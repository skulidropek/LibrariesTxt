[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[GuidAttribute("EDF3A293-A10D-4F4A-A609-38D5EDE35F89")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.DiaSymReader.TraceLog.IMetadataImportProvider {
    public abstract virtual object GetMetadataImport();
}
[GuidAttribute("969708D2-05E5-4861-A3B0-96E473CDF63F")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.DiaSymReader.TraceLog.ISymUnmanagedDispose {
    public abstract virtual int Destroy();
}
[ComVisibleAttribute("False")]
[GuidAttribute("40DE4037-7C81-3E1E-B022-AE1ABFF2CA08")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.DiaSymReader.TraceLog.ISymUnmanagedDocument {
    public abstract virtual int GetUrl(int bufferLength, Int32& count, Char[] url);
    public abstract virtual int GetDocumentType(Guid& documentType);
    public abstract virtual int GetLanguage(Guid& language);
    public abstract virtual int GetLanguageVendor(Guid& vendor);
    public abstract virtual int GetChecksumAlgorithmId(Guid& algorithm);
    public abstract virtual int GetChecksum(int bufferLength, Int32& count, Byte[] checksum);
    public abstract virtual int FindClosestLine(int line, Int32& closestLine);
    public abstract virtual int HasEmbeddedSource(Boolean& value);
    public abstract virtual int GetSourceLength(Int32& length);
    public abstract virtual int GetSourceRange(int startLine, int startColumn, int endLine, int endColumn, int bufferLength, Int32& count, Byte[] source);
}
[GuidAttribute("B62B923C-B500-3158-A543-24F307A8B7E1")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.DiaSymReader.TraceLog.ISymUnmanagedMethod {
    public abstract virtual int GetToken(Int32& methodToken);
    public abstract virtual int GetSequencePointCount(Int32& count);
    public abstract virtual int GetRootScope(ISymUnmanagedScope& scope);
    public abstract virtual int GetScopeFromOffset(int offset, ISymUnmanagedScope& scope);
    public abstract virtual int GetOffset(ISymUnmanagedDocument document, int line, int column, Int32& offset);
    public abstract virtual int GetRanges(ISymUnmanagedDocument document, int line, int column, int bufferLength, Int32& count, Int32[] ranges);
    public abstract virtual int GetParameters(int bufferLength, Int32& count, ISymUnmanagedVariable[] parameters);
    public abstract virtual int GetNamespace(ISymUnmanagedNamespace& namespace);
    public abstract virtual int GetSourceStartEnd(ISymUnmanagedDocument[] documents, Int32[] lines, Int32[] columns, Boolean& defined);
    public abstract virtual int GetSequencePoints(int bufferLength, Int32& count, Int32[] offsets, ISymUnmanagedDocument[] documents, Int32[] startLines, Int32[] startColumns, Int32[] endLines, Int32[] endColumns);
}
[GuidAttribute("0DFF7289-54F8-11d3-BD28-0000F80849BD")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.DiaSymReader.TraceLog.ISymUnmanagedNamespace {
    public abstract virtual int GetName(int bufferLength, Int32& count, Char[] name);
    public abstract virtual int GetNamespaces(int bufferLength, Int32& count, ISymUnmanagedNamespace[] namespaces);
    public abstract virtual int GetVariables(int bufferLength, Int32& count, ISymUnmanagedVariable[] variables);
}
[GuidAttribute("B4CE6286-2A6B-3712-A3B7-1EE1DAD467B5")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.DiaSymReader.TraceLog.ISymUnmanagedReader {
    public abstract virtual int GetDocument(string url, Guid language, Guid languageVendor, Guid documentType, ISymUnmanagedDocument& document);
    public abstract virtual int GetDocuments(int bufferLength, Int32& count, ISymUnmanagedDocument[] documents);
    public abstract virtual int GetUserEntryPoint(Int32& methodToken);
    public abstract virtual int GetMethod(int methodToken, ISymUnmanagedMethod& method);
    public abstract virtual int GetMethodByVersion(int methodToken, int version, ISymUnmanagedMethod& method);
    public abstract virtual int GetVariables(int methodToken, int bufferLength, Int32& count, ISymUnmanagedVariable[] variables);
    public abstract virtual int GetGlobalVariables(int bufferLength, Int32& count, ISymUnmanagedVariable[] variables);
    public abstract virtual int GetMethodFromDocumentPosition(ISymUnmanagedDocument document, int line, int column, ISymUnmanagedMethod& method);
    public abstract virtual int GetSymAttribute(int methodToken, string name, int bufferLength, Int32& count, Byte[] customDebugInformation);
    public abstract virtual int GetNamespaces(int bufferLength, Int32& count, ISymUnmanagedNamespace[] namespaces);
    public abstract virtual int Initialize(object metadataImporter, string fileName, string searchPath, IStream stream);
    public abstract virtual int UpdateSymbolStore(string fileName, IStream stream);
    public abstract virtual int ReplaceSymbolStore(string fileName, IStream stream);
    public abstract virtual int GetSymbolStoreFileName(int bufferLength, Int32& count, Char[] name);
    public abstract virtual int GetMethodsFromDocumentPosition(ISymUnmanagedDocument document, int line, int column, int bufferLength, Int32& count, ISymUnmanagedMethod[] methods);
    public abstract virtual int GetDocumentVersion(ISymUnmanagedDocument document, Int32& version, Boolean& isCurrent);
    public abstract virtual int GetMethodVersion(ISymUnmanagedMethod method, Int32& version);
}
[GuidAttribute("A09E53B2-2A57-4cca-8F63-B84F7C35D4AA")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.DiaSymReader.TraceLog.ISymUnmanagedReader2 {
    public abstract virtual int GetDocument(string url, Guid language, Guid languageVendor, Guid documentType, ISymUnmanagedDocument& document);
    public abstract virtual int GetDocuments(int bufferLength, Int32& count, ISymUnmanagedDocument[] documents);
    public abstract virtual int GetUserEntryPoint(Int32& methodToken);
    public abstract virtual int GetMethod(int methodToken, ISymUnmanagedMethod& method);
    public abstract virtual int GetMethodByVersion(int methodToken, int version, ISymUnmanagedMethod& method);
    public abstract virtual int GetVariables(int methodToken, int bufferLength, Int32& count, ISymUnmanagedVariable[] variables);
    public abstract virtual int GetGlobalVariables(int bufferLength, Int32& count, ISymUnmanagedVariable[] variables);
    public abstract virtual int GetMethodFromDocumentPosition(ISymUnmanagedDocument document, int line, int column, ISymUnmanagedMethod& method);
    public abstract virtual int GetSymAttribute(int methodToken, string name, int bufferLength, Int32& count, Byte[] customDebugInformation);
    public abstract virtual int GetNamespaces(int bufferLength, Int32& count, ISymUnmanagedNamespace[] namespaces);
    public abstract virtual int Initialize(object metadataImporter, string fileName, string searchPath, IStream stream);
    public abstract virtual int UpdateSymbolStore(string fileName, IStream stream);
    public abstract virtual int ReplaceSymbolStore(string fileName, IStream stream);
    public abstract virtual int GetSymbolStoreFileName(int bufferLength, Int32& count, Char[] name);
    public abstract virtual int GetMethodsFromDocumentPosition(ISymUnmanagedDocument document, int line, int column, int bufferLength, Int32& count, ISymUnmanagedMethod[] methods);
    public abstract virtual int GetDocumentVersion(ISymUnmanagedDocument document, Int32& version, Boolean& isCurrent);
    public abstract virtual int GetMethodVersion(ISymUnmanagedMethod method, Int32& version);
    public abstract virtual int GetMethodByVersionPreRemap(int methodToken, int version, ISymUnmanagedMethod& method);
    public abstract virtual int GetSymAttributePreRemap(int methodToken, string name, int bufferLength, Int32& count, Byte[] customDebugInformation);
    public abstract virtual int GetMethodsInDocument(ISymUnmanagedDocument document, int bufferLength, Int32& count, ISymUnmanagedMethod[] methods);
}
[GuidAttribute("68005D0F-B8E0-3B01-84D5-A11A94154942")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.DiaSymReader.TraceLog.ISymUnmanagedScope {
    public abstract virtual int GetMethod(ISymUnmanagedMethod& method);
    public abstract virtual int GetParent(ISymUnmanagedScope& scope);
    public abstract virtual int GetChildren(int bufferLength, Int32& count, ISymUnmanagedScope[] children);
    public abstract virtual int GetStartOffset(Int32& offset);
    public abstract virtual int GetEndOffset(Int32& offset);
    public abstract virtual int GetLocalCount(Int32& count);
    public abstract virtual int GetLocals(int bufferLength, Int32& count, ISymUnmanagedVariable[] locals);
    public abstract virtual int GetNamespaces(int bufferLength, Int32& count, ISymUnmanagedNamespace[] namespaces);
}
[GuidAttribute("997DD0CC-A76F-4c82-8D79-EA87559D27AD")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.DiaSymReader.TraceLog.ISymUnmanagedSourceServerModule {
    public abstract virtual int GetSourceServerData(Int32& length, Byte*& data);
}
[GuidAttribute("9F60EEBE-2D9A-3F7C-BF58-80BC991C60BB")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.DiaSymReader.TraceLog.ISymUnmanagedVariable {
    public abstract virtual int GetName(int bufferLength, Int32& count, Char[] name);
    public abstract virtual int GetAttributes(Int32& attributes);
    public abstract virtual int GetSignature(int bufferLength, Int32& count, Byte[] signature);
    public abstract virtual int GetAddressKind(Int32& kind);
    public abstract virtual int GetAddressField1(Int32& value);
    public abstract virtual int GetAddressField2(Int32& value);
    public abstract virtual int GetAddressField3(Int32& value);
    public abstract virtual int GetStartOffset(Int32& offset);
    public abstract virtual int GetEndOffset(Int32& offset);
}
internal class Microsoft.HistoricalDebuggerHost.PDQProxy : MarshalByRefObject {
    private IProgrammableDataQuery PDQ;
    private IProgrammableDataQuery2 PDQ2;
    private IProgrammableDataQuery3 PDQ3;
    public PDQProxy(IProgrammableDataQuery pdq);
    public virtual string ToString();
    public void SetGlobalData(IProgrammableDataQueryGlobalData data);
    public virtual object InitializeLifetimeService();
    public sealed virtual string FormatName(Object[] results, IProgrammableDataQueryEventData data);
    public sealed virtual string FormatPreview(Object[] results, IProgrammableDataQueryEventData data);
    public sealed virtual List`1<CollectedValueTuple> FormatCollectedValues(Object[] results, IProgrammableDataQueryEventData data);
    public sealed virtual string FormatLongDescription(Object[] results, IProgrammableDataQueryEventData data);
    public sealed virtual string FormatShortDescription(Object[] results, IProgrammableDataQueryEventData data);
    public sealed virtual List`1<Location> GetAlternateLocations(Object[] results);
    public sealed virtual Object[] ExitQuery2(object returnValue, object thisArg, Object[] args);
    public sealed virtual Object[] EntryQuery(object thisArg, Object[] args);
    public sealed virtual Object[] ExitQuery(object returnValue);
    public sealed virtual List`1<CollectedValueTuple> FormatCollectedValues(Object[] results);
    public sealed virtual string FormatLongDescription(Object[] results);
    public sealed virtual string FormatShortDescription(Object[] results);
}
internal class Microsoft.HistoricalDebuggerHost.ProgrammableDataQueryCache : object {
    private object _lock;
    private Dictionary`2<QualifiedProgrammableDataQuerySpec, ObjectHandle> _handleCache;
    private Dictionary`2<QualifiedProgrammableDataQuerySpec, PDQProxy> _proxyCache;
    public ObjectHandle GetOrCreateProxy(QualifiedProgrammableDataQuerySpec spec, IProgrammableDataQueryGlobalData globalData);
}
public class Microsoft.HistoricalDebuggerHost.ProgrammableDataQueryResultReader : MarshalByRefObject {
    private Dictionary`2<string, object> _globalData;
    private ProgrammableDataQueryCache _dqCache;
    public static string FailedQuery { get; }
    public virtual object InitializeLifetimeService();
    public static string get_FailedQuery();
    public ObjectHandle GetHandleForSpec(string module, string type, string moduleDirectory);
    public void SetGlobalData(string key, object value);
    public sealed virtual bool TryGetGlobalValue(string key, T& value);
    private TResult Format(ObjectHandle dataQueryHandle, Object[] results, Func`2<IProgrammableDataQuery3, TResult> formatter, string formatterName, TResult resultError, Func`2<Exception, TResult> exceptionHandler);
    public string FormatShortDescription(ObjectHandle dataQueryHandle, Object[] results, IProgrammableDataQueryEventData data, string eventCategoryName);
    public string FormatLongDescription(ObjectHandle dataQueryHandle, Object[] results, IProgrammableDataQueryEventData data);
    public List`1<CollectedValueTuple> FormatCollectedValues(ObjectHandle dataQueryHandle, Object[] results, IProgrammableDataQueryEventData data);
    public List`1<Location> GetAlternateLocations(ObjectHandle dataQueryHandle, Object[] results);
    public string FormatName(ObjectHandle dataQueryHandle, Object[] results, IProgrammableDataQueryEventData data);
    public string FormatPreview(ObjectHandle dataQueryHandle, Object[] results, IProgrammableDataQueryEventData data);
}
internal class Microsoft.IntelliTrace.Internal.CommonResources : object {
    internal static ResourceManager ResourceManager;
    public static string InvalidFileFormat { get; }
    public static string WaitingForProcessExit { get; }
    public static string UnsupportedImageType { get; }
    public static string CorruptImage { get; }
    public static string TruncationSuffix { get; }
    private static CommonResources();
    public static string get_InvalidFileFormat();
    public static string get_WaitingForProcessExit();
    public static string get_UnsupportedImageType();
    public static string get_CorruptImage();
    public static string get_TruncationSuffix();
    public static string DeserializationOfTypeFromAssemblyIsNotAllowed(object param0);
    public static string DeserializationOfTypeFromAssemblyIsNotAllowedDifferingPublicKeyTokens(object param0);
}
internal class Microsoft.IntelliTrace.Internal.ImageHelper : object {
    private IntPtr m_baseAddress;
    private long m_lengthBytes;
    private UInt32 m_idx;
    private UInt32 m_idxSectionStart;
    private UInt32 m_numSections;
    private UInt32 m_clrHeaderRva;
    [CompilerGeneratedAttribute]
private ImageType <ImageType>k__BackingField;
    public ImageType ImageType { get; }
    public bool ContainsClrHeader { get; }
    internal static bool Is64BitSystem { get; }
    public ImageHelper(IntPtr baseAddress, long lengthBytes);
    [CompilerGeneratedAttribute]
public ImageType get_ImageType();
    public bool get_ContainsClrHeader();
    public IntPtr GetResourcesSectionStart();
    public bool Is32BitRequired();
    public bool Is32BitPreferred();
    public bool Loads64Bit();
    internal static bool get_Is64BitSystem();
    internal IMAGE_COR20_HEADER GetCor20Header();
    internal int GetFrameworkMajorVersion();
    public IntPtr ResolveRva(long rva);
    internal T MarshalAt(UInt32 offset);
    public Byte[] GetBytesAtRva(UInt32 rva, UInt32 size);
}
internal enum Microsoft.IntelliTrace.Internal.ImageType : Enum {
    public ushort value__;
    public static ImageType Pe32bit;
    public static ImageType Pe64bit;
}
internal static class Microsoft.IntelliTrace.Internal.IntelliTraceEnvironmentVariables : object {
    public static string ENABLE_PROFILING;
    public static string PROFILER;
    public static string PROFILER_PATH;
    public static string INTELLITRACE_PROFILER_DIRECTORY;
    public static string REMOTE_LOG;
    public static string PROFILER_NOT_CLEAR_ENVVARS;
    public static string NO_LOGGER_NAME;
    public static string LOGGER_NAME;
    public static string COLLECTION_PLAN;
    public static string UNIQUEID;
    public static string APP_POOL_COLLECTION_PLAN_PREFIX;
    public static string APP_POOL_BUILD_INFO_PREFIX;
    public static string APP_POOL_APP_NAME_PREFIX;
    public static string ASSERT_ON_START;
    public static string ASSERT_ON_START_VALUE_PROFILER;
    public static string ASSERT_ON_START_VALUE_RUNTIME;
    public static string ASSERT_ON_START_VALUE_TRACELOG;
    public static string ASSERT_ON_START_VALUE_TRACELOG2;
    public static string GENTESTLOG;
    public static string ASSERT_PROFILER_WAIT;
    public static string ASSERT_LOGGER_WAIT;
    public static string TRACE;
    public static string INTERNAL_DEBUG;
    public static string INSTRUMENT;
    public static string INSTRUMENT_EXCLUDE;
    public static string INSTRUMENT_OPTIONS;
}
[ComVisibleAttribute("False")]
[FlagsAttribute]
public enum Microsoft.Tools.MessagePacking.CompressionOptions : Enum {
    public int value__;
    public static CompressionOptions None;
    public static CompressionOptions Headers;
    public static CompressionOptions PointerFields;
    public static CompressionOptions IntegerFields;
    public static CompressionOptions ArraysRLE;
}
[ComVisibleAttribute("False")]
internal class Microsoft.Tools.MessagePacking.FieldInfo : object {
    public int offset;
    public FieldType type;
    public int structIndex;
    public bool variableLength;
    public int sizeOrIndex;
    public FieldInfo(int offset, FieldType type, int structIndex, bool variableLength, int sizeOrIndex);
    internal void ToStream(Stream stream);
    internal static FieldInfo FromStream(Stream stream);
}
[ComVisibleAttribute("False")]
public enum Microsoft.Tools.MessagePacking.FieldType : Enum {
    public int value__;
    public static FieldType Structure;
    public static FieldType Bool;
    public static FieldType Byte;
    public static FieldType Char;
    public static FieldType Short;
    public static FieldType Int;
    public static FieldType Float;
    public static FieldType Long;
    public static FieldType Double;
}
[ComVisibleAttribute("False")]
internal interface Microsoft.Tools.MessagePacking.IMessageMemory {
    public abstract virtual IntPtr Reserve(int numBytes);
    public abstract virtual void Release(IntPtr p, int numBytes);
}
[ComVisibleAttribute("False")]
internal interface Microsoft.Tools.MessagePacking.IMessageMemory2 {
    public abstract virtual IntPtr Alloc(int numBytes);
    public abstract virtual void Free(IntPtr p);
}
[ComVisibleAttribute("False")]
internal interface Microsoft.Tools.MessagePacking.IMessagePartSink {
    public abstract virtual void BeginMessage(string name, int length, short msgID);
    public abstract virtual void BeginStructure(string name);
    public abstract virtual void ByteField(string name, Byte[] theBytes, string lengthFieldName);
    public abstract virtual void BoolField(string name, Boolean[] theBools, string lengthFieldName);
    public abstract virtual void CharField(string name, Char[] theChars, string lengthFieldName);
    public abstract virtual void ShortField(string name, Int16[] theShorts, string lengthFieldName);
    public abstract virtual void IntField(string name, Int32[] theInts, string lengthFieldName);
    public abstract virtual void FloatField(string name, Single[] theFloats, string lengthFieldName);
    public abstract virtual void LongField(string name, Int64[] theLongs, string lengthFieldName);
    public abstract virtual void DoubleField(string name, Double[] theDoubles, string lengthFieldName);
    public abstract virtual void BeginStructureField(string fieldName, string structName, int length, string lengthFieldName);
    public abstract virtual void EndStructureField(string name, int length);
    public abstract virtual void EndStructure(string name);
    public abstract virtual void EndMessage(string name);
}
[ComVisibleAttribute("False")]
[DebuggerNonUserCodeAttribute]
internal class Microsoft.Tools.MessagePacking.MessageInfo : object {
    public FieldType messageLengthType;
    public FieldType messageIDType;
    public Type enumType;
    public Int32[] msr;
    public StructureInfo[] si;
    public Guid schemaID;
    public CompressionOptions compressionOptions;
    public UInt32 extensionLevel;
    public bool unpackOnly;
    public MessageInfo(FieldType messageLengthType, FieldType messageIDType, Type enumType, Int32[] msr, StructureInfo[] si, Guid schemaID, CompressionOptions compressionOptions, UInt32 extensionLevel, bool unpackOnly);
    public Byte[] ToByteArray();
    public static MessageInfo FromByteArray(Byte[] bytes);
    public void ToStream(Stream stream);
    public static MessageInfo FromStream(Stream stream);
}
internal class Microsoft.Tools.MessagePacking.MessageMemoryByteArray : object {
    private Dictionary`2<IntPtr, GCHandle> _handles;
    public sealed virtual IntPtr Alloc(int numBytes);
    public sealed virtual void Free(IntPtr p);
    public Byte[] Release(IntPtr p);
}
[DebuggerNonUserCodeAttribute]
internal abstract class Microsoft.Tools.MessagePacking.MessagePacker : object {
    public static int BinaryProtocolVersion;
    private static int _Pointer_Size_If_Compression;
    private static Int32[] fieldTypeSize;
    public MessageInfo MsgInfo { get; }
    private static MessagePacker();
    public abstract virtual MessageInfo get_MsgInfo();
    public static int CalcHeaderLength(MessageInfo mi);
    public static int CalcCompressedHeaderLength(MessageInfo mi, int dataLen, short messageID);
    public static int CalcCompressedHeaderLength(MessageInfo mi, Stream stream);
    public static int GetMessageLength(MessageInfo mi, Byte[] msg, bool swapBytes);
    public static int GetMessageLength(MessageInfo mi, Byte* pMsg, bool swapBytes);
    public static short GetMessageID(MessageInfo mi, Byte[] msg, bool swapBytes);
    public static short GetMessageID(MessageInfo mi, Byte* pMsg, bool swapBytes);
    public static bool ReadMessageHeader(MessageInfo mi, Stream stream, bool swapBytes, Int32& length, Int16& id);
    public static int ReadMessage(MessageInfo mi, Stream stream, bool swapBytes, Byte[]& buffer);
    public static Byte[] ReadMessage(MessageInfo mi, Stream stream, bool swapBytes);
    public static Byte* PackMessage(MessageInfo mi, short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public static void WriteHeader(MessageInfo mi, int msgLen, short msgID, Byte* pMsg);
    public static void PackMessage(MessageInfo mi, short msgID, Byte* pData, IMessageMemory memory);
    public static Byte* UnpackMessage(MessageInfo mi, Byte* pMsg, bool swapBytes);
    public static Byte* UnpackMessage(MessageInfo mi, Byte* pMsg, IMessageMemory2 memory, bool swapBytes);
    private static int ReadHeader(MessageInfo mi, Byte* pMsg, bool swapBytes, Int32& messageLength, Int16& messageID);
    private static void PackHeader(MessageInfo mi, Byte* pMsg, int totalLen, short msgID);
    private static int GetMessageRootStructure(MessageInfo mi, short msgID);
    private static int CalcPackedSize(MessageInfo mi, int structIndex, Void* pStruct);
    private static int RecurCalcPackedSize(MessageInfo mi, StructureInfo si, Byte* pStruct);
    private static int Pack(MessageInfo mi, int structIndex, Byte* pStruct, Byte* pFix);
    private static int RecurPack(MessageInfo mi, StructureInfo si, Byte* pStruct, Byte* pFix, Byte* pVar, Byte* pBase);
    private static Byte* Unpack(MessageInfo mi, int structIndex, Byte* pFix, bool swapBytes);
    private static void RecurUnpack(MessageInfo mi, StructureInfo si, Byte* pStruct, Byte* pBase, bool swapBytes);
    public static void Pack1(Byte* pF, Byte* pT);
    public static void Pack1(Byte* pF, Byte* pT, int size);
    public static void Pack2(Byte* pF, Byte* pT);
    public static void Pack2(Byte* pF, Byte* pT, int size);
    public static void Pack4(Byte* pF, Byte* pT);
    public static void Pack4(Byte* pF, Byte* pT, int size);
    public static void Pack8(Byte* pF, Byte* pT);
    public static void Pack8(Byte* pF, Byte* pT, int size);
    public static int PackP4(UInt32 n, Byte* pT);
    public static void PackAddr(Byte* pB, Byte* pA, Byte* pT);
    public static void Swap(Byte* pF, Byte* pT);
    public static void Unpack1(Byte* pT);
    public static void Unpack2(Byte* pT);
    public static void Unpack4(Byte* pT);
    public static void Unpack8(Byte* pT);
    public static int UnpackP4(UInt32& n, Byte* pB);
    public static void UnpackAddr(Byte* pB, Byte* pA, bool swapBytes);
    public static int GetPackP4Size(UInt32 n);
    private static void CompressHeader(MessageInfo mi, Byte* pCompressedData, UInt32 totalLen, short msgID);
    private static int CalcCompressedSize(MessageInfo mi, int structIndex, Byte* pStruct);
    private static int RecurCalcCompressedSize(MessageInfo mi, StructureInfo si, bool includeSiSize, Byte*& pStruct);
    private static void Compress(MessageInfo mi, int structIndex, Byte* pStruct, Byte* pCompressedStruct);
    private static void RecurCompress(MessageInfo mi, StructureInfo si, Byte*& pStruct, Byte*& pCompressedStruct);
    private static Byte* Decompress(MessageInfo mi, int structIndex, Byte* pCompressedMsg, int compressedMsgLen, int compressedHeaderLen, IMessageMemory2 memory, bool swapBytes);
    private static void RecurDecompress(MessageInfo mi, StructureInfo si, bool swapBytes, Byte*& pCompressedStruct, Byte*& pStruct, Byte*& pVar, bool skipUnpack);
    private static int CalcDecompressedSize(MessageInfo mi, StructureInfo si, bool swapBytes, Byte* pCompressedStruct);
    private static int RecurCalcDecompressedSize(MessageInfo mi, StructureInfo si, bool includeSiSize, bool swapBytes, Byte*& pCompressedStruct);
    private static void CopyAndSwap(Byte*& pSrc, Byte*& pDest, FieldType ft, int count, bool swapBytes);
    private static int RecurDumpCompressedStructure(MessageInfo mi, IMessagePartSink sink, StructureInfo si, Byte* pStruct, bool swapBytes);
    public static int GetFieldTypeSize(FieldType type);
    public static void DumpMessage(MessageInfo mi, IMessagePartSink sink, Byte[] msg, bool swapBytes);
    public static void DumpMessage(MessageInfo mi, IMessagePartSink sink, Byte* pMsg, bool swapBytes);
    private static void DumpStructure(MessageInfo mi, IMessagePartSink sink, int structIndex, Void* pFix, bool swapBytes);
    private static void RecurDumpStructure(MessageInfo mi, IMessagePartSink sink, StructureInfo si, Byte* pStruct, bool swapBytes);
    private static void DumpField(MessageInfo mi, IMessagePartSink sink, string name, FieldType type, int size, int structIndex, string lengthFieldName, bool swapBytes, Byte*& pData);
    private static bool CompressingHeaders(MessageInfo mi);
    private static bool CompressingPointers(MessageInfo mi);
    private static bool CompressingUnsupported(MessageInfo mi);
    private static int UnpackInt(MessageInfo mi, bool swapBytes, Byte* pData);
    private static int LocalFixedPartSize(StructureInfo si);
    public abstract virtual void MergeMessageInfo(MessageInfo target);
    public static MessageInfo MergeMessageInfo(MessageInfo origin, MessageInfo target);
    private static StructureInfo AdjustStructInfo(StructureInfo origin_si, StructureInfo target_si);
    private static FieldInfo AdjustFieldInfo(FieldInfo origin_fi, FieldInfo target_fi);
}
internal class Microsoft.Tools.MessagePacking.MessagePackerMessageMemory : object {
    private sealed virtual override IntPtr Microsoft.Tools.MessagePacking.IMessageMemory2.Alloc(int numBytes);
    private sealed virtual override void Microsoft.Tools.MessagePacking.IMessageMemory2.Free(IntPtr pMem);
}
internal class Microsoft.Tools.MessagePacking.MessagePackerResources : object {
    internal static ResourceManager ResourceManager;
    public static string DataCorrupt { get; }
    private static MessagePackerResources();
    public static string get_DataCorrupt();
}
internal class Microsoft.Tools.MessagePacking.MsgHandle : ValueType {
    [CompilerGeneratedAttribute]
private Byte* <p>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageMemory2 <msgMem>k__BackingField;
    public Byte* p { get; private set; }
    public IMessageMemory2 msgMem { get; private set; }
    public MsgHandle(Byte* p_, IMessageMemory2 msgMem_);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte* get_p();
    [CompilerGeneratedAttribute]
private void set_p(Byte* value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IMessageMemory2 get_msgMem();
    [CompilerGeneratedAttribute]
private void set_msgMem(IMessageMemory2 value);
    public static Byte* op_Explicit(MsgHandle h);
    public static Void* op_Explicit(MsgHandle h);
    public static IntPtr op_Explicit(MsgHandle h);
    public sealed virtual void Dispose();
}
[ComVisibleAttribute("False")]
[FlagsAttribute]
internal enum Microsoft.Tools.MessagePacking.PointerSize : Enum {
    public int value__;
    public static PointerSize Size32;
    public static PointerSize Size64;
}
internal static class Microsoft.Tools.MessagePacking.StreamHelper : object {
    public static bool ReadBoolFromStream(Stream stream);
    public static void WriteBoolToStream(Stream stream, bool b);
    public static int ReadIntFromStream(Stream stream);
    public static void WriteIntToStream(Stream stream, int i);
    public static string ReadStringFromStream(Stream stream);
    public static void WriteStringToStream(Stream stream, string s);
}
[ComVisibleAttribute("False")]
[DebuggerNonUserCodeAttribute]
internal class Microsoft.Tools.MessagePacking.StructureInfo : object {
    public Type type;
    public StructureInitializer structInitializer;
    public int fixedPartSize;
    public FieldInfo[] fi;
    public StructureInfo(Type type, StructureInitializer structInitializer, int fixedPartSize, FieldInfo[] fi);
    internal void ToStream(Stream stream);
    internal static StructureInfo FromStream(Stream stream);
}
internal class Microsoft.Tools.MessagePacking.StructureInitializer : MulticastDelegate {
    public StructureInitializer(object object, IntPtr method);
    public virtual void Invoke(Void* pStruct, UInt32 extensionLevel);
    public virtual IAsyncResult BeginInvoke(Void* pStruct, UInt32 extensionLevel, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.Diagnostics.Common.BoundedDictionary`2 : object {
    private int _maxCapacity;
    private Dictionary`2<TKey, TValue> _dictionary;
    private Queue`1<TKey> _keys;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public BoundedDictionary`2(int maxCapacity);
    private void CheckForDuplicate(TKey key);
    private void Insert(TKey key, TValue value);
    public void Add(TKey key, TValue value);
    public bool ContainsKey(TKey key);
    public ICollection`1<TKey> get_Keys();
    public bool Remove(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public ICollection`1<TValue> get_Values();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.BucketParameters : ValueType {
    internal int fInited;
    internal string pszEventTypeName;
    internal string param0;
    internal string param1;
    internal string param2;
    internal string param3;
    internal string param4;
    internal string param5;
    internal string param6;
    internal string param7;
    internal string param8;
    internal string param9;
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.ClrGuids : object {
    internal static Guid ClsIdClrRuntimeHost;
    internal static Guid IIdIClrRuntimeHost;
    internal static Guid IIdIClrErrorReportingManager;
    private static ClrGuids();
}
internal class Microsoft.VisualStudio.Diagnostics.Common.CodedExceptionHelper : object {
    private ResourceManager resourceMan;
    private CultureInfo resourceCulture;
    private static Regex prefixRE;
    public CodedExceptionHelper(ResourceManager resourceMan, CultureInfo resourceCulture);
    private static CodedExceptionHelper();
    public void ThrowEx(string resource, Object[] args);
    public static void Throw(string message, Object[] args);
    public static void Throw(Exception innerException, string message, Object[] args);
    public static Exception FindCodedException(Exception ex);
    public static string ExtractMessageCode(string messageIn, String& messageOut);
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.ComHelper : object {
    private static string IUnknownGuid;
    public static Guid GetGuidFromType(Type type);
    public static string BstrToSz(string str);
    private static IntPtr LoadLibraryW(string dllToLoad);
    private static IntPtr GetProcAddress(IntPtr hModule, string procname);
    public static int CoCreateLocalInstance(string registryRoot, Guid clsid, Guid riid, Object& instance);
    internal static int CoCreateFromFile(string filenameOfServer, Guid clsidOfServer, Guid riid, IntPtr& pvObject);
}
[AttributeUsageAttribute("128")]
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandCommandLineArgumentAttribute : CommandLineArgumentAttribute {
    public CommandCommandLineArgumentAttribute(string name);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandLineArgument : object {
    private ArrayList values;
    private PropertyInfo propertyInfo;
    private MethodInfo addMethod;
    private MethodInfo getEnumeratorMethod;
    private Type valueType;
    private CommandLineArgumentAttribute attribute;
    public Type ValueType { get; }
    public string Name { get; }
    public string ShortName { get; }
    public string Description { get; }
    public string ValueHint { get; }
    public bool Hidden { get; }
    public bool Required { get; }
    public bool HasArgumentValue { get; }
    public int Count { get; }
    public bool AllowMultiple { get; }
    public bool IsCollection { get; }
    public bool IsArray { get; }
    public bool IsDefault { get; }
    public bool IsUnprocessed { get; }
    public bool IsCommand { get; }
    public CommandLineArgument(CommandLineArgumentAttribute attribute, PropertyInfo propertyInfo);
    public Type get_ValueType();
    public string get_Name();
    public string get_ShortName();
    public string get_Description();
    public string get_ValueHint();
    public bool get_Hidden();
    public bool get_Required();
    public bool get_HasArgumentValue();
    public int get_Count();
    public bool get_AllowMultiple();
    public bool get_IsCollection();
    public bool get_IsArray();
    public bool get_IsDefault();
    public bool get_IsUnprocessed();
    public bool get_IsCommand();
    public void SetTargetValue(object target);
    public void GetTargetValue(object target);
    public void SetArgumentValue(string value);
    public virtual string ToString();
    public bool IsValidCommand(string command);
    public void ClearValues();
}
[AttributeUsageAttribute("128")]
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandLineArgumentAttribute : Attribute {
    private string name;
    private string shortName;
    private string description;
    private string valueHint;
    private Type initializerType;
    private string commands;
    private Type resourceType;
    private bool hidden;
    private bool required;
    public string Name { get; internal set; }
    public string ShortName { get; public set; }
    public string Description { get; public set; }
    public string ValueHint { get; public set; }
    public Type Initializer { get; public set; }
    public string Commands { get; public set; }
    public Type ResourceReader { get; public set; }
    public bool Hidden { get; public set; }
    public bool Required { get; public set; }
    public CommandLineArgumentAttribute(string name);
    public string get_Name();
    internal void set_Name(string value);
    public string get_ShortName();
    public void set_ShortName(string value);
    public string get_Description();
    public void set_Description(string value);
    public string get_ValueHint();
    public void set_ValueHint(string value);
    public Type get_Initializer();
    public void set_Initializer(Type value);
    public string get_Commands();
    public void set_Commands(string value);
    public Type get_ResourceReader();
    public void set_ResourceReader(Type value);
    public bool get_Hidden();
    public void set_Hidden(bool value);
    public bool get_Required();
    public void set_Required(bool value);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandLineArgumentException : ArgumentException {
    public CommandLineArgumentException(string message);
    public CommandLineArgumentException(string message, Exception innerException);
    private CommandLineArgumentException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("4")]
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandLineCommandAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValueHint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnprocessedValueHint>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResourceReader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Switches>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Hidden>k__BackingField;
    public string Description { get; public set; }
    public string Command { get; private set; }
    public string DefaultValueHint { get; public set; }
    public string UnprocessedValueHint { get; public set; }
    public Type ResourceReader { get; public set; }
    public string Switches { get; public set; }
    public bool Hidden { get; public set; }
    public CommandLineCommandAttribute(string command);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
private void set_Command(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultValueHint();
    [CompilerGeneratedAttribute]
public void set_DefaultValueHint(string value);
    [CompilerGeneratedAttribute]
public string get_UnprocessedValueHint();
    [CompilerGeneratedAttribute]
public void set_UnprocessedValueHint(string value);
    [CompilerGeneratedAttribute]
public Type get_ResourceReader();
    [CompilerGeneratedAttribute]
public void set_ResourceReader(Type value);
    [CompilerGeneratedAttribute]
public string get_Switches();
    [CompilerGeneratedAttribute]
public void set_Switches(string value);
    [CompilerGeneratedAttribute]
public bool get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(bool value);
}
[AttributeUsageAttribute("4")]
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandLineConfigurationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResourceReader>k__BackingField;
    public string Configuration { get; private set; }
    public Type ResourceReader { get; public set; }
    public CommandLineConfigurationAttribute(string configuration);
    [CompilerGeneratedAttribute]
public string get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(string value);
    [CompilerGeneratedAttribute]
public Type get_ResourceReader();
    [CompilerGeneratedAttribute]
public void set_ResourceReader(Type value);
}
[AttributeUsageAttribute("4")]
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandLineCopyrightAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResourceReader>k__BackingField;
    public string Copyright { get; private set; }
    public Type ResourceReader { get; public set; }
    public CommandLineCopyrightAttribute(string copyright);
    [CompilerGeneratedAttribute]
public string get_Copyright();
    [CompilerGeneratedAttribute]
private void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public Type get_ResourceReader();
    [CompilerGeneratedAttribute]
public void set_ResourceReader(Type value);
}
[AttributeUsageAttribute("4")]
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandLineDescriptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResourceReader>k__BackingField;
    public string Description { get; private set; }
    public Type ResourceReader { get; public set; }
    public CommandLineDescriptionAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public Type get_ResourceReader();
    [CompilerGeneratedAttribute]
public void set_ResourceReader(Type value);
}
[AttributeUsageAttribute("4")]
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandLineExampleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Example>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResourceReader>k__BackingField;
    public string Example { get; private set; }
    public Type ResourceReader { get; public set; }
    public CommandLineExampleAttribute(string example);
    [CompilerGeneratedAttribute]
public string get_Example();
    [CompilerGeneratedAttribute]
private void set_Example(string value);
    [CompilerGeneratedAttribute]
public Type get_ResourceReader();
    [CompilerGeneratedAttribute]
public void set_ResourceReader(Type value);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandLineParser : object {
    private List`1<CommandLineArgument> argumentCollection;
    private CommandLineArgument defaultArgument;
    private CommandLineArgument unprocessedArgument;
    private CommandLineArgument commandArgument;
    private Type argumentSpecificationType;
    private Type resourceReaderType;
    private CommandLineParserFlags flags;
    private string copyright;
    private string configuration;
    private string version;
    private string description;
    private string taskName;
    private string commandName;
    private Stack`1<string> responseFiles;
    private static int maxResponseFileDepth;
    private Dictionary`2<string, String[]> commandSwitches;
    public string CommandName { get; public set; }
    public string TaskName { get; }
    public string ProcessName { get; }
    public int ArgumentCount { get; }
    public bool CaseSensitive { get; }
    public string Copyright { get; public set; }
    public string Configuration { get; public set; }
    public string Version { get; public set; }
    public string Description { get; public set; }
    public string Arguments { get; }
    public bool HasDefaultArgument { get; }
    public bool HasUnprocessedArgument { get; }
    public bool HasCommandArgument { get; }
    public CommandLineParser(Type argumentSpecificationType);
    public CommandLineParser(Type argumentSpecificationType, CommandLineParserFlags flags);
    public CommandLineParser(Type argumentSpecificationType, Type resourceReaderType);
    public CommandLineParser(Type argumentSpecificationType, Type resourceReaderType, CommandLineParserFlags flags);
    public string get_CommandName();
    public void set_CommandName(string value);
    public string get_TaskName();
    public string get_ProcessName();
    public int get_ArgumentCount();
    public bool get_CaseSensitive();
    public string get_Copyright();
    public void set_Copyright(string value);
    public string get_Configuration();
    public void set_Configuration(string value);
    public string get_Version();
    public void set_Version(string value);
    public string get_Description();
    public void set_Description(string value);
    public string get_Arguments();
    public bool get_HasDefaultArgument();
    public bool get_HasUnprocessedArgument();
    public bool get_HasCommandArgument();
    public void ParseAndSetTarget(String[] args, object target);
    public void Parse(IList`1<string> args);
    public void SetTarget(object target);
    public void GetTarget(object target);
    public string GetLogoBanner();
    public string GetUsage();
    public string GetUsage(string command);
    public string GetUsage(string command, bool showHidden);
    public string GetUsage(string command, int lineLength);
    public string GetUsage(string command, int lineLength, bool showHidden);
    private List`1<CommandLineArgument> GetRequiredArgs();
    private void GetSyntaxHelpLine(string command, StringBuilder helpText);
    private void GetCommandHelpLines(int lineLength, StringBuilder helpText, bool showHidden);
    private void GetSwitchesHelpLines(string command, int lineLength, StringBuilder helpText, bool showHidden);
    private void GetDescriptionHelpLines(string command, int lineLength, StringBuilder helpText);
    private void GetExampleHelpLines(int lineLength, StringBuilder helpText);
    private bool HasArguments(string command);
    private string GetDefaultArgumentValueHint(string command);
    private string GetUnprocessedArgumentValueHint(string command);
    private string ExternalGetString(string s, Type resourceReaderType);
    private bool IsValidCommand(string command);
    private bool IsValidCommand(CommandLineArgument argument, string command);
    private void EnsureCommandSwitches();
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Diagnostics.Common.CommandLineParserFlags : Enum {
    public int value__;
    public static CommandLineParserFlags CaseSensitive;
    public static CommandLineParserFlags None;
}
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandLineParserResources : object {
    internal static ResourceManager ResourceManager;
    public static string Command_Lowercase { get; }
    public static string CommandArgumentAlreadyDefined { get; }
    public static string CopyrightAttributesNotFound { get; }
    public static string DefaultArgumentAlreadyDefined { get; }
    public static string DescriptionAttributesNotFound { get; }
    public static string FileName_Lowercase { get; }
    public static string Number_Lowercase { get; }
    public static string Switches_Lowercase { get; }
    public static string Switches_Propercase { get; }
    public static string Text_LowerCase { get; }
    public static string UnprocessedArgumentAlreadyDefined { get; }
    public static string UnprocessedArgumentMustBeArrayOrCollection { get; }
    public static string UnprocessedRequiresDefaultArguments { get; }
    public static string Syntax_Propercase { get; }
    public static string Value_Lowercase { get; }
    public static string VersionAttributesNotFound { get; }
    public static string Commands_Propercase { get; }
    public static string Description_Propercase { get; }
    public static string Examples_Propercase { get; }
    public static string ResponseFilesTooDeep { get; }
    private static CommandLineParserResources();
    public static string get_Command_Lowercase();
    public static string get_CommandArgumentAlreadyDefined();
    public static string get_CopyrightAttributesNotFound();
    public static string get_DefaultArgumentAlreadyDefined();
    public static string get_DescriptionAttributesNotFound();
    public static string DuplicateCommandLineArgument(object param0);
    public static string get_FileName_Lowercase();
    public static string InvalidInitializerClassForCommandLineArgument(object param0, object param1);
    public static string InvalidValueForCommandLineArgument(object param0, object param1);
    public static string InvalidValueForCommandLineArgumentWithValid(object param0, object param1);
    public static string NoWayToInitializeTypeFromString(object param0);
    public static string get_Number_Lowercase();
    public static string get_Switches_Lowercase();
    public static string get_Switches_Propercase();
    public static string ProblemInvokingAddMethod(object param0);
    public static string PropertyDoesNotHaveAValueForDescription(object param0);
    public static string PropertyHasNoAddMethodWithNonObjectParameter(object param0);
    public static string PropertyIsNotAStronglyTypedArray(object param0);
    public static string PropertyShouldBeReadableAndWriteable(object param0);
    public static string RequiredArgument(object param0);
    public static string ResourceReaderDoesNotContainString(object param0, object param1);
    public static string ShortFormat(object param0);
    public static string get_Text_LowerCase();
    public static string TypeNotDerivedFromType(object param0, object param1);
    public static string UnableToParseValueForArgument(object param0, object param1);
    public static string UnknownArgument(object param0);
    public static string UnknownCommandArgument(object param0);
    public static string get_UnprocessedArgumentAlreadyDefined();
    public static string get_UnprocessedArgumentMustBeArrayOrCollection();
    public static string get_UnprocessedRequiresDefaultArguments();
    public static string get_Syntax_Propercase();
    public static string get_Value_Lowercase();
    public static string get_VersionAttributesNotFound();
    public static string get_Commands_Propercase();
    public static string get_Description_Propercase();
    public static string get_Examples_Propercase();
    public static string get_ResponseFilesTooDeep();
    public static string ResponseFileUnopened(object param0);
}
[AttributeUsageAttribute("4")]
internal class Microsoft.VisualStudio.Diagnostics.Common.CommandLineTitleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResourceReader>k__BackingField;
    public string Title { get; private set; }
    public Type ResourceReader { get; private set; }
    public CommandLineTitleAttribute(string title);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
private void set_Title(string value);
    [CompilerGeneratedAttribute]
public Type get_ResourceReader();
    [CompilerGeneratedAttribute]
private void set_ResourceReader(Type value);
}
[ComVisibleAttribute("True")]
public class Microsoft.VisualStudio.Diagnostics.Common.ComMarshal : object {
    private IMarshal modreq(System.Runtime.CompilerServices.IsVolatile) _stdMarshal;
    private object _aquireMarshal;
    private void GetStandardMarshal(Guid& riid, object pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags);
    private void RefreshStandardMarshal(Guid& riid, object pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags);
    private sealed virtual override int Microsoft.VisualStudio.Diagnostics.Common.IMarshal.GetUnmarshalClass(Guid riid, object pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags, Guid& pCid);
    private sealed virtual override int Microsoft.VisualStudio.Diagnostics.Common.IMarshal.GetMarshalSizeMax(Guid riid, object pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags, UInt32& pSize);
    private sealed virtual override int Microsoft.VisualStudio.Diagnostics.Common.IMarshal.MarshalInterface(IntPtr pStm, Guid riid, object pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags);
    private sealed virtual override int Microsoft.VisualStudio.Diagnostics.Common.IMarshal.UnmarshalInterface(IntPtr pStm, Guid riid, Object& pv);
    private sealed virtual override int Microsoft.VisualStudio.Diagnostics.Common.IMarshal.ReleaseMarshalData(IntPtr pStm);
    private sealed virtual override int Microsoft.VisualStudio.Diagnostics.Common.IMarshal.DisconnectObject(UInt32 dwReserved);
    private static int CoGetStandardMarshal(Guid& riid, object pUnk, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags, IMarshal& ppMarshal);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.COR_DEBUG_IL_TO_NATIVE_MAP : ValueType {
    public UInt32 ilOffset;
    public UInt32 nativeStartOffset;
    public UInt32 nativeEndOffset;
}
[AttributeUsageAttribute("128")]
internal class Microsoft.VisualStudio.Diagnostics.Common.DefaultCommandLineArgumentAttribute : CommandLineArgumentAttribute {
    public DefaultCommandLineArgumentAttribute(string name);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.Disposer : object {
    private List`1<IDisposable> _objs;
    private bool _disposed;
    public void Add(IDisposable obj);
    public void Add(Action act);
    public sealed virtual void Dispose();
    protected void ThrowIfDisposed();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.EnumerableUtility : object {
    public static bool SequenceEqual(IEnumerable`1<T> array1, IEnumerable`1<T> array2);
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.ExceptionHelper : object {
    public static int Invoke(Func`1<int> target, bool reportWatson);
    private static bool FilterPredicate(Exception ex, bool reportWatson);
    private static void CatchBlock(Exception ex);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.ExceptionWrapper : Exception {
    private static string NestedExceptionSerializeName;
    private ReadOnlyCollection`1<Exception> _nestedExceptions;
    public ReadOnlyCollection`1<Exception> NestedExceptions { get; }
    public ExceptionWrapper(string message);
    public ExceptionWrapper(string message, Exception innerException);
    public ExceptionWrapper(string message, IList`1<Exception> innerExceptions);
    protected ExceptionWrapper(SerializationInfo info, StreamingContext context);
    public ReadOnlyCollection`1<Exception> get_NestedExceptions();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("9065597E-D1A1-4fb2-B6BA-7E1FCE230F61")]
internal interface Microsoft.VisualStudio.Diagnostics.Common.IClrControl {
    public abstract virtual object GetCLRManager(Guid& riid);
    public abstract virtual void SetAppDomainManagerType(string pwzAppDomainManagerAssembly, string pwzAppDomainManagerType);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("980D2F1A-BF79-4c08-812A-BB9778928F78")]
internal interface Microsoft.VisualStudio.Diagnostics.Common.IClrErrorReportingManager {
    public abstract virtual int GetBucketParametersForCurrentException(BucketParameters& pParams);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("90F1A06C-7712-4762-86B5-7A5EBA6BDB02")]
internal interface Microsoft.VisualStudio.Diagnostics.Common.IClrRuntimeHost {
    public abstract virtual void Start();
    public abstract virtual void Stop();
    public abstract virtual void SetHostControl(IntPtr pHostControl);
    public abstract virtual IClrControl GetCLRControl();
    public abstract virtual void UnloadAppDomain(int dwAppDomainId, bool fWaitUntilDone);
    public abstract virtual void ExecuteInAppDomain(int dwAppDomainId, IntPtr pCallback, IntPtr cookie);
    public abstract virtual int GetCurrentAppDomainId();
    public abstract virtual int ExecuteApplication(string pwzAppFullName, int dwManifestPaths, String[] ppwzManifestPaths, int dwActivationData, String[] ppwzActivationData);
    public abstract virtual int ExecuteInDefaultAppDomain(string pwzAssemblyPath, string pwzTypeName, string pwzMethodName, string pwzArgument);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000003-0000-0000-C000-000000000046")]
internal interface Microsoft.VisualStudio.Diagnostics.Common.IMarshal {
    public abstract virtual int GetUnmarshalClass(Guid riid, object pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags, Guid& pCid);
    public abstract virtual int GetMarshalSizeMax(Guid riid, object pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags, UInt32& pSize);
    public abstract virtual int MarshalInterface(IntPtr pStm, Guid riid, object pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags);
    public abstract virtual int UnmarshalInterface(IntPtr pStm, Guid riid, Object& pv);
    public abstract virtual int ReleaseMarshalData(IntPtr pStm);
    public abstract virtual int DisconnectObject(UInt32 dwReserved);
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.MessageUtility : object {
    [ThreadStaticAttribute]
private static BinaryFormatter _formatter;
    private static BinaryFormatter Formatter { get; }
    private static BinaryFormatter get_Formatter();
    public static Byte[] SerializeObject(object o);
    public static object DeserializeObject(Byte[] value);
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.NativeMethods : object {
    internal static int WER_P0;
    internal static int WER_P1;
    internal static int WER_P2;
    internal static int WER_P3;
    internal static int WER_P4;
    internal static int WER_P5;
    internal static int WER_P6;
    internal static int WER_P7;
    internal static int WER_P8;
    internal static int WER_SUBMIT_QUEUE;
    internal static string watsonEventId;
    internal static int WerReportCreate(string pwzEventType, WER_REPORT_TYPE repType, IntPtr pReportInformation, IntPtr& phReportHandle);
    internal static int WerReportCloseHandle(IntPtr phReportHandle);
    internal static int WerReportSetParameter(IntPtr hReportHandle, int dwparamID, string pwzName, string pwzValue);
    internal static int WerReportAddDump(IntPtr hReportHandle, IntPtr hProcess, IntPtr hThread, WER_DUMP_TYPE dumpType, IntPtr pExceptionParam, IntPtr pDumpCustomOptions, int dwFlags);
    internal static int WerReportSubmit(IntPtr hReportHandle, WER_CONSENT consent, int dwFlags, IntPtr& pSubmitResult);
    public static void GetSystemInfo(SYSTEM_INFO& SystemInfo);
    public static bool ProcessIdToSessionId(UInt32 dwProcessId, UInt32& pSessionId);
    public static UInt32 GetCurrentProcessId();
}
internal abstract class Microsoft.VisualStudio.Diagnostics.Common.NullComparer : object {
    public static bool NotNullCheck(object first, object second);
    public static bool NullEqualityCheck(object first, object second);
    public static int NullCompareCheck(IComparable first, IComparable second);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.ParsedPath : object {
    private string machine;
    private string share;
    private string drive;
    private string dir;
    private string fname;
    private string ext;
    private static Char[] BadDirTrailChars;
    private static Char[] WildcardChars;
    public static ParsedPath Empty;
    private static Regex surroundingQuotesSingleLineRegex;
    private static Regex relativePathPartSingleLineRegex;
    public static Regex SurroundingQuotesSingleLineRegex { get; }
    public static Regex RelativePathPartSingleLineRegex { get; }
    public bool HasUncRoot { get; }
    public bool HasDriveRoot { get; }
    public bool HasDirectory { get; }
    public bool HasFilename { get; }
    public bool HasExtension { get; }
    public bool HasWildcards { get; }
    public bool HasRoot { get; }
    public bool IsRootDirectory { get; }
    public bool IsRootOnly { get; }
    public bool IsDirectory { get; }
    public bool IsDirectoryOnly { get; }
    public bool IsFilename { get; }
    public bool IsFilenameOnly { get; }
    public bool IsRelative { get; }
    public bool IsFull { get; }
    public int DirectoryDepth { get; }
    public String[] SubDirectories { get; }
    public string Machine { get; }
    public string Share { get; }
    public string Drive { get; }
    public string MachineAndShare { get; }
    public string Root { get; }
    public string Directory { get; }
    public string DirectoryLastFolderNoSeparator { get; }
    public string DirectoryNoSeparator { get; }
    public string File { get; }
    public string Extension { get; }
    public string RootAndDirectory { get; }
    public string RootAndDirectoryNoSeparator { get; }
    public string DirectoryAndFile { get; }
    public string FileAndExtension { get; }
    public string RootDirectoryAndFile { get; }
    public string DirectoryFileAndExtension { get; }
    public string All { get; }
    public ParsedPath(string path);
    public ParsedPath(string path, PathType typeHint);
    private static ParsedPath();
    public static Regex get_SurroundingQuotesSingleLineRegex();
    public static Regex get_RelativePathPartSingleLineRegex();
    public ParsedPath Parse(string value);
    public ParsedPath Combine(string path);
    public ParsedPath Combine(string path, PathType pathType);
    public ParsedPath MakeFullPath();
    public ParsedPath MakeFullPath(ParsedPath basePath);
    private ParsedPath GetDefaultBasePath();
    public ParsedPath MakeRelativePath(ParsedPath basePath);
    public ParsedPath MakeParentPath();
    public ParsedPath MakeParentPath(int depthChange);
    public ParsedPath MakeParentPath(ParsedPath basePath);
    public ParsedPath MakeParentPath(int depthChange, ParsedPath basePath);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool Equals(ParsedPath pp1, ParsedPath pp2);
    public virtual int GetHashCode();
    public static int Compare(ParsedPath a, ParsedPath b, bool ignoreCase);
    public static int Compare(ParsedPath a, ParsedPath b);
    public sealed virtual int CompareTo(object obj);
    public static string op_Implicit(ParsedPath pp);
    public static bool op_Equality(ParsedPath pp1, ParsedPath pp2);
    public static bool op_Inequality(ParsedPath pp1, ParsedPath pp2);
    public bool get_HasUncRoot();
    public bool get_HasDriveRoot();
    public bool get_HasDirectory();
    public bool get_HasFilename();
    public bool get_HasExtension();
    public bool get_HasWildcards();
    public bool get_HasRoot();
    public bool get_IsRootDirectory();
    public bool get_IsRootOnly();
    public bool get_IsDirectory();
    public bool get_IsDirectoryOnly();
    public bool get_IsFilename();
    public bool get_IsFilenameOnly();
    public bool get_IsRelative();
    public bool get_IsFull();
    public int get_DirectoryDepth();
    public String[] get_SubDirectories();
    public string get_Machine();
    public string get_Share();
    public string get_Drive();
    public string get_MachineAndShare();
    public string get_Root();
    public string get_Directory();
    public string get_DirectoryLastFolderNoSeparator();
    public string get_DirectoryNoSeparator();
    public string get_File();
    public string get_Extension();
    public string get_RootAndDirectory();
    public string get_RootAndDirectoryNoSeparator();
    public string get_DirectoryAndFile();
    public string get_FileAndExtension();
    public string get_RootDirectoryAndFile();
    public string get_DirectoryFileAndExtension();
    public string get_All();
}
internal enum Microsoft.VisualStudio.Diagnostics.Common.PathType : Enum {
    public int value__;
    public static PathType File;
    public static PathType Directory;
    public static PathType RootOnly;
    public static PathType Automatic;
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.PathUtility : object {
    public static string UncPrefixChars;
    public static char ExtensionSeparatorChar;
    private static PathUtility();
    public static String[] FindFileInPaths(String[] paths, string file);
    public static string Combine(string arg0, string arg1, string arg2);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.PipeServer : object {
    private string _name;
    private PipeSecurity _pipeSecurity;
    private List`1<PipeServerStream> _pipes;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private PipeServerStreamCallback`1<Exception> <ErrorHandler>k__BackingField;
    internal PipeServerStreamCallback`1<Exception> ErrorHandler { get; private set; }
    public PipeServer(string name);
    public PipeServer(string name, PipeServerStreamCallback`1<Exception> errorHandler);
    public void WaitForConnection(PipeServerStreamCallback callback);
    public sealed virtual void Dispose();
    internal void OnPipeDisposed(PipeServerStream pipe);
    [CompilerGeneratedAttribute]
internal PipeServerStreamCallback`1<Exception> get_ErrorHandler();
    [CompilerGeneratedAttribute]
private void set_ErrorHandler(PipeServerStreamCallback`1<Exception> value);
    private static void DefaultErrorHandler(PipeServerStream pipe, Exception ex);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.PipeServerStream : object {
    private NamedPipeServerStream _pipe;
    private PipeServer _server;
    internal PipeServerStream(PipeServer server, NamedPipeServerStream pipe);
    internal void WaitForConnection(PipeServerStreamCallback callback, PipeServerStreamCallback`1<Exception> errorHandler);
    internal void WaitForConnection(PipeServerStreamCallback callback);
    public void ReceiveMessage(PipeServerStreamCallback`1<Byte[]> callback, PipeServerStreamCallback`1<Exception> errorHandler);
    public void ReceiveMessage(PipeServerStreamCallback`1<Byte[]> callback);
    public void SendMessage(Byte[] message, PipeServerStreamCallback callback, PipeServerStreamCallback`1<Exception> errorHandler);
    public void SendMessage(Byte[] message, PipeServerStreamCallback callback);
    public void WaitForPipeDrain();
    public void Disconnect();
    public sealed virtual void Dispose();
    public string GetClientUserName();
    public Nullable`1<int> GetClientProcessId();
    private static bool GetNamedPipeClientProcessId(SafePipeHandle h, Int32& ClientProcessId);
    private static bool GetNamedPipeClientSessionId(SafePipeHandle h, Int32& ClientSessionId);
    private static bool PeekNamedPipe(SafePipeHandle h, IntPtr buffer, UInt32 bufferSize, IntPtr bytesRead, IntPtr bytesAvail, UInt32& bytesLeftThisMessage);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.PipeServerStreamCallback : MulticastDelegate {
    public PipeServerStreamCallback(object object, IntPtr method);
    public virtual void Invoke(PipeServerStream pipe);
    public virtual IAsyncResult BeginInvoke(PipeServerStream pipe, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.PipeServerStreamCallback`1 : MulticastDelegate {
    public PipeServerStreamCallback`1(object object, IntPtr method);
    public virtual void Invoke(PipeServerStream pipe, T t);
    public virtual IAsyncResult BeginInvoke(PipeServerStream pipe, T t, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum Microsoft.VisualStudio.Diagnostics.Common.PROCESSOR_ARCHITECTURE : Enum {
    public ushort value__;
    public static PROCESSOR_ARCHITECTURE PROCESSOR_ARCHITECTURE_AMD64;
    public static PROCESSOR_ARCHITECTURE PROCESSOR_ARCHITECTURE_IA64;
    public static PROCESSOR_ARCHITECTURE PROCESSOR_ARCHITECTURE_INTEL;
    public static PROCESSOR_ARCHITECTURE PROCESSOR_ARCHITECTURE_ARM64;
    public static PROCESSOR_ARCHITECTURE PROCESSOR_ARCHITECTURE_UNKNOWN;
}
internal class Microsoft.VisualStudio.Diagnostics.Common.ProcessWaitHandle : WaitHandle {
    [CompilerGeneratedAttribute]
private int <Pid>k__BackingField;
    public int Pid { get; private set; }
    public ProcessWaitHandle(Process process);
    public ProcessWaitHandle(int pid);
    public ProcessWaitHandle(int pid, long creationFileTime);
    [CompilerGeneratedAttribute]
public int get_Pid();
    [CompilerGeneratedAttribute]
private void set_Pid(int value);
    private void Construct(UInt32 pid, long creationFileTime);
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.StringUtility : object {
    public static string ConvertEmptyToNull(string value);
    public static string ConvertNullToEmpty(string value);
    public static string Join(string separator, List`1<string> value);
    public static String[] WordWrap(string text, int lineLength);
    public static string IFormat(string format, Object[] args);
    public static string CFormat(string format, Object[] args);
    public static string ReplaceTags(string source, string tagPrefix, string tagSuffix, IDictionary dict);
    public static string ReplaceTags(string source, string tagPrefix, string tagSuffix, IDictionary dict, TaggedStringOptions flags);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.SYSTEM_INFO : ValueType {
    public PROCESSOR_ARCHITECTURE wProcessorArchitecture;
    public ushort wReserved;
    public UInt32 dwPageSize;
    public IntPtr lpMinimumApplicationAddress;
    public IntPtr lpMaximumApplicationAddress;
    public IntPtr dwActiveProcessorMask;
    public UInt32 dwNumberOfProcessors;
    public UInt32 dwProcessorType;
    public UInt32 dwAllocationGranularity;
    public ushort wProcessorLevel;
    public ushort wProcessorRevision;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Diagnostics.Common.TaggedStringOptions : Enum {
    public int value__;
    public static TaggedStringOptions Default;
    public static TaggedStringOptions CaseSensitive;
    public static TaggedStringOptions RemoveUnknownTags;
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.TraceUtility : object {
    private static string ProductMajorDotMinor;
    private static string LogPath;
    private static string UserDefaultLogPathSuffix;
    private static string SettingsPathSuffix;
    private static TraceUtility();
    public static string GetLogFileDirectory();
    public static string GetUserDefaultLogFileDirectory();
    public static string GetSettingsDirectory(bool fGlobal);
    private static void EnsureDirectoryExists(string dir);
    private static void EnsureDirectoryReadable(string dir);
    public static string BuildCollectionPlanPath(string pathToExe, bool fGlobal);
    public static string MergeEnvironment(string originalEnv, ICollection`1<KeyValuePair`2<string, string>> varsToMerge, bool inheritByDefault);
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.Tuple : object {
    public static Tuple`2<T1, T2> Make(T1 first, T2 second);
    public static Tuple`3<T1, T2, T3> Make(T1 first, T2 second, T3 third);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.Tuple`2 : object {
    public T1 first;
    public T2 second;
    public Tuple`2(T1 first, T2 second);
    private sealed virtual override bool System.IEquatable<Microsoft.VisualStudio.Diagnostics.Common.Tuple<T1,T2>>.Equals(Tuple`2<T1, T2> other);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.Tuple`3 : object {
    public T1 first;
    public T2 second;
    public T3 third;
    public Tuple`3(T1 first, T2 second, T3 third);
    private sealed virtual override bool System.IEquatable<Microsoft.VisualStudio.Diagnostics.Common.Tuple<T1,T2,T3>>.Equals(Tuple`3<T1, T2, T3> other);
}
[AttributeUsageAttribute("128")]
internal class Microsoft.VisualStudio.Diagnostics.Common.UnprocessedCommandLineArgumentAttribute : CommandLineArgumentAttribute {
    public UnprocessedCommandLineArgumentAttribute(string name);
}
internal class Microsoft.VisualStudio.Diagnostics.Common.VolatileSettingsStore : object {
    private Dictionary`2<string, FileStream> _openStreams;
    private SettingsScope _scope;
    protected VolatileSettingsStore(SettingsScope scope);
    public static VolatileSettingsStore Create(SettingsScope scope);
    public string AddObject(_CollectionPlan config);
    public _CollectionPlan GetObject(string moniker);
    public void Add(string key, string value);
    public bool TryAdd(string key, string value);
    private void AddImpl(string fileName, string key, string value);
    public void Remove(string key);
    public bool TryGetValue(string key, String& value);
    private bool TryGetValue(SettingsScope scope, string key, String& value);
    public Dictionary`2<string, string> EnumValues(string keyPattern);
    private Dictionary`2<string, string> EnumValues(SettingsScope scope, string keyPattern);
    private DirectoryInfo TryGetStoreDirectory(SettingsScope scope);
    private DirectoryInfo GetStoreDirectory();
    private string GetNewTempFile();
    private bool EnsureStoreDoesNotHaveStaleFile(string fileName);
    public sealed virtual void Dispose();
    private void EnsureRealScope(SettingsScope scope);
    private void EnsureRealScope();
    public bool Exists(string key);
    public static _CollectionPlan LoadCollectionPlan(string CollectionPlanPath, OutputHelper outputter);
}
internal enum Microsoft.VisualStudio.Diagnostics.Common.WER_CONSENT : Enum {
    public int value__;
    public static WER_CONSENT WerConsentNotAsked;
    public static WER_CONSENT WerConsentApproved;
    public static WER_CONSENT WerConsentDenied;
    public static WER_CONSENT WerConsentAlwaysPrompt;
    public static WER_CONSENT WerConsentMax;
}
internal enum Microsoft.VisualStudio.Diagnostics.Common.WER_DUMP_TYPE : Enum {
    public int value__;
    public static WER_DUMP_TYPE WerDumpTypeMicroDump;
    public static WER_DUMP_TYPE WerDumpTypeMiniDump;
    public static WER_DUMP_TYPE WerDumpTypeHeapDump;
    public static WER_DUMP_TYPE WerDumpTypeMax;
}
internal enum Microsoft.VisualStudio.Diagnostics.Common.WER_REPORT_TYPE : Enum {
    public int value__;
    public static WER_REPORT_TYPE WerReportNonCritical;
    public static WER_REPORT_TYPE WerReportCritical;
    public static WER_REPORT_TYPE WerReportApplicationCrash;
    public static WER_REPORT_TYPE WerReportApplicationHange;
    public static WER_REPORT_TYPE WerReportKernel;
    public static WER_REPORT_TYPE WerReportInvalid;
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.Win32Utility : object {
    public static Process GetParentProcess(Process child);
}
internal static class Microsoft.VisualStudio.Diagnostics.Common.XmlUtility : object {
    public static T DeserializeString(string xml, XmlSchema schema);
    public static T DeserializeFile(string filename, XmlSchema schema);
    public static T Deserialize(Stream xml, XmlSchema schema);
    public static void Serialize(T obj, string filename);
    public static void Serialize(T obj, Stream stream);
    public static string Serialize(T obj);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.AlignedMemory : object {
    private Byte* memory;
    private UInt32 sizeBytes;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    internal bool IsDisposed { get; private set; }
    public UInt32 SizeBytes { get; }
    public Byte* Bytes { get; }
    public AlignedMemory(UInt32 sizeBytes);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
internal bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public sealed virtual UInt32 get_SizeBytes();
    public sealed virtual Byte* get_Bytes();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.AlignedMemoryAllocator : object {
    public sealed virtual IMemory Allocate(UInt32 sizeBytes);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.AtomicInt32 : ValueType {
    private int m_value;
    public bool Get();
    public void Set(int value);
    public int Increment();
    public int Decrement();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.AtomicInt64 : ValueType {
    private long m_value;
    public long Get();
    public void Set(long value);
    public long Increment();
    public long Decrement();
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.BlockUtility : object {
    public static int UnboundedFileSize;
    public static int DefaultBlockSizeBytes;
    public static long DefaultMaxBlocks;
    public static void GetBlockInfo(int mbSize, Int32& blockSize, Int64& blockCount);
    public static void GetBlockInfo(int mbSize, int blockSize, Int64& blockCount);
    public static void ValidateBlockSize(int blockSize);
    public static void ValidateFileSize(int mbSize);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Diagnostics.Logging.BufferControlFlags : Enum {
    public int value__;
    public static BufferControlFlags None;
    public static BufferControlFlags CloseHandleAfterWrite;
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.BufferDescriptor : object {
    public int streamHandle;
    public IntPtr address;
    public int bufferSize;
    public int unusedInBuffer;
    public long streamOffset;
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.BufferedIpc : CriticalFinalizerObject {
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack <TestEventStack>k__BackingField;
    private string name;
    private bool disposed;
    private static UInt32 pageSize;
    private MemoryMappedFile buffers;
    private SList freeList;
    private SList usedList;
    private EventWaitHandle freeAddedEvent;
    private EventWaitHandle usedAddedEvent;
    private LinkedList`1<BufferToken> usedTokens;
    private static string freeBuffersAddedSuffix;
    private static string usedBuffersAddedSuffix;
    private static string buffersSuffix;
    private EventWaitHandle ipcDestroyedEvent;
    private static string ipcDestroyedEventSuffix;
    private EventWaitHandle _sxLockSharedEvent;
    private EventWaitHandle _sxLockExclusiveEvent;
    private static string sxLockSharedSuffix;
    private static string sxLockExclusiveSuffix;
    private SharedExclusiveLock _sxLock;
    public bool Disposed { get; }
    public int BufferSize { get; private set; }
    public int BufferCount { get; private set; }
    public EventWaitHandle FreeBufferAdded { get; }
    public EventWaitHandle UsedBufferAdded { get; }
    public EventWaitHandle IPCDestroyed { get; }
    public bool BuffersAvailable { get; }
    public int TotalBufferSpace { get; }
    public int TotalAdminSpace { get; }
    internal Stack TestEventStack { get; internal set; }
    private BufferAdminData* AdminData { get; }
    private IntPtr ListItemBase { get; }
    public IntPtr UsedListHeader { get; }
    public IntPtr FreeListHeader { get; }
    internal BufferedIpc(string name, int bufferSize, int bufferCount, LoggingConfig loggingConfig);
    public BufferedIpc(string name, LoggingConfig loggingConfig);
    public BufferedIpc(string name, IntPtr baseAddress, LoggingConfig loggingConfig);
    private static BufferedIpc();
    [ReliabilityContractAttribute("3", "2")]
public static long GetBufferStreamOffset(BufferToken token);
    [ReliabilityContractAttribute("3", "2")]
public static BufferControlFlags GetBufferControlFlags(BufferToken token);
    [ReliabilityContractAttribute("3", "2")]
public Byte* GetBufferAddress(BufferToken token);
    [ReliabilityContractAttribute("3", "2")]
public static int GetBufferStreamHandle(BufferToken token);
    [ReliabilityContractAttribute("3", "2")]
public static int GetBufferStreamType(BufferToken token);
    [ReliabilityContractAttribute("3", "2")]
public static long GetBufferNextItemOrdinal(BufferToken token);
    [ReliabilityContractAttribute("3", "2")]
public static int GetBufferUnusedBytes(BufferToken token);
    [ReliabilityContractAttribute("3", "2")]
public static int GetBufferProcessedBytes(BufferToken token);
    [ReliabilityContractAttribute("3", "2")]
public static void SetBufferUnusedBytes(BufferToken token, int unusedBytes);
    [ReliabilityContractAttribute("3", "2")]
public static void SetBufferStreamType(BufferToken token, int type);
    [ReliabilityContractAttribute("3", "2")]
public static void SetBufferStreamOffset(BufferToken token, long offset);
    [ReliabilityContractAttribute("3", "2")]
public static void SetBufferControlFlags(BufferToken token, BufferControlFlags flags);
    [ReliabilityContractAttribute("3", "2")]
public static void SetBufferNextItemOrdinal(BufferToken token, long itemOrdinal);
    [ReliabilityContractAttribute("3", "2")]
public static void SetBufferProcessedBytes(BufferToken token, int processedBytes);
    public BufferToken AcquireFreeBuffer(int streamHandle);
    public BufferToken AcquireUsedBuffer(int timeout);
    public void RetireUsedBuffer(BufferToken token);
    public BufferToken AcquireUsedBuffer();
    public BufferToken AcquireFreeBuffer(int streamHandle, int timeout);
    public void RetireFreeBuffer(BufferToken token);
    public IList`1<BufferToken> GatherHeldByClientBuffers(bool skipLocks, Predicate`1<int> streamHandlePredicate);
    public void Destroy();
    public sealed virtual void Dispose();
    public void Close();
    public bool get_Disposed();
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
private void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public int get_BufferCount();
    [CompilerGeneratedAttribute]
private void set_BufferCount(int value);
    public EventWaitHandle get_FreeBufferAdded();
    public EventWaitHandle get_UsedBufferAdded();
    public EventWaitHandle get_IPCDestroyed();
    public bool get_BuffersAvailable();
    public int get_TotalBufferSpace();
    public int get_TotalAdminSpace();
    [CompilerGeneratedAttribute]
internal Stack get_TestEventStack();
    [CompilerGeneratedAttribute]
internal void set_TestEventStack(Stack value);
    protected void Dispose(bool disposing);
    private BufferAdminData* get_AdminData();
    private IntPtr get_ListItemBase();
    public IntPtr get_UsedListHeader();
    public IntPtr get_FreeListHeader();
    private void WaitOnEvent(WaitHandle wakeEvent, int timeout);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.BufferedIpcDispatcher : LogWorkerThread {
    private BufferedIpc bufferedIpc;
    private LoggerEngine logger;
    private bool suspended;
    private IList`1<BufferToken> _heldTokensForSuspend;
    public static string MailServiceName;
    public LoggerEngine Logger { get; }
    public IntelliTraceFile TraceDebugLogFile { get; }
    public BufferedIpc Ipc { get; }
    public int IdleTimeout { get; public set; }
    private void DispatchOnBufferReceived(BufferToken token);
    private void DispatchOnSuspend(IList`1<BufferToken> heldTokens);
    private void DispatchOnResume();
    private void DispatchOnStartup();
    private void DispatchOnIdle();
    private void DispatchOnShuttingDown();
    private void DispatchOnShutdown();
    private void DispatchOnFlush();
    private void EnableBufferProcessing();
    private void DisableBufferProcessing();
    protected virtual bool OnInitialize(LoggerEngine logger);
    protected virtual void OnThreadStartup();
    protected virtual void OnThreadEvent(int eventIndex);
    protected virtual void OnThreadShutdown();
    protected virtual bool OnThreadMessage(ThreadMail mail);
    public LoggerEngine get_Logger();
    public IntelliTraceFile get_TraceDebugLogFile();
    public BufferedIpc get_Ipc();
    public int get_IdleTimeout();
    public void set_IdleTimeout(int value);
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.BufferedIpcMessages : object {
}
[ComVisibleAttribute("True")]
internal class Microsoft.VisualStudio.Diagnostics.Logging.BufferedLogStream : LogStream {
    private LogStream _s;
    private Byte[] _buffer;
    private int _readPos;
    private int _readLen;
    private int _writePos;
    private int _bufferSize;
    private static int _DefaultBufferSize;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int Index { get; }
    public long Start { get; }
    public int Handle { get; }
    public BufferedLogStream(LogStream stream);
    public BufferedLogStream(LogStream stream, int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    private void FlushRead();
    private void FlushWrite();
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int get_Index();
    public virtual long get_Start();
    public virtual void SetStart(long value);
    public virtual void Write(Byte* buffer, int count);
    public virtual void Write(long newPosition, Byte[] buffer, int offset, int count);
    public virtual void Write(long newPosition, Byte* buffer, int count);
    public virtual int get_Handle();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.BufferToken : ValueType {
    internal Byte* listItem;
    public static BufferToken Zero { get; }
    internal BufferToken(Byte* listItem);
    public static BufferToken op_Explicit(Byte* listItem);
    public BufferToken FromBytePtr(Byte* from);
    public static bool op_Equality(BufferToken left, BufferToken right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Inequality(BufferToken left, BufferToken right);
    public static BufferToken get_Zero();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.CacheManager`1 : object {
    private IHost<TKey> host;
    private UInt32 PageSize;
    private UInt32 PageCount;
    private IMemory memory;
    private Dictionary`2<TKey, Page<TKey>> directory;
    private LinkedList`1<Page<TKey>> activePages;
    private Stack`1<Page<TKey>> freePages;
    public CacheManager`1(IHost<TKey> host, IMemory memory, UInt32 pageSize, UInt32 pageCount);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private Page<TKey> Lock(TKey key, bool writing, bool skipFill);
    private Page<TKey> LockExistingPage(TKey key, bool writing, bool skipFill, Page<TKey> page);
    private void Unlock(Page<TKey> page);
    private void UnlockPageAfterFlush(Page<TKey> page);
    public bool Invalidate(Predicate`1<TKey> pred);
    public bool Flush(Predicate`1<TKey> pred);
    public IPage<TKey> LockForRead(TKey key);
    public IPage<TKey> LockForWrite(TKey key, bool skipFill);
    [ConditionalAttribute("STRESS")]
private void TestYield();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.ChainedOutputter : object {
    private List`1<IOutputter> _outputters;
    private string Microsoft.VisualStudio.Diagnostics.Logging.IErrorTrackingOutputter.LastError { get; }
    public ChainedOutputter(IList`1<IOutputter> outputters);
    private void DispatchEvent(Action`1<IOutputter> action);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IOutputter.OutputErrorEvent(OutputErrorEventArgs e);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IOutputter.OutputMessageEvent(OutputMessageEventArgs e);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IOutputter.OutputWarningEvent(OutputWarningEventArgs e);
    private sealed virtual override string Microsoft.VisualStudio.Diagnostics.Logging.IErrorTrackingOutputter.get_LastError();
    private sealed virtual override IList`1<string> Microsoft.VisualStudio.Diagnostics.Logging.IErrorTrackingOutputter.GetErrors();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.Diagnostics.Logging.ConfigurationMessageMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static ConfigurationMessageMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static ConfigurationMessageMessagePacker Default { get; private set; }
    public ConfigurationMessageMessagePacker(MessageInfo mi);
    private static ConfigurationMessageMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static ConfigurationMessageMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(ConfigurationMessageMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageConfiguration(Configuration* pConfiguration, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageConfiguration(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageConfiguration(_Configuration configuration, IMessageMemory2 memory, Int32& msgLen);
    public _Configuration UnpackMessageConfigurationToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _Configuration UnpackMessageConfigurationToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
public class Microsoft.VisualStudio.Diagnostics.Logging.ConsoleOutputter : ErrorTrackingOutputter {
    private TextWriter writer;
    [CompilerGeneratedAttribute]
private bool <Silent>k__BackingField;
    public bool Silent { get; public set; }
    public ConsoleOutputter(TextWriter writer);
    [CompilerGeneratedAttribute]
public bool get_Silent();
    [CompilerGeneratedAttribute]
public void set_Silent(bool value);
    public virtual void OutputErrorEvent(OutputErrorEventArgs e);
    public virtual void OutputWarningEvent(OutputWarningEventArgs e);
    public virtual void OutputMessageEvent(OutputMessageEventArgs e);
    private void SafeWrite(string message);
    private void SafeWriteLine(string message);
    private void SafeSetForgroundColor(ConsoleColor color);
    private void SafeResetConsoleColor();
    private void SafeRunConsoleAction(Action consoleAction);
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.ConsoleUtility : object {
    public static int ConsoleWidth { get; }
    public static int get_ConsoleWidth();
    public static void WriteLineWithWordbreaks(string text, int lineLength);
    public static void WriteLines(String[] lines);
}
internal enum Microsoft.VisualStudio.Diagnostics.Logging.ControlCommand : Enum {
    public int value__;
    public static ControlCommand Suspend;
    public static ControlCommand RealSuspend;
    public static ControlCommand Resume;
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.ControlDispatcher : LogWorkerThread {
    private QueuedIpcPipeServer ipc;
    private LoggerEngine logger;
    private WaitableTimer timer;
    private int timeout;
    private IMessageMemory2 _memory;
    private State _state;
    private static int numIpcDispatchers;
    private QueuedIpcDispatcher[] ipcDispatchers;
    private static int _ipcMaxEntrySize;
    private static int _ipcMaxEntries;
    public static string MailServiceName;
    protected virtual bool OnInitialize(LoggerEngine logger);
    protected virtual void OnThreadStartup();
    protected virtual void OnThreadEvent(int eventIndex);
    protected virtual bool OnThreadMessage(ThreadMail mail);
    protected virtual void OnThreadShutdown();
    protected virtual void OnPrepForShutdown();
    private void PrepForShutdownComplete();
    private QueuedIpcDispatcher GetIpcDispatcher(int processId, int threadId, int streamId, StreamAccess mode);
    private void SendServerFault(int clientId, Exception ex);
    private void OnConnectRequest(int clientId);
    private void OnGetProcessInfoRequest(int clientId);
    private void OnDispatcherRequest(int clientId, _StreamSpec request);
    private void OnCreateStreamRequest(int clientId, _CreateStreamRequest request);
    private void OnStreamEntriesRequest(int clientId);
    private void OnWatchProcess(int clientId, _ProcessInfoEx _ProcessInfoEx);
    private void OnStopWatchingProcess(int clientId, _ProcessInfo _ProcessInfo);
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.ControlEvents : object {
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.ControlMessage : object {
    [CompilerGeneratedAttribute]
private ControlCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoCommand>k__BackingField;
    public ControlCommand Command { get; private set; }
    public bool AutoCommand { get; private set; }
    public ControlMessage(ControlCommand command, bool autoCommand);
    [CompilerGeneratedAttribute]
public ControlCommand get_Command();
    [CompilerGeneratedAttribute]
private void set_Command(ControlCommand value);
    [CompilerGeneratedAttribute]
public bool get_AutoCommand();
    [CompilerGeneratedAttribute]
private void set_AutoCommand(bool value);
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.Diagnostics.Logging.ControlMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static ControlMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static ControlMessagePacker Default { get; private set; }
    public ControlMessagePacker(MessageInfo mi);
    private static ControlMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static ControlMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(ControlMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageConnectRequest(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageConnectRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCreateStreamRequest(CreateStreamRequest* pCreateStreamRequest, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCreateStreamRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCreateStreamRequest(_CreateStreamRequest createStreamRequest, IMessageMemory2 memory, Int32& msgLen);
    public _CreateStreamRequest UnpackMessageCreateStreamRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CreateStreamRequest UnpackMessageCreateStreamRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCreateStreamResponse(StreamIndex* pStreamIndex, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCreateStreamResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCreateStreamResponse(_StreamIndex streamIndex, IMessageMemory2 memory, Int32& msgLen);
    public _StreamIndex UnpackMessageCreateStreamResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _StreamIndex UnpackMessageCreateStreamResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageDisconnectRequest(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageDisconnectRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageDispatcherRequest(StreamSpec* pStreamSpec, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageDispatcherRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageDispatcherRequest(_StreamSpec streamSpec, IMessageMemory2 memory, Int32& msgLen);
    public _StreamSpec UnpackMessageDispatcherRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _StreamSpec UnpackMessageDispatcherRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageDispatcherResponse(IpcInfo* pIpcInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageDispatcherResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageDispatcherResponse(_IpcInfo ipcInfo, IMessageMemory2 memory, Int32& msgLen);
    public _IpcInfo UnpackMessageDispatcherResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _IpcInfo UnpackMessageDispatcherResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageErrorList(ErrorList* pErrorList, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageErrorList(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageErrorList(_ErrorList errorList, IMessageMemory2 memory, Int32& msgLen);
    public _ErrorList UnpackMessageErrorListToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ErrorList UnpackMessageErrorListToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetErrorList(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageGetErrorList(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetProcessInfoRequest(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageGetProcessInfoRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetProcessInfoResponse(ProcessInfoEx* pProcessInfoEx, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageGetProcessInfoResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetProcessInfoResponse(_ProcessInfoEx processInfoEx, IMessageMemory2 memory, Int32& msgLen);
    public _ProcessInfoEx UnpackMessageGetProcessInfoResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ProcessInfoEx UnpackMessageGetProcessInfoResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOpSucceeded(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageOpSucceeded(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOpSucceededErrorsPending(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageOpSucceededErrorsPending(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageResumeRequest(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageResumeRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageServerFault(FaultInfo* pFaultInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageServerFault(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageServerFault(_FaultInfo faultInfo, IMessageMemory2 memory, Int32& msgLen);
    public _FaultInfo UnpackMessageServerFaultToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _FaultInfo UnpackMessageServerFaultToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSetDeleteLogOnExit(DeleteLogOnExit* pDeleteLogOnExit, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageSetDeleteLogOnExit(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSetDeleteLogOnExit(_DeleteLogOnExit deleteLogOnExit, IMessageMemory2 memory, Int32& msgLen);
    public _DeleteLogOnExit UnpackMessageSetDeleteLogOnExitToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _DeleteLogOnExit UnpackMessageSetDeleteLogOnExitToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageStopWatchingProcess(ProcessInfo* pProcessInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageStopWatchingProcess(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageStopWatchingProcess(_ProcessInfo processInfo, IMessageMemory2 memory, Int32& msgLen);
    public _ProcessInfo UnpackMessageStopWatchingProcessToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ProcessInfo UnpackMessageStopWatchingProcessToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageStreamEntriesRequest(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageStreamEntriesRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageStreamEntriesResponse(StreamEntries* pStreamEntries, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageStreamEntriesResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageStreamEntriesResponse(_StreamEntries streamEntries, IMessageMemory2 memory, Int32& msgLen);
    public _StreamEntries UnpackMessageStreamEntriesResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _StreamEntries UnpackMessageStreamEntriesResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSuspendRequest(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageSuspendRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWatchProcess(ProcessInfoEx* pProcessInfoEx, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWatchProcess(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWatchProcess(_ProcessInfoEx processInfoEx, IMessageMemory2 memory, Int32& msgLen);
    public _ProcessInfoEx UnpackMessageWatchProcessToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ProcessInfoEx UnpackMessageWatchProcessToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.DefaultBufferHandler : object {
    private Parameters[] waitCurveParameters;
    private BufferedIpcDispatcher dispatcher;
    private int waitCurveIndex;
    private int tokenCount;
    private BufferDescriptor[] descriptors;
    private BufferToken[] tokens;
    private bool suspended;
    private LogFileBase logFile;
    private BufferedIpc Ipc { get; }
    private bool ContinueOnDiskFullException { get; }
    private BufferedIpc get_Ipc();
    private bool get_ContinueOnDiskFullException();
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnInitialize(BufferedIpcDispatcher dispatcher);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnStartup();
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnBufferReceived(BufferToken& token);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnBufferWritten(BufferToken token);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnFlush();
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnIdle();
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnShuttingDown();
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnShutdown();
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnSuspend(IList`1<BufferToken> heldTokens);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnResume();
    private sealed virtual override bool Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnThreadMessage(ThreadMail message);
    private void FillBufferDescriptors(IList`1<BufferToken> tokens, int tokenCount);
    private void WriteUsedBuffers();
    private void DispatchOnBufferWritten(BufferToken token);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.DiskFullException : IOException {
    public DiskFullException(string message);
    public DiskFullException(string message, Exception innerException);
    protected DiskFullException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.EngineEventKeepAlive : EventArgs {
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.EngineEventRemoveWaitHandles : EventArgs {
    [CompilerGeneratedAttribute]
private Predicate`1<WaitHandle> <Predicate>k__BackingField;
    public Predicate`1<WaitHandle> Predicate { get; private set; }
    public EngineEventRemoveWaitHandles(Predicate`1<WaitHandle> predicate);
    [CompilerGeneratedAttribute]
public Predicate`1<WaitHandle> get_Predicate();
    [CompilerGeneratedAttribute]
private void set_Predicate(Predicate`1<WaitHandle> value);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.EngineEventSetDeleteLogOnExit : EventArgs {
    [CompilerGeneratedAttribute]
private bool <DeleteLog>k__BackingField;
    public bool DeleteLog { get; private set; }
    public EngineEventSetDeleteLogOnExit(bool deleteLog);
    [CompilerGeneratedAttribute]
public bool get_DeleteLog();
    [CompilerGeneratedAttribute]
private void set_DeleteLog(bool value);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.EngineEventWaitOnHandle : EventArgs {
    [CompilerGeneratedAttribute]
private WaitHandle <Handle>k__BackingField;
    public WaitHandle Handle { get; private set; }
    public EngineEventWaitOnHandle(WaitHandle handle);
    [CompilerGeneratedAttribute]
public WaitHandle get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(WaitHandle value);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.EngineEventWorkerThreadAborted : EventArgs {
    [CompilerGeneratedAttribute]
private LogWorkerThread <Thread>k__BackingField;
    public LogWorkerThread Thread { get; private set; }
    public EngineEventWorkerThreadAborted(LogWorkerThread thread);
    [CompilerGeneratedAttribute]
public LogWorkerThread get_Thread();
    [CompilerGeneratedAttribute]
private void set_Thread(LogWorkerThread value);
}
public abstract class Microsoft.VisualStudio.Diagnostics.Logging.ErrorTrackingOutputter : object {
    private List`1<string> _errors;
    public string LastError { get; }
    public virtual void OutputErrorEvent(OutputErrorEventArgs e);
    public virtual void OutputWarningEvent(OutputWarningEventArgs e);
    public virtual void OutputMessageEvent(OutputMessageEventArgs e);
    public sealed virtual IList`1<string> GetErrors();
    public sealed virtual string get_LastError();
    protected string Format(string code, string message);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.FailureMessage : object {
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.FatalTimeoutException : Exception {
    public FatalTimeoutException(string message, TimeoutException innerException);
    protected FatalTimeoutException(SerializationInfo info, StreamingContext context);
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.Format : object {
    internal static int FileIdentifierLength;
    internal static int MagicLength;
    public static string FileIdentifier;
}
internal interface Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler {
    public abstract virtual void OnInitialize(BufferedIpcDispatcher dispatcher);
    public abstract virtual void OnStartup();
    public abstract virtual void OnBufferReceived(BufferToken& token);
    public abstract virtual void OnBufferWritten(BufferToken token);
    public abstract virtual void OnIdle();
    public abstract virtual void OnShuttingDown();
    public abstract virtual void OnShutdown();
    public abstract virtual void OnSuspend(IList`1<BufferToken> heldTokens);
    public abstract virtual void OnResume();
    public abstract virtual void OnFlush();
    public abstract virtual bool OnThreadMessage(ThreadMail message);
}
public interface Microsoft.VisualStudio.Diagnostics.Logging.IErrorTrackingOutputter {
    public string LastError { get; }
    public abstract virtual string get_LastError();
    public abstract virtual IList`1<string> GetErrors();
}
internal interface Microsoft.VisualStudio.Diagnostics.Logging.IMemory {
    public UInt32 SizeBytes { get; }
    public Byte* Bytes { get; }
    public abstract virtual UInt32 get_SizeBytes();
    public abstract virtual Byte* get_Bytes();
}
internal interface Microsoft.VisualStudio.Diagnostics.Logging.IMemoryAllocator {
    public abstract virtual IMemory Allocate(UInt32 sizeBytes);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("084560CE-6B79-456b-934B-D764059656B2")]
internal interface Microsoft.VisualStudio.Diagnostics.Logging.IMessageIPC {
    public abstract virtual bool AddMessage(int timeout, IntPtr data, UInt32 length);
    public abstract virtual bool AddMessages(int timeout, IntPtr[] rgData, UInt32[] rgLength, UInt32 cBuffers);
    public abstract virtual void Peek(IntPtr& data, UInt32& length);
    public abstract virtual bool Remove();
    public abstract virtual void Close();
    public abstract virtual UInt32 GetMaxEntrySize();
    public abstract virtual string GetNotEmptyEventName();
    public abstract virtual bool IsEmpty();
}
public interface Microsoft.VisualStudio.Diagnostics.Logging.IOutputter {
    public abstract virtual void OutputErrorEvent(OutputErrorEventArgs e);
    public abstract virtual void OutputWarningEvent(OutputWarningEventArgs e);
    public abstract virtual void OutputMessageEvent(OutputMessageEventArgs e);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Diagnostics.Logging.IOutputterExtensions : object {
    [ExtensionAttribute]
public static void WriteDebug(IOutputter self, string message);
    [ExtensionAttribute]
public static void WriteVerbose(IOutputter self, string message);
    [ExtensionAttribute]
public static void WriteWarning(IOutputter self, string message);
    [ExtensionAttribute]
public static void WriteError(IOutputter self, string message);
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.Diagnostics.Logging.IpcMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static IpcMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static IpcMessagePacker Default { get; private set; }
    public IpcMessagePacker(MessageInfo mi);
    private static IpcMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static IpcMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(IpcMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageClose(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageClose(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageConnectRequest(StreamSpec* pStreamSpec, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageConnectRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageConnectRequest(_StreamSpec streamSpec, IMessageMemory2 memory, Int32& msgLen);
    public _StreamSpec UnpackMessageConnectRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _StreamSpec UnpackMessageConnectRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageConnectResponse(ConnectResponseData* pConnectResponseData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageConnectResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageConnectResponse(_ConnectResponseData connectResponseData, IMessageMemory2 memory, Int32& msgLen);
    public _ConnectResponseData UnpackMessageConnectResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ConnectResponseData UnpackMessageConnectResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFlushRequest(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageFlushRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetLengthRequest(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageGetLengthRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetLengthResponse(StreamInfo* pStreamInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageGetLengthResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetLengthResponse(_StreamInfo streamInfo, IMessageMemory2 memory, Int32& msgLen);
    public _StreamInfo UnpackMessageGetLengthResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _StreamInfo UnpackMessageGetLengthResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetStartRequest(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageGetStartRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetStartResponse(StreamInfo* pStreamInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageGetStartResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetStartResponse(_StreamInfo streamInfo, IMessageMemory2 memory, Int32& msgLen);
    public _StreamInfo UnpackMessageGetStartResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _StreamInfo UnpackMessageGetStartResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOpSucceeded(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageOpSucceeded(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOverwrite(OffsetDataPacket* pOffsetDataPacket, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageOverwrite(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOverwrite(_OffsetDataPacket offsetDataPacket, IMessageMemory2 memory, Int32& msgLen);
    public _OffsetDataPacket UnpackMessageOverwriteToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _OffsetDataPacket UnpackMessageOverwriteToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageReadRequest(OffsetCount* pOffsetCount, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageReadRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageReadRequest(_OffsetCount offsetCount, IMessageMemory2 memory, Int32& msgLen);
    public _OffsetCount UnpackMessageReadRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _OffsetCount UnpackMessageReadRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageReadResponse(DataPacket* pDataPacket, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageReadResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageReadResponse(_DataPacket dataPacket, IMessageMemory2 memory, Int32& msgLen);
    public _DataPacket UnpackMessageReadResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _DataPacket UnpackMessageReadResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageServerFault(FaultInfo* pFaultInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageServerFault(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageServerFault(_FaultInfo faultInfo, IMessageMemory2 memory, Int32& msgLen);
    public _FaultInfo UnpackMessageServerFaultToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _FaultInfo UnpackMessageServerFaultToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWrite(OffsetDataPacket* pOffsetDataPacket, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWrite(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWrite(_OffsetDataPacket offsetDataPacket, IMessageMemory2 memory, Int32& msgLen);
    public _OffsetDataPacket UnpackMessageWriteToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _OffsetDataPacket UnpackMessageWriteToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.LogConstants : object {
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.LogFile : LogFileBase {
    private LoggingConfig config;
    private string logFileName;
    private IMemoryAllocator memoryAllocator;
    private bool deleteOnClose;
    private bool ignoreWrites;
    private UnbufferedFile file;
    private CacheManager`1<StreamCacheKey> cache;
    private FileMeta meta;
    private int firstFreeStreamIndex;
    private Dictionary`2<int, StreamStatus> openedStreams;
    private int nextStreamHandle;
    private Dictionary`2<int, Tuple`2<StreamStatus, ulong>> bypassStreams;
    private object logFileLock;
    private State state;
    private UInt32 cachePageCount;
    private ExtentList _freeBlocks;
    private ulong _freeBlockCount;
    private ulong _freeBlockReserved;
    private int _diskFullExceptionThrown;
    private long _trimTicket;
    private UInt32 DblocksPerSblock;
    private UInt32 SblocksPerEblock;
    private UInt32 SblocksPerFblock;
    private UInt32 BytesPerDblock;
    private UInt32 BytesPerSblock;
    private UInt32 BlockSize;
    [CompilerGeneratedAttribute]
private EventHandler DiskFull;
    [CompilerGeneratedAttribute]
private EventHandler`1<TrimLogEventArgs> TrimLog;
    internal LoggingConfig Config { get; }
    internal bool IsReadOnly { get; }
    internal string LogFileName { get; }
    internal bool DiskFullExceptionThrown { get; internal set; }
    internal int TestHookLogBlockSize { get; }
    public LogFile(string logFileName);
    public LogFile(string logFileName, LogFileAccess access, IMemoryAllocator memoryAllocator);
    public LogFile(string logFileName, LogFileCreateMode mode, int blockSize, LoggingConfig loggingConfig);
    public LogFile(string logFileName, LogFileCreateMode mode, int blockSize, long maxFileBlockCount, bool deleteOnClose, LoggingConfig loggingConfig, IMemoryAllocator memoryAllocator);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.CacheManager<Microsoft.VisualStudio.Diagnostics.Logging.StreamCacheKey>.IHost.Fill(IList`1<IPage<StreamCacheKey>> pages);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.CacheManager<Microsoft.VisualStudio.Diagnostics.Logging.StreamCacheKey>.IHost.Flush(IList`1<IPage<StreamCacheKey>> pages);
    internal int InternalOpenStream(int streamIndex, FileAccess mode);
    private StreamMeta AcquireStreamMetadata(int streamIndex, bool create);
    private void ReleaseStreamMetadata(StreamMeta stream, bool logFileLockHeld);
    private void CalcSBlockLimits(StreamMeta stream, UInt32& cSblocks, UInt32& sblockTopMaxDblock, UInt32& sblockBottomMinDblock);
    private StreamStatus LockStreamHandle(int handle);
    private void ReleaseStreamHandle(int handle);
    internal virtual LoggingConfig get_Config();
    private void SetLogConstants(UInt32 blockSize);
    private static void TryAllocateMemoryForCacheManager(UInt32 pageSize, UInt32 maxPageCount, int allowedScaledown, IMemoryAllocator memoryAllocator, IMemory& memory, UInt32& allocatedPageCount);
    private void LoadFileMetadata(IMemory buff);
    private void FlushFileMetadata(IMemory buff);
    private UInt32 CalcDBlocks(ulong streamStart, ulong streamLength);
    private UInt32 CalcSBlocks(StreamMeta stream);
    private UInt32 CalcSBlocks(ulong streamStart, ulong streamLength);
    internal virtual bool StreamExists(int streamIndex);
    internal virtual int CreateStream(Guid type);
    internal virtual void CreateStream(Guid type, int streamIndex);
    internal virtual LogStream CreateStream(Guid type, StreamAccess streamOpenMode);
    internal virtual LogStream CreateStream(Guid type, int streamIndex, StreamAccess streamOpenMode);
    private int InternalCreateStream(Guid type, Nullable`1<int> requestedStreamIndex, Nullable`1<StreamAccess> streamOpenMode, LogStream& openedStream);
    internal virtual void CloseStream(int streamHandle);
    internal UInt32 Read(int streamHandle, ulong streamOffset, Byte* buffer, UInt32 requestedCount);
    internal UInt32 Write(int streamHandle, ulong streamOffset, Byte* buffer, UInt32 count);
    internal virtual void Append(BufferDescriptor[] descriptors, int cDescriptors);
    internal virtual void SuspendLogAndBypass(IList`1<BufferDescriptor> descriptors, int cDescriptors);
    internal virtual void ResumeLog();
    internal void DisposeStarted();
    public virtual void Dispose();
    private void BlockRead(ulong offset, Byte* buffer);
    private void BlockWrite(ulong offset, Byte*[] buffers);
    private ulong BlockWrite(bool useReserve, Byte* buffer);
    private IList`1<ulong> BlockWrite(bool useReserve, Byte*[] buffers, int buffersOffset, int buffersCount);
    private void FreeBlockAdd(ulong offset, ulong countBlocks, bool reserved);
    private bool FreeBlockReserve(ulong countBlocks);
    private void FreeBlockRelease(ulong countBlocks);
    private void FreeBlockGet(bool useReserved, bool minimumMatch, UInt32 blocksWanted, UInt64& offset, UInt32& blocksObtained);
    private ulong FreeBlockGet(bool useReserved, UInt32 blockCount);
    private ulong FreeBlockGet(bool useReserved, UInt32 blockCount, UInt32& outBlockCount);
    private long TrimLogOrThrow(long trimTicket);
    internal virtual void DoTrimLog(TrimLogEventArgs trimArgs);
    private ulong StreamGetLength(int streamIndex);
    private void StreamSetLength(int streamIndex, ulong offset);
    private ulong StreamGetStart(int streamIndex);
    private void StreamSetStart(int streamIndex, ulong offset);
    internal virtual LogStream OpenStream(int streamIndex, StreamAccess mode);
    private LogStreamEntry StreamMetaToLogStreamEntry(StreamMeta stream);
    internal virtual IList`1<LogStreamEntry> GetLogStreamEntries();
    internal virtual void Close();
    internal virtual int HandleToIndex(int handle);
    [CompilerGeneratedAttribute]
internal virtual void add_DiskFull(EventHandler value);
    [CompilerGeneratedAttribute]
internal virtual void remove_DiskFull(EventHandler value);
    [CompilerGeneratedAttribute]
internal virtual void add_TrimLog(EventHandler`1<TrimLogEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_TrimLog(EventHandler`1<TrimLogEventArgs> value);
    internal virtual bool get_IsReadOnly();
    internal virtual string get_LogFileName();
    internal bool get_DiskFullExceptionThrown();
    internal void set_DiskFullExceptionThrown(bool value);
    private void CheckWriteable();
    private void CheckNotClosed();
    internal int get_TestHookLogBlockSize();
    internal void TestHookDeleteStream(int streamIndex);
}
internal enum Microsoft.VisualStudio.Diagnostics.Logging.LogFileAccess : Enum {
    public int value__;
    public static LogFileAccess Read;
    public static LogFileAccess ReadWrite;
}
public abstract class Microsoft.VisualStudio.Diagnostics.Logging.LogFileBase : object {
    internal bool IsReadOnly { get; }
    internal string LogFileName { get; }
    internal LoggingConfig Config { get; }
    internal abstract virtual int CreateStream(Guid type);
    internal abstract virtual void CreateStream(Guid type, int streamIndex);
    internal abstract virtual LogStream CreateStream(Guid type, StreamAccess streamOpenMode);
    internal abstract virtual LogStream CreateStream(Guid type, int streamIndex, StreamAccess streamOpenMode);
    internal abstract virtual LogStream OpenStream(int streamIndex, StreamAccess mode);
    internal abstract virtual bool StreamExists(int streamIndex);
    internal abstract virtual int HandleToIndex(int handle);
    internal abstract virtual void Append(BufferDescriptor[] descriptors, int numDescriptors);
    internal abstract virtual void SuspendLogAndBypass(IList`1<BufferDescriptor> descriptors, int numDescriptors);
    internal abstract virtual void ResumeLog();
    internal abstract virtual IList`1<LogStreamEntry> GetLogStreamEntries();
    internal abstract virtual bool get_IsReadOnly();
    internal abstract virtual string get_LogFileName();
    internal abstract virtual void CloseStream(int streamHandle);
    internal abstract virtual void Close();
    [CompilerGeneratedAttribute]
internal abstract virtual void add_DiskFull(EventHandler value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_DiskFull(EventHandler value);
    internal abstract virtual LoggingConfig get_Config();
    [CompilerGeneratedAttribute]
internal abstract virtual void add_TrimLog(EventHandler`1<TrimLogEventArgs> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_TrimLog(EventHandler`1<TrimLogEventArgs> value);
    internal abstract virtual void DoTrimLog(TrimLogEventArgs trimArgs);
    public abstract virtual void Dispose();
}
internal enum Microsoft.VisualStudio.Diagnostics.Logging.LogFileCreateMode : Enum {
    public int value__;
    public static LogFileCreateMode OverwriteExisting;
    public static LogFileCreateMode CreateExclusive;
}
internal abstract class Microsoft.VisualStudio.Diagnostics.Logging.LoggerEngine : object {
    private Queue`1<EventArgs> _eventQueue;
    private AutoResetEvent _eventQueueEvent;
    private IntelliTraceFile traceDebugLogFile;
    private ThreadMailDispatcher _messageDispatcher;
    private List`1<IBufferHandler> _bufferHandlers;
    private List`1<LogWorkerThread> _workerThreads;
    private QueuedIpcPipeClient _controlIpc;
    private object _controlIpcLock;
    private string _controlIpcLoggerName;
    private OutputHelper _outputHelper;
    private List`1<WaitHandle> _stopHandles;
    private bool _stopHandlesEmptyShutdown;
    private bool _logDeleteOnExit;
    private WaitableTimer _keepAliveTimer;
    private LoggingConfig _config;
    private LoggingConfig _publishedConfig;
    private Thread _loggerThread;
    protected IMessageMemory2 _memory;
    protected ManualResetEvent _cancelRequestedEvent;
    public static int CollectorRate;
    private static int CollectorTimeout;
    public OutputHelper Output { get; }
    public ReadOnlyCollection`1<IBufferHandler> HandlerChain { get; }
    public LoggingConfig LoggingConfig { get; }
    internal NamedCounter Counters { get; }
    public LoggerStartInfo StartInfo { get; }
    public bool Running { get; }
    public bool Initialized { get; }
    public string LoggerName { get; }
    public int BufferSize { get; }
    public int BufferCount { get; }
    public IntelliTraceFile TraceDebugLogFile { get; }
    public ThreadMailDispatcher MailDispatcher { get; }
    internal string EventNameStarted { get; }
    internal string EventNameAttachReady { get; }
    internal string EventNameAttachComplete { get; }
    internal string EventNameFinished { get; }
    internal string EventNameShutdown { get; }
    public LoggerEngine(IOutputter outputter);
    public OutputHelper get_Output();
    public ReadOnlyCollection`1<IBufferHandler> get_HandlerChain();
    public LoggingConfig get_LoggingConfig();
    internal abstract virtual NamedCounter get_Counters();
    public abstract virtual LoggerStartInfo get_StartInfo();
    public bool get_Running();
    public bool get_Initialized();
    protected bool Run();
    private void HandleQueueMessages();
    protected bool Start(int timeout, Action action);
    public bool Stop(int timeout);
    public bool Stop(bool waitForFinish);
    private bool WaitForStart(int timeout, EventWaitHandle startedEvent, EventWaitHandle finishedEvent);
    public bool Attach(_ProcessInfo procInfo);
    internal bool WaitForLogExit(int timeout);
    public void Bind();
    public bool WaitForStart(int timeout);
    public virtual bool Suspend();
    public virtual bool Resume();
    public void AddSynchronizePermissionsToCurrentProcess();
    public bool WaitOnProcess(Process process);
    public bool StopWaitingOnProcess(Process process);
    public bool SetDeleteLogOnExit(bool deleteLog);
    public IList`1<string> GetErrorList();
    public bool DispatchEvent(EventArgs args);
    public string get_LoggerName();
    public int get_BufferSize();
    public int get_BufferCount();
    public IntelliTraceFile get_TraceDebugLogFile();
    public ThreadMailDispatcher get_MailDispatcher();
    public bool RequestCancel();
    private bool ControlLogger(Byte* controlMsg, int msgLen);
    private bool EnsureLoggerIpc();
    private void CloseLoggerIpc();
    private void CloseLoggerIpc(bool sendDisconnectRequest);
    private bool AssertCorrectResponse(Byte* pData, MessageID expectedMsgID);
    private QueuedIpcEntry RequestAndWaitForResponse(Byte* pMsg, int msgLen);
    private void OnStartQueuedIpcDispatcher(EventArgs args);
    internal bool GetLoggerProcessInfo(Int32& processID, Int64& processCreationFileTime);
    protected internal Process GetLoggerProcess();
    private bool DeleteFile(string fileName);
    private EventWaitHandle GetNamedEvent(string name, bool wantCreate, bool wantOpen);
    private EventWaitHandle GetNamedEvent(string name, bool initialState, bool wantCreate, bool wantOpen);
    private EventWaitHandle GetNamedEvent(string name, bool initialState, bool wantCreate, bool wantOpen, EventWaitHandleSecurity security, EventWaitHandleRights rights);
    private EventWaitHandle GetNamedEvent(string name, bool initialState, bool wantCreate, bool wantOpen, EventWaitHandleSecurity security, EventWaitHandleRights rights, LoggingConfig config);
    internal string get_EventNameStarted();
    internal string get_EventNameAttachReady();
    internal string get_EventNameAttachComplete();
    internal string get_EventNameFinished();
    internal string get_EventNameShutdown();
    private EventWaitHandle EventOpenStarted(bool wantModify);
    internal EventWaitHandle EventGetStarted(bool wantModify);
    private EventWaitHandle EventOpenFinished(bool wantModify);
    internal EventWaitHandle EventGetFinished(bool wantModify);
    internal EventWaitHandle EventOpenShutdown();
    private EventWaitHandle EventCreateShutdown();
    internal EventWaitHandle EventGetShutdown();
    internal EventWaitHandle EventGetAttachReady();
    internal EventWaitHandle EventGetAttachComplete();
    protected abstract virtual IntelliTraceFile CreateLogFile();
    protected abstract virtual IList`1<LogWorkerThread> CreateWorkerThreads();
    protected abstract virtual IList`1<IBufferHandler> CreateBufferHandlers();
    protected abstract virtual bool OnRunStarting();
    protected abstract virtual void OnRunStopping();
    protected virtual LoggingConfig CreateLoggingConfig();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <Stop>b__41_0();
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.LoggerProcessName : object {
    public static string VSTraceLog;
    public static string TILog;
    private static LoggerProcessName();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.LoggerStartInfo : object {
    private string _loggerName;
    private string _logFilePath;
    private int _bufferCount;
    private int _cacheBufferCount;
    private int _bufferSize;
    private static int _systemPageSize;
    private int _watchPid;
    private int _debuggeePid;
    private TraceLoggingService _service;
    [CompilerGeneratedAttribute]
private bool <OverwriteExistingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContinueOnDiskFullException>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteLogOnExit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServiceController>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputHelper <Output>k__BackingField;
    public TraceLoggingService Service { get; public set; }
    public string LoggerName { get; public set; }
    public string LogFilePath { get; public set; }
    public int BufferSize { get; public set; }
    public int BufferCount { get; public set; }
    public int CacheBufferCount { get; public set; }
    public int WatchPid { get; public set; }
    public int DebuggeePid { get; public set; }
    public bool OverwriteExistingFile { get; public set; }
    public bool ContinueOnDiskFullException { get; public set; }
    [ObsoleteAttribute]
public bool DeleteLogOnExit { get; public set; }
    public bool IsServiceController { get; public set; }
    protected static int SystemPageSize { get; }
    protected OutputHelper Output { get; private set; }
    public LoggerStartInfo(OutputHelper outputHelper);
    public TraceLoggingService get_Service();
    public void set_Service(TraceLoggingService value);
    public virtual string get_LoggerName();
    public virtual void set_LoggerName(string value);
    public virtual string get_LogFilePath();
    public virtual void set_LogFilePath(string value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public int get_BufferCount();
    public void set_BufferCount(int value);
    public int get_CacheBufferCount();
    public void set_CacheBufferCount(int value);
    public int get_WatchPid();
    public void set_WatchPid(int value);
    public int get_DebuggeePid();
    public void set_DebuggeePid(int value);
    [CompilerGeneratedAttribute]
public bool get_OverwriteExistingFile();
    [CompilerGeneratedAttribute]
public void set_OverwriteExistingFile(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_ContinueOnDiskFullException();
    [CompilerGeneratedAttribute]
public virtual void set_ContinueOnDiskFullException(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_DeleteLogOnExit();
    [CompilerGeneratedAttribute]
public virtual void set_DeleteLogOnExit(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsServiceController();
    [CompilerGeneratedAttribute]
public void set_IsServiceController(bool value);
    public string GetTruncatedProcessName(string processName);
    protected static int get_SystemPageSize();
    [CompilerGeneratedAttribute]
protected OutputHelper get_Output();
    [CompilerGeneratedAttribute]
private void set_Output(OutputHelper value);
    private static string CanonicalizeLoggerName(string loggerName);
    private static bool IsValidLoggerNameChar(char c);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.LoggerTaskResources : object {
    internal static ResourceManager ResourceManager;
    public static string Cmd_ArgumentsSwitchValueHint { get; }
    public static string Cmd_BufferCountSwitchDescription { get; }
    public static string Cmd_BufferCountSwitchHint { get; }
    public static string Cmd_BufferSizeSwitchDescription { get; }
    public static string Cmd_BufferSizeSwitchHint { get; }
    public static string Cmd_CacheBufferCountSwitchDescription { get; }
    public static string Cmd_CacheBufferCountSwitchHint { get; }
    public static string Cmd_CommandLineCopyright { get; }
    public static string Cmd_CommandLineDescription { get; }
    public static string Cmd_CommandLineTitle { get; }
    public static string Cmd_CommandSwitchHint { get; }
    public static string Cmd_CopyCommandDescription { get; }
    public static string Cmd_Copyright { get; }
    public static string Cmd_DebugConfiguration { get; }
    public static string Cmd_DebugSwitchDescription { get; }
    public static string Cmd_DefaultSwitchValueHint { get; }
    public static string Cmd_Description { get; }
    public static string Cmd_Example { get; }
    public static string Cmd_HelpCommandDefaultSwitchValueHint { get; }
    public static string Cmd_HelpCommandDescription { get; }
    public static string Cmd_HelpSwitchDescription { get; }
    public static string Cmd_LogFileSwitchDescription { get; }
    public static string Cmd_LogFileSwitchHint { get; }
    public static string Cmd_NameSwitchDescription { get; }
    public static string Cmd_NameSwitchHint { get; }
    public static string Cmd_NoLogoSwitchDescription { get; }
    public static string Cmd_RunCommandDefaultSwitchValueHint { get; }
    public static string Cmd_RunCommandDescription { get; }
    public static string Cmd_ShowHiddenSwitchDescription { get; }
    public static string Cmd_StartCommandDefaultSwitchValueHint { get; }
    public static string Cmd_StartCommandDescription { get; }
    public static string Cmd_StopCommandDescription { get; }
    public static string Cmd_Title { get; }
    public static string Cmd_WaitTimeSwitchDescription { get; }
    public static string Cmd_WaitTimeSwitchHint { get; }
    public static string Cmd_WatchProcessSwitchDescription { get; }
    public static string Cmd_WatchProcessSwitchHint { get; }
    public static string Err_LogFileUnspecified { get; }
    public static string Err_LoggerIsNotRunning { get; }
    public static string Err_LoggerIsRunning { get; }
    public static string Err_LoggerNameUnspecified { get; }
    public static string Err_NoLogFileOrLoggerName { get; }
    public static string Err_NoWorkerThreadsConfigured { get; }
    public static string Msg_LoadingBufferHandlers { get; }
    public static string Msg_LoadingWorkerThreads { get; }
    public static string Msg_StoppingLogger { get; }
    public static string Wrn_CouldNotContactLogger { get; }
    public static string Wrn_DeletingExistingLogFile { get; }
    public static string Err_InternalError { get; }
    private static LoggerTaskResources();
    public static string get_Cmd_ArgumentsSwitchValueHint();
    public static string get_Cmd_BufferCountSwitchDescription();
    public static string get_Cmd_BufferCountSwitchHint();
    public static string get_Cmd_BufferSizeSwitchDescription();
    public static string get_Cmd_BufferSizeSwitchHint();
    public static string get_Cmd_CacheBufferCountSwitchDescription();
    public static string get_Cmd_CacheBufferCountSwitchHint();
    public static string get_Cmd_CommandLineCopyright();
    public static string get_Cmd_CommandLineDescription();
    public static string get_Cmd_CommandLineTitle();
    public static string get_Cmd_CommandSwitchHint();
    public static string get_Cmd_CopyCommandDescription();
    public static string get_Cmd_Copyright();
    public static string get_Cmd_DebugConfiguration();
    public static string get_Cmd_DebugSwitchDescription();
    public static string get_Cmd_DefaultSwitchValueHint();
    public static string get_Cmd_Description();
    public static string get_Cmd_Example();
    public static string get_Cmd_HelpCommandDefaultSwitchValueHint();
    public static string get_Cmd_HelpCommandDescription();
    public static string get_Cmd_HelpSwitchDescription();
    public static string get_Cmd_LogFileSwitchDescription();
    public static string get_Cmd_LogFileSwitchHint();
    public static string get_Cmd_NameSwitchDescription();
    public static string get_Cmd_NameSwitchHint();
    public static string get_Cmd_NoLogoSwitchDescription();
    public static string get_Cmd_RunCommandDefaultSwitchValueHint();
    public static string get_Cmd_RunCommandDescription();
    public static string get_Cmd_ShowHiddenSwitchDescription();
    public static string get_Cmd_StartCommandDefaultSwitchValueHint();
    public static string get_Cmd_StartCommandDescription();
    public static string get_Cmd_StopCommandDescription();
    public static string get_Cmd_Title();
    public static string get_Cmd_WaitTimeSwitchDescription();
    public static string get_Cmd_WaitTimeSwitchHint();
    public static string get_Cmd_WatchProcessSwitchDescription();
    public static string get_Cmd_WatchProcessSwitchHint();
    public static string Err_InvalidBufferSize(object param0);
    public static string Err_InvalidLoggerName(object param0);
    public static string Err_InvalidPid(object param0);
    public static string Err_LogFileInvalid(object param0);
    public static string get_Err_LogFileUnspecified();
    public static string get_Err_LoggerIsNotRunning();
    public static string get_Err_LoggerIsRunning();
    public static string Err_LoggerNameInUse(object param0);
    public static string get_Err_LoggerNameUnspecified();
    public static string get_Err_NoLogFileOrLoggerName();
    public static string get_Err_NoWorkerThreadsConfigured();
    public static string Err_TypeNameNotInCorrectFormat(object param0);
    public static string Err_UnableToCreateEvent(object param0);
    public static string Err_UnableToDeleteFile(object param0);
    public static string Err_UnableToLoadBufferHandler(object param0);
    public static string Err_UnableToLoadWorkerThread(object param0);
    public static string Err_WorkerInitializeFailed(object param0);
    public static string Msg_BufferInfo(object param0, object param1);
    public static string Msg_LoadedBufferHandler(object param0, object param1);
    public static string Msg_LoadedWorkerThread(object param0, object param1);
    public static string get_Msg_LoadingBufferHandlers();
    public static string get_Msg_LoadingWorkerThreads();
    public static string Msg_LogFilePath(object param0);
    public static string Msg_LoggerName(object param0);
    public static string get_Msg_StoppingLogger();
    public static string get_Wrn_CouldNotContactLogger();
    public static string get_Wrn_DeletingExistingLogFile();
    public static string Wrn_UnableToContactLogger(object param0);
    public static string get_Err_InternalError();
    public static string Err_UnableToCloseFile(object param0);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.LoggingConfig : object {
    private static string _cfgName;
    private string _loggerName;
    private int _fatalTimeout;
    private int _operationTimeout;
    private string _objectCreatePrefix;
    private string _objectOpenPrefix;
    private List`1<string> _allowedUsers;
    private bool _isBound;
    private ILoggingConfig _native;
    private MemoryMappedFile _publishedConfig;
    private IMessageMemory2 _memory;
    internal string MemoryMapName { get; }
    public string LoggerName { get; }
    public bool IsBound { get; }
    public bool IsReadOnly { get; }
    public int FatalTimeout { get; public set; }
    public int OperationTimeout { get; public set; }
    unknown bool EnableCrossSession {public set; }
    public IList`1<string> AllowedUsers { get; }
    internal ILoggingConfig Native { get; }
    internal EventWaitHandleSecurity EventWaitHandleSecurityDefault { get; }
    internal EventWaitHandleSecurity EventWaitHandleSecurityPublicSync { get; }
    internal EventWaitHandleRights EventWaitHandleRightsDefault { get; }
    internal EventWaitHandleRights EventWaitHandleRightsSyncOnly { get; }
    internal SecurityDescriptor MemorySecurityDescriptor { get; }
    public LoggingConfig(string loggerName);
    public LoggingConfig(string loggerName, _CollectionPlan collectionPlan);
    public static LoggingConfig Bind(string loggerName);
    private IList`1<string> BuildAllowedUserList(_CollectionPlan collectionPlan);
    internal string get_MemoryMapName();
    public string get_LoggerName();
    public bool get_IsBound();
    public bool get_IsReadOnly();
    public int get_FatalTimeout();
    public void set_FatalTimeout(int value);
    public int get_OperationTimeout();
    public void set_OperationTimeout(int value);
    public void set_EnableCrossSession(bool value);
    public IList`1<string> get_AllowedUsers();
    internal ILoggingConfig get_Native();
    internal EventWaitHandleSecurity get_EventWaitHandleSecurityDefault();
    internal EventWaitHandleSecurity get_EventWaitHandleSecurityPublicSync();
    internal EventWaitHandleRights get_EventWaitHandleRightsDefault();
    internal EventWaitHandleRights get_EventWaitHandleRightsSyncOnly();
    internal SecurityDescriptor get_MemorySecurityDescriptor();
    public void AddAllowedUsers(IList`1<string> sids);
    internal void Publish();
    public EventWaitHandle SecureEventWaitHandleCreate(bool initialState, EventResetMode mode, string name);
    public EventWaitHandle SecureEventWaitHandleOpen(string name);
    public EventWaitHandleSecurity EventWaitHandleGetBasicSecurity(IList`1<string> sids);
    public void AddSynchronizePermissionsToCurrentProcess();
    private static bool IsQualifiedObjectName(string name);
    public string GetObjectOpenName(string name);
    public string GetObjectCreateName(string name);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.LoggingResources : object {
    internal static ResourceManager ResourceManager;
    public static string GettingLoggerProcess { get; }
    public static string LoggerStartFailed { get; }
    public static string LoggerStarted { get; }
    public static string LoggerStopped { get; }
    public static string MsgError_ActionFailed { get; }
    public static string MsgError_ActionInProgress { get; }
    public static string MsgError_MessageHijacked { get; }
    public static string MsgError_ServerFault { get; }
    public static string MsgError_UnexpectedResponse { get; }
    public static string MsgError_UnknownRequest { get; }
    public static string NoLogFileEmptyFileName { get; }
    public static string NoLogFileSpecified { get; }
    public static string NoLogFileWildcards { get; }
    public static string NoLoggerName { get; }
    public static string StartingLogger { get; }
    public static string StoppingLogger { get; }
    public static string UnableToGetLoggerProcess { get; }
    public static string LaunchCommandDescription { get; }
    public static string ProfilerNotCorrectlyRegistered { get; }
    public static string UnableToLocateLoggerExecutable { get; }
    public static string LoggerExitUnexpectedly { get; }
    public static string HelpCommandDefaultSwitchValueHint { get; }
    public static string HelpCommandDescription { get; }
    public static string LaunchCommandDefaultSwitchValueHint { get; }
    public static string ProfilerLibraryLocked { get; }
    public static string ProfilerLockDiagnosticHeader { get; }
    private static LoggingResources();
    public static string BufferInfo(object param0, object param1);
    public static string Error(object param0);
    public static string Error_InvalidPID(object param0);
    public static string ErrorInConfiguration(object param0);
    public static string get_GettingLoggerProcess();
    public static string LogFilePath(object param0);
    public static string LoggerDidNotShutdownInTime(object param0);
    public static string get_LoggerStartFailed();
    public static string LoggerDidNotStart(object param0);
    public static string LoggerDidNotStartInTime(object param0);
    public static string LoggerName(object param0);
    public static string get_LoggerStarted();
    public static string get_LoggerStopped();
    public static string get_MsgError_ActionFailed();
    public static string get_MsgError_ActionInProgress();
    public static string MsgError_ErrorReportingError(object param0);
    public static string get_MsgError_MessageHijacked();
    public static string get_MsgError_ServerFault();
    public static string get_MsgError_UnexpectedResponse();
    public static string get_MsgError_UnknownRequest();
    public static string get_NoLogFileEmptyFileName();
    public static string get_NoLogFileSpecified();
    public static string get_NoLogFileWildcards();
    public static string get_NoLoggerName();
    public static string ShutdownEventCannotBeOpenedOrCreated(object param0);
    public static string ShutdownEventName(object param0);
    public static string ShutdownFileDetected(object param0);
    public static string SignalingEvent(object param0);
    public static string StartedEventCannotBeOpenedOrCreated(object param0);
    public static string StartedEventName(object param0);
    public static string get_StartingLogger();
    public static string get_StoppingLogger();
    public static string get_UnableToGetLoggerProcess();
    public static string UnrecognizedCommand(object param0);
    public static string Warning(object param0);
    public static string get_LaunchCommandDescription();
    public static string PressCtrlCToStopLogger(object param0);
    public static string get_ProfilerNotCorrectlyRegistered();
    public static string get_UnableToLocateLoggerExecutable();
    public static string get_LoggerExitUnexpectedly();
    public static string StartedEventCouldNotBeCreated(object param0);
    public static string get_HelpCommandDefaultSwitchValueHint();
    public static string get_HelpCommandDescription();
    public static string get_LaunchCommandDefaultSwitchValueHint();
    public static string get_ProfilerLibraryLocked();
    public static string get_ProfilerLockDiagnosticHeader();
}
internal abstract class Microsoft.VisualStudio.Diagnostics.Logging.LogStream : Stream {
    public int Index { get; }
    public long Start { get; }
    public int Handle { get; }
    public abstract virtual int get_Index();
    public abstract virtual long get_Start();
    public abstract virtual void SetStart(long value);
    public abstract virtual void Write(Byte* buffer, int count);
    public abstract virtual void Write(long position, Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer);
    public abstract virtual void Write(long position, Byte* buffer, int count);
    public abstract virtual int get_Handle();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.LogStreamEntry : object {
    [CompilerGeneratedAttribute]
private Guid <StreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartOffset>k__BackingField;
    public Guid StreamType { get; private set; }
    public int Index { get; private set; }
    public long Length { get; private set; }
    public long StartOffset { get; private set; }
    public LogStreamEntry(Guid streamType, int index, long length, long startOffset);
    [CompilerGeneratedAttribute]
public Guid get_StreamType();
    [CompilerGeneratedAttribute]
private void set_StreamType(Guid value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(long value);
    [CompilerGeneratedAttribute]
public long get_StartOffset();
    [CompilerGeneratedAttribute]
private void set_StartOffset(long value);
}
internal abstract class Microsoft.VisualStudio.Diagnostics.Logging.LogWorkerThread : object {
    private EventWaitHandle _shutdownEvent;
    private EventWaitHandle _shutdownRequestedEvent;
    private EventWaitHandle _shutdownReadyEvent;
    private bool _shuttingDown;
    private ThreadMailbox _mailbox;
    private Thread _thread;
    private LoggerEngine _engine;
    private WaitHandle[] modreq(System.Runtime.CompilerServices.IsVolatile) _eventHandles;
    private int _eventWaitTime;
    protected ThreadMailbox Mailbox { get; }
    public Thread Thread { get; }
    protected int EventWaitTime { get; protected set; }
    protected bool ShuttingDown { get; protected set; }
    protected ThreadMailbox get_Mailbox();
    public Thread get_Thread();
    public bool Initialize(LoggerEngine engine);
    public WaitHandle PrepForShutdown();
    public void Shutdown();
    protected int get_EventWaitTime();
    protected void set_EventWaitTime(int value);
    protected void SetEventHandles(WaitHandle[] customHandles);
    protected abstract virtual bool OnInitialize(LoggerEngine engine);
    protected abstract virtual void OnThreadStartup();
    protected abstract virtual void OnThreadEvent(int eventIndex);
    protected abstract virtual bool OnThreadMessage(ThreadMail message);
    protected abstract virtual void OnThreadShutdown();
    protected bool get_ShuttingDown();
    protected void set_ShuttingDown(bool value);
    protected virtual void OnPrepForShutdown();
    private void ThreadStart();
    private void OnThreadMessageDefault(ThreadMail mail);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.MemoryMappedFile : CriticalFinalizerObject {
    private SafeMapHandle mapHandle;
    private Byte* pointer;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    public Byte* Data { get; }
    public IntPtr PtrData { get; }
    public bool Disposed { get; private set; }
    public long Size { get; }
    public MemoryMappedFile(FileStream file, string name, Access desiredAccess);
    public MemoryMappedFile(long size, string name, Access desiredAccess);
    internal MemoryMappedFile(long size, string name, Access desiredAccess, IntPtr securityAttributes);
    public MemoryMappedFile(string name, Access desiredAccess);
    public MemoryMappedFile(string name, IntPtr baseAddress);
    private void Construct(SafeFileHandle handle, long size, string name, Access desiredAccess, IntPtr securityAttributes);
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public void Close();
    public Byte* get_Data();
    public IntPtr get_PtrData();
    [CompilerGeneratedAttribute]
public bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    public long get_Size();
}
public enum Microsoft.VisualStudio.Diagnostics.Logging.MessageImportance : Enum {
    public int value__;
    public static MessageImportance High;
    public static MessageImportance Normal;
    public static MessageImportance Low;
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.MeteredSection : object {
    private EventWaitHandle evt;
    private MeteredSectionShared* pShared;
    public MeteredSection(MeteredSectionShared* pShared, string name, short initialAvailable, short maximumAvailable, LoggingConfig loggingConfig, Boolean& createdNew);
    public MeteredSection(MeteredSectionShared* pShared, string name, LoggingConfig loggingConfig, Boolean& createdNew);
    public void Close();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Dispose(bool disposing);
    public void Enter();
    public bool Enter(int milliseconds);
    public int Leave();
    public int Leave(int releaseCount);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.MeteredSectionShared : ValueType {
    public int initialized;
    public int sectionData;
    public int maximumAvailable;
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.NamedCounter : object {
    private bool _disposed;
    private MemoryMappedFile _memory;
    private string _name;
    [CompilerGeneratedAttribute]
private AtomicInt64* <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private AtomicInt32* <InstrumentationDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private AtomicInt32* <ProbesDisabledForFunceval>k__BackingField;
    [CompilerGeneratedAttribute]
private AtomicInt32* <IntelliTraceToken>k__BackingField;
    public AtomicInt64* Ordinal { get; private set; }
    public AtomicInt32* InstrumentationDisabled { get; private set; }
    public AtomicInt32* ProbesDisabledForFunceval { get; private set; }
    public AtomicInt32* IntelliTraceToken { get; private set; }
    public string Name { get; }
    public bool Disposed { get; }
    private NamedCounter(string name, MemoryMappedFile memory);
    [CompilerGeneratedAttribute]
public AtomicInt64* get_Ordinal();
    [CompilerGeneratedAttribute]
private void set_Ordinal(AtomicInt64* value);
    [CompilerGeneratedAttribute]
public AtomicInt32* get_InstrumentationDisabled();
    [CompilerGeneratedAttribute]
private void set_InstrumentationDisabled(AtomicInt32* value);
    [CompilerGeneratedAttribute]
public AtomicInt32* get_ProbesDisabledForFunceval();
    [CompilerGeneratedAttribute]
private void set_ProbesDisabledForFunceval(AtomicInt32* value);
    [CompilerGeneratedAttribute]
public AtomicInt32* get_IntelliTraceToken();
    [CompilerGeneratedAttribute]
private void set_IntelliTraceToken(AtomicInt32* value);
    public static NamedCounter Create(string name, LoggingConfig loggingConfig);
    public static NamedCounter Open(string name, LoggingConfig loggingConfig);
    public static string GetCounterName(string name);
    public string get_Name();
    public bool get_Disposed();
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.NativeSecurityHelper : object {
    public static UInt32 FILE_MAP_READ;
    public static UInt32 FILE_MAP_WRITE;
    public static UInt32 ERROR_INSUFFICIENT_BUFFER;
    public static UInt32 STANDARD_RIGHTS_REQUIRED;
    public static UInt32 SYNCHRONIZE;
    public static UInt32 FILE_ALL_ACCESS;
    public static UInt32 LPTR;
    public static UInt32 SECURITY_DESCRIPTOR_REVISION;
    public static UInt32 NO_INHERITANCE;
    public static string SDDL_ACCESS_ALLOWED;
    public static UInt32 SDDL_REVISION_1;
    public static Void* LocalAlloc(UInt32 uFlags, UIntPtr uBytes);
    public static Void* LocalFree(Void* hMem);
    public static Void* LocalFree(IntPtr hMem);
    public static bool InitializeSecurityDescriptor(IntPtr pSecurityDescriptor, UInt32 dwRevision);
    public static bool SetSecurityDescriptorDacl(IntPtr pSecurityDescriptor, bool daclPresent, Void* pDacl, bool daclDefaulted);
    public static bool GetSecurityDescriptorDacl(IntPtr pSecurityDescriptor, Boolean& lpbDaclPresent, IntPtr& pDacl, Boolean& lpbDaclDefaulted);
    public static bool ConvertStringSidToSidW(string StringSid, Void*& Sid);
    public static bool LookupAccountSidW(string lpSystemName, Void* Sid, StringBuilder Name, UInt32& cchName, StringBuilder ReferencedDomainName, UInt32& cchReferencedDomainName, SID_NAME_USE& peUse);
    public static UInt32 SetEntriesInAcl(UInt32 cCountOfExplicitEntries, EXPLICIT_ACCESS* pListOfExplicitEntries, Void* OldAcl, Void*& NewAcl);
    public static bool ConvertStringSecurityDescriptorToSecurityDescriptorW(string StringSecurityDescriptor, UInt32 StringSDRevision, IntPtr& SecurityDescriptor, IntPtr SecurityDescriptorSize);
    public static bool ConvertSecurityDescriptorToStringSecurityDescriptorW(IntPtr SecurityDescriptor, UInt32 RequestedStringSDRevision, SECURITY_INFORMATION SecurityInformation, Char*& StringSecurityDescriptor, Int32& StringSecurityDescriptorLen);
    internal static string CreateSDAce(string sidStr, UInt32 accessMask);
    internal static void CreateSecurityDescriptor(UInt32 accessMask, IList`1<string> allowedSids, IntPtr& securityDescriptor);
    public static int GetSecurityInfo(IntPtr handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, IntPtr ppSidOwner, IntPtr ppSidGroup, IntPtr ppDacl, IntPtr ppSacl, IntPtr& pSecurityDescriptor);
    public static int SetSecurityInfo(IntPtr handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, IntPtr psidOwner, IntPtr psidGroup, IntPtr pDacl, IntPtr pSacl);
    internal static void AddSynchronizePermissionsToCurrentProcess(IList`1<string> allowedSids);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.NullOutputter : ErrorTrackingOutputter {
}
public class Microsoft.VisualStudio.Diagnostics.Logging.OutputErrorEventArgs : OutputEventArgs {
    private string _code;
    public string Code { get; }
    public OutputErrorEventArgs(string message);
    public OutputErrorEventArgs(string message, string code);
    public string get_Code();
}
public abstract class Microsoft.VisualStudio.Diagnostics.Logging.OutputEventArgs : EventArgs {
    private string _message;
    private int _threadId;
    private DateTime _timestamp;
    public string Message { get; }
    public int ThreadId { get; }
    public DateTime Timestamp { get; }
    protected OutputEventArgs(string message);
    public string get_Message();
    public int get_ThreadId();
    public DateTime get_Timestamp();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.OutputHelper : object {
    private IOutputter _outputter;
    private bool _hasOutputErrors;
    public IOutputter Outputter { get; }
    public bool HasOutputErrors { get; }
    public OutputHelper(IOutputter outputter);
    public IOutputter get_Outputter();
    public void Message();
    public void Message(string message);
    public void Message(MessageImportance importance, string message);
    public void Message(string message, Object[] messageArgs);
    public void Message(MessageImportance importance, string message, Object[] messageArgs);
    public void Error(string message);
    public void Error(string message, Object[] messageArgs);
    public void Warning(string message);
    public void Warning(string message, Object[] messageArgs);
    public bool get_HasOutputErrors();
    public IList`1<string> GetErrors();
}
public class Microsoft.VisualStudio.Diagnostics.Logging.OutputMessageEventArgs : OutputEventArgs {
    private MessageImportance importance;
    public MessageImportance Importance { get; }
    public OutputMessageEventArgs(string message, MessageImportance importance);
    public MessageImportance get_Importance();
}
public class Microsoft.VisualStudio.Diagnostics.Logging.OutputWarningEventArgs : OutputEventArgs {
    private string _code;
    public string Code { get; }
    public OutputWarningEventArgs(string message);
    public OutputWarningEventArgs(string message, string code);
    public string get_Code();
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.PerfCounters : object {
    public static bool TraceEnabled;
    private static PerfCounters();
    public static void CreateCategories();
    public static void DeleteCategories();
}
[AttributeUsageAttribute("384")]
internal class Microsoft.VisualStudio.Diagnostics.Logging.PerformanceCounterAttribute : Attribute {
    private string _Instance;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public string Instance { get; public set; }
    public PerformanceCounterAttribute(string Name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public string get_Instance();
    public void set_Instance(string value);
}
[AttributeUsageAttribute("12")]
internal class Microsoft.VisualStudio.Diagnostics.Logging.PerformanceCounterCategoryAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Help>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceCounterCategoryType <Type>k__BackingField;
    public string Name { get; private set; }
    public string Help { get; private set; }
    public PerformanceCounterCategoryType Type { get; private set; }
    public PerformanceCounterCategoryAttribute(string Name, string Help, PerformanceCounterCategoryType Type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Help();
    [CompilerGeneratedAttribute]
private void set_Help(string value);
    [CompilerGeneratedAttribute]
public PerformanceCounterCategoryType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(PerformanceCounterCategoryType value);
}
[AttributeUsageAttribute("12")]
internal class Microsoft.VisualStudio.Diagnostics.Logging.PerformanceCounterDefAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Help>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceCounterType <Type>k__BackingField;
    public string Name { get; private set; }
    public string Help { get; private set; }
    public PerformanceCounterType Type { get; private set; }
    public PerformanceCounterDefAttribute(string Name, string Help, PerformanceCounterType Type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Help();
    [CompilerGeneratedAttribute]
private void set_Help(string value);
    [CompilerGeneratedAttribute]
public PerformanceCounterType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(PerformanceCounterType value);
}
[AttributeUsageAttribute("384")]
internal class Microsoft.VisualStudio.Diagnostics.Logging.PerformanceCounterInstanceNameAttribute : Attribute {
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.PerformanceCounterUtility : object {
    public static void CreatePerformanceCategories(Assembly assembly);
    public static void CreatePerformanceCategory();
    public static void DeletePerformanceCategories(Assembly assembly);
    public static void DeletePerformanceCategory();
    public static void CreatePerformanceCounters();
    public static void CreatePerformanceCounters(T instance);
    private static void CreatePerformanceCategory(Type type);
    private static void DeletePerformanceCategory(Type type);
    private static void CreatePerformanceCounters(Type type, object instance);
    private static CounterCreationData GetCreationData(PerformanceCounterDefAttribute counter);
    private static CounterCreationData GetBaseCreationData(CounterCreationData data);
    private static bool CounterRequiresBase(PerformanceCounterType counterType);
    private static string GetBaseCounterName(string name);
    private static string GetBaseMemberName(string name);
    private static void SetMemberValue(MemberInfo member, object instance, object value);
    private static object GetMemberValue(MemberInfo member, object instance);
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.ProfilerInterop : object {
    private static int RmRebootReasonNone;
    private static int CCH_RM_MAX_APP_NAME;
    private static int CCH_RM_MAX_SVC_NAME;
    private static int ERROR_MORE_DATA;
    private static IInteropInterface _interopInterface;
    private static NativeGetProteusSystemInfo getProteusSystemInfo;
    private static NativeFreeProteusSystemInfo freeProteusSystemInfo;
    private static NativeTryCanRead TryCanRead;
    private static NativeTryCanWrite TryCanWrite;
    private static NativeTryCanExecute TryCanExecute;
    private static string traceLogProfilerDll;
    private static string traceLogProfiler64Dll;
    private static string traceLogProfilerArm64Dll;
    private static string traceLogProfilerClsid;
    private static List`1<ProfilerLoadInfo> _profilerLoadInfo;
    internal static IInteropInterface InteropInterface { get; }
    private static ProfilerInterop();
    internal static IInteropInterface get_InteropInterface();
    internal static Byte* GetProteusSystemInfoMessage(int processId, Int32& sysInfoLen);
    internal static void FreeProteusSystemInfoMessage(Byte* pSystemInfo);
    internal static bool UserCanReadFile(string fileLocation, SecurityIdentifier sid);
    internal static bool UserCanWriteFile(string fileLocation, SecurityIdentifier sid);
    internal static bool UserCanExecuteFile(string fileLocation, SecurityIdentifier sid);
    private static IntPtr TryLoadProfilerDll(string candidatePath);
    private static Delegate GetFunctionDelegate(IntPtr pDll, string functionName, Type delegateType);
    private static void ThrowInvariantExceptionOnZeroPtr(IntPtr ptr, string message);
    private static void ThrowSpecializedException(int errorCode, string message);
    private static void WriteToEventLog(string source, string message, EventLogEntryType entryType);
    private static bool IsArm64Devenv();
    private static void InitInterop();
    private static IntPtr LoadProfilerNextToAssembly(StringBuilder diagnosticInformation, string profilerFileName);
    private static IntPtr LoadProfilerNextToProcess(StringBuilder diagnosticInformation, string profilerFileName);
    private static IntPtr LoadProfilerFromIntelliTraceFolder(StringBuilder diagnosticInformation, string profilerFileName);
    private static bool IsRestartManagerMethodsPresent();
    public static IList`1<Process> GetProcessesUsingFiles(String[] filePaths);
    private static string GetProcessHierarchy(IList`1<int> pids);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.QueuedIpcDispatcher : LogWorkerThread {
    private QueuedIpcPipeServer ipc;
    private LoggerEngine logger;
    private ThreadMail suspendMail;
    private Dictionary`2<int, LogStream> streams;
    private Byte[] writeBuffer;
    private IMessageMemory2 _memory;
    private static int _ipcMaxEntrySize;
    private static int _ipcMaxEntries;
    public string ServerName { get; }
    private bool ContinueOnDiskFullException { get; }
    protected virtual bool OnInitialize(LoggerEngine logger);
    protected virtual void OnThreadStartup();
    protected virtual void OnThreadEvent(int eventIndex);
    protected virtual void OnThreadShutdown();
    protected virtual bool OnThreadMessage(ThreadMail mail);
    public string get_ServerName();
    private void OnClose(int clientId);
    private void OnConnectRequest(int clientId, Handle hrequest);
    private void OnReadRequest(int clientId, Handle hrequest);
    private void OnFlushRequest(int clientId);
    private void OnGetLengthRequest(int clientId);
    private void OnGetStartRequest(int clientId);
    private void OnOverwrite(int clientId, Handle hrequest);
    private void OnWrite(int clientId, Handle hrequest);
    private void OnServerFault(int clientId, Exception ex);
    private LogStream GetStream(int clientId);
    private LogStream OpenStream(int streamIndex, StreamAccess mode);
    private bool get_ContinueOnDiskFullException();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.QueuedIpcEntry : ValueType {
    internal Byte* _data;
    internal int _length;
    private IMessageIPC _ipc;
    public Byte* Data { get; }
    public IntPtr PtrData { get; }
    public int Length { get; }
    public bool HasData { get; }
    internal QueuedIpcEntry(IMessageIPC ipc);
    public Byte* get_Data();
    public IntPtr get_PtrData();
    public int get_Length();
    public bool Remove();
    public void SkipData(int skip);
    public sealed virtual void Dispose();
    public bool get_HasData();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.QueuedIpcException : Exception {
    public QueuedIpcException(string message);
    public QueuedIpcException(string message, Exception innerException);
    protected QueuedIpcException(SerializationInfo info, StreamingContext context);
}
internal abstract class Microsoft.VisualStudio.Diagnostics.Logging.QueuedIpcPipe : object {
    protected object _thisLock;
    [CompilerGeneratedAttribute]
private LoggingConfig <LoggingConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PipeName>k__BackingField;
    private static int _systemPageSize;
    protected LoggingConfig LoggingConfig { get; protected set; }
    public string PipeName { get; }
    public static int SystemPageSize { get; }
    protected QueuedIpcPipe(LoggingConfig loggingConfig, string pipeName);
    [CompilerGeneratedAttribute]
protected LoggingConfig get_LoggingConfig();
    [CompilerGeneratedAttribute]
protected void set_LoggingConfig(LoggingConfig value);
    [CompilerGeneratedAttribute]
public string get_PipeName();
    protected static string ServerName(string pipeName);
    protected static string NewClientName(string pipeName);
    protected static string ClientConnectedEventName(string clientName);
    protected static string MutexName(string mutexName);
    internal static bool AddMessage(IMessageIPC ipc, int timeout, Byte* data, int msgLen);
    internal static bool AddMessage(IMessageIPC ipc, int timeout, Byte* data1, Byte* data2, int msgLen1, int msgLen2);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public static int get_SystemPageSize();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.QueuedIpcPipeClient : QueuedIpcPipe {
    private IMessageIPC _readIpc;
    private IMessageIPC _writeIpc;
    private int _streamId;
    private IMessageMemory2 _memory;
    private int _msgLen;
    private MsgHandle _messageHeader;
    private string _clientName;
    private EventWaitHandle _createdEvent;
    private EventWaitHandle _notEmptyEvent;
    private bool _waitForConnectAttempted;
    private Mutex _serverMutex;
    private Mutex ServerMutex { get; }
    public int MaxWriteSize { get; }
    public int MaxReadSize { get; }
    public QueuedIpcPipeClient(string pipeName, LoggingConfig loggingConfig);
    private Mutex get_ServerMutex();
    public void Add(Byte* data, int msgLen);
    public QueuedIpcEntry LockAndRemove();
    public void Close();
    public int get_MaxWriteSize();
    public int get_MaxReadSize();
    protected virtual void Dispose(bool disposing);
    private void CloseIPCs();
    private void CheckIfClosed();
    private void Close(bool sendCloseMessage);
    private void WaitForConnect();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.Diagnostics.Logging.QueuedIpcPipeMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static QueuedIpcPipeMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static QueuedIpcPipeMessagePacker Default { get; private set; }
    public QueuedIpcPipeMessagePacker(MessageInfo mi);
    private static QueuedIpcPipeMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static QueuedIpcPipeMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(QueuedIpcPipeMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageClientClose(Token* pToken, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageClientClose(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageClientClose(_Token token, IMessageMemory2 memory, Int32& msgLen);
    public _Token UnpackMessageClientCloseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _Token UnpackMessageClientCloseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageClientMessage(Token* pToken, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageClientMessage(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageClientMessage(_Token token, IMessageMemory2 memory, Int32& msgLen);
    public _Token UnpackMessageClientMessageToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _Token UnpackMessageClientMessageToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageConnectRequest(IpcName* pIpcName, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageConnectRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageConnectRequest(_IpcName ipcName, IMessageMemory2 memory, Int32& msgLen);
    public _IpcName UnpackMessageConnectRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _IpcName UnpackMessageConnectRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageConnectResponse(Token* pToken, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageConnectResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageConnectResponse(_Token token, IMessageMemory2 memory, Int32& msgLen);
    public _Token UnpackMessageConnectResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _Token UnpackMessageConnectResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageServerClose(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageServerClose(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageServerMessage(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageServerMessage(Byte* pMsg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.QueuedIpcPipeServer : QueuedIpcPipe {
    private IMessageIPC _readIpc;
    private Dictionary`2<int, IMessageIPC> _writeIpc;
    private int _lastId;
    private MsgHandle _messageHeader;
    private int _msgLen;
    private IMessageMemory2 _memory;
    private EventWaitHandle _notEmptyEvent;
    private Mutex _serverMutex;
    public WaitHandle NotEmptyEvent { get; }
    public int MaxReadSize { get; }
    public bool HasMessages { get; }
    public QueuedIpcPipeServer(string pipeName, int maxEntrySize, int entries, LoggingConfig loggingConfig);
    public WaitHandle get_NotEmptyEvent();
    public QueuedIpcEntry LockAndRemove(Int32& clientId);
    public void Add(int clientId, Byte* data, int msgLen);
    public void Close();
    public void Close(int clientId);
    public int get_MaxReadSize();
    public bool get_HasMessages();
    private int GetNextId();
    private void OnClose(int clientId);
    private void OnClientConnect(_IpcName request);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.QueuedIpcStream : LogStream {
    private RemoteTraceDebugLogFile _remoteTraceLogFile;
    private QueuedIpcPipeClient _ipc;
    private int _streamIndex;
    private int _streamHandle;
    private long _position;
    private StreamAccess _mode;
    private object _thisLock;
    private int _pendingReplies;
    private IMessageMemory2 _memory;
    private long _cachedStart;
    private long _cachedLength;
    private bool _inSuspendMode;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public long Start { get; }
    public int Index { get; }
    public int Handle { get; }
    public QueuedIpcStream(RemoteTraceDebugLogFile remoteTraceLogFile, string serverName, int streamIndex, StreamAccess mode, LoggingConfig loggingConfig);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(long position, Byte[] buffer, int offset, int count);
    private QueuedIpcEntry RequestAndWaitForResponse(Byte* pMsg, int msgLen);
    private void AssertCorrectResponse(Byte* pData, MessageID expectedMsgID);
    internal void EnterSuspendMode();
    internal void LeaveSuspendMode();
    public virtual long get_Start();
    public virtual void SetStart(long value);
    public virtual int get_Index();
    public virtual int get_Handle();
    public virtual void Write(long position, Byte* buffer, int count);
    public virtual void Write(Byte* buffer, int count);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.RemoteOutputter : MarshalByRefObject {
    private IOutputter _innerOutputter;
    private IChannel _remotingChannel;
    private string _remotingUrl;
    private object _thislock;
    public string RemotingUrl { get; }
    public RemoteOutputter(IOutputter outputter);
    public RemoteOutputter(string remotingUrl);
    public string get_RemotingUrl();
    public sealed virtual void Dispose();
    private void TryRemoteAction(Action`1<T> action);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IOutputter.OutputErrorEvent(OutputErrorEventArgs e);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IOutputter.OutputMessageEvent(OutputMessageEventArgs e);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IOutputter.OutputWarningEvent(OutputWarningEventArgs e);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.Resources : object {
    internal static ResourceManager ResourceManager;
    public static string Cmd_CollectionPlanSwitchDescription { get; }
    public static string Cmd_CollectionPlanSwitchHint { get; }
    public static string Cmd_InstrumentEnabledSwitchDescription { get; }
    public static string Cmd_InstrumentSwitchDescription { get; }
    public static string Cmd_InstrumentSwitchHint { get; }
    public static string Cmd_LaunchCommandDefaultSwitchValueHint { get; }
    public static string Cmd_LaunchCommandDescription { get; }
    public static string Cmd_ModuleSwitchDescription { get; }
    public static string Cmd_ModuleSwitchHint { get; }
    public static string Cmd_StatusCommandDescription { get; }
    public static string Cmd_StatisticsCommandDescription { get; }
    public static string Err_NoLogFileOrLoggerName { get; }
    public static string FileNameToExecuteNotSpecified { get; }
    public static string MsgError_ActionFailed { get; }
    public static string MsgError_ActionInProgress { get; }
    public static string MsgError_UnknownRequest { get; }
    public static string WaitingForProcessExit { get; }
    private static Resources();
    public static string get_Cmd_CollectionPlanSwitchDescription();
    public static string get_Cmd_CollectionPlanSwitchHint();
    public static string get_Cmd_InstrumentEnabledSwitchDescription();
    public static string get_Cmd_InstrumentSwitchDescription();
    public static string get_Cmd_InstrumentSwitchHint();
    public static string get_Cmd_LaunchCommandDefaultSwitchValueHint();
    public static string get_Cmd_LaunchCommandDescription();
    public static string get_Cmd_ModuleSwitchDescription();
    public static string get_Cmd_ModuleSwitchHint();
    public static string get_Cmd_StatusCommandDescription();
    public static string get_Cmd_StatisticsCommandDescription();
    public static string Error(object param0);
    public static string get_Err_NoLogFileOrLoggerName();
    public static string get_FileNameToExecuteNotSpecified();
    public static string get_MsgError_ActionFailed();
    public static string get_MsgError_ActionInProgress();
    public static string MsgError_ErrorReportingError(object param0);
    public static string get_MsgError_UnknownRequest();
    public static string ProcessExitedWithExitCode(object param0);
    public static string ProcessFailedToStart(object param0);
    public static string ProcessNotFound(object param0);
    public static string ProcessRunTime(object param0);
    public static string StartingProcess(object param0);
    public static string get_WaitingForProcessExit();
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.SecureEventWaitHandle : object {
    public static EventWaitHandle Create(bool initialState, EventResetMode mode, string name, EventWaitHandleSecurity security, EventWaitHandleRights rights, LoggingConfig loggingConfig);
    public static EventWaitHandle Open(string name, EventWaitHandleRights rights, LoggingConfig loggingConfig);
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.SecureMemoryMappedFile : object {
    public static UInt32 DefaultAccessMask;
    private static SecureMemoryMappedFile();
    public static MemoryMappedFile Create(long size, string name, LoggingConfig loggingConfig);
    public static MemoryMappedFile Open(string name, LoggingConfig loggingConfig);
}
internal static class Microsoft.VisualStudio.Diagnostics.Logging.SecureMutex : object {
    public static Mutex CreateOrOpenMutex(bool initiallyOwned, string name, bool adminExclusive);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.SecurityDescriptor : SafeHandle {
    private IntPtr _pSD;
    public bool IsInvalid { get; }
    public SecurityDescriptor(UInt32 accessMask, IList`1<string> allowedSids);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    public IntPtr GetSecurityDescriptor();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.SharedResources : object {
    internal static ResourceManager ResourceManager;
    public static string Debug { get; }
    public static string EntryIsTooLargeToEverFitInQueue { get; }
    public static string LogoCopyright { get; }
    public static string ServerFaultError { get; }
    public static string err_file_accessMode { get; }
    public static string err_file_bufferPageAlign { get; }
    public static string err_file_bufferPageSize { get; }
    public static string err_file_countSectorSize { get; }
    public static string err_file_pendingTransfers { get; }
    public static string err_file_posSectorAlign { get; }
    public static string err_file_readOnly { get; }
    public static string ERR_LOG_Corrupt { get; }
    public static string ERR_LOG_UnknownFormat { get; }
    public static string ERR_LOG_VersionIncompatible { get; }
    public static string ERR_LOG_File_Full { get; }
    public static string ipc_ConnectionClosed { get; }
    public static string ipc_UnderlyingTransportError { get; }
    public static string ipc_UnexpectedResponse { get; }
    public static string ipc_MessageHasBeenHijacked { get; }
    public static string cfg_AlreadyBound { get; }
    public static string ReturnValue { get; }
    private static SharedResources();
    public static string get_Debug();
    public static string get_EntryIsTooLargeToEverFitInQueue();
    public static string get_LogoCopyright();
    public static string get_ServerFaultError();
    public static string err_file_networkDrive(object param0, object param1);
    public static string get_err_file_accessMode();
    public static string get_err_file_bufferPageAlign();
    public static string get_err_file_bufferPageSize();
    public static string get_err_file_countSectorSize();
    public static string err_file_maxTransfer(object param0);
    public static string get_err_file_pendingTransfers();
    public static string get_err_file_posSectorAlign();
    public static string get_err_file_readOnly();
    public static string err_file_accessDenied(object param0);
    public static string err_file_cannotOpen(object param0);
    public static string get_ERR_LOG_Corrupt();
    public static string get_ERR_LOG_UnknownFormat();
    public static string get_ERR_LOG_VersionIncompatible();
    public static string err_thread_has_no_streams(object param0);
    public static string get_ERR_LOG_File_Full();
    public static string get_ipc_ConnectionClosed();
    public static string ipc_NameInUse(object param0);
    public static string get_ipc_UnderlyingTransportError();
    public static string get_ipc_UnexpectedResponse();
    public static string get_ipc_MessageHasBeenHijacked();
    public static string get_cfg_AlreadyBound();
    public static string get_ReturnValue();
    public static string err_stream_StreamNotFoundByIndex(object param0);
    public static string err_stream_StreamNotFoundByType(object param0);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.SList : object {
    public static UInt32 EolMarker;
    private Header* modreq(System.Runtime.CompilerServices.IsVolatile) pHeader;
    private Item* pItemBase;
    private UInt32 memorySize;
    public static int ReservedPerItemBytes { get; }
    public static int HeaderBytes { get; }
    public SList(IntPtr header, IntPtr itemBase, int memorySize);
    public static int get_ReservedPerItemBytes();
    public static int get_HeaderBytes();
    public void Initialize();
    public bool IsEmpty();
    public void Push(Byte* item);
    public Byte* Pop();
    public IntPtr Grab();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.SpinWait : ValueType {
    private static bool s_isSingleProc;
    private static int s_yieldFrequency;
    private static int s_yieldOneFrequency;
    private int m_count;
    private static SpinWait();
    public bool Spin();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.StartQueuedIpcDispatcherEventArgs : EventArgs {
    public QueuedIpcDispatcher Dispatcher;
    public StartQueuedIpcDispatcherEventArgs(QueuedIpcDispatcher dispatcher);
}
internal enum Microsoft.VisualStudio.Diagnostics.Logging.StreamAccess : Enum {
    public int value__;
    public static StreamAccess Read;
    public static StreamAccess ReadWrite;
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.StreamCacheKey : object {
    public Type type;
    public int index;
    public ulong offset;
    private int hashCode;
    public StreamCacheKey(Type type, int index, ulong offset);
    public virtual int GetHashCode();
    private sealed virtual override bool System.IEquatable<Microsoft.VisualStudio.Diagnostics.Logging.StreamCacheKey>.Equals(StreamCacheKey other);
}
internal enum Microsoft.VisualStudio.Diagnostics.Logging.StreamShare : Enum {
    public int value__;
    public static StreamShare ReadWrite;
    public static StreamShare ReadAppend;
    public static StreamShare Exclusive;
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.SuccessMessage : object {
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.SystemEventLogOutputter : object {
    private NonThrowingEventLog _eventLog;
    public sealed virtual void OutputErrorEvent(OutputErrorEventArgs e);
    public sealed virtual void OutputWarningEvent(OutputWarningEventArgs e);
    public sealed virtual void OutputMessageEvent(OutputMessageEventArgs e);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.ThreadMail : object {
    private ThreadMailbox _from;
    private string _to;
    private object _body;
    private ThreadMail _replyTo;
    internal ThreadMailbox From { get; }
    public string To { get; }
    public object Body { get; }
    public ThreadMail ReplyTo { get; }
    internal ThreadMail(ThreadMailbox from, string to, object body, ThreadMail replyTo);
    internal ThreadMailbox get_From();
    public string get_To();
    public object get_Body();
    public ThreadMail get_ReplyTo();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.ThreadMailbox : object {
    private ThreadMailDispatcher dispatcher;
    private EventWaitHandle waitHandle;
    private Queue`1<ThreadMail> queue;
    private bool disposed;
    public WaitHandle NotEmptyEvent { get; }
    internal ThreadMailbox(ThreadMailDispatcher dispatcher);
    public WaitHandle get_NotEmptyEvent();
    public void Deliver(ThreadMail message);
    public ThreadMail Receive();
    public int Send(ThreadMail message);
    public void Subscribe(string service);
    public void Unsubscribe(string service);
    public ThreadMail Pack(object message);
    public ThreadMail Pack(string to, object message);
    public ThreadMail Pack(ThreadMail replyTo, object message);
    internal void Register();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private void CheckDisposed();
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.ThreadMailDispatcher : object {
    private List`1<ThreadMailbox> mailBoxes;
    private Dictionary`2<string, List`1<ThreadMailbox>> mailLists;
    internal void Subscribe(ThreadMailbox mbox, string service);
    internal void Unsubscribe(ThreadMailbox mbox, string service);
    internal int Dispatch(ThreadMail message);
    internal void Register(ThreadMailbox mbox);
    internal void Unregister(ThreadMailbox mbox);
}
public class Microsoft.VisualStudio.Diagnostics.Logging.TraceOutputter : ErrorTrackingOutputter {
    public virtual void OutputErrorEvent(OutputErrorEventArgs e);
    public virtual void OutputMessageEvent(OutputMessageEventArgs e);
    public virtual void OutputWarningEvent(OutputWarningEventArgs e);
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.TrimLogEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private TrimLogReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrimSucceeded>k__BackingField;
    public TrimLogReason Reason { get; public set; }
    public bool TrimSucceeded { get; public set; }
    public TrimLogEventArgs(TrimLogReason reason);
    [CompilerGeneratedAttribute]
public TrimLogReason get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(TrimLogReason value);
    [CompilerGeneratedAttribute]
public bool get_TrimSucceeded();
    [CompilerGeneratedAttribute]
public void set_TrimSucceeded(bool value);
}
internal enum Microsoft.VisualStudio.Diagnostics.Logging.TrimLogReason : Enum {
    public int value__;
    public static TrimLogReason Unknown;
    public static TrimLogReason SpaceRequired;
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.UnbufferedFile : object {
    private SafeFileHandle modreq(System.Runtime.CompilerServices.IsVolatile) handle;
    private int asyncTransfers;
    private long length;
    private long realLength;
    private ulong reserveIncrement;
    private ulong maxSize;
    private Stack`1<EventWaitHandle> waitHandles;
    private object thisLock;
    private CodedExceptionHelper errorHelper;
    private static ulong INVALID_OFFSET;
    public static int MaxTransferSize;
    public UInt32 SectorSize;
    public static UInt32 PageSize;
    public UnbufferedFileMode Mode;
    public ulong Length { get; private set; }
    public ulong ReserveIncrement { get; }
    private ulong RealLength { get; private set; }
    private static UnbufferedFile();
    public UnbufferedFile(string fileName, UnbufferedFileMode mode);
    public UnbufferedFile(string fileName, UnbufferedFileMode mode, ulong maxSize, ulong reserveIncrement);
    public UInt32 Read(ulong filePos, UInt32 count, Byte*[] buffers);
    public UInt32 Write(ulong filePos, UInt32 count, Byte*[] buffers, UInt32 buffOffset, UInt32 buffCount);
    public UInt32 Write(ulong filePos, UInt32 count, Byte*[] buffers);
    public IAsyncResult BeginRead(ulong filePos, UInt32 count, Byte*[] buffers);
    public UInt32 EndRead(IAsyncResult result);
    public IAsyncResult BeginWrite(ulong filePos, UInt32 count, Byte*[] buffers);
    public UInt32 EndWrite(IAsyncResult result);
    public void Flush();
    public void Close();
    public void Extend(ulong count, UInt64& extentOffset, UInt64& extentCount);
    public static bool IsOnNetworkDrive(string fileName);
    public void SetZeroData(ulong offset, ulong count);
    public ulong get_Length();
    private void set_Length(ulong value);
    public ulong get_ReserveIncrement();
    private ulong get_RealLength();
    private void set_RealLength(ulong value);
    private void ExtendIfNeeded(ulong offset, ulong count, UInt64& extentOffset, UInt64& extentCount);
    private FILE_SEGMENT_ELEMENT[] CreateFileSegments(Byte*[] buffers, UInt32 count);
    private IAsyncResult BeginTransfer(ScatterGatherOp transferFunc, ulong filePos, UInt32 count, Byte*[] buffers);
    private IAsyncResult BeginOverlapped(ulong filePos, ulong count, OverlappedOp op);
    private ulong EndOverlapped(IAsyncResult iasync);
    private void CheckNotDisposed();
    private void CheckWriteable();
    private void SetLength(ulong length);
    private ulong GetLength();
    private static string GetFileMountPoint(string fileName);
    private bool HasFlag(UnbufferedFileMode flags, UnbufferedFileMode flag);
    private static void ThrowWin32ExceptionOfType(int win32Error);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Diagnostics.Logging.UnbufferedFileMode : Enum {
    public int value__;
    public static UnbufferedFileMode Read;
    public static UnbufferedFileMode Write;
    public static UnbufferedFileMode Truncate;
    public static UnbufferedFileMode Create;
    public static UnbufferedFileMode Exclusive;
    public static UnbufferedFileMode DeleteOnClose;
    public static UnbufferedFileMode ReadWrite;
    public static UnbufferedFileMode CreateExclusive;
    public static UnbufferedFileMode OverwriteExisting;
}
internal class Microsoft.VisualStudio.Diagnostics.Logging.WaitableTimer : WaitHandle {
    private bool _autoReset;
    public WaitableTimer(bool autoReset);
    public void Set(int msDelay);
    public void Cancel();
}
internal static class Microsoft.VisualStudio.Enterprise.Common.NativeMethods : object {
    internal static UInt32 PROCESS_QUERY_LIMITED_INFORMATION;
    internal static UInt32 SYNCHRONIZE;
    internal static int WM_QUERYENDSESSION;
    internal static int WM_CLOSE;
    internal static UInt32 HKEY_LOCAL_MACHINE;
    internal static int KEY_WOW64_64KEY;
    internal static int KEY_READ;
    public static int GetCurrentThreadId();
    internal static int CloseHandle(IntPtr h);
    internal static int CloseHandle(UIntPtr h);
    internal static IntPtr OpenProcess(UInt32 dwDesiredAccess, bool bInheritHandle, UInt32 dwProcessId);
    internal static bool OpenProcessToken(IntPtr hProc, UInt32 dwDesiredAccess, IntPtr& hToken);
    internal static bool CreateEnvironmentBlock(IntPtr& env, IntPtr hToken, int fInherit);
    internal static bool DestroyEnvironmentBlock(IntPtr henv);
    public static bool PostMessage(HandleRef hwnd, int msg, IntPtr wparam, IntPtr lparam);
    public static IntPtr SendMessageTimeout(HandleRef hWnd, UInt32 Msg, UIntPtr wParam, UIntPtr lParam, SendMessageTimeoutFlags fuFlags, UInt32 uTimeout, UIntPtr& lpdwResult);
    public static int EnumWindows(EnumWindowsCallback callback, IntPtr lparam);
    public static UInt32 GetWindowThreadProcessId(IntPtr hwnd, Int32& pid);
    public static bool IsWindow(IntPtr hWnd);
    internal static bool Succeeded(UInt32 hr);
    internal static bool Succeeded(int hr);
    internal static int RegOpenKeyExW(UIntPtr hKey, string subKey, UInt32 options, int sam, UIntPtr& phkResult);
    internal static int RegCloseKey(UIntPtr pHkey);
    internal static int RegQueryValueExW(UIntPtr hkey, string lpValueName, IntPtr lpReserved, UInt32& lpType, Int32& pdwData, UInt32& pcbData);
    internal static int RegQueryValueExW(UIntPtr hkey, string lpValueName, IntPtr lpReserved, UInt32& lpType, Byte[] chars, UInt32& pcbData);
    internal static bool IsWow64Process(UIntPtr hProcess, Boolean& wow64Process);
    internal static UIntPtr GetCurrentProcess();
    internal static bool GetProcessTimes(IntPtr hProcess, FILETIME& lpCreationTime, FILETIME& lpExitTime, FILETIME& lpKernelTime, FILETIME& lpUserTime);
}
internal static class Microsoft.VisualStudio.Enterprise.WebInstrument.ApplicationPoolUtility : object {
    private static string BuildInfoFileName;
    public static void ContactAppPoolsViaWebRequest(IEnumerable`1<string> pools);
    public static string GetBuildConfigInfoPath(string webSiteName, string applicationName);
    private static IEnumerable`1<string> UrlExtractor(IEnumerable`1<string> poolNames, ServerManager validServerManager);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.EnvironmentConflict : ValueType {
    private ValueAndKind _original;
    private ValueAndKind _proposed;
    public ValueAndKind Proposed { get; }
    public object ProposedValue { get; }
    public ValueAndKind Original { get; }
    public object OriginalValue { get; }
    public EnvironmentConflict(object original, object proposed);
    public EnvironmentConflict(ValueAndKind original, ValueAndKind proposed);
    public ValueAndKind get_Proposed();
    public object get_ProposedValue();
    public ValueAndKind get_Original();
    public object get_OriginalValue();
}
internal enum Microsoft.VisualStudio.Enterprise.WebInstrument.EnvironmentInjectionState : Enum {
    public int value__;
    public static EnvironmentInjectionState Unknown;
    public static EnvironmentInjectionState Injected;
    public static EnvironmentInjectionState Removed;
}
internal class Microsoft.VisualStudio.Enterprise.WebInstrument.IIS7Resetter : IISResetter {
    private Dictionary`2<string, bool> _originalLoadUserProfile;
    private Dictionary`2<string, bool> _originalSetProfileEnvironment;
    private Dictionary`2<string, StartMode> _originalStartMode;
    private HashSet`1<string> _preparedPools;
    private HashSet`1<string> _appPools;
    private static int Timeout;
    private static ProcessModelIdentityType ProcessModelIdentityType_ApplicationPoolIdentity;
    private static string IIS7ResetterName;
    private static string StartModeName;
    private static string LoadUserProfileAttributeName;
    private static string SetProfileEnvironmentName;
    public string InstanceSettings { get; public set; }
    public IEnumerable`1<SecurityIdentifier> Users { get; }
    public IEnumerable`1<string> Services { get; }
    public IEnumerable`1<SecurityIdentifier> ResetterUsers { get; }
    private Version LocalIISVersion { get; }
    public IIS7Resetter(IEnumerable`1<string> appPools);
    private IEnumerable`1<ApplicationPool> SelectActiveApplicationPools(ServerManager validServerManager);
    private IEnumerable`1<ApplicationPool> SelectRunningPools(ServerManager validServerManager);
    private IEnumerable`1<ApplicationPool> SelectNamedPools(ServerManager validServerManager, IEnumerable`1<string> poolNames);
    private static void RenamePoolInSettingsDictionary(IDictionary`2<string, TValue> appPoolSettings, string oldAppPoolName, string appPoolName);
    private void UpdateAppPoolName(string oldAppPoolName, string appPoolName);
    private bool IsConfigurationElementAttributeSupported(ConfigurationElement element, string attributeName);
    private bool SetPoolConfigurationAttribute(ApplicationPool pool, Dictionary`2<string, T> originalValuesByPoolName, ConfigurationElement element, string attributeName, T newValue);
    private bool RestorePoolConfigurationAttribute(ApplicationPool pool, Dictionary`2<string, T> originalValuesByPoolName, ConfigurationElement element, string attributeName);
    private bool SetPoolStartMode(ApplicationPool pool, StartMode mode);
    private bool RestorePoolStartMode(ApplicationPool pool);
    private bool SetPoolLoadUserProfile(ApplicationPool pool, bool value);
    private bool RestorePoolLoadUserProfile(ApplicationPool pool);
    private bool SetPoolSetProfileEnvironment(ApplicationPool pool, bool value);
    private bool RestorePoolSetProfileEnvironment(ApplicationPool pool);
    public virtual string get_InstanceSettings();
    public virtual void set_InstanceSettings(string value);
    public virtual void PrepareWorkerProcesses();
    public virtual void RestoreWorkerProcesses();
    private void ModifyInstrumentationState(bool enable);
    protected virtual void PerformInstrumentation();
    protected virtual void RemoveInstrumentation();
    private List`1<string> GetProcessGuidsForPools(IEnumerable`1<string> poolNames);
    private void PerformRecycle(IEnumerable`1<string> poolNames);
    private void PerformReset(IEnumerable`1<string> poolNames);
    private void PerformResetOrRecycle(IEnumerable`1<string> poolNames);
    public virtual IEnumerable`1<SecurityIdentifier> get_Users();
    public virtual IEnumerable`1<string> get_Services();
    public virtual IEnumerable`1<SecurityIdentifier> get_ResetterUsers();
    public virtual bool HasAccess();
    private Version get_LocalIISVersion();
    [CompilerGeneratedAttribute]
private bool <PrepareWorkerProcesses>b__33_4(ApplicationPool pool);
    [CompilerGeneratedAttribute]
private bool <PrepareWorkerProcesses>b__33_5(ApplicationPool pool);
    [CompilerGeneratedAttribute]
private bool <RestoreWorkerProcesses>b__34_1(ApplicationPool pool);
    [CompilerGeneratedAttribute]
private bool <RestoreWorkerProcesses>b__34_3(ApplicationPool pool);
    [CompilerGeneratedAttribute]
private bool <RestoreWorkerProcesses>b__34_4(ApplicationPool pool);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.IISAccessException : IISResetterException {
    public IISAccessException(Exception innerException);
    public IISAccessException(string message);
    public IISAccessException(string message, Exception innerException);
    protected IISAccessException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.VisualStudio.Enterprise.WebInstrument.IISEnvironmentInjector : object {
    [CompilerGeneratedAttribute]
private InclusionExclusionList`1<string> <IncludeExcludeList>k__BackingField;
    [CompilerGeneratedAttribute]
private IISResetter <Resetter>k__BackingField;
    [CompilerGeneratedAttribute]
private EnvironmentInjectionState <InjectionState>k__BackingField;
    private Dictionary`2<ServiceController, RegistryEnvironment> _servicesToInstrument;
    private Dictionary`2<SecurityIdentifier, RegistryEnvironment> _usersToInstrument;
    private bool _didPrepareWorkerProcesses;
    private IOutputter _outputter;
    public InclusionExclusionList`1<string> IncludeExcludeList { get; public set; }
    public IEnumerable`1<SecurityIdentifier> Users { get; }
    public string InstanceSettings { get; }
    public IISResetter Resetter { get; public set; }
    public EnvironmentInjectionState InjectionState { get; public set; }
    public IOutputter Outputter { get; public set; }
    public static IISEnvironmentInjector Create(string resetterSettings);
    public static IISEnvironmentInjector CreateFromAppPool(string appPoolName, EnvironmentInjectionState state);
    public static IISEnvironmentInjector CreateFromAppPool(string appPoolName, string settings, EnvironmentInjectionState state);
    public static IISEnvironmentInjector CreateFromAppPool(IEnumerable`1<string> appPools, string settings, EnvironmentInjectionState state);
    public sealed virtual void Dispose();
    private static void DefaultConfigure(IISEnvironmentInjector instr, string settings);
    public IEnumerable`1<OverwrittenRegistryValues> PushEnvironmentVariables(Dictionary`2<string, string> valuesToSet);
    public List`1<List`1<string>> RequestEnvironmentVariables(String[] varsRequested);
    public List`1<List`1<string>> RequestEnvironmentVariablesThrows(String[] varsRequested);
    public List`1<List`1<string>> RequestEnvironmentVariables(EnvironmentInjectionState state, String[] varsRequested, bool throws);
    public List`1<Dictionary`2<string, string>> RequestEnvironment();
    public IEnumerable`1<OverwrittenRegistryValues> PushAndReset(Dictionary`2<string, string> environmentVariablesToSet);
    public IEnumerable`1<OverwrittenRegistryValues> PushAndReset(Dictionary`2<string, string> environmentVariablesToSet, bool force);
    public void UpdateAppPool(string oldName, string appPoolName);
    public void ResetIIS(EnvironmentInjectionState injectionState);
    public void RemoveAndReset(IEnumerable`1<OverwrittenRegistryValues> previousConflicts);
    public void RemoveAndReset(Dictionary`2<string, string> environmentVariablesPreviouslySet);
    public void RemoveAndReset(Dictionary`2<string, string> environmentVariablesPreviouslySet, bool force);
    public void RemoveAndReset(Dictionary`2<string, string> environmentVariablesPreviouslySet, IEnumerable`1<OverwrittenRegistryValues> previousConflicts);
    public void RemoveAndReset(Dictionary`2<string, string> environmentVariablesPreviouslySet, IEnumerable`1<OverwrittenRegistryValues> previousConflicts, bool force);
    public void AddServices(IEnumerable`1<string> serviceNames);
    public void ClearServices();
    public void AddUsers(List`1<string> users);
    public void AddUsers(IEnumerable`1<SecurityIdentifier> usersAsSids);
    public void ResetServices();
    public static IEnumerable`1<string> FilterMachineServices(IEnumerable`1<string> serviceNames);
    private Dictionary`2<SecurityIdentifier, RegistryEnvironment> GetUsersToInstrument();
    private void PrepareWorkerProcesses();
    [CompilerGeneratedAttribute]
public InclusionExclusionList`1<string> get_IncludeExcludeList();
    [CompilerGeneratedAttribute]
public void set_IncludeExcludeList(InclusionExclusionList`1<string> value);
    public IEnumerable`1<SecurityIdentifier> get_Users();
    public string get_InstanceSettings();
    [CompilerGeneratedAttribute]
public IISResetter get_Resetter();
    [CompilerGeneratedAttribute]
public void set_Resetter(IISResetter value);
    [CompilerGeneratedAttribute]
public EnvironmentInjectionState get_InjectionState();
    [CompilerGeneratedAttribute]
public void set_InjectionState(EnvironmentInjectionState value);
    public IOutputter get_Outputter();
    public void set_Outputter(IOutputter value);
}
internal abstract class Microsoft.VisualStudio.Enterprise.WebInstrument.IISResetter : object {
    protected static string AppPoolUserPrefix;
    public static int UnknownIISVersion;
    [CompilerGeneratedAttribute]
private InclusionExclusionList`1<string> <IncludeExcludeList>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <_isProfilingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferRecycle>k__BackingField;
    [CompilerGeneratedAttribute]
private IOutputter <Outputter>k__BackingField;
    public static string WorkerProcessNameNoExtension { get; }
    public static string WorkerProcessNameWithExtension { get; }
    public InclusionExclusionList`1<string> IncludeExcludeList { get; public set; }
    private bool _isProfilingEnabled { get; private set; }
    public IEnumerable`1<SecurityIdentifier> Users { get; }
    public IEnumerable`1<string> Services { get; }
    public IEnumerable`1<SecurityIdentifier> ResetterUsers { get; }
    public string InstanceSettings { get; public set; }
    public bool PreferRecycle { get; public set; }
    public IOutputter Outputter { get; public set; }
    private static IISResetter();
    public static string get_WorkerProcessNameNoExtension();
    public static string get_WorkerProcessNameWithExtension();
    public virtual void PrepareWorkerProcesses();
    public virtual void RestoreWorkerProcesses();
    public virtual void UpdateAppPool(string oldName, string newName);
    public static IISResetter Create();
    public static IISResetter Create(IEnumerable`1<string> appPools);
    private static IISResetter CreateAppPoolResetter(IEnumerable`1<string> appPoolNames);
    [CompilerGeneratedAttribute]
public InclusionExclusionList`1<string> get_IncludeExcludeList();
    [CompilerGeneratedAttribute]
public void set_IncludeExcludeList(InclusionExclusionList`1<string> value);
    [CompilerGeneratedAttribute]
private bool get__isProfilingEnabled();
    [CompilerGeneratedAttribute]
private void set__isProfilingEnabled(bool value);
    public void Reset(bool enableInjection, bool force);
    public abstract virtual bool HasAccess();
    protected abstract virtual void PerformInstrumentation();
    protected abstract virtual void RemoveInstrumentation();
    public abstract virtual IEnumerable`1<SecurityIdentifier> get_Users();
    public abstract virtual IEnumerable`1<string> get_Services();
    public abstract virtual IEnumerable`1<SecurityIdentifier> get_ResetterUsers();
    public abstract virtual string get_InstanceSettings();
    public abstract virtual void set_InstanceSettings(string value);
    [CompilerGeneratedAttribute]
public bool get_PreferRecycle();
    [CompilerGeneratedAttribute]
public void set_PreferRecycle(bool value);
    [CompilerGeneratedAttribute]
public IOutputter get_Outputter();
    [CompilerGeneratedAttribute]
public void set_Outputter(IOutputter value);
    protected static KeyValuePair`2<string, string> ParseSettings(string settings);
}
internal class Microsoft.VisualStudio.Enterprise.WebInstrument.IISServiceResetter : IISResetter {
    private static string IISServiceName;
    private static string IISAdminServiceName;
    private static string WindowsActivationServiceName;
    private static string IISServiceLoc;
    private static string IIsApplicationPoolsName;
    private static string AppPoolIdentityTypeName;
    private static string WAMUserNameName;
    public IEnumerable`1<SecurityIdentifier> Users { get; }
    public IEnumerable`1<SecurityIdentifier> ResetterUsers { get; }
    public IEnumerable`1<string> Services { get; }
    public string InstanceSettings { get; public set; }
    protected virtual void PerformInstrumentation();
    protected virtual void RemoveInstrumentation();
    public virtual IEnumerable`1<SecurityIdentifier> get_Users();
    public virtual IEnumerable`1<SecurityIdentifier> get_ResetterUsers();
    public virtual IEnumerable`1<string> get_Services();
    public virtual string get_InstanceSettings();
    public virtual void set_InstanceSettings(string value);
    public virtual bool HasAccess();
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.InclusionExclusionList`1 : object {
    [CompilerGeneratedAttribute]
private IComparer`1<T> <Comparator>k__BackingField;
    private bool _obeyInclusion;
    private bool _obeyExclusion;
    private List`1<T> _inclusionList;
    private List`1<T> _exclusionList;
    public IComparer`1<T> Comparator { get; public set; }
    public bool ObeyInclusionList { get; public set; }
    public bool ObeyExclusionList { get; public set; }
    public ICollection`1<T> InclusionList { get; }
    public ICollection`1<T> ExclusionList { get; }
    public InclusionExclusionList`1(int capacity);
    public void Reset();
    [CompilerGeneratedAttribute]
public IComparer`1<T> get_Comparator();
    [CompilerGeneratedAttribute]
public void set_Comparator(IComparer`1<T> value);
    public void Exclude(T toExclude);
    public void Include(T toInclude);
    public bool get_ObeyInclusionList();
    public void set_ObeyInclusionList(bool value);
    public bool get_ObeyExclusionList();
    public void set_ObeyExclusionList(bool value);
    public bool IsAllowed(T toQuestion);
    public ICollection`1<T> get_InclusionList();
    public ICollection`1<T> get_ExclusionList();
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.InvalidRegistryKeyException : RegistryEnvironmentException {
    public InvalidRegistryKeyException(string message);
    public InvalidRegistryKeyException(Exception innerException);
    public InvalidRegistryKeyException(string message, Exception innerException);
    protected InvalidRegistryKeyException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.InvalidResolutionException : RegistryEnvironmentException {
    public InvalidResolutionException(string message);
    public InvalidResolutionException(string message, Exception innerException);
    protected InvalidResolutionException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.LoadUserProfileException : IISResetterException {
    public LoadUserProfileException(string message);
    public LoadUserProfileException(string appPoolName, Exception inner);
    protected LoadUserProfileException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.MultipleRegistryEnvironmentException : RegistryEnvironmentException {
    public MultipleRegistryEnvironmentException(string message);
    public MultipleRegistryEnvironmentException(string message, Exception innerException);
    protected MultipleRegistryEnvironmentException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.OverwrittenRegistryValues : object {
    [CompilerGeneratedAttribute]
private RegistryEnvironment <Manipulator>k__BackingField;
    private Dictionary`2<string, EnvironmentConflict> _conflicts;
    private RegistryEnvironment Manipulator { get; private set; }
    public Dictionary`2<string, EnvironmentConflict> Conflicts { get; public set; }
    public OverwrittenRegistryValues(RegistryEnvironment manip);
    [CompilerGeneratedAttribute]
private RegistryEnvironment get_Manipulator();
    [CompilerGeneratedAttribute]
private void set_Manipulator(RegistryEnvironment value);
    public Dictionary`2<string, EnvironmentConflict> get_Conflicts();
    public void set_Conflicts(Dictionary`2<string, EnvironmentConflict> value);
    internal void Revert();
}
public abstract class Microsoft.VisualStudio.Enterprise.WebInstrument.RegistryEnvironment : object {
    private bool overwriteValuesDefault;
    internal string RegistryLocation { get; }
    internal abstract virtual Dictionary`2<string, ValueAndKind> GetCurrentEnvironment();
    protected abstract virtual void WriteRegistryValues(Dictionary`2<string, ValueAndKind> valuesToCommit);
    internal abstract virtual string get_RegistryLocation();
    private void SeparateConflicts(Dictionary`2<string, ValueAndKind> userProposedValues, Dictionary`2& variablesSet, OverwrittenRegistryValues& resultingConflicts);
    internal List`1<string> RequestVariables(String[] queries);
    internal Dictionary`2<string, string> RequestEnvironment();
    protected virtual OverwrittenRegistryValues SetValue(string name, string value);
    protected virtual OverwrittenRegistryValues SetValue(string name, string value, RegistryValueKind kind);
    internal OverwrittenRegistryValues ApplyValues(Dictionary`2<string, string> environmentToAdd);
    internal OverwrittenRegistryValues ApplyValues(Dictionary`2<string, string> environmentToAdd, bool overwriteCurrentValues);
    internal OverwrittenRegistryValues ApplyValues(Dictionary`2<string, ValueAndKind> environmentToAdd);
    internal OverwrittenRegistryValues ApplyValues(Dictionary`2<string, ValueAndKind> valuesToAdd, bool overwriteCurrentValues);
    public int CompareTo(RegistryEnvironment other);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.RegistryEnvironmentException : WebInstrumenterException {
    public RegistryEnvironmentException(string message);
    public RegistryEnvironmentException(string message, Exception innerException);
    protected RegistryEnvironmentException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.ResetterTimeoutException : IISResetterException {
    public ResetterTimeoutException(string message);
    public ResetterTimeoutException(string message, Exception inner);
    protected ResetterTimeoutException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.VisualStudio.Enterprise.WebInstrument.Resources : object {
    internal static ResourceManager ResourceManager;
    public static string NullProvidedService { get; }
    public static string CannotReInstrument { get; }
    public static string CannotRevert { get; }
    public static string Error_RootExists { get; }
    public static string SiteRequired { get; }
    public static string WebAdministrationNotPresent { get; }
    public static string EventLog_SourceName { get; }
    public static string UnableRestoreSiteSettings { get; }
    public static string StoppingAppPoolTimedOut { get; }
    private static Resources();
    public static string UnableAcquireUsersDueToSite(object param0);
    public static string get_NullProvidedService();
    public static string ServiceRunningTimeoutt(object param0);
    public static string get_CannotReInstrument();
    public static string get_CannotRevert();
    public static string EnvironmentManipulation(object param0);
    public static string Error_GeneralWebException(object param0);
    public static string Error_KeyExists(object param0);
    public static string Error_Resetter(object param0);
    public static string get_Error_RootExists();
    public static string IISAccessDenied(object param0);
    public static string ServiceRunningTimeout(object param0);
    public static string ServiceStopTimeout(object param0);
    public static string get_SiteRequired();
    public static string get_WebAdministrationNotPresent();
    public static string Error_LoadUserProfile(object param0);
    public static string get_EventLog_SourceName();
    public static string get_UnableRestoreSiteSettings();
    public static string get_StoppingAppPoolTimedOut();
    public static string UserRegistryNotWritable(object param0);
    public static string SidRegistryNotWritable(object param0);
    public static string InvalidApplicationPool(object param0);
    public static string WaitingForRecycleWithSeconds(object param0);
    public static string WaitingForResetWithSeconds(object param0);
    public static string WaitingForWorkerProcessStartWithSeconds(object param0);
    public static string ApplicationPoolSettingAttributeToValue(object param0, object param1, object param2);
    public static string ApplicationPoolSettingAttribute(object param0, object param1);
    public static string ApplicationPoolResettingAttribute(object param0, object param1);
    public static string ResettingApplicationPool(object param0);
    public static string RecyclingApplicationPool(object param0);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.ServiceAccessException : WebInstrumenterException {
    public ServiceAccessException(string message);
    public ServiceAccessException(string message, Exception inner);
    protected ServiceAccessException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.VisualStudio.Enterprise.WebInstrument.ServiceEnvironment : RegistryEnvironment {
    private static string ControlSetLocation;
    private static string EnvironmentSubKey;
    private string _keyLocation;
    private string _multiSzValue;
    private static RegistryKey RegistryKeyRoot { get; }
    internal string RegistryLocation { get; }
    internal ServiceEnvironment(ServiceController service);
    private static RegistryKey get_RegistryKeyRoot();
    protected virtual void WriteRegistryValues(Dictionary`2<string, ValueAndKind> environmentToCommit);
    internal virtual Dictionary`2<string, ValueAndKind> GetCurrentEnvironment();
    internal virtual string get_RegistryLocation();
}
internal class Microsoft.VisualStudio.Enterprise.WebInstrument.ServiceGroup : object {
    private static TimeSpan _defaultUpdateTimeout;
    private Nullable`1<TimeSpan> _statusUpdateTimeout;
    private IEnumerable`1<ServiceController> _services;
    public TimeSpan StatusUpdateTimeout { get; public set; }
    public IEnumerable`1<ServiceController> Services { get; }
    public ServiceGroup(IEnumerable`1<ServiceController> services);
    private static ServiceGroup();
    private ServiceController[] GetDependentServices(ServiceController x);
    public TimeSpan get_StatusUpdateTimeout();
    public void set_StatusUpdateTimeout(TimeSpan value);
    public void Start();
    public void Stop();
    public IEnumerable`1<ServiceController> get_Services();
    private void EnsureRunning(ServiceController service);
    private void EnsureStopped(ServiceController service);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.ServiceTimeoutException : WebInstrumenterException {
    public ServiceTimeoutException(string message);
    public ServiceTimeoutException(string message, Exception inner);
    protected ServiceTimeoutException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.SiteConflictException : IISResetterException {
    public SiteConflictException(string message);
    public SiteConflictException(string message, Exception innerException);
    protected SiteConflictException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Enterprise.WebInstrument.SiteRequiredException : IISResetterException {
    public SiteRequiredException(Exception innerException);
    public SiteRequiredException(string message);
    public SiteRequiredException(string message, Exception innerException);
    protected SiteRequiredException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.VisualStudio.Enterprise.WebInstrument.TopologicalSorter`1 : object {
    private List`1<List`1<T>> _adjacencyList;
    private List`1<T> _nodesDiscovered;
    private List`1<T> _startingNodes;
    private NodeCoercer<T> _childCoercer;
    private IComparer`1<T> _equalityComparer;
    public List`1<T> NodesDiscovered { get; }
    private List`1<List`1<T>> AdjacencyList { get; }
    private List`1<T> StartingNodes { get; }
    private NodeCoercer<T> ChildCoercer { get; private set; }
    private IComparer`1<T> EqualityComparator { get; }
    public TopologicalSorter`1(T[] initialNodes, NodeCoercer<T> childCoercer, IComparer`1<T> equalityPredicate);
    public TopologicalSorter`1(List`1<T> initialNodes, NodeCoercer<T> childCoercer, IComparer`1<T> equalityPredicate);
    public List`1<T> get_NodesDiscovered();
    private List`1<List`1<T>> get_AdjacencyList();
    private List`1<T> get_StartingNodes();
    private NodeCoercer<T> get_ChildCoercer();
    private void set_ChildCoercer(NodeCoercer<T> value);
    private IComparer`1<T> get_EqualityComparator();
    private void DiscoverNodes();
    public List`1<T> Sort();
    private List`1<int> TopoDFS(T node, List`1<T> nodes);
    private List`1<int> TopoDFS(T node, List`1<T> nodes, List`1& visitedList);
    private Predicate`1<T> GetComparer(T toCompareAgainst);
}
internal class Microsoft.VisualStudio.Enterprise.WebInstrument.TraceDebuggerEnvironmentCleaner : object {
    private static string IISWaitHandlePrefix;
    private static string NamedAppPoolCheckHandleString;
    private EventWaitHandle _namedAppPoolCheckHandle;
    private EventWaitHandle _waitHandle;
    [CompilerGeneratedAttribute]
private string <AppPoolName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IISSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIISOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    private string AppPoolName { get; private set; }
    private string IISSettings { get; private set; }
    public EventWaitHandle IISWaitHandle { get; }
    public bool IsIISOwner { get; private set; }
    public bool CleansAllAppPools { get; }
    private bool IsDisposed { get; private set; }
    public TraceDebuggerEnvironmentCleaner(string appPoolName, string iisSettings);
    [CompilerGeneratedAttribute]
private string get_AppPoolName();
    [CompilerGeneratedAttribute]
private void set_AppPoolName(string value);
    [CompilerGeneratedAttribute]
private string get_IISSettings();
    [CompilerGeneratedAttribute]
private void set_IISSettings(string value);
    public EventWaitHandle get_IISWaitHandle();
    [CompilerGeneratedAttribute]
public bool get_IsIISOwner();
    [CompilerGeneratedAttribute]
private void set_IsIISOwner(bool value);
    public bool get_CleansAllAppPools();
    [CompilerGeneratedAttribute]
private bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    private void ThrowIfDisposed();
    public static bool IsIISSystemRegistered();
    public static bool IsNamedAppPoolRegistered();
    private static bool IsHandleOpened(string handle);
    private IISEnvironmentInjector CreateInjector();
    public void CleanupIISEnvironment();
    public void CleanupIISEnvironment(bool signal);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.Enterprise.WebInstrument.UserEnvironment : RegistryEnvironment {
    private static string SubKeyLocation;
    private SecurityIdentifier _sid;
    internal string RegistryLocation { get; }
    private static RegistryKey RegistryKeyRoot { get; }
    public UserEnvironment(SecurityIdentifier sid);
    private static UserEnvironment();
    internal virtual string get_RegistryLocation();
    private static RegistryKey get_RegistryKeyRoot();
    internal static bool CheckRegistryLocation(SecurityIdentifier sid);
    internal RegistryKey GetRegistryKey(bool writeable);
    protected virtual void WriteRegistryValues(Dictionary`2<string, ValueAndKind> envToCommit);
    internal virtual Dictionary`2<string, ValueAndKind> GetCurrentEnvironment();
}
internal class Microsoft.VisualStudio.IntelliTrace.AccessList`1 : object {
    private IList`1<EventToken> _eventTokenList;
    private StreamChain _streamChain;
    private IList`1<EventToken> EventTokenList { get; private set; }
    public int Count { get; }
    public AccessList`1(StreamChain streamChain);
    private IList`1<EventToken> get_EventTokenList();
    private void set_EventTokenList(IList`1<EventToken> value);
    private void PopulateEventTokenList();
    public sealed virtual T GetEvent(int eventIndex);
    public sealed virtual IList`1<T> GetEvents(int startIndex, int fetchCount);
    public sealed virtual int get_Count();
}
public class Microsoft.VisualStudio.IntelliTrace.ActivityEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ActivityEventCode <Code>k__BackingField;
    public ActivityEventCode Code { get; private set; }
    internal ActivityEventArgs(ActivityEventCode code);
    [CompilerGeneratedAttribute]
public ActivityEventCode get_Code();
    [CompilerGeneratedAttribute]
private void set_Code(ActivityEventCode value);
}
public enum Microsoft.VisualStudio.IntelliTrace.ActivityEventCode : Enum {
    public int value__;
    public static ActivityEventCode AttemptToCopyLogFileFailed;
    public static ActivityEventCode AttemptToCreateLogFileFailed;
    public static ActivityEventCode ErrorInSession;
    public static ActivityEventCode ExpectedProcessTraitsAdded;
    public static ActivityEventCode FatalErrorInService;
    public static ActivityEventCode InjectedProcessStarted;
    public static ActivityEventCode LoggingServiceStarted;
    public static ActivityEventCode LoggingServiceStopped;
    public static ActivityEventCode ProcessWasExpected;
    public static ActivityEventCode ProcessWasNotExpected;
    public static ActivityEventCode ServiceStartError;
    public static ActivityEventCode SessionStarted;
    public static ActivityEventCode SessionEnding;
    public static ActivityEventCode SessionFirstTruncation;
    public static ActivityEventCode SessionOutOfLogSpace;
    public static ActivityEventCode SessionStartError;
    public static ActivityEventCode InjectedProcessValidationFailure;
}
internal class Microsoft.VisualStudio.IntelliTrace.AnalysisTracker : object {
    private IDictionary`2<int, HeuristicNotifyPointSpecification> _npTable;
    private Nullable`1<int> _globalHandlerEventId;
    private static string BindingTypeName;
    public Nullable`1<int> GlobalExceptionHandlerEventId { get; }
    public AnalysisTracker(IDictionary`2<int, HeuristicNotifyPointSpecification> npTable);
    public Nullable`1<int> get_GlobalExceptionHandlerEventId();
    public IEnumerable`1<EventHandleToEC> GetExceptionRelatedEvents(DiagnosticChain chain);
}
internal class Microsoft.VisualStudio.IntelliTrace.ApplicationPoolInstrumenter : object {
    [CompilerGeneratedAttribute]
private DirectoryInfo <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityIdentifier[] <Users>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GeneratedCPlan>k__BackingField;
    [CompilerGeneratedAttribute]
private AppPoolInfo <AppPool>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ShouldProcessEventArgs> ShouldProcess;
    private static string SidIIS_IUSRS;
    private List`1<SecurityIdentifier> _appPoolSidList;
    [CompilerGeneratedAttribute]
private IOutputter <Outputter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildInfoConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    private DirectoryInfo OutputDirectory { get; private set; }
    private SecurityIdentifier[] Users { get; private set; }
    private string GeneratedCPlan { get; private set; }
    public AppPoolInfo AppPool { get; public set; }
    private string CPlanEnvName { get; }
    private string BuildInfoEnvName { get; }
    private string AppNameEnvName { get; }
    public IOutputter Outputter { get; public set; }
    public string BuildInfoConfigPath { get; public set; }
    public string ApplicationName { get; public set; }
    private List`1<SecurityIdentifier> AppPoolSidList { get; }
    private int AppPoolFrameworkMajor { get; }
    internal ApplicationPoolInstrumenter(string appPoolName);
    [CompilerGeneratedAttribute]
private DirectoryInfo get_OutputDirectory();
    [CompilerGeneratedAttribute]
private void set_OutputDirectory(DirectoryInfo value);
    [CompilerGeneratedAttribute]
private SecurityIdentifier[] get_Users();
    [CompilerGeneratedAttribute]
private void set_Users(SecurityIdentifier[] value);
    [CompilerGeneratedAttribute]
private string get_GeneratedCPlan();
    [CompilerGeneratedAttribute]
private void set_GeneratedCPlan(string value);
    [CompilerGeneratedAttribute]
public AppPoolInfo get_AppPool();
    [CompilerGeneratedAttribute]
public void set_AppPool(AppPoolInfo value);
    private string get_CPlanEnvName();
    private string get_BuildInfoEnvName();
    private string get_AppNameEnvName();
    [CompilerGeneratedAttribute]
public void add_ShouldProcess(EventHandler`1<ShouldProcessEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ShouldProcess(EventHandler`1<ShouldProcessEventArgs> value);
    [CompilerGeneratedAttribute]
public IOutputter get_Outputter();
    [CompilerGeneratedAttribute]
public void set_Outputter(IOutputter value);
    [CompilerGeneratedAttribute]
public string get_BuildInfoConfigPath();
    [CompilerGeneratedAttribute]
public void set_BuildInfoConfigPath(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationName();
    [CompilerGeneratedAttribute]
public void set_ApplicationName(string value);
    private Dictionary`2<string, string> CreateEnvironment();
    public void Start(string outputDirectory, string collectionPlanFile);
    public void Start(string outputDirectory, _CollectionPlan collectionPlan, string collectionPlanName);
    public void Stop();
    public bool IsInstrumented();
    public EnvironmentBlock GetWorkerEnvironment();
    private EnvironmentBlock GetIISEnvironment(IISEnvironmentInjector envInjector);
    private void ConfigureIIS();
    internal static void VerifyAdminRights();
    private void CreateCollectionPlanForAppPool(_CollectionPlan collectionPlan, string collectionPlanName);
    private List`1<SecurityIdentifier> get_AppPoolSidList();
    private void RegisterProfiler();
    private void UnregisterProfiler();
    private void SetAclOnCollectionPlan(string path);
    private static string GenerateCollectionPlanPath(string originalName, string appPool);
    private void VerifyArguments(string collectionPlanName, string outputDirectoryLocation);
    private static bool IsValidFileName(string collectionPlanName, Int32& invalidIndex);
    private void VerifyAccessIntelliTrace();
    private void VerifyCollectionPlanPermissions();
    private static bool CurrentUserIsAdministrator();
    private string GetProfilerPath();
    private int get_AppPoolFrameworkMajor();
    private void OnShouldProcess(ShouldProcessEventArgs e);
    private bool OnShouldProcess(string target);
    private IISEnvironmentInjector IISEnvironmentInjectorForAppPool();
    private IISEnvironmentInjector IISEnvironmentInjectorForAppPool(EnvironmentInjectionState injectionState);
}
internal class Microsoft.VisualStudio.IntelliTrace.ApplicationPoolInstrumenterResources : object {
    internal static ResourceManager ResourceManager;
    public static string CurrentUserNotAdministrator { get; }
    public static string OutputDirectoryNotLocalDrive { get; }
    public static string RegistryLockUnavailable { get; }
    private static ApplicationPoolInstrumenterResources();
    public static string AppPoolEnvironmentInaccessible(object param0);
    public static string get_CurrentUserNotAdministrator();
    public static string IncorrectPermissionsToReadCPlan(object param0, object param1);
    public static string InstrumentationAlreadyPresent(object param0);
    public static string InstrumentationNotStartedOnPool(object param0);
    public static string IntelliTraceVersionConflict(object param0);
    public static string InvalidCollectionPlanPath(object param0);
    public static string InvalidCollectionPlanName(object param0, object param1, object param2);
    public static string InvalidOutputDirectory(object param0);
    public static string MismatchAppPoolBitness(object param0);
    public static string get_OutputDirectoryNotLocalDrive();
    public static string PoolNotStarted(object param0);
    public static string get_RegistryLockUnavailable();
    public static string UnexpectedProfilerGuid(object param0, object param1);
    public static string UserCannotWriteToOutputDirectory(object param0, object param1);
    public static string UserCannotAccessIntelliTrace(object param0, object param1);
}
internal class Microsoft.VisualStudio.IntelliTrace.ArrayBlobUnpacker : CorProfBlobUnpacker {
    public bool ArraysHaveElementTypeToken { get; }
    public ArrayBlobUnpacker(Byte[] memory, int lowerBound, int upperBound, int pointerSizeBytes);
    public virtual void AfterUnpack(int typeSize);
    public virtual UnpackResult Unpack(BlobUnpacker& unpacker, ObjectLayout layout, bool isValueType);
    public virtual bool get_ArraysHaveElementTypeToken();
}
internal class Microsoft.VisualStudio.IntelliTrace.ArrayData : ClassData {
    private Type _elementType;
    protected List`1<ArrayElement> _arrayElements;
    protected ArrayDimensionLayout[] _dimensionLengths;
    protected short _cSavedElements;
    internal Type ElementType { get; internal set; }
    internal ArrayData(DataUnavailableReason reason, bool partialData);
    internal ArrayData(DataContext context, BlobUnpacker unpacker, Type elementType, ArrayDimensionLayout[] dimensionLengths, short cSavedElements, bool partialData);
    internal Type get_ElementType();
    internal void set_ElementType(Type value);
    internal List`1<ArrayElement> GetElements();
    internal int DimensionLength(Symbol arraySymbol, int dimension);
    internal virtual IEnumerable`1<IPendingUnpackData> GetPendingUnpackData();
    private IEnumerable`1<IPendingUnpackData> GetParameterPendingUnpackData();
}
internal class Microsoft.VisualStudio.IntelliTrace.ArrayDimensionLayout : ValueType {
    internal int _length;
    public virtual bool Equals(object obj);
    public static bool op_Equality(ArrayDimensionLayout pp1, ArrayDimensionLayout pp2);
    public static bool op_Inequality(ArrayDimensionLayout pp1, ArrayDimensionLayout pp2);
    public virtual int GetHashCode();
}
internal class Microsoft.VisualStudio.IntelliTrace.ArrayElement : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPendingUnpack>k__BackingField;
    public Type Type { get; public set; }
    public object Value { get; public set; }
    internal bool IsPendingUnpack { get; internal set; }
    internal ArrayElement(object value, Type type);
    internal ArrayElement(Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Type(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual void set_Value(object value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    [CompilerGeneratedAttribute]
internal bool get_IsPendingUnpack();
    [CompilerGeneratedAttribute]
internal void set_IsPendingUnpack(bool value);
}
internal enum Microsoft.VisualStudio.IntelliTrace.ArrayElementPackFlags : Enum {
    public int value__;
    public static ArrayElementPackFlags Null;
    public static ArrayElementPackFlags NonNull;
}
[CompilerGeneratedAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.AssemblyNames : object {
    public static bool IsIntelliTraceStandalone;
    public static string IntelliTraceLogger;
    public static string IntelliTraceProfiler;
    public static string IntelliTraceProfiler64;
    public static string IntelliTraceProfilerArm64;
    private static AssemblyNames();
}
internal static class Microsoft.VisualStudio.IntelliTrace.AttributeKeys : object {
    public static string Index;
    public static string Name;
    public static string MaxSize;
    public static string ExceptionObject;
    public static string Type;
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.BaseFormatter : object {
    protected static string SYNTHETIC_METHOD_PREFIX;
    protected static string ANONYMOUS_METHOD;
    protected static Regex _sAnonymousExpression;
    private static BaseFormatter();
    public virtual string FormatDataUnavailable(LogData data);
    public abstract virtual string FormatKeyword(FormatterKeyword keyword);
    public virtual string FormatSymbol(Symbol symbol, bool isOutParam, UInt32 radix);
    public virtual string FormatMethodName(MethodType method, FormatterMethodOptions options);
    private string GetMethodParameterList(MethodType method, bool includeSyntheticParameters);
    protected abstract virtual void GetMethodAttributeAsPrefixOrPostfix(MethodType method, String& methodPrefixPostfix, Boolean& isPostfix);
    private string GetFullMethodName(MethodType method, bool isCompressedNamespaces, string methodPrefixPostfix, bool isPostfix);
    public virtual string GetMethodName(string methodName);
    protected virtual string GetMethodName(MethodType method);
    public virtual string FormatType(Symbol symbol, Type type, UInt32 radix);
    protected virtual string FormatType(Symbol symbol, TypeDefType type, UInt32 radix);
    protected virtual string GetTypeNameRank(int rank, UInt32 radix);
    protected virtual string GetTypePrefix(Symbol symbol);
    protected abstract virtual string FormatType(PrimitiveType type, string prefix, string suffix);
    protected virtual string GetSimpleTypeName(TypeDefType type);
    public virtual string FormatPrimitive(PrimitiveType type, PrimitiveData data, UInt32 dwRadix);
    protected virtual string FormatPrimitive(char value, UInt32 radix);
    protected virtual string FormatPrimitive(float value, UInt32 radix);
    protected virtual string FormatPrimitive(double value, UInt32 radix);
    protected virtual string FormatPrimitive(bool value, UInt32 radix);
    protected virtual string FormatPrimitive(T value, UInt32 radix);
    protected virtual string GetCharValue(char value);
    public virtual string FormatString(string value, UInt32 radix, bool partialData);
    protected virtual string GetHexPrefix();
    public virtual string FormatClass(TypeDefType type, ClassData data, UInt32 radix);
    public virtual string FormatArray(ArrayType type, Int32[] dimensions, ArrayData arrayData, UInt32 radix);
    public virtual char GetArrayDecorative(bool isStart);
    public virtual string FormatPointer(int value);
    public virtual string FormatPointer(long value);
}
internal class Microsoft.VisualStudio.IntelliTrace.BinopNode : ExprNode {
    [CompilerGeneratedAttribute]
private ExprNode <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ExprNode <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private ExprNodeOperators <Operator>k__BackingField;
    internal ExprNode Left { get; internal set; }
    internal ExprNode Right { get; internal set; }
    internal ExprNodeOperators Operator { get; internal set; }
    [CompilerGeneratedAttribute]
internal ExprNode get_Left();
    [CompilerGeneratedAttribute]
internal void set_Left(ExprNode value);
    [CompilerGeneratedAttribute]
internal ExprNode get_Right();
    [CompilerGeneratedAttribute]
internal void set_Right(ExprNode value);
    [CompilerGeneratedAttribute]
internal ExprNodeOperators get_Operator();
    [CompilerGeneratedAttribute]
internal void set_Operator(ExprNodeOperators value);
    internal virtual Expr`2<T, bool> CompileBoolExpr();
    internal virtual Expr`2<T, int> CompileIntExpr();
    internal virtual Expr`2<T, long> CompileLongExpr();
    internal virtual Expr`2<T, string> CompileStringExpr();
}
internal class Microsoft.VisualStudio.IntelliTrace.BlobDumper : TaggedBlobUnpacker {
    public BlobDumper(Byte[] memory, int offset, PackOptions options);
    public string UnpackToString();
}
internal class Microsoft.VisualStudio.IntelliTrace.BlobPacker : object {
    private static Dictionary`2<Type, int> s_typeEncodingSizes;
    private Byte[] _buffer;
    private int _index;
    public int Index { get; }
    private static BlobPacker();
    public BlobPacker(Byte[] buffer);
    public int get_Index();
    public static Byte[] Pack(Object[] primitives);
    private static int GetEncodedSize(object val);
    public void Pack(object val);
    public void Pack(bool val);
    public void Pack(byte val);
    public void Pack(sbyte val);
    public void Pack(char val);
    public void Pack(short val);
    public void Pack(ushort val);
    public void Pack(int val);
    public void Pack(UInt32 val);
    public void Pack(long val);
    public void Pack(ulong val);
    public void Pack(float val);
    public void Pack(double val);
    public void Pack(decimal val);
    public void Pack(string s);
    public void Pack(string s, int maxBufferSize);
    public void PackInvalidRef(int depth);
    private static int GetEncodedStringSize(string s);
    private static int GetStringLength(int encodedSize);
}
internal class Microsoft.VisualStudio.IntelliTrace.BlobToObjectUnpacker : TaggedBlobUnpacker {
    public BlobToObjectUnpacker(Byte[] memory);
    public Object[] UnpackToObjectArray();
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.BlobUnpacker : object {
    internal Byte[] _memory;
    internal int _offset;
    internal int _lowerBound;
    internal int _upperBound;
    internal PackOptions _options;
    internal int _pointerSizeBytes;
    public bool SupportsNullables { get; }
    public bool ArraysHaveElementTypeToken { get; }
    public bool HasMoreData { get; }
    public abstract virtual void BeforeUnpack(int typeSize);
    public abstract virtual void AfterUnpack(int typeSize);
    public virtual UnpackResult Unpack(Boolean& value);
    public virtual UnpackResult Unpack(SByte& value);
    public virtual UnpackResult Unpack(Byte& value);
    public virtual UnpackResult UnpackNullable();
    public virtual bool get_SupportsNullables();
    public virtual bool get_ArraysHaveElementTypeToken();
    public bool get_HasMoreData();
    public virtual UnpackResult Unpack(Char& value);
    public virtual UnpackResult Unpack(Int16& value);
    public virtual UnpackResult Unpack(UInt16& value);
    public virtual UnpackResult Unpack(Int32& value);
    public virtual UnpackResult Unpack(UInt32& value);
    public virtual UnpackResult Unpack(Int64& value);
    public virtual UnpackResult Unpack(UInt64& value);
    public virtual UnpackResult Unpack(Single& value);
    public virtual UnpackResult Unpack(Double& value);
    public virtual UnpackResult Unpack(Decimal& value);
    public virtual UnpackResult Unpack(IntPtr& value);
    public virtual UnpackResult Unpack(UIntPtr& value);
    public virtual object UnpackIntPtr(UnpackResult& result);
    public virtual object UnpackUIntPtr(UnpackResult& result);
    public abstract virtual UnpackResult Unpack(String& value, Int32& originalSize);
    public abstract virtual UnpackResult Unpack(bool isNestedField, Type elementType, BlobUnpacker& value, ArrayDimensionLayout[] dimensions, Int16& savedElements);
    public abstract virtual UnpackResult UnpackLength(Int32& length);
    public abstract virtual int UnpackInvalidRefDepth();
    public abstract virtual UnpackResult Unpack(BlobUnpacker& unpacker, ObjectLayout layout, bool isValueType);
    public abstract virtual UnpackResult Unpack(BlobUnpacker& value);
    public abstract virtual UnpackResult UnpackRest(BlobUnpacker& value);
    protected void CheckBounds(int size);
    protected static void ThrowParseError();
    protected static void ThrowUnexpectedPrimitiveError(PrimitiveType pt);
}
internal class Microsoft.VisualStudio.IntelliTrace.BracketCallsiteNode : FakeCallsiteNode {
    internal long _cpOrdinal;
    internal BracketCallsiteNode(long ordinal, long cpOrdinal, CodeContext location);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.BuiltinDataTypeFormatter : BaseFormatter {
    public virtual string FormatClass(TypeDefType type, ClassData data, UInt32 radix);
    protected string FormatClassHelper(TypeDefType type, ClassData data, UInt32 radix);
    protected virtual string FormatDecimal(decimal value, UInt32 radix);
    protected virtual string FormatTimeSpan(TimeSpan value, UInt32 radix);
    protected virtual string FormatGuid(Guid value, UInt32 radix);
    protected virtual string FormatDateTime(DateTime value, UInt32 radix);
}
public class Microsoft.VisualStudio.IntelliTrace.CallSiteEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private int <CallerMethodToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <InstructionLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CalleeMethodToken>k__BackingField;
    public int CallerMethodToken { get; private set; }
    public int Offset { get; private set; }
    public byte InstructionLength { get; private set; }
    public int CalleeMethodToken { get; private set; }
    internal CallSiteEvent(CallSiteData* pData, byte instructionLength);
    [CompilerGeneratedAttribute]
public int get_CallerMethodToken();
    [CompilerGeneratedAttribute]
private void set_CallerMethodToken(int value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(int value);
    [CompilerGeneratedAttribute]
public byte get_InstructionLength();
    [CompilerGeneratedAttribute]
private void set_InstructionLength(byte value);
    [CompilerGeneratedAttribute]
public int get_CalleeMethodToken();
    [CompilerGeneratedAttribute]
private void set_CalleeMethodToken(int value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.CallsiteNode : Node {
    protected int _targetIndex;
    protected int _exitIndex;
    protected List`1<EventHandle> _children;
    protected bool _fIsCallToUninstrumented;
    protected MethodContext _targetLocation;
    public NodeType Type { get; }
    public bool IsCallToUninstrumented { get; public set; }
    public MethodContext TargetLocation { get; public set; }
    public EventHandle Target { get; }
    public EventHandle Exit { get; }
    internal List`1<EventHandle> Calls { get; }
    internal CallsiteNode(long ordinal, CodeContext location);
    public virtual NodeType get_Type();
    public bool get_IsCallToUninstrumented();
    public void set_IsCallToUninstrumented(bool value);
    public MethodContext get_TargetLocation();
    public void set_TargetLocation(MethodContext value);
    public EventHandle get_Target();
    public EventHandle get_Exit();
    public virtual IBidiEnum`1<EventHandle> GetChildren();
    internal void SetTarget(EventHandle target);
    internal void SetExit(EventHandle exit);
    internal void AddChild(EventHandle child);
    internal EventHandle GetFirstChild();
    internal EventHandle GetLastChild();
    internal int GetChildCount();
    internal List`1<EventHandle> get_Calls();
    internal void ClearChildren();
    internal void ReTarget(CallsiteNode callsite);
    internal void ReplaceTarget(EventHandle newTarget);
    internal void RemoveChild(EventHandle child);
    internal EventHandle GetFirstCopy();
    internal EventHandle GetLastCopy();
    internal EventHandle GetNextCopy();
    internal EventHandle GetPreviousCopy();
    [CompilerGeneratedAttribute]
private void <ReTarget>b__28_0(EventHandle child);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.CallTreeExtensions : object {
    public static String[] ExcludedSignatures;
    public static double AllowedTime;
    public static int MaxHighlightedNodes;
    private static double ProcessTimeThreshold;
    private static CallTreeExtensions();
    [ExtensionAttribute]
public static IList`1<T> CalculateHeaviestNodes(T root, Func`2<T, bool> inclusionPredicate);
    private static bool ExcludeSignature(string signature);
    [ExtensionAttribute]
public static IEnumerable`1<T> EnumerateChildren(T root);
    [ExtensionAttribute]
public static IEnumerable`1<T> EnumerateChildren(T rootNode, Func`2<T, bool> predicate);
}
internal class Microsoft.VisualStudio.IntelliTrace.CallTreeFrame : object {
    [CompilerGeneratedAttribute]
private DataProvider <DataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MethodEnterEventOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LoggerThreadId>k__BackingField;
    private string _signature;
    private Nullable`1<DateTime> _startTime;
    private Nullable`1<DateTime> _endTime;
    private Nullable`1<double> _totalTime;
    private Nullable`1<double> _selfTime;
    private DiagnosticFrameData _diagnosticFrameData;
    private bool _hasParameters;
    private bool _hasResolvedTimingData;
    private IList`1<IDataElement> _parameters;
    [CompilerGeneratedAttribute]
private ResolveInfo <CachedResolveInfo>k__BackingField;
    public DataProvider DataProvider { get; private set; }
    public long MethodEnterEventOrdinal { get; public set; }
    public int LoggerThreadId { get; public set; }
    public string Signature { get; internal set; }
    public Nullable`1<DateTime> StartTime { get; internal set; }
    public Nullable`1<DateTime> EndTime { get; internal set; }
    public Nullable`1<double> TotalTime { get; internal set; }
    public Nullable`1<double> SelfTime { get; }
    public DiagnosticFrameData DiagnosticFrameData { get; }
    public bool HasParameters { get; }
    public IList`1<IDataElement> Parameters { get; }
    internal ResolveInfo CachedResolveInfo { get; internal set; }
    public CallTreeFrame(DataProvider dataProvider);
    [CompilerGeneratedAttribute]
public DataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
private void set_DataProvider(DataProvider value);
    [CompilerGeneratedAttribute]
public long get_MethodEnterEventOrdinal();
    [CompilerGeneratedAttribute]
public void set_MethodEnterEventOrdinal(long value);
    [CompilerGeneratedAttribute]
public int get_LoggerThreadId();
    [CompilerGeneratedAttribute]
public void set_LoggerThreadId(int value);
    public string get_Signature();
    internal void set_Signature(string value);
    public Nullable`1<DateTime> get_StartTime();
    internal void set_StartTime(Nullable`1<DateTime> value);
    public Nullable`1<DateTime> get_EndTime();
    internal void set_EndTime(Nullable`1<DateTime> value);
    public Nullable`1<double> get_TotalTime();
    internal void set_TotalTime(Nullable`1<double> value);
    public Nullable`1<double> get_SelfTime();
    public DiagnosticFrameData get_DiagnosticFrameData();
    public bool get_HasParameters();
    public IList`1<IDataElement> get_Parameters();
    [CompilerGeneratedAttribute]
internal ResolveInfo get_CachedResolveInfo();
    [CompilerGeneratedAttribute]
internal void set_CachedResolveInfo(ResolveInfo value);
    private void ResolveTimingData();
    private void ResolveDataAtMethodEnter();
    private static string BuildMethodSignature(ResolvedMethod method);
    private void ResolveDataAtMethodExit();
    private void ResolveDataAtCallSite();
    private void ResolveParameters();
}
internal class Microsoft.VisualStudio.IntelliTrace.CallTreeNode : object {
    [CompilerGeneratedAttribute]
private CallTreeFrame <CurrentFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<CallTreeNode> <CalledFrames>k__BackingField;
    private Nullable`1<int> _descendentCount;
    public CallTreeFrame CurrentFrame { get; private set; }
    public IList`1<CallTreeNode> CalledFrames { get; public set; }
    public int DescendentCount { get; }
    public bool HasTimingData { get; }
    public Nullable`1<DateTime> StartTime { get; }
    public Nullable`1<DateTime> EndTime { get; }
    public Nullable`1<TimeSpan> TotalTime { get; }
    public Nullable`1<TimeSpan> SelfTime { get; }
    public string Name { get; }
    public IEnumerable`1<ICallTreeNode> Children { get; }
    public CallTreeNode(CallTreeFrame currentFrame);
    [CompilerGeneratedAttribute]
public CallTreeFrame get_CurrentFrame();
    [CompilerGeneratedAttribute]
private void set_CurrentFrame(CallTreeFrame value);
    [CompilerGeneratedAttribute]
public IList`1<CallTreeNode> get_CalledFrames();
    [CompilerGeneratedAttribute]
public void set_CalledFrames(IList`1<CallTreeNode> value);
    public int get_DescendentCount();
    public sealed virtual bool get_HasTimingData();
    public sealed virtual Nullable`1<DateTime> get_StartTime();
    public sealed virtual Nullable`1<DateTime> get_EndTime();
    public sealed virtual Nullable`1<TimeSpan> get_TotalTime();
    public sealed virtual Nullable`1<TimeSpan> get_SelfTime();
    public sealed virtual string get_Name();
    public sealed virtual IEnumerable`1<ICallTreeNode> get_Children();
}
internal class Microsoft.VisualStudio.IntelliTrace.CatchNode : ExceptionNode {
    public NodeType Type { get; }
    public int NotifyId { get; }
    internal CatchNode(long ordinal, CodeContext location);
    public virtual NodeType get_Type();
    public virtual int get_NotifyId();
}
public abstract class Microsoft.VisualStudio.IntelliTrace.Chain : object {
    public EventToken FirstToken { get; }
    public EventToken FirstValidToken { get; }
    public EventToken BeforeFirstToken { get; }
    public EventToken LastToken { get; }
    public EventToken AfterLastToken { get; }
    public long Count { get; }
    public bool IsEmpty { get; }
    public bool CanGetPreviousToken { get; }
    public bool CanGetLastToken { get; }
    public bool CanGetCount { get; }
    public abstract virtual EventToken get_FirstToken();
    public abstract virtual EventToken get_FirstValidToken();
    public virtual EventToken get_BeforeFirstToken();
    public virtual EventToken get_LastToken();
    public abstract virtual EventToken get_AfterLastToken();
    public abstract virtual IntelliTraceEvent GetEvent(EventToken token);
    internal virtual bool CanGetEvent(EventToken token);
    public abstract virtual IList`1<IntelliTraceEvent> GetEvents(EventToken startToken, EventToken endToken);
    public abstract virtual EventToken GetNextToken(EventToken token);
    public virtual EventToken GetPreviousToken(EventToken token);
    public virtual long get_Count();
    public abstract virtual bool get_IsEmpty();
    public virtual bool get_CanGetPreviousToken();
    public virtual bool get_CanGetLastToken();
    public virtual bool get_CanGetCount();
    public abstract virtual bool IsValidToken(EventToken token);
    public abstract virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual IEnumerator`1<TEvent> GetEnumerator();
    public virtual IEnumerator`1<IntelliTraceEvent> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IEnumerable`1<EventToken> Tokens();
    internal virtual IEnumerable`1<EventToken> TokensInternal();
}
public enum Microsoft.VisualStudio.IntelliTrace.ChainAccess : Enum {
    public int value__;
    public static ChainAccess None;
    public static ChainAccess Read;
    public static ChainAccess ReadAppend;
}
internal class Microsoft.VisualStudio.IntelliTrace.ChainEnum`1 : object {
    private Chain _chain;
    private EventToken _cursor;
    private Transform<T> _transform;
    private Predicate`1<OrdinalEvent> _filter;
    private long _maxOrdinal;
    private long _minOrdinal;
    private EventToken _startToken;
    public int Count { get; }
    internal ChainEnum`1(Chain chain, Transform<T> transform);
    internal ChainEnum`1(Chain chain, Transform<T> transform, Predicate`1<OrdinalEvent> filter);
    internal ChainEnum`1(Chain chain, Transform<T> transform, Predicate`1<OrdinalEvent> filter, long minOrdinal, long maxOrdinal, EventToken startToken);
    public sealed virtual int Next(T[] elements);
    public sealed virtual int Next(T[] elements, int arrayIndex, int count);
    public sealed virtual int Previous(T[] elements);
    public sealed virtual int Previous(T[] elements, int arrayIndex, int count);
    public sealed virtual void Skip(int count);
    public sealed virtual void Reset();
    public sealed virtual void Reset(EnumOrigin origin);
    public sealed virtual int get_Count();
    public sealed virtual IEnum`1<T> Clone();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override void Microsoft.VisualStudio.IntelliTrace.IChainTokenOwner.GetActiveTokens(EventToken& firstValidToken, EventToken& afterLastToken);
    private sealed virtual override void Microsoft.VisualStudio.IntelliTrace.IChainTokenOwner.MoveTo(EventToken token);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.ChainFilters.ChainFilter`1 : object {
    public IEnumerable`1<EventWrapper`1<T>> GetData();
    protected abstract virtual IEnumerable`1<EventWrapper`1<T>> GetDataCore();
}
internal class Microsoft.VisualStudio.IntelliTrace.ChainFilters.EnumChainFilter`1 : ChainFilter`1<T> {
    private IEnumerable`1<EventWrapper`1<T>> _cache;
    private Func`1<bool> _cancelCondition;
    public EnumChainFilter`1(Chain chain);
    public EnumChainFilter`1(Chain chain, Func`1<bool> cancelCondition);
    protected virtual IEnumerable`1<EventWrapper`1<T>> GetDataCore();
}
internal class Microsoft.VisualStudio.IntelliTrace.ChainFilters.EventWrapper`1 : object {
    [CompilerGeneratedAttribute]
private T <Event>k__BackingField;
    [CompilerGeneratedAttribute]
private EventToken <Token>k__BackingField;
    public T Event { get; public set; }
    public EventToken Token { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Event();
    [CompilerGeneratedAttribute]
public void set_Event(T value);
    [CompilerGeneratedAttribute]
public EventToken get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(EventToken value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ChainFilters.SortChainFilter`1 : ChainFilter`1<T> {
    private ChainFilter`1<T> _source;
    private Comparison`1<T> _comparer;
    public SortChainFilter`1(ChainFilter`1<T> source, Comparison`1<T> comparer);
    protected virtual IEnumerable`1<EventWrapper`1<T>> GetDataCore();
}
internal class Microsoft.VisualStudio.IntelliTrace.ChainFilters.StreamChainFilter`1 : ChainFilter`1<T> {
    private EventWrapper`1[] _cache;
    public StreamChainFilter`1(Chain chain);
    protected virtual IEnumerable`1<EventWrapper`1<T>> GetDataCore();
}
internal class Microsoft.VisualStudio.IntelliTrace.ChainFilters.WhereFilter`1 : ChainFilter`1<T> {
    private ChainFilter`1<T> _source;
    private Predicate`1<T> _filter;
    public WhereFilter`1(ChainFilter`1<T> source, Predicate`1<T> filter);
    protected virtual IEnumerable`1<EventWrapper`1<T>> GetDataCore();
    [CompilerGeneratedAttribute]
private bool <GetDataCore>b__3_0(EventWrapper`1<T> data);
}
internal class Microsoft.VisualStudio.IntelliTrace.ChainManager : object {
    private IntelliTraceFileBase _logFile;
    private Dictionary`2<int, ThreadChain> _threadChains;
    private Dictionary`2<Type, Chain> _chainsByType;
    private Dictionary`2<int, IntelliTraceTokenChain> _intelliTraceTokenChains;
    internal ChainManager(IntelliTraceFileBase logFile);
    public sealed virtual void Dispose();
    internal ThreadChain GetThreadChainByIndex(int streamIndex);
    internal ThreadCheckpointChain GetCheckpointChainByIndex(int streamIndex);
    internal T CreateSingletonChain();
    internal T GetSingletonChain();
    internal IntelliTraceTokenChain GetIntelliTraceTokenChainByIndex(int streamIndex);
}
internal class Microsoft.VisualStudio.IntelliTrace.ChainPartition : Partition`1<IntelliTraceEvent> {
    [CompilerGeneratedAttribute]
private EventToken <PartitioningToken>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedListNode`1<PartitionCacheEntry> <UsedListNode>k__BackingField;
    public EventToken PartitioningToken { get; public set; }
    public LinkedListNode`1<PartitionCacheEntry> UsedListNode { get; public set; }
    [CompilerGeneratedAttribute]
public EventToken get_PartitioningToken();
    [CompilerGeneratedAttribute]
public void set_PartitioningToken(EventToken value);
    [CompilerGeneratedAttribute]
public LinkedListNode`1<PartitionCacheEntry> get_UsedListNode();
    [CompilerGeneratedAttribute]
public void set_UsedListNode(LinkedListNode`1<PartitionCacheEntry> value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ChainWeaver : object {
    private List`1<DerivedChain> chains;
    private long totalCount;
    private List`1<EventToken> nextToken;
    private List`1<OrdinalEvent> nextEvent;
    private int currentChainIndex;
    private EventToken currentChainToken;
    private OrdinalEvent currentChainEvent;
    public EventReference Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public long Count { get; }
    public ChainWeaver(DerivedChain[] chains);
    public sealed virtual EventReference get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    public IntelliTraceEvent GetCurrentEvent();
    public void AddChain(DerivedChain chain);
    public void RemoveChain(DerivedChain chain);
    public void Refresh();
    public long get_Count();
    private EventReference GetEventReference(int chainIndex, EventToken chainToken);
}
internal class Microsoft.VisualStudio.IntelliTrace.ChainWeaverWalker : object {
    private OrdinalEvent _nextEvent;
    private ChainWeaver _weaver;
    private int _loggerTid;
    private List`1<EventTracker> _trackers;
    internal ChainWeaverWalker(ChainWeaver weaver, int loggerTid);
    internal void Seek(long ordinal);
    internal void Refresh();
    internal void Refresh(long ordinal);
    internal void AddTracker(EventTracker tracker);
    internal void RemoveTracker(EventTracker tracker);
    internal void AddChain(DerivedChain chain);
    internal void RemoveChain(DerivedChain chain);
}
internal class Microsoft.VisualStudio.IntelliTrace.CheckpointedState : TreeState {
    internal CheckpointedState(Tree tree);
    internal virtual TreeState OnNotifyPoint(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnCheckPoint(ThreadCheckpointEvent eventData);
    internal virtual TreeState OnUIRecordedEvent(DebuggerInteractionEvent eventData);
    internal virtual TreeState OnThrowNP(DiagnosticEvent eventData);
    internal virtual TreeState OnCatchNP(DiagnosticEvent eventData);
    internal virtual TreeState OnExceptionInterceptedNP(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnExceptionStopNP(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnThreadDestroyed(DiagnosticEvent eventData);
    internal virtual TreeState OnMethodEnter(MethodEnterEvent eventData);
    internal virtual TreeState OnMethodExit(MethodExitEvent eventData);
    internal virtual TreeState OnCallsite(CallSiteEvent eventData);
    internal virtual TreeState OnTailCall(TailCallSiteEvent eventData);
    internal virtual TreeState OnExceptionThrown(ExceptionThrownEvent eventData);
    internal virtual TreeState OnExceptionCatcherExit(ExceptionCatchExitEvent eventData);
}
internal class Microsoft.VisualStudio.IntelliTrace.CheckpointedStreamStatistics : StreamStatistics {
    private long _firstEventTime;
    private long _lastEventTime;
    private long _checkpointCount;
    private double _checkpointsPerSecond;
    private double _bytesPerCheckpoint;
    [CompilerGeneratedAttribute]
private long <SampleId>k__BackingField;
    public long SampleId { get; public set; }
    public double BytesPerCheckpoint { get; public set; }
    public long FirstEventTime { get; public set; }
    public long LastEventTime { get; public set; }
    public double CheckpointsPerSecond { get; public set; }
    public long CheckpointCount { get; public set; }
    [CompilerGeneratedAttribute]
public long get_SampleId();
    [CompilerGeneratedAttribute]
public void set_SampleId(long value);
    public double get_BytesPerCheckpoint();
    public void set_BytesPerCheckpoint(double value);
    public long get_FirstEventTime();
    public void set_FirstEventTime(long value);
    public long get_LastEventTime();
    public void set_LastEventTime(long value);
    public double get_CheckpointsPerSecond();
    public void set_CheckpointsPerSecond(double value);
    public long get_CheckpointCount();
    public void set_CheckpointCount(long value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ChildrenEnum : object {
    private EventHandle _originalParent;
    private EventHandle _currentParent;
    private EventHandle _firstParent;
    private int _cursor;
    private int _count;
    private bool IsInFirstSlice { get; }
    public int Count { get; }
    private ChildrenEnum(EventHandle originalParent, EventHandle firstParent, EventHandle currentParent, int cursor);
    internal static ChildrenEnum CreateFromParent(EventHandle parent);
    internal static ChildrenEnum CreateFromSibling(EventHandle sibling);
    private bool get_IsInFirstSlice();
    public sealed virtual int Next(EventHandle[] elements);
    private bool SkipChild(EventHandle childHandle);
    public sealed virtual int Next(EventHandle[] elements, int arrayIndex, int count);
    public sealed virtual int Previous(EventHandle[] elements);
    public sealed virtual int Previous(EventHandle[] elements, int arrayIndex, int count);
    public sealed virtual void Skip(int count);
    public sealed virtual void Reset();
    public sealed virtual void Reset(EnumOrigin origin);
    public sealed virtual int get_Count();
    public sealed virtual IEnum`1<EventHandle> Clone();
    public sealed virtual IEnumerator`1<EventHandle> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.VisualStudio.IntelliTrace.ClassData : LogData {
    protected List`1<LogData> _childValues;
    protected ClassData _baseValue;
    private ClassData _cycleRefValue;
    internal ClassData CycleRefValue { get; internal set; }
    internal ClassData(DataUnavailableReason reason, bool partialData);
    internal ClassData(DataContext context, BlobUnpacker unpacker, bool partialData);
    internal List`1<LogData> GetChildren(List`1<Symbol> childrenSymbols);
    internal virtual ClassData GetBase();
    internal ClassData get_CycleRefValue();
    internal void set_CycleRefValue(ClassData value);
    internal virtual IEnumerable`1<IPendingUnpackData> GetPendingUnpackData();
}
internal class Microsoft.VisualStudio.IntelliTrace.ClassNullableNullData : ClassData {
    internal string GetValue();
}
internal class Microsoft.VisualStudio.IntelliTrace.CLSFormatter : BuiltinDataTypeFormatter {
    public virtual string FormatKeyword(FormatterKeyword keyword);
    protected virtual string FormatType(PrimitiveType type, string typePrefix, string suffix);
    protected sealed virtual void GetMethodAttributeAsPrefixOrPostfix(MethodType method, String& methodPrefixPostfix, Boolean& isPostfix);
}
internal class Microsoft.VisualStudio.IntelliTrace.CodeContext : ValueType {
    internal MethodContext MethodContext;
    internal int ILOffset;
    internal bool IsReturnOffset;
    internal CodeContext(MethodContext methodContext, int ilOffset);
    internal CodeContext(MethodContext methodContext, int ilOffset, bool isReturnOffset);
    public sealed virtual bool Equals(CodeContext other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CodeContext lhs, CodeContext rhs);
    public static bool op_Inequality(CodeContext lhs, CodeContext rhs);
}
internal class Microsoft.VisualStudio.IntelliTrace.CollectionPlan.BindingComparer : NullComparer {
    public sealed virtual bool Equals(_Binding tb, _Binding mb);
    private void VerifyAutoDataQuery(_Binding b);
    public sealed virtual int GetHashCode(_Binding o);
    public sealed virtual int Compare(_Binding x, _Binding y);
    private int CompareField(T x, T y, Func`2<T, IComparable> retrieveField);
    private int CompareQueries(_Binding x, _Binding y);
    private int CompareClassicQueries(_DataQuery[] x, _DataQuery[] y);
    private QueryType GetQueryType(_Binding b);
}
internal class Microsoft.VisualStudio.IntelliTrace.CollectionPlan.CategoryComparer : NullComparer {
    public sealed virtual bool Equals(_Category t, _Category m);
    public sealed virtual int GetHashCode(_Category o);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.CollectionPlan.CollectionPlanExtensions : object {
    public static string GeneratedIDPrefix;
    private static CollectionPlanExtensions();
    [ExtensionAttribute]
public static MergeStatus Merge(_CollectionPlan into, _CollectionPlanFragment merge);
    [ExtensionAttribute]
public static MergeStatus Merge(_CollectionPlan into, _CollectionPlanFragment merge, _CollectionPlan& result);
    [ExtensionAttribute]
public static MergeStatus Merge(_CollectionPlanFragment into, _CollectionPlanFragment merge);
    [ExtensionAttribute]
public static MergeStatus Merge(_CollectionPlanFragment into, _CollectionPlanFragment merge, _CollectionPlanFragment& result);
}
public class Microsoft.VisualStudio.IntelliTrace.CollectionPlan.CollectionPlanMergeException : Exception {
    public CollectionPlanMergeException(string message);
    public CollectionPlanMergeException(SerializationInfo sinfo, StreamingContext sContext);
    public CollectionPlanMergeException(string message, Exception inner);
}
internal class Microsoft.VisualStudio.IntelliTrace.CollectionPlan.CollectionPlanMerger : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<MergeEventArgs> MergeEvent;
    [CompilerGeneratedAttribute]
public void add_MergeEvent(EventHandler`1<MergeEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MergeEvent(EventHandler`1<MergeEventArgs> value);
    public MergeStatus MergeInto(_CollectionPlan into, _CollectionPlanFragment merge);
    public MergeStatus Merge(_CollectionPlan target, _CollectionPlanFragment merge, _CollectionPlan& result);
    public MergeStatus MergeInto(_CollectionPlanFragment into, _CollectionPlanFragment merge);
    public MergeStatus Merge(_CollectionPlanFragment target, _CollectionPlanFragment merge, _CollectionPlanFragment& result);
    private MergeStatus MergeInto(_HiddenTracePointProvider into, _HiddenTracePointProvider merge);
    private _DiagnosticEventSpecification[] MergeDiagnosticEventSpecifications(_DiagnosticEventSpecification[] target, _DiagnosticEventSpecification[] merge, Dictionary`2<string, string> categoryResolutions, Dictionary`2<string, string> moduleResolutions, MergeStatus status);
    private void MergeDataQueries(_Binding replaced, _Binding replacement);
    private _Category[] MergeCategories(_Category[] target, _Category[] merge, Dictionary`2& categoryResolutions, MergeStatus status);
    private _ModuleSpecification[] MergeModuleSpecifications(_ModuleSpecification[] target, _ModuleSpecification[] merge, Dictionary`2& moduleResolutions, MergeStatus status);
    private bool TestNullMerge(T[] target, T[] merge, T[]& result);
    private IEnumerable`1<T> LinqMerge(T[] target, T[] merge, IDFieldGetter`1<T> GetID, IEqualityComparer`1<T> valueComparer, IEnumerable`1& conflicts);
    private Dictionary`2<string, string> ResolveConflicts(IEnumerable`1<Tuple`2<T, T>> conflicts, IDFieldGetter`1<T> GetID, IDFieldSetter`1<T> SetID, Duplicator`1<T> Duplicate, IEqualityComparer`1<T> valueComparer, string section, MergeStatus status);
    private void OnMergeEvent(MergeEventArgs args);
}
internal class Microsoft.VisualStudio.IntelliTrace.CollectionPlan.IDComparer`1 : NullComparer {
    private IDFieldGetter`1<T> _GetId;
    public IDComparer`1(IDFieldGetter`1<T> GetId);
    public sealed virtual int Compare(T x, T y);
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
}
internal class Microsoft.VisualStudio.IntelliTrace.CollectionPlan.MergeStatus : object {
    public static MergeStatus OK;
    [CompilerGeneratedAttribute]
private MergeStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    private List`1<MergeStatus> _subStatuses;
    public MergeStatusCode StatusCode { get; private set; }
    public string Message { get; public set; }
    public string CodedMessage { get; }
    public IEnumerable`1<MergeStatus> SubStatuses { get; }
    public IEnumerable`1<MergeStatus> AllStatuses { get; }
    public MergeStatus(MergeStatusCode code, string message);
    public MergeStatus(MergeStatusCode code);
    private static MergeStatus();
    [CompilerGeneratedAttribute]
public MergeStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
private void set_StatusCode(MergeStatusCode value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public string get_CodedMessage();
    public IEnumerable`1<MergeStatus> get_SubStatuses();
    public IEnumerable`1<MergeStatus> get_AllStatuses();
    public void Combine(ICollection`1<MergeStatus> statuses);
    public void Combine(MergeStatus status);
}
internal enum Microsoft.VisualStudio.IntelliTrace.CollectionPlan.MergeStatusCode : Enum {
    public int value__;
    public static MergeStatusCode OK;
    public static MergeStatusCode Warning;
    public static MergeStatusCode Error;
}
internal class Microsoft.VisualStudio.IntelliTrace.CollectionPlan.ModuleComparer : NullComparer {
    public sealed virtual bool Equals(_ModuleSpecification t, _ModuleSpecification m);
    public sealed virtual int GetHashCode(_ModuleSpecification o);
}
public class Microsoft.VisualStudio.IntelliTrace.CollectionPlanEvent : OrdinalEvent {
    private _CollectionPlan collectionPlan;
    private string collectionPlanXml;
    public string CollectionPlan { get; }
    internal _CollectionPlan InnerEvent { get; }
    internal CollectionPlanEvent(_CollectionPlan cp);
    public string get_CollectionPlan();
    internal _CollectionPlan get_InnerEvent();
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal static class Microsoft.VisualStudio.IntelliTrace.Common.DebuggerStringFormatUtility : object {
    private static char Delimiter;
    internal static string CSLanguageName;
    internal static string VBLanguageName;
    internal static string CPlusPlusLanguageName;
    internal static string BooleanTypeName;
    internal static string CharTypeName;
    internal static string SByteTypeName;
    internal static string ByteTypeName;
    internal static string Int16TypeName;
    internal static string UInt16TypeName;
    internal static string Int32TypeName;
    internal static string UInt32TypeName;
    internal static string Int64TypeName;
    internal static string UInt64TypeName;
    internal static string SingleTypeName;
    internal static string DoubleTypeName;
    internal static string IntPtrTypeName;
    internal static string UIntPtrTypeName;
    internal static string StringTypeName;
    internal static string ObjectTypeName;
    internal static string DecimalTypeName;
    internal static string DateTimeTypeName;
    private static DebuggerStringFormatUtility();
    public static string CharFormatRawToCSharp(char value, bool isStringFormatting);
    public static string StringFormatRawToCSharp(string value, bool isPartialData);
    public static string CharFormatRawToVB(char value);
    public static string StringFormatRawToVB(string value, bool isPartialData);
    public static void AddTruncationSuffix(bool truncated, StringBuilder sb);
    public static string AddTruncationSuffix(bool truncated, string value);
    public static string RemoveTruncationSuffix(string value, Boolean& isPartialData);
    public static string GetFCLTypeName(string typeName, string languageName);
    public static string GetRawDataValue(string value, string formattedTypeName, string languageName, Boolean& isPartialData);
    private static char CharFormatCSharpToRaw(string value);
    private static char CharFormatCSharpToRaw(char value);
    private static string StringFormatCSharpToRaw(string value, Boolean& isPartialData);
    private static char CharFormatVBToRaw(string value);
    private static string StringFormatVBToRaw(string value, Boolean& isPartialData);
}
internal static class Microsoft.VisualStudio.IntelliTrace.Common.FeatureFlagsRegistry : object {
    public static string IntelliTraceProcessSnapshotAD7ALIntegration;
    private static string DefaultVsRoot;
    private static Dictionary`2<string, bool> s_enabledCache;
    private static FeatureFlagsRegistry();
    public static bool IsFeatureFlagEnabled(string featureName);
    private static bool IsFeatureFlagEnabledInRegistry(string featureName);
    private static Nullable`1<bool> CheckValue(string root, string featureName);
}
internal static class Microsoft.VisualStudio.IntelliTrace.Common.IntelliTraceConstants : object {
    public static string NPEventDataNotifyIdPropName;
}
internal static class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.ComponentGuids : object {
    public static Guid IntelliTraceCustomMessage;
    public static Guid CoreComponentId;
    public static Guid ClientComponentId;
    public static Guid IntelliTraceSymbolMessage;
    public static Guid IntelliTraceStackMessage;
    public static Guid IntelliTraceBreakpointSourceId;
    public static Guid DebuggerToolComponentId;
    public static Guid DebuggerToolSourceId;
    public static Guid IntelliTraceNativeExceptionSourceId;
    private static ComponentGuids();
}
internal class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.ContinuousCaughtExceptionExtraData : object {
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    public string ModuleName { get; }
    public ContinuousCaughtExceptionExtraData(string moduleName);
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    public sealed virtual int GetByteCount();
    public sealed virtual Byte[] ToByteArray();
    public static ContinuousCaughtExceptionExtraData ReadFromBytes(Byte[] rawBytes);
}
internal static class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.ContinuousEventCodes : object {
    public static int DiagnosticEvent;
    public static int ProcessExit;
    public static int SymbolLoad;
    public static int PdqTruncation;
    public static int ThreadCreate;
    public static int ThreadNameChange;
    public static int ThreadDestroy;
    public static int DiagnosticEventBindingFailure;
    public static int AssociateSnapshotException;
    public static int NativeException;
}
internal static class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.ContinuousEventExtraDataUtilities : object {
    public static T ReadFromBytes(Byte[] rawBytes);
    public static int GetStringByteCount(string value);
    public static void WriteString(BinaryWriter writer, string value);
    public static string ReadString(BinaryReader reader);
}
internal class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.ContinuousEventMessageData : object {
    private static int HeaderSize;
    private static int GuidSize;
    private Byte[] extraDataByte;
    [CompilerGeneratedAttribute]
private Byte[] <RawMessagePackerData>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <StackModuleIds>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <UniqueProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private IContinuousEventExtraData <ExtraData>k__BackingField;
    public Byte[] RawMessagePackerData { get; }
    public Int32[] StackModuleIds { get; }
    public Guid UniqueProcessId { get; }
    private IContinuousEventExtraData ExtraData { get; private set; }
    public ContinuousEventMessageData(Byte[] rawMessagePackerData, Int32[] moduleIds, Guid uniqueProcessId, IContinuousEventExtraData extraData);
    [CompilerGeneratedAttribute]
public Byte[] get_RawMessagePackerData();
    [CompilerGeneratedAttribute]
public Int32[] get_StackModuleIds();
    [CompilerGeneratedAttribute]
public Guid get_UniqueProcessId();
    [CompilerGeneratedAttribute]
private IContinuousEventExtraData get_ExtraData();
    [CompilerGeneratedAttribute]
private void set_ExtraData(IContinuousEventExtraData value);
    public static ContinuousEventMessageData ReadFromBytes(Byte[] rawBytes);
    public bool HasExtraData();
    public T GetExtraData();
    public Byte[] ToByteArray();
}
internal class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.ContinuousThreadMessageData : object {
    private static int GuidSize;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ThreadName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <UniqueProcessId>k__BackingField;
    public int ThreadId { get; }
    public string ThreadName { get; }
    public Guid UniqueProcessId { get; }
    public ContinuousThreadMessageData(int threadId, string threadName, Guid uniqueProcessId);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
public string get_ThreadName();
    [CompilerGeneratedAttribute]
public Guid get_UniqueProcessId();
    public static ContinuousThreadMessageData ReadFromBytes(Byte[] rawBytes);
    public Byte[] ToByteArray();
}
internal class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.ContinuousThrownExceptionExtraData : object {
    private static int MinimumDataSize;
    [CompilerGeneratedAttribute]
private bool <HaveSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExceptionId>k__BackingField;
    [CompilerGeneratedAttribute]
private _StackFrame[] <Stack>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    public bool HaveSnapshot { get; }
    public int ExceptionId { get; }
    public _StackFrame[] Stack { get; }
    public string ModuleName { get; }
    public ContinuousThrownExceptionExtraData(bool haveSnapshot, int exceptionId, _StackFrame[] stack, string moduleName);
    [CompilerGeneratedAttribute]
public bool get_HaveSnapshot();
    [CompilerGeneratedAttribute]
public int get_ExceptionId();
    [CompilerGeneratedAttribute]
public _StackFrame[] get_Stack();
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    public sealed virtual int GetByteCount();
    public sealed virtual Byte[] ToByteArray();
    public static ContinuousThrownExceptionExtraData ReadFromBytes(Byte[] rawBytes);
}
internal enum Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.DiagnosticEventBindingFailureReason : Enum {
    public int value__;
    public static DiagnosticEventBindingFailureReason Unknown;
    public static DiagnosticEventBindingFailureReason HResult;
    public static DiagnosticEventBindingFailureReason NoFrame;
}
internal interface Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.IContinuousEventExtraData {
    public abstract virtual int GetByteCount();
    public abstract virtual Byte[] ToByteArray();
}
internal static class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.MessageCodes : object {
    public static int None;
    public static int ProcessState;
    public static int ThreadCreate;
    public static int ThreadExit;
    public static int Exception;
    public static int ThreadNameChange;
    public static int NativeException;
}
internal class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.NativeExceptionInformation : object {
    [CompilerGeneratedAttribute]
private int <ExceptionId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionName>k__BackingField;
    private static int _exceptionIdCounter;
    public int ExceptionId { get; }
    public UInt32 ThreadId { get; }
    public ulong EventId { get; }
    public long EventTime { get; }
    public string ExceptionName { get; }
    public NativeExceptionInformation(UInt32 threadId, ulong eventId, long eventTime, string exceptionName);
    public NativeExceptionInformation(int exceptionId, UInt32 threadId, ulong eventId, long eventTime, string exceptionName);
    [CompilerGeneratedAttribute]
public int get_ExceptionId();
    [CompilerGeneratedAttribute]
public UInt32 get_ThreadId();
    [CompilerGeneratedAttribute]
public ulong get_EventId();
    [CompilerGeneratedAttribute]
public long get_EventTime();
    [CompilerGeneratedAttribute]
public string get_ExceptionName();
    public static NativeExceptionInformation ReadFromBytes(Byte[] rawData);
    public Byte[] ToByteArray();
}
internal static class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.SideLoadStopCodes : object {
    public static int ReadyToSideLoad;
}
internal static class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.StackWalkMessageCodes : object {
    public static int None;
    public static int GetManagedStack;
}
internal static class Microsoft.VisualStudio.IntelliTrace.ConcordIntegration.SymbolCodes : object {
    public static int CreateSymUnmanagedReader;
    public static int GetMethod;
    public static int GetMethodVersion;
    public static int GetMethodsInDocument;
    public static int GetSequencePointCount;
    public static int GetSequencePoints;
    public static int GetToken;
    public static int GetLanguage;
    public static int GetURL;
    public static int GetCheckSum;
    public static int GetCheckSumAlgorithmId;
    public static int GetDocument;
    public static int DisposeDocument;
    public static int DisposeMethod;
    public static int DisposeSymReader;
    public static int GetSourceServerData;
}
internal class Microsoft.VisualStudio.IntelliTrace.ConfigurationTracker : EventTracker {
    private TraceLogConfiguration _config;
    internal virtual void HandleEvent(CollectionPlanEvent collectionPlan, EventHandle handle);
    internal TraceLogConfiguration GetConfiguration();
    internal static Dictionary`2<int, HeuristicNotifyPointSpecification> LoadNPTable(_CollectionPlan cp);
    private static void LoadKnownNotifyPoints(Dictionary`2<int, HeuristicNotifyPointSpecification> notifyPointIdentityTable);
    internal static Dictionary`2<string, string> LoadCategories(_CollectionPlan cp);
}
internal class Microsoft.VisualStudio.IntelliTrace.ConstNode : ExprNode {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    internal string Value { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(string value);
    internal virtual Expr`2<T, bool> CompileBoolExpr();
    internal virtual Expr`2<T, int> CompileIntExpr();
    internal virtual Expr`2<T, long> CompileLongExpr();
    internal virtual Expr`2<T, string> CompileStringExpr();
    [CompilerGeneratedAttribute]
private string <CompileStringExpr>b__7_0(T input);
}
internal class Microsoft.VisualStudio.IntelliTrace.CorProfBlobPacker : object {
    private static Byte[] _nullArray;
    internal static Int32[] _elementSizes;
    private BinaryWriter _writer;
    public CorProfBlobPacker(int capacity);
    private static CorProfBlobPacker();
    public int GetCurrentIndex();
    public Byte[] ToByteArray();
    public Byte[] GetBuffer();
    public void Pack(bool value);
    public void Pack(sbyte value);
    public void Pack(byte value);
    public void Pack(char value);
    public void Pack(short value);
    public void Pack(ushort value);
    public void Pack(int value);
    public void Pack(UInt32 value);
    public void Pack(long value);
    public void Pack(ulong value);
    public void Pack(float value);
    public void Pack(double value);
    public void Pack(string value);
    public void PackHeader(Array value);
    public static int GetArraySize(Int32[] arrayInt, Type elementType, ElementType arrayType);
    public void Pack(Byte[] buffer);
    public void Pack(Byte[] buffer, int index, int count);
    public void Pack(String[] value);
    public static Byte[] GetPackedArrayStrings(String[] array, int len);
    private static ElementType GetElementType(Type type);
    public static Byte[] PackString(string s);
    public void PackLength(UInt32 length, bool partial);
    public void PackLength(UInt32 length);
    public void PackElementNonNull();
    public void PackElementNull();
    public void PackUncollectedRef();
    private void ThrowIfDisposed();
    public sealed virtual void Dispose();
    internal void Seek(int seekLocation, SeekOrigin seekOrigin);
}
internal class Microsoft.VisualStudio.IntelliTrace.CorProfBlobUnpacker : BlobUnpacker {
    private static Type _tInt32;
    private static Type _tUInt32;
    private static Type _tInt16;
    private static Type _tUInt16;
    private static Type _tInt64;
    private static Type _tUInt64;
    private static Type _tChar;
    private static Type _tString;
    private static Type _tByte;
    private static Type _tSByte;
    private static Type _tBoolean;
    private static Type _tIntPtr;
    private static Type _tFloat32;
    private static Type _tFloat64;
    internal CorProfBlobUnpacker(Byte[] memory, int lowerBound, int upperBound, int pointerSizeBytes);
    internal CorProfBlobUnpacker(Byte[] memory, int pointerSizeBytes);
    private static CorProfBlobUnpacker();
    public virtual UnpackResult Unpack(String& value, Int32& originalSize);
    public virtual UnpackResult UnpackLength(Int32& length);
    public virtual UnpackResult Unpack(bool isNestedField, Type elementType, BlobUnpacker& value, ArrayDimensionLayout[] dimensions, Int16& savedElements);
    public object GetElementValue(Type type);
    public virtual UnpackResult Unpack(BlobUnpacker& unpacker, ObjectLayout layout, bool isValueType);
    public virtual UnpackResult Unpack(BlobUnpacker& unpacker);
    public virtual UnpackResult UnpackRest(BlobUnpacker& unpacker);
    public virtual int UnpackInvalidRefDepth();
    public virtual void BeforeUnpack(int typeSize);
    public virtual void AfterUnpack(int typeSize);
}
internal static class Microsoft.VisualStudio.IntelliTrace.CustomEventConstants : object {
    public static string DebuggerEventId;
    public static string ExceptionEventId;
}
internal class Microsoft.VisualStudio.IntelliTrace.DataContext : object {
    private static int CachedIndex;
    private EventHandle _evt;
    private TraceLog _log;
    private IntelliTraceEvent _e;
    private int _extendedDataLocation;
    [CompilerGeneratedAttribute]
private EventHandler`1<UnpackEventArgs> ValueUnpackStart;
    [CompilerGeneratedAttribute]
private EventHandler`1<UnpackEventArgs> ValueUnpackEnd;
    [CompilerGeneratedAttribute]
private EventHandler`1<UnpackEventArgs> TokenUnpackStart;
    [CompilerGeneratedAttribute]
private EventHandler`1<UnpackEventArgs> TokenUnpackEnd;
    internal TraceLog Log { get; }
    internal EventHandle ChainEvent { get; }
    internal string LogName { get; }
    internal DataContext(TraceLog log, EventHandle evt);
    internal DataContext(TraceLog log, IntelliTraceEvent e);
    [CompilerGeneratedAttribute]
internal void add_ValueUnpackStart(EventHandler`1<UnpackEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ValueUnpackStart(EventHandler`1<UnpackEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_ValueUnpackEnd(EventHandler`1<UnpackEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ValueUnpackEnd(EventHandler`1<UnpackEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_TokenUnpackStart(EventHandler`1<UnpackEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_TokenUnpackStart(EventHandler`1<UnpackEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_TokenUnpackEnd(EventHandler`1<UnpackEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_TokenUnpackEnd(EventHandler`1<UnpackEventArgs> value);
    internal TraceLog get_Log();
    internal EventHandle get_ChainEvent();
    internal T GetEvent();
    internal LogData GetData();
    private LogData GetIndependentData(DiagnosticEvent npe);
    internal List`1<LogData> GetParameters(BlobUnpacker unpacker, Symbol retSymbol, Symbol thisSymbol, List`1<Symbol> paramSymbols);
    internal List`1<LogData> GetParameters(BlobUnpacker unpacker, Symbol retSymbol, Symbol thisSymbol, List`1<Symbol> paramSymbols, Int32& extendedDataLocation, bool readNestedParameters);
    internal int GetExtendedDataLocation(BlobUnpacker unpacker, Symbol retSymbol, Symbol thisSymbol, List`1<Symbol> paramSymbols);
    internal CorProfBlobUnpacker GetExtendedDataSection(SectionId id, BlobUnpacker unpacker, Symbol retSymbol, Symbol thisSymbol, List`1<Symbol> paramSymbols);
    private bool TryGetEventKind(Boolean& isEnterEvent, Boolean& isExitEvent);
    internal void UnpackNestData(BlobUnpacker unpacker, List`1<LogData> paramValues);
    internal static IEnumerable`1<IPendingUnpackData> GetPendingNestedItems(ClassData classData);
    private Type DecideRuntimeType(BlobUnpacker unpacker, Symbol symbol, Type type);
    internal bool IsTokenNeeded(Type type);
    private Type UnpackRuntimeType(BlobUnpacker unpacker, Type type);
    internal LogData GetReturnValue(BlobUnpacker unpacker, Symbol returnSymbol);
    private LogData InternalGetReturnValue(BlobUnpacker unpacker, Symbol returnSymbol);
    internal List`1<LogData> GetFields(BlobUnpacker unpacker, List`1<Symbol> fieldSymbols);
    public List`1<LogData> GetChildren(BlobUnpacker unpacker, List`1<Symbol> childrenSymbols);
    internal LogData Dereference(BlobUnpacker unpacker, Symbol elementSymbol);
    internal List`1<ArrayElement> GetArrayElements(ArrayBlobUnpacker unpacker, Type elementType, ArrayDimensionLayout[] dimensionLengths, short totalElements);
    internal static Type GetRootElementType(Type type);
    internal List`1<ArrayElement> GetArrayElements(NestedArrayBlobUnpacker unpacker, Type elementType, ArrayDimensionLayout[] dimensionLengths, short totalElements);
    private bool IsReferenceType(Type type);
    private LogData UnpackValueOfType(BlobUnpacker unpacker, Type objectType, bool isNestedField);
    private ObjectLayout BuildLayout(BlobUnpacker unpacker, TypeDefType classType);
    private ObjectLayout BuildLayoutHelper(BlobUnpacker unpacker, TypeDefType classType);
    private void ResolveGenericType(BlobUnpacker unpacker, GenericType genericType);
    public void ResolveGenericType(int protToken, GenericType genericType);
    internal IDictionary`2<string, object> GetPropertyBag();
    internal string get_LogName();
}
internal class Microsoft.VisualStudio.IntelliTrace.DataElement : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPartialData>k__BackingField;
    private Symbol symbol;
    private LogData data;
    private Type type;
    private List`1<IDataElement> children;
    private static CLSFormatter formatter;
    public string Name { get; private set; }
    public string Value { get; private set; }
    public string TypeName { get; private set; }
    public bool HasChildren { get; }
    public bool HasPartialData { get; private set; }
    internal DataElement(Symbol symbol, LogData data);
    private static DataElement();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeName();
    [CompilerGeneratedAttribute]
private void set_TypeName(string value);
    public sealed virtual bool get_HasChildren();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasPartialData();
    [CompilerGeneratedAttribute]
private void set_HasPartialData(bool value);
    public virtual IList`1<IDataElement> GetChildren();
    internal static Type GetSymbolType(Symbol symbol);
}
internal class Microsoft.VisualStudio.IntelliTrace.DataProvider : object {
    public static string ProviderIntelliTrace;
    public static string ProviderAvicode;
    private static Version DefaultVersion;
    private _CollectionPlan _collectionPlan;
    private IDictionary`2<int, HeuristicNotifyPointSpecification> _npTable;
    [CompilerGeneratedAttribute]
private string <ProviderName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CategoryVersion> <CategoryVersions>k__BackingField;
    private IDictionary`2<int, HeuristicNotifyPointSpecification> NpTable { get; }
    public string ProviderName { get; private set; }
    internal IEnumerable`1<CategoryVersion> CategoryVersions { get; private set; }
    internal DataProvider(_CollectionPlan cp);
    private static DataProvider();
    private IDictionary`2<int, HeuristicNotifyPointSpecification> get_NpTable();
    [CompilerGeneratedAttribute]
public string get_ProviderName();
    [CompilerGeneratedAttribute]
private void set_ProviderName(string value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<CategoryVersion> get_CategoryVersions();
    [CompilerGeneratedAttribute]
private void set_CategoryVersions(IEnumerable`1<CategoryVersion> value);
    public string GetNotifyPointMethodName(int notifyId);
    public Version GetVersionForCategory(string category);
    private void ExtractDataProviderInformation(_CollectionPlan collectionPlan);
    private static Version ConvertToVersion(_Version versionInCollectionPlan);
}
internal class Microsoft.VisualStudio.IntelliTrace.DataQuery : object {
    private Dictionary`2<int, Dictionary`2<string, string>> _attributes;
    private Dictionary`2<int, String[]> _fieldIds;
    private List`1<QueryInput> _dataQuery;
    private UInt32 _cbDataBufferSize;
    private static Dictionary`2<ElementType, int> _encodedtypeSizes;
    private static int NullReferenceSize;
    public Dictionary`2<int, Dictionary`2<string, string>> Attributes { get; }
    public List`1<QueryInput> Query { get; }
    public Dictionary`2<int, String[]> FieldIds { get; }
    public UInt32 DataBufferSize { get; }
    public DataQuery(_DataQuery[] dq);
    private static DataQuery();
    public void Write(XmlWriter writer);
    public void AddPrimitiveQuery(UInt32 paramIndex, String[] fieldIds, string name, ElementType eType);
    public void AddStringQuery(UInt32 paramIndex, String[] fieldIds, string name, ElementType eType, UInt32 maxResultBytes);
    public void AddQuery(UInt32 paramIndex, String[] fieldIds, UInt32 maxEncodedBytes, byte corElementTypeOfFirstTransition);
    public void AddExceptionQuery();
    public Dictionary`2<int, Dictionary`2<string, string>> get_Attributes();
    public List`1<QueryInput> get_Query();
    public Dictionary`2<int, String[]> get_FieldIds();
    public UInt32 get_DataBufferSize();
    private int GetEncodedTypeSize(ElementType type);
    private static UInt32 GetEncodedStringSize(UInt32 minCharCount);
}
public class Microsoft.VisualStudio.IntelliTrace.DataRequestedEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    public long EventTime { get; private set; }
    internal DataRequestedEvent(LogDataRequested* pData);
    [CompilerGeneratedAttribute]
public long get_EventTime();
    [CompilerGeneratedAttribute]
private void set_EventTime(long value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.DataTruncatedException : Exception {
    public DataTruncatedException(string message, TimeoutException innerException);
    protected DataTruncatedException(SerializationInfo info, StreamingContext context);
}
internal enum Microsoft.VisualStudio.IntelliTrace.DataUnavailableReason : Enum {
    public int value__;
    public static DataUnavailableReason None;
    public static DataUnavailableReason Null;
    public static DataUnavailableReason Uncollected;
    public static DataUnavailableReason Remoted;
    public static DataUnavailableReason VersionMismatch;
    public static DataUnavailableReason UnpackError;
    public static DataUnavailableReason CycleRef;
}
public class Microsoft.VisualStudio.IntelliTrace.DebugDirectory : object {
    [CompilerGeneratedAttribute]
private IList`1<byte> <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<byte> <Data>k__BackingField;
    public IList`1<byte> Directory { get; private set; }
    public IList`1<byte> Data { get; private set; }
    internal DebugDirectory(DebugDirectory* pDebugDirectory);
    [CompilerGeneratedAttribute]
public IList`1<byte> get_Directory();
    [CompilerGeneratedAttribute]
private void set_Directory(IList`1<byte> value);
    [CompilerGeneratedAttribute]
public IList`1<byte> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(IList`1<byte> value);
}
internal static class Microsoft.VisualStudio.IntelliTrace.DebugExtendedPropertyKeys : object {
    public static string EventTime;
    public static string ActivityId;
}
public class Microsoft.VisualStudio.IntelliTrace.DebuggerInteractionEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private int <NativeThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StackFrameIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private DebuggerInteractionSource <DebuggerInteractionSource>k__BackingField;
    private List`1<IDataElement> _data;
    public int NativeThreadId { get; private set; }
    public int StackFrameIndex { get; private set; }
    public DebuggerInteractionSource DebuggerInteractionSource { get; private set; }
    public IList`1<IDataElement> Data { get; }
    internal DebuggerInteractionEvent(UIContents* pData);
    [CompilerGeneratedAttribute]
public int get_NativeThreadId();
    [CompilerGeneratedAttribute]
private void set_NativeThreadId(int value);
    [CompilerGeneratedAttribute]
public int get_StackFrameIndex();
    [CompilerGeneratedAttribute]
private void set_StackFrameIndex(int value);
    [CompilerGeneratedAttribute]
public DebuggerInteractionSource get_DebuggerInteractionSource();
    [CompilerGeneratedAttribute]
private void set_DebuggerInteractionSource(DebuggerInteractionSource value);
    public IList`1<IDataElement> get_Data();
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
    private IDataElement CreateDataElement(Property* pData);
}
public enum Microsoft.VisualStudio.IntelliTrace.DebuggerInteractionSource : Enum {
    public int value__;
    public static DebuggerInteractionSource Unknown;
    public static DebuggerInteractionSource WatchWindow;
    public static DebuggerInteractionSource LocalsWindow;
    public static DebuggerInteractionSource AutosWindow;
    public static DebuggerInteractionSource QuickWatchWindow;
    public static DebuggerInteractionSource ImmediateWindow;
    public static DebuggerInteractionSource Tracepoint;
    public static DebuggerInteractionSource DataTip;
}
internal static class Microsoft.VisualStudio.IntelliTrace.DebugPropertyGuids : object {
    public static Guid guidFilterLocals;
    public static Guid guidFilterAllLocals;
    public static Guid guidFilterArgs;
    public static Guid guidFilterLocalsPlusArgs;
    public static Guid guidFilterAllLocalsPlusArgs;
    public static Guid guidFilterRegisters;
    public static Guid guidFilterThis;
    public static Guid guidFilterAutoRegisters;
    public static Guid guidFilterAllCollected;
    public static Guid guidIntelliTraceExtended;
    private static DebugPropertyGuids();
}
internal class Microsoft.VisualStudio.IntelliTrace.DelegateTreeVisitor : object {
    [CompilerGeneratedAttribute]
private ExecuteNode ExecuteOnEnter;
    [CompilerGeneratedAttribute]
private ExecuteNode ExecuteOnExit;
    [CompilerGeneratedAttribute]
private ExecuteNode ExecuteOnCallsite;
    [CompilerGeneratedAttribute]
private ExecuteNode ExecuteOnStatement;
    [CompilerGeneratedAttribute]
public void add_ExecuteOnEnter(ExecuteNode value);
    [CompilerGeneratedAttribute]
public void remove_ExecuteOnEnter(ExecuteNode value);
    [CompilerGeneratedAttribute]
public void add_ExecuteOnExit(ExecuteNode value);
    [CompilerGeneratedAttribute]
public void remove_ExecuteOnExit(ExecuteNode value);
    [CompilerGeneratedAttribute]
public void add_ExecuteOnCallsite(ExecuteNode value);
    [CompilerGeneratedAttribute]
public void remove_ExecuteOnCallsite(ExecuteNode value);
    [CompilerGeneratedAttribute]
public void add_ExecuteOnStatement(ExecuteNode value);
    [CompilerGeneratedAttribute]
public void remove_ExecuteOnStatement(ExecuteNode value);
    public sealed virtual void OnCallsite(ITreeNode node, int depth);
    public sealed virtual void OnStatement(ITreeNode node, int depth);
    public sealed virtual void OnEnter(EventHandle handle, int depth);
    public sealed virtual void OnExit(EventHandle handle, int depth);
}
public abstract class Microsoft.VisualStudio.IntelliTrace.DerivedChain : Chain {
    public abstract virtual void Refresh();
}
public class Microsoft.VisualStudio.IntelliTrace.DiagnosticChain : PartitionedListChain {
    private DiagnosticCheckpointChain _checkpointChain;
    private long _firstVisibleOrdinal;
    private Nullable`1<EventToken> _firstVisibleToken;
    public EventToken FirstValidToken { get; }
    internal DiagnosticChain(DiagnosticStreamChain streamChain, DiagnosticCheckpointChain checkpointChain);
    internal DiagnosticChain(DiagnosticStreamChain streamChain, DiagnosticCheckpointChain checkpointChain, PartitionCache partitionCache);
    public virtual void Refresh();
    protected virtual void OnPartitionUpdate(PartitioningEvent partitioningEvent, IList`1<IntelliTraceEvent> events);
    private void EnsureFirstVisibleToken();
    public virtual EventToken get_FirstValidToken();
    public virtual bool IsValidToken(EventToken token);
}
public class Microsoft.VisualStudio.IntelliTrace.DiagnosticCheckpointChain : ListChain {
    internal DiagnosticCheckpointChain(DiagnosticCheckpointStreamChain sourceChain);
}
public class Microsoft.VisualStudio.IntelliTrace.DiagnosticCheckpointEvent : PartitioningEvent {
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ThreadStack> <ThreadStacks>k__BackingField;
    public long EventTime { get; private set; }
    public IList`1<ThreadStack> ThreadStacks { get; private set; }
    internal DiagnosticCheckpointEvent(long globalOrdinal, long streamOrdinal, long streamOffset);
    internal DiagnosticCheckpointEvent(long globalOrdinal, long streamOrdinal, long streamOffset, long firstVisibleStreamOrdinal);
    internal DiagnosticCheckpointEvent(SimpleCheckpointData* pCheckpointData);
    [CompilerGeneratedAttribute]
public sealed virtual long get_EventTime();
    [CompilerGeneratedAttribute]
private void set_EventTime(long value);
    [CompilerGeneratedAttribute]
public IList`1<ThreadStack> get_ThreadStacks();
    [CompilerGeneratedAttribute]
private void set_ThreadStacks(IList`1<ThreadStack> value);
    internal _SimpleCheckpointData AsPackable();
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
    internal ThreadStack GetStack(int threadId);
}
public class Microsoft.VisualStudio.IntelliTrace.DiagnosticCheckpointStreamChain : StreamChain {
    internal MessagePackerMessageMemory memory;
    internal MessageMemoryByteArray managedMemory;
    private DiagnosticCheckpointEventsMessagePacker packer;
    internal DiagnosticCheckpointStreamChain(LogStream stream, DiagnosticCheckpointEventsMessagePacker packer);
    protected virtual Byte[] ReadEventBytes();
    protected virtual int ReadEventLength();
    protected virtual IntelliTraceEvent ConvertToEvent(EventToken token, Byte[] data, Int32& offset);
    protected virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
}
public class Microsoft.VisualStudio.IntelliTrace.DiagnosticEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private int <NativeThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<byte> <DataBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DebuggerId>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IntelliTraceStackFrame> <FramesWithCommonRoot>k__BackingField;
    private int _stackFramesInCommon;
    [CompilerGeneratedAttribute]
private List`1<DebuggerInteractionEvent> <UIContents>k__BackingField;
    private IList`1<IntelliTraceStackFrame> _stack;
    public int NativeThreadId { get; private set; }
    public int EventId { get; private set; }
    public string Name { get; private set; }
    public long EventTime { get; private set; }
    public Nullable`1<Guid> ActivityId { get; private set; }
    public IList`1<byte> DataBytes { get; private set; }
    public long DebuggerId { get; private set; }
    internal IList`1<IntelliTraceStackFrame> FramesWithCommonRoot { get; private set; }
    public int StackFramesInCommon { get; private set; }
    internal List`1<DebuggerInteractionEvent> UIContents { get; private set; }
    public IList`1<IntelliTraceStackFrame> StackFrames { get; }
    internal DiagnosticEvent(long ordinal);
    internal DiagnosticEvent(NotifyPointData* pData);
    internal DiagnosticEvent(long ordinal, int threadId, int eventId, IList`1<IntelliTraceStackFrame> frames, IList`1<byte> dataBytes, string name, int stackFramesInCommon, long debuggerId);
    [CompilerGeneratedAttribute]
public int get_NativeThreadId();
    [CompilerGeneratedAttribute]
private void set_NativeThreadId(int value);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_EventTime();
    [CompilerGeneratedAttribute]
private void set_EventTime(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ActivityId();
    [CompilerGeneratedAttribute]
private void set_ActivityId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public IList`1<byte> get_DataBytes();
    [CompilerGeneratedAttribute]
private void set_DataBytes(IList`1<byte> value);
    [CompilerGeneratedAttribute]
public long get_DebuggerId();
    [CompilerGeneratedAttribute]
private void set_DebuggerId(long value);
    [CompilerGeneratedAttribute]
internal IList`1<IntelliTraceStackFrame> get_FramesWithCommonRoot();
    [CompilerGeneratedAttribute]
private void set_FramesWithCommonRoot(IList`1<IntelliTraceStackFrame> value);
    public int get_StackFramesInCommon();
    private void set_StackFramesInCommon(int value);
    [CompilerGeneratedAttribute]
internal List`1<DebuggerInteractionEvent> get_UIContents();
    [CompilerGeneratedAttribute]
private void set_UIContents(List`1<DebuggerInteractionEvent> value);
    internal bool TryGetTopFrame(IIntelliTraceTokenProvider tokenProvider, ProgramSymbols programSymbols, IntelliTraceStackFrame& stackFrame, Int32& metadataToken, Guid& mvid, ModuleSymbols& modSyms);
    internal void AddCommonFrames(IList`1<IntelliTraceStackFrame> baseline);
    public IList`1<IntelliTraceStackFrame> get_StackFrames();
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public enum Microsoft.VisualStudio.IntelliTrace.DiagnosticEventDataQueryType : Enum {
    public int value__;
    public static DiagnosticEventDataQueryType Unknown;
    public static DiagnosticEventDataQueryType DataQuery;
    public static DiagnosticEventDataQueryType ProgrammableDataQuery;
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.DiagnosticEventFilter : object {
    public abstract virtual bool Match(DiagnosticEvent diagnosticEvent);
}
internal class Microsoft.VisualStudio.IntelliTrace.DiagnosticEventRedirectManager : object {
    private List`1<IDiagnosticEventRedirect> _eventRedirect;
    private object _localLock;
    public void RegisterRedirect(IDiagnosticEventRedirect redirect);
    public sealed virtual bool CanRedirect(DiagnosticEvent original);
    public sealed virtual Location Redirect(DiagnosticEvent original);
    private IDiagnosticEventRedirect GetRedirect(DiagnosticEvent evt);
}
internal static class Microsoft.VisualStudio.IntelliTrace.DiagnosticEventTypes : object {
    public static string DataQuery;
    public static string AutomaticDataQueryEntry;
    public static string AutomaticDataQueryReturn;
    public static bool IsAutomaticDataQuery(DiagnosticEvent de);
    public static bool IsAutomaticDataQueryReturn(DiagnosticEvent de);
}
internal class Microsoft.VisualStudio.IntelliTrace.DiagnosticFrameData : object {
    private ResolvedDiagnosticEvent _diagnosticEvent;
    private bool _isLongDescritionInitialized;
    private string _longDescription;
    private bool _isShortDescriptionInitialized;
    private string _shortDescription;
    private bool _isCategoryIdInitialized;
    private string _categoryId;
    private bool _isDiagnosticDataInitialized;
    private IEnumerable`1<IDataElement> _diagnosticData;
    public long DiagnosticEventOrdinal { get; }
    public string LongDescription { get; }
    public string ShortDescription { get; }
    public string CategoryId { get; }
    public IEnumerable`1<IDataElement> DiagnosticData { get; }
    public DiagnosticFrameData(ResolvedDiagnosticEvent de);
    public long get_DiagnosticEventOrdinal();
    public string get_LongDescription();
    public string get_ShortDescription();
    public string get_CategoryId();
    public IEnumerable`1<IDataElement> get_DiagnosticData();
}
public class Microsoft.VisualStudio.IntelliTrace.DiagnosticStreamChain : StreamChain {
    internal MessageMemoryByteArray memory;
    private IndependentEventsMessagePacker packer;
    internal DiagnosticStreamChain(LogStream stream, IndependentEventsMessagePacker packer);
    protected virtual Byte[] ReadEventBytes();
    protected virtual int ReadEventLength();
    protected virtual IntelliTraceEvent ConvertToEvent(EventToken token, Byte[] data, Int32& offset);
    protected virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
}
public class Microsoft.VisualStudio.IntelliTrace.DisplaySettings : ValueType {
    private int width;
    private int height;
    private int bitsPerPixel;
    public int Width { get; public set; }
    public int Height { get; public set; }
    public int BitsPerPixel { get; public set; }
    internal DisplaySettings(_DisplaySettings systemInfoDisplaySettings);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public int get_BitsPerPixel();
    public void set_BitsPerPixel(int value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(DisplaySettings other);
    public static bool op_Equality(DisplaySettings displaySettings1, DisplaySettings displaySettings2);
    public static bool op_Inequality(DisplaySettings displaySettings1, DisplaySettings displaySettings2);
}
internal class Microsoft.VisualStudio.IntelliTrace.DynamicProfilerRegistration : object {
    private ProfilerRegistrationMode _registrationMode;
    private static string RegistrationCountKey;
    private static string RegistrationMutexName;
    private static int RegistrationMutexWaitTimeout;
    private static string CLSIDKeyName;
    private static string ProfilerCLSIDKeyName;
    public ProfilerRegistrationMode RegistrationMode { get; }
    public DynamicProfilerRegistration(ProfilerRegistrationMode mode);
    private static DynamicProfilerRegistration();
    public ProfilerRegistrationMode get_RegistrationMode();
    internal static Mutex TakeRegistryLock();
    public void RegisterProfiler();
    private RegistryHelper CreateRootCLSIDKey(bool is64Bit);
    private static void RegisterProfiler(RegistryHelper rootKey);
    public void UnregisterProfiler();
    private static void UnregisterProfiler(RegistryHelper rootKey);
}
internal class Microsoft.VisualStudio.IntelliTrace.EmptyAccessList`1 : object {
    public int Count { get; }
    public sealed virtual T GetEvent(int eventIndex);
    public sealed virtual IList`1<T> GetEvents(int startIndex, int fetchCount);
    public sealed virtual int get_Count();
}
internal enum Microsoft.VisualStudio.IntelliTrace.EnumOrigin : Enum {
    public int value__;
    public static EnumOrigin Begin;
    public static EnumOrigin End;
}
internal class Microsoft.VisualStudio.IntelliTrace.EventChainException : Exception {
    public EventChainException(string message);
    public EventChainException(string message, Exception innerException);
    protected EventChainException(SerializationInfo info, StreamingContext context);
}
internal static class Microsoft.VisualStudio.IntelliTrace.EventChainFactory : object {
    public static T CreateSingletonChain(IntelliTraceFileBase logFile);
    public static T CreateInstancedChain(IntelliTraceFileBase logFile, int streamIndex);
}
internal class Microsoft.VisualStudio.IntelliTrace.EventChains.BuildInformationEvent : IntelliTraceEvent {
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public string ApplicationName { get; private set; }
    public Byte[] Data { get; private set; }
    public BuildInformationEvent(_ApplicationBuildInfo buildInfo);
    [CompilerGeneratedAttribute]
public string get_ApplicationName();
    [CompilerGeneratedAttribute]
private void set_ApplicationName(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Byte[] value);
}
internal class Microsoft.VisualStudio.IntelliTrace.EventChains.BuildInformationStreamChain : CompatibilityStreamChain {
    private BuildInformationMessagePacker BuildInfoPacker { get; }
    public BuildInformationStreamChain(LogStream stream, BuildInformationMessagePacker packer);
    private BuildInformationMessagePacker get_BuildInfoPacker();
    protected virtual IntelliTraceEvent CreateEvent(EventToken token, short messageId, Byte* message);
    protected virtual bool IsValidMessage(short message);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.EventChains.CompatibilityStreamChain : EventStreamChain {
    public EventToken FirstValidToken { get; }
    public bool IsEmpty { get; }
    public EventToken FirstToken { get; }
    public long Count { get; }
    public EventToken LastToken { get; }
    public bool CanGetPreviousToken { get; }
    public bool CanGetCount { get; }
    public bool CanGetLastToken { get; }
    public EventToken BeforeFirstToken { get; }
    public EventToken AfterLastToken { get; }
    public CompatibilityStreamChain(LogStream logStream, MessagePacker packer);
    protected abstract virtual bool IsValidMessage(short message);
    private EventToken AdvanceToValidToken(EventToken token);
    public sealed virtual EventToken get_FirstValidToken();
    public sealed virtual EventToken GetNextToken(EventToken token);
    public sealed virtual IList`1<IntelliTraceEvent> GetEvents(EventToken startToken, EventToken endToken);
    public sealed virtual IntelliTraceEvent GetEvent(EventToken token);
    internal sealed virtual IEnumerable`1<EventToken> TokensInternal();
    protected sealed virtual IEnumerator`1<TEvent> GetEnumerator();
    public sealed virtual bool IsValidToken(EventToken token);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual EventToken get_FirstToken();
    protected sealed virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    protected sealed virtual Byte[] ReadEventBytes();
    protected sealed virtual int ReadEventLength();
    public sealed virtual long get_Count();
    public sealed virtual EventToken GetPreviousToken(EventToken token);
    public sealed virtual EventToken get_LastToken();
    public sealed virtual bool get_CanGetPreviousToken();
    public sealed virtual bool get_CanGetCount();
    public sealed virtual bool get_CanGetLastToken();
    public sealed virtual EventToken get_BeforeFirstToken();
    public sealed virtual EventToken get_AfterLastToken();
}
internal class Microsoft.VisualStudio.IntelliTrace.EventChains.PerformanceDescriptionWeaver : object {
    public static int LoggerThreadNotFound;
    [CompilerGeneratedAttribute]
private TraceLog <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private WebChainWeaver <WebChainWeaver>k__BackingField;
    public TraceLog Log { get; private set; }
    public WebChainWeaver WebChainWeaver { get; private set; }
    public PerformanceDescriptionWeaver(TraceLog log);
    [CompilerGeneratedAttribute]
public TraceLog get_Log();
    [CompilerGeneratedAttribute]
private void set_Log(TraceLog value);
    [CompilerGeneratedAttribute]
public WebChainWeaver get_WebChainWeaver();
    [CompilerGeneratedAttribute]
private void set_WebChainWeaver(WebChainWeaver value);
    public PerformanceEventDescription ReadDescription(PerformanceDataEvent perfEvent);
    public ThreadStreamChain CreateThreadStreamChainForEvent(PerformanceDataEvent perfEvent);
    public int GetLoggerThreadId(PerformanceDataEvent perfEvent);
    private PerformanceEventDescriptionSegment ReadEventDetails(PerformanceEventDescriptionData descriptionData, DiagnosticStreamChain diagnosticChain, ThreadStreamChain threadChain);
}
internal class Microsoft.VisualStudio.IntelliTrace.EventChains.PerformanceEventDescription : object {
    [CompilerGeneratedAttribute]
private PerformanceDataEvent <PerformanceEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceEventDescriptionSegment <RootEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceEventDescriptionSegment <HeaviestEvents>k__BackingField;
    public PerformanceDataEvent PerformanceEvent { get; private set; }
    public PerformanceEventDescriptionSegment RootEvents { get; public set; }
    public PerformanceEventDescriptionSegment HeaviestEvents { get; public set; }
    public PerformanceEventDescription(PerformanceDataEvent perfEvent);
    [CompilerGeneratedAttribute]
public PerformanceDataEvent get_PerformanceEvent();
    [CompilerGeneratedAttribute]
private void set_PerformanceEvent(PerformanceDataEvent value);
    [CompilerGeneratedAttribute]
public PerformanceEventDescriptionSegment get_RootEvents();
    [CompilerGeneratedAttribute]
public void set_RootEvents(PerformanceEventDescriptionSegment value);
    [CompilerGeneratedAttribute]
public PerformanceEventDescriptionSegment get_HeaviestEvents();
    [CompilerGeneratedAttribute]
public void set_HeaviestEvents(PerformanceEventDescriptionSegment value);
}
internal class Microsoft.VisualStudio.IntelliTrace.EventChains.PerformanceEventDescriptionSegment : object {
    [CompilerGeneratedAttribute]
private DiagnosticEvent <DiagnosticEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodEnterEvent <MethodEnterEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodExitEvent <MethodExitEvent>k__BackingField;
    public DiagnosticEvent DiagnosticEvent { get; public set; }
    public MethodEnterEvent MethodEnterEvent { get; public set; }
    public MethodExitEvent MethodExitEvent { get; public set; }
    [CompilerGeneratedAttribute]
public DiagnosticEvent get_DiagnosticEvent();
    [CompilerGeneratedAttribute]
public void set_DiagnosticEvent(DiagnosticEvent value);
    [CompilerGeneratedAttribute]
public MethodEnterEvent get_MethodEnterEvent();
    [CompilerGeneratedAttribute]
public void set_MethodEnterEvent(MethodEnterEvent value);
    [CompilerGeneratedAttribute]
public MethodExitEvent get_MethodExitEvent();
    [CompilerGeneratedAttribute]
public void set_MethodExitEvent(MethodExitEvent value);
    public static bool AreEqual(PerformanceEventDescriptionSegment lhs, PerformanceEventDescriptionSegment rhs);
    private static bool AreEqual(OrdinalEvent lhs, OrdinalEvent rhs);
}
internal enum Microsoft.VisualStudio.IntelliTrace.EventChainType : Enum {
    public int value__;
    public static EventChainType StreamZero;
    public static EventChainType Unknown;
    public static EventChainType ProcessEvents;
    public static EventChainType CheckPoints;
    public static EventChainType NotifyPoints;
    public static EventChainType TestEvents;
    public static EventChainType PackedMetadata;
}
internal class Microsoft.VisualStudio.IntelliTrace.EventData`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Event>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandle <Handle>k__BackingField;
    internal T Event { get; private set; }
    internal EventHandle Handle { get; private set; }
    internal EventData`1(T ev, EventHandle eh);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal T get_Event();
    [CompilerGeneratedAttribute]
private void set_Event(T value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal EventHandle get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(EventHandle value);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.EventHandle : object {
    internal int ThreadId { get; }
    internal abstract virtual int get_ThreadId();
    internal abstract virtual T ToEvent();
}
internal class Microsoft.VisualStudio.IntelliTrace.EventHandleToEC : EventHandle {
    private int _threadId;
    [CompilerGeneratedAttribute]
private EventToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private Chain <Chain>k__BackingField;
    internal EventToken Token { get; internal set; }
    internal Chain Chain { get; internal set; }
    internal int ThreadId { get; }
    internal EventHandleToEC(int threadId, EventToken token, Chain chain);
    [CompilerGeneratedAttribute]
internal EventToken get_Token();
    [CompilerGeneratedAttribute]
internal void set_Token(EventToken value);
    [CompilerGeneratedAttribute]
internal Chain get_Chain();
    [CompilerGeneratedAttribute]
internal void set_Chain(Chain value);
    internal virtual int get_ThreadId();
    internal virtual T ToEvent();
}
internal class Microsoft.VisualStudio.IntelliTrace.EventHandleToNode : EventHandle {
    [CompilerGeneratedAttribute]
private int <SliceId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeSliceManager <Manager>k__BackingField;
    internal int SliceId { get; private set; }
    internal int NodeId { get; private set; }
    internal TreeSliceManager Manager { get; private set; }
    internal int ThreadId { get; }
    internal EventHandleToNode(int sliceId, int nodeId, TreeSliceManager manager);
    [CompilerGeneratedAttribute]
internal int get_SliceId();
    [CompilerGeneratedAttribute]
private void set_SliceId(int value);
    [CompilerGeneratedAttribute]
internal int get_NodeId();
    [CompilerGeneratedAttribute]
private void set_NodeId(int value);
    [CompilerGeneratedAttribute]
internal TreeSliceManager get_Manager();
    [CompilerGeneratedAttribute]
private void set_Manager(TreeSliceManager value);
    internal virtual int get_ThreadId();
    internal virtual T ToEvent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.VisualStudio.IntelliTrace.EventReference : object {
    [CompilerGeneratedAttribute]
private Chain <EventChain>k__BackingField;
    [CompilerGeneratedAttribute]
private EventToken <EventToken>k__BackingField;
    public Chain EventChain { get; private set; }
    public EventToken EventToken { get; private set; }
    public EventReference(Chain chain, EventToken token);
    [CompilerGeneratedAttribute]
public Chain get_EventChain();
    [CompilerGeneratedAttribute]
private void set_EventChain(Chain value);
    [CompilerGeneratedAttribute]
public EventToken get_EventToken();
    [CompilerGeneratedAttribute]
private void set_EventToken(EventToken value);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.EventStreamChain : StreamChain {
    private MessageMemoryByteArray managedMemory;
    private MessagePackerMessageMemory memory;
    [CompilerGeneratedAttribute]
private MessagePacker <Packer>k__BackingField;
    private static bool SwapBytes;
    protected MessagePacker Packer { get; private set; }
    protected IMessageMemory2 MessageMemory { get; }
    protected EventStreamChain(LogStream logStream, MessagePacker packer);
    [CompilerGeneratedAttribute]
protected MessagePacker get_Packer();
    [CompilerGeneratedAttribute]
private void set_Packer(MessagePacker value);
    protected IMessageMemory2 get_MessageMemory();
    protected virtual Byte[] ReadEventBytes();
    protected short ReadMessageHeader(Int16& id, Int32& length);
    protected virtual int ReadEventLength();
    protected abstract virtual IntelliTraceEvent CreateEvent(EventToken token, short messageId, Byte* message);
    protected virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
    public virtual EventToken AppendEvent(IntelliTraceEvent chainEvent);
    internal virtual EventToken WriteEvent(EventToken token, IntelliTraceEvent chainEvent);
    protected sealed virtual IntelliTraceEvent ConvertToEvent(EventToken token, Byte[] data, Int32& offset);
}
public class Microsoft.VisualStudio.IntelliTrace.EventToken : ValueType {
    private long t;
    public static EventToken Zero;
    internal static EventToken MaxValue;
    public EventToken(long value);
    private static EventToken();
    public static EventToken op_Explicit(long value);
    public static long op_Explicit(EventToken token);
    public static bool op_Equality(EventToken left, EventToken right);
    public static bool op_Inequality(EventToken left, EventToken right);
    public static bool op_LessThan(EventToken left, EventToken right);
    public static bool op_GreaterThan(EventToken left, EventToken right);
    public static bool op_LessThanOrEqual(EventToken left, EventToken right);
    public static bool op_GreaterThanOrEqual(EventToken left, EventToken right);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.EventTracker : object {
    internal virtual void LogTruncated();
    internal virtual void HandleEvent(CollectionPlanEvent collectionPlan, EventHandle handle);
    internal virtual void HandleEvent(SystemInformationEvent systemInfo, EventHandle handle);
    internal virtual void HandleEvent(ProcessInformationEvent processInfo, EventHandle handle);
    internal virtual void HandleEvent(WorkerProcessInformationEvent workerProcessInfo, EventHandle handle);
    internal virtual void HandleEvent(ProcessDestroyedEvent processDestroy, EventHandle handle);
    internal virtual void HandleEvent(ThreadCreateEvent threadCreate, EventHandle handle);
    internal virtual void HandleEvent(ThreadDestroyEvent threadDestroy, EventHandle handle);
    internal virtual void HandleEvent(ThreadNameChangedEvent threadNameChanged, EventHandle handle);
    internal virtual void HandleEvent(DataRequestedEvent dataRequested, EventHandle handle);
    internal virtual void HandleEvent(ModuleLoadEvent moduleLoad, EventHandle handle);
    internal virtual void HandleEvent(ModuleUnloadEvent moduleUnload, EventHandle handle);
    internal virtual void HandleEvent(IntelliTraceTokenEvent moduleToken, EventHandle handle);
    internal virtual void HandleEvent(TypeSpecMetadataEvent typeSpecMetadata, EventHandle handle);
    internal virtual void HandleEvent(ModuleIsUserCodeEvent moduleIsUserCode, EventHandle handle);
    internal virtual void HandleEvent(DiagnosticEvent notifyPoint, EventHandle handle);
    internal virtual void HandleEvent(ThreadCheckpointEvent checkpoint, EventHandle handle);
    internal virtual void HandleEvent(DebuggerInteractionEvent uiRecorded, EventHandle handle);
    internal virtual void HandleEvent(MethodEnterEvent methodEnter, EventHandle handle);
    internal virtual void HandleEvent(MethodExitEvent methodExit, EventHandle handle);
    internal virtual void HandleEvent(CallSiteEvent callsite, EventHandle handle);
    internal virtual void HandleEvent(TailCallSiteEvent callsite, EventHandle handle);
    internal virtual void HandleEvent(ExceptionThrownEvent exceptionThrown, EventHandle handle);
    internal virtual void HandleEvent(ExceptionSearchFunctionEnterEvent searchFunctionEnter, EventHandle handle);
    internal virtual void HandleEvent(ExceptionSearchFunctionExitEvent searchFunctionExit, EventHandle handle);
    internal virtual void HandleEvent(ExceptionSearchFilterEnterEvent searchFilterEnter, EventHandle handle);
    internal virtual void HandleEvent(ExceptionSearchFilterExitEvent searchFilterExit, EventHandle handle);
    internal virtual void HandleEvent(ExceptionSearchCatchFoundEvent searchCatcherFound, EventHandle handle);
    internal virtual void HandleEvent(ExceptionUnwindFunctionEnterEvent unwindFunctionEnter, EventHandle handle);
    internal virtual void HandleEvent(ExceptionUnwindFunctionExitEvent unwindFunctionExit, EventHandle handle);
    internal virtual void HandleEvent(ExceptionUnwindFinallyEnterEvent unwindFinallyEnter, EventHandle handle);
    internal virtual void HandleEvent(ExceptionUnwindFinallyExitEvent unwindFinallyExit, EventHandle handle);
    internal virtual void HandleEvent(ExceptionCatchEnterEvent catcherEnter, EventHandle handle);
    internal virtual void HandleEvent(ExceptionCatchExitEvent catcherExit, EventHandle handle);
    internal virtual void HandleEvent(WebEvent webEvent, EventHandle handle);
    internal virtual void HandleEvent(SharePointAreaEvent areaEvent, EventHandle handle);
    internal virtual void HandleEvent(SharePointCategoryEvent categoryEvent, EventHandle handle);
}
internal enum Microsoft.VisualStudio.IntelliTrace.EventType : Enum {
    public int value__;
    public static EventType Break_StopEventAsyncBreak;
    public static EventType Break_StopEventBreakpoint;
    public static EventType Break_StopEventException;
    public static EventType Break_StopEventStepComplete;
    public static EventType Break_StopEventExceptionIntercepted;
    public static EventType Break_StopEventEntrypoint;
    public static EventType Output_FirstChanceException;
    public static EventType Output_ProgramOutput;
    public static EventType Output_ProcessExit;
    public static EventType Output_ThreadExit;
    public static EventType Output_ModuleLoad;
    public static EventType Output_ModuleUnload;
    public static EventType Output_StepFiltering;
    public static EventType Output_Unknown;
    public static EventType IntelliTrace_ExceptionThrown;
    public static EventType IntelliTrace_ExceptionCaught;
    public static EventType IntelliTrace_ADONET;
    public static EventType IntelliTrace_ASPNET;
    public static EventType IntelliTrace_HTTPClient;
    public static EventType IntelliTrace_Console;
    public static EventType IntelliTrace_File;
    public static EventType IntelliTrace_EnvironmentVariables;
    public static EventType IntelliTrace_Registry;
    public static EventType IntelliTrace_Xml;
    public static EventType IntelliTrace_Gesture;
    public static EventType IntelliTrace_UserPrompt;
    public static EventType IntelliTrace_DataBinding;
    public static EventType IntelliTrace_LazyInitialization;
    public static EventType IntelliTrace_ServiceModel;
    public static EventType IntelliTrace_Threading;
    public static EventType IntelliTrace_Workflow;
    public static EventType IntelliTrace_Custom;
    public static EventType IntelliTrace_Tracing;
    public static EventType IntelliTrace_Performance;
    public static EventType IntelliTrace_SharepointULS;
    public static EventType IntelliTrace_SharepointUserProfile;
    public static EventType IntelliTrace_TracepointHit;
}
internal static class Microsoft.VisualStudio.IntelliTrace.EventTypeHelper : object {
    public static string DiagnosticHubOutputCategory;
    private static Dictionary`2<string, EventType> _categoryToEventType;
    private static Dictionary`2<long, EventType> _eventIdToEventType;
    private static Dictionary`2<EventType, string> _eventTypeToName;
    private static string EventName_DiagnosticsDebugger;
    private static string EventName_DiagnosticsException;
    private static string EventName_SystemData;
    private static string EventName_SystemWeb;
    private static string EventName_SystemNetHttp;
    private static string EventName_Console;
    private static string EventName_DataBinding;
    private static string EventName_EnvironmentVariables;
    private static string EventName_FileAccess;
    private static string EventName_Gesture;
    private static string EventName_Lazy;
    private static string EventName_RegistryAccess;
    private static string EventName_ServiceModel;
    private static string EventName_Threading;
    private static string EventName_UserPrompt;
    private static string EventName_Workflow;
    private static string EventName_Xml;
    private static string EventName_Tracing;
    private static string EventName_Performance;
    private static string EventName_Custom;
    private static string EventName_SharePointULS;
    private static string EventName_SharePointUserProfile;
    private static string EventName_AsynBreak;
    private static string EventName_Breakpoint;
    private static string EventName_StopEventEntryPoint;
    private static string EventName_BreakException;
    private static string EventName_StopEventStepComplete;
    private static string EventName_ExceptionIntercepted;
    private static string EventName_FirstChangeException;
    private static string EventName_TracePointHit;
    private static string EventName_ProgramOutput;
    private static string EventName_ProcessExit;
    private static string EventName_ThreadExit;
    private static string EventName_ModuleLoad;
    private static string EventName_ModuleUnload;
    private static string EventName_StepFiltering;
    private static string EventName_OutputUnknown;
    private static IEnumerable`1<EventType> BreakEventTypes;
    private static IEnumerable`1<int> _breakEventNotifyIds;
    private static IEnumerable`1<EventType> OutputEventTypes;
    public static IEnumerable`1<int> BreakEventNotifyIds { get; }
    private static EventTypeHelper();
    public static IEnumerable`1<int> get_BreakEventNotifyIds();
    public static EventType GetEventType(string category, long diagnosticEventId);
    public static string GetTypeName(EventType type);
    public static bool IsBreakEvent(EventType type);
    public static bool IsBreakEvent(int notifyId);
    public static bool IsOutputEvent(EventType type);
    public static bool IsIntelliTraceEvent(EventType type);
    public static bool IsExceptionThrownEvent(EventType type);
}
internal class Microsoft.VisualStudio.IntelliTrace.EventWalker : object {
    private DerivedChain _chain;
    private EventToken _token;
    private int _loggerTid;
    private List`1<EventTracker> _trackers;
    internal EventWalker(DerivedChain chain, int loggerTid);
    internal void Seek(long ordinal);
    internal void Refresh();
    internal void Refresh(long ordinal);
    internal void AddTracker(EventTracker tracker);
    internal void RemoveTracker(EventTracker tracker);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionCatchEnterEvent : ExceptionEvent {
    internal ExceptionCatchEnterEvent(ExceptionEvent* pExceptionEvent);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionCatchExitEvent : ExceptionEvent {
    internal ExceptionCatchExitEvent(ExceptionEvent* pExceptionEvent);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.ExceptionData : LogData {
    protected List`1<LogData> _fieldValues;
    internal ExceptionData(DataUnavailableReason reason);
    internal ExceptionData(DataContext context, BlobUnpacker unpacker);
    internal List`1<LogData> GetFields(List`1<Symbol> fieldSymbols);
}
internal enum Microsoft.VisualStudio.IntelliTrace.ExceptionDisposition : Enum {
    public int value__;
    public static ExceptionDisposition Normal;
    public static ExceptionDisposition NestedInFilter;
    public static ExceptionDisposition NestedInFinally;
    public static ExceptionDisposition NestedInCatch;
}
public abstract class Microsoft.VisualStudio.IntelliTrace.ExceptionEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private int <MethodToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ILOffset>k__BackingField;
    public int MethodToken { get; private set; }
    internal int ILOffset { get; private set; }
    internal ExceptionEvent(ExceptionEvent* pExceptionEvent);
    [CompilerGeneratedAttribute]
public int get_MethodToken();
    [CompilerGeneratedAttribute]
private void set_MethodToken(int value);
    [CompilerGeneratedAttribute]
internal int get_ILOffset();
    [CompilerGeneratedAttribute]
private void set_ILOffset(int value);
    internal static IntelliTraceEvent Create(ExceptionEvent* pExceptionEvent);
}
internal enum Microsoft.VisualStudio.IntelliTrace.ExceptionEventType : Enum {
    public int value__;
    public static ExceptionEventType ExceptionSearchFunctionEnter;
    public static ExceptionEventType ExceptionSearchFunctionLeave;
    public static ExceptionEventType ExceptionSearchFilterEnter;
    public static ExceptionEventType ExceptionSearchFilterLeave;
    public static ExceptionEventType ExceptionSearchCatcherFound;
    public static ExceptionEventType ExceptionUnwindFunctionEnter;
    public static ExceptionEventType ExceptionUnwindFunctionLeave;
    public static ExceptionEventType ExceptionUnwindFinallyEnter;
    public static ExceptionEventType ExceptionUnwindFinallyLeave;
    public static ExceptionEventType ExceptionCatcherEnter;
    public static ExceptionEventType ExceptionCatcherLeave;
}
internal class Microsoft.VisualStudio.IntelliTrace.ExceptionHandlingState : CheckpointedState {
    private EHState _innerState;
    [CompilerGeneratedAttribute]
private ExceptionDisposition <ExceptionDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExceptionDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GuardDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SearchedDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnwoundDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeState <PrevState>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandle <ThrowEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandle <CatchEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticEvent <CatchFound>k__BackingField;
    internal ExceptionDisposition ExceptionDisposition { get; private set; }
    internal int ExceptionDepth { get; private set; }
    internal int GuardDepth { get; private set; }
    internal int SearchedDepth { get; private set; }
    internal int UnwoundDepth { get; private set; }
    internal bool IsInSearchPhase { get; }
    internal bool IsRunningCatcher { get; }
    internal bool IsRunningFinally { get; }
    private TreeState PrevState { get; private set; }
    internal EventHandle ThrowEvent { get; internal set; }
    internal EventHandle CatchEvent { get; internal set; }
    private DiagnosticEvent CatchFound { get; private set; }
    internal Tree Tree { get; }
    internal ExceptionHandlingState(ExceptionInFlight data, Tree tree, TreeState prevState);
    internal ExceptionHandlingState(ExceptionDisposition disposition, int guardDepth, Tree tree, ExceptionThrownEvent eventData, TreeState prevState, Tree tempTree);
    [CompilerGeneratedAttribute]
internal ExceptionDisposition get_ExceptionDisposition();
    [CompilerGeneratedAttribute]
private void set_ExceptionDisposition(ExceptionDisposition value);
    [CompilerGeneratedAttribute]
internal int get_ExceptionDepth();
    [CompilerGeneratedAttribute]
private void set_ExceptionDepth(int value);
    [CompilerGeneratedAttribute]
internal int get_GuardDepth();
    [CompilerGeneratedAttribute]
private void set_GuardDepth(int value);
    [CompilerGeneratedAttribute]
internal int get_SearchedDepth();
    [CompilerGeneratedAttribute]
private void set_SearchedDepth(int value);
    [CompilerGeneratedAttribute]
internal int get_UnwoundDepth();
    [CompilerGeneratedAttribute]
private void set_UnwoundDepth(int value);
    internal void DecrementSearchedDepth();
    internal void DecrementUnwoundDepth();
    internal bool get_IsInSearchPhase();
    internal bool get_IsRunningCatcher();
    internal bool get_IsRunningFinally();
    [CompilerGeneratedAttribute]
private TreeState get_PrevState();
    [CompilerGeneratedAttribute]
private void set_PrevState(TreeState value);
    [CompilerGeneratedAttribute]
internal EventHandle get_ThrowEvent();
    [CompilerGeneratedAttribute]
internal void set_ThrowEvent(EventHandle value);
    [CompilerGeneratedAttribute]
internal EventHandle get_CatchEvent();
    [CompilerGeneratedAttribute]
internal void set_CatchEvent(EventHandle value);
    [CompilerGeneratedAttribute]
private DiagnosticEvent get_CatchFound();
    [CompilerGeneratedAttribute]
private void set_CatchFound(DiagnosticEvent value);
    internal Tree get_Tree();
    internal virtual TreeState OnThrowNP(DiagnosticEvent eventData);
    internal virtual TreeState OnCatchNP(DiagnosticEvent eventData);
    internal virtual TreeState OnExceptionInterceptedNP(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnExceptionStopNP(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnExceptionThrown(ExceptionThrownEvent eventData);
    internal virtual TreeState OnExceptionSearchFunctionEnter(ExceptionSearchFunctionEnterEvent eventData);
    internal virtual TreeState OnExceptionSearchFunctionExit(ExceptionSearchFunctionExitEvent eventData);
    internal virtual TreeState OnExceptionSearchFilterEnter(ExceptionSearchFilterEnterEvent eventData);
    internal virtual TreeState OnExceptionSearchFilterExit(ExceptionSearchFilterExitEvent eventData);
    internal virtual TreeState OnExceptionSearchCatcherFound(ExceptionSearchCatchFoundEvent eventData);
    internal virtual TreeState OnExceptionUnwindFunctionEnter(ExceptionUnwindFunctionEnterEvent eventData);
    internal virtual TreeState OnExceptionUnwindFunctionExit(ExceptionUnwindFunctionExitEvent eventData);
    internal virtual TreeState OnExceptionUnwindFinallyEnter(ExceptionUnwindFinallyEnterEvent eventData);
    internal virtual TreeState OnExceptionUnwindFinallyExit(ExceptionUnwindFinallyExitEvent eventData);
    internal virtual TreeState OnExceptionCatcherEnter(ExceptionCatchEnterEvent eventData);
    internal virtual TreeState OnExceptionCatcherExit(ExceptionCatchExitEvent eventData);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionIndexEvent : IntelliTraceEvent {
    [CompilerGeneratedAttribute]
private long <StreamOffset>k__BackingField;
    internal long StreamOffset { get; private set; }
    public EventToken ExceptionEventToken { get; }
    internal ExceptionIndexEvent(EventToken token, ExceptionMarker* pData);
    internal ExceptionIndexEvent(int streamIndex, long streamOffset);
    [CompilerGeneratedAttribute]
internal long get_StreamOffset();
    [CompilerGeneratedAttribute]
private void set_StreamOffset(long value);
    public EventToken get_ExceptionEventToken();
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionIndexStreamChain : StreamChain {
    internal MessageMemoryByteArray memory;
    private ExceptionIndexMessagePacker packer;
    internal ExceptionIndexStreamChain(LogStream stream, ExceptionIndexMessagePacker packer);
    protected virtual Byte[] ReadEventBytes();
    protected virtual int ReadEventLength();
    protected virtual IntelliTraceEvent ConvertToEvent(EventToken token, Byte[] data, Int32& offset);
    protected virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
}
internal class Microsoft.VisualStudio.IntelliTrace.ExceptionInFlight : object {
    [CompilerGeneratedAttribute]
private ExceptionHandlingState <InnerState>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionDisposition <Disposition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExceptionDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GuardDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SearchedDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnwoundDepth>k__BackingField;
    public ExceptionHandlingState InnerState { get; private set; }
    public ExceptionDisposition Disposition { get; private set; }
    public int ExceptionDepth { get; private set; }
    public int GuardDepth { get; private set; }
    public int SearchedDepth { get; private set; }
    public int UnwoundDepth { get; private set; }
    internal ExceptionInFlight(ExceptionData* pData);
    [CompilerGeneratedAttribute]
public ExceptionHandlingState get_InnerState();
    [CompilerGeneratedAttribute]
private void set_InnerState(ExceptionHandlingState value);
    [CompilerGeneratedAttribute]
public ExceptionDisposition get_Disposition();
    [CompilerGeneratedAttribute]
private void set_Disposition(ExceptionDisposition value);
    [CompilerGeneratedAttribute]
public int get_ExceptionDepth();
    [CompilerGeneratedAttribute]
private void set_ExceptionDepth(int value);
    [CompilerGeneratedAttribute]
public int get_GuardDepth();
    [CompilerGeneratedAttribute]
private void set_GuardDepth(int value);
    [CompilerGeneratedAttribute]
public int get_SearchedDepth();
    [CompilerGeneratedAttribute]
private void set_SearchedDepth(int value);
    [CompilerGeneratedAttribute]
public int get_UnwoundDepth();
    [CompilerGeneratedAttribute]
private void set_UnwoundDepth(int value);
    internal _ExceptionData AsPackable();
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.ExceptionNode : NotifyNode {
    protected IList`1<byte> _dataBytes;
    [CompilerGeneratedAttribute]
private long <DiagnosticEventOrdinal>k__BackingField;
    public long DiagnosticEventOrdinal { get; public set; }
    public IList`1<byte> Blob { get; }
    internal IList`1<byte> DataBytes { get; internal set; }
    protected ExceptionNode(long ordinal, CodeContext location);
    [CompilerGeneratedAttribute]
public long get_DiagnosticEventOrdinal();
    [CompilerGeneratedAttribute]
public void set_DiagnosticEventOrdinal(long value);
    public virtual IList`1<byte> get_Blob();
    internal IList`1<byte> get_DataBytes();
    internal void set_DataBytes(IList`1<byte> value);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionSearchCatchFoundEvent : ExceptionEvent {
    internal ExceptionSearchCatchFoundEvent(ExceptionEvent* pExceptionEvent);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionSearchFilterEnterEvent : ExceptionEvent {
    internal ExceptionSearchFilterEnterEvent(ExceptionEvent* pExceptionEvent);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionSearchFilterExitEvent : ExceptionEvent {
    internal ExceptionSearchFilterExitEvent(ExceptionEvent* pExceptionEvent);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionSearchFunctionEnterEvent : ExceptionEvent {
    internal ExceptionSearchFunctionEnterEvent(ExceptionEvent* pExceptionEvent);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionSearchFunctionExitEvent : ExceptionEvent {
    internal ExceptionSearchFunctionExitEvent(ExceptionEvent* pExceptionEvent);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionThrownEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private IList`1<IntelliTraceStackFrame> <FramesWithCommonRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<byte> <DataBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    private IList`1<IntelliTraceStackFrame> stack;
    internal IList`1<IntelliTraceStackFrame> FramesWithCommonRoot { get; private set; }
    public IList`1<byte> DataBytes { get; private set; }
    internal int Token { get; private set; }
    public IList`1<IntelliTraceStackFrame> StackFrames { get; }
    internal ExceptionThrownEvent(ExceptionData* pData);
    [CompilerGeneratedAttribute]
internal IList`1<IntelliTraceStackFrame> get_FramesWithCommonRoot();
    [CompilerGeneratedAttribute]
private void set_FramesWithCommonRoot(IList`1<IntelliTraceStackFrame> value);
    [CompilerGeneratedAttribute]
public IList`1<byte> get_DataBytes();
    [CompilerGeneratedAttribute]
private void set_DataBytes(IList`1<byte> value);
    [CompilerGeneratedAttribute]
internal int get_Token();
    [CompilerGeneratedAttribute]
private void set_Token(int value);
    public IList`1<IntelliTraceStackFrame> get_StackFrames();
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.ExceptionTracker : object {
    private ExceptionIndexStreamChain _exceptionIndexChain;
    private DiagnosticCheckpointStreamChain _deCheckpointChain;
    private DiagnosticStreamChain _deChain;
    internal ExceptionTracker(ExceptionIndexStreamChain exceptionIndexChain, DiagnosticCheckpointStreamChain deCheckpointChain, DiagnosticStreamChain deChain);
    internal IEnum`1<EventHandle> GetExceptions();
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionUnwindFinallyEnterEvent : ExceptionEvent {
    internal ExceptionUnwindFinallyEnterEvent(ExceptionEvent* pExceptionEvent);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionUnwindFinallyExitEvent : ExceptionEvent {
    internal ExceptionUnwindFinallyExitEvent(ExceptionEvent* pExceptionEvent);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionUnwindFunctionEnterEvent : ExceptionEvent {
    internal ExceptionUnwindFunctionEnterEvent(ExceptionEvent* pExceptionEvent);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ExceptionUnwindFunctionExitEvent : ExceptionEvent {
    internal ExceptionUnwindFunctionExitEvent(ExceptionEvent* pExceptionEvent);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.VisualStudio.IntelliTrace.ExpectedProcessCollection : object {
    private List`1<ExpectedProcessCollectionEntry> list;
    private TraceLoggingService service;
    private ReaderWriterLockSlim rwLock;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ExpectedProcessCollectionEntry Item { get; public set; }
    internal ExpectedProcessCollection(TraceLoggingService service);
    public sealed virtual void Add(ExpectedProcessCollectionEntry item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(ExpectedProcessCollectionEntry item);
    public sealed virtual void CopyTo(ExpectedProcessCollectionEntry[] array, int arrayIndex);
    public sealed virtual bool Remove(ExpectedProcessCollectionEntry item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(ExpectedProcessCollectionEntry item);
    public sealed virtual void Insert(int index, ExpectedProcessCollectionEntry item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual ExpectedProcessCollectionEntry get_Item(int index);
    public sealed virtual void set_Item(int index, ExpectedProcessCollectionEntry value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<ExpectedProcessCollectionEntry> GetEnumerator();
    internal ExpectedProcessCollectionEntry Find(Predicate`1<ExpectedProcessCollectionEntry> predicate);
}
public class Microsoft.VisualStudio.IntelliTrace.ExpectedProcessCollectionEntry : object {
    [CompilerGeneratedAttribute]
private ExpectedProcessTraits <ExpectedProcessTraits>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionPlanXml>k__BackingField;
    public ExpectedProcessTraits ExpectedProcessTraits { get; private set; }
    public string CollectionPlanXml { get; private set; }
    public ExpectedProcessCollectionEntry(ExpectedProcessTraits expectedProcessTraits, string collectionPlanXml);
    [CompilerGeneratedAttribute]
public ExpectedProcessTraits get_ExpectedProcessTraits();
    [CompilerGeneratedAttribute]
private void set_ExpectedProcessTraits(ExpectedProcessTraits value);
    [CompilerGeneratedAttribute]
public string get_CollectionPlanXml();
    [CompilerGeneratedAttribute]
private void set_CollectionPlanXml(string value);
    public sealed virtual bool Equals(ExpectedProcessCollectionEntry other);
}
public class Microsoft.VisualStudio.IntelliTrace.ExpectedProcessTraits : object {
    private String[] variables;
    private String[] arguments;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StartedAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StartedBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Pid>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ParentPid>k__BackingField;
    public string FullName { get; private set; }
    public ReadOnlyCollection`1<string> Arguments { get; }
    public string Owner { get; private set; }
    public ReadOnlyCollection`1<string> Variables { get; }
    public Nullable`1<DateTime> StartedAfter { get; private set; }
    public Nullable`1<DateTime> StartedBefore { get; private set; }
    public Nullable`1<int> Pid { get; private set; }
    public Nullable`1<int> ParentPid { get; private set; }
    public ExpectedProcessTraits(string fullName, String[] arguments, String[] variables, string owner, Nullable`1<DateTime> startedAfter, Nullable`1<DateTime> startedBefore, Nullable`1<int> pid, Nullable`1<int> parentPid);
    public ExpectedProcessTraits(string fullName);
    public ExpectedProcessTraits(string fullName, String[] arguments);
    public ExpectedProcessTraits(string fullName, String[] arguments, String[] variables);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
private void set_FullName(string value);
    public ReadOnlyCollection`1<string> get_Arguments();
    [CompilerGeneratedAttribute]
public string get_Owner();
    [CompilerGeneratedAttribute]
private void set_Owner(string value);
    public ReadOnlyCollection`1<string> get_Variables();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_StartedAfter();
    [CompilerGeneratedAttribute]
private void set_StartedAfter(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_StartedBefore();
    [CompilerGeneratedAttribute]
private void set_StartedBefore(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Pid();
    [CompilerGeneratedAttribute]
private void set_Pid(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ParentPid();
    [CompilerGeneratedAttribute]
private void set_ParentPid(Nullable`1<int> value);
    public sealed virtual bool Equals(ExpectedProcessTraits other);
    public bool Match(ProcessTraits processTraits);
    private bool WildcardMatch(string content, string expression);
}
internal class Microsoft.VisualStudio.IntelliTrace.Expr`2 : MulticastDelegate {
    public Expr`2(object object, IntPtr method);
    public virtual R Invoke(T e);
    public virtual IAsyncResult BeginInvoke(T e, AsyncCallback callback, object object);
    public virtual R EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.IntelliTrace.Expr`3 : MulticastDelegate {
    public Expr`3(object object, IntPtr method);
    public virtual R Invoke(T e, T1 e1);
    public virtual IAsyncResult BeginInvoke(T e, T1 e1, AsyncCallback callback, object object);
    public virtual R EndInvoke(IAsyncResult result);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.ExprNode : object {
    internal abstract virtual Expr`2<T, bool> CompileBoolExpr();
    internal abstract virtual Expr`2<T, int> CompileIntExpr();
    internal abstract virtual Expr`2<T, long> CompileLongExpr();
    internal abstract virtual Expr`2<T, string> CompileStringExpr();
}
internal enum Microsoft.VisualStudio.IntelliTrace.ExprNodeOperators : Enum {
    public int value__;
    public static ExprNodeOperators And;
    public static ExprNodeOperators Or;
    public static ExprNodeOperators Nor;
    public static ExprNodeOperators Int_Eq;
    public static ExprNodeOperators Int_Ne;
    public static ExprNodeOperators Int_Lt;
    public static ExprNodeOperators Int_Le;
    public static ExprNodeOperators Int_Gt;
    public static ExprNodeOperators Int_Ge;
    public static ExprNodeOperators Long_Eq;
    public static ExprNodeOperators Long_Ne;
    public static ExprNodeOperators Long_Lt;
    public static ExprNodeOperators Long_Le;
    public static ExprNodeOperators Long_Gt;
    public static ExprNodeOperators Long_Ge;
    public static ExprNodeOperators Str_Eq;
    public static ExprNodeOperators Str_Ne;
}
internal class Microsoft.VisualStudio.IntelliTrace.ExtendedVersionInfo : object {
    public static short NestedValuesVersion;
    public static short DurationDataVersion;
    private static ExtendedVersionInfo _expectedVersionInfo;
    private static ExtendedVersionInfo _defaultCollectionVersionInfo;
    private static ExtendedVersionInfo _aviCodeCollectionVersionInfo;
    [CompilerGeneratedAttribute]
private SectionInfo[] <SectionVersions>k__BackingField;
    private SectionInfo[] SectionVersions { get; private set; }
    public IList`1<SectionInfo> SupportedSections { get; }
    public static ExtendedVersionInfo AvicodeCollectionVersions { get; }
    public static ExtendedVersionInfo DefaultCollectionVersions { get; }
    public static ExtendedVersionInfo SupportedVersions { get; }
    public bool SupportsNestedValues { get; }
    public bool SupportsDurationData { get; }
    private static ExtendedVersionInfo();
    internal ExtendedVersionInfo(SectionInfo[] versions);
    public ExtendedVersionInfo(_ExtendedParameterVersionInfo extendedInfo);
    [CompilerGeneratedAttribute]
private SectionInfo[] get_SectionVersions();
    [CompilerGeneratedAttribute]
private void set_SectionVersions(SectionInfo[] value);
    public IList`1<SectionInfo> get_SupportedSections();
    public static ExtendedVersionInfo get_AvicodeCollectionVersions();
    public static ExtendedVersionInfo get_DefaultCollectionVersions();
    public static ExtendedVersionInfo get_SupportedVersions();
    public _ExtendedParameterVersionInfo ConvertToMessage();
    public bool get_SupportsNestedValues();
    public bool get_SupportsDurationData();
    public static ExtendedVersionInfo GetAvicodeCollectionVersions(bool isTimingDataAvailable);
    private bool CanReadSection(SectionId sectionId);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.Extensions : object {
    [ExtensionAttribute]
public static byte CopyToByte(BitArray bitArray);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> constructor);
    [ExtensionAttribute]
public static void RemoveAll(LinkedList`1<T> linkedList, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static IEnumerable`1<T> FindAndRemoveAll(LinkedList`1<T> linkedList, Func`2<T, bool> condition);
}
internal class Microsoft.VisualStudio.IntelliTrace.FakeCallsiteNode : CallsiteNode {
    internal FakeCallsiteNode(long ordinal, CodeContext location);
}
internal class Microsoft.VisualStudio.IntelliTrace.FakeEnterNode : MethodEnterNode {
    private EventHandle _realParent;
    public IList`1<byte> Blob { get; }
    internal FakeEnterNode(long ordinal, CodeContext location);
    public virtual IList`1<byte> get_Blob();
}
internal class Microsoft.VisualStudio.IntelliTrace.FakeExitNode : MethodExitNode {
    public IList`1<byte> Blob { get; }
    internal FakeExitNode(long ordinal, CodeContext location);
    public virtual IList`1<byte> get_Blob();
}
internal class Microsoft.VisualStudio.IntelliTrace.FakeMethodEnterData : MethodEnterData {
    internal FakeMethodEnterData(DataContext context, DataUnavailableReason reason);
    internal FakeMethodEnterData(DataContext context, BlobUnpacker unpacker);
    internal virtual List`1<LogData> GetParameters(Symbol retSymbol, Symbol thisSymbol, List`1<Symbol> paramSymbols);
}
internal class Microsoft.VisualStudio.IntelliTrace.FakeMethodExitData : MethodData {
    internal FakeMethodExitData(DataContext context, DataUnavailableReason reason);
    internal FakeMethodExitData(DataContext context, BlobUnpacker unpacker);
    internal virtual List`1<LogData> GetParameters(Symbol retSymbol, Symbol thisSymbol, List`1<Symbol> paramSymbols);
}
internal class Microsoft.VisualStudio.IntelliTrace.FalseNode : ExprNode {
    internal virtual Expr`2<T, bool> CompileBoolExpr();
    internal virtual Expr`2<T, int> CompileIntExpr();
    internal virtual Expr`2<T, long> CompileLongExpr();
    internal virtual Expr`2<T, string> CompileStringExpr();
}
internal class Microsoft.VisualStudio.IntelliTrace.FieldNode : ExprNode {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal string Name { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    internal virtual Expr`2<T, bool> CompileBoolExpr();
    internal virtual Expr`2<T, int> CompileIntExpr();
    internal virtual Expr`2<T, long> CompileLongExpr();
    internal virtual Expr`2<T, string> CompileStringExpr();
    internal Expr`2<T, R> CompileGeneralExpr();
    [CompilerGeneratedAttribute]
private R <CompileGeneralExpr>b__8_0(T input);
}
internal class Microsoft.VisualStudio.IntelliTrace.Filter`1 : MulticastDelegate {
    public Filter`1(object object, IntPtr method);
    public virtual IEnumerable`1<T> Invoke(IEnumerable`1<T> input);
    public virtual IAsyncResult BeginInvoke(IEnumerable`1<T> input, AsyncCallback callback, object object);
    public virtual IEnumerable`1<T> EndInvoke(IAsyncResult result);
}
public abstract class Microsoft.VisualStudio.IntelliTrace.FilteredListChain : DerivedChain {
    private ListChain sourceChain;
    private List`1<EventToken> tokens;
    private EventToken firstValidSourceToken;
    private EventToken nextSourceTokenToRead;
    private int numInvalidTokens;
    public EventToken FirstToken { get; }
    public EventToken FirstValidToken { get; }
    public EventToken LastToken { get; }
    public EventToken AfterLastToken { get; }
    public long Count { get; }
    public bool IsEmpty { get; }
    public bool CanGetPreviousToken { get; }
    public bool CanGetLastToken { get; }
    public bool CanGetCount { get; }
    protected FilteredListChain(ListChain sourceChain);
    public virtual EventToken get_FirstToken();
    public virtual EventToken get_FirstValidToken();
    public virtual EventToken get_LastToken();
    public virtual EventToken get_AfterLastToken();
    public virtual IntelliTraceEvent GetEvent(EventToken token);
    public virtual IList`1<IntelliTraceEvent> GetEvents(EventToken startToken, EventToken endToken);
    public virtual EventToken GetNextToken(EventToken token);
    public virtual EventToken GetPreviousToken(EventToken token);
    public virtual long get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool get_CanGetPreviousToken();
    public virtual bool get_CanGetLastToken();
    public virtual bool get_CanGetCount();
    public virtual bool IsValidToken(EventToken token);
    public virtual void Refresh();
    protected virtual void Dispose(bool disposing);
}
public abstract class Microsoft.VisualStudio.IntelliTrace.FilteredStreamChain : StreamChain {
    private Int16[] excludedMessageIds;
    public EventToken FirstToken { get; }
    public EventToken FirstValidToken { get; }
    internal FilteredStreamChain(LogStream stream, Int16[] excludedMessageIds);
    public virtual EventToken get_FirstToken();
    public virtual EventToken get_FirstValidToken();
    public virtual IntelliTraceEvent GetEvent(EventToken token);
    internal virtual bool CanGetEvent(EventToken token);
    public virtual IList`1<IntelliTraceEvent> GetEvents(EventToken startToken, EventToken endToken);
    public virtual EventToken GetNextToken(EventToken token);
    protected abstract virtual short ReadEventId(EventToken token);
    protected EventToken SkipToNextUnfilteredEvent(EventToken token);
    protected bool FilteredEvent(EventToken token);
}
internal class Microsoft.VisualStudio.IntelliTrace.FilterIndex`1 : object {
    private EventToken[] _cache;
    public FilterIndex`1(ChainFilter`1<T> source);
    public IList`1<EventToken> GetCache();
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.FilterNode : object {
    internal abstract virtual Filter`1<T> CompileFilter(QueryArguments`2<T, R> arguments);
    internal abstract virtual Predicate`1<T> CompilePredicate(QueryArguments`2<T, R> arguments);
}
internal static class Microsoft.VisualStudio.IntelliTrace.FormatterHelper : object {
    public static void GetMethodAttributeForCSharp(MethodType method, String& methodAttr, Boolean& isPostfix);
    public static void GetMethodAttributeForVB(MethodType method, String& methodAttr, Boolean& isPostfix);
    public static string GetMethodNameWithPrefixOrPostfix(string methodName, string methodPrefixPostfix, bool isPostfix);
}
internal enum Microsoft.VisualStudio.IntelliTrace.FormatterKeyword : Enum {
    public int value__;
    public static FormatterKeyword Null;
    public static FormatterKeyword Uncollected;
    public static FormatterKeyword This;
    public static FormatterKeyword Base;
    public static FormatterKeyword Anonymous;
    public static FormatterKeyword Remoted;
    public static FormatterKeyword CycleRef;
}
internal enum Microsoft.VisualStudio.IntelliTrace.FormatterMethodOptions : Enum {
    public int value__;
    public static FormatterMethodOptions Short;
    public static FormatterMethodOptions Full;
    public static FormatterMethodOptions CompressedNamespaces;
    public static FormatterMethodOptions FullWithAllParameters;
    public static FormatterMethodOptions FullWithNonSyntheticParameters;
}
internal class Microsoft.VisualStudio.IntelliTrace.FuncletEnterNode : MethodEnterNode {
    public NodeType Type { get; }
    internal FuncletEnterNode(long ordinal, int intelliTraceToken, CodeContext location);
    public virtual NodeType get_Type();
}
[CompilerGeneratedAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.Guids : object {
    public static Guid IntelliTraceProfiler;
    private static Guids();
}
internal class Microsoft.VisualStudio.IntelliTrace.HeuristicNotifyPointSpecification : NotifyPointSpecification {
    private ModuleSpec _modSpec;
    private string _typeName;
    private string _methodName;
    private string _methodId;
    private List`1<string> _params;
    private string _name;
    private string _description;
    private string _categoryName;
    private string _categoryId;
    private string _settingsName;
    private bool _onReturn;
    private _CallStackInfo _callStackInfo;
    public ModuleSpec ModSpec { get; }
    public string ModuleName { get; }
    public string Category { get; }
    public string TypeName { get; }
    public string MethodName { get; }
    public string MethodId { get; }
    public string Name { get; }
    public string Description { get; }
    public bool OnReturn { get; }
    public string SettingsName { get; }
    public _CallStackInfo CallStackInfo { get; }
    public HeuristicNotifyPointSpecification(int id, ModuleSpec moduleSpec, string typeName, string methodName, string methodId, string name, string description, string category);
    public HeuristicNotifyPointSpecification(int id, string moduleSpec, string typeName, string methodName, string methodId, string name, string description, string category);
    public HeuristicNotifyPointSpecification(int id, string moduleSpec, string typeName, string methodName, string methodId, string name, string description, string category, DataQuery dq);
    public HeuristicNotifyPointSpecification(int bindId, _CollectionPlan cp, Dictionary`2<string, ModuleSpec> modSpecTable);
    public ModuleSpec get_ModSpec();
    public string get_ModuleName();
    public string get_Category();
    public string get_TypeName();
    public string get_MethodName();
    public string get_MethodId();
    public string get_Name();
    public string get_Description();
    public bool get_OnReturn();
    public string get_SettingsName();
    public _CallStackInfo get_CallStackInfo();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.HighPerformanceTimer : object {
    private static long _startTime;
    private static long _stopTime;
    private static long _freq;
    public static void Start();
    public static void Stop();
    public static long QueryPerformanceCounter();
    public static void DumpResult();
}
public interface Microsoft.VisualStudio.IntelliTrace.IAccessList`1 {
    public int Count { get; }
    public abstract virtual T GetEvent(int eventIndex);
    public abstract virtual IList`1<T> GetEvents(int startIndex, int fetchCount);
    public abstract virtual int get_Count();
}
internal interface Microsoft.VisualStudio.IntelliTrace.IBidiEnum`1 {
    public abstract virtual int Previous(T[] elements);
    public abstract virtual int Previous(T[] elements, int arrayIndex, int count);
    public abstract virtual void Reset(EnumOrigin origin);
}
internal interface Microsoft.VisualStudio.IntelliTrace.ICallTreeNode {
    public bool HasTimingData { get; }
    public Nullable`1<DateTime> StartTime { get; }
    public Nullable`1<DateTime> EndTime { get; }
    public Nullable`1<TimeSpan> TotalTime { get; }
    public Nullable`1<TimeSpan> SelfTime { get; }
    public string Name { get; }
    public IEnumerable`1<ICallTreeNode> Children { get; }
    public abstract virtual bool get_HasTimingData();
    public abstract virtual Nullable`1<DateTime> get_StartTime();
    public abstract virtual Nullable`1<DateTime> get_EndTime();
    public abstract virtual Nullable`1<TimeSpan> get_TotalTime();
    public abstract virtual Nullable`1<TimeSpan> get_SelfTime();
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<ICallTreeNode> get_Children();
}
internal interface Microsoft.VisualStudio.IntelliTrace.IChainTokenOwner {
    public abstract virtual void GetActiveTokens(EventToken& firstValidToken, EventToken& afterLastToken);
    public abstract virtual void MoveTo(EventToken token);
}
public interface Microsoft.VisualStudio.IntelliTrace.IDataElement {
    public string Name { get; }
    public string Value { get; }
    public string TypeName { get; }
    public bool HasChildren { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Value();
    public abstract virtual string get_TypeName();
    public abstract virtual bool get_HasChildren();
    public abstract virtual IList`1<IDataElement> GetChildren();
}
internal interface Microsoft.VisualStudio.IntelliTrace.IDiagnosticEventRedirect {
    public abstract virtual bool CanRedirect(DiagnosticEvent original);
    public abstract virtual Location Redirect(DiagnosticEvent original);
}
internal interface Microsoft.VisualStudio.IntelliTrace.IEnum`1 {
    public int Count { get; }
    public abstract virtual int Next(T[] elements);
    public abstract virtual int Next(T[] elements, int arrayIndex, int count);
    public abstract virtual void Skip(int count);
    public abstract virtual void Reset();
    public abstract virtual int get_Count();
    public abstract virtual IEnum`1<T> Clone();
}
internal interface Microsoft.VisualStudio.IntelliTrace.IEventWithTime {
    public long EventTime { get; }
    public abstract virtual long get_EventTime();
}
internal interface Microsoft.VisualStudio.IntelliTrace.IExtendedDataElement {
    public bool HasPartialData { get; }
    public abstract virtual bool get_HasPartialData();
}
public interface Microsoft.VisualStudio.IntelliTrace.IIntelliTraceStackFrame {
    public int MethodToken { get; }
    public int ILOffset { get; }
    public int MethodVersion { get; }
    public abstract virtual int get_MethodToken();
    public abstract virtual int get_ILOffset();
    public abstract virtual int get_MethodVersion();
}
internal interface Microsoft.VisualStudio.IntelliTrace.IIntelliTraceThreadProvider {
    public abstract virtual int LoggerThreadIdFromNativeThreadId(int nativeThreadId, long ordinal);
}
internal interface Microsoft.VisualStudio.IntelliTrace.IIntelliTraceTokenProvider {
    public abstract virtual void TranslateToken(int protToken, Int32& mdToken, Guid& mvid);
    public abstract virtual bool TryFindProteusToken(Guid guidModule, int mdToken, Int32& protToken);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.IIS.AppPoolInfoExtensions : object {
    private static bool Is64BitSystem { get; }
    [ExtensionAttribute]
public static bool Is64Bit(AppPoolInfo poolInfo);
    private static bool get_Is64BitSystem();
}
internal class Microsoft.VisualStudio.IntelliTrace.IndependentData : LogData {
    protected List`1<LogData> _fieldValues;
    protected List`1<DebuggerInteractionEvent> _uiContents;
    protected IProgrammableDataQueryEventData _npeEventData;
    private static object s_lock;
    internal IndependentData(DataUnavailableReason reason);
    internal IndependentData(DataContext context, List`1<DebuggerInteractionEvent> uiContents, BlobUnpacker unpacker, IProgrammableDataQueryEventData evtData);
    private static IndependentData();
    internal List`1<LogData> GetFields(List`1<Symbol> fieldSymbols);
    internal List`1<DebuggerInteractionEvent> GetUIContents();
    internal string GetPDQShortDescription(ProgrammableDataQuerySpec pdq, string pdqDirectory, string categoryName);
    internal string GetPDQLongDescription(ProgrammableDataQuerySpec pdq, string pdqDirectory);
    internal List`1<CollectedValueTuple> GetKeyValuePairs(ProgrammableDataQuerySpec pdq, string pdqDirectory);
    internal Object[] GetRawValues();
    internal List`1<Location> GetAlternateLocations(ProgrammableDataQuerySpec pdq, string pdqDirectory);
    internal string GetPDQName(ProgrammableDataQuerySpec pdq, string pdqDirectory);
    internal string GetPDQPreview(ProgrammableDataQuerySpec pdq, string pdqDirectory);
}
internal class Microsoft.VisualStudio.IntelliTrace.IndependentEventData : object {
    private Nullable`1<Guid> _activityId;
    private Nullable`1<Guid> Microsoft.HistoricalDebuggerHost.IProgrammableDataQueryEventData.ActivityId { get; }
    public IndependentEventData(DiagnosticEvent npe);
    private sealed virtual override Nullable`1<Guid> Microsoft.HistoricalDebuggerHost.IProgrammableDataQueryEventData.get_ActivityId();
}
internal class Microsoft.VisualStudio.IntelliTrace.IndeterminateState : TreeState {
    protected Tree _tempTree;
    protected TreeState _prevState;
    internal IndeterminateState(Tree tree, MethodEnterEvent eventData, TreeState prevState);
    internal IndeterminateState(Tree tree, CallSiteEvent eventData, TreeState prevState);
    internal virtual TreeState OnNotifyPoint(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnCheckPoint(ThreadCheckpointEvent eventData);
    internal virtual TreeState OnUIRecordedEvent(DebuggerInteractionEvent eventData);
    internal virtual TreeState OnExceptionStopNP(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnThreadDestroyed(DiagnosticEvent eventData);
    internal virtual TreeState OnMethodEnter(MethodEnterEvent eventData);
    internal virtual TreeState OnMethodExit(MethodExitEvent eventData);
    internal virtual TreeState OnCallsite(CallSiteEvent eventData);
    internal virtual TreeState OnTailCall(TailCallSiteEvent eventData);
    internal virtual TreeState OnExceptionThrown(ExceptionThrownEvent eventData);
    internal virtual TreeState OnExceptionSearchFilterExit(ExceptionSearchFilterExitEvent eventData);
    internal virtual TreeState OnExceptionUnwindFinallyExit(ExceptionUnwindFinallyExitEvent eventData);
    internal virtual TreeState OnExceptionCatcherExit(ExceptionCatchExitEvent eventData);
    internal virtual TreeState OnExceptionUnwindFunctionEnter(ExceptionUnwindFunctionEnterEvent eventData);
}
internal class Microsoft.VisualStudio.IntelliTrace.IndexAccessList`1 : object {
    private FilterIndex`1<T> _index;
    private Chain _chain;
    private bool _isDescending;
    public int Count { get; }
    public IndexAccessList`1(FilterIndex`1<T> source, Chain chain, bool isDescending);
    public sealed virtual T GetEvent(int eventIndex);
    public sealed virtual int get_Count();
    public sealed virtual IList`1<T> GetEvents(int offset, int length);
}
internal class Microsoft.VisualStudio.IntelliTrace.InputNode : FilterNode {
    internal virtual Predicate`1<T> CompilePredicate(QueryArguments`2<T, R> arguments);
    internal virtual Filter`1<T> CompileFilter(QueryArguments`2<T, R> arguments);
}
public abstract class Microsoft.VisualStudio.IntelliTrace.IntelliTraceEvent : object {
    internal static Guid ConvertToGuid(Byte* p);
}
public class Microsoft.VisualStudio.IntelliTrace.IntelliTraceFile : IntelliTraceFileBase {
    private Statistics _statistics;
    private InitializationData _initData;
    private object _traceLock;
    private WebRequestCache _webCache;
    private WebRequestStreamData _webRequestStreamData;
    private WebSessionStreamData _webSessionStreamData;
    private int _webEventsToTrim;
    private int _webRequestsWritten;
    private int _webSessionsWritten;
    private DiagnosticStreamData _diagnosticStreamData;
    private List`1<ThreadStreamData> _threadStreamData;
    private Dictionary`2<Guid, MetadataStreamData> _metadataStreamData;
    private List`1<ITruncatableStream> _truncatableStreams;
    private LogStream _streamZero;
    private Dictionary`2<TraceStreamType, LogStream> _openStreams;
    private Dictionary`2<TraceStreamType, int> _streamIndexes;
    private LogFileBase _logFile;
    private IMessageMemory2 memory;
    private List`1<IntelliTraceProcess> _processes;
    private MessagePackerCollection _packers;
    private MemoryManager memoryManager;
    private long maximumFileBytes;
    private long _fileStatePosition;
    private FileStateAtClose _lastFileState;
    private long _streamZeroMessagePackerOffset;
    private bool _fileStateFull;
    private bool _fileStateTruncated;
    private long _trimRetentionTime;
    private long _trimTimeQPCMultiplier;
    private long _trimMaxQPCSeen;
    internal static int DefaultWebEventsToTrim;
    [CompilerGeneratedAttribute]
private bool <ContinueOnDiskFullException>k__BackingField;
    internal LoggingConfig Config { get; }
    internal MessagePackerCollection Packers { get; }
    internal MemoryManager MemoryManager { get; }
    internal bool IsReadOnly { get; }
    internal string LogFileName { get; }
    internal Statistics Statistics { get; }
    public IList`1<IntelliTraceProcess> Processes { get; }
    internal bool FileStateFull { get; private set; }
    internal bool FileStateTruncated { get; private set; }
    internal bool ContinueOnDiskFullException { get; internal set; }
    public IntelliTraceFile(string logFilePath);
    public IntelliTraceFile(string logFilePath, OpenFlags flags);
    internal IntelliTraceFile(string logFilePath, LogFileAccess access);
    private IntelliTraceFile(string logFilePath, LogFileAccess access, OpenFlags flags);
    internal IntelliTraceFile(LogFile logFile, LogFileAccess access, OpenFlags flags);
    internal IntelliTraceFile(string logFilePath, LogFileCreateMode mode, CreationOptions options, LoggingConfig loggingConfig);
    internal IntelliTraceFile(string logFilePath, CreationOptions options, LoggingConfig loggingConfig);
    private void OpenVerifyConfigurationStream(StreamAccess streamAccess, bool throwIfFullOnClose, _CollectionPlan& collectionPlan);
    private void CreateConfigurationStream(CreationOptions options);
    private void CreateStandardStreams();
    private void FindGlobalStreams();
    private void TryOpenGlobalStream(TraceStreamType t);
    private void OpenGlobalStreams();
    internal static FileVersionInfo GetFileVersion(string logFilePath);
    internal virtual LoggingConfig get_Config();
    internal virtual MessagePackerCollection get_Packers();
    internal virtual MemoryManager get_MemoryManager();
    internal virtual bool get_IsReadOnly();
    internal virtual string get_LogFileName();
    internal virtual void Close();
    internal virtual int CreateStream(Guid type);
    internal virtual void CreateStream(Guid type, int streamIndex);
    internal virtual LogStream CreateStream(Guid type, StreamAccess streamOpenMode);
    internal virtual LogStream CreateStream(Guid type, int streamIndex, StreamAccess streamOpenMode);
    internal virtual LogStream OpenStream(int streamIndex, StreamAccess mode);
    internal virtual LogStream OpenStream(TraceStreamType stream, StreamAccess mode);
    internal virtual bool StreamExists(int streamIndex);
    internal virtual bool StreamExists(TraceStreamType traceStreamType);
    internal virtual int HandleToIndex(int handle);
    internal virtual void Append(BufferDescriptor[] descriptors, int numDescriptors);
    internal virtual void SuspendLogAndBypass(IList`1<BufferDescriptor> descriptors, int numDescriptors);
    internal virtual void ResumeLog();
    internal virtual IList`1<LogStreamEntry> GetLogStreamEntries();
    internal virtual void CloseStream(int threadStreamHandle);
    internal virtual void add_TrimLog(EventHandler`1<TrimLogEventArgs> value);
    internal virtual void remove_TrimLog(EventHandler`1<TrimLogEventArgs> value);
    internal virtual void DoTrimLog(TrimLogEventArgs args);
    internal virtual void add_DiskFull(EventHandler value);
    internal virtual void remove_DiskFull(EventHandler value);
    internal Statistics get_Statistics();
    private void GetStreamStatistics(StatisticsData data);
    private void InitializeStatistics(InitializationData initData);
    private void InitializeStatistics(bool enable);
    internal bool IncrementalFreeBlocks(bool trimRequired, TrimFlags flags);
    private Nullable`1<long> NextMetaDataUnloadOrdinal();
    private bool TruncateMetaDataStreams(long minOrdinal);
    public IList`1<IntelliTraceProcess> get_Processes();
    internal bool get_FileStateFull();
    private void set_FileStateFull(bool value);
    internal bool get_FileStateTruncated();
    private void set_FileStateTruncated(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ContinueOnDiskFullException();
    [CompilerGeneratedAttribute]
internal void set_ContinueOnDiskFullException(bool value);
    public virtual void Dispose();
    internal void CreateThreadStream(Int32& threadStreamIndex, Int32& threadStreamHandle);
    internal void CloseThreadStream(int threadStreamHandle);
    internal void CloseThreadStream(int threadStreamHandle, long ordinal, long afterLastEventOrdinal);
    internal void WriteThreadCheckpoint(int threadStreamIndex, _FullCheckpointData checkpointData);
    internal void WriteTestMessage(Byte[] data);
    internal void WriteThreadCreated(_ThreadCreated createData);
    internal void WriteThreadDestroyed(_ThreadDestroyed destroyData);
    internal void WriteThreadNameChanged(_ThreadNameChanged nameChanged);
    internal void WriteProcessDestroyed(_ProcessDestroyed pde);
    internal void WriteProcessMessage(Byte* pData, int length);
    internal void WriteModuleLoaded(_ModuleLoaded moduleLoaded);
    internal void WriteCollectionPlan(_CollectionPlan collectionPlan);
    internal void WriteAttachedProcessInfo(_ProcessInfo processInfo);
    internal void WriteModuleIsUserCode(_ModuleIsUserCode moduleIsUserCode);
    internal void WritePackedMetadata(Guid mvid, _SavedMetadata packedMd);
    internal void WriteWebSessionTrackingMessage(Byte* message, int length);
    internal void OnWebRequestBegin(_WebRequestBegin begin);
    internal void OnWebRequestEnd(_WebRequestEnd end);
    internal void OnWebThreadBegin(_WebThreadInfo info);
    internal void OnWebThreadEnd(_WebThreadInfo info);
    internal void OnWebRequestAssociatedDiagnosticEvent(_NotifyPointData notifyPoint);
    private void WriteWebCacheEntry(WebRequestCacheEntry entry);
    private void WriteWebRequestTrackingMessage(Byte* message, int length);
    private void WriteWebThreadTrackingMessage(Byte* message, int length);
    internal void WriteWebSummaryTrackingMessage(Byte* message, int length);
    internal void WriteWebRequest(Byte* pData, int length);
    internal void WriteExceptionIndex();
    internal void WriteSysInfo(Byte* pData, int length);
    internal void WriteDiagnosticMessage(Byte[] data);
    internal void WriteDiagnosticCheckpoint(_SimpleCheckpointData checkpointData);
    internal void WriteIntelliTraceToken(Guid mvid, _IntelliTraceToken intelliTraceToken);
    internal void WriteTypeSpecMetadata(Guid mvid, _TypeSpecMetadata typeSpecMetadata);
    internal void WriteBuildInformation(_ApplicationBuildInfo buildInfo);
    internal void SnapCheckpointStreamLengths();
    private long GetStreamLengthForCopy(LogStream stream);
    internal long GetGlobalStreamLength(TraceStreamType traceStreamType);
    internal bool OnModuleLoaded(_ModuleLoaded moduleLoaded, Int32& metadataStreamIndex);
    internal void OnModuleUnloaded(_ModuleUnloaded moduleUnloaded);
    private void WriteFileState(FileStateAtClose state);
    private void WriteStreamZeroMessagePackerMessages(_CollectionPlan collectionPlan);
    internal void RewriteCollectionPlan(_CollectionPlan collectionPlan);
    internal void CopyToLogFile(LogFile copyLog, int bufferSize);
    private void TryWrite(LogStream stream, Byte* pData, int count);
    internal bool TestHookStreamExists(Guid guid);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(object sender, EventArgs args);
}
public abstract class Microsoft.VisualStudio.IntelliTrace.IntelliTraceFileBase : LogFileBase {
    internal MessagePackerCollection Packers { get; }
    internal MemoryManager MemoryManager { get; }
    internal abstract virtual LogStream OpenStream(TraceStreamType stream, StreamAccess mode);
    internal abstract virtual bool StreamExists(TraceStreamType stream);
    internal abstract virtual MessagePackerCollection get_Packers();
    internal abstract virtual MemoryManager get_MemoryManager();
}
[CompilerGeneratedAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.IntelliTraceFileVersion : object {
    public static int MajorVersion;
    public static int MinorVersion;
    public static int ReleaseVersion;
    public static int BuildVersion;
    public static string VersionString;
    private static IntelliTraceFileVersion();
}
public class Microsoft.VisualStudio.IntelliTrace.IntelliTraceModule : object {
    private object _symbols;
    private IntelliTraceProcess _process;
    private ModuleLoadEvent _moduleLoadEvent;
    private Guid _mvid;
    private ModuleSymbols _moduleSymbols;
    public Guid Mvid { get; }
    public long ModuleId { get; }
    public string FileName { get; }
    public object Metadata { get; }
    internal ModuleSymbols ModuleSymbols { get; }
    internal IntelliTraceModule(IntelliTraceProcess process, ModuleLoadEvent moduleLoadEvent);
    public Guid get_Mvid();
    public long get_ModuleId();
    public string get_FileName();
    public object get_Metadata();
    public int LoadSymbols(string symbolSearchPath);
    public IntelliTraceSourceLocation GetSourceLocation(int metadataToken, int offset);
    internal ModuleSymbols get_ModuleSymbols();
}
public class Microsoft.VisualStudio.IntelliTrace.IntelliTraceProcess : object {
    [CompilerGeneratedAttribute]
private SystemInformationEvent <SystemInformationEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessInformationEvent <ProcessInformationEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceFileBase <TraceDebugLogFile>k__BackingField;
    private TraceLog _tracelog;
    private Dictionary`2<int, IntelliTraceThread> _threads;
    private Dictionary`2<Guid, IntelliTraceModule> _modulesByMvid;
    private Dictionary`2<long, IntelliTraceModule> _modulesById;
    private List`1<KeyValuePair`2<IntelliTraceModule, int>> _methodsById;
    private ProgramSymbols _programSymbols;
    private bool _programSymbolsInitialized;
    private SymbolContextProvider _symbolContextProvider;
    private string _programmableDataQueryDirectory;
    private static CLSFormatter _formatter;
    private bool _shouldDisposeTraceLog;
    public IEnumerable`1<IntelliTraceModule> Modules { get; }
    public IEnumerable`1<IntelliTraceThread> Threads { get; }
    public SystemInformationEvent SystemInformationEvent { get; private set; }
    public ProcessInformationEvent ProcessInformationEvent { get; private set; }
    public string ProgrammableDataQueryDirectory { get; public set; }
    internal IntelliTraceFileBase TraceDebugLogFile { get; private set; }
    internal TraceLog TraceLog { get; }
    internal ISymbolContextProvider SymbolContextProvider { get; }
    internal static BaseFormatter Formatter { get; }
    internal IntelliTraceProcess(IntelliTraceFileBase traceDebugLogFile);
    internal IntelliTraceProcess(TraceLog log);
    private static IntelliTraceProcess();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private void Initialize(IntelliTraceFileBase traceDebugLogFile);
    private void Initialize(TraceLog log);
    public IEnumerable`1<IntelliTraceModule> get_Modules();
    public IEnumerable`1<IntelliTraceThread> get_Threads();
    [CompilerGeneratedAttribute]
public SystemInformationEvent get_SystemInformationEvent();
    [CompilerGeneratedAttribute]
private void set_SystemInformationEvent(SystemInformationEvent value);
    [CompilerGeneratedAttribute]
public ProcessInformationEvent get_ProcessInformationEvent();
    [CompilerGeneratedAttribute]
private void set_ProcessInformationEvent(ProcessInformationEvent value);
    public string get_ProgrammableDataQueryDirectory();
    public void set_ProgrammableDataQueryDirectory(string value);
    [CompilerGeneratedAttribute]
internal IntelliTraceFileBase get_TraceDebugLogFile();
    [CompilerGeneratedAttribute]
private void set_TraceDebugLogFile(IntelliTraceFileBase value);
    internal TraceLog get_TraceLog();
    internal ISymbolContextProvider get_SymbolContextProvider();
    internal static BaseFormatter get_Formatter();
    public T CreateProcessChain();
    public T CreateProcessChain(int streamIndex);
    public IntelliTraceModule GetModule(Guid mvid);
    public IntelliTraceModule GetModule(long moduleId);
    public void GetMetadataToken(int intelliTraceMethodToken, Guid& mvid, Int32& methodToken);
    public void LoadSymbols(string symbolSearchPath);
    private void StoreThreadCreateEvent(IntelliTraceEvent intellitraceEvent);
    private void StoreModuleLoadEvent(IntelliTraceEvent intellitraceEvent, HashSet`1<int> metadataStreamIndexes);
    private void StoreSystemInformationEvent(IntelliTraceEvent intellitraceEvent);
    private void StoreProcessInformationEvent(IntelliTraceEvent intellitraceEvent);
    private void ProcessIntelliTraceTokenEvents(HashSet`1<int> metadataStreamIndexes);
    private void AddModule(IntelliTraceModule module);
    private void AddMethod(int methodId, Guid mvid, int methodToken);
}
public class Microsoft.VisualStudio.IntelliTrace.IntelliTraceSourceLocation : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    public string FileName { get; private set; }
    public int StartLine { get; private set; }
    public int StartColumn { get; private set; }
    public int EndLine { get; private set; }
    public int EndColumn { get; private set; }
    internal IntelliTraceSourceLocation(string fileName, int startLine, int startColumn, int endLine, int endColumn);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
private void set_StartLine(int value);
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
private void set_StartColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
private void set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
private void set_EndColumn(int value);
}
public class Microsoft.VisualStudio.IntelliTrace.IntelliTraceStackFrame : object {
    [CompilerGeneratedAttribute]
private int <MethodToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ILOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MethodVersion>k__BackingField;
    public int MethodToken { get; private set; }
    public int ILOffset { get; private set; }
    public int MethodVersion { get; private set; }
    internal IntelliTraceStackFrame(IntelliTraceStackFrame other);
    internal IntelliTraceStackFrame(StackFrame* pFrame);
    internal IntelliTraceStackFrame(_StackFrame frame);
    internal IntelliTraceStackFrame(StackFrame* pFrame);
    internal IntelliTraceStackFrame(_StackFrame frame);
    internal IntelliTraceStackFrame(StackFrame* pFrame);
    internal IntelliTraceStackFrame(_StackFrame frame);
    internal IntelliTraceStackFrame(StackFrame* pFrame);
    internal IntelliTraceStackFrame(_StackFrame frame);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MethodToken();
    [CompilerGeneratedAttribute]
private void set_MethodToken(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ILOffset();
    [CompilerGeneratedAttribute]
private void set_ILOffset(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MethodVersion();
    [CompilerGeneratedAttribute]
private void set_MethodVersion(int value);
    internal _StackFrame AsPackableForDiagnostic();
    internal _StackFrame AsPackableForThread();
    internal static IList`1<IntelliTraceStackFrame> GetStackWithoutCommonRoot(IList`1<IntelliTraceStackFrame> stackWithCommonRoot);
}
public class Microsoft.VisualStudio.IntelliTrace.IntelliTraceThread : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IntelliTraceThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NativeThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ManagedThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceProcess <Process>k__BackingField;
    private List`1<int> _streams;
    public string Name { get; private set; }
    public int IntelliTraceThreadId { get; private set; }
    public int NativeThreadId { get; private set; }
    public long ManagedThreadId { get; private set; }
    internal IntelliTraceProcess Process { get; private set; }
    internal Int32[] Streams { get; }
    internal IntelliTraceThread(IntelliTraceProcess process);
    internal void Update(ThreadCreateEvent threadCreateEvent);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_IntelliTraceThreadId();
    [CompilerGeneratedAttribute]
private void set_IntelliTraceThreadId(int value);
    [CompilerGeneratedAttribute]
public int get_NativeThreadId();
    [CompilerGeneratedAttribute]
private void set_NativeThreadId(int value);
    [CompilerGeneratedAttribute]
public long get_ManagedThreadId();
    [CompilerGeneratedAttribute]
private void set_ManagedThreadId(long value);
    public T CreateThreadChain();
    [CompilerGeneratedAttribute]
internal IntelliTraceProcess get_Process();
    [CompilerGeneratedAttribute]
private void set_Process(IntelliTraceProcess value);
    internal Int32[] get_Streams();
}
public class Microsoft.VisualStudio.IntelliTrace.IntelliTraceTokenChain : ListChain {
    internal IntelliTraceTokenChain(IntelliTraceTokenStreamChain sourceChain);
}
public class Microsoft.VisualStudio.IntelliTrace.IntelliTraceTokenEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MethodToken>k__BackingField;
    public Guid Mvid { get; private set; }
    public int MetadataToken { get; private set; }
    public int MethodToken { get; private set; }
    internal IntelliTraceTokenEvent(IntelliTraceToken* pData);
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    [CompilerGeneratedAttribute]
private void set_Mvid(Guid value);
    [CompilerGeneratedAttribute]
public int get_MetadataToken();
    [CompilerGeneratedAttribute]
private void set_MetadataToken(int value);
    [CompilerGeneratedAttribute]
public int get_MethodToken();
    [CompilerGeneratedAttribute]
private void set_MethodToken(int value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.IntelliTraceTokenStreamChain : FilteredStreamChain {
    internal MessageMemoryByteArray memory;
    private SavedMetadataEventsMessagePacker packer;
    internal IntelliTraceTokenStreamChain(LogStream stream, SavedMetadataEventsMessagePacker packer);
    protected virtual Byte[] ReadEventBytes();
    protected virtual int ReadEventLength();
    protected virtual IntelliTraceEvent ConvertToEvent(EventToken token, Byte[] data, Int32& offset);
    protected virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
    protected virtual short ReadEventId(EventToken token);
}
internal interface Microsoft.VisualStudio.IntelliTrace.IPendingUnpackData {
    public Type Type { get; public set; }
    public object Value { get; public set; }
    public abstract virtual Type get_Type();
    public abstract virtual void set_Type(Type value);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
internal interface Microsoft.VisualStudio.IntelliTrace.IProcessCommandLine {
    public abstract virtual bool ProcessCommandLine(String[] args);
}
internal interface Microsoft.VisualStudio.IntelliTrace.IProcessConfiguration {
    public abstract virtual bool ProcessConfiguration(Configuration config);
}
internal interface Microsoft.VisualStudio.IntelliTrace.IStringComparisonSearchHelper {
    public abstract virtual bool IsMatch(Expr`2<string, string> formattedValueFunc, string searchText, IList`1<string> includedSearchFields);
}
internal interface Microsoft.VisualStudio.IntelliTrace.ITraceLogInfo {
    public string LogFileName { get; }
    public IDictionary`2<string, object> PropertyBag { get; }
    public bool IsDebugLaunch { get; }
    public abstract virtual string get_LogFileName();
    public abstract virtual IDictionary`2<string, object> get_PropertyBag();
    public abstract virtual bool get_IsDebugLaunch();
}
internal interface Microsoft.VisualStudio.IntelliTrace.ITreeNode {
    public NodeType Type { get; }
    public long Ordinal { get; }
    public CodeContext Location { get; }
    public EventHandle Parent { get; }
    public LogData Data { get; }
    public IList`1<byte> Blob { get; }
    public int Depth { get; }
    public bool Hidden { get; public set; }
    public abstract virtual NodeType get_Type();
    public abstract virtual long get_Ordinal();
    public abstract virtual CodeContext get_Location();
    public abstract virtual EventHandle get_Parent();
    public abstract virtual IBidiEnum`1<EventHandle> GetChildren();
    public abstract virtual IBidiEnum`1<EventHandle> GetSiblings();
    public abstract virtual LogData get_Data();
    public abstract virtual IList`1<byte> get_Blob();
    public abstract virtual int get_Depth();
    public abstract virtual bool get_Hidden();
    public abstract virtual void set_Hidden(bool value);
}
internal interface Microsoft.VisualStudio.IntelliTrace.ITreeVisitor {
    public abstract virtual void OnCallsite(ITreeNode node, int depth);
    public abstract virtual void OnStatement(ITreeNode node, int depth);
    public abstract virtual void OnEnter(EventHandle evt, int depth);
    public abstract virtual void OnExit(EventHandle evt, int depth);
}
internal class Microsoft.VisualStudio.IntelliTrace.ListAccessList`1 : object {
    private IList`1<T> _underlyingList;
    public int Count { get; }
    public ListAccessList`1(IList`1<T> underlyingList);
    public sealed virtual T GetEvent(int eventIndex);
    public sealed virtual IList`1<T> GetEvents(int startIndex, int fetchCount);
    public sealed virtual int get_Count();
}
public abstract class Microsoft.VisualStudio.IntelliTrace.ListChain : DerivedChain {
    private Chain _sourceChain;
    private int _numInvalidEvents;
    private List`1<EventLink> _events;
    private EventToken _firstValidSourceToken;
    private EventToken _nextSourceTokenToRead;
    protected internal List`1<EventLink> EventList { get; }
    public bool IsEmpty { get; }
    public EventToken FirstToken { get; }
    public EventToken FirstValidToken { get; }
    public bool CanGetLastToken { get; }
    public bool CanGetPreviousToken { get; }
    public EventToken LastToken { get; }
    public EventToken AfterLastToken { get; }
    public bool CanGetCount { get; }
    public long Count { get; }
    protected ListChain(Chain sourceChain);
    protected internal List`1<EventLink> get_EventList();
    public EventToken ToSourceToken(EventToken token);
    public IntelliTraceEvent ReloadEvent(EventToken token);
    public virtual IntelliTraceEvent GetEvent(EventToken token);
    public virtual IList`1<IntelliTraceEvent> GetEvents(EventToken startToken, EventToken endToken);
    public virtual bool get_IsEmpty();
    public virtual EventToken get_FirstToken();
    public virtual EventToken get_FirstValidToken();
    public virtual bool get_CanGetLastToken();
    public virtual bool get_CanGetPreviousToken();
    public virtual EventToken get_LastToken();
    public virtual EventToken get_AfterLastToken();
    public virtual EventToken GetNextToken(EventToken token);
    public virtual EventToken GetPreviousToken(EventToken token);
    public virtual void Refresh();
    public virtual bool get_CanGetCount();
    public virtual long get_Count();
    public virtual bool IsValidToken(EventToken token);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.IntelliTrace.ListEnum`1 : object {
    private T[] _items;
    private int _cursor;
    public int Count { get; }
    internal ListEnum`1(List`1<T> items);
    public sealed virtual int Next(T[] elements);
    public sealed virtual int Next(T[] elements, int arrayIndex, int count);
    public sealed virtual void Skip(int count);
    public sealed virtual void Reset();
    public sealed virtual int get_Count();
    public sealed virtual IEnum`1<T> Clone();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.IntelliTrace.ListSegment`1 : object {
    [CompilerGeneratedAttribute]
private IList`1<T> <List>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public IList`1<T> List { get; private set; }
    public int Count { get; private set; }
    public int Offset { get; private set; }
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public ListSegment`1(IList`1<T> underlyingList, int offset, int count);
    [CompilerGeneratedAttribute]
public IList`1<T> get_List();
    [CompilerGeneratedAttribute]
private void set_List(IList`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(int value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.VisualStudio.IntelliTrace.LoadPartitionEventArgs`1 : PartitionedListEventArgs`1<T> {
    public LoadPartitionEventArgs`1(Partition`1<T> partition);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.LogData : object {
    protected DataUnavailableReason _reason;
    protected DataContext _context;
    protected BlobUnpacker _unpacker;
    protected bool _partialData;
    internal bool IsAvailable { get; }
    internal bool IsNull { get; }
    internal bool PartialData { get; }
    internal DataUnavailableReason UnavailableReason { get; }
    internal DataContext Context { get; }
    internal BlobUnpacker Unpacker { get; }
    protected LogData(DataContext context, DataUnavailableReason reason, bool partialData);
    protected LogData(DataUnavailableReason reason, bool partialData);
    protected LogData(DataContext context, BlobUnpacker unpacker, bool partialData);
    internal bool get_IsAvailable();
    internal bool get_IsNull();
    internal bool get_PartialData();
    internal DataUnavailableReason get_UnavailableReason();
    internal DataContext get_Context();
    internal BlobUnpacker get_Unpacker();
    public static LogData CreateUnknownValue(Type type);
}
internal class Microsoft.VisualStudio.IntelliTrace.LoggerConnection : object {
}
internal class Microsoft.VisualStudio.IntelliTrace.LogSystemInfo : object {
    [CompilerGeneratedAttribute]
private ulong <QPCInit>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <QPCFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeZoneOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeZone>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    private Dictionary`2<string, string> _sysInfoValues;
    private ProcessorArchitecture _processorArchitecture;
    private bool _isWow64;
    private int _sysLCID;
    public Dictionary`2<string, string> SystemInfoValues { get; }
    internal ulong QPCInit { get; private set; }
    internal ulong QPCFrequency { get; private set; }
    internal TimeSpan TimeZoneOffset { get; private set; }
    internal string TimeZone { get; private set; }
    internal DateTime StartTime { get; private set; }
    internal int SysLCID { get; }
    internal ProcessorArchitecture ProcessorArchitecture { get; }
    internal bool IsWOW64 { get; }
    internal int PointerSizeBytes { get; }
    internal LogSystemInfo(_SystemInfo sysInfo);
    public Dictionary`2<string, string> get_SystemInfoValues();
    [CompilerGeneratedAttribute]
internal ulong get_QPCInit();
    [CompilerGeneratedAttribute]
private void set_QPCInit(ulong value);
    [CompilerGeneratedAttribute]
internal ulong get_QPCFrequency();
    [CompilerGeneratedAttribute]
private void set_QPCFrequency(ulong value);
    [CompilerGeneratedAttribute]
internal TimeSpan get_TimeZoneOffset();
    [CompilerGeneratedAttribute]
private void set_TimeZoneOffset(TimeSpan value);
    [CompilerGeneratedAttribute]
internal string get_TimeZone();
    [CompilerGeneratedAttribute]
private void set_TimeZone(string value);
    [CompilerGeneratedAttribute]
internal DateTime get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTime value);
    internal int get_SysLCID();
    internal ProcessorArchitecture get_ProcessorArchitecture();
    internal bool get_IsWOW64();
    internal int get_PointerSizeBytes();
    public DateTime UtcTimeToLogTime(DateTime utcTime);
    public DateTime LocalTimeToLogTime(DateTime localTime);
    private void AddSystemInfoValue(string key, long value);
    private void AddSystemInfoValue(string key, string value);
}
internal static class Microsoft.VisualStudio.IntelliTrace.LogTimeUtils : object {
    public static DateTime EventTimeToDateTime(ulong qpcEventTime, DateTime baseTime, ulong qpcStartTime, ulong qpcFrequency);
    public static ulong DateTimeToEventTime(DateTime dateTime, DateTime baseTime, ulong qpcStartTime, ulong qpcFrequency);
    public static ulong TimeSpanToQPCTicks(TimeSpan timeSpan, ulong qpcFrequency);
    public static TimeSpan QPCTicksToTimeSpan(ulong qpcTicks, ulong qpcFrequency);
}
internal class Microsoft.VisualStudio.IntelliTrace.MalformedCallTreeException : Exception {
    public MalformedCallTreeException(string message);
    public MalformedCallTreeException(string message, Exception inner);
    private MalformedCallTreeException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.MaxCollectionSizes : Enum {
    public int value__;
    public static MaxCollectionSizes String;
    public static MaxCollectionSizes ArrayElements;
}
internal class Microsoft.VisualStudio.IntelliTrace.MemoryManager : object {
    [CompilerGeneratedAttribute]
private PartitionCache <DiagnosticEventPartitionCache>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionCache <ThreadEventPartitionCache>k__BackingField;
    internal PartitionCache DiagnosticEventPartitionCache { get; private set; }
    internal PartitionCache ThreadEventPartitionCache { get; private set; }
    [CompilerGeneratedAttribute]
internal PartitionCache get_DiagnosticEventPartitionCache();
    [CompilerGeneratedAttribute]
private void set_DiagnosticEventPartitionCache(PartitionCache value);
    [CompilerGeneratedAttribute]
internal PartitionCache get_ThreadEventPartitionCache();
    [CompilerGeneratedAttribute]
private void set_ThreadEventPartitionCache(PartitionCache value);
}
internal class Microsoft.VisualStudio.IntelliTrace.MergeResources : object {
    internal static ResourceManager ResourceManager;
    public static string MergeIsOK { get; }
    public static string MergeHasWarnings { get; }
    public static string MergeHasErrors { get; }
    private static MergeResources();
    public static string IDConflict(object param0, object param1, object param2);
    public static string DuplicateBindingWarning(object param0);
    public static string DuplicateSectionWarning(object param0, object param1);
    public static string BindingMultipleDataQueriesError(object param0);
    public static string DataQueryLevelError(object param0);
    public static string ValueConflict(object param0, object param1, object param2);
    public static string get_MergeIsOK();
    public static string get_MergeHasWarnings();
    public static string get_MergeHasErrors();
    public static string MergeOK(object param0);
    public static string MergeError(object param0);
    public static string MergeWarning(object param0);
}
internal class Microsoft.VisualStudio.IntelliTrace.MessagePackerCollection : object {
    [CompilerGeneratedAttribute]
private DiagnosticCheckpointEventsMessagePacker <DiagnosticCheckpointEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadCheckpointEventsMessagePacker <ThreadCheckpointEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigMessagePacker <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionIndexMessagePacker <ExceptionIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IndependentEventsMessagePacker <IndependentEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessEventsMessagePacker <ProcessEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private SavedMetadataEventsMessagePacker <SavedMetadataEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private TestEventsMessagePacker <TestEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private TestImpactDataEventsMessagePacker <TestImpactDataEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private TestImpactEventsMessagePacker <TestImpactEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceDebugEventsMessagePacker <TraceDebugEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private WebRequestEventsMessagePacker <WebRequestEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private WebSessionTrackingEventsMessagePacker <WebSessionTrackingEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private WebRequestTrackingEventsMessagePacker <WebRequestTrackingEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private WebThreadTrackingEventsMessagePacker <WebThreadTrackingEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private WebSummaryTrackingEventsMessagePacker <WebSummaryTrackingEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildInformationMessagePacker <BuildInformationEvents>k__BackingField;
    private Dictionary`2<Guid, MessagePacker> _packers;
    public DiagnosticCheckpointEventsMessagePacker DiagnosticCheckpointEvents { get; private set; }
    public ThreadCheckpointEventsMessagePacker ThreadCheckpointEvents { get; private set; }
    public ConfigMessagePacker Config { get; private set; }
    public ExceptionIndexMessagePacker ExceptionIndex { get; private set; }
    public IndependentEventsMessagePacker IndependentEvents { get; private set; }
    public ProcessEventsMessagePacker ProcessEvents { get; private set; }
    public SavedMetadataEventsMessagePacker SavedMetadataEvents { get; private set; }
    public TestEventsMessagePacker TestEvents { get; private set; }
    public TestImpactDataEventsMessagePacker TestImpactDataEvents { get; private set; }
    public TestImpactEventsMessagePacker TestImpactEvents { get; private set; }
    public TraceDebugEventsMessagePacker TraceDebugEvents { get; private set; }
    public WebRequestEventsMessagePacker WebRequestEvents { get; private set; }
    public WebSessionTrackingEventsMessagePacker WebSessionTrackingEvents { get; private set; }
    public WebRequestTrackingEventsMessagePacker WebRequestTrackingEvents { get; private set; }
    public WebThreadTrackingEventsMessagePacker WebThreadTrackingEvents { get; private set; }
    public WebSummaryTrackingEventsMessagePacker WebSummaryTrackingEvents { get; private set; }
    public BuildInformationMessagePacker BuildInformationEvents { get; private set; }
    [CompilerGeneratedAttribute]
public DiagnosticCheckpointEventsMessagePacker get_DiagnosticCheckpointEvents();
    [CompilerGeneratedAttribute]
private void set_DiagnosticCheckpointEvents(DiagnosticCheckpointEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public ThreadCheckpointEventsMessagePacker get_ThreadCheckpointEvents();
    [CompilerGeneratedAttribute]
private void set_ThreadCheckpointEvents(ThreadCheckpointEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public ConfigMessagePacker get_Config();
    [CompilerGeneratedAttribute]
private void set_Config(ConfigMessagePacker value);
    [CompilerGeneratedAttribute]
public ExceptionIndexMessagePacker get_ExceptionIndex();
    [CompilerGeneratedAttribute]
private void set_ExceptionIndex(ExceptionIndexMessagePacker value);
    [CompilerGeneratedAttribute]
public IndependentEventsMessagePacker get_IndependentEvents();
    [CompilerGeneratedAttribute]
private void set_IndependentEvents(IndependentEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public ProcessEventsMessagePacker get_ProcessEvents();
    [CompilerGeneratedAttribute]
private void set_ProcessEvents(ProcessEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public SavedMetadataEventsMessagePacker get_SavedMetadataEvents();
    [CompilerGeneratedAttribute]
private void set_SavedMetadataEvents(SavedMetadataEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public TestEventsMessagePacker get_TestEvents();
    [CompilerGeneratedAttribute]
private void set_TestEvents(TestEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public TestImpactDataEventsMessagePacker get_TestImpactDataEvents();
    [CompilerGeneratedAttribute]
private void set_TestImpactDataEvents(TestImpactDataEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public TestImpactEventsMessagePacker get_TestImpactEvents();
    [CompilerGeneratedAttribute]
private void set_TestImpactEvents(TestImpactEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public TraceDebugEventsMessagePacker get_TraceDebugEvents();
    [CompilerGeneratedAttribute]
private void set_TraceDebugEvents(TraceDebugEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public WebRequestEventsMessagePacker get_WebRequestEvents();
    [CompilerGeneratedAttribute]
private void set_WebRequestEvents(WebRequestEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public WebSessionTrackingEventsMessagePacker get_WebSessionTrackingEvents();
    [CompilerGeneratedAttribute]
private void set_WebSessionTrackingEvents(WebSessionTrackingEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public WebRequestTrackingEventsMessagePacker get_WebRequestTrackingEvents();
    [CompilerGeneratedAttribute]
private void set_WebRequestTrackingEvents(WebRequestTrackingEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public WebThreadTrackingEventsMessagePacker get_WebThreadTrackingEvents();
    [CompilerGeneratedAttribute]
private void set_WebThreadTrackingEvents(WebThreadTrackingEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public WebSummaryTrackingEventsMessagePacker get_WebSummaryTrackingEvents();
    [CompilerGeneratedAttribute]
private void set_WebSummaryTrackingEvents(WebSummaryTrackingEventsMessagePacker value);
    [CompilerGeneratedAttribute]
public BuildInformationMessagePacker get_BuildInformationEvents();
    [CompilerGeneratedAttribute]
private void set_BuildInformationEvents(BuildInformationMessagePacker value);
    public _TraceVersionInfo MakeTraceVersionInfo();
    public MessagePacker TryMergeSchema(_SchemaInfo si, Boolean& versionIncompatible);
    public MessagePacker TryMergeSchema(MessageInfo info, Boolean& versionIncompatible);
    private static void TryMergeSchema(MessagePacker packer, MessageInfo info, Byte[] info_bytes, Boolean& versionIncompatible);
    private T CreatePacker();
    private static _SchemaInfo MakeSchemaInfo(MessagePacker packer);
}
public class Microsoft.VisualStudio.IntelliTrace.MetadataEvent : IntelliTraceEvent {
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<byte> <MetadataBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DebugDirectory> <DebugDirectories>k__BackingField;
    public Guid Mvid { get; private set; }
    public IList`1<byte> MetadataBlob { get; private set; }
    public IList`1<DebugDirectory> DebugDirectories { get; private set; }
    internal MetadataEvent(SavedMetadata* pData);
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    [CompilerGeneratedAttribute]
private void set_Mvid(Guid value);
    [CompilerGeneratedAttribute]
public IList`1<byte> get_MetadataBlob();
    [CompilerGeneratedAttribute]
private void set_MetadataBlob(IList`1<byte> value);
    [CompilerGeneratedAttribute]
public IList`1<DebugDirectory> get_DebugDirectories();
    [CompilerGeneratedAttribute]
private void set_DebugDirectories(IList`1<DebugDirectory> value);
}
public class Microsoft.VisualStudio.IntelliTrace.MetadataStreamChain : FilteredStreamChain {
    internal MessageMemoryByteArray memory;
    private SavedMetadataEventsMessagePacker packer;
    internal MetadataStreamChain(LogStream stream, SavedMetadataEventsMessagePacker packer);
    protected virtual Byte[] ReadEventBytes();
    protected virtual int ReadEventLength();
    protected virtual IntelliTraceEvent ConvertToEvent(EventToken token, Byte[] data, Int32& offset);
    protected virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
    protected virtual short ReadEventId(EventToken token);
}
internal class Microsoft.VisualStudio.IntelliTrace.Method : object {
}
internal class Microsoft.VisualStudio.IntelliTrace.MethodContext : object {
    internal Guid Mvid;
    internal int Token;
    internal int MethodVersion;
    internal bool IsUserCode;
    internal MethodContext(Guid mvid, int token, int methodVersion, bool isUserCode);
    public sealed virtual bool Equals(MethodContext other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodContext lhs, MethodContext rhs);
    public static bool op_Inequality(MethodContext lhs, MethodContext rhs);
}
internal class Microsoft.VisualStudio.IntelliTrace.MethodData : LogData {
    protected List`1<LogData> _paramValues;
    private int _extendedDataLocation;
    internal MethodData(DataContext context, DataUnavailableReason reason);
    internal MethodData(DataContext context, BlobUnpacker unpacker);
    internal virtual List`1<LogData> GetParameters(Symbol retSymbol, Symbol thisSymbol, List`1<Symbol> paramSymbols);
}
internal class Microsoft.VisualStudio.IntelliTrace.MethodEnterData : MethodData {
    internal MethodEnterData(DataContext context, DataUnavailableReason reason);
    internal MethodEnterData(DataContext context, BlobUnpacker unpacker);
    internal ScalarData`1<DateTime> GetStartTime(Symbol retSymbol, Symbol thisSymbol, List`1<Symbol> paramSymbols);
}
public class Microsoft.VisualStudio.IntelliTrace.MethodEnterEvent : MethodEvent {
    internal MethodEnterEvent(EnterData* pData);
    internal MethodEnterEvent(MethodTokenData* pData);
    internal MethodEnterEvent(long ordinal, int intelliTraceToken, IList`1<byte> dataBytes);
    internal MethodEnterEvent(long ordinal);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.MethodEnterNode : MethodNode {
    public NodeType Type { get; }
    internal MethodEnterNode(long ordinal, int intelliTraceToken, CodeContext location, IList`1<byte> blob);
    public virtual NodeType get_Type();
}
public class Microsoft.VisualStudio.IntelliTrace.MethodEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private int <MethodToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<byte> <DataBytes>k__BackingField;
    public int MethodToken { get; protected set; }
    public IList`1<byte> DataBytes { get; protected set; }
    protected MethodEvent(long ordinal, int intelliTraceToken, IList`1<byte> dataBytes);
    protected MethodEvent(long ordinal);
    [CompilerGeneratedAttribute]
public virtual int get_MethodToken();
    [CompilerGeneratedAttribute]
protected virtual void set_MethodToken(int value);
    [CompilerGeneratedAttribute]
public virtual IList`1<byte> get_DataBytes();
    [CompilerGeneratedAttribute]
protected virtual void set_DataBytes(IList`1<byte> value);
}
internal class Microsoft.VisualStudio.IntelliTrace.MethodExitData : MethodData {
    private Nullable`1<DateTime> _endTime;
    private Nullable`1<TimeSpan> _totalTimeSpan;
    internal MethodExitData(DataContext context, DataUnavailableReason reason);
    internal MethodExitData(DataContext context, BlobUnpacker unpacker);
    internal ScalarData`1<DateTime> GetEndTime(Symbol retSymbol, Symbol thisSymbol, List`1<Symbol> paramSymbols);
    internal ScalarData`1<TimeSpan> GetTotalTimeSpan(Symbol retSymbol, Symbol thisSymbol, List`1<Symbol> paramSymbols);
    private void ReadTimingData(Symbol retSymbol, Symbol thisSymbol, List`1<Symbol> paramSymbols);
}
public class Microsoft.VisualStudio.IntelliTrace.MethodExitEvent : MethodEvent {
    internal MethodExitEvent(long ordinal, int intelliTraceToken, IList`1<byte> dataBytes);
    internal MethodExitEvent(ExitData* pData);
    internal MethodExitEvent(MethodTokenData* pData);
    internal MethodExitEvent(long ordinal);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.MethodExitNode : MethodNode {
    public NodeType Type { get; }
    internal MethodExitNode(long ordinal, int intelliTraceToken, CodeContext location, IList`1<byte> blob);
    public virtual NodeType get_Type();
}
internal class Microsoft.VisualStudio.IntelliTrace.MethodNode : Node {
    protected IList`1<byte> _blob;
    protected int _intelliTraceToken;
    public int IntelliTraceToken { get; }
    public IList`1<byte> Blob { get; }
    internal MethodNode(long ordinal, int intelliTraceToken, CodeContext location, IList`1<byte> blob);
    public int get_IntelliTraceToken();
    public virtual IList`1<byte> get_Blob();
}
internal class Microsoft.VisualStudio.IntelliTrace.ModuleData : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BaseLoadAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LoadTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <UnloadTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetadataStreamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LoadOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UnloadOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AppDomainId>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, IList`1<byte>> <TypeSpecs>k__BackingField;
    public string Path { get; internal set; }
    public Guid Mvid { get; internal set; }
    public long BaseLoadAddress { get; internal set; }
    public ulong LoadTime { get; internal set; }
    public ulong UnloadTime { get; internal set; }
    public int MetadataStreamIndex { get; private set; }
    internal long LoadOrdinal { get; private set; }
    internal long UnloadOrdinal { get; internal set; }
    internal int AppDomainId { get; private set; }
    internal Dictionary`2<int, IList`1<byte>> TypeSpecs { get; internal set; }
    internal ModuleData(ModuleLoadEvent moduleLoad);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    [CompilerGeneratedAttribute]
internal void set_Mvid(Guid value);
    [CompilerGeneratedAttribute]
public long get_BaseLoadAddress();
    [CompilerGeneratedAttribute]
internal void set_BaseLoadAddress(long value);
    [CompilerGeneratedAttribute]
public ulong get_LoadTime();
    [CompilerGeneratedAttribute]
internal void set_LoadTime(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_UnloadTime();
    [CompilerGeneratedAttribute]
internal void set_UnloadTime(ulong value);
    [CompilerGeneratedAttribute]
public int get_MetadataStreamIndex();
    [CompilerGeneratedAttribute]
private void set_MetadataStreamIndex(int value);
    [CompilerGeneratedAttribute]
internal long get_LoadOrdinal();
    [CompilerGeneratedAttribute]
private void set_LoadOrdinal(long value);
    [CompilerGeneratedAttribute]
internal long get_UnloadOrdinal();
    [CompilerGeneratedAttribute]
internal void set_UnloadOrdinal(long value);
    [CompilerGeneratedAttribute]
internal int get_AppDomainId();
    [CompilerGeneratedAttribute]
private void set_AppDomainId(int value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<int, IList`1<byte>> get_TypeSpecs();
    [CompilerGeneratedAttribute]
internal void set_TypeSpecs(Dictionary`2<int, IList`1<byte>> value);
}
public class Microsoft.VisualStudio.IntelliTrace.ModuleIsUserCodeEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    public Guid Mvid { get; private set; }
    internal ModuleIsUserCodeEvent(ModuleIsUserCode* pData);
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    [CompilerGeneratedAttribute]
private void set_Mvid(Guid value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ModuleLoadEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private long <ModuleId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BaseLoadAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUserCode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetadataStreamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AppDomainId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    public long ModuleId { get; private set; }
    public long EventTime { get; private set; }
    public Guid Mvid { get; private set; }
    public string Name { get; private set; }
    public long BaseLoadAddress { get; private set; }
    public bool IsUserCode { get; private set; }
    public int MetadataStreamIndex { get; private set; }
    public int AppDomainId { get; private set; }
    public long Id { get; private set; }
    internal ModuleLoadEvent(ModuleLoaded* pData);
    [CompilerGeneratedAttribute]
public long get_ModuleId();
    [CompilerGeneratedAttribute]
private void set_ModuleId(long value);
    [CompilerGeneratedAttribute]
public long get_EventTime();
    [CompilerGeneratedAttribute]
private void set_EventTime(long value);
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    [CompilerGeneratedAttribute]
private void set_Mvid(Guid value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_BaseLoadAddress();
    [CompilerGeneratedAttribute]
private void set_BaseLoadAddress(long value);
    [CompilerGeneratedAttribute]
public bool get_IsUserCode();
    [CompilerGeneratedAttribute]
private void set_IsUserCode(bool value);
    [CompilerGeneratedAttribute]
public int get_MetadataStreamIndex();
    [CompilerGeneratedAttribute]
private void set_MetadataStreamIndex(int value);
    [CompilerGeneratedAttribute]
public int get_AppDomainId();
    [CompilerGeneratedAttribute]
private void set_AppDomainId(int value);
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(long value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.ModuleSpec : object {
    public static ushort AnyVersion;
    public string ModuleId;
    public string ModuleName;
    public Version MinVersion;
    public Version MaxVersion;
    public ModuleSpec(string moduleId, string moduleName, string minVersion, string maxVersion);
}
internal class Microsoft.VisualStudio.IntelliTrace.ModuleTracker : EventTracker {
    private Dictionary`2<UniqueModuleId, ModuleData> _mods;
    private Dictionary`2<Guid, ModuleInfo> _moduleInfo;
    private List`1<KeyValuePair`2<Guid, int>> _knownTokens;
    private HashSet`1<int> _metadataStreamIndices;
    private bool _explicitUserCode;
    [CompilerGeneratedAttribute]
private EventHandler`1<NewStreamEventArgs> NewMetadataStream;
    internal virtual void HandleEvent(ModuleIsUserCodeEvent modIsUserCode, EventHandle handle);
    internal virtual void HandleEvent(ModuleLoadEvent moduleLoad, EventHandle handle);
    internal virtual void HandleEvent(ModuleUnloadEvent moduleUnload, EventHandle handle);
    internal virtual void HandleEvent(IntelliTraceTokenEvent intelliTraceToken, EventHandle handle);
    internal virtual void HandleEvent(TypeSpecMetadataEvent typeSpecMetadata, EventHandle handle);
    internal List`1<ModuleData> GetModules(EventToken beginTime, EventToken endTime);
    internal UserCodeEnum GetUserCodeStatus(Guid mvid);
    internal ModuleData LookupModule(Guid mvid);
    internal MethodContext LookupMethod(IntelliTraceStackFrame frame, ConfigurationTracker configTracker);
    internal MethodContext LookupMethod(int protToken, ConfigurationTracker configTracker);
    internal int LookupProteusToken(int mdToken, Guid mvid);
    internal Byte[] LookupTypeSpec(int mdToken, Guid mvid);
    [CompilerGeneratedAttribute]
internal void add_NewMetadataStream(EventHandler`1<NewStreamEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_NewMetadataStream(EventHandler`1<NewStreamEventArgs> value);
}
public class Microsoft.VisualStudio.IntelliTrace.ModuleUnloadEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private long <ModuleId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AppDomainId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    public long ModuleId { get; private set; }
    public long EventTime { get; private set; }
    public Guid Mvid { get; private set; }
    public int AppDomainId { get; private set; }
    public long Id { get; private set; }
    internal ModuleUnloadEvent(ModuleUnloaded* pData);
    [CompilerGeneratedAttribute]
public long get_ModuleId();
    [CompilerGeneratedAttribute]
private void set_ModuleId(long value);
    [CompilerGeneratedAttribute]
public long get_EventTime();
    [CompilerGeneratedAttribute]
private void set_EventTime(long value);
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    [CompilerGeneratedAttribute]
private void set_Mvid(Guid value);
    [CompilerGeneratedAttribute]
public int get_AppDomainId();
    [CompilerGeneratedAttribute]
private void set_AppDomainId(int value);
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(long value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.Monitoring.ExceptionEventArgs : EventArgs {
    private _MonitoringExceptionEvent exceptionEvent;
    private StackFrame[] thrownStack;
    private StackFrame[] handledStack;
    private SimpleDataElement exceptionObject;
    public ExceptionHandlingState ExceptionState { get; }
    public StackFrame[] ThrownStack { get; }
    public StackFrame[] HandledStack { get; }
    public IDataElement ExceptionObject { get; }
    public Byte[] CustomData { get; }
    internal ExceptionEventArgs(_MonitoringExceptionEvent exceptionEvent);
    public ExceptionHandlingState get_ExceptionState();
    public StackFrame[] get_ThrownStack();
    public StackFrame[] get_HandledStack();
    public IDataElement get_ExceptionObject();
    public Byte[] get_CustomData();
    private void AddExceptionFields(SimpleDataElement exception, _MonitoringExceptionData exceptionData);
}
public enum Microsoft.VisualStudio.IntelliTrace.Monitoring.ExceptionHandlingState : Enum {
    public int value__;
    public static ExceptionHandlingState Unknown;
    public static ExceptionHandlingState Thrown;
    public static ExceptionHandlingState Caught;
    public static ExceptionHandlingState Eclipsed;
    public static ExceptionHandlingState Suppressed;
    public static ExceptionHandlingState Unhandled;
}
public class Microsoft.VisualStudio.IntelliTrace.Monitoring.StackFrame : ValueType {
    private _MonitoringStackFrame monitoringStackFrame;
    public string TypeName { get; }
    public string MethodName { get; }
    public int ILOffset { get; }
    internal StackFrame(_MonitoringStackFrame monitoringStackFrame);
    public string get_TypeName();
    public string get_MethodName();
    public int get_ILOffset();
}
internal class Microsoft.VisualStudio.IntelliTrace.NamedQueryArguments`2 : QueryArguments`2<T, R> {
    [CompilerGeneratedAttribute]
private Expr`3<R, string, string> <PropertyFormatter>k__BackingField;
    internal Expr`3<R, string, string> PropertyFormatter { get; private set; }
    internal NamedQueryArguments`2(Expr`2<T, R> formatter, Expr`3<R, string, string> propertyFormatter);
    [CompilerGeneratedAttribute]
internal Expr`3<R, string, string> get_PropertyFormatter();
    [CompilerGeneratedAttribute]
private void set_PropertyFormatter(Expr`3<R, string, string> value);
}
internal class Microsoft.VisualStudio.IntelliTrace.NestedArrayBlobUnpacker : BlobUnpacker {
    private List`1<ArrayElement> _arrayElements;
    internal List`1<ArrayElement> ArrayElements { get; }
    internal NestedArrayBlobUnpacker(Byte[] memory, int lowerBound, int upperBound, int savedElementCount, Type elementType);
    internal static Type CloneTypeIfJaggedArray(Type type);
    public virtual void BeforeUnpack(int typeSize);
    public virtual void AfterUnpack(int typeSize);
    public virtual UnpackResult Unpack(String& value, Int32& originalSize);
    public virtual UnpackResult Unpack(bool isNestedField, Type elementType, BlobUnpacker& value, ArrayDimensionLayout[] dimensions, Int16& savedElements);
    public virtual UnpackResult UnpackLength(Int32& length);
    public virtual int UnpackInvalidRefDepth();
    public virtual UnpackResult Unpack(BlobUnpacker& unpacker, ObjectLayout layout, bool isValueType);
    public virtual UnpackResult Unpack(BlobUnpacker& value);
    public virtual UnpackResult UnpackRest(BlobUnpacker& value);
    internal List`1<ArrayElement> get_ArrayElements();
}
internal class Microsoft.VisualStudio.IntelliTrace.NewStreamEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <NewStreamIndex>k__BackingField;
    public int NewStreamIndex { get; private set; }
    public NewStreamEventArgs(int newStreamIndex);
    [CompilerGeneratedAttribute]
public int get_NewStreamIndex();
    [CompilerGeneratedAttribute]
private void set_NewStreamIndex(int value);
}
[DebuggerDisplayAttribute("Node: Type={Type}, Location={Location.MethodContext.Mvid}, {Location.MethodContext.Token}")]
internal abstract class Microsoft.VisualStudio.IntelliTrace.Node : object {
    protected long _ordinal;
    protected CodeContext _location;
    protected EventHandle _parent;
    [CompilerGeneratedAttribute]
private bool <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandleToNode <Handle>k__BackingField;
    public NodeType Type { get; }
    public long Ordinal { get; }
    public CodeContext Location { get; internal set; }
    public EventHandle Parent { get; internal set; }
    public LogData Data { get; }
    public IList`1<byte> Blob { get; }
    public bool Hidden { get; public set; }
    public int Depth { get; }
    internal EventHandleToNode Handle { get; internal set; }
    protected Node(long ordinal, CodeContext location);
    public virtual NodeType get_Type();
    public virtual long get_Ordinal();
    public virtual CodeContext get_Location();
    internal virtual void set_Location(CodeContext value);
    public virtual EventHandle get_Parent();
    internal virtual void set_Parent(EventHandle value);
    public virtual IBidiEnum`1<EventHandle> GetChildren();
    public virtual IBidiEnum`1<EventHandle> GetSiblings();
    public virtual LogData get_Data();
    public virtual IList`1<byte> get_Blob();
    [CompilerGeneratedAttribute]
public virtual bool get_Hidden();
    [CompilerGeneratedAttribute]
public virtual void set_Hidden(bool value);
    public virtual int get_Depth();
    [CompilerGeneratedAttribute]
internal EventHandleToNode get_Handle();
    [CompilerGeneratedAttribute]
internal void set_Handle(EventHandleToNode value);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.NodeFlags : Enum {
    public int value__;
    public static NodeFlags None;
    public static NodeFlags DataFetched;
    public static NodeFlags ChildrenFetched;
}
internal enum Microsoft.VisualStudio.IntelliTrace.NodeType : Enum {
    public int value__;
    public static NodeType Root;
    public static NodeType Callsite;
    public static NodeType Statement;
    public static NodeType MethodEnter;
    public static NodeType MethodExit;
    public static NodeType Return;
    public static NodeType Throw;
    public static NodeType Catch;
    public static NodeType Funclet;
}
internal class Microsoft.VisualStudio.IntelliTrace.NotCollectedData : StringData {
}
internal enum Microsoft.VisualStudio.IntelliTrace.NOTIFY_EXCEPTION_TYPE : Enum {
    public int value__;
    public static NOTIFY_EXCEPTION_TYPE NOTIFY_EXCPETION_UNUSED;
    public static NOTIFY_EXCEPTION_TYPE NOTIFY_EXCEPTION_THROWN;
    public static NOTIFY_EXCEPTION_TYPE NOTIFY_EXCEPTION_CAUGHT;
}
internal enum Microsoft.VisualStudio.IntelliTrace.NOTIFY_STOP_TYPE : Enum {
    public int value__;
    public static NOTIFY_STOP_TYPE NOTIFY_STOP_UNUSED;
    public static NOTIFY_STOP_TYPE NOTIFY_STOP_ENTRYPOINT;
    public static NOTIFY_STOP_TYPE NOTIFY_STOP_BREAKPOINT;
    public static NOTIFY_STOP_TYPE NOTIFY_STOP_STEPCOMPLETE;
    public static NOTIFY_STOP_TYPE NOTIFY_STOP_ASYNCBREAK;
    public static NOTIFY_STOP_TYPE NOTIFY_STOP_EXCEPTION;
    public static NOTIFY_STOP_TYPE NOTIFY_STOP_LOADCOMPLETE;
    public static NOTIFY_STOP_TYPE NOTIFY_STOP_EXCEPTION_INTERCEPTED;
}
internal class Microsoft.VisualStudio.IntelliTrace.NotifyNode : Node {
    protected EventHandle _eventHandle;
    private int _notifyId;
    public DiagnosticEvent DiagnosticEvent { get; }
    public NodeType Type { get; }
    public IList`1<byte> Blob { get; }
    public int NotifyId { get; }
    public List`1<DebuggerInteractionEvent> UIContents { get; }
    internal NotifyNode(long ordinal, CodeContext location, DiagnosticEvent np, EventHandle eventHandle);
    public DiagnosticEvent get_DiagnosticEvent();
    public virtual NodeType get_Type();
    public virtual IList`1<byte> get_Blob();
    public virtual int get_NotifyId();
    public virtual List`1<DebuggerInteractionEvent> get_UIContents();
}
internal class Microsoft.VisualStudio.IntelliTrace.NotifyPointResources : object {
    internal static int debuggerStopEventUnknown;
    internal static int debuggerStopEventAsyncBreak;
    internal static int debuggerStopEventBreakpoint;
    internal static int debuggerStopEventEntrypoint;
    internal static int debuggerStopEventException;
    internal static int debuggerStopEventStepComplete;
    internal static int debuggerStopEventLoadComplete;
    internal static int debuggerStopEventExceptionIntercepted;
    internal static int debuggerStopEventThreadSwitch;
    internal static int debuggerExceptionThrown;
    internal static int debuggerExceptionCaught;
    internal static int profilerExceptionThrown;
    internal static int profilerExceptionCaught;
    internal static int loggerThreadAborted;
    internal static int loggerLoggingSuspended;
    internal static int sideLoadBreakpoint;
    private static CultureInfo _culture;
    internal static CultureInfo Culture { get; internal set; }
    internal static string Category_DebuggerEvent { get; }
    internal static string Category_ExceptionEvent { get; }
    internal static void set_Culture(CultureInfo value);
    internal static CultureInfo get_Culture();
    internal static string get_Category_DebuggerEvent();
    internal static string get_Category_ExceptionEvent();
    internal static int GetEventId(NOTIFY_EXCEPTION_TYPE exceptionType);
    internal static int GetEventId(NOTIFY_STOP_TYPE stopType);
    internal static NotifyPointDetails GetDetails(int id);
    internal static bool IsStoppingEvent(int eventId);
}
internal class Microsoft.VisualStudio.IntelliTrace.NotifyPointSpecification : object {
    private int _id;
    protected DataQuery _dataQuery;
    protected ProgrammableDataQuerySpec _programmableDataQuerySpec;
    public int Id { get; }
    public DataQuery DataQuery { get; }
    public ProgrammableDataQuerySpec ProgrammableDataQuerySpec { get; }
    public NotifyPointSpecification(int id);
    public NotifyPointSpecification(int id, DataQuery dq);
    public NotifyPointSpecification(int id, _DataQuery[] dq);
    public int get_Id();
    public DataQuery get_DataQuery();
    public ProgrammableDataQuerySpec get_ProgrammableDataQuerySpec();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.IntelliTrace.NotifyPointSpecificationCollection : ReadOnlyCollectionBase {
    public NotifyPointSpecification Item { get; }
    public NotifyPointSpecification get_Item(int index);
    public void AddHeuristicBind(HeuristicNotifyPointSpecification hps);
    public void RemoveNotifyPoint(int id);
}
internal class Microsoft.VisualStudio.IntelliTrace.NotifyPointTracker : object {
    private Dictionary`2<int, HeuristicNotifyPointSpecification> _nptable;
    private TraceLogReader _reader;
    private Dictionary`2<string, string> _categoryIdToNameMap;
    private DiagnosticChain _npChain;
    private static string AspNetCategoryId;
    internal NotifyPointTracker(TraceLogReader reader, DiagnosticChain npChain, Dictionary`2<int, HeuristicNotifyPointSpecification> nptable, Dictionary`2<string, string> categoryIdToNameMap);
    internal void Refresh();
    internal IBidiEnum`1<NPEventData> GetNotifyPoints();
    internal IBidiEnum`1<NPEventData> GetNotifyPoints(IList`1<WebEventFilter> filters);
    internal IBidiEnum`1<UlsNPData> GetUlsNotifyPoints();
    private NPEventData GetData(OrdinalEvent evt, EventToken token, Chain chain);
    private UlsNPData GetUlsData(OrdinalEvent evt, EventToken token, Chain chain);
    private NPData GetNPData(OrdinalEvent evt, EventToken token, Chain chain, bool ulsData);
    private bool CalculateUserCode(DiagnosticEvent npe, string category);
}
internal class Microsoft.VisualStudio.IntelliTrace.NPData : object {
    [CompilerGeneratedAttribute]
private long <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    protected string _categoryName;
    [CompilerGeneratedAttribute]
private bool <IsUserEvent>k__BackingField;
    public long Ordinal { get; public set; }
    public long Id { get; public set; }
    public long EventTime { get; public set; }
    public int ThreadId { get; public set; }
    public string Category { get; public set; }
    public string CategoryName { get; }
    public bool IsUserEvent { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Ordinal();
    [CompilerGeneratedAttribute]
public void set_Ordinal(long value);
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(long value);
    [CompilerGeneratedAttribute]
public long get_EventTime();
    [CompilerGeneratedAttribute]
public void set_EventTime(long value);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
public void set_ThreadId(int value);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
    public string get_CategoryName();
    [CompilerGeneratedAttribute]
public bool get_IsUserEvent();
    [CompilerGeneratedAttribute]
public void set_IsUserEvent(bool value);
}
internal class Microsoft.VisualStudio.IntelliTrace.NPEventData : NPData {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NotifyId>k__BackingField;
    internal IntelliTraceEvent _evt;
    internal EventHandle _evtHandle;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ActivityId>k__BackingField;
    public string Name { get; public set; }
    public string Description { get; public set; }
    public string MethodName { get; public set; }
    public string TypeName { get; public set; }
    public int NotifyId { get; public set; }
    public Nullable`1<Guid> ActivityId { get; public set; }
    internal NPEventData(IntelliTraceEvent evt, EventHandle evtHandle, string categoryName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public int get_NotifyId();
    [CompilerGeneratedAttribute]
public void set_NotifyId(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ActivityId();
    [CompilerGeneratedAttribute]
public void set_ActivityId(Nullable`1<Guid> value);
    private bool IsMatch(string text, string searchText);
    public sealed virtual bool IsMatch(Expr`2<string, string> propertyFormatter, string searchText, IList`1<string> includedSearchFields);
}
public class Microsoft.VisualStudio.IntelliTrace.NullEvent : OrdinalEvent {
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.NullState : TreeState {
    internal NullState(Tree tree);
    internal virtual TreeState OnNotifyPoint(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnCheckPoint(ThreadCheckpointEvent eventData);
    internal virtual TreeState OnUIRecordedEvent(DebuggerInteractionEvent eventData);
    internal virtual TreeState OnThrowNP(DiagnosticEvent eventData);
    internal virtual TreeState OnCatchNP(DiagnosticEvent eventData);
    internal virtual TreeState OnExceptionInterceptedNP(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnExceptionStopNP(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnThreadDestroyed(DiagnosticEvent eventData);
    internal virtual TreeState OnMethodEnter(MethodEnterEvent eventData);
    internal virtual TreeState OnExceptionThrown(ExceptionThrownEvent eventData);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectLayout : object {
    [CompilerGeneratedAttribute]
private bool <HasVariableSizeFields>k__BackingField;
    private List`1<FieldLayout> _fieldsIn;
    private FieldLayout[] _fieldsOut;
    private List`1<FieldLayout> _map;
    private int _dataSize;
    private bool _isLayoutBuilt;
    private static MethodInfo _packString;
    private Int32[] _fieldSizes;
    internal IEnumerable`1<FieldLayout> Layout { get; }
    internal int DataSize { get; }
    internal bool HasVariableSizeFields { get; internal set; }
    internal IEnumerable`1<FieldLayout> OrderedLayout { get; }
    internal ObjectLayout(int sizeIntPtr);
    private static ObjectLayout();
    internal FieldLayout Add(object param, Type type);
    internal FieldLayout Add(object param, Type type, bool isNullable);
    internal void CreateLayout();
    internal UnpackResult UnPack(BlobUnpacker unpacker);
    internal static DataUnavailableReason GetObjectValueUnavailableReason(object value);
    internal IEnumerable`1<FieldLayout> get_Layout();
    internal int get_DataSize();
    [CompilerGeneratedAttribute]
internal void set_HasVariableSizeFields(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HasVariableSizeFields();
    internal IEnumerable`1<FieldLayout> get_OrderedLayout();
    private FieldType FieldTypeOfSym(Type t);
    private void AddField(FieldLayout fl);
    private void UnpackPrimitiveValue(BlobUnpacker unpacker, FieldLayout& fi, FieldType type);
}
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This class is Obsolete. Please use CallStackStateMachine", "False")]
public static class Microsoft.VisualStudio.IntelliTrace.ObjectModel.CallStackFactory : object {
    public static CallStack CreateStack();
}
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.IntelliTrace.ObjectModel.DataFactory : object {
    private static NullData _nullDataInstance;
    private static DataFactory();
    public static PrimitiveData CreatePrimitive(MetadataType dataType, object value);
    public static ClassData Create(MetadataType dataType);
    public static CycleData CreateCycle(MetadataType dataType, ObjectData reference);
    public static CycleData CreateCycle(ObjectData reference);
    public static ArrayData CreateArray(MetadataType typeSpec, Array dataElements);
    public static ArrayData CreateArray(MetadataType typeSpec, Array dataElements, int totalCount);
    public static NullData CreateNull();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.DefaultCategoryResources : object {
    internal static ResourceManager ResourceManager;
    public static string ADONet { get; }
    public static string ASPNet { get; }
    public static string Console { get; }
    public static string DataBinding { get; }
    public static string EnvironmentVariables { get; }
    public static string File { get; }
    public static string Gesture { get; }
    public static string LazyInitialization { get; }
    public static string Performance { get; }
    public static string Registry { get; }
    public static string ServiceModel { get; }
    public static string Threading { get; }
    public static string Tracing { get; }
    public static string UserPrompt { get; }
    public static string Workflow { get; }
    public static string XML { get; }
    private static DefaultCategoryResources();
    public static string get_ADONet();
    public static string get_ASPNet();
    public static string get_Console();
    public static string get_DataBinding();
    public static string get_EnvironmentVariables();
    public static string get_File();
    public static string get_Gesture();
    public static string get_LazyInitialization();
    public static string get_Performance();
    public static string get_Registry();
    public static string get_ServiceModel();
    public static string get_Threading();
    public static string get_Tracing();
    public static string get_UserPrompt();
    public static string get_Workflow();
    public static string get_XML();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ApplicationInformation.BuildInformationEventsImpl : BuildInformationEvents {
    [CompilerGeneratedAttribute]
private IList`1<BuildInformation> <BuildInformationList>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    private IList`1<BuildInformation> BuildInformationList { get; private set; }
    private IntelliTraceStoreImpl Store { get; private set; }
    public IEnumerable`1<BuildInformation> Events { get; }
    internal BuildInformationEventsImpl(IntelliTraceStoreImpl store);
    [CompilerGeneratedAttribute]
private IList`1<BuildInformation> get_BuildInformationList();
    [CompilerGeneratedAttribute]
private void set_BuildInformationList(IList`1<BuildInformation> value);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    public virtual BuildInformation CreateBuildInformation(string applicationName, Byte[] data);
    public virtual IEnumerable`1<BuildInformation> get_Events();
    private void StoreFlushHandler();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ApplicationInformation.BuildInformationImpl : BuildInformation {
    private ObjectValidityState _objectState;
    private string _applicationName;
    private Byte[] _data;
    public string ApplicationName { get; protected set; }
    public Byte[] Data { get; protected set; }
    internal BuildInformationImpl(string applicationName, Byte[] data);
    public virtual string get_ApplicationName();
    protected virtual void set_ApplicationName(string value);
    public virtual Byte[] get_Data();
    protected virtual void set_Data(Byte[] value);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.BitPacker : object {
    private BitArray _bitArray;
    private int _bitIndex;
    private Byte[] _buffer;
    private int _bufferPosition;
    private bool _bufferCommitted;
    public BitPacker(int expectedBitCount);
    public void PackBit(bool bitValue);
    public Byte[] GetBytes();
    private void PackByte();
    private void ThrowIfCommitted();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.CallStackFrameImpl : CallStackFrame {
    private ObjectValidityState _objectState;
    private ParameterDataImpl _parameterData;
    private TimingDataImpl _timingData;
    private MetadataMethod _method;
    private int _ilOffset;
    [CompilerGeneratedAttribute]
private long <EnterOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CallSiteOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LeaveOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MethodEnterOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MethodExitOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CallSiteOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DiagnosticEvent> <DiagnosticEvents>k__BackingField;
    public MetadataMethod Method { get; protected set; }
    public int ILOffset { get; protected set; }
    private long Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.IOrdered.InternalOrdinal { get; private set; }
    internal long EnterOrdinal { get; internal set; }
    internal long CallSiteOrdinal { get; internal set; }
    internal long LeaveOrdinal { get; internal set; }
    internal long MethodEnterOffset { get; internal set; }
    internal long MethodExitOffset { get; internal set; }
    internal long CallSiteOffset { get; internal set; }
    internal IList`1<DiagnosticEvent> DiagnosticEvents { get; private set; }
    public ParameterData ParameterData { get; }
    public TimingData TimingData { get; }
    internal CallStackFrameImpl(MetadataMethod method, int ilOffset);
    public virtual MetadataMethod get_Method();
    protected virtual void set_Method(MetadataMethod value);
    public virtual int get_ILOffset();
    protected virtual void set_ILOffset(int value);
    private sealed virtual override long Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.IOrdered.get_InternalOrdinal();
    private sealed virtual override void Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.IOrdered.set_InternalOrdinal(long value);
    [CompilerGeneratedAttribute]
internal long get_EnterOrdinal();
    [CompilerGeneratedAttribute]
internal void set_EnterOrdinal(long value);
    [CompilerGeneratedAttribute]
internal long get_CallSiteOrdinal();
    [CompilerGeneratedAttribute]
internal void set_CallSiteOrdinal(long value);
    [CompilerGeneratedAttribute]
internal long get_LeaveOrdinal();
    [CompilerGeneratedAttribute]
internal void set_LeaveOrdinal(long value);
    [CompilerGeneratedAttribute]
internal long get_MethodEnterOffset();
    [CompilerGeneratedAttribute]
internal void set_MethodEnterOffset(long value);
    [CompilerGeneratedAttribute]
internal long get_MethodExitOffset();
    [CompilerGeneratedAttribute]
internal void set_MethodExitOffset(long value);
    [CompilerGeneratedAttribute]
internal long get_CallSiteOffset();
    [CompilerGeneratedAttribute]
internal void set_CallSiteOffset(long value);
    [CompilerGeneratedAttribute]
internal IList`1<DiagnosticEvent> get_DiagnosticEvents();
    [CompilerGeneratedAttribute]
private void set_DiagnosticEvents(IList`1<DiagnosticEvent> value);
    public virtual ParameterData get_ParameterData();
    public virtual TimingData get_TimingData();
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.CallStackFrameSerializer : object {
    private ParameterValueSerializer _parameterValueSerializer;
    private List`1<ExtendedBlobSerializer> _extendedSerializers;
    public CallStackFrameSerializer(GlobalTokenManager globalTokenManager, bool writeNestedFields);
    public CallStackFrameSerializer(GlobalTokenManager globalTokenManager, IEnumerable`1<ExtendedBlobSerializer> packers, bool writeNestedFields);
    public void AddExtendedBlobSerializer(ExtendedBlobSerializer serializer);
    public void RemoveExtendedBlobSerializer(ExtendedBlobSerializer serializer);
    public Byte[] GetStackFrameEnterBytes(CallStackFrame frame);
    public Byte[] GetStackFrameReturnBytes(CallStackFrame frame);
    private void RunExtendedSerializers(CallStackFrame frame, CorProfBlobPacker packer, IEnumerable`1<ExtendedSerialize> extendedSerializers);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.CallStackImpl : CallStack {
    private ObjectValidityState _objectState;
    private bool _isReadOnly;
    private List`1<CallStackFrameImpl> _callFrames;
    [CompilerGeneratedAttribute]
private Thread <Thread>k__BackingField;
    private List`1<CallStackFrameImpl> CallFrames { get; }
    public IEnumerable`1<CallStackFrame> Frames { get; protected set; }
    public bool IsReadOnly { get; }
    internal Thread Thread { get; internal set; }
    private List`1<CallStackFrameImpl> get_CallFrames();
    [ObsoleteAttribute("This method is Obsolete. Please use CallStackStateMachine.CurrentCallStack", "False")]
public virtual CallStackFrame CreateCallStackFrame(MetadataMethod method, int iloffset);
    public virtual IEnumerable`1<CallStackFrame> get_Frames();
    protected virtual void set_Frames(IEnumerable`1<CallStackFrame> value);
    public virtual bool get_IsReadOnly();
    internal void AddCallStackFrame(CallStackFrameImpl frame);
    internal void MakeReadOnly();
    [CompilerGeneratedAttribute]
internal Thread get_Thread();
    [CompilerGeneratedAttribute]
internal void set_Thread(Thread value);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.CallStackStateMachineEventArgs : ThreadEventArgs {
    [CompilerGeneratedAttribute]
private int <CurrentDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private ActionType <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private StateMachineCallStackFrame <Frame>k__BackingField;
    public int CurrentDepth { get; private set; }
    public ActionType Action { get; private set; }
    public StateMachineCallStackFrame Frame { get; private set; }
    public CallStackStateMachineEventArgs(Thread thread, StateMachineCallStackFrame frame, int currentDepth, ActionType action);
    [CompilerGeneratedAttribute]
public int get_CurrentDepth();
    [CompilerGeneratedAttribute]
private void set_CurrentDepth(int value);
    [CompilerGeneratedAttribute]
public ActionType get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(ActionType value);
    [CompilerGeneratedAttribute]
public StateMachineCallStackFrame get_Frame();
    [CompilerGeneratedAttribute]
private void set_Frame(StateMachineCallStackFrame value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.CallStackStateMachineImpl : CallStackStateMachine {
    [CompilerGeneratedAttribute]
private TreeNode <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeNode <CurrentNode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeNode <ForestRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private Thread <Thread>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreMissingTimingData>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    internal TreeNode Root { get; private set; }
    private TreeNode CurrentNode { get; private set; }
    internal int CurrentDepth { get; private set; }
    internal TreeNode ForestRoot { get; private set; }
    public Thread Thread { get; protected set; }
    public CallStackFrame Top { get; }
    public bool IgnoreMissingTimingData { get; protected set; }
    private IntelliTraceStoreImpl Store { get; private set; }
    internal bool IsCurrentStackEmpty { get; }
    internal CallStackStateMachineImpl(IntelliTraceStoreImpl store, Thread thread, bool ignoreMissingPerformanceData);
    [CompilerGeneratedAttribute]
internal TreeNode get_Root();
    [CompilerGeneratedAttribute]
private void set_Root(TreeNode value);
    [CompilerGeneratedAttribute]
private TreeNode get_CurrentNode();
    [CompilerGeneratedAttribute]
private void set_CurrentNode(TreeNode value);
    [CompilerGeneratedAttribute]
internal int get_CurrentDepth();
    [CompilerGeneratedAttribute]
private void set_CurrentDepth(int value);
    [CompilerGeneratedAttribute]
internal TreeNode get_ForestRoot();
    [CompilerGeneratedAttribute]
private void set_ForestRoot(TreeNode value);
    [CompilerGeneratedAttribute]
public virtual Thread get_Thread();
    [CompilerGeneratedAttribute]
protected virtual void set_Thread(Thread value);
    public virtual CallStackFrame Push(MetadataMethod method, int iLOffset);
    public virtual IEnumerable`1<CallStackFrame> Pop(int count);
    public virtual IEnumerable`1<CallStackFrame> PopAll();
    public virtual CallStackFrame get_Top();
    public virtual CallStack GetCurrentCallStack();
    [CompilerGeneratedAttribute]
public virtual bool get_IgnoreMissingTimingData();
    [CompilerGeneratedAttribute]
protected virtual void set_IgnoreMissingTimingData(bool value);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    internal void ValidateTimingData(TreeNode node);
    internal void AddDiagnosticEventRootNode(DiagnosticEvent diagnosticEvent);
    internal bool get_IsCurrentStackEmpty();
    internal void ClearForest();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.CallStackStateMachinesImpl : CallStackStateMachines {
    private List`1<CallStackStateMachineImpl> _stateMachines;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    public IEnumerable`1<CallStackStateMachine> StateMachines { get; protected set; }
    private IntelliTraceStoreImpl Store { get; private set; }
    internal CallStackStateMachinesImpl(IntelliTraceStoreImpl store);
    public virtual CallStackStateMachine CreateCallStackStateMachine(Thread thread, bool ignoreMissingTimingData);
    public virtual IEnumerable`1<CallStackStateMachine> get_StateMachines();
    protected virtual void set_StateMachines(IEnumerable`1<CallStackStateMachine> value);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    private void StoreFlushHandler();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.CollectionPlanSettings : object {
    public static UInt32 DefaultDiagnosticCheckpointRate;
    public static UInt32 DefaultThreadCheckpointRate;
    public static int DefaultWebRequestTruncationRate;
    public static int DefaultBlockSizeBytes;
    public static long DefaultMaxBlocks;
    [CompilerGeneratedAttribute]
private UInt32 <DiagnosticCheckpointRate>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ThreadCheckpointRate>k__BackingField;
    private int _webRequestTruncationRate;
    private long _maximumBlockCount;
    private int _blockSize;
    [CompilerGeneratedAttribute]
private bool <IsTimingDataAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtendedVersionInfo <ExtendedVersionInfo>k__BackingField;
    public UInt32 DiagnosticCheckpointRate { get; public set; }
    public UInt32 ThreadCheckpointRate { get; public set; }
    public int WebRequestTruncationRate { get; public set; }
    public long MaximumBlockCount { get; public set; }
    public int BlockSize { get; public set; }
    public bool IsTimingDataAvailable { get; public set; }
    internal ExtendedVersionInfo ExtendedVersionInfo { get; internal set; }
    [CompilerGeneratedAttribute]
public UInt32 get_DiagnosticCheckpointRate();
    [CompilerGeneratedAttribute]
public void set_DiagnosticCheckpointRate(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_ThreadCheckpointRate();
    [CompilerGeneratedAttribute]
public void set_ThreadCheckpointRate(UInt32 value);
    public int get_WebRequestTruncationRate();
    public void set_WebRequestTruncationRate(int value);
    public long get_MaximumBlockCount();
    public void set_MaximumBlockCount(long value);
    public int get_BlockSize();
    public void set_BlockSize(int value);
    [CompilerGeneratedAttribute]
public bool get_IsTimingDataAvailable();
    [CompilerGeneratedAttribute]
public void set_IsTimingDataAvailable(bool value);
    [CompilerGeneratedAttribute]
internal ExtendedVersionInfo get_ExtendedVersionInfo();
    [CompilerGeneratedAttribute]
internal void set_ExtendedVersionInfo(ExtendedVersionInfo value);
    public static CollectionPlanSettings CreateDefaultCollectionPlanSettings();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Configuration.CollectionConfigurationImpl : CollectionConfiguration {
    public static int MaxStringSize;
    private Dictionary`2<DiagnosticEventCategory, DiagnosticEventCategory> _categories;
    private Dictionary`2<DiagnosticEventSpecification, DiagnosticEventSpecification> _specifications;
    [CompilerGeneratedAttribute]
private string <DataProviderName>k__BackingField;
    private int _parameterVersion;
    private Dictionary`2<string, CategoryVersion> _categoryVersions;
    [CompilerGeneratedAttribute]
private bool <CollectionConfigurationChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    private DefaultDiagnosticEventCategories _defaultCategories;
    public IEnumerable`1<DiagnosticEventCategory> Categories { get; protected set; }
    public IEnumerable`1<DiagnosticEventSpecification> Specifications { get; protected set; }
    public string DataProviderName { get; private set; }
    public int ParameterVersion { get; public set; }
    public IEnumerable`1<CategoryVersion> CategoryVersions { get; }
    public bool CollectionConfigurationChanged { get; private set; }
    private IntelliTraceStoreImpl Store { get; private set; }
    public DefaultDiagnosticEventCategories DefaultCategories { get; }
    public CollectionConfigurationImpl(IntelliTraceStoreImpl store, string dataProviderName);
    public virtual IEnumerable`1<DiagnosticEventCategory> get_Categories();
    protected virtual void set_Categories(IEnumerable`1<DiagnosticEventCategory> value);
    public virtual IEnumerable`1<DiagnosticEventSpecification> get_Specifications();
    protected virtual void set_Specifications(IEnumerable`1<DiagnosticEventSpecification> value);
    [CompilerGeneratedAttribute]
public string get_DataProviderName();
    [CompilerGeneratedAttribute]
private void set_DataProviderName(string value);
    public int get_ParameterVersion();
    public void set_ParameterVersion(int value);
    public virtual IEnumerable`1<CategoryVersion> get_CategoryVersions();
    [CompilerGeneratedAttribute]
public bool get_CollectionConfigurationChanged();
    [CompilerGeneratedAttribute]
private void set_CollectionConfigurationChanged(bool value);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    public virtual DefaultDiagnosticEventCategories get_DefaultCategories();
    public virtual DiagnosticEventCategory CreateDiagnosticEventCategory(string name, string id);
    public virtual DataQueryEventSpecification CreateDataQueryEventSpecification(DiagnosticEventCategory category, MetadataMethod binding);
    public virtual DataQueryEventSpecification CreateDataQueryEventSpecification(DiagnosticEventCategory category, MetadataMethod binding, string shortDescription);
    public virtual DataQueryEventSpecification CreateDataQueryEventSpecification(DiagnosticEventCategory category, MetadataMethod binding, string shortDescription, string longDescription);
    public virtual DataQueryEventSpecification CreateDataQueryEventSpecification(DiagnosticEventCategory category, MetadataMethod binding, string shortDescription, string longDescription, IEnumerable`1<DataQuerySpecification> queries);
    public virtual DataQuerySpecification CreateDataQuerySpecification(string name, MetadataType type);
    public virtual CategoryVersion CreateCategoryVersion(string category, Version version);
    private void HandleStoreFlush();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Configuration.DataQueryEventSpecificationImpl : DataQueryEventSpecification {
    [CompilerGeneratedAttribute]
private DiagnosticEventCategory <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LongDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataMethod <Binding>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DataQuerySpecification> <Queries>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BindingId>k__BackingField;
    private Nullable`1<int> _hashCode;
    public DiagnosticEventCategory Category { get; protected set; }
    public string ShortDescription { get; protected set; }
    public string LongDescription { get; protected set; }
    public MetadataMethod Binding { get; protected set; }
    public IEnumerable`1<DataQuerySpecification> Queries { get; protected set; }
    internal int BindingId { get; internal set; }
    public DataQueryEventSpecificationImpl(DiagnosticEventCategory category, MetadataMethod binding, string shortDescription, string longDescription, IEnumerable`1<DataQuerySpecification> queries);
    [CompilerGeneratedAttribute]
public virtual DiagnosticEventCategory get_Category();
    [CompilerGeneratedAttribute]
protected virtual void set_Category(DiagnosticEventCategory value);
    [CompilerGeneratedAttribute]
public virtual string get_ShortDescription();
    [CompilerGeneratedAttribute]
protected virtual void set_ShortDescription(string value);
    [CompilerGeneratedAttribute]
public virtual string get_LongDescription();
    [CompilerGeneratedAttribute]
protected virtual void set_LongDescription(string value);
    [CompilerGeneratedAttribute]
public virtual MetadataMethod get_Binding();
    [CompilerGeneratedAttribute]
protected virtual void set_Binding(MetadataMethod value);
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<DataQuerySpecification> get_Queries();
    [CompilerGeneratedAttribute]
protected virtual void set_Queries(IEnumerable`1<DataQuerySpecification> value);
    [CompilerGeneratedAttribute]
internal int get_BindingId();
    [CompilerGeneratedAttribute]
internal void set_BindingId(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Configuration.DataQuerySpecificationImpl : DataQuerySpecification {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataType <Type>k__BackingField;
    public string Name { get; protected set; }
    public MetadataType Type { get; protected set; }
    public DataQuerySpecificationImpl(string name, MetadataType type);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
protected virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual MetadataType get_Type();
    [CompilerGeneratedAttribute]
protected virtual void set_Type(MetadataType value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Configuration.DefaultCategoriesImpl : DefaultDiagnosticEventCategories {
    [CompilerGeneratedAttribute]
private IntelliTraceStore <Store>k__BackingField;
    private IntelliTraceStore Store { get; private set; }
    public DiagnosticEventCategory AdoNet { get; }
    public DiagnosticEventCategory AspNet { get; }
    public DiagnosticEventCategory Console { get; }
    public DiagnosticEventCategory DataBinding { get; }
    public DiagnosticEventCategory EnvironmentVariables { get; }
    public DiagnosticEventCategory File { get; }
    public DiagnosticEventCategory Gesture { get; }
    public DiagnosticEventCategory LazyInitialization { get; }
    public DiagnosticEventCategory Registry { get; }
    public DiagnosticEventCategory ServiceModel { get; }
    public DiagnosticEventCategory Threading { get; }
    public DiagnosticEventCategory Tracing { get; }
    public DiagnosticEventCategory UserPrompt { get; }
    public DiagnosticEventCategory Workflow { get; }
    public DiagnosticEventCategory Xml { get; }
    public DiagnosticEventCategory Performance { get; }
    public DefaultCategoriesImpl(IntelliTraceStore store);
    [CompilerGeneratedAttribute]
private IntelliTraceStore get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStore value);
    public virtual DiagnosticEventCategory get_AdoNet();
    public virtual DiagnosticEventCategory get_AspNet();
    public virtual DiagnosticEventCategory get_Console();
    public virtual DiagnosticEventCategory get_DataBinding();
    public virtual DiagnosticEventCategory get_EnvironmentVariables();
    public virtual DiagnosticEventCategory get_File();
    public virtual DiagnosticEventCategory get_Gesture();
    public virtual DiagnosticEventCategory get_LazyInitialization();
    public virtual DiagnosticEventCategory get_Registry();
    public virtual DiagnosticEventCategory get_ServiceModel();
    public virtual DiagnosticEventCategory get_Threading();
    public virtual DiagnosticEventCategory get_Tracing();
    public virtual DiagnosticEventCategory get_UserPrompt();
    public virtual DiagnosticEventCategory get_Workflow();
    public virtual DiagnosticEventCategory get_Xml();
    public virtual DiagnosticEventCategory get_Performance();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Configuration.DiagnosticEventCategoryImpl : DiagnosticEventCategory {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private Nullable`1<int> _hashCode;
    public string Id { get; protected set; }
    public string Name { get; protected set; }
    public DiagnosticEventCategoryImpl(string id, string name);
    [CompilerGeneratedAttribute]
public virtual string get_Id();
    [CompilerGeneratedAttribute]
protected virtual void set_Id(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
protected virtual void set_Name(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Data.ArrayDataImpl : ArrayData {
    private ObjectValidityState _objectState;
    private MetadataType _typeSpec;
    private MetadataType _dataType;
    private Array _elements;
    private int _totalCount;
    public MetadataType TypeSpec { get; protected set; }
    public MetadataType DataType { get; protected set; }
    public Array Elements { get; protected set; }
    public int TotalCount { get; protected set; }
    internal ArrayDataImpl(MetadataType typeSpec, Array elements, int totalCount);
    public virtual MetadataType get_TypeSpec();
    protected virtual void set_TypeSpec(MetadataType value);
    public virtual MetadataType get_DataType();
    protected virtual void set_DataType(MetadataType value);
    public virtual Array get_Elements();
    protected virtual void set_Elements(Array value);
    public virtual int get_TotalCount();
    protected virtual void set_TotalCount(int value);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Data.ClassDataImpl : ClassData {
    internal static string NullableTypeFieldNameHasValue;
    internal static string NullableTypeFieldNameValue;
    private ObjectValidityState _objectState;
    private Dictionary`2<MetadataMember, ObjectData> _memberData;
    private MetadataType _dataType;
    private Dictionary`2<MetadataMember, ObjectData> MemberData { get; }
    public MetadataType DataType { get; protected set; }
    internal ClassDataImpl(MetadataType dataType);
    private Dictionary`2<MetadataMember, ObjectData> get_MemberData();
    public virtual MetadataType get_DataType();
    protected virtual void set_DataType(MetadataType value);
    public virtual void SetValue(MetadataMember member, ObjectData value);
    public virtual ObjectData GetValue(MetadataMember member);
    internal void ThrowIfNullableValueNotSupported(ObjectData valueField);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Data.CycleDataImpl : CycleData {
    private ObjectValidityState _objectState;
    private MetadataType _dataType;
    private ObjectData _reference;
    public MetadataType DataType { get; protected set; }
    public ObjectData Reference { get; protected set; }
    public CycleDataImpl(MetadataType type, ObjectData reference);
    public virtual MetadataType get_DataType();
    protected virtual void set_DataType(MetadataType value);
    public virtual ObjectData get_Reference();
    protected virtual void set_Reference(ObjectData value);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Data.NullDataImpl : NullData {
    private ObjectValidityState _objectState;
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Data.PrimitiveDataImpl : PrimitiveData {
    private ObjectValidityState _objectState;
    private MetadataType _dataType;
    private object _value;
    public MetadataType DataType { get; protected set; }
    public object Value { get; protected set; }
    internal PrimitiveDataImpl(MetadataType dataType, object value);
    public virtual MetadataType get_DataType();
    protected virtual void set_DataType(MetadataType value);
    public virtual object get_Value();
    protected virtual void set_Value(object value);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.DiagnosticEventEventArgs : ThreadEventArgs {
    [CompilerGeneratedAttribute]
private DiagnosticEvent <DiagnosticEvent>k__BackingField;
    public DiagnosticEvent DiagnosticEvent { get; private set; }
    public DiagnosticEventEventArgs(Thread thread, DiagnosticEvent diagnosticEvent);
    [CompilerGeneratedAttribute]
public DiagnosticEvent get_DiagnosticEvent();
    [CompilerGeneratedAttribute]
private void set_DiagnosticEvent(DiagnosticEvent value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.ClassicDataQueryEventImpl : ClassicDataQueryEvent {
    private ObjectValidityState _objectState;
    [CompilerGeneratedAttribute]
private long <InternalOrdinal>k__BackingField;
    private DateTime _eventTime;
    private CallStack _stack;
    private Thread _thread;
    private DataQueryEventSpecification _eventSpecification;
    private string _eventName;
    private IEnumerable`1<PrimitiveData> _payload;
    private long _streamOffset;
    public long InternalOrdinal { get; public set; }
    public DateTime EventTime { get; protected set; }
    public CallStack Stack { get; protected set; }
    public Thread Thread { get; protected set; }
    public DataQueryEventSpecification EventSpecification { get; protected set; }
    public string EventName { get; protected set; }
    public IEnumerable`1<PrimitiveData> Payload { get; protected set; }
    public long StreamOffset { get; public set; }
    public ClassicDataQueryEventImpl(DateTime eventTime, Thread thread, DataQueryEventSpecification spec, CallStack callStack, IEnumerable`1<PrimitiveData> payload);
    [CompilerGeneratedAttribute]
public sealed virtual long get_InternalOrdinal();
    [CompilerGeneratedAttribute]
public sealed virtual void set_InternalOrdinal(long value);
    public virtual DateTime get_EventTime();
    protected virtual void set_EventTime(DateTime value);
    public virtual CallStack get_Stack();
    protected virtual void set_Stack(CallStack value);
    public virtual Thread get_Thread();
    protected virtual void set_Thread(Thread value);
    public virtual DataQueryEventSpecification get_EventSpecification();
    protected virtual void set_EventSpecification(DataQueryEventSpecification value);
    public virtual string get_EventName();
    protected virtual void set_EventName(string value);
    public virtual IEnumerable`1<PrimitiveData> get_Payload();
    protected virtual void set_Payload(IEnumerable`1<PrimitiveData> value);
    public sealed virtual long get_StreamOffset();
    public sealed virtual void set_StreamOffset(long value);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.DiagnosticEventsImpl : DiagnosticEvents {
    private List`1<DiagnosticEvent> _diagnosticEvents;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    private TimingDataQueries _timingDataQueries;
    public IEnumerable`1<DiagnosticEvent> Events { get; protected set; }
    private IntelliTraceStoreImpl Store { get; private set; }
    private TimingDataQueries TimingDataQueries { get; }
    internal DiagnosticEventsImpl(IntelliTraceStoreImpl store);
    public virtual ExceptionEvent CreateException(DateTime eventTime, Thread thread);
    public virtual ExceptionEvent CreateException(DateTime eventTime, Thread thread, string exceptionMessage);
    public virtual ExceptionEvent CreateException(DateTime eventTime, Thread thread, string exceptionMessage, string exceptionType);
    public virtual ExceptionEvent CreateException(DateTime eventTime, Thread thread, string exceptionMessage, string exceptionType, CallStack callStack);
    public virtual ClassicDataQueryEvent CreateClassicDataQuery(DateTime eventTime, Thread thread, DataQueryEventSpecification specification, CallStack callStack);
    public virtual ClassicDataQueryEvent CreateClassicDataQuery(DateTime eventTime, Thread thread, DataQueryEventSpecification specification, CallStack callStack, IEnumerable`1<PrimitiveData> payload);
    public virtual ClassicDataQueryEvent CreateDefaultTimingDataQuery(DateTime eventTime, Thread thread, CallStack callStack);
    public virtual ClassicDataQueryEvent CreateCustomTimingDataQuery(DateTime eventTime, Thread thread, CallStack callStack, DiagnosticEventCategory category, string description);
    public virtual ClassicDataQueryEvent CreateCustomTimingDataQuery(DateTime eventTime, Thread thread, CallStack callStack, DiagnosticEventCategory category, string shortDescription, string longDescription, IEnumerable`1<KeyValuePair`2<string, PrimitiveData>> payload);
    private DiagnosticEvent CreateDiagnosticEvent(Thread thread, CallStack callStack, Func`1<DiagnosticEvent> constructor, Action`1<DiagnosticEvent> updateOrdinals);
    public virtual IEnumerable`1<DiagnosticEvent> get_Events();
    protected virtual void set_Events(IEnumerable`1<DiagnosticEvent> value);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    private TimingDataQueries get_TimingDataQueries();
    private void StoreFlushHandler();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.ExceptionEventImpl : ExceptionEvent {
    private ObjectValidityState _objectState;
    private DateTime _eventTime;
    private Thread _thread;
    private CallStack _stack;
    private string _exceptionMessage;
    private string _exceptionType;
    private bool _isExceptionCritical;
    [CompilerGeneratedAttribute]
private long <InternalOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ThrowOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CatchOrdinal>k__BackingField;
    private long _streamOffset;
    public DateTime EventTime { get; protected set; }
    public Thread Thread { get; protected set; }
    public CallStack Stack { get; protected set; }
    public string ExceptionMessage { get; public set; }
    public string ExceptionType { get; public set; }
    public bool IsCritical { get; public set; }
    public long InternalOrdinal { get; public set; }
    internal long ThrowOrdinal { get; internal set; }
    internal long CatchOrdinal { get; internal set; }
    public long StreamOffset { get; public set; }
    internal ExceptionEventImpl(DateTime eventTime, Thread thread, CallStack callStack);
    public virtual DateTime get_EventTime();
    protected virtual void set_EventTime(DateTime value);
    public virtual Thread get_Thread();
    protected virtual void set_Thread(Thread value);
    public virtual CallStack get_Stack();
    protected virtual void set_Stack(CallStack value);
    public virtual string get_ExceptionMessage();
    public virtual void set_ExceptionMessage(string value);
    public virtual string get_ExceptionType();
    public virtual void set_ExceptionType(string value);
    public virtual bool get_IsCritical();
    public virtual void set_IsCritical(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_InternalOrdinal();
    [CompilerGeneratedAttribute]
public sealed virtual void set_InternalOrdinal(long value);
    [CompilerGeneratedAttribute]
internal long get_ThrowOrdinal();
    [CompilerGeneratedAttribute]
internal void set_ThrowOrdinal(long value);
    [CompilerGeneratedAttribute]
internal long get_CatchOrdinal();
    [CompilerGeneratedAttribute]
internal void set_CatchOrdinal(long value);
    public sealed virtual long get_StreamOffset();
    public sealed virtual void set_StreamOffset(long value);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal interface Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.IScopedThreadEvent {
    public IEnumerable`1<ScopedEventDataSection> DataSections { get; }
    public DateTime StartTime { get; }
    public DateTime EndTime { get; }
    public ScopedDataEventKind EventKind { get; }
    public abstract virtual IEnumerable`1<ScopedEventDataSection> get_DataSections();
    public abstract virtual DateTime get_StartTime();
    public abstract virtual DateTime get_EndTime();
    public abstract virtual ScopedDataEventKind get_EventKind();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.Performance.BusinessContextImpl : BusinessContext {
    private ObjectValidityState _objectState;
    [CompilerGeneratedAttribute]
private ScopedEventDataSectionImpl <DataSection>k__BackingField;
    private ScopedEventDataSectionImpl DataSection { get; private set; }
    public string ObjectUri { get; public set; }
    public string UserHostAddress { get; public set; }
    public BusinessContextImpl(ScopedEventDataSectionImpl dataSection);
    [CompilerGeneratedAttribute]
private ScopedEventDataSectionImpl get_DataSection();
    [CompilerGeneratedAttribute]
private void set_DataSection(ScopedEventDataSectionImpl value);
    public virtual string get_ObjectUri();
    public virtual void set_ObjectUri(string value);
    public virtual string get_UserHostAddress();
    public virtual void set_UserHostAddress(string value);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.Performance.CollectionNotesImpl : CollectionNotes {
    private ObjectValidityState _objectState;
    [CompilerGeneratedAttribute]
private ScopedEventDataSectionImpl <DataSection>k__BackingField;
    private ScopedEventDataSectionImpl DataSection { get; private set; }
    public string ApplicationPath { get; public set; }
    public string ApplicationEnvironment { get; public set; }
    public int AlertThreshold { get; public set; }
    public string Component { get; public set; }
    public bool IsLightEvent { get; public set; }
    public string Build { get; public set; }
    public CollectionNotesImpl(ScopedEventDataSectionImpl dataSection);
    [CompilerGeneratedAttribute]
private ScopedEventDataSectionImpl get_DataSection();
    [CompilerGeneratedAttribute]
private void set_DataSection(ScopedEventDataSectionImpl value);
    public virtual string get_ApplicationPath();
    public virtual void set_ApplicationPath(string value);
    public virtual string get_ApplicationEnvironment();
    public virtual void set_ApplicationEnvironment(string value);
    public virtual int get_AlertThreshold();
    public virtual void set_AlertThreshold(int value);
    public virtual string get_Component();
    public virtual void set_Component(string value);
    public virtual bool get_IsLightEvent();
    public virtual void set_IsLightEvent(bool value);
    public virtual string get_Build();
    public virtual void set_Build(string value);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.Performance.ScopedPerformanceEventImpl : ScopedPerformanceEvent {
    private ObjectValidityState _objectState;
    [CompilerGeneratedAttribute]
private ScopedThreadEventImpl <ProxyEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadAssociationCollection <ThreadAssociationCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private StateMachineCallStackFrame <FirstFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private StateMachineCallStackFrame <LastFrame>k__BackingField;
    private int _callStackFrames;
    private bool _hasPreviousScope;
    private BusinessContextImpl _businessContext;
    private CollectionNotesImpl _collectionNotes;
    private ScopedThreadEventImpl ProxyEvent { get; private set; }
    private ThreadAssociationCollection ThreadAssociationCollection { get; private set; }
    private StateMachineCallStackFrame FirstFrame { get; private set; }
    private StateMachineCallStackFrame LastFrame { get; private set; }
    internal Dictionary`2<string, ScopedEventDataSection> InternalDataSections { get; }
    internal OrderScopeImpl OrderScope { get; }
    public ScopedDataEventKind EventKind { get; }
    public long StartOrdinal { get; public set; }
    public long EndOrdinal { get; public set; }
    public IEnumerable`1<ThreadAssociation> ThreadAssociations { get; }
    public BusinessContext BusinessContext { get; }
    public CollectionNotes CollectionNotes { get; }
    public IEnumerable`1<ScopedEventDataSection> DataSections { get; }
    public DateTime StartTime { get; }
    public DateTime EndTime { get; public set; }
    public Thread Thread { get; }
    public ScopedPerformanceEventImpl(DateTime eventTime, DateTime endTime, IntelliTraceStoreImpl store, Thread thread);
    [CompilerGeneratedAttribute]
private ScopedThreadEventImpl get_ProxyEvent();
    [CompilerGeneratedAttribute]
private void set_ProxyEvent(ScopedThreadEventImpl value);
    [CompilerGeneratedAttribute]
private ThreadAssociationCollection get_ThreadAssociationCollection();
    [CompilerGeneratedAttribute]
private void set_ThreadAssociationCollection(ThreadAssociationCollection value);
    [CompilerGeneratedAttribute]
private StateMachineCallStackFrame get_FirstFrame();
    [CompilerGeneratedAttribute]
private void set_FirstFrame(StateMachineCallStackFrame value);
    [CompilerGeneratedAttribute]
private StateMachineCallStackFrame get_LastFrame();
    [CompilerGeneratedAttribute]
private void set_LastFrame(StateMachineCallStackFrame value);
    internal Dictionary`2<string, ScopedEventDataSection> get_InternalDataSections();
    internal OrderScopeImpl get_OrderScope();
    internal CallStackFrameImpl GetRootFrame();
    internal CallStackFrameImpl GetHeaviestFrame();
    public sealed virtual ScopedDataEventKind get_EventKind();
    public sealed virtual long get_StartOrdinal();
    public void set_StartOrdinal(long value);
    public sealed virtual long get_EndOrdinal();
    public void set_EndOrdinal(long value);
    public sealed virtual IEnumerable`1<ThreadAssociation> get_ThreadAssociations();
    public virtual BusinessContext get_BusinessContext();
    public virtual CollectionNotes get_CollectionNotes();
    public virtual IEnumerable`1<ScopedEventDataSection> get_DataSections();
    public virtual DateTime get_StartTime();
    public virtual DateTime get_EndTime();
    public virtual void set_EndTime(DateTime value);
    public virtual Thread get_Thread();
    public virtual ScopedEventDataSection CreateDataSection(string sectionName);
    public virtual OrderScope OpenScope();
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
    private void HandleCloseScope(object sender, EventArgs e);
    private void HandleEventOccurring(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
private bool <GetHeaviestFrame>b__25_0(StateMachineCallStackFrame frame);
}
internal static class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.Performance.WellKnownScopedCategories : object {
    public static string BusinessContext;
    public static string CollectionNotes;
}
internal static class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.Performance.WellKnownScopedKeys : object {
    public static string BusinessContext_ObjectURI;
    public static string BusinessContext_UserHostAddress;
    public static string CollectionNotes_ApplicationPath;
    public static string CollectionNotes_AlertThreshold;
    public static string CollectionNotes_Component;
    public static string CollectionNotes_Build;
    public static string CollectionNotes_ApplicationEnvironment;
    public static string CollectionNotes_IsLightEvent;
}
internal enum Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.ScopedDataEventKind : Enum {
    public short value__;
    public static ScopedDataEventKind Unknown;
    public static ScopedDataEventKind Performance;
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.ScopedEventDataSectionImpl : ScopedEventDataSection {
    private ObjectValidityState _objectState;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    private string _sectionName;
    private Dictionary`2<string, PrimitiveData> _data;
    private IntelliTraceStoreImpl Store { get; private set; }
    public string SectionName { get; }
    public IDictionary`2<string, PrimitiveData> Data { get; }
    public ScopedEventDataSectionImpl(string sectionName, IntelliTraceStoreImpl store);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    public virtual string get_SectionName();
    public virtual IDictionary`2<string, PrimitiveData> get_Data();
    public void SetData(string key, T value);
    public T GetData(string key);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.ScopedEventsImpl : ScopedEvents {
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ScopedEvent> <Events>k__BackingField;
    private IntelliTraceStoreImpl Store { get; private set; }
    internal IList`1<ScopedEvent> InternalEvents { get; }
    public IEnumerable`1<ScopedEvent> Events { get; protected set; }
    public ScopedEventsImpl(IntelliTraceStoreImpl store);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    internal IList`1<ScopedEvent> get_InternalEvents();
    public virtual ScopedPerformanceEvent CreateScopedPerformanceEvent(Thread thread, DateTime startTime);
    public virtual ScopedPerformanceEvent CreateScopedPerformanceEvent(Thread thread, DateTime startTime, DateTime endTime);
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<ScopedEvent> get_Events();
    [CompilerGeneratedAttribute]
protected virtual void set_Events(IEnumerable`1<ScopedEvent> value);
    private void StoreFlushHandler();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.ScopedThreadEventImpl : ScopedThreadEvent {
    private ObjectValidityState _objectState;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderScopeImpl <OrderScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ScopedEventDataSection> <InternalDataSections>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadAssociationCollection <ThreadAssociationCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopedDataEventKind <EventKind>k__BackingField;
    private DateTime _startTime;
    private DateTime _endTime;
    private ThreadImpl _thread;
    private IntelliTraceStoreImpl Store { get; private set; }
    public OrderScopeImpl OrderScope { get; private set; }
    public Dictionary`2<string, ScopedEventDataSection> InternalDataSections { get; private set; }
    public long StartOrdinal { get; public set; }
    public long EndOrdinal { get; public set; }
    private ThreadAssociationCollection ThreadAssociationCollection { get; private set; }
    public IEnumerable`1<ThreadAssociation> ThreadAssociations { get; }
    public ScopedDataEventKind EventKind { get; private set; }
    public DateTime StartTime { get; }
    public DateTime EndTime { get; public set; }
    public Thread Thread { get; }
    public IEnumerable`1<ScopedEventDataSection> DataSections { get; }
    public ScopedThreadEventImpl(ThreadImpl thread, DateTime startTime, DateTime endTime, ScopedDataEventKind eventKind, IntelliTraceStoreImpl store);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    [CompilerGeneratedAttribute]
public OrderScopeImpl get_OrderScope();
    [CompilerGeneratedAttribute]
private void set_OrderScope(OrderScopeImpl value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ScopedEventDataSection> get_InternalDataSections();
    [CompilerGeneratedAttribute]
private void set_InternalDataSections(Dictionary`2<string, ScopedEventDataSection> value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_StartOrdinal();
    [CompilerGeneratedAttribute]
public void set_StartOrdinal(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_EndOrdinal();
    [CompilerGeneratedAttribute]
public void set_EndOrdinal(long value);
    [CompilerGeneratedAttribute]
private ThreadAssociationCollection get_ThreadAssociationCollection();
    [CompilerGeneratedAttribute]
private void set_ThreadAssociationCollection(ThreadAssociationCollection value);
    public sealed virtual IEnumerable`1<ThreadAssociation> get_ThreadAssociations();
    [CompilerGeneratedAttribute]
public sealed virtual ScopedDataEventKind get_EventKind();
    [CompilerGeneratedAttribute]
private void set_EventKind(ScopedDataEventKind value);
    public virtual DateTime get_StartTime();
    public virtual DateTime get_EndTime();
    public virtual void set_EndTime(DateTime value);
    public virtual Thread get_Thread();
    public virtual IEnumerable`1<ScopedEventDataSection> get_DataSections();
    public virtual ScopedEventDataSection CreateDataSection(string sectionName);
    public virtual OrderScope OpenScope();
    private void ScopeSuspendHandler(object sender, EventArgs e);
    private void ScopeResumeHandler(object sender, EventArgs e);
    private void ScopeCloseHandler(object sender, EventArgs e);
    private void EventOccurringHandler(object sender, EventArgs args);
    private static void ValidateEventTime(IntelliTraceStoreImpl store, DateTime startTime, DateTime endTime);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.ThreadAssociation : object {
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private long <End>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    public long Start { get; public set; }
    public long End { get; public set; }
    public int ThreadId { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(long value);
    [CompilerGeneratedAttribute]
public long get_End();
    [CompilerGeneratedAttribute]
public void set_End(long value);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
public void set_ThreadId(int value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.ThreadAssociationCollection : object {
    [CompilerGeneratedAttribute]
private ThreadAssociation <CurrentAssociation>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ThreadAssociation> <ThreadAssociations>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    public ThreadAssociation CurrentAssociation { get; private set; }
    public IList`1<ThreadAssociation> ThreadAssociations { get; private set; }
    private IntelliTraceStoreImpl Store { get; private set; }
    public ThreadAssociationCollection(IntelliTraceStoreImpl store);
    [CompilerGeneratedAttribute]
public ThreadAssociation get_CurrentAssociation();
    [CompilerGeneratedAttribute]
private void set_CurrentAssociation(ThreadAssociation value);
    [CompilerGeneratedAttribute]
public IList`1<ThreadAssociation> get_ThreadAssociations();
    [CompilerGeneratedAttribute]
private void set_ThreadAssociations(IList`1<ThreadAssociation> value);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    public void OpenThreadAssociation(int threadId);
    public void CloseCurrentAssociation();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.TimingDataQueries : object {
    private static string _instrumentationTypeName;
    private static string _performanceAlertMethodName;
    private Regex ReparameterizeRegex;
    private static int DefaultPayloadSize;
    private static string MethodNameParameter;
    private static string MethodEnterParameter;
    private static string MethodExitParameter;
    private static string MethodExecutionParameter;
    private static string MethodNameIndexer;
    private static string MethodExecutionIndexer;
    private static string MethodEnterIndexer;
    private static string MethodExitIndexer;
    [CompilerGeneratedAttribute]
private IntelliTraceStore <Store>k__BackingField;
    private MetadataType _systemString;
    private MetadataMethod _bindingMethod;
    private IEnumerable`1<DataQuerySpecification> _defaultTimingDataQueries;
    private DataQueryEventSpecification _defaultEventSpecification;
    private IntelliTraceStore Store { get; private set; }
    public MetadataType SystemString { get; }
    private MetadataMethod BindingMethod { get; }
    private IEnumerable`1<DataQuerySpecification> DefaultTimingDataQueries { get; }
    public DataQueryEventSpecification DefaultTimingEventSpecification { get; }
    public string DefaultShortDescription { get; }
    public string DefaultLongDescription { get; }
    public static string DescriptionName { get; }
    public TimingDataQueries(IntelliTraceStore store);
    [CompilerGeneratedAttribute]
private IntelliTraceStore get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStore value);
    public MetadataType get_SystemString();
    private MetadataMethod get_BindingMethod();
    private IEnumerable`1<DataQuerySpecification> get_DefaultTimingDataQueries();
    public DataQueryEventSpecification get_DefaultTimingEventSpecification();
    public string get_DefaultShortDescription();
    public string get_DefaultLongDescription();
    public static string get_DescriptionName();
    public IEnumerable`1<PrimitiveData> CreatePayload(CallStack callStack);
    public DataQueryEventSpecification CreateCustomSpecification(DiagnosticEventCategory category, string shortDescription, string longDescription, IEnumerable`1<KeyValuePair`2<string, PrimitiveData>> payload);
    public IEnumerable`1<PrimitiveData> CreateCustomPayload(CallStack stack, IEnumerable`1<PrimitiveData> payload);
    internal string ReparameterizeString(string s, int payloadSize);
    private static string ParameterReplacer(Match m, int parameterCount);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.WebRequestEventImpl : WebRequestEvent {
    private ObjectValidityState _objectState;
    [CompilerGeneratedAttribute]
private OrderScopeImpl <OrderScope>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadAssociationCollection <ThreadAssociationCollection>k__BackingField;
    private DateTime _startTime;
    private DateTime _endTime;
    private string _url;
    private string _userAgent;
    private string _ip;
    private string _httpMethod;
    private int _requestStatus;
    private int _requestSubStatus;
    private string _queryString;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOrdinal>k__BackingField;
    internal OrderScopeImpl OrderScope { get; private set; }
    private ThreadAssociationCollection ThreadAssociationCollection { get; private set; }
    public DateTime StartTime { get; protected set; }
    public DateTime EndTime { get; protected set; }
    public string Url { get; protected set; }
    public string UserAgent { get; protected set; }
    public string IP { get; protected set; }
    public string HttpMethod { get; protected set; }
    public int RequestStatus { get; protected set; }
    public int RequestSubStatus { get; protected set; }
    public string QueryString { get; protected set; }
    private IntelliTraceStoreImpl Store { get; private set; }
    public long StartOrdinal { get; public set; }
    public long EndOrdinal { get; public set; }
    public IEnumerable`1<ThreadAssociation> ThreadAssociations { get; }
    internal WebRequestEventImpl(DateTime startTime, DateTime endTime, string httpMethod, string url, string ip, string userAgent, int status, int subStatus, string queryString, IntelliTraceStoreImpl store);
    [CompilerGeneratedAttribute]
internal OrderScopeImpl get_OrderScope();
    [CompilerGeneratedAttribute]
private void set_OrderScope(OrderScopeImpl value);
    [CompilerGeneratedAttribute]
private ThreadAssociationCollection get_ThreadAssociationCollection();
    [CompilerGeneratedAttribute]
private void set_ThreadAssociationCollection(ThreadAssociationCollection value);
    public virtual DateTime get_StartTime();
    protected virtual void set_StartTime(DateTime value);
    public virtual DateTime get_EndTime();
    protected virtual void set_EndTime(DateTime value);
    public virtual string get_Url();
    protected virtual void set_Url(string value);
    public virtual string get_UserAgent();
    protected virtual void set_UserAgent(string value);
    public virtual string get_IP();
    protected virtual void set_IP(string value);
    public virtual string get_HttpMethod();
    protected virtual void set_HttpMethod(string value);
    public virtual int get_RequestStatus();
    protected virtual void set_RequestStatus(int value);
    public virtual int get_RequestSubStatus();
    protected virtual void set_RequestSubStatus(int value);
    public virtual string get_QueryString();
    protected virtual void set_QueryString(string value);
    public virtual OrderScope OpenScope();
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    private void ScopeSuspendHandler(object sender, EventArgs e);
    private void ScopeCloseHandler(object sender, EventArgs e);
    private void EventOccurringHandler(object sender, EventArgs args);
    [CompilerGeneratedAttribute]
public sealed virtual long get_StartOrdinal();
    [CompilerGeneratedAttribute]
public void set_StartOrdinal(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_EndOrdinal();
    [CompilerGeneratedAttribute]
public void set_EndOrdinal(long value);
    public sealed virtual IEnumerable`1<ThreadAssociation> get_ThreadAssociations();
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Events.WebRequestEventsImpl : WebRequestEvents {
    private List`1<WebRequestEventImpl> _events;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    public IEnumerable`1<WebRequestEvent> Events { get; protected set; }
    private IntelliTraceStoreImpl Store { get; private set; }
    internal WebRequestEventsImpl(IntelliTraceStoreImpl store);
    public virtual WebRequestEvent CreateWebRequestEvent(DateTime startTime, DateTime endTime, string httpMethod, string url, string ip, string userAgent, int status, int subStatus, string queryString);
    public virtual IEnumerable`1<WebRequestEvent> get_Events();
    protected virtual void set_Events(IEnumerable`1<WebRequestEvent> value);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    private void StoreFlushHandler();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ExtendedBlobSerializer : object {
    [CompilerGeneratedAttribute]
private ExtendedSerialize <PackExtendedEnter>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtendedSerialize <PackExtendedReturn>k__BackingField;
    public ExtendedSerialize PackExtendedEnter { get; public set; }
    public ExtendedSerialize PackExtendedReturn { get; public set; }
    [CompilerGeneratedAttribute]
public ExtendedSerialize get_PackExtendedEnter();
    [CompilerGeneratedAttribute]
public void set_PackExtendedEnter(ExtendedSerialize value);
    [CompilerGeneratedAttribute]
public ExtendedSerialize get_PackExtendedReturn();
    [CompilerGeneratedAttribute]
public void set_PackExtendedReturn(ExtendedSerialize value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ExtendedSerialize : MulticastDelegate {
    public ExtendedSerialize(object object, IntPtr method);
    public virtual void Invoke(CallStackFrame frame, CorProfBlobPacker packer);
    public virtual IAsyncResult BeginInvoke(CallStackFrame frame, CorProfBlobPacker packer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.GlobalTokenManager : object {
    private int _intelliTraceToken;
    private Dictionary`2<TokenKey, int> _tokenMap;
    internal IDictionary`2<TokenKey, int> TokenMap { get; }
    internal IDictionary`2<TokenKey, int> get_TokenMap();
    internal int GetIntelliTraceToken(MetadataType type);
    internal int GetIntelliTraceToken(MetadataMethod method);
    private int GetIntelliTraceToken(Guid mvid, int originalToken);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.IntelliTraceFileSerializerImpl : IntelliTraceFileSerializer {
    [CompilerGeneratedAttribute]
private CollectionPlanSettings <CollectionPlanSettings>k__BackingField;
    internal CollectionPlanSettings CollectionPlanSettings { get; private set; }
    public bool IsTimingDataAvailable { get; public set; }
    public IntelliTraceFileSerializerImpl(CollectionPlanSettings collectionPlanSettings);
    [CompilerGeneratedAttribute]
internal CollectionPlanSettings get_CollectionPlanSettings();
    [CompilerGeneratedAttribute]
private void set_CollectionPlanSettings(CollectionPlanSettings value);
    public virtual bool get_IsTimingDataAvailable();
    public virtual void set_IsTimingDataAvailable(bool value);
    public virtual void Serialize(string fileName, IntelliTraceStore store);
    private void ValidateStore(string filename, IntelliTraceStore store);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.IntelliTraceIncrementalFileSerializerImpl : IntelliTraceIncrementalFileSerializer {
    private bool _isDisposed;
    private bool _isFirstFlush;
    private SerializerContext _context;
    private EventHandler`1<TrimLogEventArgs> _truncationHandler;
    [CompilerGeneratedAttribute]
private ExtendedVersionInfo <ExtendedVersionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceStore <IntelliTraceStore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlushOnDispose>k__BackingField;
    internal ExtendedVersionInfo ExtendedVersionInfo { get; internal set; }
    public IntelliTraceStore IntelliTraceStore { get; protected set; }
    public string FileName { get; protected set; }
    public bool IsTimingDataAvailable { get; public set; }
    public bool FlushOnDispose { get; public set; }
    internal CollectionPlanSettings CollectionPlanSettings { get; }
    public IntelliTraceIncrementalFileSerializerImpl(CollectionPlanSettings collectionPlanSettings, IntelliTraceStoreImpl store, string filename);
    [CompilerGeneratedAttribute]
internal ExtendedVersionInfo get_ExtendedVersionInfo();
    [CompilerGeneratedAttribute]
internal void set_ExtendedVersionInfo(ExtendedVersionInfo value);
    [CompilerGeneratedAttribute]
public virtual IntelliTraceStore get_IntelliTraceStore();
    [CompilerGeneratedAttribute]
protected virtual void set_IntelliTraceStore(IntelliTraceStore value);
    [CompilerGeneratedAttribute]
public virtual string get_FileName();
    [CompilerGeneratedAttribute]
protected virtual void set_FileName(string value);
    public virtual bool get_IsTimingDataAvailable();
    public virtual void set_IsTimingDataAvailable(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_FlushOnDispose();
    [CompilerGeneratedAttribute]
public virtual void set_FlushOnDispose(bool value);
    public virtual void Flush();
    public virtual void Snapshot(string snapshotFileName);
    protected virtual void Dispose(bool disposing);
    internal CollectionPlanSettings get_CollectionPlanSettings();
    private void ThrowIfDisposed();
    private void FlushStore();
    private void FlushFileHeader();
    private void FlushFile();
    private void CloseFile();
    private void HandleTruncation(object sender, TrimLogEventArgs args);
    [CompilerGeneratedAttribute]
private void <FlushFileHeader>b__31_0();
    [CompilerGeneratedAttribute]
private void <FlushFile>b__32_0();
    [CompilerGeneratedAttribute]
private void <CloseFile>b__33_0();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.IntelliTraceStoreImpl : IntelliTraceStore {
    private CallStackCreationModes _callStackCreationMode;
    [CompilerGeneratedAttribute]
private MetadataStore <MetadataStore>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemInfo <SystemInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticEvents <DiagnosticEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private WebRequestEvents <WebRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private DataSourceType <DataSourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private CallStackStateMachines <CallStackStateMachines>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopedEvents <ScopedEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildInformationEvents <BuildInformationEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsPerformanceMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessImpl <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderManager <OrderManager>k__BackingField;
    [CompilerGeneratedAttribute]
private Action StoreFlush;
    private Dictionary`2<MetadataModuleImpl, DebugData> _moduleDebugData;
    private ObjectValidityState _currentObjectValidityState;
    public MetadataStore MetadataStore { get; protected set; }
    public SystemInfo SystemInfo { get; protected set; }
    public DiagnosticEvents DiagnosticEvents { get; protected set; }
    public CollectionConfiguration Configuration { get; protected set; }
    public WebRequestEvents WebRequests { get; protected set; }
    public DataSourceType DataSourceType { get; public set; }
    public CallStackStateMachines CallStackStateMachines { get; protected set; }
    public ScopedEvents ScopedEvents { get; protected set; }
    public BuildInformationEvents BuildInformationEvents { get; protected set; }
    internal Nullable`1<bool> IsPerformanceMode { get; internal set; }
    internal ProcessImpl Process { get; private set; }
    internal OrderManager OrderManager { get; private set; }
    internal Dictionary`2<MetadataModuleImpl, DebugData> ModuleDebugData { get; }
    internal CallStackCreationModes CallStackCreationMode { get; internal set; }
    public ObjectValidityState CurrentObjectValidityState { get; private set; }
    public string DataProviderName { get; }
    internal IntelliTraceStoreImpl(string dataProviderName);
    [CompilerGeneratedAttribute]
public virtual MetadataStore get_MetadataStore();
    [CompilerGeneratedAttribute]
protected virtual void set_MetadataStore(MetadataStore value);
    [CompilerGeneratedAttribute]
public virtual SystemInfo get_SystemInfo();
    [CompilerGeneratedAttribute]
protected virtual void set_SystemInfo(SystemInfo value);
    [CompilerGeneratedAttribute]
public virtual DiagnosticEvents get_DiagnosticEvents();
    [CompilerGeneratedAttribute]
protected virtual void set_DiagnosticEvents(DiagnosticEvents value);
    [CompilerGeneratedAttribute]
public virtual CollectionConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
protected virtual void set_Configuration(CollectionConfiguration value);
    [CompilerGeneratedAttribute]
public virtual WebRequestEvents get_WebRequests();
    [CompilerGeneratedAttribute]
protected virtual void set_WebRequests(WebRequestEvents value);
    [CompilerGeneratedAttribute]
public virtual DataSourceType get_DataSourceType();
    [CompilerGeneratedAttribute]
public virtual void set_DataSourceType(DataSourceType value);
    [CompilerGeneratedAttribute]
public virtual CallStackStateMachines get_CallStackStateMachines();
    [CompilerGeneratedAttribute]
protected virtual void set_CallStackStateMachines(CallStackStateMachines value);
    [CompilerGeneratedAttribute]
public virtual ScopedEvents get_ScopedEvents();
    [CompilerGeneratedAttribute]
protected virtual void set_ScopedEvents(ScopedEvents value);
    [CompilerGeneratedAttribute]
public virtual BuildInformationEvents get_BuildInformationEvents();
    [CompilerGeneratedAttribute]
protected virtual void set_BuildInformationEvents(BuildInformationEvents value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_IsPerformanceMode();
    [CompilerGeneratedAttribute]
internal void set_IsPerformanceMode(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal ProcessImpl get_Process();
    [CompilerGeneratedAttribute]
private void set_Process(ProcessImpl value);
    [CompilerGeneratedAttribute]
internal OrderManager get_OrderManager();
    [CompilerGeneratedAttribute]
private void set_OrderManager(OrderManager value);
    [CompilerGeneratedAttribute]
internal void add_StoreFlush(Action value);
    [CompilerGeneratedAttribute]
internal void remove_StoreFlush(Action value);
    internal Dictionary`2<MetadataModuleImpl, DebugData> get_ModuleDebugData();
    public virtual Process CreateProcess(int id, DateTime startTime, DateTime endTime);
    public virtual Process CreateProcess(int id, DateTime startTime);
    public virtual void SetDebugDirectory(string fullFileName, MetadataModule module);
    public virtual void SetDebugDirectory(DebugData debugdata, MetadataModule module);
    internal void FlushMemoryState();
    internal CallStackCreationModes get_CallStackCreationMode();
    internal void set_CallStackCreationMode(CallStackCreationModes value);
    public ObjectValidityState get_CurrentObjectValidityState();
    private void set_CurrentObjectValidityState(ObjectValidityState value);
    public virtual string get_DataProviderName();
}
internal interface Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.IObjectValidityState {
    public abstract virtual void VerifyObjectValidity();
    public abstract virtual void SetObjectValidityState(ObjectValidityState state);
}
internal interface Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.IOrdered {
    public long InternalOrdinal { get; public set; }
    public abstract virtual long get_InternalOrdinal();
    public abstract virtual void set_InternalOrdinal(long value);
}
internal interface Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.IScoped {
    public long StartOrdinal { get; }
    public long EndOrdinal { get; }
    public abstract virtual long get_StartOrdinal();
    public abstract virtual long get_EndOrdinal();
}
internal interface Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.IStreamed {
    public long StreamOffset { get; public set; }
    public abstract virtual long get_StreamOffset();
    public abstract virtual void set_StreamOffset(long value);
}
internal interface Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.IThreadAssociated {
    public IEnumerable`1<ThreadAssociation> ThreadAssociations { get; }
    public abstract virtual IEnumerable`1<ThreadAssociation> get_ThreadAssociations();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.MachineInfo.SystemInfoImpl : SystemInfo {
    private DateTime _startTime;
    private long _initialQueryPerformanceCounter;
    private long _frequency;
    private static long DefaultFrequency;
    private List`1<DisplaySetting> _displaySettings;
    [CompilerGeneratedAttribute]
private OSVersion <OSVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryStatistics <MemoryStatistics>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessorInfo <ProcessorInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemBiosInfo <SystemBiosInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private UserInfo <UserInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWow64Process>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComputerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SystemDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WindowsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClrVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeZoneInfo <TimeZoneInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SystemLcid>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    public OSVersion OSVersion { get; protected set; }
    public DateTime StartTime { get; public set; }
    public MemoryStatistics MemoryStatistics { get; protected set; }
    public ProcessorInfo ProcessorInfo { get; protected set; }
    public SystemBiosInfo SystemBiosInfo { get; protected set; }
    public UserInfo UserInfo { get; protected set; }
    public bool IsWow64Process { get; public set; }
    public string ComputerName { get; public set; }
    public string SystemDirectory { get; public set; }
    public string WindowsDirectory { get; public set; }
    public string ClrVersion { get; public set; }
    public TimeZoneInfo TimeZoneInfo { get; protected set; }
    public int SystemLcid { get; public set; }
    public long StartFileTime { get; }
    internal int PointerSize { get; }
    public IEnumerable`1<DisplaySetting> DisplaySettings { get; protected set; }
    public long InitialPerformanceCounter { get; public set; }
    public long PerformanceFrequency { get; public set; }
    private IntelliTraceStoreImpl Store { get; private set; }
    internal SystemInfoImpl(IntelliTraceStoreImpl store);
    [CompilerGeneratedAttribute]
public virtual OSVersion get_OSVersion();
    [CompilerGeneratedAttribute]
protected virtual void set_OSVersion(OSVersion value);
    public virtual DateTime get_StartTime();
    public virtual void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public virtual MemoryStatistics get_MemoryStatistics();
    [CompilerGeneratedAttribute]
protected virtual void set_MemoryStatistics(MemoryStatistics value);
    [CompilerGeneratedAttribute]
public virtual ProcessorInfo get_ProcessorInfo();
    [CompilerGeneratedAttribute]
protected virtual void set_ProcessorInfo(ProcessorInfo value);
    [CompilerGeneratedAttribute]
public virtual SystemBiosInfo get_SystemBiosInfo();
    [CompilerGeneratedAttribute]
protected virtual void set_SystemBiosInfo(SystemBiosInfo value);
    [CompilerGeneratedAttribute]
public virtual UserInfo get_UserInfo();
    [CompilerGeneratedAttribute]
protected virtual void set_UserInfo(UserInfo value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsWow64Process();
    [CompilerGeneratedAttribute]
public virtual void set_IsWow64Process(bool value);
    [CompilerGeneratedAttribute]
public virtual string get_ComputerName();
    [CompilerGeneratedAttribute]
public virtual void set_ComputerName(string value);
    [CompilerGeneratedAttribute]
public virtual string get_SystemDirectory();
    [CompilerGeneratedAttribute]
public virtual void set_SystemDirectory(string value);
    [CompilerGeneratedAttribute]
public virtual string get_WindowsDirectory();
    [CompilerGeneratedAttribute]
public virtual void set_WindowsDirectory(string value);
    [CompilerGeneratedAttribute]
public virtual string get_ClrVersion();
    [CompilerGeneratedAttribute]
public virtual void set_ClrVersion(string value);
    [CompilerGeneratedAttribute]
public virtual TimeZoneInfo get_TimeZoneInfo();
    [CompilerGeneratedAttribute]
protected virtual void set_TimeZoneInfo(TimeZoneInfo value);
    [CompilerGeneratedAttribute]
public virtual int get_SystemLcid();
    [CompilerGeneratedAttribute]
public virtual void set_SystemLcid(int value);
    public long get_StartFileTime();
    internal int get_PointerSize();
    public virtual DisplaySetting CreateDisplaySetting(int width, int height, int bitsPerPixel);
    public virtual IEnumerable`1<DisplaySetting> get_DisplaySettings();
    protected virtual void set_DisplaySettings(IEnumerable`1<DisplaySetting> value);
    public virtual long get_InitialPerformanceCounter();
    public virtual void set_InitialPerformanceCounter(long value);
    public virtual long get_PerformanceFrequency();
    public virtual void set_PerformanceFrequency(long value);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    internal long GetInitialPerformanceCounter();
    internal long GetPerformanceFrequency();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataAssemblyImpl : MetadataAssembly {
    [CompilerGeneratedAttribute]
private MetadataStoreImpl <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <GeneratedToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TokenGenerationInProgress>k__BackingField;
    private List`1<MetadataModuleImpl> _metadataModules;
    [CompilerGeneratedAttribute]
private AssemblyName <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    internal MetadataStoreImpl Store { get; internal set; }
    internal UInt32 GeneratedToken { get; private set; }
    private bool TokenGenerationInProgress { get; private set; }
    internal List`1<MetadataModuleImpl> MetadataModules { get; }
    public bool HasBreakingChange { get; }
    public bool HasChange { get; }
    public AssemblyName Name { get; protected set; }
    public int Token { get; protected set; }
    public IEnumerable`1<MetadataModule> Modules { get; }
    internal bool IsMsCorlib { get; }
    internal bool HasReferencedTypes { get; }
    internal MetadataAssemblyImpl(MetadataStoreImpl store, AssemblyName assemblyName, int token);
    [CompilerGeneratedAttribute]
internal MetadataStoreImpl get_Store();
    [CompilerGeneratedAttribute]
internal void set_Store(MetadataStoreImpl value);
    [CompilerGeneratedAttribute]
internal UInt32 get_GeneratedToken();
    [CompilerGeneratedAttribute]
private void set_GeneratedToken(UInt32 value);
    [CompilerGeneratedAttribute]
private bool get_TokenGenerationInProgress();
    [CompilerGeneratedAttribute]
private void set_TokenGenerationInProgress(bool value);
    internal List`1<MetadataModuleImpl> get_MetadataModules();
    public bool get_HasBreakingChange();
    public bool get_HasChange();
    [CompilerGeneratedAttribute]
public virtual AssemblyName get_Name();
    [CompilerGeneratedAttribute]
protected virtual void set_Name(AssemblyName value);
    [CompilerGeneratedAttribute]
public virtual int get_Token();
    [CompilerGeneratedAttribute]
protected virtual void set_Token(int value);
    public virtual MetadataModule CreateModule(string filename, Guid moduleVersionId);
    public virtual IEnumerable`1<MetadataModule> get_Modules();
    public virtual bool TryGetModule(Guid moduleVersionId, MetadataModule& metadataModule);
    internal bool get_IsMsCorlib();
    internal bool get_HasReferencedTypes();
    internal void GenerateTokens(IMetaDataDispenser metadataDispenser);
    internal void ResetGeneratedTokens();
    internal void GenerateAssemblyToken(IMetaDataAssemblyEmit metadataAssemblyEmit);
    internal void GenerateReferencedAssemblyTokens(IMetaDataDispenser metadataDispenser, IMetaDataAssemblyEmit metadataAssemblyEmit, List`1<MetadataReferencedType> metadataReferencedTypes);
    private static ASSEMBLYMETADATA GetAssemblyData(MetadataAssemblyImpl assembly);
    private void GenerateTokensPrivate(IMetaDataDispenser metadataDispenser);
    private void GenerateModuleTokens(IMetaDataDispenser metadataDispenser);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataExtensions : object {
    [ExtensionAttribute]
public static MetadataType FindPrimitiveType(MetadataStoreImpl store);
}
internal static class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataHelper : object {
    internal static void AddItemToCollection(Dictionary`2<K, T> collection, K key, T value);
    internal static bool TryGetValue(Dictionary`2<K, T> collection, K key, I& value);
    internal static UInt32 RidToToken(UInt32 rid, UInt32 tktype);
    internal static UInt32 TokenFromRid(UInt32 rid, UInt32 tktype);
    internal static UInt32 RidFromToken(UInt32 tk);
    internal static bool IsNilToken(UInt32 tk);
    internal static UInt32 TypeFromToken(UInt32 tk);
    internal static bool IsTokenValid(UInt32 tk, UInt32 type);
    internal static IndexType GetIndexTypeFromToken(UInt32 tk);
    internal static void EncodeNumber(List`1<byte> signature, UInt32 value);
    internal static void EncodeSignedNumber(List`1<byte> signature, int value);
    internal static void EncodeTypeDefOrRefToken(List`1<byte> signature, UInt32 value);
    internal static void EncodeArrayDefinition(List`1<byte> signature, MetadataArrayDefinition arrayDefinition);
    internal static void AddReferencedTypeForGenericDefinition(MetadataModuleImpl parentModule, MetadataGenericDefinition genericDefinition);
    internal static void SetGenericParameterTypeOwner(MetadataGenericDefinition genericDefinition);
    internal static void CheckGenericParameterType(MetadataGenericDefinition genericDefinition);
    internal static UInt32 GetMetadataTypeToken(MetadataModuleImpl metadataModule, MetadataTypeImpl metadataType);
    internal static void AddTypeToSignature(List`1<byte> signature, MetadataModuleImpl metadataModule, MetadataTypeImpl metadataType, bool isMethodSpec);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataMemberImpl : MetadataMember {
    [CompilerGeneratedAttribute]
private UInt32 <GeneratedToken>k__BackingField;
    [CompilerGeneratedAttribute]
private CorFieldAttr <MemberAttributes>k__BackingField;
    private object _defaultValue;
    [CompilerGeneratedAttribute]
private MetadataType <ParentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataType <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    internal UInt32 GeneratedToken { get; internal set; }
    private CorFieldAttr MemberAttributes { get; private set; }
    public MetadataType ParentType { get; protected set; }
    public string Name { get; protected set; }
    public MetadataType MemberType { get; protected set; }
    public int Token { get; protected set; }
    public bool IsPublic { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsStatic { get; public set; }
    public object DefaultValue { get; public set; }
    internal bool IsMemberInLocalModule { get; }
    internal MetadataModuleImpl MetadataModule { get; }
    internal MetadataMemberImpl(MetadataType parentType, string name, MetadataType memberType, int token);
    [CompilerGeneratedAttribute]
internal UInt32 get_GeneratedToken();
    [CompilerGeneratedAttribute]
internal void set_GeneratedToken(UInt32 value);
    [CompilerGeneratedAttribute]
private CorFieldAttr get_MemberAttributes();
    [CompilerGeneratedAttribute]
private void set_MemberAttributes(CorFieldAttr value);
    [CompilerGeneratedAttribute]
public virtual MetadataType get_ParentType();
    [CompilerGeneratedAttribute]
protected virtual void set_ParentType(MetadataType value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
protected virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual MetadataType get_MemberType();
    [CompilerGeneratedAttribute]
protected virtual void set_MemberType(MetadataType value);
    [CompilerGeneratedAttribute]
public virtual int get_Token();
    [CompilerGeneratedAttribute]
protected virtual void set_Token(int value);
    public virtual bool get_IsPublic();
    public virtual void set_IsPublic(bool value);
    public virtual bool get_IsAssembly();
    public virtual void set_IsAssembly(bool value);
    public virtual bool get_IsStatic();
    public virtual void set_IsStatic(bool value);
    public virtual object get_DefaultValue();
    public virtual void set_DefaultValue(object value);
    internal bool get_IsMemberInLocalModule();
    internal void GenerateTokens(IMetaDataEmit2 metadataEmit2);
    internal void ResetGeneratedTokens();
    internal MetadataModuleImpl get_MetadataModule();
    private void SetMemberDefAttribute(CorFieldAttr mask, CorFieldAttr attribute, CorFieldAttr resetattribute, bool isSet);
    private void SetMemberDefAttribute(CorFieldAttr attribute, bool isSet);
    private bool IsMemberDefAttributeSet(CorFieldAttr mask, CorFieldAttr attribute);
    private bool IsMemberDefAttributeSet(CorFieldAttr attribute);
    private Byte[] GenerateMemberSignature();
    private Byte[] GetEnumDefaultValue(MetadataTypeImpl enumMetadataType);
    private void NotifyPropertyChanged(string property, object oldValue, object newValue);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataMethodImpl : MetadataMethod {
    [CompilerGeneratedAttribute]
private UInt32 <GeneratedToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GenericName>k__BackingField;
    [CompilerGeneratedAttribute]
private CorMethodImpl <ImplFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private CorMethodAttr <MethodAttributes>k__BackingField;
    private bool _isReturnTypeByRef;
    private MetadataTypeImpl _returnType;
    private List`1<MetadataParameterImpl> _metadataParameters;
    [CompilerGeneratedAttribute]
private MetadataModule <ParentModule>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataType <ParentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataMethod <MethodSpecParentMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataGenericDefinition <GenericDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodeRva>k__BackingField;
    private bool _isDefaultCall;
    private bool _isCCall;
    private bool _isStdCall;
    private bool _isFastCall;
    internal UInt32 GeneratedToken { get; internal set; }
    internal string GenericName { get; internal set; }
    private CorMethodImpl ImplFlags { get; private set; }
    private CorMethodAttr MethodAttributes { get; private set; }
    private bool IsReturnTypeByRef { get; private set; }
    private MetadataTypeImpl ReturnType { get; private set; }
    private List`1<MetadataParameterImpl> MetadataParameters { get; private set; }
    public MetadataModule ParentModule { get; protected set; }
    public MetadataType ParentType { get; protected set; }
    public string Name { get; protected set; }
    public int Token { get; protected set; }
    public MetadataMethod MethodSpecParentMethod { get; protected set; }
    public MetadataGenericDefinition GenericDefinition { get; protected set; }
    public bool IsGenericMethod { get; protected set; }
    public bool IsMethodSpec { get; protected set; }
    public int CodeRva { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsFinal { get; public set; }
    public bool IsVirtual { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsDefaultCall { get; public set; }
    public bool IsCCall { get; public set; }
    public bool IsStdCall { get; public set; }
    public bool IsFastCall { get; public set; }
    public IEnumerable`1<MetadataParameter> Parameters { get; protected set; }
    internal bool IsMethodSpecParentMethodInLocalModule { get; }
    internal bool IsReturnTypeInLocalModule { get; }
    internal MetadataModuleImpl MetadataModule { get; }
    internal MetadataMethodImpl(MetadataModule metadataModule, MetadataType parentType, string name, int token);
    internal MetadataMethodImpl(MetadataModule metadataModule, MetadataType parentType, string name, int token, MetadataGenericDefinition metadataGenericDefinition);
    internal MetadataMethodImpl(MetadataModule metadataModule, MetadataType parentType, MetadataMethod methodspecParentMethod, int methodspecToken, MetadataGenericDefinition metadataGenericDefinition);
    [CompilerGeneratedAttribute]
internal UInt32 get_GeneratedToken();
    [CompilerGeneratedAttribute]
internal void set_GeneratedToken(UInt32 value);
    [CompilerGeneratedAttribute]
internal string get_GenericName();
    [CompilerGeneratedAttribute]
internal void set_GenericName(string value);
    [CompilerGeneratedAttribute]
private CorMethodImpl get_ImplFlags();
    [CompilerGeneratedAttribute]
private void set_ImplFlags(CorMethodImpl value);
    [CompilerGeneratedAttribute]
private CorMethodAttr get_MethodAttributes();
    [CompilerGeneratedAttribute]
private void set_MethodAttributes(CorMethodAttr value);
    private bool get_IsReturnTypeByRef();
    private void set_IsReturnTypeByRef(bool value);
    private MetadataTypeImpl get_ReturnType();
    private void set_ReturnType(MetadataTypeImpl value);
    private List`1<MetadataParameterImpl> get_MetadataParameters();
    private void set_MetadataParameters(List`1<MetadataParameterImpl> value);
    [CompilerGeneratedAttribute]
public virtual MetadataModule get_ParentModule();
    [CompilerGeneratedAttribute]
protected virtual void set_ParentModule(MetadataModule value);
    [CompilerGeneratedAttribute]
public virtual MetadataType get_ParentType();
    [CompilerGeneratedAttribute]
protected virtual void set_ParentType(MetadataType value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
protected virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual int get_Token();
    [CompilerGeneratedAttribute]
protected virtual void set_Token(int value);
    [CompilerGeneratedAttribute]
public virtual MetadataMethod get_MethodSpecParentMethod();
    [CompilerGeneratedAttribute]
protected virtual void set_MethodSpecParentMethod(MetadataMethod value);
    [CompilerGeneratedAttribute]
public virtual MetadataGenericDefinition get_GenericDefinition();
    [CompilerGeneratedAttribute]
protected virtual void set_GenericDefinition(MetadataGenericDefinition value);
    public virtual bool get_IsGenericMethod();
    protected virtual void set_IsGenericMethod(bool value);
    public virtual bool get_IsMethodSpec();
    protected virtual void set_IsMethodSpec(bool value);
    [CompilerGeneratedAttribute]
public virtual int get_CodeRva();
    [CompilerGeneratedAttribute]
public virtual void set_CodeRva(int value);
    public virtual bool get_IsPrivate();
    public virtual void set_IsPrivate(bool value);
    public virtual bool get_IsAssembly();
    public virtual void set_IsAssembly(bool value);
    public virtual bool get_IsPublic();
    public virtual void set_IsPublic(bool value);
    public virtual bool get_IsStatic();
    public virtual void set_IsStatic(bool value);
    public virtual bool get_IsFinal();
    public virtual void set_IsFinal(bool value);
    public virtual bool get_IsVirtual();
    public virtual void set_IsVirtual(bool value);
    public virtual bool get_IsAbstract();
    public virtual void set_IsAbstract(bool value);
    public virtual bool get_IsDefaultCall();
    public virtual void set_IsDefaultCall(bool value);
    public virtual bool get_IsCCall();
    public virtual void set_IsCCall(bool value);
    public virtual bool get_IsStdCall();
    public virtual void set_IsStdCall(bool value);
    public virtual bool get_IsFastCall();
    public virtual void set_IsFastCall(bool value);
    public virtual void SetMethodReturnType(MetadataType returnType, bool isByRef);
    public virtual void GetMethodReturnType(MetadataType& returnType, Boolean& isByRef);
    public virtual MetadataParameter CreateParameter(string name, MetadataType parameterType);
    public virtual MetadataParameter CreateParameter(string name, MetadataType parameterType, int token);
    public virtual IEnumerable`1<MetadataParameter> get_Parameters();
    protected virtual void set_Parameters(IEnumerable`1<MetadataParameter> value);
    public virtual bool TryGetParameter(int token, MetadataParameter& metadataParameter);
    internal bool get_IsMethodSpecParentMethodInLocalModule();
    internal bool get_IsReturnTypeInLocalModule();
    internal void GenerateTokens(IMetaDataEmit2 metadataEmit2);
    internal void ResetGeneratedTokens();
    internal MetadataModuleImpl get_MetadataModule();
    private bool GetOrCreateParameter(string name, MetadataType parameterType, Func`1<int> tokenCreator, MetadataParameterImpl& parameter);
    private void MakeGenericName();
    private void SetMethodAttribute(CorMethodAttr attribute, bool isSet);
    private bool IsMethodAttributeSet(CorMethodAttr attribute);
    private Byte[] GenerateMethodSignature();
    private Byte[] GenerateMethodSpecSignature();
    private void GenerateParameterTokens(IMetaDataEmit2 metadataEmit2);
    private void NotifyPropertyChanged(string property, object oldValue, object newValue);
    [CompilerGeneratedAttribute]
private int <CreateParameter>b__105_0();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataModuleImpl : MetadataModule {
    [CompilerGeneratedAttribute]
private Byte[] <MetadataBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <GeneratedModuleVersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataType <FirstType>k__BackingField;
    private MetadataTokenManager _tokenManager;
    private Dictionary`2<UInt32, MetadataTypeImpl> _metadataTypes;
    private List`1<MetadataReferencedType> _metadataReferencedTypes;
    private HashSet`1<MetadataTypeImpl> _newlyCreatedTypes;
    private HashSet`1<MetadataMethodImpl> _newlyCreatedMethods;
    private Action`2<MetadataTypeImpl, MetadataPropertyChangedEventArgs> _typeChangedHandler;
    private Action`2<MetadataMemberImpl, MetadataPropertyChangedEventArgs> _memberChangedHandler;
    private Action`2<MetadataMethodImpl, MetadataPropertyChangedEventArgs> _methodChangedHandler;
    private Action`2<MetadataParameterImpl, MetadataPropertyChangedEventArgs> _parameterChangedHandler;
    private bool _hasChange;
    private bool _hasBreakingChange;
    [CompilerGeneratedAttribute]
private MetadataAssembly <ParentAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ModuleVersionId>k__BackingField;
    internal Byte[] MetadataBlob { get; private set; }
    private string ModuleName { get; private set; }
    private Guid GeneratedModuleVersionId { get; private set; }
    private MetadataType FirstType { get; private set; }
    internal MetadataTokenManager TokenManager { get; }
    internal MetadataAssemblyImpl MetadataAssembly { get; }
    internal Dictionary`2<UInt32, MetadataTypeImpl> MetadataTypes { get; }
    internal List`1<MetadataReferencedType> MetadataReferencedTypes { get; }
    internal bool HasChange { get; private set; }
    internal bool HasBreakingChange { get; private set; }
    public MetadataAssembly ParentAssembly { get; protected set; }
    public string FileName { get; protected set; }
    public Guid ModuleVersionId { get; protected set; }
    public IEnumerable`1<MetadataType> Types { get; protected set; }
    internal bool HasReferencedTypes { get; }
    internal MetadataModuleImpl(MetadataAssemblyImpl parentAssembly, string filename, Guid moduleVersionId);
    [CompilerGeneratedAttribute]
internal Byte[] get_MetadataBlob();
    [CompilerGeneratedAttribute]
private void set_MetadataBlob(Byte[] value);
    [CompilerGeneratedAttribute]
private string get_ModuleName();
    [CompilerGeneratedAttribute]
private void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
private Guid get_GeneratedModuleVersionId();
    [CompilerGeneratedAttribute]
private void set_GeneratedModuleVersionId(Guid value);
    [CompilerGeneratedAttribute]
private MetadataType get_FirstType();
    [CompilerGeneratedAttribute]
private void set_FirstType(MetadataType value);
    internal MetadataTokenManager get_TokenManager();
    internal MetadataAssemblyImpl get_MetadataAssembly();
    internal Dictionary`2<UInt32, MetadataTypeImpl> get_MetadataTypes();
    internal List`1<MetadataReferencedType> get_MetadataReferencedTypes();
    internal bool get_HasChange();
    private void set_HasChange(bool value);
    internal bool get_HasBreakingChange();
    private void set_HasBreakingChange(bool value);
    [CompilerGeneratedAttribute]
public virtual MetadataAssembly get_ParentAssembly();
    [CompilerGeneratedAttribute]
protected virtual void set_ParentAssembly(MetadataAssembly value);
    [CompilerGeneratedAttribute]
public virtual string get_FileName();
    [CompilerGeneratedAttribute]
protected virtual void set_FileName(string value);
    [CompilerGeneratedAttribute]
public virtual Guid get_ModuleVersionId();
    [CompilerGeneratedAttribute]
protected virtual void set_ModuleVersionId(Guid value);
    public virtual MetadataType CreateType(string name, MetadataType parentType);
    public virtual MetadataType CreateType(string name, MetadataType parentType, MetadataType[] implementedInterfaceTypes);
    public virtual MetadataType CreateType(string name, int token, MetadataType parentType);
    public virtual MetadataType CreateType(string name, int token, MetadataType parentType, MetadataType[] implementedInterfaceTypes);
    public virtual MetadataType CreateGenericType(string name, MetadataType parentType, MetadataGenericDefinition metadataGenericDefinition, MetadataType[] implementedInterfaceTypes);
    public virtual MetadataType CreateGenericType(string name, int token, MetadataType parentType, MetadataGenericDefinition metadataGenericDefinition, MetadataType[] implementedInterfaceTypes);
    public virtual MetadataType CreateGenericParameterType(string name, int genericParameterSequence);
    public virtual MetadataType CreateTypeSpec(MetadataType parentType, MetadataGenericDefinition metadataGenericDefinition);
    public virtual MetadataType CreateTypeSpec(MetadataType parentType, int typespecToken, MetadataGenericDefinition metadataGenericDefinition);
    public virtual MetadataType CreateArrayType(MetadataType parentType, MetadataArrayDefinition metadataArrayDefinition);
    public virtual MetadataType CreateArrayType(MetadataType parentType, int typespecToken, MetadataArrayDefinition metadataArrayDefinition);
    public virtual IEnumerable`1<MetadataType> get_Types();
    protected virtual void set_Types(IEnumerable`1<MetadataType> value);
    public virtual bool TryGetType(int token, MetadataType& metadataType);
    internal bool get_HasReferencedTypes();
    internal void AddReferencedType(MetadataTypeImpl refmetadataType);
    internal UInt32 GetReferenceTypeToken(MetadataTypeImpl refmetadataType);
    internal void GenerateTokens(IMetaDataDispenser metadataDispenser);
    internal void ResetGeneratedTokens();
    private bool GetOrCreateSimpleType(string name, MetadataType parentType, MetadataType[] implementedInterfaceTypes, MetadataType& type, Nullable`1<int> typeToken);
    private bool GetOrCreateGenericType(string name, MetadataType parentType, MetadataGenericDefinition metadataGenericDefinition, MetadataType[] implementedInterfaceTypes, MetadataType& type, Nullable`1<int> genericToken);
    private bool GetOrCreateTypeSpec(MetadataType parentType, MetadataGenericDefinition metadataGenericDefinition, MetadataType& type, Nullable`1<int> typespecToken);
    private bool GetOrCreateArrayType(MetadataType parentType, MetadataArrayDefinition metadataArrayDefinition, MetadataType& type, Nullable`1<int> typespecToken);
    private bool GetOrCreateType(Func`2<MetadataTypeImpl, bool> findPredicate, Func`2<int, MetadataType> creator, Func`1<int> tokenCreator, MetadataType& type);
    private void GenerateModuleToken(IMetaDataDispenser metadataDispenser, IMetaDataEmit2 metadataEmit2);
    private void GenerateReferencedModuleTokens(IMetaDataDispenser metadataDispenser, IMetaDataEmit2 metadataEmit2);
    private void GenerateTypeTokens(IMetaDataEmit2 metadataEmit2);
    private void SaveMetadataBlob(IMetaDataEmit2 metadataEmit2);
    internal void OnNewMethodParameter(MetadataParameterImpl parameter);
    private void OnNewType(MetadataTypeImpl type);
    internal void OnNewMethod(MetadataMethodImpl method);
    internal void OnNewMember(MetadataMemberImpl member);
    internal void HandleStoreFlush();
    private void HandleTypeChanged(MetadataTypeImpl type, MetadataPropertyChangedEventArgs args);
    private void HandleMemberChanged(MetadataMemberImpl member, MetadataPropertyChangedEventArgs args);
    private void HandleMethodChanged(MetadataMethodImpl method, MetadataPropertyChangedEventArgs args);
    private void HandleParameterChanged(MetadataParameterImpl parameter, MetadataPropertyChangedEventArgs args);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataNameExtensions : object {
    [ExtensionAttribute]
public static string GetFullName(MetadataMethod method);
    [ExtensionAttribute]
public static string GetSimpleName(MetadataMethod method);
    [ExtensionAttribute]
public static string GetFullName(MetadataType type);
    [ExtensionAttribute]
public static string CreateMethodId(MetadataMethod method);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataParameterImpl : MetadataParameter {
    [CompilerGeneratedAttribute]
private UInt32 <GeneratedToken>k__BackingField;
    [CompilerGeneratedAttribute]
private CorParamAttr <ParameterAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataMethod <ParentMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataType <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sequence>k__BackingField;
    private bool _isByRef;
    internal UInt32 GeneratedToken { get; internal set; }
    private CorParamAttr ParameterAttributes { get; private set; }
    public MetadataMethod ParentMethod { get; protected set; }
    public string Name { get; protected set; }
    public MetadataType ParameterType { get; protected set; }
    public int Token { get; protected set; }
    public int Sequence { get; protected set; }
    public bool IsByRef { get; public set; }
    public bool IsInParameter { get; public set; }
    public bool IsOutParameter { get; public set; }
    internal bool IsParameterTypeInLocalModule { get; }
    internal MetadataModuleImpl MetadataModule { get; }
    internal MetadataParameterImpl(MetadataMethod parentMethod, string name, MetadataType parameterType, int token, int sequence);
    [CompilerGeneratedAttribute]
internal UInt32 get_GeneratedToken();
    [CompilerGeneratedAttribute]
internal void set_GeneratedToken(UInt32 value);
    [CompilerGeneratedAttribute]
private CorParamAttr get_ParameterAttributes();
    [CompilerGeneratedAttribute]
private void set_ParameterAttributes(CorParamAttr value);
    [CompilerGeneratedAttribute]
public virtual MetadataMethod get_ParentMethod();
    [CompilerGeneratedAttribute]
protected virtual void set_ParentMethod(MetadataMethod value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
protected virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual MetadataType get_ParameterType();
    [CompilerGeneratedAttribute]
protected virtual void set_ParameterType(MetadataType value);
    [CompilerGeneratedAttribute]
public virtual int get_Token();
    [CompilerGeneratedAttribute]
protected virtual void set_Token(int value);
    [CompilerGeneratedAttribute]
public virtual int get_Sequence();
    [CompilerGeneratedAttribute]
protected virtual void set_Sequence(int value);
    public virtual bool get_IsByRef();
    public virtual void set_IsByRef(bool value);
    public virtual bool get_IsInParameter();
    public virtual void set_IsInParameter(bool value);
    public virtual bool get_IsOutParameter();
    public virtual void set_IsOutParameter(bool value);
    internal bool get_IsParameterTypeInLocalModule();
    internal void GenerateTokens(IMetaDataEmit2 metadataEmit2);
    internal void ResetGeneratedTokens();
    internal MetadataModuleImpl get_MetadataModule();
    private void SetParamAttribute(CorParamAttr attribute, bool isSet);
    private bool IsParamAttributeSet(CorParamAttr attribute);
    private void NotifyPropertyChanged(string property, object oldValue, object newValue);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataPropertyChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <NewValue>k__BackingField;
    public string Property { get; private set; }
    public object OldValue { get; private set; }
    public object NewValue { get; private set; }
    public MetadataPropertyChangedEventArgs(string property, object oldValue, object newValue);
    [CompilerGeneratedAttribute]
public string get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(string value);
    [CompilerGeneratedAttribute]
public object get_OldValue();
    [CompilerGeneratedAttribute]
private void set_OldValue(object value);
    [CompilerGeneratedAttribute]
public object get_NewValue();
    [CompilerGeneratedAttribute]
private void set_NewValue(object value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataReferencedType : object {
    [CompilerGeneratedAttribute]
private MetadataTypeImpl <ReferencedType>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TypeRefToken>k__BackingField;
    internal MetadataTypeImpl ReferencedType { get; internal set; }
    internal UInt32 TypeRefToken { get; internal set; }
    [CompilerGeneratedAttribute]
internal MetadataTypeImpl get_ReferencedType();
    [CompilerGeneratedAttribute]
internal void set_ReferencedType(MetadataTypeImpl value);
    [CompilerGeneratedAttribute]
internal UInt32 get_TypeRefToken();
    [CompilerGeneratedAttribute]
internal void set_TypeRefToken(UInt32 value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataStoreImpl : MetadataStore {
    private List`1<MetadataAssemblyImpl> _metadataAssemblies;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <IntelliTraceStore>k__BackingField;
    internal List`1<MetadataAssemblyImpl> MetadataAssemblies { get; }
    internal IntelliTraceStoreImpl IntelliTraceStore { get; private set; }
    public bool HasChange { get; }
    public bool HasBreakingChange { get; }
    public IEnumerable`1<MetadataAssembly> Assemblies { get; }
    internal MetadataStoreImpl(IntelliTraceStoreImpl intelliTraceStore);
    internal List`1<MetadataAssemblyImpl> get_MetadataAssemblies();
    [CompilerGeneratedAttribute]
internal IntelliTraceStoreImpl get_IntelliTraceStore();
    [CompilerGeneratedAttribute]
private void set_IntelliTraceStore(IntelliTraceStoreImpl value);
    public bool get_HasChange();
    public bool get_HasBreakingChange();
    public virtual MetadataAssembly CreateAssembly(AssemblyName assemblyName);
    public virtual MetadataAssembly CreateAssembly(AssemblyName assemblyName, int token);
    public virtual IEnumerable`1<MetadataAssembly> get_Assemblies();
    public virtual bool TryGetAssembly(AssemblyName assemblyName, MetadataAssembly& metadataAssembly);
    internal void EmitMetadata();
    private bool GetOrCreateAssembly(AssemblyName assemblyName, Func`1<int> tokenCreator, MetadataAssembly& assembly);
    private void StoreFlushHandler();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataTokenManager : object {
    private static int _nextAssemblyToken;
    private int _nextTypeToken;
    private int _nextTypeSpecToken;
    private int _nextMemberToken;
    private int _nextMemberRefToken;
    private int _nextMethodToken;
    private int _nextMethodSpecToken;
    private int _nextParameterToken;
    private int _nextGenericParameterToken;
    private static MetadataTokenManager();
    internal static UInt32 GetAssemblyToken();
    internal UInt32 GetTypeToken();
    internal UInt32 GetTypeSpecToken();
    internal UInt32 GetMemberToken();
    internal UInt32 GetMemberRefToken();
    internal UInt32 GetMethodToken();
    internal UInt32 GetMethodSpecToken();
    internal UInt32 GetParameterToken();
    internal UInt32 GetGenericParameterToken();
}
[DebuggerDisplayAttribute("MetadataTypeImpl: Name = {Name}")]
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.MetadataTypeImpl : MetadataType {
    [CompilerGeneratedAttribute]
private Action`2<MetadataTypeImpl, MetadataPropertyChangedEventArgs> TypeChanged;
    [CompilerGeneratedAttribute]
private Action`2<MetadataMemberImpl, MetadataPropertyChangedEventArgs> MemberChanged;
    [CompilerGeneratedAttribute]
private Action`2<MetadataMethodImpl, MetadataPropertyChangedEventArgs> MethodChanged;
    [CompilerGeneratedAttribute]
private Action`2<MetadataParameterImpl, MetadataPropertyChangedEventArgs> ParameterChanged;
    internal static TypeEqualityChecker EqualityChecker;
    [CompilerGeneratedAttribute]
private UInt32 <GeneratedToken>k__BackingField;
    [CompilerGeneratedAttribute]
private ElementType <MetadataElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GenericName>k__BackingField;
    private Dictionary`2<ElementType, int> _sizes;
    [CompilerGeneratedAttribute]
private CorTypeAttr <TypeAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private CorGenericParamAttr <GenericParameterAttributes>k__BackingField;
    private Dictionary`2<UInt32, MetadataMethodImpl> _metadataMethods;
    private Dictionary`2<UInt32, MetadataMemberImpl> _metadataMembers;
    private bool _isGenericParameterTypeAssignedToOwner;
    [CompilerGeneratedAttribute]
private MetadataModule <ParentModule>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataType <ParentType>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataType[] <ImplementedInterfaceTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataGenericDefinition <GenericDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataArrayDefinition <ArrayDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GenericParameterSequence>k__BackingField;
    internal UInt32 GeneratedToken { get; internal set; }
    internal ElementType MetadataElementType { get; internal set; }
    internal string GenericName { get; internal set; }
    private CorTypeAttr TypeAttributes { get; private set; }
    private CorGenericParamAttr GenericParameterAttributes { get; private set; }
    internal Dictionary`2<UInt32, MetadataMethodImpl> MetadataMethods { get; }
    internal Dictionary`2<UInt32, MetadataMemberImpl> MetadataMembers { get; }
    internal bool IsGenericParameterTypeAssignedToOwner { get; internal set; }
    public MetadataModule ParentModule { get; protected set; }
    public string Name { get; protected set; }
    public int Token { get; protected set; }
    public MetadataType ParentType { get; protected set; }
    public MetadataType[] ImplementedInterfaceTypes { get; protected set; }
    public MetadataGenericDefinition GenericDefinition { get; protected set; }
    public MetadataArrayDefinition ArrayDefinition { get; protected set; }
    public bool IsPublic { get; public set; }
    public int GenericParameterSequence { get; protected set; }
    public bool IsGenericType { get; protected set; }
    public bool IsGenericParameterType { get; protected set; }
    public bool IsConstructedGenericType { get; protected set; }
    public bool IsTypeSpec { get; protected set; }
    public bool IsArrayType { get; protected set; }
    public bool IsNullableType { get; protected set; }
    public bool IsEnumType { get; protected set; }
    public bool IsValue { get; protected set; }
    public bool IsGenericCovariant { get; public set; }
    public bool IsGenericContravariant { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public IEnumerable`1<MetadataMethod> Methods { get; protected set; }
    public IEnumerable`1<MetadataMember> Members { get; protected set; }
    internal bool IsSimpleElementType { get; }
    internal bool IsParentTypeInLocalModule { get; }
    internal bool IsReservedType { get; }
    internal IEnumerable`1<MetadataType> AllTypes { get; internal set; }
    internal object DefaultValue { get; }
    internal MetadataType EnumElementType { get; }
    internal int Size { get; }
    internal MetadataModuleImpl MetadataModule { get; }
    private bool IsWellKnownAbstractType { get; }
    internal bool IsSystemArrayType { get; }
    internal bool IsSystemObjectType { get; }
    internal bool IsSystemStringType { get; }
    private IDictionary`2<ElementType, int> SizeTable { get; }
    private MetadataTypeImpl(MetadataModuleImpl metadataModule, string name, MetadataType parentType, bool ignoreName, MetadataGenericDefinition metadataGenericDefinition);
    internal MetadataTypeImpl(MetadataModuleImpl metadataModule, string name, int token, MetadataType parentType, MetadataType[] implementedInterfaceTypes);
    internal MetadataTypeImpl(MetadataModuleImpl metadataModule, string name, int token, int genericParameterSequence);
    internal MetadataTypeImpl(MetadataModuleImpl metadataModule, string name, int token, MetadataType parentType, MetadataGenericDefinition metadataGenericDefinition, MetadataType[] implementedInterfaceTypes);
    internal MetadataTypeImpl(MetadataModuleImpl metadataModule, MetadataType parentType, int typespecToken, MetadataGenericDefinition metadataGenericDefinition);
    internal MetadataTypeImpl(MetadataModuleImpl metadataModule, MetadataType parentType, int typespecToken, MetadataArrayDefinition metadataArrayDefinition);
    private static MetadataTypeImpl();
    [CompilerGeneratedAttribute]
public void add_TypeChanged(Action`2<MetadataTypeImpl, MetadataPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TypeChanged(Action`2<MetadataTypeImpl, MetadataPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_MemberChanged(Action`2<MetadataMemberImpl, MetadataPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MemberChanged(Action`2<MetadataMemberImpl, MetadataPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_MethodChanged(Action`2<MetadataMethodImpl, MetadataPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MethodChanged(Action`2<MetadataMethodImpl, MetadataPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ParameterChanged(Action`2<MetadataParameterImpl, MetadataPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ParameterChanged(Action`2<MetadataParameterImpl, MetadataPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal UInt32 get_GeneratedToken();
    [CompilerGeneratedAttribute]
internal void set_GeneratedToken(UInt32 value);
    [CompilerGeneratedAttribute]
internal ElementType get_MetadataElementType();
    [CompilerGeneratedAttribute]
internal void set_MetadataElementType(ElementType value);
    [CompilerGeneratedAttribute]
internal string get_GenericName();
    [CompilerGeneratedAttribute]
internal void set_GenericName(string value);
    [CompilerGeneratedAttribute]
private CorTypeAttr get_TypeAttributes();
    [CompilerGeneratedAttribute]
private void set_TypeAttributes(CorTypeAttr value);
    [CompilerGeneratedAttribute]
private CorGenericParamAttr get_GenericParameterAttributes();
    [CompilerGeneratedAttribute]
private void set_GenericParameterAttributes(CorGenericParamAttr value);
    internal Dictionary`2<UInt32, MetadataMethodImpl> get_MetadataMethods();
    internal Dictionary`2<UInt32, MetadataMemberImpl> get_MetadataMembers();
    internal bool get_IsGenericParameterTypeAssignedToOwner();
    internal void set_IsGenericParameterTypeAssignedToOwner(bool value);
    [CompilerGeneratedAttribute]
public virtual MetadataModule get_ParentModule();
    [CompilerGeneratedAttribute]
protected virtual void set_ParentModule(MetadataModule value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
protected virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual int get_Token();
    [CompilerGeneratedAttribute]
protected virtual void set_Token(int value);
    [CompilerGeneratedAttribute]
public virtual MetadataType get_ParentType();
    [CompilerGeneratedAttribute]
protected virtual void set_ParentType(MetadataType value);
    [CompilerGeneratedAttribute]
public virtual MetadataType[] get_ImplementedInterfaceTypes();
    [CompilerGeneratedAttribute]
protected virtual void set_ImplementedInterfaceTypes(MetadataType[] value);
    [CompilerGeneratedAttribute]
public virtual MetadataGenericDefinition get_GenericDefinition();
    [CompilerGeneratedAttribute]
protected virtual void set_GenericDefinition(MetadataGenericDefinition value);
    [CompilerGeneratedAttribute]
public virtual MetadataArrayDefinition get_ArrayDefinition();
    [CompilerGeneratedAttribute]
protected virtual void set_ArrayDefinition(MetadataArrayDefinition value);
    public virtual bool get_IsPublic();
    public virtual void set_IsPublic(bool value);
    [CompilerGeneratedAttribute]
public virtual int get_GenericParameterSequence();
    [CompilerGeneratedAttribute]
protected virtual void set_GenericParameterSequence(int value);
    public virtual bool get_IsGenericType();
    protected virtual void set_IsGenericType(bool value);
    public virtual bool get_IsGenericParameterType();
    protected virtual void set_IsGenericParameterType(bool value);
    public virtual bool get_IsConstructedGenericType();
    protected virtual void set_IsConstructedGenericType(bool value);
    public virtual bool get_IsTypeSpec();
    protected virtual void set_IsTypeSpec(bool value);
    public virtual bool get_IsArrayType();
    protected virtual void set_IsArrayType(bool value);
    public virtual bool get_IsNullableType();
    protected virtual void set_IsNullableType(bool value);
    public virtual bool get_IsEnumType();
    protected virtual void set_IsEnumType(bool value);
    public virtual bool get_IsValue();
    protected virtual void set_IsValue(bool value);
    public virtual bool get_IsGenericCovariant();
    public virtual void set_IsGenericCovariant(bool value);
    public virtual bool get_IsGenericContravariant();
    public virtual void set_IsGenericContravariant(bool value);
    public virtual bool get_IsInterface();
    public virtual void set_IsInterface(bool value);
    public virtual bool get_IsAbstract();
    public virtual void set_IsAbstract(bool value);
    public virtual bool get_IsSealed();
    public virtual void set_IsSealed(bool value);
    public virtual MetadataMethod CreateMethod(string name);
    public virtual MetadataMethod CreateMethod(string name, int token);
    public virtual MetadataMethod CreateGenericMethod(string name, MetadataGenericDefinition metadataGenericDefinition);
    public virtual MetadataMethod CreateGenericMethod(string name, int token, MetadataGenericDefinition metadataGenericDefinition);
    private bool TryGetGenericMethod(int token, MetadataGenericDefinition metadataGenericDefinition, MetadataMethodImpl& method);
    public virtual MetadataMethod CreateMethodSpec(MetadataMethod methodspecParentMethod, MetadataGenericDefinition metadataGenericDefinition);
    public virtual MetadataMethod CreateMethodSpec(MetadataMethod methodspecParentMethod, int methodspecToken, MetadataGenericDefinition metadataGenericDefinition);
    public virtual IEnumerable`1<MetadataMethod> get_Methods();
    protected virtual void set_Methods(IEnumerable`1<MetadataMethod> value);
    public virtual bool TryGetMethod(int token, MetadataMethod& metadataMethod);
    public virtual bool TryGetMethod(string name, MetadataType[] paramTypes, MetadataMethod& metadataMethod);
    public virtual MetadataMember CreateMember(string name, MetadataType memberType);
    public virtual MetadataMember CreateMember(string name, MetadataType memberType, int token);
    public virtual IEnumerable`1<MetadataMember> get_Members();
    protected virtual void set_Members(IEnumerable`1<MetadataMember> value);
    public virtual bool TryGetMember(int token, MetadataMember& metadataMember);
    internal bool get_IsSimpleElementType();
    internal bool get_IsParentTypeInLocalModule();
    internal bool get_IsReservedType();
    internal IEnumerable`1<MetadataType> get_AllTypes();
    internal void set_AllTypes(IEnumerable`1<MetadataType> value);
    internal object get_DefaultValue();
    internal MetadataType get_EnumElementType();
    internal void GenerateTokens(IMetaDataEmit2 metadataEmit2);
    internal void ResetGeneratedTokens();
    internal void GenerateMemberAndMethodTokens(IMetaDataEmit2 metadataEmit2);
    internal void GenerateGenericParameterTokens(IMetaDataEmit2 metadataEmit2, UInt32 genericTypeOrMethodToken);
    internal int get_Size();
    internal MetadataModuleImpl get_MetadataModule();
    private void ValidateMemberType(MetadataType memberType);
    private bool GetOrCreateMember(string name, MetadataType memberType, MetadataMember& member, Nullable`1<int> memberToken);
    private bool GetOrCreateMember(Func`2<MetadataMemberImpl, bool> findPredicate, Func`2<int, MetadataMember> creator, Func`1<int> tokenCreator, MetadataMember& member);
    private void SetImplementedInterfaces(MetadataType[] implementedInterfaceTypes);
    private bool get_IsWellKnownAbstractType();
    internal bool get_IsSystemArrayType();
    internal bool get_IsSystemObjectType();
    internal bool get_IsSystemStringType();
    private void GetTypes(List`1<MetadataType> metadataTypes);
    private void GetMembers(List`1<MetadataMember> metadataMembers, bool storeGenericMembers, bool isConstructedType);
    private void GetMethods(List`1<MetadataMethod> metadataMethods, bool storeGenericMethods);
    private void SetElementType();
    private IDictionary`2<ElementType, int> get_SizeTable();
    private void SetTypeDefAttribute(CorTypeAttr mask, CorTypeAttr attribute, CorTypeAttr resetattribute, bool isSet);
    private void SetTypeDefAttribute(CorTypeAttr attribute, bool isSet);
    private bool IsTypeDefAttributeSet(CorTypeAttr mask, CorTypeAttr attribute);
    private bool IsTypeDefAttributeSet(CorTypeAttr attribute);
    private void SetGenericParamAttribute(CorGenericParamAttr mask, CorGenericParamAttr attribute, CorGenericParamAttr resetattribute, bool isSet);
    private void SetGenericParamAttribute(CorGenericParamAttr attribute, bool isSet);
    private bool IsGenericParamAttributeSet(CorGenericParamAttr mask, CorGenericParamAttr attribute);
    private bool IsGenericParamAttributeSet(CorGenericParamAttr attribute);
    private void MakeGenericName();
    internal static string MakeGenericName(string typeName, MetadataGenericDefinition genericDefinition);
    private Byte[] GenerateTypeSpecSignature();
    private void GenerateMemberTokens(IMetaDataEmit2 metadataEmit2);
    private void GenerateMethodTokens(IMetaDataEmit2 metadataEmit2);
    private UInt32 GetParentToken();
    private UInt32[] GetParentInterfaceTokens();
    private void NotifyPropertyChanged(string property, object oldValue, object newValue);
    internal void NotifyMemberChanged(MetadataMemberImpl member, MetadataPropertyChangedEventArgs args);
    internal void NotifyMethodChanged(MetadataMethodImpl method, MetadataPropertyChangedEventArgs args);
    internal void NotifyParameterChanged(MetadataParameterImpl parameter, MetadataPropertyChangedEventArgs args);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.Metadata.TypeEqualityChecker : object {
    public sealed virtual bool Equals(MetadataType first, MetadataType second);
    public sealed virtual int GetHashCode(MetadataType type);
    public bool IsDuplicateTypeSpec(MetadataType type, MetadataType parent, MetadataGenericDefinition genericDefinition);
    public bool IsDuplicateGenericType(MetadataType type, string name, MetadataGenericDefinition genericDefinition);
    public bool IsDuplicateArray(MetadataType type, MetadataType elementType, MetadataArrayDefinition arrayDefinition);
    private bool IsDuplicate(MetadataType type, string name, MetadataType parent, MetadataArrayDefinition arrayDefinition, MetadataGenericDefinition genericDefinition);
    private bool IsDuplicateGeneric(MetadataType type, string name, MetadataType parent, MetadataGenericDefinition genericDefinition);
    private static bool CheckFields(MetadataTypeImpl x, MetadataTypeImpl y);
    private bool GenericDefinitionEquals(MetadataGenericDefinition x, MetadataGenericDefinition y);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ModuleIdManager : object {
    private int _moduleId;
    public int GetNextModuleId();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ObjectModelHelper : object {
    private static bool IsParameterMatchInGenericContext(MetadataParameter paramInTypeSpec, MetadataParameter paramInGenericType);
    private static bool IsSameMethodInGenericContext(MetadataMethodImpl method, MetadataMethodImpl otherMethod);
    internal static MetadataMethodImpl GetMethodFromGenericType(MetadataMethodImpl method);
    internal static void ThrowAlreadyExistsException();
    internal static void ThrowFileAlreadyExistsException(string filename);
    internal static void ThrowCyclicDependencyException();
    internal static long DateTimeToEventTime(DateTime dateTime, SystemInfoImpl systemInfo);
    internal static int GetPointerSize(MetadataTypeImpl type);
    internal static void ValidatePrimitiveData(MetadataTypeImpl dataType, object value, bool throwOnFailure);
    internal static void ValidateEnumType(MetadataTypeImpl type, bool throwOnFailure);
    internal static void ValidateEnumData(object value, bool throwOnFailure);
    [ExtensionAttribute]
internal static MetadataType GetRuntimeType(ObjectData data);
    internal static bool IsCompatibleInContextOfArrayOrGenericVariance(MetadataType rhs, MetadataType lhs);
    internal static bool VarianceExtends(MetadataType type, MetadataType other);
    internal static bool IsTypeEqualOrVarianceExtends(MetadataType type, MetadataType other);
    [ExtensionAttribute]
internal static bool Extends(MetadataType type, MetadataType other);
    [ExtensionAttribute]
internal static bool IsAssignableTo(MetadataType type, MetadataType other, MetadataType[] genericArguments);
    [ExtensionAttribute]
internal static MetadataType GetRootElementType(MetadataType type);
    internal static bool ArrayDefinitionEquals(MetadataArrayDefinition x, MetadataArrayDefinition y);
    internal static void ValidateTimingData(IntelliTraceStore store, Thread thread, TreeNode node, bool ignoreMissingTimingData);
    internal static void ValidateTimingData(IntelliTraceStore store, Thread thread, CallStackFrame lastFrame, CallStackFrame frame, bool isChild);
    internal static void GetBlockInfo(int mbSize, Int32& blockSize, Int64& blockCount);
    private static void ValidatePrimitiveData(MetadataTypeImpl dataType, object value, Action`2<bool, string> checkAction);
    private static void ValidateEnumType(MetadataTypeImpl type, Action`2<bool, string> checkAction);
    private static void ValidateEnumData(object value, Action`2<bool, string> checkAction);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ObjectValidityState : object {
    private bool _isValid;
    public void VerifyValidity();
    public void Invalidate();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.OrderManager : object {
    private List`1<OrderScope> _scopes;
    private long _internalOrdinal;
    private OrderScope _activeScope;
    private IntelliTraceStoreImpl Store;
    internal OrderManager(IntelliTraceStoreImpl store);
    internal long GetNextOrdinal();
    internal bool IsScopeActive();
    internal OrderScope GetActiveScope();
    internal OrderScope OpenScope();
    internal void SuspendScope(OrderScope scope);
    internal void ResumeScope(OrderScope scope);
    internal void RaiseScopeEvent(EventArgs args);
    private void SuspendActive();
    private void ScopeCloseHandler(object sender, EventArgs e);
    private void ReactivateLastScope();
    private void StoreFlushHandler();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.OrderScopeImpl : OrderScope {
    [CompilerGeneratedAttribute]
private EventHandler EventOccurring;
    [CompilerGeneratedAttribute]
private EventHandler SuspendScope;
    [CompilerGeneratedAttribute]
private EventHandler ResumeScope;
    [CompilerGeneratedAttribute]
private EventHandler CloseScope;
    private bool _active;
    private OrderManager _orderManager;
    public bool IsActive { get; }
    public OrderScopeImpl(OrderManager orderManager);
    [CompilerGeneratedAttribute]
internal void add_EventOccurring(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_EventOccurring(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_SuspendScope(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_SuspendScope(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_ResumeScope(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ResumeScope(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_CloseScope(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_CloseScope(EventHandler value);
    public bool get_IsActive();
    public virtual void SuspendAll();
    internal void InternalSuspend();
    public virtual void Resume();
    protected virtual void Dispose(bool disposing);
    internal void RaiseEventCreation(EventArgs e);
    internal void InternalResume();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.OrdinalManager : object {
    private long _ordinal;
    private OrdinalRange _currentRange;
    public long GetNextOrdinal();
    public OrdinalRange CreateOrdinalRange();
    public OrdinalManager Clone(bool copyDisposing);
    private void OrdinalRangeDispose(object sender, EventArgs e);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.OrdinalRange : object {
    private HashSet`1<long> _allocatedOrdinals;
    [CompilerGeneratedAttribute]
private long <BaseOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> Disposing;
    public long BaseOrdinal { get; private set; }
    public long MaxOffset { get; private set; }
    public OrdinalRange(long baseOrdinal);
    private OrdinalRange(long baseOrdinal, HashSet`1<long> allocatedOrdinals);
    [CompilerGeneratedAttribute]
public long get_BaseOrdinal();
    [CompilerGeneratedAttribute]
private void set_BaseOrdinal(long value);
    [CompilerGeneratedAttribute]
public long get_MaxOffset();
    [CompilerGeneratedAttribute]
private void set_MaxOffset(long value);
    [CompilerGeneratedAttribute]
public void add_Disposing(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Disposing(EventHandler`1<EventArgs> value);
    public OrdinalRange Clone(bool copyDisposing);
    public long GetNextOrdinal(long internalOrdinal);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ParameterDataImpl : ParameterData {
    private ObjectValidityState _objectState;
    private ClassData _this;
    private ObjectData _returnData;
    private Dictionary`2<MetadataParameter, ObjectData> _paramData;
    [CompilerGeneratedAttribute]
private MetadataMethod <Method>k__BackingField;
    private Dictionary`2<MetadataParameter, ObjectData> ParamData { get; }
    public ObjectData InstanceData { get; public set; }
    public IEnumerable`1<KeyValuePair`2<MetadataParameter, ObjectData>> ParameterValues { get; }
    public ObjectData ReturnData { get; public set; }
    internal MetadataMethod Method { get; private set; }
    internal ParameterDataImpl(MetadataMethod method);
    private Dictionary`2<MetadataParameter, ObjectData> get_ParamData();
    public virtual ObjectData get_InstanceData();
    public virtual void set_InstanceData(ObjectData value);
    public virtual void AddParameterData(MetadataParameter parameter, ObjectData value);
    public virtual IEnumerable`1<KeyValuePair`2<MetadataParameter, ObjectData>> get_ParameterValues();
    public virtual ObjectData get_ReturnData();
    public virtual void set_ReturnData(ObjectData value);
    [CompilerGeneratedAttribute]
internal MetadataMethod get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MetadataMethod value);
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ParameterValueSerializer : object {
    private GlobalTokenManager _globalTokenManager;
    public static int PackerMemoryCapacity;
    [CompilerGeneratedAttribute]
private bool <WriteNestedFields>k__BackingField;
    public bool WriteNestedFields { get; public set; }
    public ParameterValueSerializer(GlobalTokenManager tokenManager);
    [CompilerGeneratedAttribute]
public bool get_WriteNestedFields();
    [CompilerGeneratedAttribute]
public void set_WriteNestedFields(bool value);
    public Byte[] GetParameterDataBlob(MetadataMethod method, ParameterData parameterData);
    public virtual void PackParameterDataBlob(MetadataMethod method, ParameterData parameterData, CorProfBlobPacker packer);
    private MetadataType ResolveGenericParameter(MetadataMethod method, MetadataType parameterType, ObjectData objectData);
    private void WriteNestedData(MetadataMethod method, ParameterData parameterData, CorProfBlobPacker packer);
    private void WriteNestedObjectData(CorProfBlobPacker packer, MetadataTypeImpl declaredType, ObjectData objectData);
    private void WriteNestedObjectData(CorProfBlobPacker packer, ObjectData objectData, CycleState cycleState);
    private void PackCycle(CorProfBlobPacker packer, MetadataType declaredType, CycleData cycleData, CycleState cycleState);
    private void PackNestedFieldWrapper(ObjectData childData, CycleState cycleState, Action nonNullFieldAction, Action nullFieldAction);
    private void PackNullNestedField(CorProfBlobPacker packer, MetadataType type, CycleState cycleState);
    private void PackNullTopLevelParameter(CorProfBlobPacker packer, MetadataType declaredType, bool packGeneric);
    private void WriteNestedArrayData(CorProfBlobPacker packer, ArrayData arrayObject, MetadataType declaredType, CycleState cycleState);
    private static IEnumerable`1<int> GetDimensionLengths(ArrayData arrayObject);
    private void WriteNestedArrayElementData(CorProfBlobPacker packer, ObjectData objectData, MetadataType declaredType, CycleState cycleState);
    private void WriteNestedArrayHeader(CorProfBlobPacker packer, bool isOutputElementBitmap, Byte[] validElementBitmap, bool isPartial, short elementCountToPack, int totalElementCount, Int32[] arrayDimensions);
    private bool IsTokenNeeded(MetadataType metadataType);
    public Byte[] GetReturnDataBlob(MetadataMethod method, ParameterData parameterData);
    public virtual void PackReturnDataBlob(MetadataMethod method, ParameterData parameterData, CorProfBlobPacker packer);
    private void WriteData(CorProfBlobPacker packer, MetadataType declaredType, ObjectData data);
    private void WriteData(CorProfBlobPacker packer, MetadataType declaredType, ObjectData data, bool packForGenericParam);
    private void WriteData(CorProfBlobPacker packer, MetadataType declaredType, ObjectData data, bool packForGenericParam, bool isNested);
    private IEnumerable`1<MetadataMember> GetPackableClassDataMembers(MetadataType type);
    private void WriteClassPrimitiveData(CorProfBlobPacker packer, IEnumerable`1<MetadataMember> dataTypeMembers, ClassDataImpl data);
    private void WriteClassBitFieldsData(CorProfBlobPacker packer, IEnumerable`1<MetadataMember> dataTypeMembers, ClassDataImpl data);
    private void WriteClassNullableData(CorProfBlobPacker packer, IEnumerable`1<MetadataMember> dataTypeMembers, ClassDataImpl data);
    private void WriteClassData(CorProfBlobPacker packer, MetadataTypeImpl type, ClassDataImpl data);
    private void WriteArrayData(CorProfBlobPacker packer, MetadataTypeImpl declaredType, ArrayDataImpl data, bool isNested);
    private void WriteTopLevelArrayExtendedData(CorProfBlobPacker packer, ArrayData data, CycleState cycleState);
    private void WriteArrayAndElementToken(CorProfBlobPacker packer, MetadataType declaredType, ArrayData data, bool isNested);
    private void WriteArrayElementToken(CorProfBlobPacker packer, MetadataType runtimeType, bool nowrite);
    private void WriteArrayHeader(CorProfBlobPacker packer, int byteSize, bool isPartial, short elementCountToPack, int totalElementCount, Int32[] arrayDimensions);
    private static bool IsMemberInBitField(MetadataMember member, bool isIncludeBooleanMember);
    private void WriteNullableData(CorProfBlobPacker packer, ClassData data);
    private static bool ShouldWriteNullableMemberAsBit(MetadataTypeImpl type);
    private void WriteClassDefaultData(CorProfBlobPacker packer, MetadataTypeImpl type);
    private void WriteArrayDefaultData(CorProfBlobPacker packer, MetadataTypeImpl type, bool isNested, bool writeNull);
    private void WriteDefaultData(CorProfBlobPacker packer, MetadataTypeImpl type);
    private void WriteDefaultData(CorProfBlobPacker packer, MetadataTypeImpl type, bool packForGenericParam);
    private void WriteDefaultData(CorProfBlobPacker packer, MetadataTypeImpl type, bool packForGenericParam, bool isNested);
    private void WritePrimitiveData(CorProfBlobPacker packer, MetadataTypeImpl type, object value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ProcessImpl : Process {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLine>k__BackingField;
    private Dictionary`2<ThreadKey, ThreadImpl> _threads;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    public int Id { get; protected set; }
    public DateTime StartTime { get; protected set; }
    public DateTime EndTime { get; protected set; }
    public string Name { get; public set; }
    public string CommandLine { get; public set; }
    public IEnumerable`1<Thread> Threads { get; protected set; }
    private IntelliTraceStoreImpl Store { get; private set; }
    internal ProcessImpl(IntelliTraceStoreImpl store, int id, DateTime startTime, DateTime endTime);
    [CompilerGeneratedAttribute]
public virtual int get_Id();
    [CompilerGeneratedAttribute]
protected virtual void set_Id(int value);
    [CompilerGeneratedAttribute]
public virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
protected virtual void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public virtual DateTime get_EndTime();
    [CompilerGeneratedAttribute]
protected virtual void set_EndTime(DateTime value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual string get_CommandLine();
    [CompilerGeneratedAttribute]
public virtual void set_CommandLine(string value);
    public virtual Thread CreateThread(int id, DateTime startTime, DateTime endTime);
    public virtual Thread CreateThread(int id, DateTime startTime);
    public virtual IEnumerable`1<Thread> get_Threads();
    protected virtual void set_Threads(IEnumerable`1<Thread> value);
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ScopedEventIdManager : object {
    private int _requestId;
    public int GetNextScopedEventId();
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.SerializerContext : object {
    [CompilerGeneratedAttribute]
private CollectionPlanSettings <CollectionPlanSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceStoreImpl <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleIdManager <ModuleIdManager>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopedEventIdManager <WebRequestIdManager>k__BackingField;
    [CompilerGeneratedAttribute]
private OrdinalManager <OrdinalManager>k__BackingField;
    [CompilerGeneratedAttribute]
private GlobalTokenManager <GlobalTokenManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageMemory2 <Memory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFileDeleteRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private FlushState <SerializationState>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceFile <File>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticEventStreamState <DiagnosticStreamState>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<Thread, ThreadEventStreamState> <ThreadStreamStates>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsPerformanceMode>k__BackingField;
    private bool _isDisposed;
    public CollectionPlanSettings CollectionPlanSettings { get; private set; }
    public IntelliTraceStoreImpl Store { get; private set; }
    public string FileName { get; private set; }
    private ModuleIdManager ModuleIdManager { get; private set; }
    private ScopedEventIdManager WebRequestIdManager { get; private set; }
    private OrdinalManager OrdinalManager { get; private set; }
    private GlobalTokenManager GlobalTokenManager { get; private set; }
    private IMessageMemory2 Memory { get; private set; }
    private bool IsFileDeleteRequired { get; private set; }
    private FlushState SerializationState { get; private set; }
    public IntelliTraceFile File { get; public set; }
    private DiagnosticEventStreamState DiagnosticStreamState { get; private set; }
    private Dictionary`2<Thread, ThreadEventStreamState> ThreadStreamStates { get; private set; }
    private Nullable`1<bool> IsPerformanceMode { get; private set; }
    public SerializerContext(CollectionPlanSettings collectionPlanSettings, IntelliTraceStore store, string filename);
    [CompilerGeneratedAttribute]
public CollectionPlanSettings get_CollectionPlanSettings();
    [CompilerGeneratedAttribute]
private void set_CollectionPlanSettings(CollectionPlanSettings value);
    [CompilerGeneratedAttribute]
public IntelliTraceStoreImpl get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IntelliTraceStoreImpl value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
private ModuleIdManager get_ModuleIdManager();
    [CompilerGeneratedAttribute]
private void set_ModuleIdManager(ModuleIdManager value);
    [CompilerGeneratedAttribute]
private ScopedEventIdManager get_WebRequestIdManager();
    [CompilerGeneratedAttribute]
private void set_WebRequestIdManager(ScopedEventIdManager value);
    [CompilerGeneratedAttribute]
private OrdinalManager get_OrdinalManager();
    [CompilerGeneratedAttribute]
private void set_OrdinalManager(OrdinalManager value);
    [CompilerGeneratedAttribute]
private GlobalTokenManager get_GlobalTokenManager();
    [CompilerGeneratedAttribute]
private void set_GlobalTokenManager(GlobalTokenManager value);
    [CompilerGeneratedAttribute]
private IMessageMemory2 get_Memory();
    [CompilerGeneratedAttribute]
private void set_Memory(IMessageMemory2 value);
    [CompilerGeneratedAttribute]
private bool get_IsFileDeleteRequired();
    [CompilerGeneratedAttribute]
private void set_IsFileDeleteRequired(bool value);
    [CompilerGeneratedAttribute]
private FlushState get_SerializationState();
    [CompilerGeneratedAttribute]
private void set_SerializationState(FlushState value);
    [CompilerGeneratedAttribute]
public IntelliTraceFile get_File();
    [CompilerGeneratedAttribute]
public void set_File(IntelliTraceFile value);
    [CompilerGeneratedAttribute]
private DiagnosticEventStreamState get_DiagnosticStreamState();
    [CompilerGeneratedAttribute]
private void set_DiagnosticStreamState(DiagnosticEventStreamState value);
    [CompilerGeneratedAttribute]
private Dictionary`2<Thread, ThreadEventStreamState> get_ThreadStreamStates();
    [CompilerGeneratedAttribute]
private void set_ThreadStreamStates(Dictionary`2<Thread, ThreadEventStreamState> value);
    [CompilerGeneratedAttribute]
private Nullable`1<bool> get_IsPerformanceMode();
    [CompilerGeneratedAttribute]
private void set_IsPerformanceMode(Nullable`1<bool> value);
    public sealed virtual void Dispose();
    public static void Validate(IntelliTraceStore store, string filename, CollectionPlanSettings collectionPlanSettings);
    public static void ValidateCallStackStateMachinesTimingData(IntelliTraceStore store);
    public static void ValidateDiagnosticEventsTimingData(IntelliTraceStore store);
    public static void ValidateBeforeFlush(IntelliTraceStore store);
    public void Execute(Action action);
    public void FlushFileHeader();
    public void FlushInitialCheckpoints();
    public void FlushFile();
    public void FlushThreadDestroy();
    public void FlushFileMetadata();
    public void Snapshot(string snapshotFileName);
    private void FlushThreadDestroy(IntelliTraceFile file, OrdinalManager ordinalManager, bool resetThreadStreamStates);
    private void FlushFileMetadata(IntelliTraceFile file, OrdinalManager ordinalManager);
    private bool HasScopedEvents();
    private void RewriteConfiguration();
    private void WriteDiagnosticEvent(OrdinalRange range, DiagnosticEvent diagEvent, IEnumerable`1<CallStackFrame> previousStack, CallStackCreationModes callStackCreationModes);
    private void WriteProcessInfoEvent();
    private void WriteSystemInfo();
    private _ModuleLoaded WriteOnModuleLoadedEvent(IntelliTraceFile file, OrdinalManager ordinalManager, ModuleIdManager moduleIdManager, MetadataModule module);
    private void WriteModuleLoadedEvent(MetadataModule module);
    public void FlushCheckpoints();
    private void WriteDiagnosticCheckpoint(long ordinal);
    private void WriteThreadCheckpoint(ThreadEventStreamState state, long ordinal);
    private void WriteThreadCreateEvent(ThreadEventStreamState threadState, OrdinalRange range);
    private void WriteThreadDestroyEvent(IntelliTraceFile file, OrdinalManager ordinalManager, ThreadEventStreamState threadState, bool resetThreadStreamStates);
    private void WriteScopedEvents(OrdinalRange range);
    private void WriteScopedEvent(LogStream requestStream, LogStream threadStream, int requestId, OrdinalRange range, IScoped ev);
    private int WriteThreadAssociations(LogStream threadStream, int requestId, OrdinalRange range, IThreadAssociated ev, int length);
    private _WebRequest ToMessagePackerWebRequest(LogStream threadStream, int requestId, OrdinalRange range, WebRequestEvent request);
    private _WebRequest ToMessagePackerWebRequest(LogStream threadStream, int requestId, OrdinalRange range, IScopedThreadEvent ev);
    private static _DescriptionRelatedEvents ToDescriptionData(CallStackFrameImpl frame);
    private void WriteDiagnosticEventInThreadStream(LogStream stream, ThreadEventStreamState streamState, OrdinalRange range, DiagnosticEvent diagEvent);
    private void WriteExceptionEvent(ThreadEventStreamState threadState, ExceptionEvent exception, OrdinalRange range, IEnumerable`1<CallStackFrame> previousStack, CallStackCreationModes callStackCreationModes);
    private void WriteClassicDataQueryEvent(ThreadEventStreamState state, ClassicDataQueryEventImpl dq, OrdinalRange range, IEnumerable`1<CallStackFrame> previousStack, CallStackCreationModes callStackCreationModes);
    private void WriteParameterData(ThreadEventStreamState threadState, DiagnosticEvent diagnosticEvent, OrdinalRange range);
    private void WriteCallStackStateMachine(OrdinalRange range, CallStackStateMachineImpl stateMachine);
    private void WriteCallStackStateMachine(LogStream stream, ThreadEventStreamState streamState, CallStackFrameSerializer callStackSerializer, OrdinalRange range, TreeNode node);
    private void WriteMethodEnterEvent(LogStream stream, ThreadEventStreamState streamState, CallStackFrameSerializer callStackSerializer, OrdinalRange range, CallStackFrameImpl frame, CallStackFrameImpl nextframe);
    private void WriteMethodExitEvent(LogStream stream, ThreadEventStreamState streamState, CallStackFrameSerializer callStackSerializer, OrdinalRange range, CallStackFrameImpl frame);
    private void WriteSavedMetadata(IntelliTraceFile file);
    private void WriteIntelliTraceToken(IntelliTraceFile file, OrdinalManager ordinalManager);
    private void WriteBuildInformationEvents(BuildInformationEvents infoEvents);
    private CreationOptions GetCreateOptions();
    private LaunchType GetLaunchType();
    private _CollectionPlan CreateCollectionPlan();
    private void MergeDataQueryConfiguration(_CollectionPlan cp);
    private void ConvertStackFrame(FrameType[]& stackFrames, Int32& stackFramesInCommon, Func`2<CallStackFrame, FrameType> frameConverter, IEnumerable`1<CallStackFrame> previousStack, IEnumerable`1<CallStackFrame> stack);
    private _StackFrame ToThreadEventStackFrame(CallStackFrame frame);
    private _StackFrame ToIndependentEventFrame(CallStackFrame frame);
    private static int CountFramesInCommon(IEnumerable`1<CallStackFrame> previousStack, IEnumerable`1<CallStackFrame> stack);
    private void ThrowIfDisposed();
    private static _CollectionPlanFragment CreateFragment(DataQueryEventSpecification dq);
    private static _DataQuery[] CreateQueries(DataQueryEventSpecification dq);
    private static ClrType ToClrType(MetadataType metadataType);
    private static void WriteString(BinaryWriter writer, string s);
    private static IEnumerable`1<object> WeaveThreadEvents(TreeNode node);
    [CompilerGeneratedAttribute]
private _StackFrame <WriteDiagnosticEventInThreadStream>b__90_0(CallStackFrame frame);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.StateMachineCallStackFrame : CallStackFrameImpl {
    [CompilerGeneratedAttribute]
private TreeNode <Node>k__BackingField;
    private Nullable`1<TimeSpan> _selfTime;
    public TreeNode Node { get; private set; }
    public bool HasTimingData { get; }
    public Nullable`1<DateTime> StartTime { get; }
    public Nullable`1<DateTime> EndTime { get; }
    public Nullable`1<TimeSpan> TotalTime { get; }
    public Nullable`1<TimeSpan> SelfTime { get; }
    public string Name { get; }
    public IEnumerable`1<ICallTreeNode> Children { get; }
    public StateMachineCallStackFrame(TreeNode node, MetadataMethod method, int ilOffset);
    [CompilerGeneratedAttribute]
public TreeNode get_Node();
    [CompilerGeneratedAttribute]
private void set_Node(TreeNode value);
    public sealed virtual bool get_HasTimingData();
    public sealed virtual Nullable`1<DateTime> get_StartTime();
    public sealed virtual Nullable`1<DateTime> get_EndTime();
    public sealed virtual Nullable`1<TimeSpan> get_TotalTime();
    public sealed virtual Nullable`1<TimeSpan> get_SelfTime();
    public sealed virtual string get_Name();
    public sealed virtual IEnumerable`1<ICallTreeNode> get_Children();
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ThreadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Thread <Thread>k__BackingField;
    public Thread Thread { get; private set; }
    protected ThreadEventArgs(Thread thread);
    [CompilerGeneratedAttribute]
public Thread get_Thread();
    [CompilerGeneratedAttribute]
private void set_Thread(Thread value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.ThreadImpl : Thread {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <InternalOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOpenScope>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ReservedCheckpointOrdinal>k__BackingField;
    public int Id { get; protected set; }
    public DateTime StartTime { get; protected set; }
    public DateTime EndTime { get; public set; }
    public string Name { get; public set; }
    public long InternalOrdinal { get; public set; }
    public bool HasOpenScope { get; public set; }
    public long ReservedCheckpointOrdinal { get; public set; }
    internal ThreadImpl(int id, DateTime startTime, DateTime endTime);
    [CompilerGeneratedAttribute]
public virtual int get_Id();
    [CompilerGeneratedAttribute]
protected virtual void set_Id(int value);
    [CompilerGeneratedAttribute]
public virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
protected virtual void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public virtual DateTime get_EndTime();
    [CompilerGeneratedAttribute]
public virtual void set_EndTime(DateTime value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_InternalOrdinal();
    [CompilerGeneratedAttribute]
public sealed virtual void set_InternalOrdinal(long value);
    [CompilerGeneratedAttribute]
public bool get_HasOpenScope();
    [CompilerGeneratedAttribute]
public void set_HasOpenScope(bool value);
    [CompilerGeneratedAttribute]
public long get_ReservedCheckpointOrdinal();
    [CompilerGeneratedAttribute]
public void set_ReservedCheckpointOrdinal(long value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.TimingDataImpl : TimingData {
    private ObjectValidityState _objectState;
    private DateTime _startTime;
    private DateTime _endTime;
    private TimeSpan _totalTime;
    public DateTime StartTime { get; public set; }
    public DateTime EndTime { get; public set; }
    public TimeSpan TotalTime { get; public set; }
    public bool HasNoData { get; }
    public bool HasFullData { get; }
    public bool HasPartialData { get; }
    public virtual DateTime get_StartTime();
    public virtual void set_StartTime(DateTime value);
    public virtual DateTime get_EndTime();
    public virtual void set_EndTime(DateTime value);
    public virtual TimeSpan get_TotalTime();
    public virtual void set_TotalTime(TimeSpan value);
    public bool get_HasNoData();
    public bool get_HasFullData();
    public bool get_HasPartialData();
    public sealed virtual void VerifyObjectValidity();
    public sealed virtual void SetObjectValidityState(ObjectValidityState state);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.TimingDataSerializer : ExtendedBlobSerializer {
    private TimingDataCodec _timingDataCodec;
    public TimingDataSerializer(DateTime logStartTime, ulong qpcStartTime, ulong qpcFrequency);
    public void PackTimingDataAtEnter(CallStackFrame frame, CorProfBlobPacker packer);
    public void PackTimingDataAtReturn(CallStackFrame frame, CorProfBlobPacker packer);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.Impl.TokenKey : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    internal Guid Guid { get; internal set; }
    internal int Token { get; internal set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal Guid get_Guid();
    [CompilerGeneratedAttribute]
internal void set_Guid(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal int get_Token();
    [CompilerGeneratedAttribute]
internal void set_Token(int value);
    public virtual int GetHashCode();
    public static bool op_Equality(TokenKey a, TokenKey b);
    public static bool op_Inequality(TokenKey a, TokenKey b);
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(TokenKey other);
}
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.IntelliTrace.ObjectModel.IntelliTraceFileSerializerFactory : object {
    public static int UnboundedFileSize;
    public static IntelliTraceFileSerializer CreateIntelliTraceFileSerializer();
    private static IntelliTraceFileSerializer CreateIntelliTraceFileSerializer(int blockSize, long maximumBlockCount);
    public static IntelliTraceFileSerializer CreateIntelliTraceFileSerializer(int mbSize);
}
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.IntelliTrace.ObjectModel.IntelliTraceIncrementalFileSerializerFactory : object {
    public static int UnboundedFileSize;
    public static IntelliTraceIncrementalFileSerializer CreateIntelliTraceIncrementalFileSerializer(IntelliTraceStore store, string filename, int blockSize, long maximumBlockCount);
    public static IntelliTraceIncrementalFileSerializer CreateIntelliTraceIncrementalFileSerializer(IntelliTraceStore store, string filename, int mbSize);
}
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.IntelliTrace.ObjectModel.IntelliTraceStoreFactory : object {
    public static IntelliTraceStore CreateIntelliTraceStore();
    public static IntelliTraceStore CreateIntelliTraceStore(string providerName);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectModel.ObjectModelResources : object {
    internal static ResourceManager ResourceManager;
    public static string AssertMissingNullableValue { get; }
    public static string AssertPointerSize { get; }
    public static string ExceptionNullableValueHasNonPrimitiveFieldValue { get; }
    public static string ExceptionNestedArrayHasNullableElement { get; }
    public static string ExceptionCycle { get; }
    public static string ExceptionGenericParameter { get; }
    public static string ExceptionGenericType { get; }
    public static string ExceptionReusingStack { get; }
    public static string ExceptionUnexpectedCycleData { get; }
    public static string ExceptionUnexpectedData { get; }
    public static string ExceptionUnknownCycle { get; }
    public static string ExceptionVoidReturn { get; }
    public static string ExceptionCannotCreateAbstractClass { get; }
    public static string ExceptionCannotCreateInterfaceInstance { get; }
    public static string ExceptionInvalidArraySize { get; }
    public static string ExceptionInvalidArrayType { get; }
    public static string ExceptionMethodOccurenceCount { get; }
    public static string ExceptionNoValidMethodName { get; }
    public static string ExceptionNoValidTypeName { get; }
    public static string ExceptionMixedModeCallStackCreationName { get; }
    public static string DefaultTimingStartString { get; }
    public static string DefaultTimingTotalString { get; }
    public static string DefaultTimingEndString { get; }
    public static string DefaultTimingMethodNameString { get; }
    public static string ExceptionMissingStringType { get; }
    public static string DefaultTimingDescriptionName { get; }
    public static string ExceptionCallStackStateMachineNotEmpty { get; }
    public static string ExceptionCallStackStateMachineNotEmptyBeforeFlush { get; }
    public static string ExceptionScopesNotEmptyBeforeFlush { get; }
    public static string ExceptionInvalidObjectState { get; }
    public static string ExceptionNonScopedCallStackFramesPopped { get; }
    public static string ExceptionPerformanceEventScopeMismatch { get; }
    public static string ExceptionScopeAlreadyOpen { get; }
    public static string ExceptionMixedPerformanceEvents { get; }
    public static string ExceptionInvalidEventTime { get; }
    public static string ExceptionPerformanceEventCanOnlyHaveOneScope { get; }
    public static string ExceptionPerformanceEventMultipleRoots { get; }
    public static string ExceptionTypedByRefField { get; }
    public static string ExceptionTypedByRefValue { get; }
    public static string ExceptionTypedByRefArray { get; }
    public static string ExceptionEndTimeBeforeLogFileStartTimeName { get; }
    public static string ExceptionStartTimeBeforeLogFileStartTimeName { get; }
    private static ObjectModelResources();
    public static string get_AssertMissingNullableValue();
    public static string get_AssertPointerSize();
    public static string get_ExceptionNullableValueHasNonPrimitiveFieldValue();
    public static string get_ExceptionNestedArrayHasNullableElement();
    public static string get_ExceptionCycle();
    public static string get_ExceptionGenericParameter();
    public static string get_ExceptionGenericType();
    public static string get_ExceptionReusingStack();
    public static string get_ExceptionUnexpectedCycleData();
    public static string get_ExceptionUnexpectedData();
    public static string get_ExceptionUnknownCycle();
    public static string get_ExceptionVoidReturn();
    public static string get_ExceptionCannotCreateAbstractClass();
    public static string get_ExceptionCannotCreateInterfaceInstance();
    public static string get_ExceptionInvalidArraySize();
    public static string get_ExceptionInvalidArrayType();
    public static string ExceptionInvalidArrayTypeSpec(object param0);
    public static string ExceptionInvalidClassType(object param0);
    public static string ExceptionInvalidAssignment(object param0, object param1);
    public static string ExceptionInvalidNullAssignment(object param0);
    public static string get_ExceptionMethodOccurenceCount();
    public static string get_ExceptionNoValidMethodName();
    public static string get_ExceptionNoValidTypeName();
    public static string get_ExceptionMixedModeCallStackCreationName();
    public static string DefaultTimingDataQueryLongDescription(object param0, object param1);
    public static string DefaultTimingDataQueryShortDescription(object param0);
    public static string get_DefaultTimingStartString();
    public static string get_DefaultTimingTotalString();
    public static string get_DefaultTimingEndString();
    public static string get_DefaultTimingMethodNameString();
    public static string get_ExceptionMissingStringType();
    public static string ExceptionTimingDataBeforeStartTimeName(object param0);
    public static string ExceptionMissingTimingDataName(object param0);
    public static string ExceptionTimeNotWithinRange(object param0, object param1);
    public static string ExceptionStartTimeIsNotInRange(object param0, object param1);
    public static string ExceptionEndTimeIsNotInRange(object param0, object param1);
    public static string ExceptionSiblingStartTimeNotInRange(object param0, object param1);
    public static string ExceptionInvalidTimingData(object param0);
    public static string ExceptionTimingDataNotInThreadTimeRange(object param0);
    public static string ExceptionTotalTimeNotInRange(object param0);
    public static string get_DefaultTimingDescriptionName();
    public static string ExceptionParameterOutOfRange(object param0);
    public static string ExceptionMissingMsCorlibType(object param0);
    public static string get_ExceptionCallStackStateMachineNotEmpty();
    public static string get_ExceptionCallStackStateMachineNotEmptyBeforeFlush();
    public static string get_ExceptionScopesNotEmptyBeforeFlush();
    public static string get_ExceptionInvalidObjectState();
    public static string get_ExceptionNonScopedCallStackFramesPopped();
    public static string get_ExceptionPerformanceEventScopeMismatch();
    public static string get_ExceptionScopeAlreadyOpen();
    public static string ExceptionFrameNotCreatedByStateMachine(object param0);
    public static string ExceptionObjectsOutOfOrder(object param0, object param1);
    public static string get_ExceptionMixedPerformanceEvents();
    public static string get_ExceptionInvalidEventTime();
    public static string get_ExceptionPerformanceEventCanOnlyHaveOneScope();
    public static string get_ExceptionPerformanceEventMultipleRoots();
    public static string ExceptionInvalidNullData(object param0);
    public static string get_ExceptionTypedByRefField();
    public static string get_ExceptionTypedByRefValue();
    public static string get_ExceptionTypedByRefArray();
    public static string get_ExceptionEndTimeBeforeLogFileStartTimeName();
    public static string get_ExceptionStartTimeBeforeLogFileStartTimeName();
    public static string ExceptionCategoryVersion(object param0, object param1, object param2);
    public static string ExceptionNoDataProviderName(object param0, object param1);
}
internal class Microsoft.VisualStudio.IntelliTrace.ObjectUnpacker : BlobUnpacker {
    private IEnumerable`1<FieldLayout> _fields;
    private IEnumerator`1<FieldLayout> _fieldEnum;
    public bool SupportsNullables { get; }
    public bool ArraysHaveElementTypeToken { get; }
    internal IEnumerable`1<FieldLayout> Fields { get; }
    public ObjectUnpacker(IEnumerable`1<FieldLayout> fields, int pointerSizeBytes);
    public virtual void BeforeUnpack(int typeSize);
    public virtual void AfterUnpack(int typeSize);
    public virtual bool get_SupportsNullables();
    public virtual bool get_ArraysHaveElementTypeToken();
    internal IEnumerable`1<FieldLayout> get_Fields();
    private FieldType FieldTypeOfType();
    private UnpackResult Unpack(T& value);
    public virtual UnpackResult Unpack(Boolean& value);
    public virtual UnpackResult Unpack(SByte& value);
    public virtual UnpackResult Unpack(Byte& value);
    public virtual UnpackResult Unpack(Char& value);
    public virtual UnpackResult Unpack(Int16& value);
    public virtual UnpackResult Unpack(UInt16& value);
    public virtual UnpackResult Unpack(Int32& value);
    public virtual UnpackResult Unpack(UInt32& value);
    public virtual UnpackResult Unpack(Int64& value);
    public virtual UnpackResult Unpack(UInt64& value);
    public virtual UnpackResult Unpack(Single& value);
    public virtual UnpackResult Unpack(Double& value);
    public virtual UnpackResult Unpack(Decimal& value);
    public virtual UnpackResult Unpack(IntPtr& value);
    public virtual UnpackResult Unpack(UIntPtr& value);
    public virtual object UnpackIntPtr(UnpackResult& result);
    public virtual object UnpackUIntPtr(UnpackResult& result);
    public virtual UnpackResult Unpack(String& value, Int32& originalSize);
    public virtual UnpackResult Unpack(bool isNestedField, Type elementType, BlobUnpacker& value, ArrayDimensionLayout[] dimensions, Int16& savedElements);
    public virtual UnpackResult UnpackLength(Int32& length);
    public virtual int UnpackInvalidRefDepth();
    public virtual UnpackResult Unpack(BlobUnpacker& unpacker, ObjectLayout layout, bool isValueType);
    public object GetNextData();
    public Type GetCurrentFieldType();
    public virtual UnpackResult Unpack(BlobUnpacker& value);
    public virtual UnpackResult UnpackRest(BlobUnpacker& value);
}
public class Microsoft.VisualStudio.IntelliTrace.OrdinalEvent : IntelliTraceEvent {
    [CompilerGeneratedAttribute]
private long <Ordinal>k__BackingField;
    public long Ordinal { get; protected set; }
    protected OrdinalEvent(long ordinal);
    [CompilerGeneratedAttribute]
public long get_Ordinal();
    [CompilerGeneratedAttribute]
protected void set_Ordinal(long value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int Compare(OrdinalEvent x, OrdinalEvent y);
    public sealed virtual int CompareTo(OrdinalEvent other);
    public virtual bool Equals(object other);
    public static bool Equals(OrdinalEvent first, OrdinalEvent second);
    public virtual int GetHashCode();
    public static bool op_GreaterThan(OrdinalEvent first, OrdinalEvent second);
    public static bool op_LessThan(OrdinalEvent first, OrdinalEvent second);
    public static bool op_Equality(OrdinalEvent first, OrdinalEvent second);
    public static bool op_Inequality(OrdinalEvent first, OrdinalEvent second);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.PackOptions : Enum {
    public int value__;
    public static PackOptions None;
    public static PackOptions Is64Bit;
    public static PackOptions StringsCompressed;
}
internal class Microsoft.VisualStudio.IntelliTrace.Partition`1 : object {
    private IList`1<T> items;
    private WeakReference weakRef;
    private long startIndex;
    private int count;
    public long StartIndex { get; }
    public long EndIndex { get; }
    public int Count { get; }
    public IList`1<T> Items { get; public set; }
    public bool IsLoaded { get; }
    public void Initialize(long startIndex, int count);
    public void ReleaseItems();
    public bool TryRecoverItems();
    public void AddItems(IList`1<T> addItems);
    public void GrowItemCount(int growByAmount);
    public long get_StartIndex();
    public long get_EndIndex();
    public int get_Count();
    public IList`1<T> get_Items();
    public void set_Items(IList`1<T> value);
    public bool get_IsLoaded();
}
internal class Microsoft.VisualStudio.IntelliTrace.PartitionCache : object {
    private LinkedList`1<PartitionCacheEntry> _usedPartitions;
    private int _maxLoadedPartitions;
    internal int MaxLoadedPartitions { get; }
    internal PartitionCache(int maxLoadedPartitions);
    internal int get_MaxLoadedPartitions();
    internal void OnPartitionAccess(ChainPartition partition, PartitionedList`2<IntelliTraceEvent, ChainPartition> partitionedList);
    internal void OnPartitionLoad(ChainPartition partition, PartitionedList`2<IntelliTraceEvent, ChainPartition> partitionedList);
    internal void OnPartitionUnload(ChainPartition partition, PartitionedList`2<IntelliTraceEvent, ChainPartition> partitionedList);
}
internal class Microsoft.VisualStudio.IntelliTrace.PartitionCacheEntry : object {
    [CompilerGeneratedAttribute]
private ChainPartition <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionedList`2<IntelliTraceEvent, ChainPartition> <PartitionedList>k__BackingField;
    internal ChainPartition Partition { get; internal set; }
    internal PartitionedList`2<IntelliTraceEvent, ChainPartition> PartitionedList { get; internal set; }
    [CompilerGeneratedAttribute]
internal ChainPartition get_Partition();
    [CompilerGeneratedAttribute]
internal void set_Partition(ChainPartition value);
    [CompilerGeneratedAttribute]
internal PartitionedList`2<IntelliTraceEvent, ChainPartition> get_PartitionedList();
    [CompilerGeneratedAttribute]
internal void set_PartitionedList(PartitionedList`2<IntelliTraceEvent, ChainPartition> value);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.IntelliTrace.PartitionedList`2 : object {
    private List`1<TPartition> partitions;
    private long itemCount;
    private int loadedPartitionCount;
    private int firstValidPartitionIndex;
    [CompilerGeneratedAttribute]
private EventHandler`1<LoadPartitionEventArgs`1<T>> PartitionLoad;
    [CompilerGeneratedAttribute]
private EventHandler`1<UnloadPartitionEventArgs`1<T>> PartitionUnload;
    public T Item { get; }
    public long ItemCount { get; private set; }
    public int PartitionCount { get; }
    public int LoadedPartitionCount { get; }
    public TPartition FirstPartition { get; }
    public TPartition LastPartition { get; }
    public int LastPartitionIndex { get; }
    public int FirstValidPartitionIndex { get; public set; }
    public long FirstValidItemIndex { get; }
    public TPartition FirstValidPartition { get; }
    public PartitionItemLink BeforeFirstItemLink { get; }
    public PartitionItemLink FirstItemLink { get; }
    public PartitionItemLink FirstValidItemLink { get; }
    public PartitionItemLink LastItemLink { get; }
    public long LastItemIndex { get; }
    public PartitionItemLink AfterLastItemLink { get; }
    public PartitionedList`2(Int32[] partitionLengths);
    [CompilerGeneratedAttribute]
public void add_PartitionLoad(EventHandler`1<LoadPartitionEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void remove_PartitionLoad(EventHandler`1<LoadPartitionEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void add_PartitionUnload(EventHandler`1<UnloadPartitionEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void remove_PartitionUnload(EventHandler`1<UnloadPartitionEventArgs`1<T>> value);
    public T get_Item(PartitionItemLink link);
    public long get_ItemCount();
    private void set_ItemCount(long value);
    public int get_PartitionCount();
    public int get_LoadedPartitionCount();
    public TPartition get_FirstPartition();
    public TPartition get_LastPartition();
    public int get_LastPartitionIndex();
    public int get_FirstValidPartitionIndex();
    public void set_FirstValidPartitionIndex(int value);
    public long get_FirstValidItemIndex();
    public TPartition get_FirstValidPartition();
    public PartitionItemLink get_BeforeFirstItemLink();
    public PartitionItemLink get_FirstItemLink();
    public PartitionItemLink get_FirstValidItemLink();
    public PartitionItemLink get_LastItemLink();
    public long get_LastItemIndex();
    public PartitionItemLink get_AfterLastItemLink();
    public void AddPartition(int partitionLength);
    public void AddPartitions(Int32[] partitionLengths);
    public void GrowLastPartition(int growByAmount);
    public void AddToLastPartition(IList`1<T> items);
    public void GrowLastAndAddPartition(int growByAmount, int partitionLength);
    public void GrowLastAndAddPartitions(int growByAmount, Int32[] partitionLengths);
    public void UnloadPartition(int partitionIndex);
    public void UnloadPartition(TPartition partition);
    public void LoadPartition(int partitionIndex);
    public void LoadPartition(TPartition partition);
    public TPartition GetPartition(int partitionIndex);
    public PartitionItemLink ItemIndexToItemLink(long itemIndex);
    public int PartitionIndexFromItemIndex(long itemIndex);
    public PartitionItemLink IncrementItemLink(PartitionItemLink link);
    public PartitionItemLink DecrementItemLink(PartitionItemLink link);
    public bool IsValidItemIndex(long itemIndex);
    public bool IsValidLink(PartitionItemLink link);
    private void InternalAddPartitions(Int32[] partitionLengths);
    private void InternalGrowLastPartition(int growByAmount);
    private int InternalPartitionIndexFromItemIndex(long itemIndex);
    private void FirePartitionLoadEvent(Partition`1<T> partition);
    private void FirePartitionUnloadEvent(Partition`1<T> partition);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class Microsoft.VisualStudio.IntelliTrace.PartitionedListChain : DerivedChain {
    private PartitionedList`2<IntelliTraceEvent, ChainPartition> events;
    private EventToken trackedStreamToken;
    private EventToken trackedPartitioningToken;
    private EventToken firstValidPartitioningToken;
    private EventToken firstValidPartitionedToken;
    private StreamChain partitionedChain;
    private DerivedChain partitioningChain;
    private PartitionCache partitionCache;
    protected internal DerivedChain PartitioningChain { get; }
    protected internal StreamChain PartitionedChain { get; }
    public bool PartitionLoadLimitEnabled { get; }
    public bool IsEmpty { get; }
    public EventToken BeforeFirstToken { get; }
    public EventToken FirstToken { get; }
    public EventToken FirstValidToken { get; }
    public EventToken LastToken { get; }
    public bool CanGetLastToken { get; }
    public EventToken AfterLastToken { get; }
    public bool CanGetCount { get; }
    public long Count { get; }
    internal PartitionedListChain(StreamChain partitionedChain, DerivedChain partitioningChain);
    internal PartitionedListChain(StreamChain partitionedChain, DerivedChain partitioningChain, PartitionCache partitionCache);
    protected internal DerivedChain get_PartitioningChain();
    protected internal StreamChain get_PartitionedChain();
    public bool get_PartitionLoadLimitEnabled();
    private void OnPartitionLoad(object sender, LoadPartitionEventArgs`1<IntelliTraceEvent> args);
    private void OnPartitionUnload(object sender, UnloadPartitionEventArgs`1<IntelliTraceEvent> args);
    protected virtual void OnPartitionUpdate(PartitioningEvent partitioningEvent, IList`1<IntelliTraceEvent> events);
    public virtual IntelliTraceEvent GetEvent(EventToken token);
    public virtual IList`1<IntelliTraceEvent> GetEvents(EventToken startToken, EventToken endToken);
    public virtual bool get_IsEmpty();
    public virtual EventToken get_BeforeFirstToken();
    public virtual EventToken get_FirstToken();
    public virtual EventToken get_FirstValidToken();
    public virtual EventToken get_LastToken();
    public virtual bool get_CanGetLastToken();
    public virtual EventToken get_AfterLastToken();
    public virtual EventToken GetNextToken(EventToken token);
    public virtual EventToken GetPreviousToken(EventToken token);
    public virtual bool get_CanGetCount();
    public virtual long get_Count();
    public virtual void Refresh();
    protected virtual void Dispose(bool disposing);
    public virtual bool IsValidToken(EventToken token);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
}
internal class Microsoft.VisualStudio.IntelliTrace.PartitionedListEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private Partition`1<T> <Partition>k__BackingField;
    public Partition`1<T> Partition { get; private set; }
    public PartitionedListEventArgs`1(Partition`1<T> partition);
    [CompilerGeneratedAttribute]
public Partition`1<T> get_Partition();
    [CompilerGeneratedAttribute]
private void set_Partition(Partition`1<T> value);
}
public class Microsoft.VisualStudio.IntelliTrace.PartitioningEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private long <StreamOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StreamOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FirstVisibleStreamOrdinal>k__BackingField;
    internal long StreamOrdinal { get; private set; }
    internal long StreamOffset { get; private set; }
    internal long FirstVisibleStreamOrdinal { get; internal set; }
    public EventToken EventToken { get; }
    internal PartitioningEvent(long ordinal, long streamOrdinal, long streamOffset, long firstVisibleStreamOrdinal);
    [CompilerGeneratedAttribute]
internal long get_StreamOrdinal();
    [CompilerGeneratedAttribute]
private void set_StreamOrdinal(long value);
    [CompilerGeneratedAttribute]
internal long get_StreamOffset();
    [CompilerGeneratedAttribute]
private void set_StreamOffset(long value);
    [CompilerGeneratedAttribute]
internal long get_FirstVisibleStreamOrdinal();
    [CompilerGeneratedAttribute]
internal void set_FirstVisibleStreamOrdinal(long value);
    public EventToken get_EventToken();
}
internal class Microsoft.VisualStudio.IntelliTrace.PartitionItemLink : ValueType {
    internal int partitionIndex;
    internal int relativeItemIndex;
    public int PartitionIndex { get; }
    public int RelativeItemIndex { get; }
    public PartitionItemLink(long token);
    public PartitionItemLink(int partitionIndex, int relativeItemIndex);
    public int get_PartitionIndex();
    public int get_RelativeItemIndex();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static long op_Explicit(PartitionItemLink link);
    public virtual int GetHashCode();
    public static bool op_Equality(PartitionItemLink left, PartitionItemLink right);
    public static bool op_Inequality(PartitionItemLink left, PartitionItemLink right);
    public static bool op_LessThan(PartitionItemLink left, PartitionItemLink right);
    public static bool op_LessThanOrEqual(PartitionItemLink left, PartitionItemLink right);
    public static bool op_GreaterThan(PartitionItemLink left, PartitionItemLink right);
    public static bool op_GreaterThanOrEqual(PartitionItemLink left, PartitionItemLink right);
}
internal class Microsoft.VisualStudio.IntelliTrace.PerformanceDataEvent : WebScopedEvent {
    private List`1<ScopedData> _scopedData;
    [CompilerGeneratedAttribute]
private PerformanceEventDescriptionData <RootEventDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceEventDescriptionData <HeaviestMethodDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AlertThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Build>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLightEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ObjectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserHostAddress>k__BackingField;
    public IEnumerable`1<ScopedData> ScopedData { get; }
    public IEnumerable`1<ScopedData> AllScopedData { get; }
    public PerformanceEventDescriptionData RootEventDetails { get; private set; }
    public PerformanceEventDescriptionData HeaviestMethodDetails { get; private set; }
    public long Duration { get; private set; }
    public string Source { get; private set; }
    public int AlertThreshold { get; private set; }
    public string ApplicationPath { get; private set; }
    public string Build { get; private set; }
    public string Component { get; private set; }
    public bool IsLightEvent { get; public set; }
    public string ObjectUri { get; private set; }
    public string UserHostAddress { get; private set; }
    public PerformanceDataEvent(EventToken token, long ordinal);
    public PerformanceDataEvent(EventToken token, _WebRequest webRequest);
    private bool ProcessWellKnownValues(string category, string key, object value);
    public IEnumerable`1<ScopedData> get_ScopedData();
    public IEnumerable`1<ScopedData> get_AllScopedData();
    [CompilerGeneratedAttribute]
public PerformanceEventDescriptionData get_RootEventDetails();
    [CompilerGeneratedAttribute]
private void set_RootEventDetails(PerformanceEventDescriptionData value);
    [CompilerGeneratedAttribute]
public PerformanceEventDescriptionData get_HeaviestMethodDetails();
    [CompilerGeneratedAttribute]
private void set_HeaviestMethodDetails(PerformanceEventDescriptionData value);
    [CompilerGeneratedAttribute]
public long get_Duration();
    [CompilerGeneratedAttribute]
private void set_Duration(long value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(string value);
    [CompilerGeneratedAttribute]
public int get_AlertThreshold();
    [CompilerGeneratedAttribute]
private void set_AlertThreshold(int value);
    [CompilerGeneratedAttribute]
public string get_ApplicationPath();
    [CompilerGeneratedAttribute]
private void set_ApplicationPath(string value);
    [CompilerGeneratedAttribute]
public string get_Build();
    [CompilerGeneratedAttribute]
private void set_Build(string value);
    [CompilerGeneratedAttribute]
public string get_Component();
    [CompilerGeneratedAttribute]
private void set_Component(string value);
    [CompilerGeneratedAttribute]
public bool get_IsLightEvent();
    [CompilerGeneratedAttribute]
public void set_IsLightEvent(bool value);
    [CompilerGeneratedAttribute]
public string get_ObjectUri();
    [CompilerGeneratedAttribute]
private void set_ObjectUri(string value);
    [CompilerGeneratedAttribute]
public string get_UserHostAddress();
    [CompilerGeneratedAttribute]
private void set_UserHostAddress(string value);
}
internal class Microsoft.VisualStudio.IntelliTrace.PerformanceEventDescriptionData : object {
    public long EnterEventOffset;
    public long ExitEventOffset;
    public long DiagnosticEventOffset;
    public bool HasDiagnosticEvent { get; }
    public PerformanceEventDescriptionData(long enterEventOffset, long exitEventOffset, long diagnosticEventOffset);
    public bool get_HasDiagnosticEvent();
    public DiagnosticEvent ReadDiagnosticEvent(DiagnosticStreamChain chain);
    public MethodEnterEvent ReadMethodEnterEvent(ThreadStreamChain chain);
    public MethodExitEvent ReadMethodExitEvent(ThreadStreamChain chain);
    private static T ReadEvent(StreamChain chain, long offset);
}
internal class Microsoft.VisualStudio.IntelliTrace.PerformanceEventTracker : ScopedEventTracker`1<PerformanceDataEvent> {
    public PerformanceEventTracker(IntelliTraceFileBase file);
}
internal class Microsoft.VisualStudio.IntelliTrace.PinnedHandleDispenser : object {
    private List`1<GCHandle> handleList;
    protected virtual override void Finalize();
    public IntPtr Alloc(object objToPin);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.IntelliTrace.PointerData : LogData {
    protected LogData _value;
    internal PointerData(DataUnavailableReason reason);
    internal PointerData(DataContext context, BlobUnpacker unpacker);
    internal LogData Dereference(Symbol elementSymbol);
}
internal class Microsoft.VisualStudio.IntelliTrace.PrimitiveData : LogData {
    internal PrimitiveData(DataUnavailableReason reason, bool partialData);
}
internal class Microsoft.VisualStudio.IntelliTrace.PrimitiveNullableNullData : PrimitiveData {
    internal string GetValue();
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.PrimitiveType : Enum {
    public int value__;
    public static PrimitiveType ptBool;
    public static PrimitiveType ptByte;
    public static PrimitiveType ptSByte;
    public static PrimitiveType ptWChar;
    public static PrimitiveType ptShort;
    public static PrimitiveType ptUShort;
    public static PrimitiveType ptInt;
    public static PrimitiveType ptUInt;
    public static PrimitiveType ptLong;
    public static PrimitiveType ptULong;
    public static PrimitiveType ptFloat;
    public static PrimitiveType ptDouble;
    public static PrimitiveType ptDecimal;
    public static PrimitiveType ptStringA;
    public static PrimitiveType ptStringW;
    public static PrimitiveType ptPointer;
    public static PrimitiveType ptTruncated;
    public static PrimitiveType ptInvalidRef;
    public static PrimitiveType ptFlagMask;
    public static PrimitiveType ptTypeMask;
}
public class Microsoft.VisualStudio.IntelliTrace.ProcessChain : ListChain {
    internal ProcessChain(ProcessStreamChain sourceChain);
}
public class Microsoft.VisualStudio.IntelliTrace.ProcessDestroyedEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    public long EventTime { get; private set; }
    internal ProcessDestroyedEvent(ProcessDestroyed* pData);
    [CompilerGeneratedAttribute]
public long get_EventTime();
    [CompilerGeneratedAttribute]
private void set_EventTime(long value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ProcessInformationEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ProcessCreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessBitWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessCommandLine>k__BackingField;
    public int ProcessId { get; private set; }
    public long ProcessCreationTime { get; private set; }
    public int SessionId { get; private set; }
    public string ProcessName { get; private set; }
    public int ProcessBitWidth { get; private set; }
    public string ProcessCommandLine { get; private set; }
    internal ProcessInformationEvent(ProcessInfo* pData);
    [CompilerGeneratedAttribute]
public int get_ProcessId();
    [CompilerGeneratedAttribute]
private void set_ProcessId(int value);
    [CompilerGeneratedAttribute]
public long get_ProcessCreationTime();
    [CompilerGeneratedAttribute]
private void set_ProcessCreationTime(long value);
    [CompilerGeneratedAttribute]
public int get_SessionId();
    [CompilerGeneratedAttribute]
private void set_SessionId(int value);
    [CompilerGeneratedAttribute]
public string get_ProcessName();
    [CompilerGeneratedAttribute]
private void set_ProcessName(string value);
    [CompilerGeneratedAttribute]
public int get_ProcessBitWidth();
    [CompilerGeneratedAttribute]
private void set_ProcessBitWidth(int value);
    [CompilerGeneratedAttribute]
public string get_ProcessCommandLine();
    [CompilerGeneratedAttribute]
private void set_ProcessCommandLine(string value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.ProcessManagerDispatcher : LogWorkerThread {
    private QueuedIpcPipeServer _ipc;
    private LoggerEngine _logger;
    private IntelliTraceFile _traceDebugLogFile;
    private ThreadMail _suspendMail;
    private LogStream _processStream;
    private TestCoverageManager _testCoverageManager;
    private int _notifyPointCheckpointRate;
    private long _nextNotifyPointCheckpointOrdinal;
    private _ThreadStackState[] _threadStackState;
    private long _notifyPointOrdinal;
    private bool _isFirstDiagnosticEvent;
    private bool _processAttached;
    private NamedCounter _eventCounter;
    private ProcessWaitHandle _attachedProcessHandle;
    private _ProcessInfo _attachedProcessInfo;
    private EventWaitHandle _attachReadyEvent;
    private Dictionary`2<ThreadMail, CallbackAction> _mailedRequests;
    private Dictionary`2<Guid, bool> _observedWebRequests;
    private Action _delayedAttachComplete;
    private int _delayedAttachClientId;
    private IMessageMemory2 _memory;
    private MessageMemoryByteArray _memory2;
    private object _thisLock;
    private bool _shuttingDown;
    private bool _disableProbesForFuncevalInSuspend;
    private bool _reconcileThreadCheckpointsWithNotifyPoints;
    private Dictionary`2<int, PerThreadState> _perThreadStates;
    private UInt32 _backgroundActions;
    private static long MaxBuildInfoSizeBytes;
    private static Type _dispenserType;
    private static int _ipcMaxEntrySize;
    private static int _ipcMaxEntries;
    private HashSet`1<UniqueModuleId> _uniqueLoadedModules;
    private TraceLoggerStartInfo _traceLoggerStartInfo;
    [CompilerGeneratedAttribute]
private bool <HasSharePointData>k__BackingField;
    private TraceLogger TraceLogger { get; }
    private TraceLoggerStartInfo TraceLoggerStartInfo { get; }
    private _CollectionPlan CollectionPlan { get; }
    private bool ContinueOnDiskFullException { get; }
    private bool HasLogFile { get; }
    private bool HasSharePointData { get; private set; }
    private static ProcessManagerDispatcher();
    private TraceLogger get_TraceLogger();
    private TraceLoggerStartInfo get_TraceLoggerStartInfo();
    private _CollectionPlan get_CollectionPlan();
    private bool get_ContinueOnDiskFullException();
    private bool get_HasLogFile();
    [CompilerGeneratedAttribute]
private bool get_HasSharePointData();
    [CompilerGeneratedAttribute]
private void set_HasSharePointData(bool value);
    protected virtual bool OnInitialize(LoggerEngine logger);
    protected virtual void OnThreadStartup();
    protected virtual void OnThreadEvent(int eventIndex);
    protected virtual bool OnThreadMessage(ThreadMail mail);
    protected virtual void OnPrepForShutdown();
    protected virtual void OnThreadShutdown();
    private void OnNotifyPointStreamOpen(int clientId);
    private void OnNotifyPointStreamClose(int clientId);
    private void OnNotifyPointCheckPointSync(int clientId, _DataPacket wrappedCPSync);
    private void WriteDiagnosticCheckpoint();
    private void OnProcessNotifyPoint(int clientId, _DataPacket wrappedNotifyHit);
    private void OnDebuggerAttach(int clientId, _ProcessInfo request);
    private void OnProfilerAttach(int clientId, _ProcessInfo request);
    private bool DoAttach(int clientId, _ProcessInfo request);
    private void PublishCollectionPlanToProfiler(int clientId);
    private void CompleteAttach(int clientId, _ProcessInfo request);
    private bool IsWorkerProcess(string fileName);
    private string GetAppPoolName(_ProcessInfo request);
    private bool IsAppPoolExcluded(_ProcessInfo request);
    private static object GetMetaDataInfo(string module, bool isTargetProcess64bit);
    private void OnModuleLoaded(int clientId, _ModuleLoaded moduleLoaded);
    private void OnModuleUnloaded(int clientId, QueuedIpcEntry message);
    private void QueueBackgroundAction(Action action);
    private void BackgroundActionCallback(object o);
    private void SaveModuleMetadata(string moduleName, Guid expectedGuid);
    private void WriteSharePointData();
    private void WriteSharePointData(WriteMessageAction writeAction);
    private void WriteSharePointDataToProcessStream(string fullPath, WriteMessageAction writeAction, SharePointSKU sku);
    private void OnModuleIsUserCode(int clientId, _ModuleIsUserCode moduleIsUserCode);
    private void OnThreadDestroyed(int clientId, _ThreadDestroyed pData);
    private void OnThreadCreated(int clientId, _ThreadCreated threadCreateData);
    private void OnThreadNameChanged(int clientId, _ThreadNameChanged threadNameChangedData);
    private void OnServerFault(int clientId, Exception ex);
    private void OnThreadStreamsRequest(int clientId, _ThreadID pData);
    private void OnTestEvent(int clientId, _DataPacket dataPacket);
    private void OnAllocCoverageBuffer(int clientId, _AllocCoverageBufferRequest request);
    private void OnFreeCoverageBuffer(int clientId, _FreeCoverageBuffer request);
    private void CreateLogCopy(int clientId, LogFile copyLog);
    private void OnRequestStatistics(int clientId);
    private void OnRequestLogCopy(int clientId, _LogCopyRequest _LogCopyRequest);
    private void OnRequestCoverageData(int clientId, _CoverageDataRequest request);
    private void OnCheckpoint(int clientId, _DataPacket dataPacket);
    private void OnWebSessionMessage(MessageID messageId, QueuedIpcEntry message);
    private void OnWebRequestMessage(MessageID messageId, QueuedIpcEntry message);
    private void OnWebThreadMessage(MessageID messageId, QueuedIpcEntry message);
    private void OnWebRequestBegin(int clientId, QueuedIpcEntry message, Boolean& checksResponse);
    private void OnWebRequestEnd(int clientId, QueuedIpcEntry message);
    private void OnModuleToken(int clientId, _ModuleToken moduleToken);
    private void OnModuleMetadata(int clientId, _ModuleMetadata moduleMetadata);
    private void OnRequestLoggerInfo(int clientId);
    private void OnBuildInfo(_BuildInfo buildInfo);
    private void CloseDownRunningThreads(long destroyedEventTime);
    private void CreatePerThreadState(int nativeThreadId, _ThreadCreated threadCreateEvent);
    private void DeletePerThreadState(int nativeThreadId);
    private PerThreadState GetPerThreadState(int nativeThreadId);
    private static string MakeIpcName(string loggerName);
    private void QueueSuspendCommand(ThreadMail suspendMail);
    private void TryProcessSuspendCommand();
    private _LoggerInfo BuildLoggerInfo(_ProcessInfo clientInfo);
}
public class Microsoft.VisualStudio.IntelliTrace.ProcessStreamChain : StreamChain {
    internal IMessageMemory2 memory;
    private ProcessEventsMessagePacker processPacker;
    private ConfigMessagePacker configPacker;
    internal ProcessStreamChain(LogStream stream, ProcessEventsMessagePacker processPacker, ConfigMessagePacker configPacker);
    protected virtual Byte[] ReadEventBytes();
    protected virtual int ReadEventLength();
    protected virtual IntelliTraceEvent ConvertToEvent(EventToken token, Byte[] data, Int32& offset);
    protected virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
}
public class Microsoft.VisualStudio.IntelliTrace.ProcessTraits : object {
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Pid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParentPid>k__BackingField;
    public string FullName { get; private set; }
    public string Arguments { get; private set; }
    public string Owner { get; private set; }
    public string Variables { get; private set; }
    public DateTime StartTime { get; private set; }
    public int Pid { get; private set; }
    public int ParentPid { get; private set; }
    internal ProcessTraits(string fullName, string arguments, string variables, string owner, DateTime startTime, int pid, int parentPid);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
private void set_FullName(string value);
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public string get_Owner();
    [CompilerGeneratedAttribute]
private void set_Owner(string value);
    [CompilerGeneratedAttribute]
public string get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(string value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public int get_Pid();
    [CompilerGeneratedAttribute]
private void set_Pid(int value);
    [CompilerGeneratedAttribute]
public int get_ParentPid();
    [CompilerGeneratedAttribute]
private void set_ParentPid(int value);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.ProfilerRegistrationMode : Enum {
    public int value__;
    public static ProfilerRegistrationMode None;
    public static ProfilerRegistrationMode x86;
    public static ProfilerRegistrationMode x64;
    public static ProfilerRegistrationMode Machine;
    public static ProfilerRegistrationMode CurrentUser;
}
internal class Microsoft.VisualStudio.IntelliTrace.ProgrammableDataQuerySpec : object {
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string ModuleName { get; private set; }
    public string TypeName { get; private set; }
    public ProgrammableDataQuerySpec(string moduleName, string typeName);
    public ProgrammableDataQuerySpec(_ProgrammableDataQuery pdq);
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
private void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
private void set_TypeName(string value);
}
internal class Microsoft.VisualStudio.IntelliTrace.QualifiedProgrammableDataQuerySpec : ProgrammableDataQuerySpec {
    [CompilerGeneratedAttribute]
private string <ModuleDirectory>k__BackingField;
    private string _qualifiedModule;
    private int _hashCode;
    public string ModuleDirectory { get; private set; }
    public string QualifiedModule { get; }
    public QualifiedProgrammableDataQuerySpec(string moduleName, string typeName, string moduleDirectory);
    [CompilerGeneratedAttribute]
public string get_ModuleDirectory();
    [CompilerGeneratedAttribute]
private void set_ModuleDirectory(string value);
    public string get_QualifiedModule();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
internal class Microsoft.VisualStudio.IntelliTrace.QueryArguments`2 : object {
    [CompilerGeneratedAttribute]
private Expr`2<T, R> <Formatter>k__BackingField;
    internal Expr`2<T, R> Formatter { get; private set; }
    internal QueryArguments`2(Expr`2<T, R> formatter);
    [CompilerGeneratedAttribute]
internal Expr`2<T, R> get_Formatter();
    [CompilerGeneratedAttribute]
private void set_Formatter(Expr`2<T, R> value);
}
internal class Microsoft.VisualStudio.IntelliTrace.QueryImplDelegate : MulticastDelegate {
    public QueryImplDelegate(object object, IntPtr method);
    public virtual void Invoke(IntelliTraceEvent evt, SearchResults results, SearchTracker tracker);
    public virtual IAsyncResult BeginInvoke(IntelliTraceEvent evt, SearchResults results, SearchTracker tracker, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.RefPackFlags : Enum {
    public int value__;
    public static RefPackFlags Null;
    public static RefPackFlags LenIsTwo;
    public static RefPackFlags Uncollected;
    public static RefPackFlags Cycle;
    public static RefPackFlags Partial;
    public static RefPackFlags Remoted;
    public static RefPackFlags MaxOneByteLen;
    public static RefPackFlags MaxTwoByteLen;
}
internal class Microsoft.VisualStudio.IntelliTrace.RegistrationInfo : object {
    [CompilerGeneratedAttribute]
private ProfilerRegistrationMode <Mode>k__BackingField;
    public ProfilerRegistrationMode Mode { get; private set; }
    public bool ShouldRegister { get; }
    private RegistrationInfo(ProfilerRegistrationMode mode);
    [CompilerGeneratedAttribute]
public ProfilerRegistrationMode get_Mode();
    [CompilerGeneratedAttribute]
private void set_Mode(ProfilerRegistrationMode value);
    public static RegistrationInfo Create(int frameworkVersion, bool is64Bit);
    public static RegistrationInfo Create(string targetPath);
    internal static string GetIntelliTraceDirectory();
    internal static string GetIntelliTraceLoggerPath();
    internal static string GetProfilerPath(bool isTarget64Bit);
    public string GetProfilerPath();
    private static bool CurrentUserIsAdministrator();
    public bool get_ShouldRegister();
}
internal class Microsoft.VisualStudio.IntelliTrace.RegistryHelper : object {
    public static SafeHandle LocalMachineHandle;
    public static SafeHandle ClassesRootHandle;
    public static SafeHandle CurrentUserHandle;
    internal static int ERROR_SUCCESS;
    private SafeHandle _handle;
    [CompilerGeneratedAttribute]
private bool <Is64Bit>k__BackingField;
    public bool Is64Bit { get; private set; }
    public RegistryHelper(SafeHandle registryHandle, bool is64Bit);
    private static RegistryHelper();
    [CompilerGeneratedAttribute]
public bool get_Is64Bit();
    [CompilerGeneratedAttribute]
private void set_Is64Bit(bool value);
    public RegistryHelper CreateKey(string subKey, bool isVolatile);
    public RegistryHelper OpenSubKey(string subKey);
    public void SetRegistryValue(string name, object value);
    public bool TryGetRegistryValue(string name, UInt32& value);
    public void DeleteSubTree(string path);
    private RegistryAccessMask GetAccessMask();
    public sealed virtual void Dispose();
    private static void ThrowOnFailure(int resultCode);
}
internal class Microsoft.VisualStudio.IntelliTrace.RemoteData : ClassData {
}
internal class Microsoft.VisualStudio.IntelliTrace.RemoteTraceDebugLogFile : IntelliTraceFileBase {
    private string _loggerName;
    private QueuedIpcPipeClient _controlIpc;
    private QueuedIpcPipeClient _processIpc;
    private IMessageMemory2 _memory;
    private Dictionary`2<int, int> threadStreams;
    private Stream webRequestEventStream;
    private object webRequestEventStreamLock;
    private Dictionary`2<TraceStreamType, int> _streamIndexes;
    private LoggingConfig _config;
    private MessagePackerCollection _packers;
    private SortedList`2<QueuedIpcStream, QueuedIpcStream> _streams;
    private object _streamsLock;
    private MemoryManager _memoryManager;
    internal LoggingConfig Config { get; }
    internal MessagePackerCollection Packers { get; }
    internal MemoryManager MemoryManager { get; }
    internal ControlMessagePacker PackerControl { get; }
    internal ProcessEventsMessagePacker PackerProcessEvents { get; }
    internal WebRequestEventsMessagePacker WebRequestEvents { get; }
    internal bool IsReadOnly { get; }
    internal string LogFileName { get; }
    internal Stream WebRequestEventStream { get; }
    public RemoteTraceDebugLogFile(string loggerName);
    internal virtual LoggingConfig get_Config();
    internal virtual MessagePackerCollection get_Packers();
    internal virtual MemoryManager get_MemoryManager();
    internal ControlMessagePacker get_PackerControl();
    internal ProcessEventsMessagePacker get_PackerProcessEvents();
    internal WebRequestEventsMessagePacker get_WebRequestEvents();
    internal virtual bool get_IsReadOnly();
    internal virtual string get_LogFileName();
    public int GetTraceStreamHandle(int nativeThreadId);
    public void Checkpoint(Byte* pData, int msgLen);
    public void RequestLogCopy(string copyFilePath);
    public _LoggerInfo RequestLoggerInfo();
    public string RequestStatistics();
    public bool RequestCoverageData(string copyFilePath, Guid testExecId, Boolean& logWasFull);
    internal Stream get_WebRequestEventStream();
    internal virtual LogStream OpenStream(TraceStreamType stream, StreamAccess mode);
    internal virtual int CreateStream(Guid id);
    internal virtual void CreateStream(Guid id, int index);
    internal virtual LogStream CreateStream(Guid type, StreamAccess streamOpenMode);
    internal virtual LogStream CreateStream(Guid type, int index, StreamAccess streamOpenMode);
    internal virtual bool StreamExists(int streamIndex);
    internal virtual bool StreamExists(TraceStreamType stream);
    internal virtual int HandleToIndex(int handle);
    internal virtual void Append(BufferDescriptor[] descriptors, int numDescriptors);
    internal virtual void SuspendLogAndBypass(IList`1<BufferDescriptor> descriptors, int numDescriptors);
    internal virtual void ResumeLog();
    internal virtual LogStream OpenStream(int streamIndex, StreamAccess mode);
    internal virtual IList`1<LogStreamEntry> GetLogStreamEntries();
    internal virtual void CloseStream(int streamHandle);
    internal virtual void Close();
    internal virtual void add_TrimLog(EventHandler`1<TrimLogEventArgs> value);
    internal virtual void remove_TrimLog(EventHandler`1<TrimLogEventArgs> value);
    internal virtual void DoTrimLog(TrimLogEventArgs trimArgs);
    internal virtual void add_DiskFull(EventHandler value);
    internal virtual void remove_DiskFull(EventHandler value);
    public virtual void Dispose();
    internal void EnterSuspendMode();
    internal void LeaveSuspendMode();
    internal void StreamCreated(QueuedIpcStream stream);
    internal void StreamDisposed(QueuedIpcStream stream);
    private string GetDispatcher(int streamIndex, StreamAccess streamMode);
    private QueuedIpcEntry RequestAndWaitForResponse(QueuedIpcPipeClient ipc, Byte* pMsg, int msgLen);
    private void AssertCorrectResponse(Byte* pData, MessageID expectedMsgID);
    private void AssertCorrectResponse(Byte* pData, MessageID expectedMsgID);
}
public class Microsoft.VisualStudio.IntelliTrace.ResolvedCallSiteEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private CallSiteEvent <CallSiteEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolvedMethod <CallerMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolvedMethod <CalleeMethod>k__BackingField;
    public CallSiteEvent CallSiteEvent { get; private set; }
    public ResolvedMethod CallerMethod { get; private set; }
    public ResolvedMethod CalleeMethod { get; private set; }
    public ResolvedCallSiteEvent(IntelliTraceProcess process, CallSiteEvent callSiteEvent);
    [CompilerGeneratedAttribute]
public CallSiteEvent get_CallSiteEvent();
    [CompilerGeneratedAttribute]
private void set_CallSiteEvent(CallSiteEvent value);
    [CompilerGeneratedAttribute]
public ResolvedMethod get_CallerMethod();
    [CompilerGeneratedAttribute]
private void set_CallerMethod(ResolvedMethod value);
    [CompilerGeneratedAttribute]
public ResolvedMethod get_CalleeMethod();
    [CompilerGeneratedAttribute]
private void set_CalleeMethod(ResolvedMethod value);
}
public class Microsoft.VisualStudio.IntelliTrace.ResolvedDiagnosticEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private IntelliTraceProcess <TraceProcess>k__BackingField;
    private DiagnosticEvent _notifyPointEvent;
    private NotifyType _notifyType;
    public DiagnosticEvent DiagnosticEvent { get; }
    public DiagnosticEventDataQueryType DataQueryType { get; }
    public string DataQueryShortDescriptionFormatString { get; }
    public string DataQueryLongDescriptionFormatString { get; }
    public string CategoryId { get; }
    private string CategoryName { get; }
    internal IntelliTraceProcess TraceProcess { get; private set; }
    public ResolvedDiagnosticEvent(IntelliTraceProcess process, DiagnosticEvent notifyPointEvent);
    public DiagnosticEvent get_DiagnosticEvent();
    public DiagnosticEventDataQueryType get_DataQueryType();
    public string GetShortDescription();
    public string GetLongDescription();
    public string get_DataQueryShortDescriptionFormatString();
    public string get_DataQueryLongDescriptionFormatString();
    public string get_CategoryId();
    private string get_CategoryName();
    public IList`1<IDataElement> GetData();
    internal IndependentData GetDiagnosticEventData();
    private string FormatDataQuery(string dataQueryFormat);
    private string GetModuleName();
    [CompilerGeneratedAttribute]
internal IntelliTraceProcess get_TraceProcess();
    [CompilerGeneratedAttribute]
private void set_TraceProcess(IntelliTraceProcess value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.ResolvedDiagnosticEventExtension : object {
    [ExtensionAttribute]
public static IEnumerable`1<IDataElement> GetQuerySpecificData(ResolvedDiagnosticEvent diagnosticEvent);
}
public class Microsoft.VisualStudio.IntelliTrace.ResolvedExceptionEvent : ResolvedMethodEvent {
    [CompilerGeneratedAttribute]
private ExceptionEvent <ExceptionEvent>k__BackingField;
    public ExceptionEvent ExceptionEvent { get; private set; }
    public ResolvedExceptionEvent(IntelliTraceProcess process, ExceptionEvent exceptionEvent);
    [CompilerGeneratedAttribute]
public ExceptionEvent get_ExceptionEvent();
    [CompilerGeneratedAttribute]
private void set_ExceptionEvent(ExceptionEvent value);
}
public class Microsoft.VisualStudio.IntelliTrace.ResolvedExceptionThrownEvent : ResolvedMethodEvent {
    [CompilerGeneratedAttribute]
private ExceptionThrownEvent <ExceptionThrownEvent>k__BackingField;
    public ExceptionThrownEvent ExceptionThrownEvent { get; private set; }
    public ResolvedExceptionThrownEvent(IntelliTraceProcess process, ExceptionThrownEvent exceptionThrownEvent);
    [CompilerGeneratedAttribute]
public ExceptionThrownEvent get_ExceptionThrownEvent();
    [CompilerGeneratedAttribute]
private void set_ExceptionThrownEvent(ExceptionThrownEvent value);
    public IList`1<IDataElement> GetData();
}
public class Microsoft.VisualStudio.IntelliTrace.ResolvedMethod : object {
    private IntelliTraceProcess process;
    private Guid mvid;
    private UInt32 methodDefToken;
    private MethodType methodType;
    private string methodName;
    private string containingTypeName;
    private string returnTypeName;
    private List`1<string> parameterTypeNames;
    private List`1<string> parameterNames;
    public string MethodName { get; }
    public string ContainingTypeName { get; }
    public string ReturnTypeName { get; }
    public IList`1<string> ParameterTypeNames { get; }
    public IList`1<string> ParameterNames { get; }
    internal MethodType MethodType { get; }
    internal ResolvedMethod(IntelliTraceProcess process, Guid mvid, int methodDefToken);
    public string get_MethodName();
    public string get_ContainingTypeName();
    public string get_ReturnTypeName();
    public IList`1<string> get_ParameterTypeNames();
    public IList`1<string> get_ParameterNames();
    internal MethodType get_MethodType();
}
public class Microsoft.VisualStudio.IntelliTrace.ResolvedMethodEnterEvent : ResolvedMethodExecutionEvent {
    private Nullable`1<DateTime> _eventTime;
    public MethodEnterEvent MethodEnterEvent { get; }
    public ResolvedMethodEnterEvent(IntelliTraceProcess process, MethodEnterEvent methodEnterEvent);
    public MethodEnterEvent get_MethodEnterEvent();
    internal bool HasParameters();
    public IList`1<IDataElement> GetParameters();
    internal DateTime GetStartTime();
}
public abstract class Microsoft.VisualStudio.IntelliTrace.ResolvedMethodEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private ResolvedMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceProcess <Process>k__BackingField;
    private Guid mvid;
    private int metadataToken;
    public ResolvedMethod Method { get; private set; }
    protected IntelliTraceProcess Process { get; protected set; }
    protected Guid Mvid { get; protected set; }
    protected int MetadataToken { get; protected set; }
    protected ResolvedMethodEvent(IntelliTraceProcess process, long ordinal, int traceDebugToken);
    [CompilerGeneratedAttribute]
public ResolvedMethod get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(ResolvedMethod value);
    [CompilerGeneratedAttribute]
protected IntelliTraceProcess get_Process();
    [CompilerGeneratedAttribute]
protected void set_Process(IntelliTraceProcess value);
    protected Guid get_Mvid();
    protected void set_Mvid(Guid value);
    protected int get_MetadataToken();
    protected void set_MetadataToken(int value);
}
public abstract class Microsoft.VisualStudio.IntelliTrace.ResolvedMethodExecutionEvent : ResolvedMethodEvent {
    [CompilerGeneratedAttribute]
private MethodEvent <MethodEvent>k__BackingField;
    internal MethodType MethodType { get; }
    protected MethodEvent MethodEvent { get; private set; }
    protected ResolvedMethodExecutionEvent(IntelliTraceProcess process, MethodEvent methodEvent);
    internal MethodType get_MethodType();
    [CompilerGeneratedAttribute]
protected MethodEvent get_MethodEvent();
    [CompilerGeneratedAttribute]
private void set_MethodEvent(MethodEvent value);
    internal LogData GetMethodData();
}
public class Microsoft.VisualStudio.IntelliTrace.ResolvedMethodExitEvent : ResolvedMethodExecutionEvent {
    private Nullable`1<DateTime> _endTime;
    private Nullable`1<TimeSpan> _totalTime;
    public MethodExitEvent MethodExitEvent { get; }
    public ResolvedMethodExitEvent(IntelliTraceProcess process, MethodExitEvent methodExitEvent);
    public MethodExitEvent get_MethodExitEvent();
    public IDataElement GetReturnValue();
    public IList`1<IDataElement> GetOutputs();
    private static List`1<Symbol> GetParameters(MethodType methodType);
    internal DateTime GetEndTime();
    internal TimeSpan GetTotalTime();
    private void ReadTimingData();
}
public class Microsoft.VisualStudio.IntelliTrace.ResolvedStackFrame : object {
    [CompilerGeneratedAttribute]
private IntelliTraceStackFrame <StackFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolvedMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceModule <Module>k__BackingField;
    private IntelliTraceSourceLocation sourceLocation;
    private Guid mvid;
    private int metadataToken;
    public IntelliTraceStackFrame StackFrame { get; private set; }
    public ResolvedMethod Method { get; private set; }
    public IntelliTraceModule Module { get; private set; }
    public IntelliTraceSourceLocation SourceLocation { get; }
    public ResolvedStackFrame(IntelliTraceProcess process, IntelliTraceStackFrame stackFrame);
    [CompilerGeneratedAttribute]
public IntelliTraceStackFrame get_StackFrame();
    [CompilerGeneratedAttribute]
private void set_StackFrame(IntelliTraceStackFrame value);
    [CompilerGeneratedAttribute]
public ResolvedMethod get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(ResolvedMethod value);
    [CompilerGeneratedAttribute]
public IntelliTraceModule get_Module();
    [CompilerGeneratedAttribute]
private void set_Module(IntelliTraceModule value);
    public IntelliTraceSourceLocation get_SourceLocation();
}
internal class Microsoft.VisualStudio.IntelliTrace.ReturnNode : Node {
    public NodeType Type { get; }
    internal ReturnNode(long ordinal, CodeContext location);
    public virtual NodeType get_Type();
}
public abstract class Microsoft.VisualStudio.IntelliTrace.RootChain : Chain {
    [CompilerGeneratedAttribute]
private ChainAccess <Access>k__BackingField;
    public ChainAccess Access { get; protected set; }
    [CompilerGeneratedAttribute]
public ChainAccess get_Access();
    [CompilerGeneratedAttribute]
protected void set_Access(ChainAccess value);
    public abstract virtual EventToken AppendEvent(IntelliTraceEvent chainEvent);
}
internal class Microsoft.VisualStudio.IntelliTrace.RootNode : BracketCallsiteNode {
    public NodeType Type { get; }
    internal RootNode(long ordinal, long cpOrdinal);
    public virtual NodeType get_Type();
    public virtual IBidiEnum`1<EventHandle> GetSiblings();
}
internal class Microsoft.VisualStudio.IntelliTrace.ScalarData`1 : PrimitiveData {
    private T _value;
    internal ScalarData`1(T value);
    internal T GetValue();
}
internal class Microsoft.VisualStudio.IntelliTrace.ScopedData : object {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Values>k__BackingField;
    public string Category { get; private set; }
    public IDictionary`2<string, object> Values { get; private set; }
    public ScopedData(string category);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Values();
    [CompilerGeneratedAttribute]
private void set_Values(IDictionary`2<string, object> value);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.ScopedEventTracker`1 : EventTracker {
    [CompilerGeneratedAttribute]
private WebChainWeaver <WebChainWeaver>k__BackingField;
    [CompilerGeneratedAttribute]
private IntelliTraceFileBase <File>k__BackingField;
    internal WebChainWeaver WebChainWeaver { get; private set; }
    internal IntelliTraceFileBase File { get; private set; }
    public ScopedEventTracker`1(IntelliTraceFileBase file);
    [CompilerGeneratedAttribute]
internal WebChainWeaver get_WebChainWeaver();
    [CompilerGeneratedAttribute]
private void set_WebChainWeaver(WebChainWeaver value);
    [CompilerGeneratedAttribute]
internal IntelliTraceFileBase get_File();
    [CompilerGeneratedAttribute]
private void set_File(IntelliTraceFileBase value);
    public IBidiEnum`1<NPEventData> GetDiagnosticEvents(NotifyPointTracker npTracker, int webRequestId, long threadStreamOffset, Boolean& eventsTruncated);
    public IList`1<CallTreeNode> GetCallTreeData(WebRequestCallTreeTraverser ctTraverser, int webRequestId, long threadStreamOffset);
    internal IEnumerable`1<BinopNode> GetWebEventFilterBinopNodes(int requestId, long threadStreamOffset, Boolean& eventsTruncated);
    private static BinopNode GetBinopNodeFromFilter(WebEventFilter filter);
}
internal class Microsoft.VisualStudio.IntelliTrace.SearchCommand : object {
    private SearchPolicy _policy;
    private QueryExpression _query;
    private SearchContext _context;
    internal SearchPolicy Policy { get; internal set; }
    internal QueryExpression Query { get; internal set; }
    internal SearchContext Context { get; internal set; }
    internal SearchPolicy get_Policy();
    internal void set_Policy(SearchPolicy value);
    internal QueryExpression get_Query();
    internal void set_Query(QueryExpression value);
    internal SearchContext get_Context();
    internal void set_Context(SearchContext value);
}
internal class Microsoft.VisualStudio.IntelliTrace.SearchNode : ValueType {
    public int resultId;
    public long clock;
}
internal class Microsoft.VisualStudio.IntelliTrace.SearchResults : object {
    public UInt32 searchId;
    public Dictionary`2<TextSpan, SortedList`2<long, SearchNode>> searchResults;
    public int ResultsCount { get; }
    public int get_ResultsCount();
    public void Add(TextSpan span, SearchNode searchResult);
}
internal class Microsoft.VisualStudio.IntelliTrace.SearchTracker : object {
    private QueryImplDelegate _queryImpl;
    private ChainWeaver _weaver;
    private SearchResults _searchResults;
    internal SearchTracker(QueryImplDelegate queryImpl, ChainWeaver weaver);
    public bool Sync(Predicate`1<SearchResults> continuePredicate, SearchResults results);
    public EventHandle GetCurrentEventHandle(ThreadTracker threadTracker);
}
internal enum Microsoft.VisualStudio.IntelliTrace.SectionId : Enum {
    public short value__;
    public static SectionId NestedValues;
    public static SectionId DurationData;
}
internal class Microsoft.VisualStudio.IntelliTrace.SectionInfo : object {
    [CompilerGeneratedAttribute]
private SectionId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private short <Version>k__BackingField;
    public SectionId Id { get; private set; }
    public short Version { get; private set; }
    public SectionInfo(SectionId sectionId, short version);
    [CompilerGeneratedAttribute]
public SectionId get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(SectionId value);
    [CompilerGeneratedAttribute]
public short get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(short value);
}
public class Microsoft.VisualStudio.IntelliTrace.SharePointAreaEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private SharePointArea <Area>k__BackingField;
    public SharePointArea Area { get; private set; }
    internal SharePointAreaEvent(_SharePointArea data);
    [CompilerGeneratedAttribute]
public SharePointArea get_Area();
    [CompilerGeneratedAttribute]
private void set_Area(SharePointArea value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.SharePointCategoryEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private SharePointCategory <Category>k__BackingField;
    public SharePointCategory Category { get; private set; }
    internal SharePointCategoryEvent(_SharePointCategory data);
    [CompilerGeneratedAttribute]
public SharePointCategory get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(SharePointCategory value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.SharePointEventExtensions : object {
    [ExtensionAttribute]
public static SharePointSKU ToSharePointSKU(SharePointSKU sku);
    [ExtensionAttribute]
public static SharePointArea ToSharePointArea(_SharePointArea data);
    [ExtensionAttribute]
public static SharePointCategory ToSharePointCategory(_SharePointCategory data);
}
internal class Microsoft.VisualStudio.IntelliTrace.SharePointTracker : EventTracker {
    private SharePointData _spFoundationData;
    private SharePointData _mossData;
    public SharePointData GetSharePointFoundationData();
    public SharePointData GetMOSSData();
    internal virtual void HandleEvent(SharePointAreaEvent areaEvent, EventHandle handle);
    internal virtual void HandleEvent(SharePointCategoryEvent categoryEvent, EventHandle handle);
    internal SharePointData GetSharePointData(SharePointSKU sku);
}
internal class Microsoft.VisualStudio.IntelliTrace.ShouldProcessEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldProcess>k__BackingField;
    public string Target { get; public set; }
    public bool ShouldProcess { get; public set; }
    public ShouldProcessEventArgs(string target);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public bool get_ShouldProcess();
    [CompilerGeneratedAttribute]
public void set_ShouldProcess(bool value);
}
[DebuggerDisplayAttribute("Name = {Name}, Type = {TypeName}, Value = {Value}")]
internal class Microsoft.VisualStudio.IntelliTrace.SimpleDataElement : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPartialData>k__BackingField;
    private List`1<IDataElement> children;
    public string Name { get; private set; }
    public string Value { get; private set; }
    public string TypeName { get; private set; }
    public bool HasChildren { get; }
    public bool HasPartialData { get; private set; }
    internal SimpleDataElement(string name, string value, string typeName, bool hasPartialValue);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeName();
    [CompilerGeneratedAttribute]
private void set_TypeName(string value);
    public virtual bool get_HasChildren();
    public virtual IList`1<IDataElement> GetChildren();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasPartialData();
    [CompilerGeneratedAttribute]
private void set_HasPartialData(bool value);
    internal void AddChild(IDataElement child);
}
internal class Microsoft.VisualStudio.IntelliTrace.SlicedEventChain : DerivedChain {
    private DerivedChain _chain;
    private EventToken _first;
    private EventToken _afterLast;
    private long _count;
    public bool IsEmpty { get; }
    public EventToken BeforeFirstToken { get; }
    public EventToken FirstToken { get; }
    public EventToken FirstValidToken { get; }
    public EventToken LastToken { get; }
    public EventToken AfterLastToken { get; }
    public bool CanGetPreviousToken { get; }
    public bool CanGetLastToken { get; }
    public bool CanGetCount { get; }
    public long Count { get; }
    public SlicedEventChain(DerivedChain chain, EventToken first, EventToken afterLast);
    public SlicedEventChain(DerivedChain chain, EventToken first, EventToken afterLast, long count);
    public void SetEndpoint(EventToken afterLast);
    public void RefreshEndpoint();
    public virtual bool get_IsEmpty();
    public virtual EventToken get_BeforeFirstToken();
    public virtual EventToken get_FirstToken();
    public virtual EventToken get_FirstValidToken();
    public virtual EventToken get_LastToken();
    public virtual EventToken get_AfterLastToken();
    public virtual bool get_CanGetPreviousToken();
    public virtual bool get_CanGetLastToken();
    public virtual bool get_CanGetCount();
    public virtual long get_Count();
    public virtual IntelliTraceEvent GetEvent(EventToken token);
    public virtual IList`1<IntelliTraceEvent> GetEvents(EventToken startToken, EventToken endToken);
    public virtual EventToken GetNextToken(EventToken token);
    public virtual EventToken GetPreviousToken(EventToken token);
    public virtual void Refresh();
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
    public virtual bool IsValidToken(EventToken token);
    private long CountEvents(EventToken first, EventToken afterLast);
    private long CompareTokens(EventToken left, EventToken right);
}
internal enum Microsoft.VisualStudio.IntelliTrace.SliceEdge : Enum {
    public int value__;
    public static SliceEdge Leading;
    public static SliceEdge Trailing;
}
internal class Microsoft.VisualStudio.IntelliTrace.Statistics : object {
    private Action`1<InitializationData> _initCallback;
    private Action`1<StatisticsData> _statEvaluator;
    private CheckpointState _diagnosticCheckpointState;
    private WebStatistics _webStats;
    private Dictionary`2<int, CheckpointState> _threadCheckpoints;
    private bool _enable;
    private InitializationData _initData;
    public bool Enabled { get; }
    public Statistics(bool enable, Action`1<InitializationData> initCallback, Action`1<StatisticsData> statEvaluator);
    public bool get_Enabled();
    public StatisticsData GetData();
    private void CreateCheckpointStats(CheckpointedStreamStatistics streamStats, CheckpointState checkpointState);
    public void DiagnosticCheckpointCreated(_SimpleCheckpointData checkpointData);
    public void DiagnosticCheckpointCreated(SimpleCheckpointData* checkpointData);
    public void OnWebRequestBegin(_WebRequestBegin begin);
    public void OnWebRequestEnd(_WebRequestEnd end);
    public void OnWebThreadBegin(_WebThreadInfo begin);
    public void OnWebThreadEnd(_WebThreadInfo end);
    public void ThreadCheckpointCreated(int streamIndex, _FullCheckpointData checkpointData);
    public static TimeSpan CalculateTimeSpan(long start, long end, long frequency);
    public static double CalculateSeconds(long start, long end, long frequency);
}
internal class Microsoft.VisualStudio.IntelliTrace.StatisticsData : object {
    private StreamStatisticsSet _streamInfo;
    private long _startTime;
    private long _frequency;
    private long _timestamp;
    [CompilerGeneratedAttribute]
private long <MaximumConcurrentWebRequests>k__BackingField;
    public long MaximumConcurrentWebRequests { get; public set; }
    public long Timestamp { get; public set; }
    public long Frequency { get; public set; }
    public long StartTime { get; public set; }
    public StreamStatisticsSet StreamInformation { get; }
    [CompilerGeneratedAttribute]
public long get_MaximumConcurrentWebRequests();
    [CompilerGeneratedAttribute]
public void set_MaximumConcurrentWebRequests(long value);
    public long get_Timestamp();
    public void set_Timestamp(long value);
    public long get_Frequency();
    public void set_Frequency(long value);
    public long get_StartTime();
    public void set_StartTime(long value);
    public StreamStatisticsSet get_StreamInformation();
    public string CreateResponse();
    private static XElement ElementFromStream(string name, StreamStatistics stats);
}
public abstract class Microsoft.VisualStudio.IntelliTrace.StreamChain : RootChain {
    internal LogStream stream;
    internal int Index { get; }
    public bool IsEmpty { get; }
    public EventToken FirstToken { get; }
    public EventToken FirstValidToken { get; }
    public EventToken AfterLastToken { get; }
    internal StreamChain(LogStream stream);
    internal int get_Index();
    protected abstract virtual Byte[] ReadEventBytes();
    protected abstract virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    protected abstract virtual IntelliTraceEvent ConvertToEvent(EventToken token, Byte[] data, Int32& offset);
    protected abstract virtual int ReadEventLength();
    internal void SetFirstValidToken(EventToken token);
    public virtual IntelliTraceEvent GetEvent(EventToken token);
    internal IntelliTraceEvent GetEvent(EventToken token, bool checkValidity);
    public virtual IList`1<IntelliTraceEvent> GetEvents(EventToken startToken, EventToken endToken);
    public virtual EventToken GetNextToken(EventToken token);
    internal virtual EventToken WriteEvent(EventToken token, IntelliTraceEvent chainEvent);
    public virtual EventToken AppendEvent(IntelliTraceEvent chainEvent);
    public virtual bool get_IsEmpty();
    public virtual EventToken get_FirstToken();
    public virtual EventToken get_FirstValidToken();
    public virtual EventToken get_AfterLastToken();
    public virtual bool IsValidToken(EventToken token);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.IntelliTrace.StreamStatistics : object {
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public long Length { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(long value);
}
internal class Microsoft.VisualStudio.IntelliTrace.StreamStatisticsSet : object {
    private Dictionary`2<Guid, StreamStatistics> _metadata;
    private Dictionary`2<int, StreamStatistics> _thread;
    private Dictionary`2<int, CheckpointedStreamStatistics> _threadCheckpoints;
    [CompilerGeneratedAttribute]
private StreamStatistics <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamStatistics <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamStatistics <Diagnostic>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckpointedStreamStatistics <DiagnosticCheckpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamStatistics <TestEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamStatistics <ExceptionIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamStatistics <WebRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamStatistics <WebSessionTracking>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamStatistics <WebRequestTracking>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamStatistics <WebThreadTracking>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamStatistics <WebSummaryTracking>k__BackingField;
    public StreamStatistics Process { get; private set; }
    public StreamStatistics Configuration { get; private set; }
    public StreamStatistics Diagnostic { get; private set; }
    public CheckpointedStreamStatistics DiagnosticCheckpoints { get; private set; }
    public StreamStatistics TestEvents { get; private set; }
    public StreamStatistics ExceptionIndex { get; private set; }
    public StreamStatistics WebRequests { get; private set; }
    public StreamStatistics WebSessionTracking { get; private set; }
    public StreamStatistics WebRequestTracking { get; private set; }
    public StreamStatistics WebThreadTracking { get; private set; }
    public StreamStatistics WebSummaryTracking { get; private set; }
    [CompilerGeneratedAttribute]
public StreamStatistics get_Process();
    [CompilerGeneratedAttribute]
private void set_Process(StreamStatistics value);
    [CompilerGeneratedAttribute]
public StreamStatistics get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(StreamStatistics value);
    [CompilerGeneratedAttribute]
public StreamStatistics get_Diagnostic();
    [CompilerGeneratedAttribute]
private void set_Diagnostic(StreamStatistics value);
    [CompilerGeneratedAttribute]
public CheckpointedStreamStatistics get_DiagnosticCheckpoints();
    [CompilerGeneratedAttribute]
private void set_DiagnosticCheckpoints(CheckpointedStreamStatistics value);
    [CompilerGeneratedAttribute]
public StreamStatistics get_TestEvents();
    [CompilerGeneratedAttribute]
private void set_TestEvents(StreamStatistics value);
    [CompilerGeneratedAttribute]
public StreamStatistics get_ExceptionIndex();
    [CompilerGeneratedAttribute]
private void set_ExceptionIndex(StreamStatistics value);
    [CompilerGeneratedAttribute]
public StreamStatistics get_WebRequests();
    [CompilerGeneratedAttribute]
private void set_WebRequests(StreamStatistics value);
    [CompilerGeneratedAttribute]
public StreamStatistics get_WebSessionTracking();
    [CompilerGeneratedAttribute]
private void set_WebSessionTracking(StreamStatistics value);
    [CompilerGeneratedAttribute]
public StreamStatistics get_WebRequestTracking();
    [CompilerGeneratedAttribute]
private void set_WebRequestTracking(StreamStatistics value);
    [CompilerGeneratedAttribute]
public StreamStatistics get_WebThreadTracking();
    [CompilerGeneratedAttribute]
private void set_WebThreadTracking(StreamStatistics value);
    [CompilerGeneratedAttribute]
public StreamStatistics get_WebSummaryTracking();
    [CompilerGeneratedAttribute]
private void set_WebSummaryTracking(StreamStatistics value);
    public StreamStatistics Metadata(Guid mvid);
    public StreamStatistics Thread(int threadId);
    public CheckpointedStreamStatistics ThreadCheckpoints(int threadId);
    public IDictionary`2<int, StreamStatistics> GetThreadStreams();
    public IDictionary`2<int, CheckpointedStreamStatistics> GetThreadCheckpointStreams();
    public IDictionary`2<Guid, StreamStatistics> GetMetadataStreams();
    private static T GetOrCreate(IDictionary`2<K, T> dictionary, K key);
}
internal class Microsoft.VisualStudio.IntelliTrace.StringData : PrimitiveData {
    protected string _value;
    internal StringData(DataUnavailableReason reason);
    internal StringData(string value, bool partialData);
    internal string GetString();
}
internal class Microsoft.VisualStudio.IntelliTrace.StringListComparer : object {
    private StringComparer comparer;
    internal static IEqualityComparer`1<IList`1<string>> OrdinalIgnoreCase;
    private static StringListComparer();
    private StringListComparer(StringComparer comparer);
    public sealed virtual bool Equals(IList`1<string> first, IList`1<string> second);
    public sealed virtual int GetHashCode(IList`1<string> list);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object first, object second);
    public sealed virtual int GetHashCode(object obj);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.StringPackFlags : Enum {
    public int value__;
    public static StringPackFlags Null;
    public static StringPackFlags LenIsTwo;
    public static StringPackFlags Compressed;
    public static StringPackFlags Partial;
    public static StringPackFlags MaxOneByteLen;
}
internal class Microsoft.VisualStudio.IntelliTrace.SummaryTracker : EventTracker {
    private LogSystemInfo _sysInfo;
    internal virtual void HandleEvent(SystemInformationEvent systemInfo, EventHandle handle);
    internal LogSystemInfo GetSystemInfo();
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.SupportedInstrumentationMethods : Enum {
    public int value__;
    public static SupportedInstrumentationMethods None;
    public static SupportedInstrumentationMethods Trace;
    public static SupportedInstrumentationMethods Detour;
    public static SupportedInstrumentationMethods TestImpact;
    public static SupportedInstrumentationMethods DiagnosticEvents;
    public static SupportedInstrumentationMethods All;
}
internal class Microsoft.VisualStudio.IntelliTrace.SymbolContextProvider : object {
    private TraceLog _tracelog;
    private ProgramSymbols _programSymbols;
    public TraceLog Log { get; }
    public ProgramSymbols Symbols { get; }
    internal SymbolContextProvider(TraceLog traceLog, ProgramSymbols programSymbols);
    public sealed virtual TraceLog get_Log();
    public sealed virtual ProgramSymbols get_Symbols();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.ArrayElementSymbol : Symbol {
    private Int32[] _indices;
    public ArrayElementSymbol(Int32[] indices, Type type);
    public Int32[] GetIndices();
}
[DebuggerDisplayAttribute("ArrayType: Element Type = {ElementType}, Rank = {Rank}")]
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.ArrayType : TypeDefType {
    private Type _elemType;
    private int _rank;
    [CompilerGeneratedAttribute]
private Type <ElementMetadataType>k__BackingField;
    public int Rank { get; }
    public Type ElementType { get; public set; }
    public Type ElementMetadataType { get; private set; }
    internal ArrayType(ModuleSymbols modSyms, Type elemType, int rank);
    public int get_Rank();
    public Type get_ElementType();
    public void set_ElementType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ElementMetadataType();
    [CompilerGeneratedAttribute]
private void set_ElementMetadataType(Type value);
    public Type ResolveElementType();
    public Type ResolveElementMetadataType();
    public Symbol GetElementSymbol(Int32[] indices, Type runtimeType);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.AssemblyProps : object {
    public UInt32 Token;
    public string Name;
    public ASSEMBLYMETADATA Metadata;
    public AssemblyProps(UInt32 token);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.AssemblyRefProps : object {
    public UInt32 Token;
    public string Name;
    public ASSEMBLYMETADATA Metadata;
    public AssemblyRefProps(UInt32 token);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.CoffHeader : object {
    internal ushort Machine;
    internal ushort NumberOfSections;
    internal UInt32 TimeDateStamp;
    internal UInt32 PointerToSymbolTable;
    internal UInt32 NumberOfSymbols;
    internal ushort SizeOfOptionalHeader;
    internal ushort Characteristics;
    internal CoffHeader(BinaryReader r);
}
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.CorMethodSemanticsAttr : Enum {
    public UInt32 value__;
    public static CorMethodSemanticsAttr msSetter;
    public static CorMethodSemanticsAttr msGetter;
    public static CorMethodSemanticsAttr msOther;
    public static CorMethodSemanticsAttr msAddOn;
    public static CorMethodSemanticsAttr msRemoveOn;
    public static CorMethodSemanticsAttr msFire;
}
public class Microsoft.VisualStudio.IntelliTrace.Symbols.CV_INFO_PDB70 : ValueType {
    public UInt32 CvSignature;
    public Guid Signature;
    public UInt32 Age;
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.DataNotCollectedType : Type {
    private ElementType _elemType;
    public bool IsString { get; }
    public bool IsVoid { get; }
    public bool IsPrimitive { get; }
    internal DataNotCollectedType(ElementType elemType);
    public bool get_IsString();
    public bool get_IsVoid();
    public bool get_IsPrimitive();
    public ElementType GetPrimitiveType();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.DebugDirectory : object {
    internal static int sizeOfDebugDirectory;
    internal UInt32 Characteristics;
    internal UInt32 TimeDateStamp;
    internal ushort MajorVersion;
    internal ushort MinorVersion;
    internal UInt32 Type;
    internal UInt32 SizeOfData;
    internal UInt32 AddressOfRawData;
    internal UInt32 PointerToRawData;
    internal Byte[] raw;
    internal DebugDirectory(BinaryReader r);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.EmbeddedSymbolInfo : object {
    public Byte[] Metadata;
    public Byte[][] DebugDirectories;
    public Byte[][] DebugData;
    [CompilerGeneratedAttribute]
private string <ModulePath>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymUnmanagedReader <SymbolReader>k__BackingField;
    [CompilerGeneratedAttribute]
private object <MetadataImport>k__BackingField;
    private GCHandle _metadataPin;
    private MetadataEvent _mevent;
    private static Type _dispenserType;
    [CompilerGeneratedAttribute]
private ISymbolLocator140 <SymbolLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegistryRoot>k__BackingField;
    public string ModulePath { get; private set; }
    public ISymUnmanagedReader SymbolReader { get; private set; }
    public object MetadataImport { get; private set; }
    internal ISymbolLocator140 SymbolLocator { get; private set; }
    internal string RegistryRoot { get; private set; }
    internal EmbeddedSymbolInfo(ModuleData mdata, MetadataEvent mevent, string registryRoot);
    private static EmbeddedSymbolInfo();
    [CompilerGeneratedAttribute]
public string get_ModulePath();
    [CompilerGeneratedAttribute]
private void set_ModulePath(string value);
    [CompilerGeneratedAttribute]
public ISymUnmanagedReader get_SymbolReader();
    [CompilerGeneratedAttribute]
private void set_SymbolReader(ISymUnmanagedReader value);
    [CompilerGeneratedAttribute]
public object get_MetadataImport();
    [CompilerGeneratedAttribute]
private void set_MetadataImport(object value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public int LoadMetadataImport();
    public bool GetPdbInfo(string modulePath, PdbInfo& pdbInfo);
    public int LoadSymbolReader(string pdbPath, string modulePath);
    [CompilerGeneratedAttribute]
internal ISymbolLocator140 get_SymbolLocator();
    [CompilerGeneratedAttribute]
private void set_SymbolLocator(ISymbolLocator140 value);
    [CompilerGeneratedAttribute]
internal string get_RegistryRoot();
    [CompilerGeneratedAttribute]
private void set_RegistryRoot(string value);
    internal int EnsureSymbolLocatorInitialized();
    public sealed virtual object GetMetadataImport();
    [CompilerGeneratedAttribute]
private void <Dispose>b__19_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__19_1();
    [CompilerGeneratedAttribute]
private void <Dispose>b__19_2();
    [CompilerGeneratedAttribute]
private void <Dispose>b__19_3();
}
public enum Microsoft.VisualStudio.IntelliTrace.Symbols.enum_SymbolLoadingOptions : Enum {
    public int value__;
    public static enum_SymbolLoadingOptions SymLoadOption_All;
    public static enum_SymbolLoadingOptions SymLoadOption_SkipInvalidLocations;
    public static enum_SymbolLoadingOptions SymLoadOption_UseMissCache;
    public static enum_SymbolLoadingOptions SymLoadOption_CacheNetworkSymbols;
    public static enum_SymbolLoadingOptions SymLoadOption_ProgressDialog;
    public static enum_SymbolLoadingOptions SymLoadOption_UseWOWPaths;
    public static enum_SymbolLoadingOptions SymLoadOption_CreateDiaDataSource;
    public static enum_SymbolLoadingOptions SymLoadOption_IgnoreIncludeExcludeList;
    public static enum_SymbolLoadingOptions SymLoadOption_RequestPdbCacheWriteBack;
    public static enum_SymbolLoadingOptions SymLoadOption_PromptForCredentials;
    public static enum_SymbolLoadingOptions SymLoadOption_EnableSymSrvPortablePdb;
}
public enum Microsoft.VisualStudio.IntelliTrace.Symbols.enum_SymSettingsFields : Enum {
    public int value__;
    public static enum_SymSettingsFields SymSettingsFields_All;
    public static enum_SymSettingsFields SymSettingsFields_SymbolPath;
    public static enum_SymSettingsFields SymSettingsFields_CachePath;
    public static enum_SymSettingsFields SymSettingsFields_Paths;
    public static enum_SymSettingsFields SymSettingsFields_IncludeList;
    public static enum_SymSettingsFields SymSettingsFields_ExcludeList;
    public static enum_SymSettingsFields SymSettingsFields_IsManual;
    public static enum_SymSettingsFields SymSettingsFields_LoadAdjacent;
    public static enum_SymSettingsFields SymSettingsFields_LoadState;
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.ExceptionType : Type {
    private static List`1<Symbol> _symbols;
    internal List`1<Symbol> GetFields();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.FieldProps : object {
    public UInt32 Token;
    public string Name;
    public FieldFlags Flags;
    public Byte* Signature;
    public UInt32 SignatureLength;
    public UInt32 CPlusTypeFlag;
    public object Value;
    public bool IsStatic { get; }
    public bool IsLiteral { get; }
    public bool HasDefault { get; }
    public FieldProps(UInt32 token);
    public bool get_IsStatic();
    public bool get_IsLiteral();
    public bool get_HasDefault();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.FieldSigParser : TypeSigParser {
    private FieldProps _props;
    private IList`1<Type> _instanceTypes;
    public FieldSigParser(ModuleSymbols modSyms, FieldProps props, IList`1<Type> instanceTypes);
    public Type GetFieldType();
    public virtual void NotifyTypeGenericTypeVariable(UInt32 number);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.GenericType : Type {
    private Type _runtimeType;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMethodVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <GenericParameterIndex>k__BackingField;
    public Type RuntimeType { get; }
    public string Name { get; public set; }
    public bool IsMethodVariable { get; private set; }
    public UInt32 GenericParameterIndex { get; private set; }
    internal GenericType(ModuleSymbols modSymbols, bool mvar, UInt32 index);
    public Type get_RuntimeType();
    public void SetRuntimeType(Type runtimeType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsMethodVariable();
    [CompilerGeneratedAttribute]
private void set_IsMethodVariable(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_GenericParameterIndex();
    [CompilerGeneratedAttribute]
private void set_GenericParameterIndex(UInt32 value);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.IgnoreMethodSigParser : SigParserHandler {
    private SigParser _parser;
    private SigParserHandler _handler;
    private UInt32 _recursionCount;
    public IgnoreMethodSigParser(SigParser parser, SigParserHandler handler);
    public virtual void NotifyBeginMethod(SignatureType elem_type);
    public virtual void NotifyEndMethod();
}
public class Microsoft.VisualStudio.IntelliTrace.Symbols.IMAGE_DEBUG_DIRECTORY : ValueType {
    public UInt32 Characteristics;
    public UInt32 TimeDateStamp;
    public ushort MajorVersion;
    public ushort MinorVersion;
    public UInt32 Type;
    public UInt32 SizeOfData;
    public UInt32 AddressOfRawData;
    public UInt32 PointerToRawData;
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.ImageDataDirectory : object {
    internal UInt32 VirtualAddress;
    internal UInt32 Size;
    internal ImageDataDirectory(BinaryReader r);
}
internal interface Microsoft.VisualStudio.IntelliTrace.Symbols.ISymbolContextProvider {
    public ProgramSymbols Symbols { get; }
    public TraceLog Log { get; }
    public abstract virtual ProgramSymbols get_Symbols();
    public abstract virtual TraceLog get_Log();
}
[GuidAttribute("61EF826B-B598-43F7-970F-C1815D3E515A")]
[InterfaceTypeAttribute("1")]
public interface Microsoft.VisualStudio.IntelliTrace.Symbols.ISymbolLocator {
    public abstract virtual void SetSymbolSettings(SymbolSettings& SymbolSettings);
    public abstract virtual ISymbolSearchResult LocatePdb(PdbInfo& pdbFile, string additionalSearchPaths, UInt32 symbolLoadingOptions);
    public abstract virtual ISymbolSearchResult LocateBinary(string moduleFilePath, UInt32 timeStamp, UInt32 imageSize, string additionalSearchPaths, UInt32 symbolLoadingOptions);
    public abstract virtual void ClearSymbolStoreCache();
    public abstract virtual string GetStatusMessageForHResult(int hr);
    public abstract virtual UInt32 GetSymbolLocationType(string path);
    public abstract virtual PdbInfo GetPdbInfoForModule(string ModulePath, int isManagedLoad);
    public abstract virtual PdbInfo GetPdbInfoFromCallback(object pCallback, int isManagedLoad);
}
[GuidAttribute("956541FB-AFEE-4DE4-B630-DE054A46F2A4")]
[InterfaceTypeAttribute("1")]
public interface Microsoft.VisualStudio.IntelliTrace.Symbols.ISymbolLocator140 {
    public abstract virtual void SetSymbolSettings(SymbolSettings& SymbolSettings);
    public abstract virtual ISymbolSearchResult LocatePdb(PdbInfo& pdbFile, string additionalSearchPaths, UInt32 symbolLoadingOptions);
    public abstract virtual ISymbolSearchResult LocateBinary(string moduleFilePath, UInt32 timeStamp, UInt32 imageSize, string additionalSearchPaths, UInt32 symbolLoadingOptions);
    public abstract virtual void ClearSymbolStoreCache();
    public abstract virtual string GetStatusMessageForHResult(int hr);
    public abstract virtual UInt32 GetSymbolLocationType(string path);
    public abstract virtual PdbInfo GetPdbInfoForModule(string ModulePath, int isManagedLoad);
    public abstract virtual PdbInfo GetPdbInfoFromCallback(object pCallback, int isManagedLoad);
    public abstract virtual ISymbolSearchResult140 LocateAnyFormatPdb(PdbInfo& pdbFile, object pMetadataProvider, string additionalSearchPaths, UInt32 symbolLoadingOptions);
    public abstract virtual void SetPortablePdbReaderCodebase(string codeBase);
}
public interface Microsoft.VisualStudio.IntelliTrace.Symbols.ISymbolLocatorFactory {
    public abstract virtual int CreateSymbolLocator(string registryRoot, ISymbolLocator140& symbolLocator);
}
[GuidAttribute("FA96855B-5137-4198-BCF7-1424F7AD3F0E")]
[InterfaceTypeAttribute("1")]
public interface Microsoft.VisualStudio.IntelliTrace.Symbols.ISymbolLocatorVsIntegration {
    public abstract virtual void SetThreadedWaitDialog(object threadedWaitDialog);
    public abstract virtual void SetServiceProvider(object serviceProvider);
    public abstract virtual void SetLocaleId(ushort localeId);
}
[GuidAttribute("F5E66C13-B773-43A4-8CDB-AF3A4BCB1B5C")]
[InterfaceTypeAttribute("1")]
public interface Microsoft.VisualStudio.IntelliTrace.Symbols.ISymbolSearchResult {
    public abstract virtual string GetSymbolFilePath();
    public abstract virtual string GetSymbolStatusMessage();
    public abstract virtual string GetSymbolSearchInformation();
    public abstract virtual object GetDiaDataSource();
}
[GuidAttribute("04E08581-C22A-4378-AD44-88312D99DDDA")]
[InterfaceTypeAttribute("1")]
public interface Microsoft.VisualStudio.IntelliTrace.Symbols.ISymbolSearchResult140 {
    [DispIdAttribute("1610743808")]
public bool IsFound { get; }
    [DispIdAttribute("1610743809")]
public bool IsPortablePdb { get; }
    public abstract virtual string GetSymbolFilePath();
    public abstract virtual string GetSymbolStatusMessage();
    public abstract virtual string GetSymbolSearchInformation();
    public abstract virtual object GetDiaDataSource();
    public abstract virtual bool get_IsFound();
    public abstract virtual bool get_IsPortablePdb();
    public abstract virtual object GetSymReader();
}
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.MDIndexType : Enum {
    public byte value__;
    public static MDIndexType Module;
    public static MDIndexType TypeRef;
    public static MDIndexType TypeDef;
    public static MDIndexType Field;
    public static MDIndexType MethodDef;
    public static MDIndexType Param;
    public static MDIndexType InterfaceImpl;
    public static MDIndexType MemberRef;
    public static MDIndexType Constant;
    public static MDIndexType CustomAttribute;
    public static MDIndexType FieldMarshal;
    public static MDIndexType DeclSecurity;
    public static MDIndexType ClassLayout;
    public static MDIndexType FieldLayout;
    public static MDIndexType StandAloneSig;
    public static MDIndexType EventMap;
    public static MDIndexType Event;
    public static MDIndexType PropertyMap;
    public static MDIndexType Property;
    public static MDIndexType MethodSemantics;
    public static MDIndexType MethodImpl;
    public static MDIndexType ModuleRef;
    public static MDIndexType TypeSpec;
    public static MDIndexType ImplMap;
    public static MDIndexType FieldRVA;
    public static MDIndexType Assembly;
    public static MDIndexType AssemblyProcessor;
    public static MDIndexType AssemblyOS;
    public static MDIndexType AssemblyRef;
    public static MDIndexType AssemblyRefProcessor;
    public static MDIndexType AssemblyRefOS;
    public static MDIndexType File;
    public static MDIndexType ExportedType;
    public static MDIndexType ManifestResource;
    public static MDIndexType NestedClass;
    public static MDIndexType GenericParam;
    public static MDIndexType MethodSpec;
    public static MDIndexType GenericParamConstraint;
    public static MDIndexType ProteusToken;
}
internal static class Microsoft.VisualStudio.IntelliTrace.Symbols.MDUtil : object {
    public static UInt32 TypeDefNil;
    private static MDUtil();
    public static MDIndexType GetIndexTypeFromToken(UInt32 mdToken);
    public static UInt32 GetTokenFromIndex(MDIndexType indexType, UInt32 index);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.MemberRefProps : object {
    public UInt32 Token;
    public UInt32 TokenParent;
    public string Name;
    public Byte* Signature;
    public UInt32 SignatureLength;
    public MemberRefProps(UInt32 token);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.MetadataImport : object {
    private Guid _originalMvid;
    private Guid _generatedMvid;
    private bool _hasGeneratedMetadata;
    private TokenDictionary _metadataTokenMapping;
    private TokenDictionary MetadataTokenMapping { get; }
    private TokenDictionary get_MetadataTokenMapping();
    internal void Initialize(IMetaDataImport2 metadataImport);
    internal Guid GetMvid(Guid mvid);
    internal UInt32 GetGeneratedToken(UInt32 token);
    internal UInt32 GetOriginalToken(UInt32 token);
    private static bool IsNilToken(UInt32 token);
}
internal static class Microsoft.VisualStudio.IntelliTrace.Symbols.MetadataMapping : object {
    private static string _UserStringSeparator;
    private static string _IntelliTracePrefix;
    internal static void AddUserString(IMetaDataEmit2 metadataEmit2, UInt32 key, UInt32 value);
    internal static void AddUserString(IMetaDataEmit2 metadataEmit2, Guid key, Guid value);
    internal static void AddUserString(IMetaDataEmit2 metadataEmit2, string key, string value);
    internal static bool GetUserString(IMetaDataImport2 metadataImport, UInt32 token, UInt32& key, UInt32& value);
    internal static bool GetUserString(IMetaDataImport2 metadataImport, UInt32 token, Guid& key, Guid& value);
    internal static bool GetUserString(IMetaDataImport2 metadataImport, UInt32 token, String& key, String& value);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.MethodProps : object {
    public UInt32 Token;
    public UInt32 TokenTypeDef;
    public string Name;
    public UInt32 Flags;
    public Byte* Signature;
    public UInt32 SignatureLength;
    public UInt32 CodeRVA;
    public UInt32 ImplFlags;
    public CorMethodSemanticsAttr SemanticsAttr;
    public MethodProps(UInt32 token);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.MethodSigParser : TypeSigParser {
    protected UInt32 _tokMethod;
    protected ParamProps[] _paramProps;
    protected int _paramIdx;
    protected int _argIdx;
    protected List`1<Symbol> _paramFields;
    protected Symbol _this;
    protected Symbol _retSymbol;
    protected UInt32 _enclosingToken;
    public MethodSigParser(ModuleSymbols modSymbols, UInt32 tokMethod);
    public Symbol GetThis();
    public List`1<Symbol> GetParameters();
    public Symbol GetReturn();
    public virtual void NotifyBeginMethod(SignatureType elementType);
    public virtual void NotifyParamCount(UInt32 count);
    public virtual void NotifyEndParam();
    public virtual void NotifyEndRetType();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.MethodSpecProps : object {
    public UInt32 Token;
    public UInt32 TokenParent;
    public Byte* Signature;
    public UInt32 SignatureLength;
    public MethodSpecProps(UInt32 token);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.MethodStringBuilder : SigParserHandler {
    private StringBuilder _methodBuilder;
    private StringBuilder _returnTypeBuilder;
    private StringBuilder _currentBuilder;
    private ModuleSymbols _symbols;
    private SigParser _parser;
    private UInt32 _numParams;
    private bool _passedByRef;
    private Stack`1<SignatureTypeInfo> _typeInfo;
    public MethodStringBuilder(ModuleSymbols symbols);
    public string ToString(UInt32 methodDefToken);
    private string GetTokenString(UInt32 token);
    public virtual void NotifyGenericParamCount(UInt32 count);
    public virtual void NotifyBeginRetType();
    public virtual void NotifyEndRetType();
    public virtual void NotifyParamCount(UInt32 count);
    public virtual void NotifyBeginParam();
    public virtual void NotifyByref();
    public virtual void NotifyEndParam();
    public virtual void NotifyBeginType();
    public virtual void NotifyTypePointer();
    public virtual void NotifyVoid();
    public virtual void NotifyTypedByref();
    public virtual void NotifyTypeSimple(ElementType elem_type);
    public virtual void NotifyRank(UInt32 rank);
    public virtual void NotifyTypeSzArray();
    public virtual void NotifyCustomMod(byte cmod, IndexType indexType, UInt32 index);
    public virtual void NotifyTypeDefOrRef(IndexType indexType, UInt32 index);
    public virtual void NotifyTypeGenericInst(ElementType elem_type, IndexType indexType, UInt32 index, UInt32 number);
    public virtual void NotifyTypeGenericTypeVariable(UInt32 number);
    public virtual void NotifyTypeGenericMemberVariable(UInt32 number);
    public virtual void NotifyTypeFunctionPointer();
    public virtual void NotifyEndType();
    private void AppendTypeName(UInt32 token);
    private void AppendTypeRefName(UInt32 token);
    private void AppendTypeDefName(UInt32 token);
    private string GetSimpleTypeString(ElementType elem_type);
    private static bool IsNilToken(UInt32 token);
    private void Reset();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.MethodType : Type {
    private UInt32 _token;
    private UInt32 _enclosingToken;
    private string _name;
    private CorMethodSemanticsAttr _semanticsAttr;
    private TypeDefType _classType;
    private List`1<Symbol> _parameters;
    private Symbol _this;
    private bool _thisSet;
    private Symbol _returnSym;
    protected MethodType(ModuleSymbols modSymbols, UInt32 token, UInt32 enclosingToken, string name, CorMethodSemanticsAttr semanticsAttr);
    public static MethodType Create(ModuleSymbols modSymbols, UInt32 token);
    public virtual TypeDefType GetClassType();
    public virtual string GetMethodName();
    public virtual CorMethodSemanticsAttr GetMethodSemanticsAttr();
    public virtual bool GetIsConstructor();
    public virtual Symbol GetThis();
    public virtual List`1<Symbol> GetParameters();
    public virtual Symbol GetReturn();
    public List`1<Symbol> GetParametersCopy();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.ModuleRefProps : object {
    public UInt32 Token;
    public string Name;
    public ModuleRefProps(UInt32 token);
}
internal static class Microsoft.VisualStudio.IntelliTrace.Symbols.ModuleSignatureReader : object {
    private static ushort IMAGE_DOS_SIGNATURE;
    private static UInt32 IMAGE_NT_SIGNATURE;
    private static ushort IMAGE_NT_OPTIONAL_HDR32_MAGIC;
    private static ushort IMAGE_NT_OPTIONAL_HDR64_MAGIC;
    private static UInt32 IMAGE_DEBUG_TYPE_CODEVIEW;
    private static UInt32 RSDS_SIGNATURE;
    private static UInt32 METADATA_SIGNATURE;
    private static UInt32 _dosHeaderSize;
    private static UInt32 _pe32HeaderSize;
    private static UInt32 _pe64HeaderSize;
    private static UInt32 _sectionHeaderSize;
    private static UInt32 _debugDirectorySize;
    private static UInt32 _codeViewDataSize;
    private static UInt32 _clrHeaderSize;
    private static UInt32 _metadataHeaderSize;
    private static UInt32 _metadataStreamHeaderSize;
    private static UInt32 _metadataTablesHeaderSize;
    private static ModuleSignatureReader();
    public static bool GetSignature(string path, Guid& signature, UInt32& age);
    private static bool ReadDOSHeader(FileStream stream, UInt32& peHeaderFileOffset);
    private static bool ReadPEHeader(FileStream stream, UInt32 peHeaderOffset, UInt32& peHeaderSize, UInt32& numberOfSections, UInt32& debugDirectoryRVA, UInt32& debugDirectoryCount, UInt32& clrHeaderRVA);
    private static Byte[] ReadSectionHeaders(FileStream stream, UInt32 peHeaderOffset, UInt32 peHeaderSize, UInt32 numberOfSections);
    private static UInt32 ConvertRVAToFileOffset(Byte[] sectionHeaders, UInt32 numberOfSections, UInt32 rva);
    private static bool ReadDebugDirectory(FileStream stream, Byte[] sectionHeaders, UInt32 numberOfSections, UInt32 debugDirectoryRVA, UInt32 debugDirectoryCount, Guid& signature, UInt32& age);
    private static bool ReadCLRHeader(FileStream stream, Byte[] sectionHeaders, UInt32 numberOfSections, UInt32 clrHeaderRVA, Guid& signature);
    private static bool ReadMetadataStreamHeaders(FileStream stream, int numberOfStreams, UInt32& guidHeapOffset, UInt32& metadataTablesOffset);
    private static bool ReadMetadataHeader(FileStream stream, Byte[] sectionHeaders, UInt32 numberOfSections, UInt32 clrHeaderRVA, UInt32& metadataOffset, Int32& numberOfStreams);
    private static bool ReadMetadataTableHeader(FileStream stream, UInt32 offset, Int32& numberOfTables, Boolean& stringHeapSizeIs4, Boolean& guidHeapSizeIs4);
    private static Char[] ReadStreamName(FileStream stream);
    private static int BitCount(ulong bits);
    private static int ReadInt32(FileStream stream);
    private static short ReadInt16(FileStream stream);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.ModuleSymbols : object {
    private EmbeddedSymbolInfo _symInfo;
    private IMetaDataImport2 _metaData;
    private IMetaDataAssemblyImport _metaDataAssembly;
    private ISymUnmanagedReader _symReader;
    private ISymbolContextProvider _symbolContextProvider;
    private TraceLog _log;
    private bool _disposed;
    private Dictionary`2<string, ExportedTypeDefinition> _exportedTypeCache;
    private Guid _moduleId;
    private Nullable`1<UInt32> _assemblyToken;
    private string _moduleName;
    private MetadataImport _mappingMetadataImport;
    internal static int MAX_PATH;
    public ISymbolContextProvider SymbolContextProvider { get; public set; }
    private Dictionary`2<string, ExportedTypeDefinition> ExportedTypeCache { get; }
    public Guid ModuleId { get; }
    public string ModuleName { get; }
    public bool HasMetadata { get; }
    public object Metadata { get; }
    public bool HasDebugInfo { get; }
    public ISymUnmanagedReader DebugInfo { get; }
    public ModuleSymbols(Guid moduleId, string moduleName);
    public ModuleSymbols(object metaData, ISymUnmanagedReader symReader);
    public ModuleSymbols(EmbeddedSymbolInfo symInfo, string pdbPath, TraceLog log);
    public ModuleSymbols(object metaData, ISymUnmanagedReader symReader, TraceLog log);
    private static ModuleSymbols();
    public ISymbolContextProvider get_SymbolContextProvider();
    public void set_SymbolContextProvider(ISymbolContextProvider value);
    private Dictionary`2<string, ExportedTypeDefinition> get_ExportedTypeCache();
    private void Construct(object metaData, ISymUnmanagedReader symReader, TraceLog log);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public Guid get_ModuleId();
    public string get_ModuleName();
    public bool get_HasMetadata();
    public object get_Metadata();
    public bool get_HasDebugInfo();
    public ISymUnmanagedReader get_DebugInfo();
    public int LoadDebugInfo(string pdbPath);
    internal int GetSourceServerData(Int32& length, Byte*& data);
    internal _SavedMetadata InitSavedMetadata();
    public string GetMethodNameFromToken(UInt32 tokMethod);
    public bool TryGetMethodVersion(int tokMethod, Int32& currentVersion);
    public bool TryGetMethodTokensFromSpan(string filename, TextPosition begin, TextPosition end, List`1& tokMethods);
    public bool TryGetMethodTokensFromExactSourceLocation(string filename, TextPosition location, List`1& tokMethods);
    public bool TryGetMethodTokensNearSourceLocation(string filename, TextPosition location, List`1& tokMethods);
    private static bool TryGetDocumentUrl(ISymUnmanagedDocument document, String& url);
    private bool TryGetMethodTokensFromSourceLocation(string filename, TextPosition location, TextPosition endlocation, bool fExact, bool contain, List`1& tokMethods);
    public bool TryFindIndexOfNextUserCode(Int32& idx, int offset, int cPoints, Int32[] offsets, Int32[] lines, SourceSearchPolicy searchPolicy);
    public bool GetMethodOffsetsAndLines(int tokMethod, Int32[]& offsets, Int32[]& lines);
    public bool TryGetChecksumAndAlgorithmId(int tokMethod, int offset, SourceSearchPolicy searchPolicy, Guid& algorithm, UInt32 maxBytes, UInt32& bufferSize, Byte[] checksumBuffer);
    public bool TryGetSourceLines(int tokMethod, int offset, SourceSearchPolicy searchPolicy, String& filename, TextPosition& begin, TextPosition& end, Int32& latestVersion);
    public bool TryGetSequencePoint(int tokMethod, int offset, Int32& sequencePoint, Int32& beginOffset, Int32& endOffset);
    public bool TryGetSourceLanguage(int tokMethod, Guid& languageId);
    public bool TryFindCustomAttributeByName(UInt32 tokenDef, string customAttributeName);
    public TypeDefProps GetTypeDefProps(UInt32 tokenDef);
    public bool GetNestedClassProps(UInt32 typeDef, UInt32& enclosingTypeDef);
    private object ConvertDefaultValue(UInt32 eType, Byte* value, UInt32 valueLen);
    public FieldProps GetFieldProps(UInt32 tokenField);
    public ParamProps GetParamProps(UInt32 tokenParam);
    public MethodProps GetMethodProps(UInt32 tokenMethod, bool modifyPropName);
    public MemberRefProps GetMemberRefProps(UInt32 tokenMemberRef);
    public MethodSpecProps GetMethodSpecProps(UInt32 tokenMethodSpec);
    public void GetMethodSemantics(UInt32 token, UInt32& eventOrPropToken, CorMethodSemanticsAttr& semanticAttr);
    public bool GetPropertyName(UInt32 token, String& propName);
    public TypeRefProps GetTypeRefProps(UInt32 tokenTypeRef);
    public TypeSpec GetTypeSpec(UInt32 tokenTypeSpec, Boolean& fProteusTypeSpec);
    private AssemblyProps GetAssemblyProps();
    private AssemblyProps GetAssemblyProps(UInt32 tokenAssembly);
    private AssemblyRefProps GetAssemblyRefProps(UInt32 tokenAssemblyRef);
    private ModuleRefProps GetModuleRefProps(UInt32 tokenModuleRef);
    public ParamProps[] GetMethodParams(UInt32 tokenMethod);
    public UInt32[] GetTypeDefFields(UInt32 tokenDef);
    public UInt32 FindTypeRef(string strTypeRef);
    public UInt32 FindTypeDef(string strTypeDef, UInt32 tokenEnclosingClass);
    public UInt32 FindTypeDef(string strTypeDef, UInt32 tokenEnclosingClass, bool throwOnFail);
    public UInt32 FindMethodDef(string type, string method, Byte[] signature, bool throwOnFailure);
    public void ResolveTypeRef(string strTypeRef, UInt32& tokenTypeDef, ModuleSymbols& modSymbols);
    private void ResolveTypeRef(UInt32 tokAssemblyOrModuleRef, string strTypeRef, UInt32& tokenTypeDef, ModuleSymbols& modSymbols);
    private bool TryGetExportedTypeByName(string name, UInt32& token, ModuleSymbols& modSymbols);
    private static bool IsGreaterAssemblyVersion(ASSEMBLYMETADATA first, ASSEMBLYMETADATA second);
    public void ResolveTypeDefInAssembly(string strTypeDef, string strModule, UInt32& tokenTypeDef, ModuleSymbols& modSymbols, bool throwOnFail);
    public void ResolveTypeDefOrExportInAssembly(string strTypeDef, string strAssembly, UInt32& tokenTypeDef, ModuleSymbols& modSymbols);
    public void ResolveTypeRef(UInt32 tokenTypeRef, UInt32& tokenTypeDef, ModuleSymbols& modSymbols);
    public UInt32[] GetGenericParams(UInt32 tokenDef);
    public string GetGenericParamName(UInt32 genericParamToken);
    internal void ResolveProteusToken(UInt32 mdProtToken, UInt32& tokenTypeDef, ModuleSymbols& modSymbols);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.Native.ASSEMBLYMETADATA : ValueType {
    public ushort usMajorVersion;
    public ushort usMinorVersion;
    public ushort usBuildNumber;
    public ushort usRevisionNumber;
    public Char* szLocale;
    public UInt32 cbLocale;
    public UInt32* rProcessor;
    public UInt32 ulProcessor;
    public OSINFO* rOS;
    public UInt32 ulOS;
}
internal static class Microsoft.VisualStudio.IntelliTrace.Symbols.Native.Constants : object {
    internal static Guid clsidCorMetaDataRuntime;
    internal static Guid clsidCorMetaDataDispenser;
    internal static Guid clsidCorSymBinderSxS;
    internal static Guid iidIMetaDataImport;
    internal static Guid iidIMetaDataImport2;
    internal static Guid iidIMetaDataEmit2;
    internal static Guid iidIMetaDataAssemblyEmit;
    internal static UInt32 AllowRegistryAccess;
    internal static UInt32 AllowSymbolServerAccess;
    internal static UInt32 AllowOriginalPathAccess;
    internal static UInt32 AllowReferencePathAccess;
    internal static UInt32 cssAccurate;
    internal static UInt32 cssQuick;
    internal static UInt32 cssDiscardTransientCAs;
    private static Constants();
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.CorFieldAttr : Enum {
    public int value__;
    public static CorFieldAttr fdFieldAccessMask;
    public static CorFieldAttr fdPrivateScope;
    public static CorFieldAttr fdPrivate;
    public static CorFieldAttr fdFamANDAssem;
    public static CorFieldAttr fdAssembly;
    public static CorFieldAttr fdFamily;
    public static CorFieldAttr fdFamORAssem;
    public static CorFieldAttr fdPublic;
    public static CorFieldAttr fdStatic;
    public static CorFieldAttr fdInitOnly;
    public static CorFieldAttr fdLiteral;
    public static CorFieldAttr fdNotSerialized;
    public static CorFieldAttr fdSpecialName;
    public static CorFieldAttr fdPinvokeImpl;
    public static CorFieldAttr fdReservedMask;
    public static CorFieldAttr fdRTSpecialName;
    public static CorFieldAttr fdHasFieldMarshal;
    public static CorFieldAttr fdHasDefault;
    public static CorFieldAttr fdHasFieldRVA;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.CorGenericParamAttr : Enum {
    public int value__;
    public static CorGenericParamAttr gpVarianceMask;
    public static CorGenericParamAttr gpNonVariant;
    public static CorGenericParamAttr gpCovariant;
    public static CorGenericParamAttr gpContravariant;
    public static CorGenericParamAttr gpSpecialConstraintMask;
    public static CorGenericParamAttr gpNoSpecialConstraint;
    public static CorGenericParamAttr gpReferenceTypeConstraint;
    public static CorGenericParamAttr gpNotNullableValueTypeConstraint;
    public static CorGenericParamAttr gpDefaultConstructorConstraint;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.CorMethodAttr : Enum {
    public int value__;
    public static CorMethodAttr mdMemberAccessMask;
    public static CorMethodAttr mdPrivateScope;
    public static CorMethodAttr mdPrivate;
    public static CorMethodAttr mdFamANDAssem;
    public static CorMethodAttr mdAssem;
    public static CorMethodAttr mdFamily;
    public static CorMethodAttr mdFamORAssem;
    public static CorMethodAttr mdPublic;
    public static CorMethodAttr mdStatic;
    public static CorMethodAttr mdFinal;
    public static CorMethodAttr mdVirtual;
    public static CorMethodAttr mdHideBySig;
    public static CorMethodAttr mdVtableLayoutMask;
    public static CorMethodAttr mdReuseSlot;
    public static CorMethodAttr mdNewSlot;
    public static CorMethodAttr mdCheckAccessOnOverride;
    public static CorMethodAttr mdAbstract;
    public static CorMethodAttr mdSpecialName;
    public static CorMethodAttr mdPinvokeImpl;
    public static CorMethodAttr mdUnmanagedExport;
    public static CorMethodAttr mdReservedMask;
    public static CorMethodAttr mdRTSpecialName;
    public static CorMethodAttr mdHasSecurity;
    public static CorMethodAttr mdRequireSecObject;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.CorMethodImpl : Enum {
    public int value__;
    public static CorMethodImpl miCodeTypeMask;
    public static CorMethodImpl miIL;
    public static CorMethodImpl miNative;
    public static CorMethodImpl miOPTIL;
    public static CorMethodImpl miRuntime;
    public static CorMethodImpl miManagedMask;
    public static CorMethodImpl miUnmanaged;
    public static CorMethodImpl miManaged;
    public static CorMethodImpl miForwardRef;
    public static CorMethodImpl miPreserveSig;
    public static CorMethodImpl miInternalCall;
    public static CorMethodImpl miSynchronized;
    public static CorMethodImpl miNoInlining;
    public static CorMethodImpl miMaxMethodImplVal;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.CorOpenFlags : Enum {
    public UInt32 value__;
    public static CorOpenFlags ofRead;
    public static CorOpenFlags ofWrite;
    public static CorOpenFlags ofReadWriteMask;
    public static CorOpenFlags ofCopyMemory;
    public static CorOpenFlags ofReadOnly;
    public static CorOpenFlags ofTakeOwnership;
    public static CorOpenFlags ofNoTypeLib;
    public static CorOpenFlags ofNoTransform;
    public static CorOpenFlags ofReserved1;
    public static CorOpenFlags ofReserved2;
    public static CorOpenFlags ofReserved3;
    public static CorOpenFlags ofReserved;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.CorParamAttr : Enum {
    public int value__;
    public static CorParamAttr pdIn;
    public static CorParamAttr pdOut;
    public static CorParamAttr pdOptional;
    public static CorParamAttr pdReservedMask;
    public static CorParamAttr pdHasDefault;
    public static CorParamAttr pdHasFieldMarshal;
    public static CorParamAttr pdUnused;
}
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.CorSaveSize : Enum {
    public int value__;
    public static CorSaveSize cssAccurate;
    public static CorSaveSize cssQuick;
    public static CorSaveSize cssDiscardTransientCAs;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.CorTypeAttr : Enum {
    public int value__;
    public static CorTypeAttr tdVisibilityMask;
    public static CorTypeAttr tdNotPublic;
    public static CorTypeAttr tdPublic;
    public static CorTypeAttr tdNestedPublic;
    public static CorTypeAttr tdNestedPrivate;
    public static CorTypeAttr tdNestedFamily;
    public static CorTypeAttr tdNestedAssembly;
    public static CorTypeAttr tdNestedFamANDAssem;
    public static CorTypeAttr tdNestedFamORAssem;
    public static CorTypeAttr tdLayoutMask;
    public static CorTypeAttr tdAutoLayout;
    public static CorTypeAttr tdSequentialLayout;
    public static CorTypeAttr tdExplicitLayout;
    public static CorTypeAttr tdClassSemanticsMask;
    public static CorTypeAttr tdClass;
    public static CorTypeAttr tdInterface;
    public static CorTypeAttr tdAbstract;
    public static CorTypeAttr tdSealed;
    public static CorTypeAttr tdSpecialName;
    public static CorTypeAttr tdImport;
    public static CorTypeAttr tdSerializable;
    public static CorTypeAttr tdStringFormatMask;
    public static CorTypeAttr tdAnsiClass;
    public static CorTypeAttr tdUnicodeClass;
    public static CorTypeAttr tdAutoClass;
    public static CorTypeAttr tdCustomFormatClass;
    public static CorTypeAttr tdCustomFormatMask;
    public static CorTypeAttr tdBeforeFieldInit;
    public static CorTypeAttr tdForwarder;
    public static CorTypeAttr tdReservedMask;
    public static CorTypeAttr tdRTSpecialName;
    public static CorTypeAttr tdHasSecurity;
}
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.ElementType : Enum {
    public byte value__;
    public static ElementType ELEMENT_TYPE_END;
    public static ElementType ELEMENT_TYPE_VOID;
    public static ElementType ELEMENT_TYPE_BOOLEAN;
    public static ElementType ELEMENT_TYPE_CHAR;
    public static ElementType ELEMENT_TYPE_I1;
    public static ElementType ELEMENT_TYPE_U1;
    public static ElementType ELEMENT_TYPE_I2;
    public static ElementType ELEMENT_TYPE_U2;
    public static ElementType ELEMENT_TYPE_I4;
    public static ElementType ELEMENT_TYPE_U4;
    public static ElementType ELEMENT_TYPE_I8;
    public static ElementType ELEMENT_TYPE_U8;
    public static ElementType ELEMENT_TYPE_R4;
    public static ElementType ELEMENT_TYPE_R8;
    public static ElementType ELEMENT_TYPE_STRING;
    public static ElementType ELEMENT_TYPE_PTR;
    public static ElementType ELEMENT_TYPE_BYREF;
    public static ElementType ELEMENT_TYPE_VALUETYPE;
    public static ElementType ELEMENT_TYPE_CLASS;
    public static ElementType ELEMENT_TYPE_VAR;
    public static ElementType ELEMENT_TYPE_ARRAY;
    public static ElementType ELEMENT_TYPE_GENERICINST;
    public static ElementType ELEMENT_TYPE_TYPEDBYREF;
    public static ElementType ELEMENT_TYPE_I;
    public static ElementType ELEMENT_TYPE_U;
    public static ElementType ELEMENT_TYPE_FNPTR;
    public static ElementType ELEMENT_TYPE_OBJECT;
    public static ElementType ELEMENT_TYPE_SZARRAY;
    public static ElementType ELEMENT_TYPE_MVAR;
    public static ElementType ELEMENT_TYPE_CMOD_REQD;
    public static ElementType ELEMENT_TYPE_CMOD_OPT;
    public static ElementType ELEMENT_TYPE_INTERNAL;
    public static ElementType ELEMENT_TYPE_MODIFIER;
    public static ElementType ELEMENT_TYPE_SENTINEL;
    public static ElementType ELEMENT_TYPE_PINNED;
}
[GuidAttribute("587A461C-B80B-4f54-9194-5032589A6319")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.VisualStudio.IntelliTrace.Symbols.Native.IDiaReadExeAtOffsetCallback {
    public abstract virtual int ReadExecutableAt(ulong fileOffset, UInt32 cbData, UInt32& pcbData, Byte[] pbData);
}
[GuidAttribute("211EF15B-5317-4438-B196-DEC87B887693")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.VisualStudio.IntelliTrace.Symbols.Native.IMetaDataAssemblyEmit {
    public abstract virtual int DefineAssembly(IntPtr pbPublicKey, UInt32 cbPublicKey, UInt32 ulHashAlgId, string Name, ASSEMBLYMETADATA& pMetaData, UInt32 dwAssemblyFlags, UInt32& pma);
    public abstract virtual int DefineAssemblyRef(IntPtr pbPublicKeyOrToken, UInt32 cbPublicKeyOrToken, string Name, ASSEMBLYMETADATA& pMetaData, IntPtr pbHashValue, UInt32 cbHashValue, UInt32 dwAssemblyRefFlags, UInt32& pmdar);
    public abstract virtual int stub3();
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int stub7();
    public abstract virtual int stub8();
    public abstract virtual int stub9();
    public abstract virtual int stub10();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("EE62470B-E94B-424e-9B7C-2F00C9249F93")]
internal interface Microsoft.VisualStudio.IntelliTrace.Symbols.Native.IMetaDataAssemblyImport {
    public abstract virtual int GetAssemblyProps(UInt32 mda, IntPtr ppbPublicKey, IntPtr pcbPublicKey, IntPtr pulHashAlgId, Char* szName, UInt32 cchName, UInt32& pchName, ASSEMBLYMETADATA& pMetaData, IntPtr pdwAssemblyFlags);
    public abstract virtual int GetAssemblyRefProps(UInt32 mdar, IntPtr ppbPublicKeyOrToken, IntPtr pcbPublicKeyOrToken, Char* szName, UInt32 cchName, UInt32& pchName, ASSEMBLYMETADATA& pMetaData, IntPtr ppbHashValue, IntPtr pcbHashValue, IntPtr pdwAssemblyRefFlags);
    public abstract virtual int stub_GetFileProp();
    public abstract virtual int GetExportedTypeProps(UInt32 mdToken, Char* szName, UInt32 cchName, UInt32& pchName, UInt32& tokenImplementation, UInt32& tokenTypeDef, UInt32& exportedTypeFlags);
    public abstract virtual int stub_GetManifestResourceProps();
    public abstract virtual int stub_EnumAssemblyRefs();
    public abstract virtual int stub_EnumFiles();
    public abstract virtual int stub_EnumExportedTypes();
    public abstract virtual int stub_EnumManifestResources();
    public abstract virtual int GetAssemblyFromScope(UInt32& ptkAssembly);
    public abstract virtual int FindExportedTypeByName(string szName, UInt32 enclosingType, UInt32& mdToken);
    public abstract virtual int stub_FindManifestResourceByName();
    public abstract virtual void stub_CloseEnum();
    public abstract virtual int stub_FindAssembliesByName();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("809c652e-7396-11d2-9771-00A0C9B4d50c")]
internal interface Microsoft.VisualStudio.IntelliTrace.Symbols.Native.IMetaDataDispenser {
    public abstract virtual int DefineScope(Guid& rclsid, UInt32 dwCreateFlags, Guid& riid, IntPtr& ppIUnk);
    public abstract virtual int OpenScope(string szScope, UInt32 dwOpenFlags, Guid& riid, IntPtr& ppIUnk);
    public abstract virtual int OpenScopeOnMemory(IntPtr pData, UInt32 cbData, UInt32 dwOpenFlags, Guid& riid, IntPtr& ppIUnk);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("F5DD9950-F693-42e6-830E-7B833E8146A9")]
internal interface Microsoft.VisualStudio.IntelliTrace.Symbols.Native.IMetaDataEmit2 {
    public abstract virtual int SetModuleProps(Char* szName);
    public abstract virtual int stub_Save();
    public abstract virtual int stub_SaveToStream();
    public abstract virtual int GetSaveSize(UInt32 fSave, UInt32& pdwSaveSize);
    public abstract virtual int DefineTypeDef(Char* szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32[] rtkImplements, UInt32& token);
    public abstract virtual int stub_DefineNestedType();
    public abstract virtual int stub_SetHandler();
    public abstract virtual int DefineMethod(UInt32 td, Char* szName, UInt32 dwMethodFlags, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags, UInt32& token);
    public abstract virtual int stub_DefineMethodImpl();
    public abstract virtual int DefineTypeRefByName(UInt32 tkResolutionScope, Char* szName, UInt32& token);
    public abstract virtual int stub_DefineImportType();
    public abstract virtual int DefineMemberRef(UInt32 tkImport, Char* szName, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32& token);
    public abstract virtual int stub_DefineImportMember();
    public abstract virtual int stub_DefineEvent();
    public abstract virtual int stub_SetClassLayout();
    public abstract virtual int stub_DeleteClassLayout();
    public abstract virtual int stub_SetFieldMarshal();
    public abstract virtual int stub_DeleteFieldMarshal();
    public abstract virtual int stub_DefinePermissionSet();
    public abstract virtual int stub_SetRVA();
    public abstract virtual int stub_GetTokenFromSig();
    public abstract virtual int DefineModuleRef(Char* szName, UInt32& token);
    public abstract virtual int stub_SetParent();
    public abstract virtual int GetTokenFromTypeSpec(Byte* pvSig, UInt32 pcbSig, UInt32& token);
    public abstract virtual int SaveToMemory(IntPtr pbData, UInt32 cbData);
    public abstract virtual int DefineUserString(Char* szString, UInt32 cchString, UInt32& token);
    public abstract virtual int stub_DeleteToken();
    public abstract virtual int SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public abstract virtual int SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements);
    public abstract virtual int stub_SetEventProps();
    public abstract virtual int stub_SetPermissionSetProps();
    public abstract virtual int stub_DefinePinvokeMap();
    public abstract virtual int stub_SetPinvokeMap();
    public abstract virtual int stub_DeletePinvokeMap();
    public abstract virtual int stub_DefineCustomAttribute();
    public abstract virtual int stub_SetCustomAttributeValue();
    public abstract virtual int DefineField(UInt32 td, Char* szName, UInt32 dwFieldFlags, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, Byte* pValue, UInt32 cbValue, UInt32& token);
    public abstract virtual int stub_DefineProperty();
    public abstract virtual int DefineParam(UInt32 md, UInt32 ulParamSeq, Char* szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue, UInt32& token);
    public abstract virtual int stub_SetFieldProps();
    public abstract virtual int stub_SetPropertyProps();
    public abstract virtual int SetParamProps(UInt32 pd, Char* szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    public abstract virtual int stub_DefineSecurityAttributeSet();
    public abstract virtual int stub_ApplyEditAndContinue();
    public abstract virtual int stub_TranslateSigWithScope();
    public abstract virtual int stub_SetMethodImplFlags();
    public abstract virtual int stub_SetFieldRVA();
    public abstract virtual int stub_Merge();
    public abstract virtual int stub_MergeEnd();
    public abstract virtual int DefineMethodSpec(UInt32 tkParent, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32& token);
    public abstract virtual int stub_GetDeltaSaveSize();
    public abstract virtual int stub_SaveDelta();
    public abstract virtual int stub_SaveDeltaToStream();
    public abstract virtual int stub_SaveDeltaToMemory();
    public abstract virtual int DefineGenericParam(UInt32 tkToken, UInt32 ulParamSeq, UInt32 dwParamFlags, Char* szName, UInt32 reserved, Void* rtkConstraints, UInt32& token);
    public abstract virtual int SetGenericParamProps(UInt32 tkToken, UInt32 dwParamFlags, Char* szName, UInt32 reserved, Void* rtkConstraints);
    public abstract virtual int stub_ResetENCLog();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("FCE5EFA0-8BBA-4f8e-A036-8F2022B08466")]
internal interface Microsoft.VisualStudio.IntelliTrace.Symbols.Native.IMetaDataImport2 {
    public abstract virtual int CloseEnum(Void* hEnum);
    public abstract virtual int stub2();
    public abstract virtual int stub3();
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int EnumTypeRefs(Void*& phEnum, UInt32& rTypeRefs, UInt32 cMax, UInt32& pcTypeRefs);
    public abstract virtual int FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass, UInt32& ptd);
    public abstract virtual int GetScopeProps(Char* szName, UInt32 cchName, UInt32& pchName, Guid& mvid);
    public abstract virtual int stub9();
    public abstract virtual int GetTypeDefProps(UInt32 td, Char* szTypeDef, UInt32 cchTypeDef, UInt32& pchTypeDef, UInt32& pdwTypeDefFlags, UInt32& ptkExtends);
    public abstract virtual int stub11();
    public abstract virtual int GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, Char* szName, UInt32 cchName, UInt32& pchName);
    public abstract virtual int ResolveTypeRef(UInt32 tr, Guid riid, Object& ppIScope, UInt32& ptd);
    public abstract virtual int stub14();
    public abstract virtual int stub15();
    public abstract virtual int stub16();
    public abstract virtual int EnumMethodsWithName(IntPtr& hEnum, UInt32 typeDef, string name, UInt32& token, UInt32 maxLength, UInt32& actualLength);
    public abstract virtual int EnumFields(Void*& phEnum, UInt32 cl, UInt32& rFields, UInt32 cMax, UInt32& pcTokens);
    public abstract virtual int EnumFieldsWithName(Void*& phEnum, UInt32 cl, string szName, UInt32& rFields, UInt32 cMax, UInt32& pcTokens);
    public abstract virtual int EnumParams(Void*& phEnum, UInt32 mb, UInt32& rParam, UInt32 cMax, UInt32& pcTokens);
    public abstract virtual int stub21();
    public abstract virtual int stub22();
    public abstract virtual int stub23();
    public abstract virtual int stub24();
    public abstract virtual int FindMethod(UInt32 tkTypeDef, string szName, Byte* pvSigBlob, int cbSigBlob, UInt32& ptkMethodDef);
    public abstract virtual int stub26();
    public abstract virtual int stub27();
    public abstract virtual int GetMethodProps(UInt32 tokMethodDef, UInt32& tokTypeDef, Char* methodName, UInt32 cchMethodStringBuilderCapacity, UInt32& cchMethodReturned, UInt32& attributeflags, Byte*& pvSigBlob, UInt32& cbSigBlob, UInt32& codeRVA, UInt32& implFlags);
    public abstract virtual int GetMemberRefProps(UInt32 tokMemberRref, UInt32& tokParent, Char* memberName, UInt32 cchMemberStringBuilderCapacity, UInt32& cchMemberReturned, Byte*& pvSigBlob, UInt32& cbSigBlob);
    public abstract virtual int stub30();
    public abstract virtual int stub31();
    public abstract virtual int GetEventProps(UInt32 ev, UInt32& pClass, Char* szEvent, UInt32 cchEvent, UInt32& pchEvent, IntPtr pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, IntPtr rmdOtherMethod, UInt32 cMax, IntPtr pcOtherMethod);
    public abstract virtual int EnumMethodSemantics(Void*& phEnum, UInt32 mb, UInt32* rEventProp, UInt32 cMax, UInt32& pcEventProp);
    public abstract virtual int GetMethodSemantics(UInt32 mb, UInt32 tkEventProp, UInt32& pdwSemanticsFlags);
    public abstract virtual int stub35();
    public abstract virtual int stub36();
    public abstract virtual int stub37();
    public abstract virtual int stub38();
    public abstract virtual int stub39();
    public abstract virtual int GetModuleRefProps(UInt32 mur, Char* buffer, UInt32 cchName, UInt32& pchName);
    public abstract virtual int EnumModuleRefs(Void*& phEnum, UInt32& rModuleRefs, UInt32 cmax, UInt32& pcModuleRefs);
    public abstract virtual int GetTypeSpecFromToken(UInt32 tokTypeSpec, Byte*& ppvSigBlob, UInt32& pcbSigBlob);
    public abstract virtual int stub43();
    public abstract virtual int stub44();
    public abstract virtual int GetUserString(UInt32 stk, Char* szString, UInt32 cchString, UInt32& pcStrings);
    public abstract virtual int stub46();
    public abstract virtual int stub47();
    public abstract virtual int stub48();
    public abstract virtual int EnumUserStrings(Void*& phEnum, UInt32& rStrings, UInt32 cmax, UInt32& pcStrings);
    public abstract virtual int stub50();
    public abstract virtual int stub51();
    public abstract virtual int stub52();
    public abstract virtual int FindTypeRef(UInt32 tkResolutionScope, string szName, UInt32& ptr);
    public abstract virtual int stub54();
    public abstract virtual int GetFieldProps(UInt32 mb, UInt32& pClass, Char* szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, Byte*& ppValue, UInt32& pcchValue);
    public abstract virtual int GetPropertyProps(UInt32 prop, UInt32& pClass, Char* szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, Byte*& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, UInt32& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32& rmdOtherMethod, UInt32 cMax, UInt32& pcOtherMethod);
    public abstract virtual int GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, Char* szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, Byte*& ppValue, UInt32& pcchValue);
    public abstract virtual int GetCustomAttributeByName(UInt32 tkObj, string szName, Byte*& ppData, UInt32& pcbData);
    public abstract virtual int stub59();
    public abstract virtual int GetNestedClassProps(UInt32 tdNestedClass, UInt32& ptdEnclosingClass);
    public abstract virtual int stub61();
    public abstract virtual int stub62();
    public abstract virtual int EnumGenericParams(Void*& phEnum, UInt32 tk, UInt32& rGenericParams, UInt32 cMax, UInt32& pcGenericParams);
    public abstract virtual int GetGenericParamProps(UInt32 gp, UInt32* pulParamSeq, UInt32* pdwParamFlags, UInt32* ptOwner, UInt32* reserved, Char* wzName, UInt32 cchName, UInt32& pchName);
    public abstract virtual int GetMethodSpecProps(UInt32 tokMethodSpec, UInt32& tokParent, Byte*& pvSigBlob, UInt32& cbSigBlob);
    public abstract virtual int stub_EnumGenericParamConstraints();
    public abstract virtual int stub_GetGenericParamConstraintProps();
    public abstract virtual int stub_GetPEKind();
    public abstract virtual int stub_GetVersionString();
    public abstract virtual int stub_EnumMethodSpecs();
}
[GuidAttribute("BADB5F70-58DA-43a9-A1C6-D74819F19B15")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface Microsoft.VisualStudio.IntelliTrace.Symbols.Native.IMetaDataTables2 {
    public abstract virtual int stub1();
    public abstract virtual int stub2();
    public abstract virtual int stub3();
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int stub7();
    public abstract virtual int stub8();
    public abstract virtual int stub9();
    public abstract virtual int stub10();
    public abstract virtual int stub11();
    public abstract virtual int stub12();
    public abstract virtual int stub13();
    public abstract virtual int stub14();
    public abstract virtual int stub15();
    public abstract virtual int stub16();
    public abstract virtual int stub17();
    public abstract virtual int stub18();
    public abstract virtual int stub19();
    public abstract virtual int GetMetaDataStorage(IntPtr& pvMd, UInt32& cbMd);
    public abstract virtual int stub21();
}
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.IndexType : Enum {
    public byte value__;
    public static IndexType SIG_INDEX_TYPE_TYPEDEF;
    public static IndexType SIG_INDEX_TYPE_TYPEREF;
    public static IndexType SIG_INDEX_TYPE_TYPESPEC;
    public static IndexType SIG_INDEX_TYPE_PROTEUSTOKEN;
    public static IndexType SIG_INDEX_TYPE_MASK;
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.Native.OSINFO : ValueType {
    public UInt32 dwOSPlatformId;
    public UInt32 dwOSMajorVersion;
    public UInt32 dwOSMinorVersion;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.SignatureType : Enum {
    public byte value__;
    public static SignatureType SIG_METHOD_DEFAULT;
    public static SignatureType SIG_METHOD_C;
    public static SignatureType SIG_METHOD_STDCALL;
    public static SignatureType SIG_METHOD_THISCALL;
    public static SignatureType SIG_METHOD_FASTCALL;
    public static SignatureType SIG_METHOD_VARARG;
    public static SignatureType SIG_FIELD;
    public static SignatureType SIG_LOCAL_SIG;
    public static SignatureType SIG_PROPERTY;
    public static SignatureType SIG_UNMGD;
    public static SignatureType SIG_GENERICINST;
    public static SignatureType SIG_NATIVEVARARG;
    public static SignatureType SIG_CALLCONV_MAX;
    public static SignatureType SIG_CALLCONV_MASK;
    public static SignatureType SIG_GENERIC;
    public static SignatureType SIG_HASTHIS;
    public static SignatureType SIG_EXPLICITTHIS;
}
internal enum Microsoft.VisualStudio.IntelliTrace.Symbols.Native.TokenType : Enum {
    public byte value__;
    public static TokenType Module;
    public static TokenType TypeRef;
    public static TokenType TypeDef;
    public static TokenType FieldDef;
    public static TokenType MethodDef;
    public static TokenType ParamDef;
    public static TokenType InterfaceImpl;
    public static TokenType MemberRef;
    public static TokenType CustomAttribute;
    public static TokenType Permission;
    public static TokenType Signature;
    public static TokenType Event;
    public static TokenType Property;
    public static TokenType ModuleRef;
    public static TokenType TypeSpec;
    public static TokenType Assembly;
    public static TokenType AssemblyRef;
    public static TokenType File;
    public static TokenType ExportedType;
    public static TokenType ManifestResource;
    public static TokenType GenericParam;
    public static TokenType MethodSpec;
    public static TokenType GenericParamConstraint;
    public static TokenType ProteusToken;
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.NotifyType : Type {
    private HeuristicNotifyPointSpecification _spec;
    public ProgrammableDataQuerySpec ProgrammableDataQuerySpec { get; }
    public DataQuery DataQuery { get; }
    public _CallStackInfo CallStackInfo { get; }
    internal NotifyType(HeuristicNotifyPointSpecification spec);
    public ProgrammableDataQuerySpec get_ProgrammableDataQuerySpec();
    public DataQuery get_DataQuery();
    public _CallStackInfo get_CallStackInfo();
    public string GetCategory();
    public string GetName();
    public string GetTypeName();
    public string GetMethodName();
    public string GetDescription();
    public int GetNotifyPointId();
    public string GetSettingsName();
    public string GetSpecModuleName();
    internal List`1<Symbol> GetFields();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.NullMethodType : MethodType {
    internal NullMethodType(ModuleSymbols modSymbols);
    public virtual string GetMethodName();
    public virtual TypeDefType GetClassType();
    public virtual bool GetIsConstructor();
    public virtual List`1<Symbol> GetParameters();
    public virtual Symbol GetReturn();
    public virtual Symbol GetThis();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.OptionalPE32Header : object {
    internal static int sizeOfOptionalPE32Header;
    internal ushort Magic;
    internal byte MajorLinkerVersion;
    internal byte MinorLinkerVersion;
    internal UInt32 SizeOfCode;
    internal UInt32 SizeOfInitializedData;
    internal UInt32 SizeOfUninitializedData;
    internal UInt32 AddressOfEntryPoint;
    internal UInt32 BaseOfCode;
    internal UInt32 BaseOfData;
    internal UInt32 ImageBase;
    internal UInt32 SectionAlignment;
    internal UInt32 FileAlignment;
    internal ushort MajorOperatingSystemVersion;
    internal ushort MinorOperatingSystemVersion;
    internal ushort MajorImageVersion;
    internal ushort MinorImageVersion;
    internal ushort MajorSubsystemVersion;
    internal ushort MinorSubsystemVersion;
    internal UInt32 Win32VersionValue;
    internal UInt32 SizeOfImage;
    internal UInt32 SizeOfHeaders;
    internal UInt32 CheckSum;
    internal ushort Subsystem;
    internal ushort DllCharacteristics;
    internal UInt32 SizeOfStackReserve;
    internal UInt32 SizeOfStackCommit;
    internal UInt32 SizeOfHeapReserve;
    internal UInt32 SizeOfHeapCommit;
    internal UInt32 LoaderFlags;
    internal UInt32 NumberOfRvaAndSizes;
    internal ImageDataDirectory[] ImageDirectories;
    internal OptionalPE32Header(ushort Magic, BinaryReader r);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.OptionalPE32PlusHeader : object {
    internal static int sizeOfOptionalPE32PlusHeader;
    internal ushort Magic;
    internal byte MajorLinkerVersion;
    internal byte MinorLinkerVersion;
    internal UInt32 SizeOfCode;
    internal UInt32 SizeOfInitializedData;
    internal UInt32 SizeOfUninitializedData;
    internal UInt32 AddressOfEntryPoint;
    internal UInt32 BaseOfCode;
    internal ulong ImageBase;
    internal UInt32 SectionAlignment;
    internal UInt32 FileAlignment;
    internal ushort MajorOperatingSystemVersion;
    internal ushort MinorOperatingSystemVersion;
    internal ushort MajorImageVersion;
    internal ushort MinorImageVersion;
    internal ushort MajorSubsystemVersion;
    internal ushort MinorSubsystemVersion;
    internal UInt32 Win32VersionValue;
    internal UInt32 SizeOfImage;
    internal UInt32 SizeOfHeaders;
    internal UInt32 CheckSum;
    internal ushort Subsystem;
    internal ushort DllCharacteristics;
    internal ulong SizeOfStackReserve;
    internal ulong SizeOfStackCommit;
    internal ulong SizeOfHeapReserve;
    internal ulong SizeOfHeapCommit;
    internal UInt32 LoaderFlags;
    internal UInt32 NumberOfRvaAndSizes;
    internal ImageDataDirectory[] ImageDirectories;
    internal OptionalPE32PlusHeader(ushort Magic, BinaryReader r);
}
[DebuggerDisplayAttribute("ParameterSymbol: Name = { GetName() }")]
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.ParameterSymbol : Symbol {
    private static UInt32 FLAGOUT;
    private ModuleSymbols _modSymbols;
    private ParamProps _props;
    private bool _isByRef;
    public ParameterSymbol(ModuleSymbols modSymbols, ParamProps props, Type type, bool isByRef);
    public virtual string GetName();
    public bool GetOutParam();
    public bool GetByRef();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.ParamProps : object {
    public UInt32 Token;
    public string Name;
    public UInt32 TokenMethod;
    public UInt32 SequencePosition;
    public UInt32 Flags;
    public UInt32 CPlusTypeFlag;
    public object Value;
    public ParamProps(UInt32 token);
}
public class Microsoft.VisualStudio.IntelliTrace.Symbols.PdbInfo : ValueType {
    public string FileName;
    public PdbVersionId VersionId;
    public string DebugDirectory;
    public string ModulePath;
    public string ExeDirectory;
    public ulong ModuleTimeStamp;
}
public class Microsoft.VisualStudio.IntelliTrace.Symbols.PdbVersionId : ValueType {
    public Guid Mvid;
    public UInt32 Age;
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.PEFile : object {
    internal CoffHeader CoffHeader;
    internal OptionalPE32Header OptionalPE32Header;
    internal OptionalPE32PlusHeader OptionalPE32PlusHeader;
    internal SectionHeader[] SectionHeaders;
    internal DebugDirectory[] DebugDirectories;
    internal Byte[][] DebugData;
    internal Byte[] raw;
    internal PEFile(string fileName, bool isTargetProcess64bit);
    private UInt32 RVAToFilePos(UInt32 address);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.PointerType : Type {
    private Type _elemType;
    public Type ElementType { get; }
    internal PointerType(Type elemType);
    public Type get_ElementType();
    public Symbol GetElementSymbol(string name);
}
[DebuggerDisplayAttribute("PrimitiveType: ElementType = {_elemType.ToString()}")]
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.PrimitiveType : Type {
    private ElementType _elemType;
    public bool IsString { get; }
    public bool IsVoid { get; }
    public bool IsPrimitive { get; }
    internal PrimitiveType(ElementType elemType);
    public bool get_IsString();
    public bool get_IsVoid();
    public bool get_IsPrimitive();
    public ElementType GetPrimitiveType();
    public int GetPrimitiveSize();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.ProgramSymbols : object {
    private Dictionary`2<Guid, ModuleSymbols> _symbols;
    internal ModuleSymbols Item { get; }
    internal IEnumerable`1<ModuleSymbols> Modules { get; }
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void Add(ModuleSymbols moduleSymbols);
    internal ModuleSymbols get_Item(Guid mvid);
    internal IEnumerable`1<ModuleSymbols> get_Modules();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.ProteusTypeSpecParser : TypeSpecParser {
    public ProteusTypeSpecParser(ModuleSymbols modSyms, TypeSpec spec, IList`1<Type> instanceTypes);
}
[DebuggerDisplayAttribute("ReturnSymbol: Name = { GetName() }")]
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.ReturnSymbol : Symbol {
    private bool _isByRef;
    public static string ReturnValString;
    public ReturnSymbol(Type type, bool isByRef);
    private static ReturnSymbol();
    public virtual string GetName();
    public bool GetByRef();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.SectionHeader : object {
    internal static int sizeOfSectionHeader;
    internal Byte[] Name;
    internal UInt32 VirtualSize;
    internal UInt32 VirtualAddress;
    internal UInt32 SizeOfRawData;
    internal UInt32 PointerToRawData;
    internal UInt32 PointerToRelocations;
    internal UInt32 PointerToLinenumbers;
    internal ushort NumberOfRelocations;
    internal ushort NumberOfLinenumbers;
    internal UInt32 Characteristics;
    internal SectionHeader(BinaryReader r);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.SignatureTypeInfo : object {
    public UInt32 NumberOfGenericParameters;
    public UInt32 PointerIndirectionCounter;
    public bool IsFunctionPointer;
    public bool IsSzArray;
    public bool IsGeneric;
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.SigParser : object {
    private Byte* pbBase;
    private Byte* pbCur;
    private Byte* pbEnd;
    [CompilerGeneratedAttribute]
private SigParserHandler <Handler>k__BackingField;
    public SigParserHandler Handler { get; public set; }
    public SigParser(SigParserHandler handler);
    [CompilerGeneratedAttribute]
public SigParserHandler get_Handler();
    [CompilerGeneratedAttribute]
public void set_Handler(SigParserHandler value);
    public bool Parse(Byte* blob, UInt32 len);
    public bool ParseTypeSpec(Byte* blob, UInt32 len);
    public bool ParseMethodSpec(Byte* blob, UInt32 len);
    private bool ParseArrayShape();
    private bool ParseByte(Byte* pbOut);
    private bool ParseCustomMod();
    private bool ParseField(byte num1);
    private bool ParseLocal();
    private bool ParseLocals(byte num1);
    private bool ParseMethod(byte num1);
    protected bool ParseNumber(UInt32* pOut);
    private bool ParseSignedNumber(Int32* pOut);
    private bool ParseOptionalCustomMods();
    private bool ParseOptionalCustomModsOrConstraint();
    private bool ParseParam();
    private bool ParseProperty(byte num1);
    private bool ParseMethodSpec();
    private bool ParseRetType();
    private bool ParseType();
    private bool ParseTypeSpec();
    protected virtual bool ParseTypeDefOrRefEncoded(Byte* pOutIndexType, UInt32* pOutIndex);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.Symbols.SigParserHandler : object {
    public virtual void NotifyBeginMethod(SignatureType elem_type);
    public virtual void NotifyEndMethod();
    public virtual void NotifyParamCount(UInt32 count);
    public virtual void NotifyBeginRetType();
    public virtual void NotifyEndRetType();
    public virtual void NotifyBeginParam();
    public virtual void NotifyEndParam();
    public virtual void NotifySentinal();
    public virtual void NotifyGenericParamCount(UInt32 count);
    public virtual void NotifyBeginField(SignatureType elem_type);
    public virtual void NotifyEndField();
    public virtual void NotifyBeginLocals(SignatureType elem_type);
    public virtual void NotifyEndLocals();
    public virtual void NotifyLocalsCount(UInt32 count);
    public virtual void NotifyBeginLocal();
    public virtual void NotifyEndLocal();
    public virtual void NotifyConstraint(ElementType elem_type);
    public virtual void NotifyBeginProperty(SignatureType elem_type);
    public virtual void NotifyEndProperty();
    public virtual void NotifyBeginArrayShape();
    public virtual void NotifyEndArrayShape();
    public virtual void NotifyRank(UInt32 rank);
    public virtual void NotifyNumSizes(UInt32 sizes);
    public virtual void NotifySize(UInt32 size);
    public virtual void NotifyNumLoBounds(UInt32 lobound);
    public virtual void NotifyLoBound(int lobound);
    public virtual void NotifyBeginType();
    public virtual void NotifyEndType();
    public virtual void NotifyTypedByref();
    public virtual void NotifyByref();
    public virtual void NotifyVoid();
    public virtual void NotifyCustomMod(byte cmod, IndexType indexType, UInt32 index);
    public virtual void NotifyTypeSimple(ElementType elem_type);
    public virtual void NotifyTypeDefOrRef(IndexType indexType, UInt32 index);
    public virtual void NotifyTypeGenericInst(ElementType elem_type, IndexType indexType, UInt32 index, UInt32 number);
    public virtual void NotifyTypeGenericTypeVariable(UInt32 number);
    public virtual void NotifyTypeGenericMemberVariable(UInt32 number);
    public virtual void NotifyTypeValueType();
    public virtual void NotifyTypeClass();
    public virtual void NotifyTypePointer();
    public virtual void NotifyTypeFunctionPointer();
    public virtual void NotifyTypeArray();
    public virtual void NotifyTypeSzArray();
}
internal static class Microsoft.VisualStudio.IntelliTrace.Symbols.SigUtil : object {
    internal static UInt32 GetTokenFromIndex(IndexType indexType, UInt32 index);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.Symbol : object {
    protected Type _type;
    protected Type _metadataType;
    protected string _name;
    public Type MetadataType { get; }
    public Symbol(Type type);
    public Symbol(Type type, string name);
    public virtual Type GetSymbolType();
    public virtual Type GetRawType();
    public virtual Type get_MetadataType();
    public virtual string GetName();
    public virtual void SetRuntimeType(Type t);
    public virtual FieldFlags GetFieldFlag();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.SymbolLocatorFactory : object {
    public sealed virtual int CreateSymbolLocator(string registryRoot, ISymbolLocator140& symbolLocator140Interface);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.SymbolLocatorFactoryInstance : object {
    [CompilerGeneratedAttribute]
private static ISymbolLocatorFactory <Factory>k__BackingField;
    private static object _syncRoot;
    public static ISymbolLocatorFactory Factory { get; public set; }
    private static SymbolLocatorFactoryInstance();
    [CompilerGeneratedAttribute]
public static ISymbolLocatorFactory get_Factory();
    [CompilerGeneratedAttribute]
public static void set_Factory(ISymbolLocatorFactory value);
    public static int CreateInstance(string registryRoot, ISymbolLocator140& symbolLocator);
}
public class Microsoft.VisualStudio.IntelliTrace.Symbols.SymbolSettings : ValueType {
    public string SymbolPath;
    public string CachePath;
    public string IncludeList;
    public string ExcludeList;
    public int IsManual;
    public int LoadAdjacent;
    public UInt32 ValidFields;
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.SymbolUtilities : object {
    public static Guid SymbolLocatorClassGuid;
    private static SymbolUtilities();
    public static T BytesToStructure(Byte[] bytes);
    public static string TryGetFileName(string path);
    public static string TryGetDirectory(string path);
    public static ulong TimeDateStampToFileTime(UInt32 timeDateStamp);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.SZArrayType : ArrayType {
    public SZArrayType(ModuleSymbols modSyms, Type elemType);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.Symbols.Type : object {
    protected ModuleSymbols _modSymbols;
    protected bool _isNullable;
    public bool IsNullable { get; public set; }
    internal ModuleSymbols ModuleSymbols { get; }
    protected Type(ModuleSymbols modSymbols);
    public static Type Create(ModuleSymbols modSymbols, UInt32 mdToken, IList`1<Type> instanceTypes);
    public static Type Create(ModuleSymbols modSymbols, UInt32 mdToken, IList`1<Type> instanceTypes, bool fResolveToPrimitives);
    public bool get_IsNullable();
    public void set_IsNullable(bool value);
    public string GetModuleName();
    internal ModuleSymbols get_ModuleSymbols();
    public Type ResolveInModule(int mdToken, Guid mvid);
    internal static Type ConvertFromNameToType(string name);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.TypeDefProps : object {
    public UInt32 Token;
    public string Name;
    public TypeDefFlags TypeFlags;
    public UInt32 TokenBase;
    public TypeDefProps(UInt32 token);
}
[DebuggerDisplayAttribute("TypeDefType: Type Name = {_props.Name}")]
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.TypeDefType : Type {
    private TypeDefProps _props;
    private IList`1<Type> _instanceTypes;
    private TypeDefType _baseType;
    public bool IsSealed { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public bool IsArray { get; }
    public bool IsClosed { get; }
    public bool HasGenericParams { get; }
    public bool IsDecimal { get; }
    public bool IsTimeSpan { get; }
    public bool IsDateTime { get; }
    public bool IsGuid { get; }
    public bool IsNullableContainer { get; }
    public bool IsObject { get; }
    protected TypeDefType(ModuleSymbols modSymbols);
    internal TypeDefType(ModuleSymbols modSymbols, UInt32 mdToken, IList`1<Type> instanceTypes);
    public virtual List`1<Symbol> GetFields();
    public virtual List`1<Symbol> GetFields(bool returnStatics);
    public virtual string GetName();
    public virtual TypeDefType GetBaseTypeDef();
    public IList`1<Type> GetInstanceTypes();
    public bool get_IsSealed();
    public bool get_IsEnum();
    public bool get_IsValueType();
    public bool get_IsArray();
    public bool get_IsClosed();
    public bool get_HasGenericParams();
    public bool get_IsDecimal();
    public bool get_IsTimeSpan();
    public bool get_IsDateTime();
    public bool get_IsGuid();
    public bool get_IsNullableContainer();
    public bool get_IsObject();
    private static bool IsCoreModule(string moduleName);
    public PrimitiveType GetEnumType();
    public Type GetNullableInnerType();
}
[DebuggerDisplayAttribute("TypeMemberSymbol: Name = { GetName() }")]
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.TypeMemberSymbol : Symbol {
    private FieldProps _props;
    public TypeMemberSymbol(FieldProps props, Type type);
    public virtual string GetName();
    public object GetLiteralValue();
    public virtual FieldFlags GetFieldFlag();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.TypeRefProps : object {
    public UInt32 Token;
    public UInt32 TokenResolutionScope;
    public string Name;
    public TypeRefProps(UInt32 token);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.TypeSigParser : SigParserHandler {
    protected ModuleSymbols _modSymbols;
    protected Type _currentType;
    protected bool _isByRef;
    protected Stack`1<ElementType> _typeStack;
    protected Stack`1<Type> _currentTypeStack;
    protected Stack`1<Tuple`3<IndexType, UInt32, UInt32>> _genericInstStack;
    protected int _rank;
    protected SigParser _parser;
    protected TypeSigParser(ModuleSymbols modSymbols);
    protected TypeSigParser(ModuleSymbols modSymbols, SigParser parser);
    public virtual void NotifyBeginType();
    public virtual void NotifyEndType();
    public virtual void NotifyBeginParam();
    public virtual void NotifyByref();
    public virtual void NotifyTypePointer();
    public virtual void NotifyTypeArray();
    public virtual void NotifyTypeSzArray();
    public virtual void NotifyTypeClass();
    public virtual void NotifyTypeValueType();
    public virtual void NotifyTypeGenericInst(ElementType elem_type, IndexType indexType, UInt32 index, UInt32 number);
    public virtual void NotifyTypeGenericTypeVariable(UInt32 number);
    public virtual void NotifyTypeGenericMemberVariable(UInt32 number);
    public virtual void NotifyTypeSimple(ElementType elementType);
    public virtual void NotifyTypeDefOrRef(IndexType indexType, UInt32 index);
    public virtual void NotifyVoid();
    public virtual void NotifyTypedByref();
    public virtual void NotifyRank(UInt32 rank);
    public virtual void NotifyTypeFunctionPointer();
    public virtual void NotifyNumSizes(UInt32 sizes);
    public virtual void NotifySize(UInt32 size);
    public virtual void NotifyNumLoBounds(UInt32 lobound);
    public virtual void NotifyLoBound(int lobound);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.TypeSpec : object {
    public UInt32 Token;
    public Byte[] Signature;
    public TypeSpec(UInt32 token);
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.TypeSpecParser : TypeSigParser {
    private TypeSpec _spec;
    private IList`1<Type> _instanceTypes;
    public TypeSpecParser(ModuleSymbols modSyms, TypeSpec spec, IList`1<Type> instanceTypes);
    public TypeSpecParser(ModuleSymbols modSyms, TypeSpec spec, IList`1<Type> instanceTypes, SigParser parser);
    public virtual void NotifyTypeGenericTypeVariable(UInt32 number);
    public Type GetConstructedType();
}
internal class Microsoft.VisualStudio.IntelliTrace.Symbols.UnknownType : TypeDefType {
    private string _typeName;
    internal UnknownType(string typeName, ModuleSymbols modSymbols);
    public virtual string GetName();
    public virtual TypeDefType GetBaseTypeDef();
    public virtual List`1<Symbol> GetFields();
    public virtual List`1<Symbol> GetFields(bool returnStatics);
}
public class Microsoft.VisualStudio.IntelliTrace.SystemInformationEvent : OrdinalEvent {
    private _SystemInfo systemInfo;
    private List`1<DisplaySettings> displaySettings;
    public string SystemManufacturer { get; }
    public string SystemProductName { get; }
    public string BiosVersion { get; }
    public string BiosDate { get; }
    public int ProcessorArchitecture { get; }
    public int NumberOfProcessors { get; }
    public int ProcessorLevel { get; }
    public int ProcessorRevision { get; }
    public int ProcessorSpeed { get; }
    public bool IsWow64Process { get; }
    public string UserDomain { get; }
    public string UserName { get; }
    public string ComputerName { get; }
    public string WindowsDirectory { get; }
    public string SystemDirectory { get; }
    public string ClrVersion { get; }
    public int OSMajorVersion { get; }
    public int OSMinorVersion { get; }
    public int OSBuildNumber { get; }
    public int OSProductType { get; }
    public string ServicePack { get; }
    public int OSRole { get; }
    public int SystemLocaleId { get; }
    public long TotalPhysicalBytes { get; }
    public long AvailablePhysicalBytes { get; }
    public long TotalPageFileBytes { get; }
    public long AvailablePageFileBytes { get; }
    public long TotalVirtualMemoryBytes { get; }
    public long AvailableVirtualMemoryBytes { get; }
    public IList`1<DisplaySettings> Displays { get; }
    public string TimeZone { get; }
    public long TimeZoneBias { get; }
    public long StartTime { get; }
    public long TimerStartTime { get; }
    public long TimerFrequency { get; }
    internal _SystemInfo InnerEvent { get; }
    internal SystemInformationEvent(_SystemInfo si);
    public string get_SystemManufacturer();
    public string get_SystemProductName();
    public string get_BiosVersion();
    public string get_BiosDate();
    public int get_ProcessorArchitecture();
    public int get_NumberOfProcessors();
    public int get_ProcessorLevel();
    public int get_ProcessorRevision();
    public int get_ProcessorSpeed();
    public bool get_IsWow64Process();
    public string get_UserDomain();
    public string get_UserName();
    public string get_ComputerName();
    public string get_WindowsDirectory();
    public string get_SystemDirectory();
    public string get_ClrVersion();
    public int get_OSMajorVersion();
    public int get_OSMinorVersion();
    public int get_OSBuildNumber();
    public int get_OSProductType();
    public string get_ServicePack();
    public int get_OSRole();
    public int get_SystemLocaleId();
    public long get_TotalPhysicalBytes();
    public long get_AvailablePhysicalBytes();
    public long get_TotalPageFileBytes();
    public long get_AvailablePageFileBytes();
    public long get_TotalVirtualMemoryBytes();
    public long get_AvailableVirtualMemoryBytes();
    public IList`1<DisplaySettings> get_Displays();
    public string get_TimeZone();
    public long get_TimeZoneBias();
    public long get_StartTime();
    public long get_TimerStartTime();
    public long get_TimerFrequency();
    internal _SystemInfo get_InnerEvent();
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.TaggedBlobUnpacker : BlobUnpacker {
    public TaggedBlobUnpacker(Byte[] memory, int lowerBound, int upperBound, PackOptions options);
    public TaggedBlobUnpacker(Byte[] memory, int offset, PackOptions options);
    public TaggedBlobUnpacker(Byte[] memory, PackOptions options);
    public TaggedBlobUnpacker(Byte[] memory);
    public virtual UnpackResult Unpack(Boolean& value);
    public virtual UnpackResult Unpack(SByte& value);
    public virtual UnpackResult Unpack(Byte& value);
    public virtual UnpackResult Unpack(Char& value);
    public virtual UnpackResult Unpack(Int16& value);
    public virtual UnpackResult Unpack(UInt16& value);
    public virtual UnpackResult Unpack(Int32& value);
    public virtual UnpackResult Unpack(UInt32& value);
    public virtual UnpackResult Unpack(Int64& value);
    public virtual UnpackResult Unpack(UInt64& value);
    public virtual UnpackResult Unpack(Single& value);
    public virtual UnpackResult Unpack(Double& value);
    public virtual UnpackResult Unpack(Decimal& value);
    public virtual UnpackResult Unpack(String& value, Int32& originalSize);
    public virtual UnpackResult Unpack(bool isNestedField, Type elementType, BlobUnpacker& value, ArrayDimensionLayout[] dimensions, Int16& savedElements);
    public virtual UnpackResult UnpackLength(Int32& length);
    public virtual int UnpackInvalidRefDepth();
    private void UnpackUnicodeString(String& value);
    private void UnpackAnsiString(String& value);
    public virtual UnpackResult Unpack(BlobUnpacker& unpacker, ObjectLayout layout, bool isValueType);
    public virtual UnpackResult Unpack(BlobUnpacker& unpacker);
    public virtual UnpackResult UnpackRest(BlobUnpacker& unpacker);
    public virtual void BeforeUnpack(int typeSize);
    public virtual void AfterUnpack(int typeSize);
}
public class Microsoft.VisualStudio.IntelliTrace.TailCallSiteEvent : CallSiteEvent {
    internal TailCallSiteEvent(CallSiteData* pData, byte instructionLength);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.TestCase : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <StartOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <EndOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TestExecutionId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TCMId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TestCaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TestCaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TestCasePassed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChildTestCase>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TestStep> <TestSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private TestSession <ParentSession>k__BackingField;
    internal Nullable`1<long> StartOrdinal { get; private set; }
    internal Nullable`1<long> EndOrdinal { get; private set; }
    internal Nullable`1<ulong> StartTime { get; private set; }
    internal Nullable`1<ulong> EndTime { get; private set; }
    internal Guid SessionId { get; }
    internal Guid TestExecutionId { get; private set; }
    internal int TCMId { get; private set; }
    internal Guid TestCaseId { get; private set; }
    internal string TestCaseName { get; private set; }
    internal bool TestCasePassed { get; private set; }
    internal bool IsChildTestCase { get; private set; }
    internal IList`1<TestStep> TestSteps { get; private set; }
    private TestSession ParentSession { get; private set; }
    internal void SetStartData(long startOrdinal, ulong startTime, Guid testExecutionId, int tcmId, Guid testCaseId, string testCaseName, bool isChild, TestSession parentSession);
    internal void SetEndData(long endOrdinal, ulong endTime, Guid testExecutionId, int tcmId, Guid testCaseId, string testCaseName, bool isChild, TestSession parentSession, bool testCasePassed);
    internal void SetCaseId(Guid testCaseId);
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_StartOrdinal();
    [CompilerGeneratedAttribute]
private void set_StartOrdinal(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_EndOrdinal();
    [CompilerGeneratedAttribute]
private void set_EndOrdinal(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_EndTime();
    [CompilerGeneratedAttribute]
private void set_EndTime(Nullable`1<ulong> value);
    internal Guid get_SessionId();
    [CompilerGeneratedAttribute]
internal Guid get_TestExecutionId();
    [CompilerGeneratedAttribute]
private void set_TestExecutionId(Guid value);
    [CompilerGeneratedAttribute]
internal int get_TCMId();
    [CompilerGeneratedAttribute]
private void set_TCMId(int value);
    [CompilerGeneratedAttribute]
internal Guid get_TestCaseId();
    [CompilerGeneratedAttribute]
private void set_TestCaseId(Guid value);
    [CompilerGeneratedAttribute]
internal string get_TestCaseName();
    [CompilerGeneratedAttribute]
private void set_TestCaseName(string value);
    [CompilerGeneratedAttribute]
internal bool get_TestCasePassed();
    [CompilerGeneratedAttribute]
private void set_TestCasePassed(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsChildTestCase();
    [CompilerGeneratedAttribute]
private void set_IsChildTestCase(bool value);
    [CompilerGeneratedAttribute]
internal IList`1<TestStep> get_TestSteps();
    [CompilerGeneratedAttribute]
private void set_TestSteps(IList`1<TestStep> value);
    [CompilerGeneratedAttribute]
private TestSession get_ParentSession();
    [CompilerGeneratedAttribute]
private void set_ParentSession(TestSession value);
}
public class Microsoft.VisualStudio.IntelliTrace.TestCaseEndEvent : TestCaseEvent {
    [CompilerGeneratedAttribute]
private int <TestCaseOutcome>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TestCasePassed>k__BackingField;
    public int TestCaseOutcome { get; private set; }
    public bool TestCasePassed { get; private set; }
    internal TestCaseEndEvent(_TestCaseEndContext testCaseEndContext);
    [CompilerGeneratedAttribute]
public int get_TestCaseOutcome();
    [CompilerGeneratedAttribute]
private void set_TestCaseOutcome(int value);
    [CompilerGeneratedAttribute]
public bool get_TestCasePassed();
    [CompilerGeneratedAttribute]
private void set_TestCasePassed(bool value);
}
public abstract class Microsoft.VisualStudio.IntelliTrace.TestCaseEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private Guid <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TestExecutionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TestCaseId>k__BackingField;
    private _TestCaseContext testCaseContext;
    public long EventTime { get; }
    public Guid SessionId { get; protected set; }
    public Guid TestExecutionId { get; protected set; }
    public Guid TestCaseId { get; protected set; }
    public int TestCaseManagerId { get; }
    public string TestCaseName { get; }
    public bool IsChildTestCase { get; }
    internal _TestCaseContext InnerEvent { get; }
    internal TestCaseEvent(_TestCaseContext testCaseContext);
    public long get_EventTime();
    [CompilerGeneratedAttribute]
public Guid get_SessionId();
    [CompilerGeneratedAttribute]
protected void set_SessionId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_TestExecutionId();
    [CompilerGeneratedAttribute]
protected void set_TestExecutionId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_TestCaseId();
    [CompilerGeneratedAttribute]
protected void set_TestCaseId(Guid value);
    public int get_TestCaseManagerId();
    public string get_TestCaseName();
    public bool get_IsChildTestCase();
    internal _TestCaseContext get_InnerEvent();
}
public class Microsoft.VisualStudio.IntelliTrace.TestCasePauseEvent : TestCaseEvent {
    internal TestCasePauseEvent(_TestCaseContext testCaseContext);
}
public class Microsoft.VisualStudio.IntelliTrace.TestCaseResetEvent : TestCaseEvent {
    internal TestCaseResetEvent(_TestCaseContext testCaseContext);
}
public class Microsoft.VisualStudio.IntelliTrace.TestCaseResumeEvent : TestCaseEvent {
    internal TestCaseResumeEvent(_TestCaseContext testCaseContext);
}
public class Microsoft.VisualStudio.IntelliTrace.TestCaseStartEvent : TestCaseEvent {
    internal TestCaseStartEvent(_TestCaseContext testCaseContext);
}
public class Microsoft.VisualStudio.IntelliTrace.TestChain : ListChain {
    internal TestChain(TestStreamChain sourceChain);
}
internal class Microsoft.VisualStudio.IntelliTrace.TestImpact.TestCoverageManager : object {
    private List`1<ModuleCoverageBuffer> _moduleBuffers;
    private Test[] _tests;
    private string _loggerName;
    private IntelliTraceFileBase _logFile;
    private static object _lockObj;
    private LogStream _testImpactEventsStream;
    private LogStream _testImpactDataEventsStream;
    private bool _disposed;
    private IMessageMemory2 _memory;
    private Dictionary`2<Guid, long> _testOffsets;
    internal IntelliTraceFileBase LogFile { get; }
    internal int MaximumTestCount { get; }
    public TestCoverageManager(int maxTests, string loggerName, IntelliTraceFileBase logFile);
    private static TestCoverageManager();
    public string AllocateCoverageBuffer(_AllocCoverageBufferRequest bufferRequest);
    public void FreeCoverageBuffer(_FreeCoverageBuffer bufferRequest);
    public void NotifyTestStarted(_TestCaseContext context);
    public void NotifyTestEnded(_TestCaseEndContext tcEndContext);
    public void NotifySessionPaused(_SessionContext context);
    public void NotifySessionResumed(_SessionContext context);
    public void NotifySessionEnd(_SessionContext context);
    public void NotifyTestPaused(_TestCaseContext context);
    public void NotifyTestResumed(_TestCaseContext context);
    public void NotifyTestReset(_TestCaseContext context);
    public int GetTestCoverageBufferIndex(Guid testExecutionId);
    public sealed virtual void Dispose();
    public WriteCoverageStreamResult WriteTestImpactDataStream(string path, Guid testExecId);
    internal IntelliTraceFileBase get_LogFile();
    internal int get_MaximumTestCount();
    internal string GetModuleBufferName(long moduleId);
    internal int PackImpactDataFlushEvent(_TestImpactDataFlushEvent evt);
    private void PackTestFlushEvent(Test test);
    private Test FindTest(Guid testId);
    private void CheckDisposed();
    private void PauseTest(Test test);
    private void ResumeTest(Test test);
}
internal static class Microsoft.VisualStudio.IntelliTrace.TestImpact.TestImpactDataUtility : object {
    public static bool IsTestImpactEventsStream(LogStreamEntry entry, TestImpactEventsMessagePacker packer);
    public static bool IsTestImpactDataEventsStream(LogStreamEntry entry, TestImpactDataEventsMessagePacker packer);
    public static _TestFlushEvent ReadTestFlushEvent(Stream stream, TestImpactEventsMessagePacker packer, IMessageMemory2 memory);
    public static _TestImpactDataFlushEvent ReadImpactDataFlushEvent(Stream stream, TestImpactDataEventsMessagePacker packer, IMessageMemory2 memory);
    public static _TestFlushEvent FindTestFlushEvent(Guid testExecId, Stream stream, TestImpactEventsMessagePacker packer, IMessageMemory2 memory);
    public static IEnumerable`1<_TestImpactDataFlushEvent> GetImpactDataFlushEvents(_TestFlushEvent testEvt, Stream stream, TestImpactDataEventsMessagePacker packer, IMessageMemory2 memory);
    public static IEnumerable`1<UInt32> GetEnteredMethodTokens(_TestImpactDataFlushEvent evt);
    public static void UnionBitfield(_TestImpactDataFlushEvent evt, Byte[] bitfield);
    public static bool AreTestIdsEqual(Guid g, int otherInteger);
}
public enum Microsoft.VisualStudio.IntelliTrace.TestImpact.WriteCoverageStreamResult : Enum {
    public int value__;
    public static WriteCoverageStreamResult Succeeded;
    public static WriteCoverageStreamResult TestHasNoData;
    public static WriteCoverageStreamResult LogIsFull;
}
public class Microsoft.VisualStudio.IntelliTrace.TestRunContextEvent : OrdinalEvent {
    private _TfsContext _tfsContext;
    public string TeamFoundationServerProjectName { get; }
    public string TeamFoundationServerUri { get; }
    public int TestRunId { get; }
    internal _TfsContext InnerEvent { get; }
    internal TestRunContextEvent(_TfsContext tfsContext);
    public string get_TeamFoundationServerProjectName();
    public string get_TeamFoundationServerUri();
    public int get_TestRunId();
    internal _TfsContext get_InnerEvent();
}
internal class Microsoft.VisualStudio.IntelliTrace.TestSession : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <StartOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <EndOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<Guid, TestCase> <TestCases>k__BackingField;
    internal Nullable`1<long> StartOrdinal { get; private set; }
    internal Nullable`1<long> EndOrdinal { get; private set; }
    internal Nullable`1<ulong> StartTime { get; private set; }
    internal Nullable`1<ulong> EndTime { get; private set; }
    internal Guid SessionId { get; private set; }
    internal Dictionary`2<Guid, TestCase> TestCases { get; private set; }
    internal void SetStartData(long startOrdinal, ulong startTime, Guid sessionId);
    internal void SetEndData(long endOrdinal, ulong endTime, Guid sessionId);
    internal void SetSessionIdData(Guid sessionId);
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_StartOrdinal();
    [CompilerGeneratedAttribute]
private void set_StartOrdinal(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_EndOrdinal();
    [CompilerGeneratedAttribute]
private void set_EndOrdinal(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_EndTime();
    [CompilerGeneratedAttribute]
private void set_EndTime(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Guid get_SessionId();
    [CompilerGeneratedAttribute]
private void set_SessionId(Guid value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<Guid, TestCase> get_TestCases();
    [CompilerGeneratedAttribute]
private void set_TestCases(Dictionary`2<Guid, TestCase> value);
}
public class Microsoft.VisualStudio.IntelliTrace.TestSessionEndEvent : TestSessionEvent {
    internal TestSessionEndEvent(_SessionContext sessionContext);
}
public abstract class Microsoft.VisualStudio.IntelliTrace.TestSessionEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private Guid <SessionId>k__BackingField;
    private _SessionContext sessionContext;
    public long EventTime { get; }
    public Guid SessionId { get; protected set; }
    internal _SessionContext InnerEvent { get; }
    internal TestSessionEvent(_SessionContext sessionContext);
    public long get_EventTime();
    [CompilerGeneratedAttribute]
public Guid get_SessionId();
    [CompilerGeneratedAttribute]
protected void set_SessionId(Guid value);
    internal _SessionContext get_InnerEvent();
}
public class Microsoft.VisualStudio.IntelliTrace.TestSessionPauseEvent : TestSessionEvent {
    internal TestSessionPauseEvent(_SessionContext sessionContext);
}
public class Microsoft.VisualStudio.IntelliTrace.TestSessionResumeEvent : TestSessionEvent {
    internal TestSessionResumeEvent(_SessionContext sessionContext);
}
public class Microsoft.VisualStudio.IntelliTrace.TestSessionStartEvent : TestSessionEvent {
    internal TestSessionStartEvent(_SessionContext sessionContext);
}
internal class Microsoft.VisualStudio.IntelliTrace.TestStep : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <EndOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StepId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StepDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StepPassed>k__BackingField;
    private TestCase _parentTestCase;
    internal Nullable`1<long> EndOrdinal { get; private set; }
    internal Nullable`1<ulong> EndTime { get; private set; }
    internal int StepId { get; private set; }
    internal string StepDescription { get; private set; }
    internal bool StepPassed { get; private set; }
    internal TestStep(Nullable`1<long> endOrdinal, Nullable`1<ulong> endTime, int stepId, string stepDescription, TestCase parentTestCase, bool stepPassed);
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_EndOrdinal();
    [CompilerGeneratedAttribute]
private void set_EndOrdinal(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_EndTime();
    [CompilerGeneratedAttribute]
private void set_EndTime(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal int get_StepId();
    [CompilerGeneratedAttribute]
private void set_StepId(int value);
    [CompilerGeneratedAttribute]
internal string get_StepDescription();
    [CompilerGeneratedAttribute]
private void set_StepDescription(string value);
    [CompilerGeneratedAttribute]
internal bool get_StepPassed();
    [CompilerGeneratedAttribute]
private void set_StepPassed(bool value);
}
public class Microsoft.VisualStudio.IntelliTrace.TestStepEndEvent : TestStepEvent {
    [CompilerGeneratedAttribute]
private int <TestStepOutcome>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TestStepPassed>k__BackingField;
    public int TestStepOutcome { get; private set; }
    public bool TestStepPassed { get; private set; }
    internal TestStepEndEvent(_TestStepContext testStepContext);
    [CompilerGeneratedAttribute]
public int get_TestStepOutcome();
    [CompilerGeneratedAttribute]
private void set_TestStepOutcome(int value);
    [CompilerGeneratedAttribute]
public bool get_TestStepPassed();
    [CompilerGeneratedAttribute]
private void set_TestStepPassed(bool value);
}
public abstract class Microsoft.VisualStudio.IntelliTrace.TestStepEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private Guid <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TestExecutionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TestCaseId>k__BackingField;
    private _TestStepContext testStepContext;
    public long EventTime { get; }
    public Guid SessionId { get; protected set; }
    public Guid TestExecutionId { get; protected set; }
    public Guid TestCaseId { get; protected set; }
    public int TestCaseManagerId { get; }
    public string TestCaseName { get; }
    public bool IsChildTestCase { get; }
    public int TestStepId { get; }
    public string TestStepDescription { get; }
    internal _TestStepContext InnerEvent { get; }
    internal TestStepEvent(_TestStepContext testStepContext);
    public long get_EventTime();
    [CompilerGeneratedAttribute]
public Guid get_SessionId();
    [CompilerGeneratedAttribute]
protected void set_SessionId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_TestExecutionId();
    [CompilerGeneratedAttribute]
protected void set_TestExecutionId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_TestCaseId();
    [CompilerGeneratedAttribute]
protected void set_TestCaseId(Guid value);
    public int get_TestCaseManagerId();
    public string get_TestCaseName();
    public bool get_IsChildTestCase();
    public int get_TestStepId();
    public string get_TestStepDescription();
    internal _TestStepContext get_InnerEvent();
}
public class Microsoft.VisualStudio.IntelliTrace.TestStepStartEvent : TestStepEvent {
    internal TestStepStartEvent(_TestStepContext testStepContext);
}
public class Microsoft.VisualStudio.IntelliTrace.TestStreamChain : StreamChain {
    internal IMessageMemory2 memory;
    private TestEventsMessagePacker packer;
    internal TestStreamChain(LogStream stream, TestEventsMessagePacker packer);
    protected virtual Byte[] ReadEventBytes();
    protected virtual int ReadEventLength();
    protected virtual IntelliTraceEvent ConvertToEvent(EventToken token, Byte[] data, Int32& offset);
    protected virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
}
internal class Microsoft.VisualStudio.IntelliTrace.TestTracker : object {
    private EventToken _token;
    private TestChain _testChain;
    private Dictionary`2<Guid, TestSession> _testSessions;
    internal TestTracker(TestChain testChain);
    private void OnEventVisited(object sender, IntelliTraceEvent evt);
    private void Sync();
    internal IEnum`1<TestSession> GetTestInformation();
    private void AddTestCaseStartToSession(TestSession sess, TestCaseStartEvent caseStartEvent);
    private void AddTestCaseEndToSession(TestSession sess, TestCaseEndEvent caseEndEvent);
    private void AddTestStepToSession(TestSession sess, TestStepEndEvent stepEndEvent);
}
internal class Microsoft.VisualStudio.IntelliTrace.TextPosition : ValueType {
    private UInt32 _dwColumn;
    private UInt32 _dwLine;
    public UInt32 dwColumn { get; }
    public UInt32 dwLine { get; }
    public UInt32 dwColumn_1 { get; }
    public UInt32 dwLine_1 { get; }
    private TextPosition(UInt32 line, UInt32 col);
    public UInt32 get_dwColumn();
    public UInt32 get_dwLine();
    public UInt32 get_dwColumn_1();
    public UInt32 get_dwLine_1();
    public static TextPosition CreatePositionFromOneBased(int line, int col);
    public static TextPosition CreatePositionFromZeroBased(int line, int col);
    public bool IsBefore(TextPosition pos);
    public bool IsOnOrBefore(TextPosition pos);
    public TextSpan PickBetterMatch(TextSpan spanA, TextSpan spanB);
    public TextSpan PickBetterMatch(TextSpan spanA, TextSpan spanB, bool lineMatch);
}
internal class Microsoft.VisualStudio.IntelliTrace.TextSpan : ValueType {
    public TextPosition begin;
    public TextPosition end;
    public long TextMetric { get; }
    public bool Surrounds(TextPosition pos);
    public long get_TextMetric();
    public long Distance(TextPosition pos);
}
internal class Microsoft.VisualStudio.IntelliTrace.TfsContextTracker : object {
    private TestRunContextEvent _tfsContext;
    internal TestRunContextEvent TfsContext { get; }
    internal TfsContextTracker(TestChain testChain);
    internal TestRunContextEvent get_TfsContext();
}
public class Microsoft.VisualStudio.IntelliTrace.ThreadChain : PartitionedListChain {
    public int IntelliTraceThreadId { get; }
    internal ThreadChain(ThreadStreamChain streamChain, ThreadCheckpointChain checkpointChain);
    internal ThreadChain(ThreadStreamChain streamChain, ThreadCheckpointChain checkpointChain, PartitionCache partitionCache);
    public int get_IntelliTraceThreadId();
}
public class Microsoft.VisualStudio.IntelliTrace.ThreadCheckpointChain : ListChain {
    internal ThreadCheckpointChain(ThreadCheckpointStreamChain sourceChain);
}
public class Microsoft.VisualStudio.IntelliTrace.ThreadCheckpointEvent : PartitioningEvent {
    [CompilerGeneratedAttribute]
private int <NativeThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StreamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StackFramesInCommon>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IntelliTraceStackFrame> <FramesWithCommonRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ExceptionInFlight> <Exceptions>k__BackingField;
    private IList`1<IntelliTraceStackFrame> stack;
    public int IntelliTraceThreadId { get; }
    internal int NativeThreadId { get; private set; }
    internal int StreamIndex { get; private set; }
    public int StackFramesInCommon { get; private set; }
    internal IList`1<IntelliTraceStackFrame> FramesWithCommonRoot { get; private set; }
    public long EventTime { get; private set; }
    internal IList`1<ExceptionInFlight> Exceptions { get; private set; }
    public IList`1<IntelliTraceStackFrame> StackFrames { get; }
    internal ThreadCheckpointEvent(long globalOrdinal, long streamOrdinal, long streamOffset, int streamIndex);
    internal ThreadCheckpointEvent(long globalOrdinal, long streamOrdinal, long streamOffset, long firstVisibleStreamOrdinal, int streamIndex);
    internal ThreadCheckpointEvent(FullCheckpointData* pCheckpointData);
    public int get_IntelliTraceThreadId();
    [CompilerGeneratedAttribute]
internal int get_NativeThreadId();
    [CompilerGeneratedAttribute]
private void set_NativeThreadId(int value);
    [CompilerGeneratedAttribute]
internal int get_StreamIndex();
    [CompilerGeneratedAttribute]
private void set_StreamIndex(int value);
    [CompilerGeneratedAttribute]
public int get_StackFramesInCommon();
    [CompilerGeneratedAttribute]
private void set_StackFramesInCommon(int value);
    [CompilerGeneratedAttribute]
internal IList`1<IntelliTraceStackFrame> get_FramesWithCommonRoot();
    [CompilerGeneratedAttribute]
private void set_FramesWithCommonRoot(IList`1<IntelliTraceStackFrame> value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_EventTime();
    [CompilerGeneratedAttribute]
private void set_EventTime(long value);
    [CompilerGeneratedAttribute]
internal IList`1<ExceptionInFlight> get_Exceptions();
    [CompilerGeneratedAttribute]
private void set_Exceptions(IList`1<ExceptionInFlight> value);
    internal _FullCheckpointData AsPackable();
    public IList`1<IntelliTraceStackFrame> get_StackFrames();
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ThreadCheckpointStreamChain : StreamChain {
    internal MessagePackerMessageMemory memory;
    internal MessageMemoryByteArray managedMemory;
    private ThreadCheckpointEventsMessagePacker packer;
    internal ThreadCheckpointStreamChain(LogStream stream, ThreadCheckpointEventsMessagePacker packer);
    protected virtual Byte[] ReadEventBytes();
    protected virtual int ReadEventLength();
    protected virtual IntelliTraceEvent ConvertToEvent(EventToken token, Byte[] data, Int32& offset);
    protected virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
}
public class Microsoft.VisualStudio.IntelliTrace.ThreadCreateEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private long <ManagedThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NativeThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IntelliTraceThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PriorityName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSource <Source>k__BackingField;
    internal _StreamList streams;
    public long ManagedThreadId { get; private set; }
    public int NativeThreadId { get; private set; }
    public int IntelliTraceThreadId { get; private set; }
    public long EventTime { get; private set; }
    public string PriorityName { get; private set; }
    public string Name { get; private set; }
    public int Category { get; private set; }
    public long Id { get; private set; }
    internal EventSource Source { get; private set; }
    internal _StreamList Streams { get; }
    internal ThreadCreateEvent(ThreadCreated* pData);
    [CompilerGeneratedAttribute]
public long get_ManagedThreadId();
    [CompilerGeneratedAttribute]
private void set_ManagedThreadId(long value);
    [CompilerGeneratedAttribute]
public int get_NativeThreadId();
    [CompilerGeneratedAttribute]
private void set_NativeThreadId(int value);
    [CompilerGeneratedAttribute]
public int get_IntelliTraceThreadId();
    [CompilerGeneratedAttribute]
private void set_IntelliTraceThreadId(int value);
    [CompilerGeneratedAttribute]
public long get_EventTime();
    [CompilerGeneratedAttribute]
private void set_EventTime(long value);
    [CompilerGeneratedAttribute]
public string get_PriorityName();
    [CompilerGeneratedAttribute]
private void set_PriorityName(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(int value);
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(long value);
    [CompilerGeneratedAttribute]
internal EventSource get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(EventSource value);
    internal _StreamList get_Streams();
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.ThreadData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PriorityName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NativeThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ManagedThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LoggerThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Running>k__BackingField;
    public string Name { get; public set; }
    public string PriorityName { get; public set; }
    public int NativeThreadId { get; public set; }
    public long ManagedThreadId { get; public set; }
    public int LoggerThreadId { get; public set; }
    public int Category { get; public set; }
    public ulong StartTime { get; public set; }
    public ulong EndTime { get; public set; }
    internal long StartOrdinal { get; internal set; }
    internal long EndOrdinal { get; internal set; }
    internal bool Running { get; internal set; }
    internal ThreadData(ThreadCreateEvent threadEvent);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_PriorityName();
    [CompilerGeneratedAttribute]
public void set_PriorityName(string value);
    [CompilerGeneratedAttribute]
public int get_NativeThreadId();
    [CompilerGeneratedAttribute]
public void set_NativeThreadId(int value);
    [CompilerGeneratedAttribute]
public long get_ManagedThreadId();
    [CompilerGeneratedAttribute]
public void set_ManagedThreadId(long value);
    [CompilerGeneratedAttribute]
public int get_LoggerThreadId();
    [CompilerGeneratedAttribute]
public void set_LoggerThreadId(int value);
    [CompilerGeneratedAttribute]
public int get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(int value);
    [CompilerGeneratedAttribute]
public ulong get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_EndTime();
    [CompilerGeneratedAttribute]
public void set_EndTime(ulong value);
    [CompilerGeneratedAttribute]
internal long get_StartOrdinal();
    [CompilerGeneratedAttribute]
internal void set_StartOrdinal(long value);
    [CompilerGeneratedAttribute]
internal long get_EndOrdinal();
    [CompilerGeneratedAttribute]
internal void set_EndOrdinal(long value);
    [CompilerGeneratedAttribute]
internal bool get_Running();
    [CompilerGeneratedAttribute]
internal void set_Running(bool value);
}
internal class Microsoft.VisualStudio.IntelliTrace.ThreadDestroyedState : TreeState {
    internal ThreadDestroyedState(Tree tree);
}
public class Microsoft.VisualStudio.IntelliTrace.ThreadDestroyEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private int <IntelliTraceThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ManagedThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NativeThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSource <Source>k__BackingField;
    public int IntelliTraceThreadId { get; private set; }
    public long ManagedThreadId { get; private set; }
    public int NativeThreadId { get; private set; }
    public long EventTime { get; private set; }
    public long Id { get; private set; }
    internal EventSource Source { get; private set; }
    internal ThreadDestroyEvent(ThreadDestroyed* pData);
    [CompilerGeneratedAttribute]
public int get_IntelliTraceThreadId();
    [CompilerGeneratedAttribute]
private void set_IntelliTraceThreadId(int value);
    [CompilerGeneratedAttribute]
public long get_ManagedThreadId();
    [CompilerGeneratedAttribute]
private void set_ManagedThreadId(long value);
    [CompilerGeneratedAttribute]
public int get_NativeThreadId();
    [CompilerGeneratedAttribute]
private void set_NativeThreadId(int value);
    [CompilerGeneratedAttribute]
public long get_EventTime();
    [CompilerGeneratedAttribute]
private void set_EventTime(long value);
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(long value);
    [CompilerGeneratedAttribute]
internal EventSource get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(EventSource value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ThreadNameChangedEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private int <IntelliTraceThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ManagedThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NativeThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ThreadName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSource <Source>k__BackingField;
    public int IntelliTraceThreadId { get; private set; }
    public long ManagedThreadId { get; private set; }
    public int NativeThreadId { get; private set; }
    public string ThreadName { get; private set; }
    public int Category { get; private set; }
    public long Id { get; private set; }
    internal EventSource Source { get; private set; }
    internal ThreadNameChangedEvent(ThreadNameChanged* pData);
    [CompilerGeneratedAttribute]
public int get_IntelliTraceThreadId();
    [CompilerGeneratedAttribute]
private void set_IntelliTraceThreadId(int value);
    [CompilerGeneratedAttribute]
public long get_ManagedThreadId();
    [CompilerGeneratedAttribute]
private void set_ManagedThreadId(long value);
    [CompilerGeneratedAttribute]
public int get_NativeThreadId();
    [CompilerGeneratedAttribute]
private void set_NativeThreadId(int value);
    [CompilerGeneratedAttribute]
public string get_ThreadName();
    [CompilerGeneratedAttribute]
private void set_ThreadName(string value);
    [CompilerGeneratedAttribute]
public int get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(int value);
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(long value);
    [CompilerGeneratedAttribute]
internal EventSource get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(EventSource value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
public class Microsoft.VisualStudio.IntelliTrace.ThreadStack : object {
    [CompilerGeneratedAttribute]
private int <NativeThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IntelliTraceStackFrame> <StackFrames>k__BackingField;
    public int NativeThreadId { get; private set; }
    public IList`1<IntelliTraceStackFrame> StackFrames { get; private set; }
    internal ThreadStack(ThreadStackState* pThreadStack);
    [CompilerGeneratedAttribute]
public int get_NativeThreadId();
    [CompilerGeneratedAttribute]
private void set_NativeThreadId(int value);
    [CompilerGeneratedAttribute]
public IList`1<IntelliTraceStackFrame> get_StackFrames();
    [CompilerGeneratedAttribute]
private void set_StackFrames(IList`1<IntelliTraceStackFrame> value);
    internal _ThreadStackState AsPackable();
}
public class Microsoft.VisualStudio.IntelliTrace.ThreadStreamChain : StreamChain {
    internal MessageMemoryByteArray memory;
    private TraceDebugEventsMessagePacker packer;
    public int IntelliTraceThreadId { get; }
    internal ThreadStreamChain(LogStream stream, TraceDebugEventsMessagePacker packer);
    protected virtual Byte[] ReadEventBytes();
    protected virtual int ReadEventLength();
    protected virtual IntelliTraceEvent ConvertToEvent(EventToken token, Byte[] data, Int32& offset);
    protected virtual Byte[] ConvertToBytes(IntelliTraceEvent chainEvent);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
    public int get_IntelliTraceThreadId();
}
internal class Microsoft.VisualStudio.IntelliTrace.ThreadTracker : EventTracker {
    private Dictionary`2<int, int> _nativeTidToLoggerTid;
    private Dictionary`2<int, ThreadData> _loggerTidToThreadData;
    private Dictionary`2<long, string> _threadNameChanges;
    internal virtual void HandleEvent(ThreadCreateEvent threadCreate, EventHandle handle);
    internal virtual void HandleEvent(ThreadDestroyEvent threadDestroy, EventHandle handle);
    internal virtual void HandleEvent(ThreadNameChangedEvent threadNameChanged, EventHandle handle);
    internal virtual void HandleEvent(ProcessDestroyedEvent processDestroy, EventHandle handle);
    internal virtual void HandleEvent(DataRequestedEvent dataRequested, EventHandle handle);
    internal ThreadData LookupThreadByNativeThreadId(int nativeThreadId, long ordinal);
    internal bool DoesThreadExist(int loggerTid);
    internal ThreadData LookupThread(int loggerTid);
    internal List`1<ThreadData> GetThreads(EventToken beginTime, EventToken endTime);
    internal IEnumerable`1<int> LoggerThreadIds();
}
internal class Microsoft.VisualStudio.IntelliTrace.ThrowNode : ExceptionNode {
    public NodeType Type { get; }
    public int NotifyId { get; }
    internal ThrowNode(long ordinal, CodeContext location);
    public virtual NodeType get_Type();
    public virtual int get_NotifyId();
}
internal class Microsoft.VisualStudio.IntelliTrace.TimeSlice : object {
    private TraceLogReader _reader;
    private EventToken _beginTime;
    private EventToken _endTime;
    internal TimeSlice(TraceLogReader reader, EventToken beginTime, EventToken endTime);
    internal Chain GetEventChain();
    internal IBidiEnum`1<NPEventData> GetNotifyPoints();
    internal IEnum`1<EventHandle> GetExceptions();
    internal IEnum`1<TestSession> GetTestData();
    internal TestRunContextEvent GetTfsContext();
    internal ThreadData LookupThread(int loggerTid);
    internal IEnum`1<ThreadData> GetThreads();
    internal ThreadData LookupThreadByNativeThreadId(int nativeThreadId, long ordinal);
    internal IEnum`1<ModuleData> GetModules();
    internal UserCodeEnum GetModuleUserCodeStatus(Guid mvid);
    internal IEnum`1<EventHandle> GetStack(EventHandle eh, int tid, bool fIncludeLeaf);
    internal EventHandle GetLastEvent(int tid);
}
internal class Microsoft.VisualStudio.IntelliTrace.TimingDataCodec : object {
    [CompilerGeneratedAttribute]
private ulong <PerformanceFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <InitialPerformanceCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LogStart>k__BackingField;
    public ulong PerformanceFrequency { get; private set; }
    public ulong InitialPerformanceCounter { get; private set; }
    public DateTime LogStart { get; private set; }
    public TimingDataCodec(DateTime logStart, ulong qpcInitialPerformanceCounter, ulong qpcPerformanceFrequency);
    [CompilerGeneratedAttribute]
public ulong get_PerformanceFrequency();
    [CompilerGeneratedAttribute]
private void set_PerformanceFrequency(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_InitialPerformanceCounter();
    [CompilerGeneratedAttribute]
private void set_InitialPerformanceCounter(ulong value);
    [CompilerGeneratedAttribute]
public DateTime get_LogStart();
    [CompilerGeneratedAttribute]
private void set_LogStart(DateTime value);
    public ulong EncodeStartTime(DateTime startTime);
    public ulong EncodeEndTime(DateTime endTime);
    public ulong EncodeTotalTime(TimeSpan totalTime);
    public DateTime DecodeEventTime(ulong encodedTime);
    public TimeSpan DecodeTimeSpan(ulong encodedDuration);
}
internal class Microsoft.VisualStudio.IntelliTrace.TimingDataDeserializer : object {
    private TimingDataCodec _timingDataCodec;
    public TimingDataDeserializer(DateTime logStartTime, ulong qpcStartTime, ulong qpcFrequency);
    public Nullable`1<DateTime> UnpackStartTime(BlobUnpacker unpacker);
    public ExitTimingData UnpackEndData(BlobUnpacker unpacker);
    private Nullable`1<DateTime> UnpackTime(BlobUnpacker unpacker);
}
internal class Microsoft.VisualStudio.IntelliTrace.TraceLog : object {
    private bool _fLiveDebugging;
    private string _logFileName;
    private TraceLogReader _reader;
    private TimeSlice _currSlice;
    private TraceLogSandbox _sandbox;
    private Nullable`1<bool> _hasAzureData;
    private Nullable`1<bool> _hasMSTestData;
    private Dictionary`2<int, WeakReference> _cachedMetadataEvents;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool IsInstrEnabled { get; }
    public bool IsTraceInstrumentationEnabled { get; }
    public bool IsThisAvailable { get; }
    public bool AreInParamsAvailable { get; }
    public bool AreOutParamsAvailable { get; }
    public bool AreRetValuesAvailable { get; }
    public bool ArePropsAvailable { get; }
    public bool AreCallSitesAvailable { get; }
    public bool AreRuntimeTypesAvailable { get; }
    public bool AreNonPrimitiveTypesAvailable { get; }
    public bool AreParameterBlobsCompatible { get; }
    public Dictionary`2<int, HeuristicNotifyPointSpecification> NotifyPointIdentityTable { get; }
    public Dictionary`2<string, string> Categories { get; }
    public bool SupportsNestedValuesSection { get; }
    public bool SupportsDurationDataSection { get; }
    public string LogFileName { get; }
    public DateTime FileCreateTime { get; }
    public DateTime LocalFileCreateTime { get; }
    public DateTime FileLastModifiedTime { get; }
    public DateTime LocalFileLastModifiedTime { get; }
    public TraceLogReader TraceLogReader { get; }
    public TraceLogSandbox Sandbox { get; }
    public bool HasSharePointData { get; }
    public bool HasSharePointFoundationData { get; }
    public bool HasOfficeServerData { get; }
    public bool HasAzureData { get; }
    public bool HasMSTestData { get; }
    private TraceLog(IntelliTraceFileBase logFile, bool fLiveDebugging);
    internal static TraceLog Create(IntelliTraceFileBase logFile, bool fLiveDebugging);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
    public int GetThreadOfStream(int streamId);
    public IEnum`1<ThreadData> GetThreads();
    public ThreadData LookupThreadByNativeThreadId(int nativeThreadId, long ordinal);
    public bool IsThreadAlive(int loggerThreadId);
    public IEnum`1<ModuleData> GetModules();
    internal UserCodeEnum GetModuleUserCodeStatus(Guid mvid);
    public IBidiEnum`1<NPEventData> GetNotifyPoints();
    public IBidiEnum`1<UlsNPData> GetUlsNotifyPoints();
    public IEnum`1<EventHandle> GetExceptions();
    internal IEnumerable`1<EventHandleToEC> GetExceptionRelatedEvents(DiagnosticChain chain);
    internal EmbeddedSymbolInfo GetModuleMetadata(ModuleData mdata);
    public TestSession[] GetTestSessions(EventHandle evt);
    public TestRunContextEvent GetTfsContext();
    public T GetEventByHandle(EventHandle evt);
    public IEnum`1<EventHandle> GetStack(EventHandle eh, int loggerTid, bool fIncludeLeaf);
    public IEnum`1<EventHandle> GetStack(EventHandle eh, int loggerTid);
    public DiagnosticEvent GetDiagnosticEventWithFullStack(EventHandleToEC ecHandle);
    internal bool IsLiveDebugging();
    public bool IsThreadRecorded(int loggerTid);
    public bool IsThreadCheckpointed(int loggerTid);
    public EventHandle GetLastEvent(int loggerTid);
    public EventHandle GetClosestEvent(int loggerTid, long ordinal);
    public EventHandle GetClosestEvent(int loggerTid, long ordinal, int matchingDepth);
    public EventHandle GetClosestEvent(long ordinal);
    public EventHandle GetThreadRootCall(int loggerTid);
    public LogData GetData(EventHandle evt);
    public sealed virtual void TranslateToken(int protToken, Int32& mdToken, Guid& mvid);
    public sealed virtual bool TryFindProteusToken(Guid guidModule, int mdToken, Int32& protToken);
    public void GetTypeSpec(Guid mvid, int mdToken, Byte[]& sigBlob);
    public NotifyType GetNotifyType(int notifyId);
    public MethodType GetMethodType(MethodContext context, ModuleSymbols syms);
    public bool Contains(EventHandle e);
    public void Sync();
    public bool get_IsInstrEnabled();
    public bool get_IsTraceInstrumentationEnabled();
    public bool get_IsThisAvailable();
    public bool get_AreInParamsAvailable();
    public bool get_AreOutParamsAvailable();
    public bool get_AreRetValuesAvailable();
    public bool get_ArePropsAvailable();
    public bool get_AreCallSitesAvailable();
    public bool get_AreRuntimeTypesAvailable();
    public bool get_AreNonPrimitiveTypesAvailable();
    public bool get_AreParameterBlobsCompatible();
    public _CollectionPlan GetCollectionPlan();
    public Dictionary`2<int, HeuristicNotifyPointSpecification> get_NotifyPointIdentityTable();
    public Dictionary`2<string, string> get_Categories();
    public bool get_SupportsNestedValuesSection();
    public bool get_SupportsDurationDataSection();
    public string get_LogFileName();
    public DateTime get_FileCreateTime();
    public DateTime get_LocalFileCreateTime();
    public DateTime get_FileLastModifiedTime();
    public DateTime get_LocalFileLastModifiedTime();
    public TraceLogReader get_TraceLogReader();
    public TraceLogSandbox get_Sandbox();
    public DateTime GetDateTimeFromEventTime(ulong eventTime);
    public static DateTime GetDateTimeFromEventTime(ulong eventTime, DateTime baseTime, ulong qpcInit, ulong qpcFrequency);
    public static DateTime GetDateTimeFromEventTime(ulong eventTime, LogSystemInfo sysInfo);
    public IDictionary`2<string, object> GetPropertyBag();
    public bool get_HasSharePointData();
    public bool get_HasSharePointFoundationData();
    public bool get_HasOfficeServerData();
    public bool get_HasAzureData();
    public bool get_HasMSTestData();
    private bool HasProperty(string key);
    public LogSystemInfo GetLogSystemInfo();
    public sealed virtual int LoggerThreadIdFromNativeThreadId(int nativeThreadId, long ordinal);
    private void CheckForAzureData();
    private void CheckForMSTestData();
    private bool SearchForModules(List`1<string> moduleNames);
    internal bool SupportsExtendedDataSection(SectionId sectionId);
    internal int GetExtendedDataSectionIndex(SectionId sectionId);
}
internal class Microsoft.VisualStudio.IntelliTrace.TraceLogBufferHandler : object {
    private BufferedIpcDispatcher dispatcher;
    private BufferedIpc bufferedIpc;
    private IMessageMemory2 memory;
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnInitialize(BufferedIpcDispatcher dispatcher);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnStartup();
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnBufferReceived(BufferToken& token);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnBufferWritten(BufferToken token);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnIdle();
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnShuttingDown();
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnShutdown();
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnSuspend(IList`1<BufferToken> heldTokens);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnResume();
    private sealed virtual override bool Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnThreadMessage(ThreadMail message);
    private sealed virtual override void Microsoft.VisualStudio.Diagnostics.Logging.IBufferHandler.OnFlush();
}
internal class Microsoft.VisualStudio.IntelliTrace.TraceLogConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <IsInstrEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsThisAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreInParamsAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreOutParamsAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreRetValuesAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ArePropsAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreNonPrimitiveTypesAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreCallSitesAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreRuntimeTypesAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreParameterBlobsCompatible>k__BackingField;
    [CompilerGeneratedAttribute]
private _CollectionPlan <CollectionPlan>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, HeuristicNotifyPointSpecification> <NotifyPointIdentityTable>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Categories>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtendedVersionInfo <ExtendedVersionInfo>k__BackingField;
    public bool IsInstrEnabled { get; public set; }
    public bool IsThisAvailable { get; public set; }
    public bool AreInParamsAvailable { get; public set; }
    public bool AreOutParamsAvailable { get; public set; }
    public bool AreRetValuesAvailable { get; public set; }
    public bool ArePropsAvailable { get; public set; }
    public bool AreNonPrimitiveTypesAvailable { get; public set; }
    public bool AreCallSitesAvailable { get; public set; }
    public bool AreRuntimeTypesAvailable { get; public set; }
    public bool AreParameterBlobsCompatible { get; public set; }
    public _CollectionPlan CollectionPlan { get; public set; }
    public Dictionary`2<int, HeuristicNotifyPointSpecification> NotifyPointIdentityTable { get; public set; }
    public Dictionary`2<string, string> Categories { get; public set; }
    public ExtendedVersionInfo ExtendedVersionInfo { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsInstrEnabled();
    [CompilerGeneratedAttribute]
public void set_IsInstrEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsThisAvailable();
    [CompilerGeneratedAttribute]
public void set_IsThisAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_AreInParamsAvailable();
    [CompilerGeneratedAttribute]
public void set_AreInParamsAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_AreOutParamsAvailable();
    [CompilerGeneratedAttribute]
public void set_AreOutParamsAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_AreRetValuesAvailable();
    [CompilerGeneratedAttribute]
public void set_AreRetValuesAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_ArePropsAvailable();
    [CompilerGeneratedAttribute]
public void set_ArePropsAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_AreNonPrimitiveTypesAvailable();
    [CompilerGeneratedAttribute]
public void set_AreNonPrimitiveTypesAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_AreCallSitesAvailable();
    [CompilerGeneratedAttribute]
public void set_AreCallSitesAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_AreRuntimeTypesAvailable();
    [CompilerGeneratedAttribute]
public void set_AreRuntimeTypesAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_AreParameterBlobsCompatible();
    [CompilerGeneratedAttribute]
public void set_AreParameterBlobsCompatible(bool value);
    [CompilerGeneratedAttribute]
public _CollectionPlan get_CollectionPlan();
    [CompilerGeneratedAttribute]
public void set_CollectionPlan(_CollectionPlan value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, HeuristicNotifyPointSpecification> get_NotifyPointIdentityTable();
    [CompilerGeneratedAttribute]
public void set_NotifyPointIdentityTable(Dictionary`2<int, HeuristicNotifyPointSpecification> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Categories();
    [CompilerGeneratedAttribute]
public void set_Categories(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public ExtendedVersionInfo get_ExtendedVersionInfo();
    [CompilerGeneratedAttribute]
public void set_ExtendedVersionInfo(ExtendedVersionInfo value);
}
internal class Microsoft.VisualStudio.IntelliTrace.TraceLogger : LoggerEngine {
    private static string _loggerHistoryPrefix;
    private static string _loggerHistoryWildcard;
    private static string installDir;
    private string _profilerKeyName;
    private NamedCounter _eventCounter;
    private RemoteTraceDebugLogFile remoteTraceDebugLogFile;
    private TraceLogBufferHandler traceLogBufferHandler;
    private bool _outputRemoteMessages;
    private NamedCounter _counters;
    private TraceLoggerStartInfo _traceLoggerStartInfo;
    private static string VSFolderPattern;
    private static string IntelliTraceRelativePath;
    internal NamedCounter Counters { get; }
    private static string LoggerHistoryPrefix { get; }
    private static string LoggerHistoryWildcard { get; }
    public bool OutputRemoteMessages { get; public set; }
    public LoggerStartInfo StartInfo { get; }
    internal RemoteTraceDebugLogFile RemoteTraceDebugLogFile { get; }
    internal static string InstallDir { get; }
    public TraceLogger(IOutputter outputter);
    internal virtual NamedCounter get_Counters();
    private static string get_LoggerHistoryPrefix();
    private static string get_LoggerHistoryWildcard();
    public bool get_OutputRemoteMessages();
    public void set_OutputRemoteMessages(bool value);
    protected virtual bool OnRunStarting();
    protected virtual void OnRunStopping();
    protected virtual IList`1<IBufferHandler> CreateBufferHandlers();
    protected virtual IntelliTraceFile CreateLogFile();
    protected virtual IList`1<LogWorkerThread> CreateWorkerThreads();
    protected virtual void Dispose(bool disposing);
    protected virtual LoggingConfig CreateLoggingConfig();
    public virtual bool Suspend();
    public virtual bool Resume();
    public void OnDiskFull(object sender, EventArgs args);
    public void OnTrimLog(object sender, TrimLogEventArgs args);
    public bool StartProcess(int timeout, string pathToLogger);
    public bool StartThread(int timeout);
    public bool Launch(string pathToLogger);
    public bool Status();
    public bool RequestLogCopy(string logFilePath);
    public string RequestStatistics();
    public bool RequestCoverageData(string logFilePath, Guid testExecId, Boolean& logWasFull);
    public bool Checkpoint(Byte* pData, int msgLen);
    public virtual LoggerStartInfo get_StartInfo();
    public static IList`1<KeyValuePair`2<string, string>> GetProfilerEnvVars();
    internal RemoteTraceDebugLogFile get_RemoteTraceDebugLogFile();
    private static IEnumerable`1<string> GetLoggerHistoryFiles();
    private static void RegisterInfo(_LoggerInfo info);
    private static void UnregisterInfo(string loggerName);
    internal void Register(_ProcessInfo processInfo);
    private void Unregister();
    internal static IEnumerable`1<_LoggerInfo> GetRegisteredLoggers();
    internal static IEnumerable`1<string> CleanRegisteredLoggers();
    internal void IncrementInstrumentationDisabled();
    private void CheckIsProfilerRegistered(Process targetProcess);
    private string ProfilerFileLocation();
    internal static string get_InstallDir();
    [CompilerGeneratedAttribute]
private bool <StartThread>b__33_0();
    [CompilerGeneratedAttribute]
private void <StartThread>b__33_1();
}
internal class Microsoft.VisualStudio.IntelliTrace.TraceLoggerStartInfo : LoggerStartInfo {
    private string _collectionPlanPath;
    private String[] _launchArgs;
    private string _launchExe;
    private _CollectionPlan _collectionPlan;
    private bool _loadCollectionPlanDone;
    private static string s_collectionPlanXmlFilename;
    [CompilerGeneratedAttribute]
private SupportedInstrumentationMethods <SupportedInstrumentationMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FindFreeLogFileName>k__BackingField;
    public SupportedInstrumentationMethods SupportedInstrumentationMethods { get; public set; }
    public string CollectionPlanPath { get; public set; }
    public string LaunchExecutable { get; public set; }
    public String[] LaunchArguments { get; public set; }
    public string LogFilePath { get; public set; }
    public _CollectionPlan CollectionPlan { get; public set; }
    public bool ContinueOnDiskFullException { get; public set; }
    [ObsoleteAttribute]
public bool DeleteLogOnExit { get; public set; }
    public bool DeleteLogOnClose { get; public set; }
    internal bool FindFreeLogFileName { get; private set; }
    public TraceLoggerStartInfo(OutputHelper outputHelper);
    private static TraceLoggerStartInfo();
    [CompilerGeneratedAttribute]
public SupportedInstrumentationMethods get_SupportedInstrumentationMethods();
    [CompilerGeneratedAttribute]
public void set_SupportedInstrumentationMethods(SupportedInstrumentationMethods value);
    public string get_CollectionPlanPath();
    public void set_CollectionPlanPath(string value);
    public string get_LaunchExecutable();
    public void set_LaunchExecutable(string value);
    public String[] get_LaunchArguments();
    public void set_LaunchArguments(String[] value);
    public virtual string get_LogFilePath();
    public virtual void set_LogFilePath(string value);
    public _CollectionPlan get_CollectionPlan();
    public void set_CollectionPlan(_CollectionPlan value);
    public virtual bool get_ContinueOnDiskFullException();
    public virtual void set_ContinueOnDiskFullException(bool value);
    public virtual bool get_DeleteLogOnExit();
    public virtual void set_DeleteLogOnExit(bool value);
    public bool get_DeleteLogOnClose();
    public void set_DeleteLogOnClose(bool value);
    [CompilerGeneratedAttribute]
internal bool get_FindFreeLogFileName();
    [CompilerGeneratedAttribute]
private void set_FindFreeLogFileName(bool value);
    private void LoadCollectionPlan();
    private void DisableUnsupportedInstrumentationMethods(_CollectionPlan plan, bool doNotAssert);
}
public class Microsoft.VisualStudio.IntelliTrace.TraceLoggingService : object {
    private TraceLogger serviceLogger;
    private ExpectedProcessCollection expectedProcesses;
    private TraceLoggingSessionCollection traceLoggingSessions;
    private GetPropertyDelegate getPropertyDelegate;
    private string ServiceName;
    [CompilerGeneratedAttribute]
private EventHandler`1<ActivityEventArgs> Activity;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExceptionEventArgs> ExceptionEvent;
    private static int maximumPropertyLength;
    public ExpectedProcessCollection ExpectedProcesses { get; }
    public TraceLoggingSessionCollection TraceLoggingSessions { get; }
    internal TraceLogger ServiceLogger { get; }
    private bool IsStarted { get; }
    public TraceLoggingService(GetPropertyDelegate getPropertyDelegate);
    public IAsyncResult BeginStart(AsyncCallback userCallback, object stateObject);
    public void EndStart(IAsyncResult asyncResult);
    public void Start();
    public IAsyncResult BeginStop(AsyncCallback userCallback, object stateObject);
    public void EndStop(IAsyncResult asyncResult);
    public void Stop();
    public ExpectedProcessCollection get_ExpectedProcesses();
    public TraceLoggingSessionCollection get_TraceLoggingSessions();
    [CompilerGeneratedAttribute]
public void add_Activity(EventHandler`1<ActivityEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Activity(EventHandler`1<ActivityEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ExceptionEvent(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExceptionEvent(EventHandler`1<ExceptionEventArgs> value);
    internal void FireActivityEvent(object sender, ActivityEventCode code);
    internal string InvokeGetProperty(TraceLoggingSession session, string propertyName);
    internal void FireMonitoringExceptionEvent(object sender, ExceptionEventArgs exceptionEventArgs);
    internal TraceLogger get_ServiceLogger();
    private bool get_IsStarted();
    private void AssertServiceStarted();
    private void AssertServiceStopped();
    private void EndAsyncOperation(IAsyncResult asyncResult);
    public sealed virtual void Dispose();
}
public class Microsoft.VisualStudio.IntelliTrace.TraceLoggingSession : object {
    [CompilerGeneratedAttribute]
private ProcessTraits <ProcessTraits>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionPlanXml>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpectedProcessTraits <ExpectedProcessTraits>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceLogger <TraceLogger>k__BackingField;
    public ProcessTraits ProcessTraits { get; internal set; }
    public string CollectionPlanXml { get; internal set; }
    public ExpectedProcessTraits ExpectedProcessTraits { get; internal set; }
    internal TraceLogger TraceLogger { get; internal set; }
    internal TraceLoggingSession(ProcessTraits processTraits, string collectionPlanXml, ExpectedProcessTraits expectedProcessTraits, TraceLogger traceLogger);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public ProcessTraits get_ProcessTraits();
    [CompilerGeneratedAttribute]
internal void set_ProcessTraits(ProcessTraits value);
    [CompilerGeneratedAttribute]
public string get_CollectionPlanXml();
    [CompilerGeneratedAttribute]
internal void set_CollectionPlanXml(string value);
    [CompilerGeneratedAttribute]
public ExpectedProcessTraits get_ExpectedProcessTraits();
    [CompilerGeneratedAttribute]
internal void set_ExpectedProcessTraits(ExpectedProcessTraits value);
    [CompilerGeneratedAttribute]
internal TraceLogger get_TraceLogger();
    [CompilerGeneratedAttribute]
internal void set_TraceLogger(TraceLogger value);
    public sealed virtual void Dispose();
    public IAsyncResult BeginCopyLogFile(string logFileDirectory, AsyncCallback userCallback, object stateObject);
    public void EndCopyLogFile(IAsyncResult asyncResult);
    public void CopyLogFile(string logFileDirectory);
    internal void Terminate();
    internal void Dispose(bool disposing);
}
public class Microsoft.VisualStudio.IntelliTrace.TraceLoggingSessionCollection : object {
    private List`1<TraceLoggingSession> list;
    private ReaderWriterLockSlim rwLock;
    public int Count { get; }
    public int get_Count();
    public TraceLoggingSession Find(Predicate`1<TraceLoggingSession> predicate);
    public TraceLoggingSession[] Copy();
    internal void InternalAdd(TraceLoggingSession item);
    internal void InternalRemove(TraceLoggingSession item);
}
internal class Microsoft.VisualStudio.IntelliTrace.TraceLogGlobalState : object {
    private static object _sGlobalLock;
    private static Dictionary`2<string, CachedState> _sGlobalStates;
    private CachedState _cache;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    private bool IsDisposed { get; private set; }
    public DiagnosticEventRedirectManager RedirectManager { get; }
    private TraceLogGlobalState(CachedState cache);
    private static TraceLogGlobalState();
    [CompilerGeneratedAttribute]
private bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public DiagnosticEventRedirectManager get_RedirectManager();
    protected virtual override void Finalize();
    public static TraceLogGlobalState Connect(string path);
    private static void Disconnect(string path);
    private void Disconnect();
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
    private void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.IntelliTrace.TraceLogInfo : object {
    private TraceLog _log;
    public string LogFileName { get; }
    public IDictionary`2<string, object> PropertyBag { get; }
    public bool IsDebugLaunch { get; }
    public TraceLogInfo(TraceLog log);
    public sealed virtual string get_LogFileName();
    public sealed virtual IDictionary`2<string, object> get_PropertyBag();
    public sealed virtual bool get_IsDebugLaunch();
}
internal class Microsoft.VisualStudio.IntelliTrace.TraceLogReader : object {
    private static int MaxTreeSliceCacheSize;
    internal static string SharePointMappingKey;
    internal static string OfficeServerMappingKey;
    private IntelliTraceFileBase _logFile;
    private ChainManager _chainManager;
    private Dictionary`2<int, TreeSliceManager> _treeMgrs;
    private LinkedList`1<TreeSlice> _sliceCache;
    private TraceLogConfiguration _config;
    private LogSystemInfo _systemInfo;
    private bool _fLiveDebugging;
    private object _diagCheckpointStreamChainLock;
    private bool _disposed;
    private ChainWeaverWalker _procEventWalker;
    private ThreadTracker _threadTracker;
    private ModuleTracker _moduleTracker;
    private ConfigurationTracker _configTracker;
    private SummaryTracker _summaryTracker;
    private NotifyPointTracker _npTracker;
    private ExceptionTracker _exceptionTracker;
    private AnalysisTracker _analysisTracker;
    private WebTracker _webTracker;
    private SharePointTracker _sharePointTracker;
    private Dictionary`2<int, MetadataStream> _metadataStreamChains;
    private Dictionary`2<Guid, MetadataEventToken> _mdMvidToToken;
    private EventToken _lastReadToken;
    private List`1<DiagnosticCheckpointEvent> _diagnosticCheckpointEventsCache;
    private Dictionary`2<EventToken, DiagnosticEvent> _diagnosticEventsCache;
    private static int _maxCacheCount;
    private IDictionary`2<string, object> _propertyBag;
    private Nullable`1<bool> _isPerformanceMode;
    private Nullable`1<bool> _isSinglePerformanceMode;
    internal bool IsLiveDebugging { get; }
    internal bool HasBuildInfo { get; }
    internal IntelliTraceFileBase LogFile { get; }
    internal ChainManager ChainManager { get; }
    internal ModuleTracker ModuleTracker { get; }
    internal ConfigurationTracker ConfigTracker { get; }
    internal ThreadTracker ThreadTracker { get; }
    internal SharePointTracker SharePointTracker { get; }
    private WebTracker WebTracker { get; }
    private NotifyPointTracker NotifyPointTracker { get; }
    public AnalysisTracker AnalysisTracker { get; }
    private List`1<DiagnosticCheckpointEvent> DiagnosticCheckpointEventsCache { get; }
    private Dictionary`2<EventToken, DiagnosticEvent> DiagnosticEventsCache { get; }
    internal TraceLogReader(IntelliTraceFileBase logFile, bool fLiveDebugging);
    internal bool Refresh();
    public bool IsPerformanceMode();
    public bool IsSinglePerformanceMode();
    internal TraceLogConfiguration GetConfigInfo();
    internal LogSystemInfo GetSystemInfo();
    internal TimeSlice GetSlice(EventToken beginToken, EventToken endToken);
    internal TimeSlice[] GetSlices();
    internal bool get_IsLiveDebugging();
    internal bool get_HasBuildInfo();
    internal IntelliTraceFileBase get_LogFile();
    internal EventHandle GetLastEvent(int loggerTid);
    internal EventHandle FindClosestNode(int loggerTid, long ordinal);
    internal EventHandle FindClosestCallSiteNode(int loggerTid, long ordinal);
    internal IEnum`1<EventHandle> GetStack(EventHandle eh, int loggerTid, bool fIncludeLeaf);
    internal void TranslateToken(int proteusToken, Int32& mdToken, Guid& mvid);
    internal ChainManager get_ChainManager();
    internal ModuleTracker get_ModuleTracker();
    internal ConfigurationTracker get_ConfigTracker();
    internal ThreadTracker get_ThreadTracker();
    internal SharePointTracker get_SharePointTracker();
    private WebTracker get_WebTracker();
    private NotifyPointTracker get_NotifyPointTracker();
    public AnalysisTracker get_AnalysisTracker();
    private List`1<DiagnosticCheckpointEvent> get_DiagnosticCheckpointEventsCache();
    private Dictionary`2<EventToken, DiagnosticEvent> get_DiagnosticEventsCache();
    internal IEnum`1<ThreadData> GetThreads(EventToken beginTime, EventToken endTime);
    internal ThreadData LookupThread(int loggerThreadId);
    internal ThreadData LookupThreadByNativeThreadId(int nativeThreadId, long ordinal);
    internal IEnum`1<ModuleData> GetModules(EventToken beginTime, EventToken endTime);
    internal UserCodeEnum GetModuleUserCodeStatus(Guid mvid);
    internal void CacheTreeSlice(TreeSlice slice);
    internal EventHandle GetThreadRootCall(int loggerTid);
    internal TreeSliceManager GetTreeManager(int loggerTid);
    internal MetadataEvent GetMetadataEvent(ModuleData mdata);
    internal IEnumerable`1<BuildInformationEvent> GetBuildInformation();
    internal TestRunContextEvent GetTfsContext(EventToken beginTime, EventToken endTime);
    internal IBidiEnum`1<NPEventData> GetDiagnosticEventsForRequest(int requestId, long threadStreamOffset, Boolean& eventsTruncated);
    internal IList`1<CallTreeNode> GetCallTreeForRequest(int requestId, long threadStreamOffset, WebRequestCallTreeTraverser ctTraverser);
    internal IEnumerable`1<BinopNode> GetWebEventFilterBinopNodes(int requestId, long threadStreamOffset, Boolean& eventsTruncated);
    internal IEnum`1<TestSession> GetTestData(EventToken beginTime, EventToken endTime);
    private bool HasTestData();
    internal IBidiEnum`1<NPEventData> GetNotifyPoints(EventToken beginTime, EventToken endTime);
    internal IBidiEnum`1<UlsNPData> GetUlsNotifyPoints();
    internal IEnum`1<EventHandle> GetExceptions(EventToken beginTime, EventToken endTime);
    internal bool HasExceptions();
    internal IEnumerable`1<EventHandleToEC> GetExceptionRelatedEvents(DiagnosticChain chain);
    private void TrimDiagnosticEvents();
    internal DiagnosticEvent GetDiagnosticEventWithFullStack(EventHandleToEC ecHandle);
    internal DiagnosticCheckpointEvent GetNearestDiagnosticCheckpointEvent(Predicate`1<DiagnosticCheckpointEvent> pastPredicate, DiagnosticCheckpointStreamChain checkpointChain);
    internal DiagnosticCheckpointEvent GetNearestDiagnosticCheckpointEvent(EventHandleToEC ecHandle, DiagnosticCheckpointStreamChain& checkpointChain);
    internal IDictionary`2<string, object> GetPropertyBag();
    internal bool SupportsExtendedDataSection(SectionId sectionId);
    internal int GetExtendedDataSectionIndex(SectionId sectionId);
    private SectionInfo GetReaderExtendedSectionInfo(SectionId sectionId);
    private SectionInfo GetFileExtendedSectionInfo(SectionId sectionId);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
private void <.ctor>b__33_0(object sender, NewStreamEventArgs e);
}
internal class Microsoft.VisualStudio.IntelliTrace.TraceLogResources : object {
    internal static ResourceManager ResourceManager;
    public static string Fmt_IndependentEventsDescription { get; }
    public static string Fmt_IndependentEventsRawDescription { get; }
    public static string Fmt_ProcessEventsDescription { get; }
    public static string Fmt_TraceDebugEventDescription { get; }
    public static string Status_Header { get; }
    public static string Fmt_TestCoverageEventsDescription { get; }
    public static string ERR_DiskFull { get; }
    public static string ERR_DiskFullFatal { get; }
    public static string WRN_ProfilerNotFound { get; }
    public static string WRN_ProfilerNotFound32 { get; }
    public static string WRN_ProfilerNotFound64 { get; }
    public static string ERR_CollectionPlanMissingPath { get; }
    public static string SysInfo_AvailablePageSize { get; }
    public static string SysInfo_AvailablePhysicalBytes { get; }
    public static string SysInfo_AvailableVirtual { get; }
    public static string SysInfo_CLRVersion { get; }
    public static string SysInfo_ComputerName { get; }
    public static string SysInfo_Displays { get; }
    public static string SysInfo_NumberOfProcessors { get; }
    public static string SysInfo_OSVersionNumber { get; }
    public static string SysInfo_ProcessorArchitecture { get; }
    public static string SysInfo_WOW64 { get; }
    public static string SysInfo_ProcessorLevel { get; }
    public static string SysInfo_ProcessorRevision { get; }
    public static string SysInfo_ServicePack { get; }
    public static string SysInfo_SystemDir { get; }
    public static string SysInfo_TotalPageFile { get; }
    public static string SysInfo_TotalPhysicalBytes { get; }
    public static string SysInfo_TotalVirtual { get; }
    public static string SysInfo_UserDomain { get; }
    public static string SysInfo_UserName { get; }
    public static string SysInfo_WinDir { get; }
    public static string SysInfo_BiosDate { get; }
    public static string SysInfo_BiosVersion { get; }
    public static string SysInfo_BitsPerPixel { get; }
    public static string SysInfo_DisplayHeight { get; }
    public static string SysInfo_DisplayWidth { get; }
    public static string SysInfo_OS { get; }
    public static string SysInfo_OSServer2003 { get; }
    public static string SysInfo_OSSku { get; }
    public static string SysInfo_OSVista { get; }
    public static string SysInfo_OSWin2k8 { get; }
    public static string SysInfo_OSWin2K { get; }
    public static string SysInfo_OSXP { get; }
    public static string SysInfo_OSWindows7 { get; }
    public static string SysInfo_OSWin2k8R2 { get; }
    public static string SysInfo_OSWindows8 { get; }
    public static string SysInfo_OSWin2k12 { get; }
    public static string SysInfo_OSWindows81 { get; }
    public static string SysInfo_OSWin2k12R2 { get; }
    public static string SysInfo_ProcessorArchItanium { get; }
    public static string SysInfo_ProcessorArchUnknown { get; }
    public static string SysInfo_ProcessorArchx64 { get; }
    public static string SysInfo_ProcessorArchx86 { get; }
    public static string SysInfo_WOW64Yes { get; }
    public static string SysInfo_WOW64No { get; }
    public static string SysInfo_ProcessorSpeed { get; }
    public static string SysInfo_SystemLCID { get; }
    public static string SysInfo_SystemManufacturer { get; }
    public static string SysInfo_SystemProductName { get; }
    public static string SysInfo_Timezone { get; }
    public static string SysInfo_TimezoneBias { get; }
    public static string Category_DebuggerEvent { get; }
    public static string Category_ExceptionEvent { get; }
    public static string UnknownType { get; }
    public static string UnknownMethod { get; }
    public static string Description_AsyncBreak { get; }
    public static string Description_BreakPoint { get; }
    public static string Description_EntryPoint { get; }
    public static string Name_AsyncBreak { get; }
    public static string Name_BadExceptionTypeProvided { get; }
    public static string Name_BadStopTypeProvided { get; }
    public static string Description_ExceptionIntercepted { get; }
    public static string Description_StopException { get; }
    public static string Description_StepComplete { get; }
    public static string Debug_ErrorMessage { get; }
    public static string Retail_PDQShortDescriptionErrorUnknownCategory { get; }
    public static string Retail_PDQLongDescriptionError { get; }
    public static string Name_ExceptionMessage { get; }
    public static string Name_ExceptionType { get; }
    public static string Name_ExceptionWinRT { get; }
    public static string Description_LoggingSuspended { get; }
    public static string Description_ThreadAborted { get; }
    public static string EventLog_SourceName { get; }
    public static string ShortDesc_AsyncBreak { get; }
    public static string ShortDesc_BreakPoint { get; }
    public static string ShortDesc_EntryPoint { get; }
    public static string ShortDesc_ExceptionCaught { get; }
    public static string ShortDesc_ExceptionIntercepted { get; }
    public static string ShortDesc_ExceptionThrown { get; }
    public static string ShortDesc_LoadComplete { get; }
    public static string ShortDesc_LoggingSuspended { get; }
    public static string ShortDesc_StepComplete { get; }
    public static string ShortDesc_StopException { get; }
    public static string ShortDesc_ThreadAborted { get; }
    public static string Description_ThreadSwitch { get; }
    public static string Name_ThreadSwitch { get; }
    public static string ShortDesc_ThreadSwitch { get; }
    public static string DataUncollected { get; }
    public static string OutParamSuffix { get; }
    public static string DataRemoted { get; }
    public static string DataReferenceCycle { get; }
    public static string Exception_BadDiagnosticHandle { get; }
    public static string Exception_ReadingWhileLive { get; }
    public static string Exception_MissedToken { get; }
    public static string Exception_ItemAlreadyExists { get; }
    public static string Exception_MetadataCyclicDependency { get; }
    public static string Exception_MsCorlibSimpleTypes { get; }
    public static string Exception_GenericType { get; }
    public static string Exception_TypedReference { get; }
    public static string Exception_UnknownTokenType { get; }
    public static string Exception_InvalidStartTime { get; }
    public static string Exception_InvalidPerformanceFrequency { get; }
    public static string Exception_InvalidPerformanceCounter { get; }
    public static string Exception_MissingProcessInformation { get; }
    public static string Exception_MissingThreadInformation { get; }
    public static string Exception_InvalidOSVersionMajor { get; }
    public static string Exception_InvalidOSVersionMinor { get; }
    public static string Exception_InvalidOSVersionProductType { get; }
    public static string Exception_InvalidOSVersionBuildNumber { get; }
    public static string Exception_InvalidOSVersionSKU { get; }
    public static string Exception_InvalidMemoryStatisticsTotalPhysicalBytes { get; }
    public static string Exception_InvalidMemoryStatisticsAvailablePhysicalBytes { get; }
    public static string Exception_InvalidMemoryStatisticsTotalCommittedBytes { get; }
    public static string Exception_InvalidMemoryStatisticsAvailableCommitBytes { get; }
    public static string Exception_InvalidMemoryStatisticsTotalVirtualBytes { get; }
    public static string Exception_InvalidMemoryStatisticsAvailableVirtualBytes { get; }
    public static string Exception_InvalidProcessorInfoArchitecture { get; }
    public static string Exception_InvalidProcessorInfoNumberOfProcessors { get; }
    public static string Exception_InvalidProcessorInfoProcessorLevel { get; }
    public static string Exception_InvalidProcessorInfoProcessorRevision { get; }
    public static string Exception_InvalidProcessorInfoProcessorSpeed { get; }
    public static string Exception_InvalidTimeZoneInfoTimeZoneBias { get; }
    public static string Exception_InvalidSystemLCID { get; }
    public static string Exception_InvalidDisplaySettingsWidth { get; }
    public static string Exception_InvalidDisplaySettingsHeight { get; }
    public static string Exception_InvalidDisplaySettingsBitsPerPixel { get; }
    public static string Exception_InvalidDisplaySetting { get; }
    public static string Exception_InvalidFileSize { get; }
    public static string Exception_MixedPerfEvents { get; }
    public static string DiagnosticEventAndCallStackInDifferentThreads { get; }
    public static string SysInfo_ProcessorArchArm64 { get; }
    private static TraceLogResources();
    public static string get_Fmt_IndependentEventsDescription();
    public static string get_Fmt_IndependentEventsRawDescription();
    public static string get_Fmt_ProcessEventsDescription();
    public static string get_Fmt_TraceDebugEventDescription();
    public static string Status_Deleting(object param0);
    public static string get_Status_Header();
    public static string Status_Logger(object param0, object param1, object param2, object param3);
    public static string Status_Process(object param0, object param1, object param2, object param3);
    public static string get_Fmt_TestCoverageEventsDescription();
    public static string ERR_CollectionPlanInvalid(object param0);
    public static string ERR_CollectionPlanInvalidInfo(object param0, object param1);
    public static string get_ERR_DiskFull();
    public static string get_ERR_DiskFullFatal();
    public static string get_WRN_ProfilerNotFound();
    public static string get_WRN_ProfilerNotFound32();
    public static string get_WRN_ProfilerNotFound64();
    public static string ERR_UserNameInvalid(object param0);
    public static string get_ERR_CollectionPlanMissingPath();
    public static string ERR_CollectionPlanMissing(object param0);
    public static string get_SysInfo_AvailablePageSize();
    public static string get_SysInfo_AvailablePhysicalBytes();
    public static string get_SysInfo_AvailableVirtual();
    public static string get_SysInfo_CLRVersion();
    public static string get_SysInfo_ComputerName();
    public static string get_SysInfo_Displays();
    public static string get_SysInfo_NumberOfProcessors();
    public static string get_SysInfo_OSVersionNumber();
    public static string get_SysInfo_ProcessorArchitecture();
    public static string get_SysInfo_WOW64();
    public static string get_SysInfo_ProcessorLevel();
    public static string get_SysInfo_ProcessorRevision();
    public static string get_SysInfo_ServicePack();
    public static string get_SysInfo_SystemDir();
    public static string get_SysInfo_TotalPageFile();
    public static string get_SysInfo_TotalPhysicalBytes();
    public static string get_SysInfo_TotalVirtual();
    public static string get_SysInfo_UserDomain();
    public static string get_SysInfo_UserName();
    public static string get_SysInfo_WinDir();
    public static string get_SysInfo_BiosDate();
    public static string get_SysInfo_BiosVersion();
    public static string get_SysInfo_BitsPerPixel();
    public static string get_SysInfo_DisplayHeight();
    public static string get_SysInfo_DisplayWidth();
    public static string get_SysInfo_OS();
    public static string get_SysInfo_OSServer2003();
    public static string get_SysInfo_OSSku();
    public static string SysInfo_OSUnknown(object param0, object param1);
    public static string get_SysInfo_OSVista();
    public static string get_SysInfo_OSWin2k8();
    public static string get_SysInfo_OSWin2K();
    public static string get_SysInfo_OSXP();
    public static string get_SysInfo_OSWindows7();
    public static string get_SysInfo_OSWin2k8R2();
    public static string get_SysInfo_OSWindows8();
    public static string get_SysInfo_OSWin2k12();
    public static string get_SysInfo_OSWindows81();
    public static string get_SysInfo_OSWin2k12R2();
    public static string get_SysInfo_ProcessorArchItanium();
    public static string get_SysInfo_ProcessorArchUnknown();
    public static string get_SysInfo_ProcessorArchx64();
    public static string get_SysInfo_ProcessorArchx86();
    public static string get_SysInfo_WOW64Yes();
    public static string get_SysInfo_WOW64No();
    public static string get_SysInfo_ProcessorSpeed();
    public static string get_SysInfo_SystemLCID();
    public static string get_SysInfo_SystemManufacturer();
    public static string get_SysInfo_SystemProductName();
    public static string get_SysInfo_Timezone();
    public static string get_SysInfo_TimezoneBias();
    public static string get_Category_DebuggerEvent();
    public static string get_Category_ExceptionEvent();
    public static string get_UnknownType();
    public static string get_UnknownMethod();
    public static string get_Description_AsyncBreak();
    public static string get_Description_BreakPoint();
    public static string get_Description_EntryPoint();
    public static string Description_ExceptionCaught(object param0, object param1, object param2, object param3);
    public static string Description_ExceptionThrown(object param0, object param1, object param2, object param3);
    public static string get_Name_AsyncBreak();
    public static string get_Name_BadExceptionTypeProvided();
    public static string get_Name_BadStopTypeProvided();
    public static string Name_BreakPoint(object param0);
    public static string Name_EntryPoint(object param0);
    public static string Name_ExceptionCaught(object param0, object param1, object param2, object param3);
    public static string Name_ExceptionIntercepted(object param0);
    public static string Name_ExceptionThrown(object param0, object param1, object param2, object param3);
    public static string Name_LoadComplete(object param0);
    public static string Name_StepComplete(object param0);
    public static string Name_StopException(object param0);
    public static string Name_ThreadAborted(object param0);
    public static string Name_Unused(object param0);
    public static string get_Description_ExceptionIntercepted();
    public static string get_Description_StopException();
    public static string get_Description_StepComplete();
    public static string get_Debug_ErrorMessage();
    public static string get_Retail_PDQShortDescriptionErrorUnknownCategory();
    public static string get_Retail_PDQLongDescriptionError();
    public static string Retail_PDQShortDescriptionErrorWithCategoryName(object param0);
    public static string get_Name_ExceptionMessage();
    public static string get_Name_ExceptionType();
    public static string get_Name_ExceptionWinRT();
    public static string get_Description_LoggingSuspended();
    public static string get_Description_ThreadAborted();
    public static string Description_Unused(object param0);
    public static string Name_LoggingSuspended(object param0);
    public static string get_EventLog_SourceName();
    public static string get_ShortDesc_AsyncBreak();
    public static string get_ShortDesc_BreakPoint();
    public static string get_ShortDesc_EntryPoint();
    public static string get_ShortDesc_ExceptionCaught();
    public static string get_ShortDesc_ExceptionIntercepted();
    public static string get_ShortDesc_ExceptionThrown();
    public static string get_ShortDesc_LoadComplete();
    public static string get_ShortDesc_LoggingSuspended();
    public static string get_ShortDesc_StepComplete();
    public static string get_ShortDesc_StopException();
    public static string get_ShortDesc_ThreadAborted();
    public static string get_Description_ThreadSwitch();
    public static string get_Name_ThreadSwitch();
    public static string get_ShortDesc_ThreadSwitch();
    public static string ShortDesc_Unused(object param0);
    public static string get_DataUncollected();
    public static string get_OutParamSuffix();
    public static string DebuggerEventMessage(object param0, object param1, object param2);
    public static string get_DataRemoted();
    public static string get_DataReferenceCycle();
    public static string Exception_InvalidData(object param0);
    public static string get_Exception_BadDiagnosticHandle();
    public static string get_Exception_ReadingWhileLive();
    public static string get_Exception_MissedToken();
    public static string Description_LoadComplete(object param0);
    public static string Name_BadNotifyPointIdProvided(object param0);
    public static string get_Exception_ItemAlreadyExists();
    public static string Exception_FileAlreadyExists(object param0);
    public static string get_Exception_MetadataCyclicDependency();
    public static string get_Exception_MsCorlibSimpleTypes();
    public static string get_Exception_GenericType();
    public static string get_Exception_TypedReference();
    public static string get_Exception_UnknownTokenType();
    public static string get_Exception_InvalidStartTime();
    public static string get_Exception_InvalidPerformanceFrequency();
    public static string get_Exception_InvalidPerformanceCounter();
    public static string get_Exception_MissingProcessInformation();
    public static string get_Exception_MissingThreadInformation();
    public static string get_Exception_InvalidOSVersionMajor();
    public static string get_Exception_InvalidOSVersionMinor();
    public static string get_Exception_InvalidOSVersionProductType();
    public static string get_Exception_InvalidOSVersionBuildNumber();
    public static string get_Exception_InvalidOSVersionSKU();
    public static string get_Exception_InvalidMemoryStatisticsTotalPhysicalBytes();
    public static string get_Exception_InvalidMemoryStatisticsAvailablePhysicalBytes();
    public static string get_Exception_InvalidMemoryStatisticsTotalCommittedBytes();
    public static string get_Exception_InvalidMemoryStatisticsAvailableCommitBytes();
    public static string get_Exception_InvalidMemoryStatisticsTotalVirtualBytes();
    public static string get_Exception_InvalidMemoryStatisticsAvailableVirtualBytes();
    public static string get_Exception_InvalidProcessorInfoArchitecture();
    public static string get_Exception_InvalidProcessorInfoNumberOfProcessors();
    public static string get_Exception_InvalidProcessorInfoProcessorLevel();
    public static string get_Exception_InvalidProcessorInfoProcessorRevision();
    public static string get_Exception_InvalidProcessorInfoProcessorSpeed();
    public static string get_Exception_InvalidTimeZoneInfoTimeZoneBias();
    public static string get_Exception_InvalidSystemLCID();
    public static string get_Exception_InvalidDisplaySettingsWidth();
    public static string get_Exception_InvalidDisplaySettingsHeight();
    public static string get_Exception_InvalidDisplaySettingsBitsPerPixel();
    public static string get_Exception_InvalidDisplaySetting();
    public static string Concord_RestrictedErrorPrefix(object param0, object param1);
    public static string Exception_InvalidBlockSize(object param0);
    public static string get_Exception_InvalidFileSize();
    public static string get_Exception_MixedPerfEvents();
    public static string get_DiagnosticEventAndCallStackInDifferentThreads();
    public static string get_SysInfo_ProcessorArchArm64();
}
internal class Microsoft.VisualStudio.IntelliTrace.TraceLogSandbox : object {
    private object _lock;
    private Dictionary`2<QualifiedProgrammableDataQuerySpec, ObjectHandle> _sandboxHandleCache;
    private Dictionary`2<QualifiedProgrammableDataQuerySpec, ObjectHandle> _defaultHandleCache;
    public static string DefaultPDQAssemblyName;
    private static string ResultReaderType;
    private static string _pdqAssembly;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceLogInfo <Log>k__BackingField;
    private AppDomain _sandboxDomain;
    private ProgrammableDataQueryResultReader _sandboxReader;
    private ProgrammableDataQueryResultReader _defaultReader;
    public static string DefaultPDQLocation { get; }
    public static string DefaultPDQAssembly { get; }
    private bool IsDisposed { get; private set; }
    private ITraceLogInfo Log { get; private set; }
    private string AppDomainKey { get; }
    public AppDomain SandboxDomain { get; }
    private ProgrammableDataQueryResultReader SandboxReader { get; }
    private ProgrammableDataQueryResultReader DefaultReader { get; }
    public TraceLogSandbox(ITraceLogInfo log);
    public static string get_DefaultPDQLocation();
    public static string get_DefaultPDQAssembly();
    [CompilerGeneratedAttribute]
private bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
private ITraceLogInfo get_Log();
    [CompilerGeneratedAttribute]
private void set_Log(ITraceLogInfo value);
    private string get_AppDomainKey();
    public AppDomain get_SandboxDomain();
    private ProgrammableDataQueryResultReader get_SandboxReader();
    private ProgrammableDataQueryResultReader get_DefaultReader();
    public sealed virtual void Dispose();
    private void Dispose(bool isDisposing);
    private void ThrowIfDisposed();
    private T Format(ProgrammableDataQuerySpec spec, string pdqDirectory, Func`3<ProgrammableDataQueryResultReader, ObjectHandle, T> formatter);
    public string FormatName(ProgrammableDataQuerySpec spec, string pdqDirectory, Object[] results, IProgrammableDataQueryEventData data);
    public string FormatPreview(ProgrammableDataQuerySpec spec, string pdqDirectory, Object[] results, IProgrammableDataQueryEventData data);
    public string FormatLongDescription(ProgrammableDataQuerySpec spec, string pdqDirectory, Object[] results, IProgrammableDataQueryEventData data);
    public string FormatShortDescription(ProgrammableDataQuerySpec spec, string pdqDirectory, Object[] results, IProgrammableDataQueryEventData data, string categoryName);
    public List`1<CollectedValueTuple> FormatCollectedValues(ProgrammableDataQuerySpec spec, string pdqDirectory, Object[] results, IProgrammableDataQueryEventData data);
    public List`1<Location> GetAlternateLocations(ProgrammableDataQuerySpec spec, string pdqDirectory, Object[] results);
    protected virtual bool ShouldRunInDefaultDomain(QualifiedProgrammableDataQuerySpec spec);
    protected virtual bool IsDefaultPublicKey(Byte[] publicKeyBytes);
    protected virtual bool IsDefaultAssemblyLocation(QualifiedProgrammableDataQuerySpec spec);
    protected virtual bool IsDefaultAssemblyName(string assemblyName);
    private StrongName GetStrongName(Assembly assembly);
    private void InitializeReaderProperties(ProgrammableDataQueryResultReader reader);
    private QualifiedProgrammableDataQuerySpec Qualify(ProgrammableDataQuerySpec pdq, string directory);
    private ObjectHandle GetHandleForPDQ(QualifiedProgrammableDataQuerySpec spec, ProgrammableDataQueryResultReader& reader);
}
internal enum Microsoft.VisualStudio.IntelliTrace.TraceStreamType : Enum {
    public int value__;
    public static TraceStreamType StreamZero;
    public static TraceStreamType Unknown;
    public static TraceStreamType ProcessEvents;
    public static TraceStreamType Diagnostic;
    public static TraceStreamType DiagnosticCheckpoints;
    public static TraceStreamType TestEvents;
    public static TraceStreamType ExceptionIndex;
    public static TraceStreamType WebRequests;
    public static TraceStreamType WebSessionTracking;
    public static TraceStreamType WebRequestTracking;
    public static TraceStreamType WebThreadTracking;
    public static TraceStreamType WebSummaryTracking;
    public static TraceStreamType BuildInformation;
}
internal static class Microsoft.VisualStudio.IntelliTrace.TraceStreamUtils : object {
    public static Guid GetSchemaId(TraceStreamType stream);
    public static TraceStreamType GetStreamType(Guid schemaId);
}
internal class Microsoft.VisualStudio.IntelliTrace.Tree : object {
    private TreeTracker _tracker;
    private EventData`1<RootNode> _root;
    private EventData`1<CallsiteNode> _cursor;
    private ModuleTracker _modTracker;
    private ConfigurationTracker _configTracker;
    private bool _fMergedInitialCheckpoint;
    private CallsiteNode _cursorAtLastCheckpoint;
    private DiagnosticEvent _lastNotifyPointEvent;
    internal EventData`1<RootNode> Root { get; }
    internal EventData`1<CallsiteNode> Cursor { get; }
    internal DiagnosticEvent LastNotifyPoint { get; }
    internal bool HasLiveFrames { get; }
    internal Tree(TreeTracker tracker, ModuleTracker modTracker, ConfigurationTracker configTracker, long rootOrdinal, long cpOrdinal);
    internal Tree(Tree original, long rootOrdinal);
    internal EventData`1<RootNode> get_Root();
    internal EventData`1<CallsiteNode> get_Cursor();
    internal DiagnosticEvent get_LastNotifyPoint();
    private CallsiteNode GetCursorForNextEvent();
    private void AdjustCursorForNextEvent();
    private void AddLeafNode(Node node, EventHandle nodeHandle);
    private void AddNode(CallsiteNode node, EventHandle nodeHandle);
    private void AddNode(MethodEnterNode node, EventHandle nodeHandle);
    private void AddNode(MethodExitNode node, EventHandle nodeHandle);
    internal void AddEnter(MethodEnterEvent me);
    internal void AddFakeEnter(long ordinal, IntelliTraceStackFrame frame);
    internal void AddFakeEnter(long ordinal, MethodContext mc);
    internal void AddFuncletEnter(ExceptionSearchFilterEnterEvent exceptionSearchFilterEnter);
    internal void AddCallsite(CallSiteEvent evt);
    internal void AddFakeCallsite(long ordinal);
    internal void AddFakeCallsite(long ordinal, IntelliTraceStackFrame frame, bool fBracket, long cpOrdinal);
    internal void AddExit(MethodExitEvent me);
    internal void AddFakeExit(long ordinal);
    internal void AddExceptionExit(ExceptionUnwindFunctionExitEvent exceptionUnwindFunctionExit);
    internal void AddFuncletExit(ExceptionSearchFilterExitEvent exceptionSearchFilterExit);
    internal void AddNotify(OrdinalEvent snapshotEvent, EventHandle handle, IntelliTraceStackFrame leafFrame);
    internal void AddThreadExit(DiagnosticEvent npEvent);
    private CodeContext GetCodeContext(IntelliTraceStackFrame frame);
    internal EventHandle AddThrow(OrdinalEvent throwEvent, IntelliTraceStackFrame throwFrame);
    internal EventHandle AddCatch(OrdinalEvent catchEvent, IntelliTraceStackFrame catchFrame);
    internal EventHandle AddCatch(ExceptionCatchEnterEvent catchEvent);
    internal void Merge(Tree tempTree, OrdinalEvent snapshotEvent, IList`1<IntelliTraceStackFrame> snapshotFrames, int commonFrameCount);
    internal void Merge(Tree tempTree, OrdinalEvent snapshotEvent, IList`1<IntelliTraceStackFrame> snapshotFrames, int commonFrameCount, bool fPopFirst);
    private static LinkedList`1<LiveFrame> GetLiveFrames(Tree tree);
    internal void Merge(Tree tempTree);
    internal void GetFirstRealEnterNode(bool fRequireExit, MethodEnterNode& enterNode, FakeCallsiteNode& enterNodeParent);
    private void UpgradeFakeFrameAtCursor(FakeCallsiteNode realEnterParent);
    private void PopToLocation(MethodContext location, Tree tempTree);
    internal void PopToDepth(int depth, Tree tempTree);
    internal void PopToMatchingNode(CallsiteNode node, Tree tempTree);
    internal void PopToMatchingEnter(MethodExitEvent exit, Tree tempTree);
    internal void PopToMatchingEnter(TailCallSiteEvent tailCall, Tree tempTree);
    internal void PopToMatchingEnter(CallSiteEvent callsite, Tree tempTree);
    internal void PopWhileFakeFrames(Tree tempTree);
    internal void MoveCursorToParent();
    internal bool get_HasLiveFrames();
    internal int GetCommonFrameCount(int framesInCommon, IntelliTraceStackFrame[] rightFrames);
    internal void MapOrdinal(long oldOrdinal, long newOrdinal);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.TreeNodeExtensions : object {
    [ExtensionAttribute]
public static long GetTimeContextOrdinal(ITreeNode node, long minOrdinalValue);
}
internal class Microsoft.VisualStudio.IntelliTrace.TreeSlice : object {
    private TreeSliceManager _mgr;
    private int _sliceId;
    private SlicedEventChain _slicedThreadChain;
    private SlicedEventChain _slicedNPChain;
    private SlicedEventChain _slicedCPChain;
    private ThreadCheckpointEvent _startingCheckpoint;
    private bool _startingCheckpointUpdated;
    private long _startOrdinal;
    private long _endOrdinal;
    private int _commonFrameCount;
    private List`1<Node> _nodeList;
    private ChainWeaver _weaver;
    private ChainWeaverWalker _walker;
    private TreeTracker _tracker;
    private bool _fLoaded;
    private bool _fDirty;
    private bool _fNeutered;
    [CompilerGeneratedAttribute]
private bool <ForceCheckpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedListNode`1<TreeSlice> <CacheEntry>k__BackingField;
    internal int Id { get; }
    internal int ThreadId { get; }
    internal bool ForceCheckpoint { get; internal set; }
    internal bool IsCheckpointed { get; }
    internal long StartOrdinal { get; }
    internal long EndOrdinal { get; }
    internal int CommonFrameCount { get; }
    internal ThreadCheckpointEvent StartingCheckpoint { get; internal set; }
    internal LinkedListNode`1<TreeSlice> CacheEntry { get; internal set; }
    internal ModuleTracker ModuleTracker { get; }
    internal ConfigurationTracker ConfigTracker { get; }
    internal TreeSlice(TreeSliceManager mgr, int sliceId, ThreadCheckpointEvent checkpoint, int commonFrameCount, SlicedEventChain slicedThreadChain, SlicedEventChain slicedNPChain, SlicedEventChain slicedCPChain, bool isFirstSlice);
    internal int get_Id();
    internal int get_ThreadId();
    [CompilerGeneratedAttribute]
internal bool get_ForceCheckpoint();
    [CompilerGeneratedAttribute]
internal void set_ForceCheckpoint(bool value);
    internal bool get_IsCheckpointed();
    internal long get_StartOrdinal();
    internal long get_EndOrdinal();
    internal int get_CommonFrameCount();
    internal ThreadCheckpointEvent get_StartingCheckpoint();
    internal void set_StartingCheckpoint(ThreadCheckpointEvent value);
    [CompilerGeneratedAttribute]
internal LinkedListNode`1<TreeSlice> get_CacheEntry();
    [CompilerGeneratedAttribute]
internal void set_CacheEntry(LinkedListNode`1<TreeSlice> value);
    internal ModuleTracker get_ModuleTracker();
    internal ConfigurationTracker get_ConfigTracker();
    internal void EnsureLoaded();
    private bool MarkHiddenNodes(EventHandle root, long firstVisibleOrdinal);
    internal void Unload();
    internal void Neuter();
    internal void SetEndpoint(long endOrdinal, long endThreadPartition);
    internal void RefreshEndpoint();
    internal Node GetNode(int nodeId);
    internal EventHandle FindNodeForOrdinal(long ordinal, int matchingDepth);
    internal EventHandle FindClosestCallSiteNode(long ordinal, int matchingDepth);
    private EventHandle FindClosestNode(long ordinal, int matchingDepth, bool isCallsiteNodeOnly);
    internal EventHandle FindCopyOfNode(CallsiteNode callsite, SliceEdge edge);
    internal EventHandle GetLastEvent();
    internal EventHandle AddNode(Node n);
    internal void MapOrdinal(long oldOrdinal, long newOrdinal);
}
internal class Microsoft.VisualStudio.IntelliTrace.TreeSliceManager : object {
    private TraceLogReader _reader;
    private int _osTid;
    private int _loggerTid;
    private Dictionary`2<long, TreeSlice> _slices;
    private Dictionary`2<long, long> _mappedOrdinals;
    private ThreadCheckpointChain _cpChain;
    private ThreadChain _threadChain;
    private DiagnosticCheckpointChain _npcpChain;
    private DiagnosticChain _npChain;
    private long _firstValidSlice;
    private long _afterLastValidSlice;
    private long _currNpPartition;
    internal int ThreadId { get; }
    internal int OsThreadId { get; }
    internal ModuleTracker ModuleTracker { get; }
    internal ConfigurationTracker ConfigTracker { get; }
    private long ValidSliceCount { get; }
    internal bool IsThreadCheckpointed { get; }
    internal TreeSliceManager(TraceLogReader reader, int osTid, int loggerTid);
    internal int get_ThreadId();
    internal int get_OsThreadId();
    internal ModuleTracker get_ModuleTracker();
    internal ConfigurationTracker get_ConfigTracker();
    private long get_ValidSliceCount();
    internal void Refresh();
    internal Node GetNode(int sliceId, int nodeId);
    internal List`1<TreeSlice> GetSlices();
    internal EventHandle FindClosestNode(EventHandle eh);
    internal EventHandle FindClosestNode(long ordinal, int matchingDepth);
    internal EventHandle FindClosestCallSiteNode(long ordinal, int matchingDepth);
    internal EventHandle GetFirstCopyOfNode(CallsiteNode callsite);
    internal EventHandle GetLastCopyOfNode(CallsiteNode callsite);
    internal EventHandle GetPreviousCopyOfNode(CallsiteNode callsite);
    internal EventHandle GetNextCopyOfNode(CallsiteNode callsite);
    internal bool get_IsThreadCheckpointed();
    internal EventHandle GetLastEvent();
    internal void TranslateToken(int proteusToken, Int32& mdToken, Guid& mvid);
    internal void MapOrdinal(long oldOrdinal, long newOrdinal);
    private SlicedEventChain CreateSlicedThreadChain(long partition);
    private SlicedEventChain CreateSlicedNPChain(long threadEventOrdinal);
    private SlicedEventChain CreateSlicedCPChain(long partition);
    private TreeSlice GetSlice(int sliceId);
    private TreeSlice FindSliceByOrdinal(long eventOrdinal);
    private long GetMappedOrdinal(long ordinal);
    private TreeSlice FindFirstSliceForNode(CallsiteNode callsite);
    private TreeSlice FindLastSliceForNode(CallsiteNode callsite);
    private TreeSlice FindPreviousSliceForNode(CallsiteNode callsite);
    private TreeSlice FindNextSliceForNode(CallsiteNode callsite);
    private CodeContext GetCodeContext(IntelliTraceStackFrame frame);
    private int GuessCommonFrameCount(IList`1<IntelliTraceStackFrame> leftFrames, IList`1<IntelliTraceStackFrame> rightFrames);
    private bool IsLastEvent(CallsiteNode callsite);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.TreeState : object {
    protected Tree _tree;
    protected TreeState(Tree tree);
    internal virtual TreeState OnNotifyPoint(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnCheckPoint(ThreadCheckpointEvent eventData);
    internal virtual TreeState OnUIRecordedEvent(DebuggerInteractionEvent eventData);
    internal virtual TreeState OnThrowNP(DiagnosticEvent eventData);
    internal virtual TreeState OnCatchNP(DiagnosticEvent eventData);
    internal virtual TreeState OnExceptionInterceptedNP(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnExceptionStopNP(DiagnosticEvent eventData, EventHandle eventHandle);
    internal virtual TreeState OnThreadDestroyed(DiagnosticEvent eventData);
    internal virtual TreeState OnMethodEnter(MethodEnterEvent eventData);
    internal virtual TreeState OnMethodExit(MethodExitEvent eventData);
    internal virtual TreeState OnCallsite(CallSiteEvent eventData);
    internal virtual TreeState OnTailCall(TailCallSiteEvent eventData);
    internal virtual TreeState OnExceptionThrown(ExceptionThrownEvent eventData);
    internal virtual TreeState OnExceptionSearchFunctionEnter(ExceptionSearchFunctionEnterEvent eventData);
    internal virtual TreeState OnExceptionSearchFunctionExit(ExceptionSearchFunctionExitEvent eventData);
    internal virtual TreeState OnExceptionSearchFilterEnter(ExceptionSearchFilterEnterEvent eventData);
    internal virtual TreeState OnExceptionSearchFilterExit(ExceptionSearchFilterExitEvent eventData);
    internal virtual TreeState OnExceptionSearchCatcherFound(ExceptionSearchCatchFoundEvent eventData);
    internal virtual TreeState OnExceptionUnwindFunctionEnter(ExceptionUnwindFunctionEnterEvent eventData);
    internal virtual TreeState OnExceptionUnwindFunctionExit(ExceptionUnwindFunctionExitEvent eventData);
    internal virtual TreeState OnExceptionUnwindFinallyEnter(ExceptionUnwindFinallyEnterEvent eventData);
    internal virtual TreeState OnExceptionUnwindFinallyExit(ExceptionUnwindFinallyExitEvent eventData);
    internal virtual TreeState OnExceptionCatcherEnter(ExceptionCatchEnterEvent eventData);
    internal virtual TreeState OnExceptionCatcherExit(ExceptionCatchExitEvent eventData);
    private TreeState InvalidTransition(T evt);
}
internal class Microsoft.VisualStudio.IntelliTrace.TreeTracker : EventTracker {
    private int _nativeTid;
    private TreeSlice _slice;
    private TreeState _state;
    private Tree _tree;
    private EventHandle _lastEvent;
    internal EventHandle LastEvent { get; internal set; }
    internal bool IsCheckpointed { get; }
    internal EventHandle Root { get; }
    internal TreeTracker(int nativeTid, TreeSlice slice);
    internal virtual void HandleEvent(DiagnosticEvent notifyPoint, EventHandle handle);
    internal virtual void HandleEvent(ThreadCheckpointEvent checkpoint, EventHandle handle);
    internal virtual void HandleEvent(DebuggerInteractionEvent uiRecorded, EventHandle handle);
    internal virtual void HandleEvent(MethodEnterEvent methodEnter, EventHandle handle);
    internal virtual void HandleEvent(MethodExitEvent methodExit, EventHandle handle);
    internal virtual void HandleEvent(CallSiteEvent callsite, EventHandle handle);
    internal virtual void HandleEvent(TailCallSiteEvent callsite, EventHandle handle);
    internal virtual void HandleEvent(ExceptionThrownEvent exceptionThrown, EventHandle handle);
    internal virtual void HandleEvent(ExceptionSearchFunctionEnterEvent searchFunctionEnter, EventHandle handle);
    internal virtual void HandleEvent(ExceptionSearchFunctionExitEvent searchFunctionExit, EventHandle handle);
    internal virtual void HandleEvent(ExceptionSearchFilterEnterEvent searchFilterEnter, EventHandle handle);
    internal virtual void HandleEvent(ExceptionSearchFilterExitEvent searchFilterExit, EventHandle handle);
    internal virtual void HandleEvent(ExceptionSearchCatchFoundEvent searchCatcherFound, EventHandle handle);
    internal virtual void HandleEvent(ExceptionUnwindFunctionEnterEvent unwindFunctionEnter, EventHandle handle);
    internal virtual void HandleEvent(ExceptionUnwindFunctionExitEvent unwindFunctionExit, EventHandle handle);
    internal virtual void HandleEvent(ExceptionUnwindFinallyEnterEvent unwindFinallyEnter, EventHandle handle);
    internal virtual void HandleEvent(ExceptionUnwindFinallyExitEvent unwindFinallyExit, EventHandle handle);
    internal virtual void HandleEvent(ExceptionCatchEnterEvent catcherEnter, EventHandle handle);
    internal virtual void HandleEvent(ExceptionCatchExitEvent catcherExit, EventHandle handle);
    internal EventHandle get_LastEvent();
    internal void set_LastEvent(EventHandle value);
    internal EventHandle AddNode(T node);
    internal void MapOrdinal(long oldOrdinal, long newOrdinal);
    internal bool get_IsCheckpointed();
    internal EventHandle get_Root();
}
internal class Microsoft.VisualStudio.IntelliTrace.TreeTrackerException : Exception {
    public TreeTrackerException(string message, Exception innerException);
    protected TreeTrackerException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.VisualStudio.IntelliTrace.TreeTraverser : object {
    private TraceLogReader _logReader;
    private ITreeVisitor _visitor;
    internal TreeTraverser(TraceLogReader logReader, ITreeVisitor visitor);
    public void TraverseThread(int loggerThreadId);
    public void TraverseThread(int loggerThreadId, long startOrdinal);
    public void TraverseThread(int loggerThreadId, long startOrdinal, long endOrdinal);
    internal void TraverseNode(EventHandle evt, int depth, Nullable`1<long> startOrdinal, Nullable`1<long> endOrdinal);
}
internal class Microsoft.VisualStudio.IntelliTrace.TrueNode : ExprNode {
    internal virtual Expr`2<T, bool> CompileBoolExpr();
    internal virtual Expr`2<T, int> CompileIntExpr();
    internal virtual Expr`2<T, long> CompileLongExpr();
    internal virtual Expr`2<T, string> CompileStringExpr();
}
public class Microsoft.VisualStudio.IntelliTrace.TypeSpecMetadataEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<byte> <SignatureBytes>k__BackingField;
    public Guid Mvid { get; private set; }
    public int MetadataToken { get; private set; }
    public IList`1<byte> SignatureBytes { get; private set; }
    internal TypeSpecMetadataEvent(TypeSpecMetadata* pData);
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    [CompilerGeneratedAttribute]
private void set_Mvid(Guid value);
    [CompilerGeneratedAttribute]
public int get_MetadataToken();
    [CompilerGeneratedAttribute]
private void set_MetadataToken(int value);
    [CompilerGeneratedAttribute]
public IList`1<byte> get_SignatureBytes();
    [CompilerGeneratedAttribute]
private void set_SignatureBytes(IList`1<byte> value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.UlsNPData : NPData {
    public static string UlsNPCategoryName;
    public static int UlsEventIdDataIndex;
    [CompilerGeneratedAttribute]
private string <LongDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UlsEventId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UlsCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private short <UlsLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UlsArea>k__BackingField;
    public string LongDescription { get; public set; }
    public int UlsEventId { get; public set; }
    public string UlsCategory { get; public set; }
    public short UlsLevel { get; public set; }
    public string CorrelationId { get; public set; }
    public string UlsArea { get; public set; }
    public UlsNPData(string categoryName);
    [CompilerGeneratedAttribute]
public string get_LongDescription();
    [CompilerGeneratedAttribute]
public void set_LongDescription(string value);
    [CompilerGeneratedAttribute]
public int get_UlsEventId();
    [CompilerGeneratedAttribute]
public void set_UlsEventId(int value);
    [CompilerGeneratedAttribute]
public string get_UlsCategory();
    [CompilerGeneratedAttribute]
public void set_UlsCategory(string value);
    [CompilerGeneratedAttribute]
public short get_UlsLevel();
    [CompilerGeneratedAttribute]
public void set_UlsLevel(short value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public string get_UlsArea();
    [CompilerGeneratedAttribute]
public void set_UlsArea(string value);
    public static short ConvertUlsLevel(string ulsLevelString);
}
internal class Microsoft.VisualStudio.IntelliTrace.UnloadPartitionEventArgs`1 : PartitionedListEventArgs`1<T> {
    public UnloadPartitionEventArgs`1(Partition`1<T> partition);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.IntelliTrace.UnpackResult : Enum {
    public int value__;
    public static UnpackResult InvalidRef;
    public static UnpackResult Null;
    public static UnpackResult Succeeded;
    public static UnpackResult PartialData;
    public static UnpackResult Remoted;
    public static UnpackResult NullableNull;
    public static UnpackResult UncollectedRef;
    public static UnpackResult CycleRef;
}
internal enum Microsoft.VisualStudio.IntelliTrace.UserCodeEnum : Enum {
    public int value__;
    public static UserCodeEnum Unknown;
    public static UserCodeEnum UserCode;
    public static UserCodeEnum NonUserCode;
}
internal class Microsoft.VisualStudio.IntelliTrace.Version : object {
    public static ushort AnyVersion;
    public ushort MajorVersion;
    public ushort MinorVersion;
    public ushort BuildNumber;
    public ushort RevisionNumber;
    public Version(string version);
}
[CompilerGeneratedAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.VersionInfo : object {
    public static string AssemblyVersion;
    public static string AssemblyFileVersion;
    private static VersionInfo();
}
[CompilerGeneratedAttribute]
internal static class Microsoft.VisualStudio.IntelliTrace.VisualStudioVersionInfo : object {
    public static string MajorVersion;
    public static string MinorVersion;
    public static string ProductVersion;
    public static string VSAssemblyVersion;
}
[CommandLineConfigurationAttribute("")]
[CommandLineTitleAttribute("Cmd_CommandLineTitle")]
[CommandLineDescriptionAttribute("Cmd_CommandLineDescription")]
[CommandLineCopyrightAttribute("Cmd_CommandLineCopyright")]
[CommandLineCommandAttribute("start")]
[CommandLineCommandAttribute("run")]
[CommandLineCommandAttribute("stop")]
[CommandLineCommandAttribute("help")]
[CommandLineCommandAttribute("launch")]
[CommandLineCommandAttribute("status")]
[CommandLineCommandAttribute("statistics")]
[CommandLineCommandAttribute("copy")]
internal class Microsoft.VisualStudio.IntelliTrace.VSTraceLog : object {
    private string _command;
    private CommandLineParser _parser;
    private OutputHelper _outputHelper;
    [CompilerGeneratedAttribute]
private TraceLoggerStartInfo <TraceLoggerStartInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowHelp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoLogo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowHidden>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputRemoteMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExecutableToStart>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceLogger <Logger>k__BackingField;
    private CommandLineParser Parser { get; }
    private OutputHelper Output { get; }
    private TraceLoggerStartInfo TraceLoggerStartInfo { get; }
    [CommandLineArgumentAttribute("name")]
public string LoggerName { get; public set; }
    [CommandLineArgumentAttribute("logfile")]
public string LogFilePath { get; public set; }
    [CommandLineArgumentAttribute("buffersize")]
public int BufferSize { get; public set; }
    [CommandLineArgumentAttribute("buffercount")]
public int BufferCount { get; public set; }
    public int CacheBufferCount { get; public set; }
    [CommandLineArgumentAttribute("watch")]
public int WatchPid { get; public set; }
    [CommandLineArgumentAttribute("help")]
public bool ShowHelp { get; public set; }
    [CommandLineArgumentAttribute("nologo")]
public bool NoLogo { get; public set; }
    [CommandCommandLineArgumentAttribute("command")]
public string Command { get; public set; }
    [CommandLineArgumentAttribute("collectionPlan")]
public string CollectionPlanPath { get; public set; }
    [CommandLineArgumentAttribute("hidden")]
public bool ShowHidden { get; public set; }
    public bool OutputRemoteMessages { get; public set; }
    [DefaultCommandLineArgumentAttribute("default")]
public string DefaultArgument { get; public set; }
    [UnprocessedCommandLineArgumentAttribute("arguments")]
public String[] Arguments { get; public set; }
    public int Timeout { get; public set; }
    public string ExecutableToStart { get; private set; }
    public TraceLogger Logger { get; private set; }
    internal VSTraceLog(TraceLogger logger, string pathToLogger);
    private CommandLineParser get_Parser();
    private OutputHelper get_Output();
    [CompilerGeneratedAttribute]
private TraceLoggerStartInfo get_TraceLoggerStartInfo();
    public string get_LoggerName();
    public void set_LoggerName(string value);
    public string get_LogFilePath();
    public void set_LogFilePath(string value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public int get_BufferCount();
    public void set_BufferCount(int value);
    public int get_CacheBufferCount();
    public void set_CacheBufferCount(int value);
    public int get_WatchPid();
    public void set_WatchPid(int value);
    [CompilerGeneratedAttribute]
public bool get_ShowHelp();
    [CompilerGeneratedAttribute]
public void set_ShowHelp(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoLogo();
    [CompilerGeneratedAttribute]
public void set_NoLogo(bool value);
    public string get_Command();
    public void set_Command(string value);
    public string get_CollectionPlanPath();
    public void set_CollectionPlanPath(string value);
    [CompilerGeneratedAttribute]
public bool get_ShowHidden();
    [CompilerGeneratedAttribute]
public void set_ShowHidden(bool value);
    [CompilerGeneratedAttribute]
public bool get_OutputRemoteMessages();
    [CompilerGeneratedAttribute]
public void set_OutputRemoteMessages(bool value);
    public string get_DefaultArgument();
    public void set_DefaultArgument(string value);
    public String[] get_Arguments();
    public void set_Arguments(String[] value);
    [CompilerGeneratedAttribute]
public int get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public string get_ExecutableToStart();
    [CompilerGeneratedAttribute]
private void set_ExecutableToStart(string value);
    [CompilerGeneratedAttribute]
public TraceLogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(TraceLogger value);
    public bool Execute();
    private bool ExecuteStop();
    private bool ExecuteRun();
    public bool ExecuteStart();
    public bool ExecuteStatistics();
    public sealed virtual bool ProcessCommandLine(String[] args);
}
internal class Microsoft.VisualStudio.IntelliTrace.WebChainWeaver : object {
    private WebRequestStreamChain _requestStream;
    private WebSessionStreamChain _sessionStream;
    private WebThreadStreamChain _threadStream;
    public WebRequestStreamChain RequestStream { get; }
    public WebChainWeaver(IntelliTraceFileBase file);
    public WebRequestStreamChain get_RequestStream();
    public WebRequestEvent GetWebRequestEvent(EventToken requestToken);
    public IList`1<WebEventFilter> GetWebEventFilters(int requestId, long threadStreamOffset, Boolean& eventsTruncated);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.WebEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private EventToken <EventToken>k__BackingField;
    public EventToken EventToken { get; private set; }
    protected WebEvent(EventToken token, long ordinal);
    [CompilerGeneratedAttribute]
public EventToken get_EventToken();
    [CompilerGeneratedAttribute]
private void set_EventToken(EventToken value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal class Microsoft.VisualStudio.IntelliTrace.WebEventFilter : DiagnosticEventFilter {
    private long _start;
    private long _end;
    private int _threadId;
    internal int ThreadId { get; }
    internal long StartOrdinal { get; }
    internal long EndOrdinal { get; }
    public WebEventFilter(int threadId, long start, long end);
    public virtual bool Match(DiagnosticEvent diagnosticEvent);
    internal int get_ThreadId();
    internal long get_StartOrdinal();
    internal long get_EndOrdinal();
}
internal class Microsoft.VisualStudio.IntelliTrace.WebRequestCache : object {
    private Dictionary`2<int, int> _activeThreadToRequestMap;
    private Dictionary`2<int, WebRequestCacheEntry> _cache;
    public void OnWebAssociatedDiagnosticEvent(_NotifyPointData data);
    public void OnWebRequestBegin(_WebRequestBegin begin);
    public void OnWebThreadAssociationBegin(_WebThreadInfo threadInfo);
    public void OnWebThreadAssociationEnd(_WebThreadInfo threadInfo);
    private static bool UriMatchesDefaultRedirect(string firstUri, string secondUri);
    public WebRequestCacheEntry OnWebRequestEnd(_WebRequestEnd end);
    private WebRequestCacheEntry GetCacheEntry(int requestId);
}
internal class Microsoft.VisualStudio.IntelliTrace.WebRequestCallTreeTraverser : object {
    private IList`1<CallTreeNode> _callTrees;
    private CallTreeNode _currentCallTree;
    private Stack`1<CallTreeNode> _currentCallStack;
    private int _placeholderFrameCount;
    private DelegateTreeVisitor _treeVisitor;
    private long _startOrdinal;
    private long _endOrdinal;
    private int _loggerThreadId;
    private IntelliTraceProcess _process;
    private TraceLogReader _traceLogReader;
    private IIntelliTraceThreadProvider _threadProvider;
    [CompilerGeneratedAttribute]
private DataProvider <DataProvider>k__BackingField;
    private DataProvider DataProvider { get; private set; }
    public WebRequestCallTreeTraverser(TraceLogReader logReader, IntelliTraceProcess process, IIntelliTraceThreadProvider threadProvider);
    [CompilerGeneratedAttribute]
private DataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
private void set_DataProvider(DataProvider value);
    public IList`1<CallTreeNode> GetCallTreeData(IList`1<WebEventFilter> filters);
    private bool HasLeftScope(long ordinal);
    private bool HasEnteredScope(long ordinal);
    private void OnStatement(ITreeNode node, int depth);
    private void OnEnter(ITreeNode node, int depth);
    private void OnExit(ITreeNode node, int depth);
    private void ResetCallTree(bool commitCallTree);
}
internal class Microsoft.VisualStudio.IntelliTrace.WebRequestEvent : WebScopedEvent {
    [CompilerGeneratedAttribute]
private long <BeginOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Ip>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SubStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ActivityId>k__BackingField;
    public long BeginOrdinal { get; private set; }
    public int WebRequestId { get; }
    public string RequestUrl { get; private set; }
    public string Ip { get; private set; }
    public string UserAgent { get; private set; }
    public int ResponseCode { get; private set; }
    public int SubStatus { get; private set; }
    public int SessionId { get; private set; }
    public string HttpMethod { get; private set; }
    public Nullable`1<Guid> ActivityId { get; private set; }
    public WebRequestEvent(EventToken token, long ordinal);
    public WebRequestEvent(EventToken token, _WebRequest request);
    [CompilerGeneratedAttribute]
public long get_BeginOrdinal();
    [CompilerGeneratedAttribute]
private void set_BeginOrdinal(long value);
    public int get_WebRequestId();
    [CompilerGeneratedAttribute]
public string get_RequestUrl();
    [CompilerGeneratedAttribute]
private void set_RequestUrl(string value);
    [CompilerGeneratedAttribute]
public string get_Ip();
    [CompilerGeneratedAttribute]
private void set_Ip(string value);
    [CompilerGeneratedAttribute]
public string get_UserAgent();
    [CompilerGeneratedAttribute]
private void set_UserAgent(string value);
    [CompilerGeneratedAttribute]
public int get_ResponseCode();
    [CompilerGeneratedAttribute]
private void set_ResponseCode(int value);
    [CompilerGeneratedAttribute]
public int get_SubStatus();
    [CompilerGeneratedAttribute]
private void set_SubStatus(int value);
    [CompilerGeneratedAttribute]
public int get_SessionId();
    [CompilerGeneratedAttribute]
private void set_SessionId(int value);
    [CompilerGeneratedAttribute]
public string get_HttpMethod();
    [CompilerGeneratedAttribute]
private void set_HttpMethod(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ActivityId();
    [CompilerGeneratedAttribute]
private void set_ActivityId(Nullable`1<Guid> value);
}
internal class Microsoft.VisualStudio.IntelliTrace.WebRequestStreamChain : EventStreamChain {
    private Nullable`1<bool> _isPerfEvent;
    public WebRequestStreamChain(LogStream webRequestStream, WebRequestTrackingEventsMessagePacker packer);
    protected virtual IntelliTraceEvent CreateEvent(EventToken token, short messageId, Byte* message);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.WebScopedEvent : WebEvent {
    [CompilerGeneratedAttribute]
private long <BeginEventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndEventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ThreadStreamOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    public long BeginEventTime { get; private set; }
    public long EndEventTime { get; private set; }
    public long ThreadStreamOffset { get; private set; }
    public int Id { get; private set; }
    protected WebScopedEvent(int id, EventToken token, long ordinal, long beginEventTime, long endEventTime, long threadStreamOffset);
    [CompilerGeneratedAttribute]
public long get_BeginEventTime();
    [CompilerGeneratedAttribute]
private void set_BeginEventTime(long value);
    [CompilerGeneratedAttribute]
public long get_EndEventTime();
    [CompilerGeneratedAttribute]
private void set_EndEventTime(long value);
    [CompilerGeneratedAttribute]
public long get_ThreadStreamOffset();
    [CompilerGeneratedAttribute]
private void set_ThreadStreamOffset(long value);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(int value);
}
internal class Microsoft.VisualStudio.IntelliTrace.WebSessionBeginEvent : WebSessionEvent {
    public WebSessionBeginEvent(EventToken token, long ordinal);
    public WebSessionBeginEvent(EventToken token, _WebSessionBegin session);
}
internal class Microsoft.VisualStudio.IntelliTrace.WebSessionEndEvent : WebSessionEvent {
    public WebSessionEndEvent(EventToken token, long ordinal);
    public WebSessionEndEvent(EventToken token, _WebSessionEnd session);
}
internal abstract class Microsoft.VisualStudio.IntelliTrace.WebSessionEvent : WebEvent {
    [CompilerGeneratedAttribute]
private int <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    public int SessionId { get; protected set; }
    public long EventTime { get; protected set; }
    protected WebSessionEvent(EventToken token, long ordinal);
    protected WebSessionEvent(EventToken token, long ordinal, int sesionId, long eventTime);
    [CompilerGeneratedAttribute]
public int get_SessionId();
    [CompilerGeneratedAttribute]
protected void set_SessionId(int value);
    [CompilerGeneratedAttribute]
public long get_EventTime();
    [CompilerGeneratedAttribute]
protected void set_EventTime(long value);
}
internal class Microsoft.VisualStudio.IntelliTrace.WebSessionStreamChain : EventStreamChain {
    public WebSessionStreamChain(LogStream stream, WebSessionTrackingEventsMessagePacker packer);
    protected virtual IntelliTraceEvent CreateEvent(EventToken token, short messageId, Byte* message);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
}
internal class Microsoft.VisualStudio.IntelliTrace.WebThreadEvent : WebEvent {
    [CompilerGeneratedAttribute]
private long <BeginOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WebRequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    public long BeginOrdinal { get; private set; }
    public int WebRequestId { get; private set; }
    public int ThreadId { get; private set; }
    public WebThreadEvent(EventToken token, long ordinal);
    public WebThreadEvent(EventToken token, _WebThreadAssociation thread);
    [CompilerGeneratedAttribute]
public long get_BeginOrdinal();
    [CompilerGeneratedAttribute]
private void set_BeginOrdinal(long value);
    [CompilerGeneratedAttribute]
public int get_WebRequestId();
    [CompilerGeneratedAttribute]
private void set_WebRequestId(int value);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
private void set_ThreadId(int value);
}
internal class Microsoft.VisualStudio.IntelliTrace.WebThreadStreamChain : EventStreamChain {
    public WebThreadStreamChain(LogStream stream, WebThreadTrackingEventsMessagePacker packer);
    protected virtual IntelliTraceEvent CreateEvent(EventToken token, short messageId, Byte* message);
    public virtual bool IsValidEventType(IntelliTraceEvent chainEvent);
}
internal class Microsoft.VisualStudio.IntelliTrace.WebTracker : ScopedEventTracker`1<WebRequestEvent> {
    public WebTracker(IntelliTraceFileBase file);
}
internal class Microsoft.VisualStudio.IntelliTrace.WhereIterator`1 : object {
    private Filter`1<T> _prev;
    private Predicate`1<T> _predicate;
    internal WhereIterator`1(Filter`1<T> prev, Predicate`1<T> predicate);
    internal IEnumerable`1<T> Iter(IEnumerable`1<T> input);
}
internal class Microsoft.VisualStudio.IntelliTrace.WhereNode : FilterNode {
    [CompilerGeneratedAttribute]
private FilterNode <Previous>k__BackingField;
    [CompilerGeneratedAttribute]
private ExprNode <Predicate>k__BackingField;
    internal FilterNode Previous { get; internal set; }
    internal ExprNode Predicate { get; internal set; }
    [CompilerGeneratedAttribute]
internal FilterNode get_Previous();
    [CompilerGeneratedAttribute]
internal void set_Previous(FilterNode value);
    [CompilerGeneratedAttribute]
internal ExprNode get_Predicate();
    [CompilerGeneratedAttribute]
internal void set_Predicate(ExprNode value);
    internal virtual Predicate`1<T> CompilePredicate(QueryArguments`2<T, R> arguments);
    internal virtual Filter`1<T> CompileFilter(QueryArguments`2<T, R> arguments);
}
public class Microsoft.VisualStudio.IntelliTrace.WorkerProcessInformationEvent : OrdinalEvent {
    [CompilerGeneratedAttribute]
private string <ApplicationPoolName>k__BackingField;
    public string ApplicationPoolName { get; private set; }
    internal WorkerProcessInformationEvent(_WorkerProcessInfo data);
    [CompilerGeneratedAttribute]
public string get_ApplicationPoolName();
    [CompilerGeneratedAttribute]
private void set_ApplicationPoolName(string value);
    internal virtual void Dispatch(EventTracker tracker, EventHandle handle);
}
internal static class Microsoft.VisualStudio.IntelliTrace.Wow64Redirection : object {
    private static bool Wow64DisableWow64FsRedirection(IntPtr& handle);
    private static bool Wow64RevertWow64FsRedirection(IntPtr handle);
    public static T CallWithoutRedirect(Func`1<T> action, bool isTargetProcess64Bit);
    private static bool DisableRedirectForModulePaths(bool isTargetProcess64Bit);
}
[GuidAttribute("6380BCFF-41D3-4B2E-8B2E-BF8A6810C848")]
[InterfaceTypeAttribute("1")]
public interface Microsoft.VisualStudio.Setup.Interop.IEnumSetupInstances {
    public abstract virtual void Next(int celt, ISetupInstance& rgelt, Int32& pceltFetched);
    public abstract virtual void Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual IEnumSetupInstances Clone();
}
[GuidAttribute("42843719-DB4C-46C2-8E7C-64F1816EFD5B")]
[InterfaceTypeAttribute("1")]
public interface Microsoft.VisualStudio.Setup.Interop.ISetupConfiguration {
    public abstract virtual IEnumSetupInstances EnumInstances();
    public abstract virtual ISetupInstance GetInstanceForCurrentProcess();
    public abstract virtual ISetupInstance GetInstanceForPath(string wzPath);
}
[GuidAttribute("B41463C3-8866-43B5-BC33-2B0676F7F42E")]
[InterfaceTypeAttribute("1")]
public interface Microsoft.VisualStudio.Setup.Interop.ISetupInstance {
    public abstract virtual string GetInstanceId();
    public abstract virtual FILETIME GetInstallDate();
    public abstract virtual string GetInstallationName();
    public abstract virtual string GetInstallationPath();
    public abstract virtual string GetInstallationVersion();
    public abstract virtual string GetDisplayName(int lcid);
    public abstract virtual string GetDescription(int lcid);
    public abstract virtual string ResolvePath(string relativePath);
}
[GuidAttribute("177F0C4A-1CD3-4DE7-A32C-71DBBB9FA36D")]
public class Microsoft.VisualStudio.Setup.Interop.SetupConfiguration : object {
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.BuildInformationMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static BuildInformationMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static BuildInformationMessagePacker Default { get; private set; }
    public BuildInformationMessagePacker(MessageInfo mi);
    private static BuildInformationMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static BuildInformationMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(BuildInformationMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageApplicationBuildInfo(ApplicationBuildInfo* pApplicationBuildInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageApplicationBuildInfo(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageApplicationBuildInfo(_ApplicationBuildInfo applicationBuildInfo, IMessageMemory2 memory, Int32& msgLen);
    public _ApplicationBuildInfo UnpackMessageApplicationBuildInfoToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ApplicationBuildInfo UnpackMessageApplicationBuildInfoToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.ConfigMessagePacker : MessagePacker {
    public static Int32[] CompatibleParameterBlobVersions;
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static ConfigMessagePacker <Default>k__BackingField;
    private static object xmlSchemaReference;
    private static object xmlClassLock;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static ConfigMessagePacker Default { get; private set; }
    private static XmlSchema MessagesXmlSchema { get; }
    public ConfigMessagePacker(MessageInfo mi);
    private static ConfigMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static ConfigMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(ConfigMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageCollectionPlan(CollectionPlan* pCollectionPlan, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCollectionPlan(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCollectionPlan(_CollectionPlan collectionPlan, IMessageMemory2 memory, Int32& msgLen);
    public _CollectionPlan UnpackMessageCollectionPlanToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CollectionPlan UnpackMessageCollectionPlanToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFileState(FileState* pFileState, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageFileState(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFileState(_FileState fileState, IMessageMemory2 memory, Int32& msgLen);
    public _FileState UnpackMessageFileStateToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _FileState UnpackMessageFileStateToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTraceVersionInfo(TraceVersionInfo* pTraceVersionInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTraceVersionInfo(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTraceVersionInfo(_TraceVersionInfo traceVersionInfo, IMessageMemory2 memory, Int32& msgLen);
    public _TraceVersionInfo UnpackMessageTraceVersionInfoToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TraceVersionInfo UnpackMessageTraceVersionInfoToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public static XmlSchema GenerateXmlSchema();
    private static XmlSchema get_MessagesXmlSchema();
    public static void WriteSchema(TextWriter xml);
    private static void OnValidationEvent(object sender, ValidationEventArgs e);
    private static XmlReader CreateXmlReader(TextReader xml, bool useSchemaValidation);
    internal static LaunchType FromTokenString_LaunchType(string val);
    internal static AttachOptions FromTokenString_AttachOptions(string val);
    internal static ClrVersionAttachOptions FromTokenString_ClrVersionAttachOptions(string val);
    internal static TraceOptions FromTokenString_TraceOptions(string val);
    internal static AllowedUserType FromTokenString_AllowedUserType(string val);
    internal static ProfilerDebugFlags FromTokenString_ProfilerDebugFlags(string val);
    internal static CheckpointMode FromTokenString_CheckpointMode(string val);
    internal static DetourOptions FromTokenString_DetourOptions(string val);
    internal static SectionId FromTokenString_SectionId(string val);
    internal static ClrType FromTokenString_ClrType(string val);
    internal static CollectionLevel FromTokenString_CollectionLevel(string val);
    internal static string ToTokenString(LaunchType val);
    internal static string ToTokenString(AttachOptions val);
    internal static string ToTokenString(ClrVersionAttachOptions val);
    internal static string ToTokenString(TraceOptions val);
    internal static string ToTokenString(AllowedUserType val);
    internal static string ToTokenString(ProfilerDebugFlags val);
    internal static string ToTokenString(CheckpointMode val);
    internal static string ToTokenString(DetourOptions val);
    internal static string ToTokenString(SectionId val);
    internal static string ToTokenString(ClrType val);
    internal static string ToTokenString(CollectionLevel val);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
internal class Microsoft.VisualStudio.TraceLog.DefaultServiceMessages : object {
    internal static ResourceManager ResourceManager;
    public static string FatalErrorInService { get; }
    public static string LoggingServiceStarted { get; }
    public static string LoggingServiceStopped { get; }
    private static DefaultServiceMessages();
    public static string AttemptToCopyLogFileFailed(object param0, object param1);
    public static string AttemptToCreateLogFileFailed(object param0, object param1, object param2);
    public static string ErrorInSession(object param0, object param1);
    public static string ExpectedProcessTraitsAdded(object param0);
    public static string get_FatalErrorInService();
    public static string InjectedProcessStarted(object param0, object param1);
    public static string get_LoggingServiceStarted();
    public static string get_LoggingServiceStopped();
    public static string ProcessWasExpected(object param0, object param1, object param2);
    public static string ProcessWasNotExpected(object param0, object param1);
    public static string SessionEnding(object param0, object param1);
    public static string SessionFirstTruncation(object param0, object param1);
    public static string SessionOutOfLogSpace(object param0, object param1);
    public static string SessionStartError(object param0, object param1);
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.DiagnosticCheckpointEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static DiagnosticCheckpointEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static DiagnosticCheckpointEventsMessagePacker Default { get; private set; }
    public DiagnosticCheckpointEventsMessagePacker(MessageInfo mi);
    private static DiagnosticCheckpointEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static DiagnosticCheckpointEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(DiagnosticCheckpointEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageCheckpointOrdinalInfo(OrdinalInfo* pOrdinalInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCheckpointOrdinalInfo(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCheckpointOrdinalInfo(_OrdinalInfo ordinalInfo, IMessageMemory2 memory, Int32& msgLen);
    public _OrdinalInfo UnpackMessageCheckpointOrdinalInfoToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _OrdinalInfo UnpackMessageCheckpointOrdinalInfoToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageNotifyPointCheckpoint(SimpleCheckpointData* pSimpleCheckpointData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageNotifyPointCheckpoint(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageNotifyPointCheckpoint(_SimpleCheckpointData simpleCheckpointData, IMessageMemory2 memory, Int32& msgLen);
    public _SimpleCheckpointData UnpackMessageNotifyPointCheckpointToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _SimpleCheckpointData UnpackMessageNotifyPointCheckpointToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.ExceptionIndexMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static ExceptionIndexMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static ExceptionIndexMessagePacker Default { get; private set; }
    public ExceptionIndexMessagePacker(MessageInfo mi);
    private static ExceptionIndexMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static ExceptionIndexMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(ExceptionIndexMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageExceptionMarker(ExceptionMarker* pExceptionMarker, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageExceptionMarker(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageExceptionMarker(_ExceptionMarker exceptionMarker, IMessageMemory2 memory, Int32& msgLen);
    public _ExceptionMarker UnpackMessageExceptionMarkerToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ExceptionMarker UnpackMessageExceptionMarkerToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.IndependentEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static IndependentEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static IndependentEventsMessagePacker Default { get; private set; }
    public IndependentEventsMessagePacker(MessageInfo mi);
    private static IndependentEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static IndependentEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(IndependentEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageNotifyPointExceptionThrown(NotifyPointData* pNotifyPointData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageNotifyPointExceptionThrown(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageNotifyPointExceptionThrown(_NotifyPointData notifyPointData, IMessageMemory2 memory, Int32& msgLen);
    public _NotifyPointData UnpackMessageNotifyPointExceptionThrownToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _NotifyPointData UnpackMessageNotifyPointExceptionThrownToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageNotifyPointHit(NotifyPointData* pNotifyPointData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageNotifyPointHit(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageNotifyPointHit(_NotifyPointData notifyPointData, IMessageMemory2 memory, Int32& msgLen);
    public _NotifyPointData UnpackMessageNotifyPointHitToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _NotifyPointData UnpackMessageNotifyPointHitToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageUserInterfaceContents(UIContents* pUIContents, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageUserInterfaceContents(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageUserInterfaceContents(_UIContents uIContents, IMessageMemory2 memory, Int32& msgLen);
    public _UIContents UnpackMessageUserInterfaceContentsToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _UIContents UnpackMessageUserInterfaceContentsToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.ProcessEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static ProcessEventsMessagePacker <Default>k__BackingField;
    private static object xmlSchemaReference;
    private static object xmlClassLock;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static ProcessEventsMessagePacker Default { get; private set; }
    private static XmlSchema MessagesXmlSchema { get; }
    public ProcessEventsMessagePacker(MessageInfo mi);
    private static ProcessEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static ProcessEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(ProcessEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageAllocCoverageBufferRequest(AllocCoverageBufferRequest* pAllocCoverageBufferRequest, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageAllocCoverageBufferRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageAllocCoverageBufferRequest(_AllocCoverageBufferRequest allocCoverageBufferRequest, IMessageMemory2 memory, Int32& msgLen);
    public _AllocCoverageBufferRequest UnpackMessageAllocCoverageBufferRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _AllocCoverageBufferRequest UnpackMessageAllocCoverageBufferRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageAllocCoverageBufferResponse(AllocCoverageBufferResponse* pAllocCoverageBufferResponse, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageAllocCoverageBufferResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageAllocCoverageBufferResponse(_AllocCoverageBufferResponse allocCoverageBufferResponse, IMessageMemory2 memory, Int32& msgLen);
    public _AllocCoverageBufferResponse UnpackMessageAllocCoverageBufferResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _AllocCoverageBufferResponse UnpackMessageAllocCoverageBufferResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageAttachedProcessInfo(ProcessInfo* pProcessInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageAttachedProcessInfo(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageAttachedProcessInfo(_ProcessInfo processInfo, IMessageMemory2 memory, Int32& msgLen);
    public _ProcessInfo UnpackMessageAttachedProcessInfoToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ProcessInfo UnpackMessageAttachedProcessInfoToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageAttachRequest(ProcessInfo* pProcessInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageAttachRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageAttachRequest(_ProcessInfo processInfo, IMessageMemory2 memory, Int32& msgLen);
    public _ProcessInfo UnpackMessageAttachRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ProcessInfo UnpackMessageAttachRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCheckpointRequest(DataPacket* pDataPacket, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCheckpointRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCheckpointRequest(_DataPacket dataPacket, IMessageMemory2 memory, Int32& msgLen);
    public _DataPacket UnpackMessageCheckpointRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _DataPacket UnpackMessageCheckpointRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCheckpointSynchronize(DataPacket* pDataPacket, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCheckpointSynchronize(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCheckpointSynchronize(_DataPacket dataPacket, IMessageMemory2 memory, Int32& msgLen);
    public _DataPacket UnpackMessageCheckpointSynchronizeToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _DataPacket UnpackMessageCheckpointSynchronizeToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageConfigInstrumentationRequest(ProcessInfo* pProcessInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageConfigInstrumentationRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageConfigInstrumentationRequest(_ProcessInfo processInfo, IMessageMemory2 memory, Int32& msgLen);
    public _ProcessInfo UnpackMessageConfigInstrumentationRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ProcessInfo UnpackMessageConfigInstrumentationRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFreeCoverageBuffer(FreeCoverageBuffer* pFreeCoverageBuffer, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageFreeCoverageBuffer(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFreeCoverageBuffer(_FreeCoverageBuffer freeCoverageBuffer, IMessageMemory2 memory, Int32& msgLen);
    public _FreeCoverageBuffer UnpackMessageFreeCoverageBufferToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _FreeCoverageBuffer UnpackMessageFreeCoverageBufferToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetPropertyRequest(GetPropertyRequest* pGetPropertyRequest, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageGetPropertyRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetPropertyRequest(_GetPropertyRequest getPropertyRequest, IMessageMemory2 memory, Int32& msgLen);
    public _GetPropertyRequest UnpackMessageGetPropertyRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _GetPropertyRequest UnpackMessageGetPropertyRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetPropertyResponse(GetPropertyResponse* pGetPropertyResponse, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageGetPropertyResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageGetPropertyResponse(_GetPropertyResponse getPropertyResponse, IMessageMemory2 memory, Int32& msgLen);
    public _GetPropertyResponse UnpackMessageGetPropertyResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _GetPropertyResponse UnpackMessageGetPropertyResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageIndependentEventsStreamClose(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageIndependentEventsStreamClose(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageIndependentEventsStreamOpen(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageIndependentEventsStreamOpen(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageIndependentEventsWriteData(DataPacket* pDataPacket, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageIndependentEventsWriteData(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageIndependentEventsWriteData(_DataPacket dataPacket, IMessageMemory2 memory, Int32& msgLen);
    public _DataPacket UnpackMessageIndependentEventsWriteDataToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _DataPacket UnpackMessageIndependentEventsWriteDataToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageKeepAlive(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageKeepAlive(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageLoggerDetails(LoggerDetails* pLoggerDetails, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageLoggerDetails(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageLoggerDetails(_LoggerDetails loggerDetails, IMessageMemory2 memory, Int32& msgLen);
    public _LoggerDetails UnpackMessageLoggerDetailsToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _LoggerDetails UnpackMessageLoggerDetailsToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageLoggerInfo(LoggerInfo* pLoggerInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageLoggerInfo(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageLoggerInfo(_LoggerInfo loggerInfo, IMessageMemory2 memory, Int32& msgLen);
    public _LoggerInfo UnpackMessageLoggerInfoToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _LoggerInfo UnpackMessageLoggerInfoToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageLogStatisticsRequest(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageLogStatisticsRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageLogStatisticsResponse(LogStatisticsResponse* pLogStatisticsResponse, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageLogStatisticsResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageLogStatisticsResponse(_LogStatisticsResponse logStatisticsResponse, IMessageMemory2 memory, Int32& msgLen);
    public _LogStatisticsResponse UnpackMessageLogStatisticsResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _LogStatisticsResponse UnpackMessageLogStatisticsResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageModuleIsUserCode(ModuleIsUserCode* pModuleIsUserCode, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageModuleIsUserCode(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageModuleIsUserCode(_ModuleIsUserCode moduleIsUserCode, IMessageMemory2 memory, Int32& msgLen);
    public _ModuleIsUserCode UnpackMessageModuleIsUserCodeToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ModuleIsUserCode UnpackMessageModuleIsUserCodeToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageModuleLoaded(ModuleLoaded* pModuleLoaded, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageModuleLoaded(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageModuleLoaded(_ModuleLoaded moduleLoaded, IMessageMemory2 memory, Int32& msgLen);
    public _ModuleLoaded UnpackMessageModuleLoadedToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ModuleLoaded UnpackMessageModuleLoadedToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageModuleMetadata(ModuleMetadata* pModuleMetadata, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageModuleMetadata(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageModuleMetadata(_ModuleMetadata moduleMetadata, IMessageMemory2 memory, Int32& msgLen);
    public _ModuleMetadata UnpackMessageModuleMetadataToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ModuleMetadata UnpackMessageModuleMetadataToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageModuleToken(ModuleToken* pModuleToken, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageModuleToken(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageModuleToken(_ModuleToken moduleToken, IMessageMemory2 memory, Int32& msgLen);
    public _ModuleToken UnpackMessageModuleTokenToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ModuleToken UnpackMessageModuleTokenToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageModuleUnloaded(ModuleUnloaded* pModuleUnloaded, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageModuleUnloaded(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageModuleUnloaded(_ModuleUnloaded moduleUnloaded, IMessageMemory2 memory, Int32& msgLen);
    public _ModuleUnloaded UnpackMessageModuleUnloadedToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ModuleUnloaded UnpackMessageModuleUnloadedToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageMonitoringExceptionEvent(MonitoringExceptionEvent* pMonitoringExceptionEvent, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageMonitoringExceptionEvent(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageMonitoringExceptionEvent(_MonitoringExceptionEvent monitoringExceptionEvent, IMessageMemory2 memory, Int32& msgLen);
    public _MonitoringExceptionEvent UnpackMessageMonitoringExceptionEventToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _MonitoringExceptionEvent UnpackMessageMonitoringExceptionEventToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageNotifyPointFailure(DataPacket* pDataPacket, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageNotifyPointFailure(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageNotifyPointFailure(_DataPacket dataPacket, IMessageMemory2 memory, Int32& msgLen);
    public _DataPacket UnpackMessageNotifyPointFailureToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _DataPacket UnpackMessageNotifyPointFailureToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOpFailBitnessMismatch(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageOpFailBitnessMismatch(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOpFailCLRVersionMismatch(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageOpFailCLRVersionMismatch(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOpFailExcludedAppPool(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageOpFailExcludedAppPool(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOpFailNoLoggerStarted(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageOpFailNoLoggerStarted(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOpFailNoTestCoverageStream(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageOpFailNoTestCoverageStream(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOpSucceeded(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageOpSucceeded(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageProcessDestroyed(ProcessDestroyed* pProcessDestroyed, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageProcessDestroyed(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageProcessDestroyed(_ProcessDestroyed processDestroyed, IMessageMemory2 memory, Int32& msgLen);
    public _ProcessDestroyed UnpackMessageProcessDestroyedToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ProcessDestroyed UnpackMessageProcessDestroyedToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageRequestCoverageData(CoverageDataRequest* pCoverageDataRequest, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageRequestCoverageData(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageRequestCoverageData(_CoverageDataRequest coverageDataRequest, IMessageMemory2 memory, Int32& msgLen);
    public _CoverageDataRequest UnpackMessageRequestCoverageDataToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CoverageDataRequest UnpackMessageRequestCoverageDataToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageRequestLogCopy(LogCopyRequest* pLogCopyRequest, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageRequestLogCopy(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageRequestLogCopy(_LogCopyRequest logCopyRequest, IMessageMemory2 memory, Int32& msgLen);
    public _LogCopyRequest UnpackMessageRequestLogCopyToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _LogCopyRequest UnpackMessageRequestLogCopyToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageRequestLogger(RequestLogger* pRequestLogger, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageRequestLogger(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageRequestLogger(_RequestLogger requestLogger, IMessageMemory2 memory, Int32& msgLen);
    public _RequestLogger UnpackMessageRequestLoggerToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _RequestLogger UnpackMessageRequestLoggerToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageRequestLoggerInfo(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageRequestLoggerInfo(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageResumeClient(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageResumeClient(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageServerFault(FaultInfo* pFaultInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageServerFault(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageServerFault(_FaultInfo faultInfo, IMessageMemory2 memory, Int32& msgLen);
    public _FaultInfo UnpackMessageServerFaultToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _FaultInfo UnpackMessageServerFaultToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageStreamHandleList(StreamHandleList* pStreamHandleList, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageStreamHandleList(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageStreamHandleList(_StreamHandleList streamHandleList, IMessageMemory2 memory, Int32& msgLen);
    public _StreamHandleList UnpackMessageStreamHandleListToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _StreamHandleList UnpackMessageStreamHandleListToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSystemInfo(SystemInfo* pSystemInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageSystemInfo(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSystemInfo(_SystemInfo systemInfo, IMessageMemory2 memory, Int32& msgLen);
    public _SystemInfo UnpackMessageSystemInfoToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _SystemInfo UnpackMessageSystemInfoToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestEvent(DataPacket* pDataPacket, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestEvent(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestEvent(_DataPacket dataPacket, IMessageMemory2 memory, Int32& msgLen);
    public _DataPacket UnpackMessageTestEventToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _DataPacket UnpackMessageTestEventToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestIndexResponse(TestIndexResponse* pTestIndexResponse, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestIndexResponse(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestIndexResponse(_TestIndexResponse testIndexResponse, IMessageMemory2 memory, Int32& msgLen);
    public _TestIndexResponse UnpackMessageTestIndexResponseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TestIndexResponse UnpackMessageTestIndexResponseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestMadeWebRequest(TestMadeWebRequest* pTestMadeWebRequest, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestMadeWebRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestMadeWebRequest(_TestMadeWebRequest testMadeWebRequest, IMessageMemory2 memory, Int32& msgLen);
    public _TestMadeWebRequest UnpackMessageTestMadeWebRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TestMadeWebRequest UnpackMessageTestMadeWebRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageThreadCreated(ThreadCreated* pThreadCreated, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageThreadCreated(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageThreadCreated(_ThreadCreated threadCreated, IMessageMemory2 memory, Int32& msgLen);
    public _ThreadCreated UnpackMessageThreadCreatedToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ThreadCreated UnpackMessageThreadCreatedToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageThreadDestroyed(ThreadDestroyed* pThreadDestroyed, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageThreadDestroyed(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageThreadDestroyed(_ThreadDestroyed threadDestroyed, IMessageMemory2 memory, Int32& msgLen);
    public _ThreadDestroyed UnpackMessageThreadDestroyedToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ThreadDestroyed UnpackMessageThreadDestroyedToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageThreadNameChanged(ThreadNameChanged* pThreadNameChanged, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageThreadNameChanged(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageThreadNameChanged(_ThreadNameChanged threadNameChanged, IMessageMemory2 memory, Int32& msgLen);
    public _ThreadNameChanged UnpackMessageThreadNameChangedToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ThreadNameChanged UnpackMessageThreadNameChangedToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageThreadStreamsRequest(ThreadID* pThreadID, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageThreadStreamsRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageThreadStreamsRequest(_ThreadID threadID, IMessageMemory2 memory, Int32& msgLen);
    public _ThreadID UnpackMessageThreadStreamsRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ThreadID UnpackMessageThreadStreamsRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWorkerProcessInfo(WorkerProcessInfo* pWorkerProcessInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWorkerProcessInfo(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWorkerProcessInfo(_WorkerProcessInfo workerProcessInfo, IMessageMemory2 memory, Int32& msgLen);
    public _WorkerProcessInfo UnpackMessageWorkerProcessInfoToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WorkerProcessInfo UnpackMessageWorkerProcessInfoToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageLogDataRequested(LogDataRequested* pLogDataRequested, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageLogDataRequested(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageLogDataRequested(_LogDataRequested logDataRequested, IMessageMemory2 memory, Int32& msgLen);
    public _LogDataRequested UnpackMessageLogDataRequestedToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _LogDataRequested UnpackMessageLogDataRequestedToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageOpFailLogFull(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageOpFailLogFull(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSharePointAreaInfo(SharePointArea* pSharePointArea, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageSharePointAreaInfo(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSharePointAreaInfo(_SharePointArea sharePointArea, IMessageMemory2 memory, Int32& msgLen);
    public _SharePointArea UnpackMessageSharePointAreaInfoToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _SharePointArea UnpackMessageSharePointAreaInfoToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSharePointCategoryInfo(SharePointCategory* pSharePointCategory, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageSharePointCategoryInfo(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSharePointCategoryInfo(_SharePointCategory sharePointCategory, IMessageMemory2 memory, Int32& msgLen);
    public _SharePointCategory UnpackMessageSharePointCategoryInfoToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _SharePointCategory UnpackMessageSharePointCategoryInfoToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageBuildInfo(BuildInfo* pBuildInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageBuildInfo(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageBuildInfo(_BuildInfo buildInfo, IMessageMemory2 memory, Int32& msgLen);
    public _BuildInfo UnpackMessageBuildInfoToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _BuildInfo UnpackMessageBuildInfoToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public static XmlSchema GenerateXmlSchema();
    private static XmlSchema get_MessagesXmlSchema();
    public static void WriteSchema(TextWriter xml);
    private static void OnValidationEvent(object sender, ValidationEventArgs e);
    private static XmlReader CreateXmlReader(TextReader xml, bool useSchemaValidation);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.SavedMetadataEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static SavedMetadataEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static SavedMetadataEventsMessagePacker Default { get; private set; }
    public SavedMetadataEventsMessagePacker(MessageInfo mi);
    private static SavedMetadataEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static SavedMetadataEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(SavedMetadataEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageIntelliTraceToken(IntelliTraceToken* pIntelliTraceToken, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageIntelliTraceToken(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageIntelliTraceToken(_IntelliTraceToken intelliTraceToken, IMessageMemory2 memory, Int32& msgLen);
    public _IntelliTraceToken UnpackMessageIntelliTraceTokenToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _IntelliTraceToken UnpackMessageIntelliTraceTokenToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageMetadata(SavedMetadata* pSavedMetadata, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageMetadata(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageMetadata(_SavedMetadata savedMetadata, IMessageMemory2 memory, Int32& msgLen);
    public _SavedMetadata UnpackMessageMetadataToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _SavedMetadata UnpackMessageMetadataToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTypeSpecMetadata(TypeSpecMetadata* pTypeSpecMetadata, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTypeSpecMetadata(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTypeSpecMetadata(_TypeSpecMetadata typeSpecMetadata, IMessageMemory2 memory, Int32& msgLen);
    public _TypeSpecMetadata UnpackMessageTypeSpecMetadataToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TypeSpecMetadata UnpackMessageTypeSpecMetadataToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.TestEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static TestEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static TestEventsMessagePacker Default { get; private set; }
    public TestEventsMessagePacker(MessageInfo mi);
    private static TestEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static TestEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(TestEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageSessionEnd(SessionContext* pSessionContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageSessionEnd(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSessionEnd(_SessionContext sessionContext, IMessageMemory2 memory, Int32& msgLen);
    public _SessionContext UnpackMessageSessionEndToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _SessionContext UnpackMessageSessionEndToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSessionPause(SessionContext* pSessionContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageSessionPause(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSessionPause(_SessionContext sessionContext, IMessageMemory2 memory, Int32& msgLen);
    public _SessionContext UnpackMessageSessionPauseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _SessionContext UnpackMessageSessionPauseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSessionResume(SessionContext* pSessionContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageSessionResume(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSessionResume(_SessionContext sessionContext, IMessageMemory2 memory, Int32& msgLen);
    public _SessionContext UnpackMessageSessionResumeToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _SessionContext UnpackMessageSessionResumeToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSessionStart(SessionContext* pSessionContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageSessionStart(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSessionStart(_SessionContext sessionContext, IMessageMemory2 memory, Int32& msgLen);
    public _SessionContext UnpackMessageSessionStartToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _SessionContext UnpackMessageSessionStartToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSessionTfsContext(TfsContext* pTfsContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageSessionTfsContext(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageSessionTfsContext(_TfsContext tfsContext, IMessageMemory2 memory, Int32& msgLen);
    public _TfsContext UnpackMessageSessionTfsContextToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TfsContext UnpackMessageSessionTfsContextToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestCaseEnd(TestCaseEndContext* pTestCaseEndContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestCaseEnd(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestCaseEnd(_TestCaseEndContext testCaseEndContext, IMessageMemory2 memory, Int32& msgLen);
    public _TestCaseEndContext UnpackMessageTestCaseEndToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TestCaseEndContext UnpackMessageTestCaseEndToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestCasePause(TestCaseContext* pTestCaseContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestCasePause(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestCasePause(_TestCaseContext testCaseContext, IMessageMemory2 memory, Int32& msgLen);
    public _TestCaseContext UnpackMessageTestCasePauseToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TestCaseContext UnpackMessageTestCasePauseToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestCaseReset(TestCaseContext* pTestCaseContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestCaseReset(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestCaseReset(_TestCaseContext testCaseContext, IMessageMemory2 memory, Int32& msgLen);
    public _TestCaseContext UnpackMessageTestCaseResetToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TestCaseContext UnpackMessageTestCaseResetToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestCaseResume(TestCaseContext* pTestCaseContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestCaseResume(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestCaseResume(_TestCaseContext testCaseContext, IMessageMemory2 memory, Int32& msgLen);
    public _TestCaseContext UnpackMessageTestCaseResumeToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TestCaseContext UnpackMessageTestCaseResumeToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestCaseStart(TestCaseContext* pTestCaseContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestCaseStart(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestCaseStart(_TestCaseContext testCaseContext, IMessageMemory2 memory, Int32& msgLen);
    public _TestCaseContext UnpackMessageTestCaseStartToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TestCaseContext UnpackMessageTestCaseStartToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestStepEnd(TestStepContext* pTestStepContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestStepEnd(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestStepEnd(_TestStepContext testStepContext, IMessageMemory2 memory, Int32& msgLen);
    public _TestStepContext UnpackMessageTestStepEndToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TestStepContext UnpackMessageTestStepEndToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestStepStart(TestStepContext* pTestStepContext, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestStepStart(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestStepStart(_TestStepContext testStepContext, IMessageMemory2 memory, Int32& msgLen);
    public _TestStepContext UnpackMessageTestStepStartToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TestStepContext UnpackMessageTestStepStartToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.TestImpactDataEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static TestImpactDataEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static TestImpactDataEventsMessagePacker Default { get; private set; }
    public TestImpactDataEventsMessagePacker(MessageInfo mi);
    private static TestImpactDataEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static TestImpactDataEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(TestImpactDataEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageTestImpactDataFlushEvent(TestImpactDataFlushEvent* pTestImpactDataFlushEvent, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestImpactDataFlushEvent(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestImpactDataFlushEvent(_TestImpactDataFlushEvent testImpactDataFlushEvent, IMessageMemory2 memory, Int32& msgLen);
    public _TestImpactDataFlushEvent UnpackMessageTestImpactDataFlushEventToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TestImpactDataFlushEvent UnpackMessageTestImpactDataFlushEventToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.TestImpactEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static TestImpactEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static TestImpactEventsMessagePacker Default { get; private set; }
    public TestImpactEventsMessagePacker(MessageInfo mi);
    private static TestImpactEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static TestImpactEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(TestImpactEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageTestFlushEvent(TestFlushEvent* pTestFlushEvent, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTestFlushEvent(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTestFlushEvent(_TestFlushEvent testFlushEvent, IMessageMemory2 memory, Int32& msgLen);
    public _TestFlushEvent UnpackMessageTestFlushEventToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _TestFlushEvent UnpackMessageTestFlushEventToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.ThreadCheckpointEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static ThreadCheckpointEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static ThreadCheckpointEventsMessagePacker Default { get; private set; }
    public ThreadCheckpointEventsMessagePacker(MessageInfo mi);
    private static ThreadCheckpointEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static ThreadCheckpointEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(ThreadCheckpointEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageThreadCheckpoint(FullCheckpointData* pFullCheckpointData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageThreadCheckpoint(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageThreadCheckpoint(_FullCheckpointData fullCheckpointData, IMessageMemory2 memory, Int32& msgLen);
    public _FullCheckpointData UnpackMessageThreadCheckpointToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _FullCheckpointData UnpackMessageThreadCheckpointToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.TraceDebugEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static TraceDebugEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static TraceDebugEventsMessagePacker Default { get; private set; }
    public TraceDebugEventsMessagePacker(MessageInfo mi);
    private static TraceDebugEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static TraceDebugEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(TraceDebugEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageBlob(BlobData* pBlobData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageBlob(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageBlob(_BlobData blobData, IMessageMemory2 memory, Int32& msgLen);
    public _BlobData UnpackMessageBlobToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _BlobData UnpackMessageBlobToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite1(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite1(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite1(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite1ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite1ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite10(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite10(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite10(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite10ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite10ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite11(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite11(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite11(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite11ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite11ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite12(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite12(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite12(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite12ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite12ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite13(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite13(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite13(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite13ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite13ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite2(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite2(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite2(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite2ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite2ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite3(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite3(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite3(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite3ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite3ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite4(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite4(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite4(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite4ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite4ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite5(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite5(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite5(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite5ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite5ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite6(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite6(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite6(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite6ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite6ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite7(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite7(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite7(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite7ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite7ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite8(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite8(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite8(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite8ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite8ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite9(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCallSite9(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCallSite9(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageCallSite9ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageCallSite9ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCatch(CatchData* pCatchData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageCatch(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageCatch(_CatchData catchData, IMessageMemory2 memory, Int32& msgLen);
    public _CatchData UnpackMessageCatchToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CatchData UnpackMessageCatchToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageExceptionEvent(ExceptionEvent* pExceptionEvent, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageExceptionEvent(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageExceptionEvent(_ExceptionEvent exceptionEvent, IMessageMemory2 memory, Int32& msgLen);
    public _ExceptionEvent UnpackMessageExceptionEventToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ExceptionEvent UnpackMessageExceptionEventToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageExceptionExit(MethodTokenData* pMethodTokenData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageExceptionExit(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageExceptionExit(_MethodTokenData methodTokenData, IMessageMemory2 memory, Int32& msgLen);
    public _MethodTokenData UnpackMessageExceptionExitToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _MethodTokenData UnpackMessageExceptionExitToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageExceptionThrown(ExceptionData* pExceptionData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageExceptionThrown(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageExceptionThrown(_ExceptionData exceptionData, IMessageMemory2 memory, Int32& msgLen);
    public _ExceptionData UnpackMessageExceptionThrownToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ExceptionData UnpackMessageExceptionThrownToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFault(FaultData* pFaultData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageFault(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFault(_FaultData faultData, IMessageMemory2 memory, Int32& msgLen);
    public _FaultData UnpackMessageFaultToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _FaultData UnpackMessageFaultToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFilter(FilterData* pFilterData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageFilter(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFilter(_FilterData filterData, IMessageMemory2 memory, Int32& msgLen);
    public _FilterData UnpackMessageFilterToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _FilterData UnpackMessageFilterToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFinally(FinallyData* pFinallyData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageFinally(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFinally(_FinallyData finallyData, IMessageMemory2 memory, Int32& msgLen);
    public _FinallyData UnpackMessageFinallyToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _FinallyData UnpackMessageFinallyToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFunctionEnter(EnterData* pEnterData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageFunctionEnter(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFunctionEnter(_EnterData enterData, IMessageMemory2 memory, Int32& msgLen);
    public _EnterData UnpackMessageFunctionEnterToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _EnterData UnpackMessageFunctionEnterToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFunctionEnterNoParameters(MethodTokenData* pMethodTokenData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageFunctionEnterNoParameters(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFunctionEnterNoParameters(_MethodTokenData methodTokenData, IMessageMemory2 memory, Int32& msgLen);
    public _MethodTokenData UnpackMessageFunctionEnterNoParametersToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _MethodTokenData UnpackMessageFunctionEnterNoParametersToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFunctionExit(ExitData* pExitData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageFunctionExit(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFunctionExit(_ExitData exitData, IMessageMemory2 memory, Int32& msgLen);
    public _ExitData UnpackMessageFunctionExitToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _ExitData UnpackMessageFunctionExitToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFunctionLeaveNoParameters(MethodTokenData* pMethodTokenData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageFunctionLeaveNoParameters(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageFunctionLeaveNoParameters(_MethodTokenData methodTokenData, IMessageMemory2 memory, Int32& msgLen);
    public _MethodTokenData UnpackMessageFunctionLeaveNoParametersToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _MethodTokenData UnpackMessageFunctionLeaveNoParametersToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageNop(IMessageMemory2 memory, Int32& msgLen);
    public void UnpackMessageNop(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageString(StringData* pStringData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageString(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageString(_StringData stringData, IMessageMemory2 memory, Int32& msgLen);
    public _StringData UnpackMessageStringToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _StringData UnpackMessageStringToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTailCallSite13(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTailCallSite13(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTailCallSite13(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageTailCallSite13ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageTailCallSite13ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTailCallSite7(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTailCallSite7(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTailCallSite7(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageTailCallSite7ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageTailCallSite7ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTailCallSite5(CallSiteData* pCallSiteData, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageTailCallSite5(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageTailCallSite5(_CallSiteData callSiteData, IMessageMemory2 memory, Int32& msgLen);
    public _CallSiteData UnpackMessageTailCallSite5ToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _CallSiteData UnpackMessageTailCallSite5ToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.WebRequestEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static WebRequestEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static WebRequestEventsMessagePacker Default { get; private set; }
    public WebRequestEventsMessagePacker(MessageInfo mi);
    private static WebRequestEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static WebRequestEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(WebRequestEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageWebRequestBegin(WebRequestBegin* pWebRequestBegin, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWebRequestBegin(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebRequestBegin(_WebRequestBegin webRequestBegin, IMessageMemory2 memory, Int32& msgLen);
    public _WebRequestBegin UnpackMessageWebRequestBeginToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WebRequestBegin UnpackMessageWebRequestBeginToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebRequestEnd(WebRequestEnd* pWebRequestEnd, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWebRequestEnd(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebRequestEnd(_WebRequestEnd webRequestEnd, IMessageMemory2 memory, Int32& msgLen);
    public _WebRequestEnd UnpackMessageWebRequestEndToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WebRequestEnd UnpackMessageWebRequestEndToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.WebRequestTrackingEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static WebRequestTrackingEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static WebRequestTrackingEventsMessagePacker Default { get; private set; }
    public WebRequestTrackingEventsMessagePacker(MessageInfo mi);
    private static WebRequestTrackingEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static WebRequestTrackingEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(WebRequestTrackingEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageWebRequest(WebRequest* pWebRequest, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWebRequest(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebRequest(_WebRequest webRequest, IMessageMemory2 memory, Int32& msgLen);
    public _WebRequest UnpackMessageWebRequestToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WebRequest UnpackMessageWebRequestToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebRequestBegin(WebRequestBegin* pWebRequestBegin, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWebRequestBegin(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebRequestBegin(_WebRequestBegin webRequestBegin, IMessageMemory2 memory, Int32& msgLen);
    public _WebRequestBegin UnpackMessageWebRequestBeginToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WebRequestBegin UnpackMessageWebRequestBeginToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebRequestEnd(WebRequestEnd* pWebRequestEnd, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWebRequestEnd(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebRequestEnd(_WebRequestEnd webRequestEnd, IMessageMemory2 memory, Int32& msgLen);
    public _WebRequestEnd UnpackMessageWebRequestEndToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WebRequestEnd UnpackMessageWebRequestEndToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.WebSessionTrackingEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static WebSessionTrackingEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static WebSessionTrackingEventsMessagePacker Default { get; private set; }
    public WebSessionTrackingEventsMessagePacker(MessageInfo mi);
    private static WebSessionTrackingEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static WebSessionTrackingEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(WebSessionTrackingEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageWebSessionBegin(WebSessionBegin* pWebSessionBegin, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWebSessionBegin(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebSessionBegin(_WebSessionBegin webSessionBegin, IMessageMemory2 memory, Int32& msgLen);
    public _WebSessionBegin UnpackMessageWebSessionBeginToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WebSessionBegin UnpackMessageWebSessionBeginToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebSessionEnd(WebSessionEnd* pWebSessionEnd, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWebSessionEnd(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebSessionEnd(_WebSessionEnd webSessionEnd, IMessageMemory2 memory, Int32& msgLen);
    public _WebSessionEnd UnpackMessageWebSessionEndToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WebSessionEnd UnpackMessageWebSessionEndToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.WebSummaryTrackingEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static WebSummaryTrackingEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static WebSummaryTrackingEventsMessagePacker Default { get; private set; }
    public WebSummaryTrackingEventsMessagePacker(MessageInfo mi);
    private static WebSummaryTrackingEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static WebSummaryTrackingEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(WebSummaryTrackingEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageWebSummary(WebSummary* pWebSummary, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWebSummary(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebSummary(_WebSummary webSummary, IMessageMemory2 memory, Int32& msgLen);
    public _WebSummary UnpackMessageWebSummaryToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WebSummary UnpackMessageWebSummaryToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[DebuggerNonUserCodeAttribute]
[ComVisibleAttribute("False")]
[GeneratedCodeAttribute("MkMsgs", "17.0.0.0")]
internal class Microsoft.VisualStudio.TraceLog.WebThreadTrackingEventsMessagePacker : MessagePacker {
    [CompilerGeneratedAttribute]
private bool <SwapBytes>k__BackingField;
    private MessageInfo _msgInfo;
    private static MessageInfo s_msgInfo;
    [CompilerGeneratedAttribute]
private static WebThreadTrackingEventsMessagePacker <Default>k__BackingField;
    public bool SwapBytes { get; public set; }
    public MessageInfo MsgInfo { get; }
    public static WebThreadTrackingEventsMessagePacker Default { get; private set; }
    public WebThreadTrackingEventsMessagePacker(MessageInfo mi);
    private static WebThreadTrackingEventsMessagePacker();
    [CompilerGeneratedAttribute]
public bool get_SwapBytes();
    [CompilerGeneratedAttribute]
public void set_SwapBytes(bool value);
    public virtual MessageInfo get_MsgInfo();
    [CompilerGeneratedAttribute]
public static WebThreadTrackingEventsMessagePacker get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(WebThreadTrackingEventsMessagePacker value);
    public MessageID GetMessageID(Byte* pMsg);
    public MessageID GetMessageID(Byte[] msg);
    public MsgHandle PackMessageWebThreadAssociation(WebThreadAssociation* pWebThreadAssociation, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWebThreadAssociation(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebThreadAssociation(_WebThreadAssociation webThreadAssociation, IMessageMemory2 memory, Int32& msgLen);
    public _WebThreadAssociation UnpackMessageWebThreadAssociationToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WebThreadAssociation UnpackMessageWebThreadAssociationToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebThreadBegin(WebThreadInfo* pWebThreadInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWebThreadBegin(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebThreadBegin(_WebThreadInfo webThreadInfo, IMessageMemory2 memory, Int32& msgLen);
    public _WebThreadInfo UnpackMessageWebThreadBeginToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WebThreadInfo UnpackMessageWebThreadBeginToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebThreadEnd(WebThreadInfo* pWebThreadInfo, IMessageMemory2 memory, Int32& msgLen);
    public Handle UnpackMessageWebThreadEnd(Byte* pMsg, IMessageMemory2 messageMemory);
    public MsgHandle PackMessageWebThreadEnd(_WebThreadInfo webThreadInfo, IMessageMemory2 memory, Int32& msgLen);
    public _WebThreadInfo UnpackMessageWebThreadEndToClass(Byte* pMsg, IMessageMemory2 messageMemory);
    public _WebThreadInfo UnpackMessageWebThreadEndToClass(Byte[] msg, IMessageMemory2 messageMemory);
    public int CalcHeaderLength();
    public int CalcCompressedHeaderLength(Stream stream);
    public Byte[] ReadMessage(Stream stream);
    public void ReadMessageHeader(Stream stream, Int32& length, Int16& id);
    public int GetMessageLength(Byte[] msg);
    public int GetMessageLength(Byte* pMsg);
    public MsgHandle PackMessage(short msgID, Byte* pData, IMessageMemory2 memory, Int32& msgLen);
    public void PackMessage(short msgID, Byte* pData, IMessageMemory memory);
    public void DumpMessage(IMessagePartSink sink, Byte* pMsg);
    public void DumpMessage(IMessagePartSink sink, Byte[] msg);
    public virtual void MergeMessageInfo(MessageInfo targetMsgInfo);
    public void RestoreMessageInfo();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
