[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Microsoft.VisualStudio.ApplicationInsights.Channel.EventSourceWriter : object {
    private string instrumentationKey;
    private string providerName;
    private bool disposed;
    internal Guid ProviderId { get; }
    internal string ProviderName { get; }
    internal string InstrumentationKey { get; }
    internal EventSourceWriter(string instrumentationKey, bool developerMode);
    internal Guid get_ProviderId();
    internal string get_ProviderName();
    internal string get_InstrumentationKey();
    public sealed virtual void Dispose();
    internal void WriteTelemetry(ITelemetry telemetryItem);
    internal void WriteEvent(string eventName, TelemetryContext context, T data);
    private static string RemoveInvalidInstrumentationKeyChars(string input);
    private void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.FileBasedMutex : object {
    private string lockFile;
    private FileSystemWatcher watcher;
    private AutoResetEvent watcherEvent;
    private FileStream stream;
    private bool disposed;
    private static SemaphoreSlim inMemoryLock;
    private bool releaseInMemoryLock;
    public FileBasedMutex(string lockFile);
    private static FileBasedMutex();
    public bool AcquireMutex(CancellationToken token);
    public void ReleaseLock();
    public sealed virtual void Dispose();
    private bool InternalAcquireMutex(CancellationToken token);
    private void WatcherDeleted(object sender, FileSystemEventArgs e);
    [CompilerGeneratedAttribute]
private void <AcquireMutex>b__8_0();
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.FlushManager : object {
    private TelemetryBuffer telemetryBuffer;
    private AutoResetEvent flushWaitHandle;
    private StorageBase storage;
    private int disposeCount;
    private bool flushLoopEnabled;
    [CompilerGeneratedAttribute]
private TimeSpan <FlushDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <EndpointAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    internal TimeSpan FlushDelay { get; internal set; }
    internal Uri EndpointAddress { get; internal set; }
    private string ApiKey { get; }
    internal FlushManager(StorageBase storage, TelemetryBuffer telemetryBuffer, string apiKey, bool supportAutoFlush);
    internal FlushManager(StorageBase storage, TelemetryBuffer telemetryBuffer, bool supportAutoFlush);
    [CompilerGeneratedAttribute]
internal TimeSpan get_FlushDelay();
    [CompilerGeneratedAttribute]
internal void set_FlushDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
internal Uri get_EndpointAddress();
    [CompilerGeneratedAttribute]
internal void set_EndpointAddress(Uri value);
    [CompilerGeneratedAttribute]
private string get_ApiKey();
    public sealed virtual void Dispose();
    internal void Flush();
    private void FlushLoop();
    private void OnTelemetryBufferFull();
}
public class Microsoft.VisualStudio.ApplicationInsights.Channel.InMemoryChannel : object {
    private TelemetryBuffer buffer;
    private InMemoryTransmitter transmitter;
    private bool developerMode;
    private int bufferSize;
    public bool DeveloperMode { get; public set; }
    public TimeSpan SendingInterval { get; public set; }
    public string EndpointAddress { get; public set; }
    [ObsoleteAttribute("This value is now obsolete and will be removed in next release, use SendingInterval instead.")]
public double DataUploadIntervalInSeconds { get; public set; }
    public int MaxTelemetryBufferCapacity { get; public set; }
    internal InMemoryChannel(TelemetryBuffer telemetryBuffer, InMemoryTransmitter transmitter);
    public sealed virtual bool get_DeveloperMode();
    public sealed virtual void set_DeveloperMode(bool value);
    public TimeSpan get_SendingInterval();
    public void set_SendingInterval(TimeSpan value);
    public sealed virtual string get_EndpointAddress();
    public sealed virtual void set_EndpointAddress(string value);
    public double get_DataUploadIntervalInSeconds();
    public void set_DataUploadIntervalInSeconds(double value);
    public int get_MaxTelemetryBufferCapacity();
    public void set_MaxTelemetryBufferCapacity(int value);
    public sealed virtual void Send(ITelemetry item);
    public sealed virtual void Flush();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.InMemoryChannel/<FlushAndTransmitAsync>d__23")]
public sealed virtual Task FlushAndTransmitAsync(CancellationToken token);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.InMemoryTransmitter : object {
    private TelemetryBuffer buffer;
    private object sendingLockObj;
    private AutoResetEvent startRunnerEvent;
    private bool enabled;
    private int disposeCount;
    private TimeSpan sendingInterval;
    private Uri endpointAddress;
    internal Uri EndpointAddress { get; internal set; }
    internal TimeSpan SendingInterval { get; internal set; }
    internal InMemoryTransmitter(TelemetryBuffer buffer);
    internal Uri get_EndpointAddress();
    internal void set_EndpointAddress(Uri value);
    internal TimeSpan get_SendingInterval();
    internal void set_SendingInterval(TimeSpan value);
    public sealed virtual void Dispose();
    internal void Flush();
    private void Runner();
    private void OnBufferFull();
    private void DequeueAndSend();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.InMemoryTransmitter/<Send>d__19")]
private Task Send(IEnumerable`1<ITelemetry> telemetryItems);
    private void Dispose(bool disposing);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Channel.IProcessLock {
    public abstract virtual void Acquire(Action action, CancellationToken cancelToken);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Channel.IProcessLockFactory {
    public abstract virtual IProcessLock CreateLocker(string folderFullName, string prefix);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Channel.IStorageBuilder {
    public abstract virtual StorageBase Create(string persistenceFolderName);
}
public interface Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry {
    public DateTimeOffset Timestamp { get; public set; }
    public TelemetryContext Context { get; }
    public string Sequence { get; public set; }
    public abstract virtual DateTimeOffset get_Timestamp();
    public abstract virtual void set_Timestamp(DateTimeOffset value);
    public abstract virtual TelemetryContext get_Context();
    public abstract virtual string get_Sequence();
    public abstract virtual void set_Sequence(string value);
    public abstract virtual void Sanitize();
}
public interface Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetryChannel {
    public bool DeveloperMode { get; public set; }
    public string EndpointAddress { get; public set; }
    public abstract virtual bool get_DeveloperMode();
    public abstract virtual void set_DeveloperMode(bool value);
    public abstract virtual string get_EndpointAddress();
    public abstract virtual void set_EndpointAddress(string value);
    public abstract virtual void Send(ITelemetry item);
    public abstract virtual void Flush();
    public abstract virtual Task FlushAndTransmitAsync(CancellationToken token);
}
internal static class Microsoft.VisualStudio.ApplicationInsights.Channel.JsonSerializer : object {
    private static UTF8Encoding TransmissionEncoding;
    internal static string CompressionType { get; }
    private static JsonSerializer();
    internal static string get_CompressionType();
    internal static Byte[] Serialize(IEnumerable`1<ITelemetry> telemetryItems, bool compress);
    internal static Byte[] Serialize(ITelemetry telemetryItem, bool compress);
    internal static string SerializeAsString(IEnumerable`1<ITelemetry> telemetryItems);
    internal static string SerializeAsString(ITelemetry telemetry);
    private static void ConvertExceptionTree(Exception exception, ExceptionDetails parentExceptionDetails, List`1<ExceptionDetails> exceptions);
    private static void SerializeExceptions(IEnumerable`1<ExceptionDetails> exceptions, IJsonWriter writer);
    private static void SerializeStackFrame(StackFrame frame, IJsonWriter writer);
    private static Stream CreateCompressedStream(Stream stream);
    private static void SerializeTelemetryItem(ITelemetry telemetryItem, JsonWriter jsonWriter);
    private static void SeializeToStream(IEnumerable`1<ITelemetry> telemetryItems, TextWriter streamWriter);
    private static void SerializeEventTelemetry(EventTelemetry eventTelemetry, JsonWriter writer);
    private static void SerializeExceptionTelemetry(ExceptionTelemetry exceptionTelemetry, JsonWriter writer);
    private static void SerializeMetricTelemetry(MetricTelemetry metricTelemetry, JsonWriter writer);
    private static void SerializePageViewTelemetry(PageViewTelemetry pageViewTelemetry, JsonWriter writer);
    private static void SerializeRemoteDependencyTelemetry(RemoteDependencyTelemetry remoteDependencyTelemetry, JsonWriter writer);
    private static void SerializeRequestTelemetry(RequestTelemetry requestTelemetry, JsonWriter jsonWriter);
    private static void SerializeSessionStateTelemetry(SessionStateTelemetry sessionStateTelemetry, JsonWriter jsonWriter);
    private static void SerializeTraceTelemetry(TraceTelemetry traceTelemetry, JsonWriter writer);
    private static void SerializePerformanceCounter(PerformanceCounterTelemetry performanceCounter, JsonWriter writer);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.LinuxStorage : PersistentStorageBase {
    internal LinuxStorage(string uniqueFolderName);
    protected virtual DirectoryInfo GetApplicationFolder();
    protected virtual bool CanDelete(FileInfo fileInfo);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.LinuxStorageBuilder : object {
    public sealed virtual StorageBase Create(string persistenceFolderName);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.MacStorage : PersistentStorageBase {
    internal MacStorage(string uniqueFolderName);
    protected virtual DirectoryInfo GetApplicationFolder();
    protected virtual bool CanDelete(FileInfo fileInfo);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.MacStorageBuilder : object {
    public sealed virtual StorageBase Create(string persistenceFolderName);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.MonoProcessLock : object {
    private FileBasedMutex mutex;
    public MonoProcessLock(string name);
    public sealed virtual void Acquire(Action action, CancellationToken cancelToken);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.MonoProcessLockFactory : object {
    public sealed virtual IProcessLock CreateLocker(string folderFullName, string prefix);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.PersistenceChannel : object {
    internal TelemetryBuffer TelemetryBuffer;
    internal PersistenceTransmitter Transmitter;
    private FlushManager flushManager;
    private bool developerMode;
    private int disposeCount;
    private int telemetryBufferSize;
    private StorageBase storage;
    [CompilerGeneratedAttribute]
private double <StopUploadAfterIntervalInSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTransmissionBufferCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTransmissionSenderCapacity>k__BackingField;
    public string StorageUniqueFolder { get; }
    public bool DeveloperMode { get; public set; }
    public TimeSpan SendingInterval { get; public set; }
    public TimeSpan FlushInterval { get; public set; }
    public string EndpointAddress { get; public set; }
    public int MaxTelemetryBufferCapacity { get; public set; }
    public ulong MaxTransmissionStorageCapacity { get; public set; }
    public UInt32 MaxTransmissionStorageFilesCapacity { get; public set; }
    [ObsoleteAttribute("This value is now obsolete and will be removed in next release. Currently it does nothing.")]
public double StopUploadAfterIntervalInSeconds { get; public set; }
    [ObsoleteAttribute("This value is now obsolete and will be removed in next release, use FlushInterval instead.")]
public double DataUploadIntervalInSeconds { get; public set; }
    [ObsoleteAttribute("This value is now obsolete and will be removed in next release. Currently it does nothing.")]
public int MaxTransmissionBufferCapacity { get; public set; }
    [ObsoleteAttribute("This value is now obsolete and will be removed in next release, use the sendersCount parameter in the constructor instead.")]
public int MaxTransmissionSenderCapacity { get; public set; }
    public PersistenceChannel(StorageBase storage, IProcessLockFactory processLockFactory, string apiKey, int sendersCount);
    public string get_StorageUniqueFolder();
    public sealed virtual bool get_DeveloperMode();
    public sealed virtual void set_DeveloperMode(bool value);
    public TimeSpan get_SendingInterval();
    public void set_SendingInterval(TimeSpan value);
    public TimeSpan get_FlushInterval();
    public void set_FlushInterval(TimeSpan value);
    public sealed virtual string get_EndpointAddress();
    public sealed virtual void set_EndpointAddress(string value);
    public int get_MaxTelemetryBufferCapacity();
    public void set_MaxTelemetryBufferCapacity(int value);
    public ulong get_MaxTransmissionStorageCapacity();
    public void set_MaxTransmissionStorageCapacity(ulong value);
    public UInt32 get_MaxTransmissionStorageFilesCapacity();
    public void set_MaxTransmissionStorageFilesCapacity(UInt32 value);
    [CompilerGeneratedAttribute]
public double get_StopUploadAfterIntervalInSeconds();
    [CompilerGeneratedAttribute]
public void set_StopUploadAfterIntervalInSeconds(double value);
    public double get_DataUploadIntervalInSeconds();
    public void set_DataUploadIntervalInSeconds(double value);
    [CompilerGeneratedAttribute]
public int get_MaxTransmissionBufferCapacity();
    [CompilerGeneratedAttribute]
public void set_MaxTransmissionBufferCapacity(int value);
    [CompilerGeneratedAttribute]
public int get_MaxTransmissionSenderCapacity();
    [CompilerGeneratedAttribute]
public void set_MaxTransmissionSenderCapacity(int value);
    public sealed virtual void Dispose();
    public sealed virtual void Send(ITelemetry item);
    public sealed virtual void Flush();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistenceChannel/<FlushAndTransmitAsync>d__49")]
public sealed virtual Task FlushAndTransmitAsync(CancellationToken token);
    public sealed virtual void Initialize(TelemetryConfiguration configuration);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.PersistenceTransmitter : object {
    private IProcessLock locker;
    private ConcurrentBag`1<Sender> senders;
    private StorageBase storage;
    private CancellationTokenSource sendingCancellationTokenSource;
    private int disposeCount;
    private AutoResetEvent eventToKeepMutexThreadAlive;
    [CompilerGeneratedAttribute]
private TimeSpan <SendingInterval>k__BackingField;
    internal string StorageUniqueFolder { get; }
    internal TimeSpan SendingInterval { get; internal set; }
    internal PersistenceTransmitter(StorageBase storage, int sendersCount, bool createSenders);
    internal PersistenceTransmitter(StorageBase storage, int sendersCount, IProcessLockFactory processLockFactory, bool createSenders);
    internal string get_StorageUniqueFolder();
    [CompilerGeneratedAttribute]
internal TimeSpan get_SendingInterval();
    [CompilerGeneratedAttribute]
internal void set_SendingInterval(TimeSpan value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistenceTransmitter/<Flush>d__14")]
public Task Flush(CancellationToken token);
    public sealed virtual void Dispose();
    private void AcquireMutex(Action action);
    private void CreateSenders(int sendersCount);
    private void StopSenders();
}
internal abstract class Microsoft.VisualStudio.ApplicationInsights.Channel.PersistentStorageBase : StorageBase {
    private ConcurrentDictionary`2<string, string> filesToDelete;
    private object peekLockObj;
    private DirectoryInfo storageFolder;
    private int transmissionsDropped;
    private string storageFolderName;
    private bool storageFolderInitialized;
    private object storageFolderLock;
    internal string FolderName { get; }
    internal bool StorageFolderInitialized { get; internal set; }
    internal DirectoryInfo StorageFolder { get; }
    internal PersistentStorageBase(string uniqueFolderName);
    internal virtual string get_FolderName();
    internal bool get_StorageFolderInitialized();
    internal void set_StorageFolderInitialized(bool value);
    internal virtual DirectoryInfo get_StorageFolder();
    internal virtual IEnumerable`1<StorageTransmission> PeekAll(CancellationToken token);
    internal virtual StorageTransmission Peek();
    internal virtual void Delete(StorageTransmission item);
    private void TryRemoveFilesToDelete();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistentStorageBase/<EnqueueAsync>d__19")]
internal virtual Task EnqueueAsync(Transmission transmission);
    private StorageTransmission BuildTransmissionFromFile(FileInfo file);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistentStorageBase/<GetFilteredFiles>d__21")]
private IEnumerable`1<FileInfo> GetFilteredFiles();
    private string BuildFullFileNameWithoutExtension();
    private string BuildNewFullFileNameWithSameDate(string name);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistentStorageBase/<SaveTransmissionToFileAsync>d__24")]
private static Task SaveTransmissionToFileAsync(Transmission transmission, string fileFullName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistentStorageBase/<LoadTransmissionFromFileAsync>d__25")]
private static Task`1<StorageTransmission> LoadTransmissionFromFileAsync(FileInfo file);
    private static string GetApplicationIdentity();
    internal static string GetSHA256Hash(string input, string defaultValue);
    protected abstract virtual DirectoryInfo GetApplicationFolder();
    private bool IsStorageLimitsReached();
    private IEnumerable`1<FileInfo> GetFiles(string filter);
    private void DeleteObsoleteFiles();
    protected abstract virtual bool CanDelete(FileInfo fileInfo);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.ProcessLockException : Exception {
    [CompilerGeneratedAttribute]
private bool <IsRetryable>k__BackingField;
    public bool IsRetryable { get; }
    public ProcessLockException(string description, Exception innerException, bool isRetryable);
    [CompilerGeneratedAttribute]
public bool get_IsRetryable();
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.Sender : object {
    private static int TriggerCountStaleHashCheck;
    private static TimeSpan StaleHashPeriod;
    protected AutoResetEvent DelayHandler;
    private TimeSpan sendingIntervalOnNoData;
    private TimeSpan maxIntervalBetweenRetries;
    private AutoResetEvent stoppedHandler;
    private LinkedList`1<Tuple`2<DateTime, string>> listOfTransmissionHash;
    private Dictionary`2<string, LinkedListNode`1<Tuple`2<DateTime, string>>> setOfTransmissionHash;
    private object hashLock;
    private int checkStaleHashCount;
    private bool stopped;
    private TimeSpan drainingTimeout;
    private StorageBase storage;
    private int disposeCount;
    private PersistenceTransmitter transmitter;
    private TimeSpan SendingInterval { get; }
    internal Sender(StorageBase storage, PersistenceTransmitter transmitter, bool startSending);
    private static Sender();
    private TimeSpan get_SendingInterval();
    public sealed virtual void Dispose();
    internal Task StopAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.Sender/<FlushAll>d__20")]
internal Task FlushAll(CancellationToken token);
    protected void SendLoop();
    protected virtual bool Send(StorageTransmission transmission, TimeSpan& nextSendInterval);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.Sender/<SendAsync>d__23")]
private Task`1<Tuple`2<bool, TimeSpan>> SendAsync(StorageTransmission transmission, CancellationToken token, TimeSpan sendInterval);
    private void CleanupStaleTransmissionHash();
    private static void LogInterval(TimeSpan prevSendInterval, TimeSpan nextSendInterval);
    private static Nullable`1<int> GetStatusCode(WebException e);
    private static bool IsRetryable(Nullable`1<int> httpStatusCode, WebExceptionStatus webExceptionStatus);
    private TimeSpan CalculateNextInterval(Nullable`1<int> httpStatusCode, TimeSpan currentSendInterval, TimeSpan maxInterval);
    [CompilerGeneratedAttribute]
private void <StopAsync>b__19_0();
}
internal abstract class Microsoft.VisualStudio.ApplicationInsights.Channel.StorageBase : object {
    protected IDictionary`2<string, string> peekedTransmissions;
    [CompilerGeneratedAttribute]
private ulong <CapacityInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxFiles>k__BackingField;
    internal ulong CapacityInBytes { get; internal set; }
    internal UInt32 MaxFiles { get; internal set; }
    internal string FolderName { get; }
    internal DirectoryInfo StorageFolder { get; }
    [CompilerGeneratedAttribute]
internal ulong get_CapacityInBytes();
    [CompilerGeneratedAttribute]
internal void set_CapacityInBytes(ulong value);
    [CompilerGeneratedAttribute]
internal UInt32 get_MaxFiles();
    [CompilerGeneratedAttribute]
internal void set_MaxFiles(UInt32 value);
    internal abstract virtual string get_FolderName();
    internal abstract virtual DirectoryInfo get_StorageFolder();
    internal abstract virtual StorageTransmission Peek();
    internal abstract virtual IEnumerable`1<StorageTransmission> PeekAll(CancellationToken token);
    internal abstract virtual void Delete(StorageTransmission transmission);
    internal abstract virtual Task EnqueueAsync(Transmission transmission);
    protected void OnPeekedItemDisposed(string fileName);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.StorageTransmission : Transmission {
    private static int ConvertChunkSize;
    private static int BufferSize;
    internal Action`1<StorageTransmission> Disposing;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullFilePath>k__BackingField;
    internal string FileName { get; private set; }
    internal string FullFilePath { get; private set; }
    protected StorageTransmission(string fullPath, Uri address, Byte[] content, string contentType, string apiKey, string contentEncoding);
    [CompilerGeneratedAttribute]
internal string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
internal string get_FullFilePath();
    [CompilerGeneratedAttribute]
private void set_FullFilePath(string value);
    public sealed virtual void Dispose();
    public virtual string ToString();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.StorageTransmission/<CreateFromStreamAsync>d__14")]
internal static Task`1<StorageTransmission> CreateFromStreamAsync(Stream stream, string fileName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.StorageTransmission/<SaveAsync>d__15")]
internal static Task SaveAsync(Transmission transmission, Stream stream);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.StorageTransmission/<ReadHeaderAsync>d__16")]
private static Task`1<string> ReadHeaderAsync(TextReader reader, string headerName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.StorageTransmission/<ReadAddressAsync>d__17")]
private static Task`1<Uri> ReadAddressAsync(TextReader reader);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.StorageTransmission/<ReadContentAsync>d__18")]
private static Task`1<Byte[]> ReadContentAsync(TextReader reader);
    private void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.TelemetryBuffer : object {
    public Action OnFull;
    private static int DefaultCapacity;
    private object lockObj;
    private int capacity;
    private List`1<ITelemetry> items;
    public int Capacity { get; public set; }
    public int get_Capacity();
    public void set_Capacity(int value);
    public void Enqueue(ITelemetry item);
    public IEnumerable`1<ITelemetry> Dequeue();
}
public class Microsoft.VisualStudio.ApplicationInsights.Channel.Transmission : object {
    internal static string ContentTypeHeader;
    internal static string ContentEncodingHeader;
    internal static string EndPointAPIKeyPropertyName;
    private static string Key;
    private static HashAlgorithm Encrypter;
    private static object hashLock;
    private static TimeSpan DefaultTimeout;
    private int isSending;
    private string contentHash;
    internal string ApiKey;
    [CompilerGeneratedAttribute]
private Uri <EndpointAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    public Uri EndpointAddress { get; private set; }
    public Byte[] Content { get; private set; }
    public string ContentHash { get; }
    public string ContentType { get; private set; }
    public string ContentEncoding { get; private set; }
    public TimeSpan Timeout { get; private set; }
    public Transmission(Uri address, Byte[] content, string contentType, string contentEncoding, TimeSpan timeout);
    public Transmission(Uri address, Byte[] content, string contentType, string contentEncoding, string apiKey, TimeSpan timeout);
    private static Transmission();
    [CompilerGeneratedAttribute]
public Uri get_EndpointAddress();
    [CompilerGeneratedAttribute]
private void set_EndpointAddress(Uri value);
    [CompilerGeneratedAttribute]
public Byte[] get_Content();
    [CompilerGeneratedAttribute]
private void set_Content(Byte[] value);
    public string get_ContentHash();
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
private void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
private void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
private void set_Timeout(TimeSpan value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.Transmission/<SendAsync>d__35")]
public virtual Task SendAsync(CancellationToken token);
    private string GetNoResponseBodyFlag();
    public virtual string ToString();
    protected virtual WebRequest CreateRequest(Uri address);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.Transmission/<SendRequestAsync>d__39")]
private Task SendRequestAsync(WebRequest request);
    private static string HashContent(Byte[] content);
}
public class Microsoft.VisualStudio.ApplicationInsights.Channel.UniversalTelemetryChannel : object {
    private ConcurrentDictionary`2<string, EventSourceWriter> eventSourceWriters;
    private bool disposed;
    [CompilerGeneratedAttribute]
private bool <DeveloperMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointAddress>k__BackingField;
    public bool DeveloperMode { get; public set; }
    public string EndpointAddress { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DeveloperMode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DeveloperMode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EndpointAddress();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndpointAddress(string value);
    public static bool IsAvailable();
    public sealed virtual void Dispose();
    public sealed virtual void Send(ITelemetry item);
    public sealed virtual void Flush();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.UniversalTelemetryChannel/<FlushAndTransmitAsync>d__15")]
public sealed virtual Task FlushAndTransmitAsync(CancellationToken token);
    internal EventSourceWriter GetEventSourceWriter(string instrumentationKey);
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private EventSourceWriter <GetEventSourceWriter>b__16_0(string key);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.WindowsProcessLock : object {
    private Mutex mutex;
    private string mutexPath;
    public WindowsProcessLock(string name);
    public sealed virtual void Acquire(Action action, CancellationToken cancelToken);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.WindowsProcessLockFactory : object {
    public sealed virtual IProcessLock CreateLocker(string folderFullName, string prefix);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.WindowsStorage : PersistentStorageBase {
    private WindowsIdentity principal;
    internal WindowsStorage(string uniqueFolderName);
    protected virtual DirectoryInfo GetApplicationFolder();
    protected virtual bool CanDelete(FileInfo fileInfo);
    private static void CheckAccessPermissions(DirectoryInfo telemetryDirectory);
    private bool ContainsRights(FileSystemRights right, FileSystemAccessRule rule);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.WindowsStorageBuilder : object {
    public sealed virtual StorageBase Create(string persistenceFolderName);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Constants : object {
    internal static string TelemetryServiceEndpoint;
    internal static string TelemetryNamePrefix;
    internal static string DevModeTelemetryNamePrefix;
    internal static string TelemetryGroup;
    internal static string DevModeTelemetryGroup;
    internal static string EventSourceGroupTraitKey;
    internal static int MaxExceptionCountToSave;
    internal static string WebRequestContentType;
    internal static string AiasimovChannelName;
    internal static string AiVortexChannelName;
    internal static string CollectorChannelName;
    internal static string CollectorClientVersion;
    internal static string CollectorEndpoint;
    internal static string NewCollectorEndpoint;
    internal static string VortexEndPoint;
    internal static string CollectorNoResponseBodyDiagnosticsEnvVar;
    internal static bool InitialDefaultUseCollector;
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.EventTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal EventData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CommonSchemaVersion>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Name { get; public set; }
    public int CommonSchemaVersion { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public IDictionary`2<string, string> Properties { get; }
    public EventTelemetry(string name);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_CommonSchemaVersion();
    [CompilerGeneratedAttribute]
public void set_CommonSchemaVersion(int value);
    public IDictionary`2<string, double> get_Metrics();
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
public enum Microsoft.VisualStudio.ApplicationInsights.DataContracts.ExceptionHandledAt : Enum {
    public int value__;
    public static ExceptionHandledAt Unhandled;
    public static ExceptionHandledAt UserCode;
    public static ExceptionHandledAt Platform;
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.ExceptionTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal ExceptionData Data;
    private TelemetryContext context;
    private Exception exception;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public ExceptionHandledAt HandledAt { get; public set; }
    public Exception Exception { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public IDictionary`2<string, string> Properties { get; }
    public Nullable`1<SeverityLevel> SeverityLevel { get; public set; }
    internal IList`1<ExceptionDetails> Exceptions { get; }
    public ExceptionTelemetry(Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public ExceptionHandledAt get_HandledAt();
    public void set_HandledAt(ExceptionHandledAt value);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public IDictionary`2<string, double> get_Metrics();
    public sealed virtual IDictionary`2<string, string> get_Properties();
    public Nullable`1<SeverityLevel> get_SeverityLevel();
    public void set_SeverityLevel(Nullable`1<SeverityLevel> value);
    internal IList`1<ExceptionDetails> get_Exceptions();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
    private static void ConvertExceptionTree(Exception exception, ExceptionDetails parentExceptionDetails, List`1<ExceptionDetails> exceptions);
    private void UpdateExceptions(Exception exception);
    private ExceptionHandledAt ValidateExceptionHandledAt(string value);
}
public interface Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable {
    public abstract virtual void Serialize(IJsonWriter writer);
}
public interface Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonWriter {
    public abstract virtual void WriteStartArray();
    public abstract virtual void WriteStartObject();
    public abstract virtual void WriteEndArray();
    public abstract virtual void WriteEndObject();
    public abstract virtual void WriteComma();
    public abstract virtual void WriteProperty(string name, string value);
    public abstract virtual void WriteProperty(string name, Nullable`1<bool> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<int> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<double> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<TimeSpan> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<DateTimeOffset> value);
    public abstract virtual void WriteProperty(string name, IDictionary`2<string, double> values);
    public abstract virtual void WriteProperty(string name, IDictionary`2<string, string> values);
    public abstract virtual void WriteProperty(string name, IJsonSerializable value);
    public abstract virtual void WritePropertyName(string name);
    public abstract virtual void WriteRawValue(object value);
}
internal class Microsoft.VisualStudio.ApplicationInsights.DataContracts.InnerExceptionCountExceededException : Exception {
    public InnerExceptionCountExceededException(string message);
    public InnerExceptionCountExceededException(string message, Exception innerException);
    protected InnerExceptionCountExceededException(SerializationInfo info, StreamingContext context);
}
public interface Microsoft.VisualStudio.ApplicationInsights.DataContracts.ISupportProperties {
    public IDictionary`2<string, string> Properties { get; }
    public abstract virtual IDictionary`2<string, string> get_Properties();
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.MetricTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal MetricData Data;
    internal DataPoint Metric;
    private TelemetryContext context;
    private bool isAggregation;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Name { get; public set; }
    public double Value { get; public set; }
    public Nullable`1<int> Count { get; public set; }
    public Nullable`1<double> Min { get; public set; }
    public Nullable`1<double> Max { get; public set; }
    public Nullable`1<double> StandardDeviation { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public MetricTelemetry(string metricName, double metricValue);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Name();
    public void set_Name(string value);
    public double get_Value();
    public void set_Value(double value);
    public Nullable`1<int> get_Count();
    public void set_Count(Nullable`1<int> value);
    public Nullable`1<double> get_Min();
    public void set_Min(Nullable`1<double> value);
    public Nullable`1<double> get_Max();
    public void set_Max(Nullable`1<double> value);
    public Nullable`1<double> get_StandardDeviation();
    public void set_StandardDeviation(Nullable`1<double> value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
    private void UpdateKind();
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.PageViewTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal PageViewData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Name { get; public set; }
    public Uri Url { get; public set; }
    public TimeSpan Duration { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public IDictionary`2<string, string> Properties { get; }
    public PageViewTelemetry(string pageName);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Name();
    public void set_Name(string value);
    public Uri get_Url();
    public void set_Url(Uri value);
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    public IDictionary`2<string, double> get_Metrics();
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
[DebuggerDisplayAttribute("CategoryName={CategoryName}; CounterName={CounterName}; InstanceName={InstanceName}; Value={Value}; Timestamp={Timestamp}")]
internal class Microsoft.VisualStudio.ApplicationInsights.DataContracts.PerformanceCounterTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal PerformanceCounterData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public double Value { get; public set; }
    public string CategoryName { get; public set; }
    public string CounterName { get; public set; }
    public string InstanceName { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public PerformanceCounterTelemetry(string categoryName, string counterName, string instanceName, double value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public double get_Value();
    public void set_Value(double value);
    public string get_CategoryName();
    public void set_CategoryName(string value);
    public string get_CounterName();
    public void set_CounterName(string value);
    public string get_InstanceName();
    public void set_InstanceName(string value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
[DebuggerDisplayAttribute("Value={Value}; Name={Name}; Count={Count}; Success={Success}; Async={Async}; Timestamp={Timestamp}")]
internal class Microsoft.VisualStudio.ApplicationInsights.DataContracts.RemoteDependencyTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal RemoteDependencyData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Name { get; public set; }
    public string CommandName { get; public set; }
    public DependencyKind DependencyKind { get; public set; }
    public double Value { get; public set; }
    public Nullable`1<int> Count { get; public set; }
    public Nullable`1<bool> Success { get; public set; }
    public Nullable`1<bool> Async { get; public set; }
    public DependencySourceType DependencySource { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Name();
    public void set_Name(string value);
    public string get_CommandName();
    public void set_CommandName(string value);
    public DependencyKind get_DependencyKind();
    public void set_DependencyKind(DependencyKind value);
    public double get_Value();
    public void set_Value(double value);
    public Nullable`1<int> get_Count();
    public void set_Count(Nullable`1<int> value);
    public Nullable`1<bool> get_Success();
    public void set_Success(Nullable`1<bool> value);
    public Nullable`1<bool> get_Async();
    public void set_Async(Nullable`1<bool> value);
    public DependencySourceType get_DependencySource();
    public void set_DependencySource(DependencySourceType value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.RequestTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal RequestData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Id { get; public set; }
    public string Name { get; public set; }
    public string ResponseCode { get; public set; }
    public bool Success { get; public set; }
    public TimeSpan Duration { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public Uri Url { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public string HttpMethod { get; public set; }
    public RequestTelemetry(string name, DateTimeOffset timestamp, TimeSpan duration, string responseCode, bool success);
    public sealed virtual DateTimeOffset get_Timestamp();
    public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Id();
    public void set_Id(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_ResponseCode();
    public void set_ResponseCode(string value);
    public bool get_Success();
    public void set_Success(bool value);
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    public Uri get_Url();
    public void set_Url(Uri value);
    public IDictionary`2<string, double> get_Metrics();
    public string get_HttpMethod();
    public void set_HttpMethod(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
    private DateTimeOffset ValidateDateTimeOffset(string value);
}
public enum Microsoft.VisualStudio.ApplicationInsights.DataContracts.SessionState : Enum {
    public int value__;
    public static SessionState Start;
    public static SessionState End;
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.SessionStateTelemetry : object {
    internal static string TelemetryName;
    internal SessionStateData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionState <State>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public TelemetryContext Context { get; }
    public string Sequence { get; public set; }
    public SessionState State { get; public set; }
    public SessionStateTelemetry(SessionState state);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    public sealed virtual TelemetryContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    [CompilerGeneratedAttribute]
public SessionState get_State();
    [CompilerGeneratedAttribute]
public void set_State(SessionState value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
public enum Microsoft.VisualStudio.ApplicationInsights.DataContracts.SeverityLevel : Enum {
    public int value__;
    public static SeverityLevel Verbose;
    public static SeverityLevel Information;
    public static SeverityLevel Warning;
    public static SeverityLevel Error;
    public static SeverityLevel Critical;
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.TelemetryContext : object {
    private IDictionary`2<string, string> properties;
    private IDictionary`2<string, string> tags;
    private string instrumentationKey;
    private ComponentContext component;
    private DeviceContext device;
    private SessionContext session;
    private UserContext user;
    private OperationContext operation;
    private LocationContext location;
    private InternalContext internalContext;
    public string InstrumentationKey { get; public set; }
    public ComponentContext Component { get; }
    public DeviceContext Device { get; }
    public SessionContext Session { get; }
    public UserContext User { get; }
    public OperationContext Operation { get; }
    public LocationContext Location { get; }
    public IDictionary`2<string, string> Properties { get; }
    internal InternalContext Internal { get; }
    internal IDictionary`2<string, string> Tags { get; }
    internal TelemetryContext(IDictionary`2<string, string> properties, IDictionary`2<string, string> tags);
    public string get_InstrumentationKey();
    public void set_InstrumentationKey(string value);
    public ComponentContext get_Component();
    public DeviceContext get_Device();
    public SessionContext get_Session();
    public UserContext get_User();
    public OperationContext get_Operation();
    public LocationContext get_Location();
    public IDictionary`2<string, string> get_Properties();
    internal InternalContext get_Internal();
    internal IDictionary`2<string, string> get_Tags();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
    internal void Initialize(TelemetryContext source, string instrumentationKey);
    [CompilerGeneratedAttribute]
private ComponentContext <get_Component>b__16_0();
    [CompilerGeneratedAttribute]
private DeviceContext <get_Device>b__18_0();
    [CompilerGeneratedAttribute]
private SessionContext <get_Session>b__20_0();
    [CompilerGeneratedAttribute]
private UserContext <get_User>b__22_0();
    [CompilerGeneratedAttribute]
private OperationContext <get_Operation>b__24_0();
    [CompilerGeneratedAttribute]
private LocationContext <get_Location>b__26_0();
    [CompilerGeneratedAttribute]
private InternalContext <get_Internal>b__30_0();
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.TraceTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal MessageData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Message { get; public set; }
    public Nullable`1<SeverityLevel> SeverityLevel { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public TraceTelemetry(string message);
    public TraceTelemetry(string message, SeverityLevel severityLevel);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Message();
    public void set_Message(string value);
    public Nullable`1<SeverityLevel> get_SeverityLevel();
    public void set_SeverityLevel(Nullable`1<SeverityLevel> value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.ApplicationLifecycle : object {
    private static object SyncRoot;
    private static ApplicationLifecycle service;
    private IApplicationLifecycle provider;
    [CompilerGeneratedAttribute]
private Action`2<object, object> Started;
    [CompilerGeneratedAttribute]
private EventHandler`1<ApplicationStoppingEventArgs> Stopping;
    public static IApplicationLifecycle Service { get; internal set; }
    unknown IApplicationLifecycle Provider {private set; }
    private static ApplicationLifecycle();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
    public static IApplicationLifecycle get_Service();
    internal static void set_Service(IApplicationLifecycle value);
    private void set_Provider(IApplicationLifecycle value);
    public static void SetProvider(IApplicationLifecycle provider);
    private void OnStarted(object sender, object eventArgs);
    private void OnStopping(object sender, ApplicationStoppingEventArgs eventArgs);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.ApplicationStoppingEventArgs : EventArgs {
    internal static ApplicationStoppingEventArgs Empty;
    private Func`2<Func`1<Task>, Task> asyncMethodRunner;
    public ApplicationStoppingEventArgs(Func`2<Func`1<Task>, Task> asyncMethodRunner);
    private static ApplicationStoppingEventArgs();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Extensibility.ApplicationStoppingEventArgs/<Run>d__3")]
public void Run(Func`1<Task> asyncMethod);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.BuildInfoConfigComponentVersionContextInitializer : object {
    private string version;
    public sealed virtual void Initialize(TelemetryContext context);
    protected virtual XElement LoadBuildInfoConfig();
    private string GetVersion();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.ComponentContextInitializer : object {
    public sealed virtual void Initialize(TelemetryContext context);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.ComponentContextReader : object {
    internal static string UnknownComponentVersion;
    private static IComponentContextReader instance;
    public static IComponentContextReader Instance { get; internal set; }
    public static IComponentContextReader get_Instance();
    internal static void set_Instance(IComponentContextReader value);
    public sealed virtual void Initialize();
    public sealed virtual string GetVersion();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.DeviceContextInitializer : object {
    public sealed virtual void Initialize(TelemetryContext context);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.DeviceContextReader : object {
    private object syncRoot;
    private string deviceId;
    private string operatingSystem;
    private string deviceManufacturer;
    private string deviceName;
    private Nullable`1<int> networkType;
    private FallbackDeviceContext cachedContext;
    internal static string ContextPersistentStorageFileName;
    private static IDeviceContextReader instance;
    public FallbackDeviceContext FallbackContext { get; }
    public static IDeviceContextReader Instance { get; internal set; }
    public virtual FallbackDeviceContext get_FallbackContext();
    public virtual void Initialize();
    public virtual string GetDeviceType();
    public virtual string GetDeviceUniqueId();
    public virtual Task`1<string> GetOperatingSystemAsync();
    public virtual string GetOemName();
    public virtual string GetDeviceModel();
    public sealed virtual int GetNetworkType();
    public sealed virtual Task`1<string> GetScreenResolutionAsync();
    private FallbackDeviceContext ReadSerializedContext();
    private string RunWmiQuery(string table, string property, string defaultValue);
    public static IDeviceContextReader get_Instance();
    internal static void set_Instance(IDeviceContextReader value);
    public virtual string GetHostSystemLocale();
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.FallbackDeviceContext : object {
    [CompilerGeneratedAttribute]
private string <DeviceUniqueId>k__BackingField;
    public string DeviceUniqueId { get; private set; }
    [CompilerGeneratedAttribute]
public string get_DeviceUniqueId();
    [CompilerGeneratedAttribute]
private void set_DeviceUniqueId(string value);
    public sealed virtual void Initialize();
    public sealed virtual void Serialize(XElement rootElement);
    public sealed virtual bool Deserialize(XElement rootElement);
}
public interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.IApplicationLifecycle {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.IComponentContextReader {
    public abstract virtual void Initialize();
    public abstract virtual string GetVersion();
}
public interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.IContextInitializer {
    public abstract virtual void Initialize(TelemetryContext context);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.IDeviceContextReader {
    public FallbackDeviceContext FallbackContext { get; }
    public abstract virtual FallbackDeviceContext get_FallbackContext();
    public abstract virtual void Initialize();
    public abstract virtual string GetDeviceType();
    public abstract virtual string GetDeviceUniqueId();
    public abstract virtual Task`1<string> GetOperatingSystemAsync();
    public abstract virtual string GetOemName();
    public abstract virtual string GetDeviceModel();
    public abstract virtual int GetNetworkType();
    public abstract virtual Task`1<string> GetScreenResolutionAsync();
    public abstract virtual string GetHostSystemLocale();
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.IFallbackContext {
    public abstract virtual void Initialize();
    public abstract virtual void Serialize(XElement rootElement);
    public abstract virtual bool Deserialize(XElement rootElement);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Clock : object {
    private static DateTimeOffset InitialTimeStamp;
    private static Stopwatch OffsetStopwatch;
    private static IClock instance;
    public static IClock Instance { get; protected set; }
    public DateTimeOffset Time { get; }
    private static Clock();
    public static IClock get_Instance();
    protected static void set_Instance(IClock value);
    public sealed virtual DateTimeOffset get_Time();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.ComponentContext : object {
    private IDictionary`2<string, string> tags;
    public string Version { get; public set; }
    internal ComponentContext(IDictionary`2<string, string> tags);
    public string get_Version();
    public void set_Version(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.CurrentThreadTaskScheduler : TaskScheduler {
    public static TaskScheduler Instance;
    public int MaximumConcurrencyLevel { get; }
    private static CurrentThreadTaskScheduler();
    public virtual int get_MaximumConcurrencyLevel();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.DeviceContext : object {
    private IDictionary`2<string, string> tags;
    public string Type { get; public set; }
    public string Id { get; public set; }
    public string OperatingSystem { get; public set; }
    public string OemName { get; public set; }
    public string Model { get; public set; }
    public string NetworkType { get; public set; }
    public string ScreenResolution { get; public set; }
    public string Language { get; public set; }
    public string RoleName { get; public set; }
    public string RoleInstance { get; public set; }
    internal DeviceContext(IDictionary`2<string, string> tags);
    public string get_Type();
    public void set_Type(string value);
    public string get_Id();
    public void set_Id(string value);
    public string get_OperatingSystem();
    public void set_OperatingSystem(string value);
    public string get_OemName();
    public void set_OemName(string value);
    public string get_Model();
    public void set_Model(string value);
    public string get_NetworkType();
    public void set_NetworkType(string value);
    public string get_ScreenResolution();
    public void set_ScreenResolution(string value);
    public string get_Language();
    public void set_Language(string value);
    public string get_RoleName();
    public void set_RoleName(string value);
    public string get_RoleInstance();
    public void set_RoleInstance(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.EventTelemetryExtensions : object {
    [ExtensionAttribute]
public static bool TryGetBoolean(IDictionary`2<string, string> properties, string propertyName, Boolean& result);
    [ExtensionAttribute]
public static bool IsMicrosoftInternal(EventTelemetry telemetry);
}
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.ExceptionConverter : object {
    public static int MaxParsedStackLength;
    internal static ExceptionDetails ConvertToExceptionDetails(Exception exception, ExceptionDetails parentExceptionDetails);
    private static Tuple`2<List`1<TOutput>, bool> SanitizeStackFrame(IList`1<TInput> inputList, Func`3<TInput, int, TOutput> converter, Func`2<TOutput, int> lengthGetter);
    private static StackFrame GetStackFrame(StackFrame stackFrame, int frameId);
    private static int GetStackFrameLength(StackFrame stackFrame);
}
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.ExceptionHandler : object {
    public static void Start(Func`1<Task> asyncMethod);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.AjaxCallData : PageViewData {
    [CompilerGeneratedAttribute]
private string <ajaxUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private double <requestSize>k__BackingField;
    [CompilerGeneratedAttribute]
private double <responseSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <timeToFirstByte>k__BackingField;
    [CompilerGeneratedAttribute]
private string <timeToLastByte>k__BackingField;
    [CompilerGeneratedAttribute]
private string <callbackDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <responseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <success>k__BackingField;
    public string ajaxUrl { get; public set; }
    public double requestSize { get; public set; }
    public double responseSize { get; public set; }
    public string timeToFirstByte { get; public set; }
    public string timeToLastByte { get; public set; }
    public string callbackDuration { get; public set; }
    public string responseCode { get; public set; }
    public bool success { get; public set; }
    protected AjaxCallData(string fullName, string name);
    [CompilerGeneratedAttribute]
public string get_ajaxUrl();
    [CompilerGeneratedAttribute]
public void set_ajaxUrl(string value);
    [CompilerGeneratedAttribute]
public double get_requestSize();
    [CompilerGeneratedAttribute]
public void set_requestSize(double value);
    [CompilerGeneratedAttribute]
public double get_responseSize();
    [CompilerGeneratedAttribute]
public void set_responseSize(double value);
    [CompilerGeneratedAttribute]
public string get_timeToFirstByte();
    [CompilerGeneratedAttribute]
public void set_timeToFirstByte(string value);
    [CompilerGeneratedAttribute]
public string get_timeToLastByte();
    [CompilerGeneratedAttribute]
public void set_timeToLastByte(string value);
    [CompilerGeneratedAttribute]
public string get_callbackDuration();
    [CompilerGeneratedAttribute]
public void set_callbackDuration(string value);
    [CompilerGeneratedAttribute]
public string get_responseCode();
    [CompilerGeneratedAttribute]
public void set_responseCode(string value);
    [CompilerGeneratedAttribute]
public bool get_success();
    [CompilerGeneratedAttribute]
public void set_success(bool value);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.ComponentContextData : object {
    private IDictionary`2<string, string> tags;
    public string Version { get; public set; }
    public string Build { get; public set; }
    internal ComponentContextData(IDictionary`2<string, string> tags);
    public string get_Version();
    public void set_Version(string value);
    public string get_Build();
    public void set_Build(string value);
    internal void SetDefaults(ComponentContextData source);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.ContextTagKeys : object {
    private static ContextTagKeys keys;
    [CompilerGeneratedAttribute]
private string <ApplicationVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceIp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceLocale>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceModel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceNetwork>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceOEMName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceOS>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceOSVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceRoleInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceRoleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceScreenResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceMachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationIp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationRootId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationSyntheticSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationIsSynthetic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionIsFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionIsNew>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAccountAcquisitionDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserStoreRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SampleRate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InternalSdkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InternalAgentVersion>k__BackingField;
    internal static ContextTagKeys Keys { get; }
    public string ApplicationVersion { get; public set; }
    public string ApplicationBuild { get; public set; }
    public string DeviceId { get; public set; }
    public string DeviceIp { get; public set; }
    public string DeviceLanguage { get; public set; }
    public string DeviceLocale { get; public set; }
    public string DeviceModel { get; public set; }
    public string DeviceNetwork { get; public set; }
    public string DeviceOEMName { get; public set; }
    public string DeviceOS { get; public set; }
    public string DeviceOSVersion { get; public set; }
    public string DeviceRoleInstance { get; public set; }
    public string DeviceRoleName { get; public set; }
    public string DeviceScreenResolution { get; public set; }
    public string DeviceType { get; public set; }
    public string DeviceMachineName { get; public set; }
    public string LocationIp { get; public set; }
    public string OperationId { get; public set; }
    public string OperationName { get; public set; }
    public string OperationParentId { get; public set; }
    public string OperationRootId { get; public set; }
    public string OperationSyntheticSource { get; public set; }
    public string OperationIsSynthetic { get; public set; }
    public string SessionId { get; public set; }
    public string SessionIsFirst { get; public set; }
    public string SessionIsNew { get; public set; }
    public string UserAccountAcquisitionDate { get; public set; }
    public string UserAccountId { get; public set; }
    public string UserAgent { get; public set; }
    public string UserId { get; public set; }
    public string UserStoreRegion { get; public set; }
    public string SampleRate { get; public set; }
    public string InternalSdkVersion { get; public set; }
    public string InternalAgentVersion { get; public set; }
    protected ContextTagKeys(string fullName, string name);
    internal static ContextTagKeys get_Keys();
    [CompilerGeneratedAttribute]
public string get_ApplicationVersion();
    [CompilerGeneratedAttribute]
public void set_ApplicationVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationBuild();
    [CompilerGeneratedAttribute]
public void set_ApplicationBuild(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceId();
    [CompilerGeneratedAttribute]
public void set_DeviceId(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceIp();
    [CompilerGeneratedAttribute]
public void set_DeviceIp(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceLanguage();
    [CompilerGeneratedAttribute]
public void set_DeviceLanguage(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceLocale();
    [CompilerGeneratedAttribute]
public void set_DeviceLocale(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceModel();
    [CompilerGeneratedAttribute]
public void set_DeviceModel(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceNetwork();
    [CompilerGeneratedAttribute]
public void set_DeviceNetwork(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceOEMName();
    [CompilerGeneratedAttribute]
public void set_DeviceOEMName(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceOS();
    [CompilerGeneratedAttribute]
public void set_DeviceOS(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceOSVersion();
    [CompilerGeneratedAttribute]
public void set_DeviceOSVersion(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceRoleInstance();
    [CompilerGeneratedAttribute]
public void set_DeviceRoleInstance(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceRoleName();
    [CompilerGeneratedAttribute]
public void set_DeviceRoleName(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceScreenResolution();
    [CompilerGeneratedAttribute]
public void set_DeviceScreenResolution(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceType();
    [CompilerGeneratedAttribute]
public void set_DeviceType(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceMachineName();
    [CompilerGeneratedAttribute]
public void set_DeviceMachineName(string value);
    [CompilerGeneratedAttribute]
public string get_LocationIp();
    [CompilerGeneratedAttribute]
public void set_LocationIp(string value);
    [CompilerGeneratedAttribute]
public string get_OperationId();
    [CompilerGeneratedAttribute]
public void set_OperationId(string value);
    [CompilerGeneratedAttribute]
public string get_OperationName();
    [CompilerGeneratedAttribute]
public void set_OperationName(string value);
    [CompilerGeneratedAttribute]
public string get_OperationParentId();
    [CompilerGeneratedAttribute]
public void set_OperationParentId(string value);
    [CompilerGeneratedAttribute]
public string get_OperationRootId();
    [CompilerGeneratedAttribute]
public void set_OperationRootId(string value);
    [CompilerGeneratedAttribute]
public string get_OperationSyntheticSource();
    [CompilerGeneratedAttribute]
public void set_OperationSyntheticSource(string value);
    [CompilerGeneratedAttribute]
public string get_OperationIsSynthetic();
    [CompilerGeneratedAttribute]
public void set_OperationIsSynthetic(string value);
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(string value);
    [CompilerGeneratedAttribute]
public string get_SessionIsFirst();
    [CompilerGeneratedAttribute]
public void set_SessionIsFirst(string value);
    [CompilerGeneratedAttribute]
public string get_SessionIsNew();
    [CompilerGeneratedAttribute]
public void set_SessionIsNew(string value);
    [CompilerGeneratedAttribute]
public string get_UserAccountAcquisitionDate();
    [CompilerGeneratedAttribute]
public void set_UserAccountAcquisitionDate(string value);
    [CompilerGeneratedAttribute]
public string get_UserAccountId();
    [CompilerGeneratedAttribute]
public void set_UserAccountId(string value);
    [CompilerGeneratedAttribute]
public string get_UserAgent();
    [CompilerGeneratedAttribute]
public void set_UserAgent(string value);
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(string value);
    [CompilerGeneratedAttribute]
public string get_UserStoreRegion();
    [CompilerGeneratedAttribute]
public void set_UserStoreRegion(string value);
    [CompilerGeneratedAttribute]
public string get_SampleRate();
    [CompilerGeneratedAttribute]
public void set_SampleRate(string value);
    [CompilerGeneratedAttribute]
public string get_InternalSdkVersion();
    [CompilerGeneratedAttribute]
public void set_InternalSdkVersion(string value);
    [CompilerGeneratedAttribute]
public string get_InternalAgentVersion();
    [CompilerGeneratedAttribute]
public void set_InternalAgentVersion(string value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.DataPoint : object {
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private DataPointType <kind>k__BackingField;
    [CompilerGeneratedAttribute]
private double <value>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <count>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <max>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <stdDev>k__BackingField;
    public string name { get; public set; }
    public DataPointType kind { get; public set; }
    public double value { get; public set; }
    public Nullable`1<int> count { get; public set; }
    public Nullable`1<double> min { get; public set; }
    public Nullable`1<double> max { get; public set; }
    public Nullable`1<double> stdDev { get; public set; }
    protected DataPoint(string fullName, string name);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public DataPointType get_kind();
    [CompilerGeneratedAttribute]
public void set_kind(DataPointType value);
    [CompilerGeneratedAttribute]
public double get_value();
    [CompilerGeneratedAttribute]
public void set_value(double value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_count();
    [CompilerGeneratedAttribute]
public void set_count(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_min();
    [CompilerGeneratedAttribute]
public void set_min(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_max();
    [CompilerGeneratedAttribute]
public void set_max(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_stdDev();
    [CompilerGeneratedAttribute]
public void set_stdDev(Nullable`1<double> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal enum Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.DataPointType : Enum {
    public int value__;
    public static DataPointType Measurement;
    public static DataPointType Aggregation;
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal enum Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.DependencyKind : Enum {
    public int value__;
    public static DependencyKind SQL;
    public static DependencyKind Http;
    public static DependencyKind Other;
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal enum Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.DependencySourceType : Enum {
    public int value__;
    public static DependencySourceType Undefined;
    public static DependencySourceType Aic;
    public static DependencySourceType Apmc;
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.DeviceContextData : object {
    private IDictionary`2<string, string> tags;
    public string Type { get; public set; }
    public string Id { get; public set; }
    public string OperatingSystem { get; public set; }
    public string OemName { get; public set; }
    public string Model { get; public set; }
    public Nullable`1<int> NetworkType { get; public set; }
    public string ScreenResolution { get; public set; }
    public string Language { get; public set; }
    public string RoleName { get; public set; }
    public string RoleInstance { get; public set; }
    public string Ip { get; public set; }
    public string MachineName { get; public set; }
    internal DeviceContextData(IDictionary`2<string, string> tags);
    public string get_Type();
    public void set_Type(string value);
    public string get_Id();
    public void set_Id(string value);
    public string get_OperatingSystem();
    public void set_OperatingSystem(string value);
    public string get_OemName();
    public void set_OemName(string value);
    public string get_Model();
    public void set_Model(string value);
    public Nullable`1<int> get_NetworkType();
    public void set_NetworkType(Nullable`1<int> value);
    public string get_ScreenResolution();
    public void set_ScreenResolution(string value);
    public string get_Language();
    public void set_Language(string value);
    public string get_RoleName();
    public void set_RoleName(string value);
    public string get_RoleInstance();
    public void set_RoleInstance(string value);
    public string get_Ip();
    public void set_Ip(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    internal void SetDefaults(DeviceContextData source);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.EventData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, double> <measurements>k__BackingField;
    public int ver { get; public set; }
    public string name { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected EventData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, double> get_measurements();
    [CompilerGeneratedAttribute]
public void set_measurements(IDictionary`2<string, double> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.ExceptionData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <handledAt>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ExceptionDetails> <exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SeverityLevel> <severityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <problemId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <crashThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, double> <measurements>k__BackingField;
    public int ver { get; public set; }
    public string handledAt { get; public set; }
    public IList`1<ExceptionDetails> exceptions { get; public set; }
    public Nullable`1<SeverityLevel> severityLevel { get; public set; }
    public string problemId { get; public set; }
    public int crashThreadId { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected ExceptionData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_handledAt();
    [CompilerGeneratedAttribute]
public void set_handledAt(string value);
    [CompilerGeneratedAttribute]
public IList`1<ExceptionDetails> get_exceptions();
    [CompilerGeneratedAttribute]
public void set_exceptions(IList`1<ExceptionDetails> value);
    [CompilerGeneratedAttribute]
public Nullable`1<SeverityLevel> get_severityLevel();
    [CompilerGeneratedAttribute]
public void set_severityLevel(Nullable`1<SeverityLevel> value);
    [CompilerGeneratedAttribute]
public string get_problemId();
    [CompilerGeneratedAttribute]
public void set_problemId(string value);
    [CompilerGeneratedAttribute]
public int get_crashThreadId();
    [CompilerGeneratedAttribute]
public void set_crashThreadId(int value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, double> get_measurements();
    [CompilerGeneratedAttribute]
public void set_measurements(IDictionary`2<string, double> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.ExceptionDetails : object {
    [CompilerGeneratedAttribute]
private int <id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <outerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <typeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <hasFullStack>k__BackingField;
    [CompilerGeneratedAttribute]
private string <stack>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<StackFrame> <parsedStack>k__BackingField;
    public int id { get; public set; }
    public int outerId { get; public set; }
    public string typeName { get; public set; }
    public string message { get; public set; }
    public bool hasFullStack { get; public set; }
    public string stack { get; public set; }
    public IList`1<StackFrame> parsedStack { get; public set; }
    protected ExceptionDetails(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_id();
    [CompilerGeneratedAttribute]
public void set_id(int value);
    [CompilerGeneratedAttribute]
public int get_outerId();
    [CompilerGeneratedAttribute]
public void set_outerId(int value);
    [CompilerGeneratedAttribute]
public string get_typeName();
    [CompilerGeneratedAttribute]
public void set_typeName(string value);
    [CompilerGeneratedAttribute]
public string get_message();
    [CompilerGeneratedAttribute]
public void set_message(string value);
    [CompilerGeneratedAttribute]
public bool get_hasFullStack();
    [CompilerGeneratedAttribute]
public void set_hasFullStack(bool value);
    [CompilerGeneratedAttribute]
public string get_stack();
    [CompilerGeneratedAttribute]
public void set_stack(string value);
    [CompilerGeneratedAttribute]
public IList`1<StackFrame> get_parsedStack();
    [CompilerGeneratedAttribute]
public void set_parsedStack(IList`1<StackFrame> value);
    internal static ExceptionDetails CreateWithoutStackInfo(Exception exception, ExceptionDetails parentExceptionDetails);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.InternalContextData : object {
    private IDictionary`2<string, string> tags;
    public string SdkVersion { get; public set; }
    public string AgentVersion { get; public set; }
    internal InternalContextData(IDictionary`2<string, string> tags);
    public string get_SdkVersion();
    public void set_SdkVersion(string value);
    public string get_AgentVersion();
    public void set_AgentVersion(string value);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.LocationContextData : object {
    private IDictionary`2<string, string> tags;
    public string Ip { get; public set; }
    internal LocationContextData(IDictionary`2<string, string> tags);
    public string get_Ip();
    public void set_Ip(string value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.MessageData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <message>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SeverityLevel> <severityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    public int ver { get; public set; }
    public string message { get; public set; }
    public Nullable`1<SeverityLevel> severityLevel { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    protected MessageData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_message();
    [CompilerGeneratedAttribute]
public void set_message(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<SeverityLevel> get_severityLevel();
    [CompilerGeneratedAttribute]
public void set_severityLevel(Nullable`1<SeverityLevel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.MetricData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DataPoint> <metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    public int ver { get; public set; }
    public IList`1<DataPoint> metrics { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    protected MetricData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public IList`1<DataPoint> get_metrics();
    [CompilerGeneratedAttribute]
public void set_metrics(IList`1<DataPoint> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.OperationContextData : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public string Name { get; public set; }
    public string ParentId { get; public set; }
    public string RootId { get; public set; }
    public string SyntheticSource { get; public set; }
    public Nullable`1<bool> IsSynthetic { get; public set; }
    internal OperationContextData(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_ParentId();
    public void set_ParentId(string value);
    public string get_RootId();
    public void set_RootId(string value);
    public string get_SyntheticSource();
    public void set_SyntheticSource(string value);
    public Nullable`1<bool> get_IsSynthetic();
    public void set_IsSynthetic(Nullable`1<bool> value);
    internal void SetDefaults(OperationContextData source);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.PageViewData : EventData {
    [CompilerGeneratedAttribute]
private string <url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <duration>k__BackingField;
    public string url { get; public set; }
    public string duration { get; public set; }
    protected PageViewData(string fullName, string name);
    [CompilerGeneratedAttribute]
public string get_url();
    [CompilerGeneratedAttribute]
public void set_url(string value);
    [CompilerGeneratedAttribute]
public string get_duration();
    [CompilerGeneratedAttribute]
public void set_duration(string value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.PageViewPerfData : PageViewData {
    [CompilerGeneratedAttribute]
private string <perfTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <networkConnect>k__BackingField;
    [CompilerGeneratedAttribute]
private string <sentRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <receivedResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private string <domProcessing>k__BackingField;
    public string perfTotal { get; public set; }
    public string networkConnect { get; public set; }
    public string sentRequest { get; public set; }
    public string receivedResponse { get; public set; }
    public string domProcessing { get; public set; }
    protected PageViewPerfData(string fullName, string name);
    [CompilerGeneratedAttribute]
public string get_perfTotal();
    [CompilerGeneratedAttribute]
public void set_perfTotal(string value);
    [CompilerGeneratedAttribute]
public string get_networkConnect();
    [CompilerGeneratedAttribute]
public void set_networkConnect(string value);
    [CompilerGeneratedAttribute]
public string get_sentRequest();
    [CompilerGeneratedAttribute]
public void set_sentRequest(string value);
    [CompilerGeneratedAttribute]
public string get_receivedResponse();
    [CompilerGeneratedAttribute]
public void set_receivedResponse(string value);
    [CompilerGeneratedAttribute]
public string get_domProcessing();
    [CompilerGeneratedAttribute]
public void set_domProcessing(string value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.PerformanceCounterData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <categoryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <counterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <instanceName>k__BackingField;
    [CompilerGeneratedAttribute]
private DataPointType <kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <count>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <max>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <stdDev>k__BackingField;
    [CompilerGeneratedAttribute]
private double <value>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    public int ver { get; public set; }
    public string categoryName { get; public set; }
    public string counterName { get; public set; }
    public string instanceName { get; public set; }
    public DataPointType kind { get; public set; }
    public Nullable`1<int> count { get; public set; }
    public Nullable`1<double> min { get; public set; }
    public Nullable`1<double> max { get; public set; }
    public Nullable`1<double> stdDev { get; public set; }
    public double value { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    protected PerformanceCounterData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_categoryName();
    [CompilerGeneratedAttribute]
public void set_categoryName(string value);
    [CompilerGeneratedAttribute]
public string get_counterName();
    [CompilerGeneratedAttribute]
public void set_counterName(string value);
    [CompilerGeneratedAttribute]
public string get_instanceName();
    [CompilerGeneratedAttribute]
public void set_instanceName(string value);
    [CompilerGeneratedAttribute]
public DataPointType get_kind();
    [CompilerGeneratedAttribute]
public void set_kind(DataPointType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_count();
    [CompilerGeneratedAttribute]
public void set_count(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_min();
    [CompilerGeneratedAttribute]
public void set_min(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_max();
    [CompilerGeneratedAttribute]
public void set_max(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_stdDev();
    [CompilerGeneratedAttribute]
public void set_stdDev(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public double get_value();
    [CompilerGeneratedAttribute]
public void set_value(double value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.RemoteDependencyData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private DataPointType <kind>k__BackingField;
    [CompilerGeneratedAttribute]
private double <value>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <count>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <max>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <stdDev>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyKind <dependencyKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <success>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <async>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencySourceType <dependencySource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <commandName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <dependencyTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    public int ver { get; public set; }
    public string name { get; public set; }
    public DataPointType kind { get; public set; }
    public double value { get; public set; }
    public Nullable`1<int> count { get; public set; }
    public Nullable`1<double> min { get; public set; }
    public Nullable`1<double> max { get; public set; }
    public Nullable`1<double> stdDev { get; public set; }
    public DependencyKind dependencyKind { get; public set; }
    public Nullable`1<bool> success { get; public set; }
    public Nullable`1<bool> async { get; public set; }
    public DependencySourceType dependencySource { get; public set; }
    public string commandName { get; public set; }
    public string dependencyTypeName { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    protected RemoteDependencyData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public DataPointType get_kind();
    [CompilerGeneratedAttribute]
public void set_kind(DataPointType value);
    [CompilerGeneratedAttribute]
public double get_value();
    [CompilerGeneratedAttribute]
public void set_value(double value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_count();
    [CompilerGeneratedAttribute]
public void set_count(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_min();
    [CompilerGeneratedAttribute]
public void set_min(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_max();
    [CompilerGeneratedAttribute]
public void set_max(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_stdDev();
    [CompilerGeneratedAttribute]
public void set_stdDev(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public DependencyKind get_dependencyKind();
    [CompilerGeneratedAttribute]
public void set_dependencyKind(DependencyKind value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_success();
    [CompilerGeneratedAttribute]
public void set_success(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_async();
    [CompilerGeneratedAttribute]
public void set_async(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public DependencySourceType get_dependencySource();
    [CompilerGeneratedAttribute]
public void set_dependencySource(DependencySourceType value);
    [CompilerGeneratedAttribute]
public string get_commandName();
    [CompilerGeneratedAttribute]
public void set_commandName(string value);
    [CompilerGeneratedAttribute]
public string get_dependencyTypeName();
    [CompilerGeneratedAttribute]
public void set_dependencyTypeName(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.RequestData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <startTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <responseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <success>k__BackingField;
    [CompilerGeneratedAttribute]
private string <httpMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <url>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, double> <measurements>k__BackingField;
    public int ver { get; public set; }
    public string id { get; public set; }
    public string name { get; public set; }
    public string startTime { get; public set; }
    public string duration { get; public set; }
    public string responseCode { get; public set; }
    public bool success { get; public set; }
    public string httpMethod { get; public set; }
    public string url { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected RequestData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_id();
    [CompilerGeneratedAttribute]
public void set_id(string value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public string get_startTime();
    [CompilerGeneratedAttribute]
public void set_startTime(string value);
    [CompilerGeneratedAttribute]
public string get_duration();
    [CompilerGeneratedAttribute]
public void set_duration(string value);
    [CompilerGeneratedAttribute]
public string get_responseCode();
    [CompilerGeneratedAttribute]
public void set_responseCode(string value);
    [CompilerGeneratedAttribute]
public bool get_success();
    [CompilerGeneratedAttribute]
public void set_success(bool value);
    [CompilerGeneratedAttribute]
public string get_httpMethod();
    [CompilerGeneratedAttribute]
public void set_httpMethod(string value);
    [CompilerGeneratedAttribute]
public string get_url();
    [CompilerGeneratedAttribute]
public void set_url(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, double> get_measurements();
    [CompilerGeneratedAttribute]
public void set_measurements(IDictionary`2<string, double> value);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.SessionContextData : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public Nullable`1<bool> IsFirst { get; public set; }
    public Nullable`1<bool> IsNewSession { get; public set; }
    internal SessionContextData(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public Nullable`1<bool> get_IsFirst();
    public void set_IsFirst(Nullable`1<bool> value);
    public Nullable`1<bool> get_IsNewSession();
    public void set_IsNewSession(Nullable`1<bool> value);
    internal void SetDefaults(SessionContextData source);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal enum Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.SessionState : Enum {
    public int value__;
    public static SessionState Start;
    public static SessionState End;
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.SessionStateData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionState <state>k__BackingField;
    public int ver { get; public set; }
    public SessionState state { get; public set; }
    protected SessionStateData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public SessionState get_state();
    [CompilerGeneratedAttribute]
public void set_state(SessionState value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal enum Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.SeverityLevel : Enum {
    public int value__;
    public static SeverityLevel Verbose;
    public static SeverityLevel Information;
    public static SeverityLevel Warning;
    public static SeverityLevel Error;
    public static SeverityLevel Critical;
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.StackFrame : object {
    [CompilerGeneratedAttribute]
private int <level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <fileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <line>k__BackingField;
    public int level { get; public set; }
    public string method { get; public set; }
    public string assembly { get; public set; }
    public string fileName { get; public set; }
    public int line { get; public set; }
    protected StackFrame(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_level();
    [CompilerGeneratedAttribute]
public void set_level(int value);
    [CompilerGeneratedAttribute]
public string get_method();
    [CompilerGeneratedAttribute]
public void set_method(string value);
    [CompilerGeneratedAttribute]
public string get_assembly();
    [CompilerGeneratedAttribute]
public void set_assembly(string value);
    [CompilerGeneratedAttribute]
public string get_fileName();
    [CompilerGeneratedAttribute]
public void set_fileName(string value);
    [CompilerGeneratedAttribute]
public int get_line();
    [CompilerGeneratedAttribute]
public void set_line(int value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.Tags : object {
    [ExtensionAttribute]
internal static Nullable`1<bool> GetTagBoolValueOrNull(IDictionary`2<string, string> tags, string tagKey);
    [ExtensionAttribute]
internal static Nullable`1<int> GetTagIntValueOrNull(IDictionary`2<string, string> tags, string tagKey);
    [ExtensionAttribute]
internal static Nullable`1<DateTimeOffset> GetTagDateTimeOffsetValueOrNull(IDictionary`2<string, string> tags, string tagKey);
    [ExtensionAttribute]
internal static void SetStringValueOrRemove(IDictionary`2<string, string> tags, string tagKey, string tagValue);
    [ExtensionAttribute]
internal static void SetDateTimeOffsetValueOrRemove(IDictionary`2<string, string> tags, string tagKey, Nullable`1<DateTimeOffset> tagValue);
    [ExtensionAttribute]
internal static void SetTagValueOrRemove(IDictionary`2<string, string> tags, string tagKey, T tagValue);
    [ExtensionAttribute]
internal static void InitializeTagValue(IDictionary`2<string, string> tags, string tagKey, T tagValue);
    [ExtensionAttribute]
internal static void InitializeTagDateTimeOffsetValue(IDictionary`2<string, string> tags, string tagKey, Nullable`1<DateTimeOffset> tagValue);
    [ExtensionAttribute]
internal static string GetTagValueOrNull(IDictionary`2<string, string> tags, string tagKey);
    [ExtensionAttribute]
private static void SetTagValueOrRemove(IDictionary`2<string, string> tags, string tagKey, string tagValue);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.UserContextData : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public string AccountId { get; public set; }
    public string UserAgent { get; public set; }
    public string StoreRegion { get; public set; }
    public Nullable`1<DateTimeOffset> AcquisitionDate { get; public set; }
    internal UserContextData(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public string get_AccountId();
    public void set_AccountId(string value);
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public string get_StoreRegion();
    public void set_StoreRegion(string value);
    public Nullable`1<DateTimeOffset> get_AcquisitionDate();
    public void set_AcquisitionDate(Nullable`1<DateTimeOffset> value);
    internal void SetDefaults(UserContextData source);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.FixedSizeQueue`1 : object {
    private int maxSize;
    private object queueLockObj;
    private Queue`1<T> queue;
    internal FixedSizeQueue`1(int maxSize);
    internal void Enqueue(T item);
    internal bool Contains(T item);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.IClock {
    public DateTimeOffset Time { get; }
    public abstract virtual DateTimeOffset get_Time();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.InternalContext : object {
    private IDictionary`2<string, string> tags;
    public string SdkVersion { get; public set; }
    public string AgentVersion { get; public set; }
    internal InternalContext(IDictionary`2<string, string> tags);
    public string get_SdkVersion();
    public void set_SdkVersion(string value);
    public string get_AgentVersion();
    public void set_AgentVersion(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.IPlatform {
    public abstract virtual IDictionary`2<string, object> GetApplicationSettings();
    public abstract virtual string ReadConfigurationXml();
    public abstract virtual ExceptionDetails GetExceptionDetails(Exception exception, ExceptionDetails parentExceptionDetails);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.IPlatformDispatcher {
    public abstract virtual Task RunAsync(Action action);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.IRandomNumberBatchGenerator {
    public abstract virtual void NextBatch(UInt64[] buffer, int index, int count);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.JsonWriter : object {
    private EmptyObjectDetector emptyObjectDetector;
    private TextWriter textWriter;
    private bool currentObjectHasProperties;
    internal JsonWriter(TextWriter textWriter);
    public sealed virtual void WriteStartArray();
    public sealed virtual void WriteStartObject();
    public sealed virtual void WriteEndArray();
    public sealed virtual void WriteEndObject();
    public sealed virtual void WriteComma();
    public sealed virtual void WriteRawValue(object value);
    public sealed virtual void WriteProperty(string name, string value);
    public sealed virtual void WriteProperty(string name, Nullable`1<bool> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<int> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<double> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<TimeSpan> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<DateTimeOffset> value);
    public sealed virtual void WriteProperty(string name, IJsonSerializable value);
    public sealed virtual void WriteProperty(string name, IDictionary`2<string, double> values);
    public sealed virtual void WriteProperty(string name, IDictionary`2<string, string> values);
    public sealed virtual void WritePropertyName(string name);
    protected bool IsNullOrEmpty(IJsonSerializable instance);
    protected void WriteString(string value);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.LocationContext : object {
    private IDictionary`2<string, string> tags;
    public string Ip { get; public set; }
    internal LocationContext(IDictionary`2<string, string> tags);
    public string get_Ip();
    public void set_Ip(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
    private bool IsIpV4(string ip);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.OperationContext : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public string Name { get; public set; }
    public string SyntheticSource { get; public set; }
    internal OperationContext(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_SyntheticSource();
    public void set_SyntheticSource(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Platform.PlatformApplicationLifecycle : object {
    private static IApplicationLifecycle provider;
    [CompilerGeneratedAttribute]
private Action`2<object, object> Started;
    [CompilerGeneratedAttribute]
private EventHandler`1<ApplicationStoppingEventArgs> Stopping;
    public static IApplicationLifecycle Provider { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
    public static IApplicationLifecycle get_Provider();
    public static void set_Provider(IApplicationLifecycle value);
    internal void Initialize();
    private static IApplicationLifecycle CreateDefaultProvider();
    private void OnStarted(object eventArgs);
    private void OnStopping(ApplicationStoppingEventArgs eventArgs);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(object sender, EventArgs e);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Platform.PlatformImplementation : object {
    public sealed virtual IDictionary`2<string, object> GetApplicationSettings();
    public sealed virtual string ReadConfigurationXml();
    public sealed virtual ExceptionDetails GetExceptionDetails(Exception exception, ExceptionDetails parentExceptionDetails);
}
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Platform.PlatformSingleton : object {
    private static IPlatform current;
    public static IPlatform Current { get; public set; }
    public static IPlatform get_Current();
    public static void set_Current(IPlatform value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Property : object {
    public static int MaxDictionaryNameLength;
    public static int MaxValueLength;
    public static int MaxNameLength;
    public static int MaxMessageLength;
    public static int MaxUrlLength;
    private static RegexOptions SanitizeOptions;
    private static Regex InvalidNameCharacters;
    private static Property();
    public static void Set(T& property, T value);
    public static void Initialize(Nullable`1& property, Nullable`1<T> value);
    public static void Initialize(String& property, string value);
    [ExtensionAttribute]
public static string SanitizeName(string name);
    [ExtensionAttribute]
public static string SanitizeValue(string value);
    [ExtensionAttribute]
public static string SanitizeMessage(string message);
    [ExtensionAttribute]
public static Uri SanitizeUri(Uri uri);
    [ExtensionAttribute]
public static void SanitizeProperties(IDictionary`2<string, string> dictionary);
    [ExtensionAttribute]
public static void SanitizeMeasurements(IDictionary`2<string, double> dictionary);
    private static string TrimAndTruncate(string value, int maxLength);
    private static string Truncate(string value, int maxLength);
    private static string SanitizeKey(string key, IDictionary`2<string, TValue> dictionary);
    private static string MakeKeyNonEmpty(string key);
    private static string MakeKeyUnique(string key, IDictionary`2<string, TValue> dictionary);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.SessionContext : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public Nullable`1<bool> IsFirst { get; public set; }
    internal SessionContext(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public Nullable`1<bool> get_IsFirst();
    public void set_IsFirst(Nullable`1<bool> value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.SeverityLevelExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<SeverityLevel> TranslateSeverityLevel(Nullable`1<SeverityLevel> sdkSeverityLevel);
    [ExtensionAttribute]
public static Nullable`1<SeverityLevel> TranslateSeverityLevel(Nullable`1<SeverityLevel> dataPlatformSeverityLevel);
}
internal abstract class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.SnapshottingCollection`2 : object {
    protected TCollection Collection;
    protected TCollection snapshot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    protected SnapshottingCollection`2(TCollection collection);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TItem item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TItem item);
    public sealed virtual void CopyTo(TItem[] array, int arrayIndex);
    public sealed virtual bool Remove(TItem item);
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected abstract virtual TCollection CreateSnapshot(TCollection collection);
    protected TCollection GetSnapshot();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.SnapshottingDictionary`2 : SnapshottingCollection`2<KeyValuePair`2<TKey, TValue>, IDictionary`2<TKey, TValue>> {
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    protected sealed virtual IDictionary`2<TKey, TValue> CreateSnapshot(IDictionary`2<TKey, TValue> collection);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.SnapshottingList`1 : SnapshottingCollection`2<T, IList`1<T>> {
    public T Item { get; public set; }
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    protected sealed virtual IList`1<T> CreateSnapshot(IList`1<T> collection);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TaskTimer : object {
    public static TimeSpan InfiniteTimeSpan;
    private TimeSpan delay;
    private CancellationTokenSource tokenSource;
    public TimeSpan Delay { get; public set; }
    public bool IsStarted { get; }
    private static TaskTimer();
    public TimeSpan get_Delay();
    public void set_Delay(TimeSpan value);
    public bool get_IsStarted();
    public void Start(Func`1<Task> elapsed);
    public void Cancel();
    public sealed virtual void Dispose();
    private static void CancelAndDispose(CancellationTokenSource tokenSource);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TelemetryConfigurationFactory : object {
    private static string AddElementName;
    private static string TypeAttributeName;
    private static MethodInfo LoadInstancesDefinition;
    private static XNamespace XmlNamespace;
    private static TelemetryConfigurationFactory instance;
    public static TelemetryConfigurationFactory Instance { get; public set; }
    private static TelemetryConfigurationFactory();
    public static TelemetryConfigurationFactory get_Instance();
    public static void set_Instance(TelemetryConfigurationFactory value);
    public virtual void Initialize(TelemetryConfiguration configuration);
    protected static object CreateInstance(Type interfaceType, string typeName);
    protected static void LoadFromXml(TelemetryConfiguration configuration, XDocument xml);
    protected static object LoadInstance(XElement definition, Type expectedType, object instance);
    protected static void LoadInstances(XElement definition, ICollection`1<T> instances);
    protected static void LoadProperties(XElement instanceDefinition, object instance);
    private static void InitializeComponents(TelemetryConfiguration configuration);
    private static void InitializeComponents(IEnumerable components, TelemetryConfiguration configuration);
    private static void InitializeComponent(object component, TelemetryConfiguration configuration);
    private static void LoadInstanceFromValue(XElement definition, Type expectedType, Object& instance);
    private static Type GetType(string typeName);
    private static Type GetWindowsRuntimeType(string typeName);
    private static Type GetManagedType(string typeName);
    private static bool GetCollectionElementType(Type type, Type& elementType);
    private static IEnumerable`1<XElement> GetPropertyDefinitions(XElement instanceDefinition);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TelemetryContextExtensions : object {
    [ExtensionAttribute]
public static InternalContext GetInternalContext(TelemetryContext context);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TelemetryHelper : object {
    [ExtensionAttribute]
public static void WriteEnvelopeProperties(ITelemetry telemetry, IJsonWriter json);
    private static void AddMsInternal(EventTelemetry telemetry, IJsonWriter json);
    [ExtensionAttribute]
public static void WriteTelemetryName(ITelemetry telemetry, IJsonWriter json, string telemetryName);
    private static string NormalizeInstrumentationKey(string instrumentationKey);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TelemetryItemExtensions : object {
    [ExtensionAttribute]
internal static string GetTelemetryFullName(ITelemetry item, string envelopeName);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Tracing.ApplicationNameProvider : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    private string GetApplicationName();
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Tracing.CoreEventSource : object {
    public static ICoreEventSource Log;
    private static CoreEventSource();
    private static ICoreEventSource CreateWindowsEventSource();
    private static ICoreEventSource CreateMonoEventSource();
}
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Tracing.EventSourceKeywords : object {
    public static long UserActionable;
    public static long Diagnostics;
    public static long VerboseFailure;
    public static long ErrorFailure;
    public static long ReservedUserKeywordBegin;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Tracing.Extensions : object {
    [ExtensionAttribute]
public static string ToInvariantString(Exception exception);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Tracing.ICoreEventSource {
    public abstract virtual void LogVerbose(string message, string appDomainName);
    public abstract virtual void BuildInfoConfigBrokenXmlError(string msg, string appDomainName);
    public abstract virtual void PopulateRequiredStringWithValue(string parameterName, string telemetryType, string appDomainName);
    public abstract virtual void RequestTelemetryIncorrectDuration(string appDomainName);
    public abstract virtual void LogError(string msg, string appDomainName);
    public abstract virtual void DiagnosticsEventThrottlingHasBeenStartedForTheEvent(int eventId, string appDomainName);
    public abstract virtual void DiagnosticsEventThrottlingHasBeenResetForTheEvent(int eventId, int executionCount, string appDomainName);
    public abstract virtual void DiagnoisticsEventThrottlingSchedulerTimerWasCreated(int intervalInMilliseconds, string appDomainName);
    public abstract virtual void DiagnoisticsEventThrottlingSchedulerTimerWasRemoved(string appDomainName);
    public abstract virtual void DiagnoisticsEventThrottlingSchedulerDisposeTimerFailure(string exception, string appDomainName);
    public abstract virtual void TrackingWasDisabled(string appDomainName);
    public abstract virtual void TrackingWasEnabled(string appDomainName);
    public abstract virtual void TelemetryClientConstructorWithNoTelemetryConfiguration(string appDomainName);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Tracing.MonoEventSource : object {
    public sealed virtual void BuildInfoConfigBrokenXmlError(string msg, string appDomainName);
    public sealed virtual void DiagnoisticsEventThrottlingSchedulerDisposeTimerFailure(string exception, string appDomainName);
    public sealed virtual void DiagnoisticsEventThrottlingSchedulerTimerWasCreated(int intervalInMilliseconds, string appDomainName);
    public sealed virtual void DiagnoisticsEventThrottlingSchedulerTimerWasRemoved(string appDomainName);
    public sealed virtual void DiagnosticsEventThrottlingHasBeenResetForTheEvent(int eventId, int executionCount, string appDomainName);
    public sealed virtual void DiagnosticsEventThrottlingHasBeenStartedForTheEvent(int eventId, string appDomainName);
    public sealed virtual void LogError(string msg, string appDomainName);
    public sealed virtual void LogVerbose(string message, string appDomainName);
    public sealed virtual void PopulateRequiredStringWithValue(string parameterName, string telemetryType, string appDomainName);
    public sealed virtual void RequestTelemetryIncorrectDuration(string appDomainName);
    public sealed virtual void TelemetryClientConstructorWithNoTelemetryConfiguration(string appDomainName);
    public sealed virtual void TrackingWasDisabled(string appDomainName);
    public sealed virtual void TrackingWasEnabled(string appDomainName);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Tracing.SpinWait : object {
    [ExtensionAttribute]
internal static void ExecuteSpinWaitLock(object syncRoot, Action action);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Tracing.ThreadResourceLock : object {
    [ThreadStaticAttribute]
private static object syncObject;
    public static bool IsResourceLocked { get; }
    public static bool get_IsResourceLocked();
    public sealed virtual void Dispose();
}
[EventSourceAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Tracing.WindowsCoreEventSource : EventSource {
    private ApplicationNameProvider nameProvider;
    public static WindowsCoreEventSource Log;
    private static WindowsCoreEventSource();
    [EventAttribute("10")]
public sealed virtual void LogVerbose(string msg, string appDomainName);
    [EventAttribute("20")]
public sealed virtual void DiagnosticsEventThrottlingHasBeenStartedForTheEvent(int eventId, string appDomainName);
    [EventAttribute("30")]
public sealed virtual void DiagnosticsEventThrottlingHasBeenResetForTheEvent(int eventId, int executionCount, string appDomainName);
    [EventAttribute("40")]
public sealed virtual void DiagnoisticsEventThrottlingSchedulerDisposeTimerFailure(string exception, string appDomainName);
    [EventAttribute("50")]
public sealed virtual void DiagnoisticsEventThrottlingSchedulerTimerWasCreated(int intervalInMilliseconds, string appDomainName);
    [EventAttribute("60")]
public sealed virtual void DiagnoisticsEventThrottlingSchedulerTimerWasRemoved(string appDomainName);
    [EventAttribute("70")]
public sealed virtual void TelemetryClientConstructorWithNoTelemetryConfiguration(string appDomainName);
    [EventAttribute("71")]
public sealed virtual void PopulateRequiredStringWithValue(string parameterName, string telemetryType, string appDomainName);
    [EventAttribute("72")]
public sealed virtual void RequestTelemetryIncorrectDuration(string appDomainName);
    [EventAttribute("80")]
public sealed virtual void TrackingWasDisabled(string appDomainName);
    [EventAttribute("81")]
public sealed virtual void TrackingWasEnabled(string appDomainName);
    [EventAttribute("90")]
public sealed virtual void LogError(string msg, string appDomainName);
    [EventAttribute("91")]
public sealed virtual void BuildInfoConfigBrokenXmlError(string msg, string appDomainName);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TypeExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetRuntimeMethods(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.UserContext : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public string AccountId { get; public set; }
    public string UserAgent { get; public set; }
    public Nullable`1<DateTimeOffset> AcquisitionDate { get; public set; }
    internal UserContext(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public string get_AccountId();
    public void set_AccountId(string value);
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public Nullable`1<DateTimeOffset> get_AcquisitionDate();
    public void set_AcquisitionDate(Nullable`1<DateTimeOffset> value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.WeakConcurrentRandom : object {
    private static WeakConcurrentRandom random;
    private int index;
    private int segmentCount;
    private int segmentSize;
    private int bitsToStoreRandomIndexWithinSegment;
    private int segmentIndexMask;
    private int randomIndexWithinSegmentMask;
    private int randomArrayIndexMask;
    private IRandomNumberBatchGenerator[] randomGemerators;
    private UInt64[] randomNumbers;
    public static WeakConcurrentRandom Instance { get; }
    public static WeakConcurrentRandom get_Instance();
    public void Initialize();
    public void Initialize(Func`2<ulong, IRandomNumberBatchGenerator> randomGeneratorFactory, int segmentIndexBits, int segmentBits);
    public ulong Next();
    private void RegenerateSegment(int newIndex);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.XorshiftRandomBatchGenerator : object {
    private static ulong Y;
    private static ulong Z;
    private static ulong W;
    private ulong lastX;
    private ulong lastY;
    private ulong lastZ;
    private ulong lastW;
    public XorshiftRandomBatchGenerator(ulong seed);
    public sealed virtual void NextBatch(UInt64[] buffer, int index, int count);
}
public interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.ISupportConfiguration {
    public abstract virtual void Initialize(TelemetryConfiguration configuration);
}
public interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.ITelemetryInitializer {
    public abstract virtual void Initialize(ITelemetry telemetry);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.SdkVersionPropertyContextInitializer : object {
    private static string SDKVersion;
    private string sdkVersion;
    public sealed virtual void Initialize(TelemetryContext context);
    private string GetAssemblyVersion();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.SequencePropertyInitializer : object {
    private string stablePrefix;
    private long currentNumber;
    public sealed virtual void Initialize(ITelemetry telemetry);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.TelemetryConfiguration : object {
    private static object syncRoot;
    private static TelemetryConfiguration active;
    private SnapshottingList`1<IContextInitializer> contextInitializers;
    private SnapshottingList`1<ITelemetryInitializer> telemetryInitializers;
    private SnapshottingList`1<object> telemetryModules;
    private string instrumentationKey;
    private bool disableTelemetry;
    [CompilerGeneratedAttribute]
private ITelemetryChannel <TelemetryChannel>k__BackingField;
    public static TelemetryConfiguration Active { get; internal set; }
    public string InstrumentationKey { get; public set; }
    public bool DisableTelemetry { get; public set; }
    public IList`1<IContextInitializer> ContextInitializers { get; }
    public IList`1<ITelemetryInitializer> TelemetryInitializers { get; }
    public IList`1<object> TelemetryModules { get; }
    public ITelemetryChannel TelemetryChannel { get; public set; }
    private static TelemetryConfiguration();
    public static TelemetryConfiguration get_Active();
    internal static void set_Active(TelemetryConfiguration value);
    public string get_InstrumentationKey();
    public void set_InstrumentationKey(string value);
    public bool get_DisableTelemetry();
    public void set_DisableTelemetry(bool value);
    public IList`1<IContextInitializer> get_ContextInitializers();
    public IList`1<ITelemetryInitializer> get_TelemetryInitializers();
    public IList`1<object> get_TelemetryModules();
    [CompilerGeneratedAttribute]
public ITelemetryChannel get_TelemetryChannel();
    [CompilerGeneratedAttribute]
public void set_TelemetryChannel(ITelemetryChannel value);
    public static TelemetryConfiguration CreateDefault();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.TimestampPropertyInitializer : object {
    public sealed virtual void Initialize(ITelemetry telemetry);
}
internal static class Microsoft.VisualStudio.ApplicationInsights.KeysConstants : object {
    internal static string VSCollectorApiKey;
    internal static string VSCodeCollectorApiKey;
    internal static string VSCollectorIKey;
    internal static string VSCodeCollectorIKey;
    internal static string VSAsimovIKey;
    internal static string VSAppInsightsIKey;
    private static KeysConstants();
}
public class Microsoft.VisualStudio.ApplicationInsights.TelemetryClient : object {
    private TelemetryConfiguration configuration;
    private TelemetryContext context;
    private ITelemetryChannel channel;
    public TelemetryContext Context { get; internal set; }
    public string InstrumentationKey { get; public set; }
    internal ITelemetryChannel Channel { get; internal set; }
    public TelemetryClient(TelemetryConfiguration configuration);
    public TelemetryContext get_Context();
    internal void set_Context(TelemetryContext value);
    public string get_InstrumentationKey();
    public void set_InstrumentationKey(string value);
    internal ITelemetryChannel get_Channel();
    internal void set_Channel(ITelemetryChannel value);
    public bool IsEnabled();
    public void TrackEvent(string eventName, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics);
    public void TrackEvent(EventTelemetry telemetry);
    public void TrackTrace(string message);
    public void TrackTrace(string message, SeverityLevel severityLevel);
    public void TrackTrace(string message, IDictionary`2<string, string> properties);
    public void TrackTrace(string message, SeverityLevel severityLevel, IDictionary`2<string, string> properties);
    public void TrackTrace(TraceTelemetry telemetry);
    public void TrackMetric(string name, double value, IDictionary`2<string, string> properties);
    public void TrackMetric(MetricTelemetry telemetry);
    public void TrackException(Exception exception, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics);
    public void TrackException(ExceptionTelemetry telemetry);
    [EditorBrowsableAttribute("1")]
public void Track(ITelemetry telemetry);
    public void TrackPageView(string name);
    public void TrackPageView(PageViewTelemetry telemetry);
    public void TrackRequest(string name, DateTimeOffset timestamp, TimeSpan duration, string responseCode, bool success);
    public void TrackRequest(RequestTelemetry request);
    public void Flush();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.TelemetryClient/<FlushAndTransmitAsync>d__32")]
public Task FlushAndTransmitAsync(CancellationToken token);
    private TelemetryContext CreateInitializedContext();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Utils : object {
    private static String[] RelativeFolderPath;
    private static Utils();
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
    public static void CopyDictionary(IDictionary`2<string, TValue> source, IDictionary`2<string, TValue> target);
    public static string PopulateRequiredStringValue(string value, string parameterName, string telemetryType);
    public static TimeSpan ValidateDuration(string value);
    public static TType ReadSerializedContext(string fileName);
}
internal class Microsoft.VisualStudio.Experimentation.ActiveFlightsData : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <Flights>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConfigData> <Configs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssignmentContext>k__BackingField;
    [JsonPropertyAttribute]
public IList`1<string> Flights { get; public set; }
    [JsonPropertyAttribute]
public IList`1<ConfigData> Configs { get; public set; }
    [JsonPropertyAttribute]
public string AssignmentContext { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_Flights();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Flights(IList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ConfigData> get_Configs();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configs(IList`1<ConfigData> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssignmentContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AssignmentContext(string value);
}
internal class Microsoft.VisualStudio.Experimentation.AFDFlightsProvider : CachedRemotePollerFlightsProviderBase`1<ActiveFlightsData> {
    private static int DefaultPollingIntervalInSecs;
    private static int DefaultRequestTimeout;
    private static string DefaultGetMethod;
    private static string DefaultContentType;
    private static string DefaultUrl;
    private static HttpRequestCachePolicy DefaultCachePolicy;
    internal static Regex RegExpression;
    private string flightsKey;
    private IExperimentationFilterProvider filterProvider;
    private IHttpWebRequestFactory httpWebRequestFactory;
    public AFDFlightsProvider(IKeyValueStorage keyValueStorage, string flightsKey, IFlightsStreamParser flightsStreamParser, IExperimentationFilterProvider filterProvider, IHttpWebRequestFactory httpWebRequestFactory);
    private static AFDFlightsProvider();
    protected virtual void InternalDispose();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.AFDFlightsProvider/<SendRemoteRequestInternalAsync>d__12")]
protected virtual Task`1<Stream> SendRemoteRequestInternalAsync();
    protected virtual string BuildFlightsKey();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Experimentation.AFDFlightsProvider/<GetAllFilters>d__14")]
private IEnumerable`1<KeyValuePair`2<string, string>> GetAllFilters();
    private static string ProcessFilterValue(string value);
    private void AddIfNotEmpty(List`1<string> parts, string v);
}
internal abstract class Microsoft.VisualStudio.Experimentation.CachedRemotePollerFlightsProviderBase`1 : TelemetryDisposableObject {
    private object lockObject;
    private Lazy`1<LocalFlightsProvider> cachedFlightsProvider;
    private IFlightsStreamParser flightsStreamParser;
    private Timer timer;
    private int timerInterval;
    private bool isStarted;
    private Task firstTaskRequest;
    private HashSet`1<FlightAllocation> flights;
    private IList`1<ConfigData> configs;
    [CompilerGeneratedAttribute]
private EventHandler`1<FlightsEventArgs> FlightsUpdated;
    public IEnumerable`1<FlightAllocation> Flights { get; private set; }
    public IEnumerable`1<ConfigData> Configs { get; private set; }
    public CachedRemotePollerFlightsProviderBase`1(IKeyValueStorage keyValueStorage, IFlightsStreamParser flightsStreamParser, int timerInterval);
    public sealed virtual IEnumerable`1<FlightAllocation> get_Flights();
    private void set_Flights(IEnumerable`1<FlightAllocation> value);
    public sealed virtual IEnumerable`1<ConfigData> get_Configs();
    private void set_Configs(IEnumerable`1<ConfigData> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    public sealed virtual void Start();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.CachedRemotePollerFlightsProviderBase`1/<WaitForReady>d__20")]
public sealed virtual Task WaitForReady(CancellationToken token);
    protected virtual void DisposeManagedResources();
    protected abstract virtual Task`1<Stream> SendRemoteRequestInternalAsync();
    protected abstract virtual string BuildFlightsKey();
    protected virtual void InternalDispose();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.CachedRemotePollerFlightsProviderBase`1/<SendRemoteRequestAsync>d__25")]
private Task SendRemoteRequestAsync();
    private void OnFlightsUpdated();
}
internal class Microsoft.VisualStudio.Experimentation.ConfigData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Parameters>k__BackingField;
    [JsonPropertyAttribute]
public string Id { get; public set; }
    [JsonPropertyAttribute]
public IDictionary`2<string, object> Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(IDictionary`2<string, object> value);
}
public class Microsoft.VisualStudio.Experimentation.DefaultExperimentationFilterProvider : object {
    internal static string Unknown;
    private TelemetrySession telemetrySession;
    private IProcessInformationProvider processInformation;
    public DefaultExperimentationFilterProvider(TelemetrySession telemetrySession);
    internal DefaultExperimentationFilterProvider(TelemetrySession telemetrySession, IProcessInformationProvider processInformation);
    public sealed virtual string GetFilterValue(Filters filter);
}
internal class Microsoft.VisualStudio.Experimentation.DefaultExperimentationOptinStatusReader : object {
    private TelemetrySession telemetrySession;
    private IRegistryTools registryTools;
    private Lazy`1<bool> isOptedIn;
    public bool IsOptedIn { get; }
    public DefaultExperimentationOptinStatusReader(TelemetrySession telemetrySession, IRegistryTools registryTools);
    public sealed virtual bool get_IsOptedIn();
    private bool GetIsOptedIn();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__3_0();
}
internal class Microsoft.VisualStudio.Experimentation.DefaultExperimentationTelemetry : object {
    private TelemetrySession telemetrySession;
    public DefaultExperimentationTelemetry(TelemetrySession telemetrySession);
    public sealed virtual void PostEvent(string name, IDictionary`2<string, string> properties);
    public sealed virtual void SetSharedProperty(string name, string value);
    public sealed virtual void PostFault(string eventName, string description);
    public sealed virtual void PostEvent(string name, IDictionary`2<string, object> properties);
    public sealed virtual void SetSharedProperty(string name, object value);
}
internal class Microsoft.VisualStudio.Experimentation.DisabledFlightsData : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <Flights>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConfigData> <Configs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssignmentContext>k__BackingField;
    [JsonPropertyAttribute]
public IList`1<string> Flights { get; public set; }
    [JsonPropertyAttribute]
public IList`1<ConfigData> Configs { get; public set; }
    [JsonPropertyAttribute]
public string AssignmentContext { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_Flights();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Flights(IList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ConfigData> get_Configs();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configs(IList`1<ConfigData> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssignmentContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AssignmentContext(string value);
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Experimentation.DisabledFlightsRemoteFileReaderFactory : FlightsRemoteFileReaderFactoryBase {
    private static string DefaultPath;
}
public class Microsoft.VisualStudio.Experimentation.ExperimentationService : TelemetryDisposableObject {
    private static Lazy`1<ExperimentationService> defaultExperimentationService;
    private static ExperimentationServiceInitializer customInitializer;
    private IExperimentationTelemetry telemetry;
    private IExperimentationFilterProvider filterProvider;
    private ConcurrentDictionary`2<string, FlightStatus> flightStatus;
    private IFlightsProvider flightsProvider;
    private SetFlightsProvider setFlightsProvider;
    private object lockStartFlights;
    private bool isStarted;
    [ExcludeFromCodeCoverageAttribute]
public static IExperimentationService Default { get; }
    [ExcludeFromCodeCoverageAttribute]
public static IExperimentationSetterService DefaultSetter { get; }
    [ExcludeFromCodeCoverageAttribute]
public static IExperimentationStatusService DefaultStatus { get; }
    public IEnumerable`1<string> AllEnabledCachedFlights { get; }
    public ExperimentationService(ExperimentationServiceInitializer initializer);
    private static ExperimentationService();
    public static IExperimentationService get_Default();
    public static IExperimentationSetterService get_DefaultSetter();
    public static IExperimentationStatusService get_DefaultStatus();
    private static ExperimentationServiceInitializer GetDefaultInitializer();
    public static IExperimentationService CreateDefaultExperimentationService(ExperimentationServiceInitializer initializer);
    public sealed virtual bool QueryCachedFlightStatus(string flight);
    public sealed virtual bool IsCachedFlightEnabled(string flight);
    public sealed virtual Task`1<bool> QueryFlightStatusAsync(string flight, CancellationToken token);
    public sealed virtual Task`1<bool> IsFlightEnabledAsync(string flight, CancellationToken token);
    public sealed virtual IEnumerable`1<string> get_AllEnabledCachedFlights();
    public sealed virtual void Start();
    public sealed virtual void SetFlight(string flightName, int timeoutInMinutes);
    protected virtual void DisposeManagedResources();
    private void OnFlightsUpdated(object sender, FlightsEventArgs e);
    private void SetFlightsTelemetry();
    private void PostFlightRequestTelemetry(string flight, bool isEnabled);
    private bool IsCachedFlightEnabledInternal(string flight, bool sendTriggeredEvent);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.ExperimentationService/<IsFlightEnabledInternalAsync>d__31")]
private Task`1<bool> IsFlightEnabledInternalAsync(string flight, CancellationToken token, bool sendTriggeredEvent);
    public sealed virtual IDictionary`2<string, object> GetCachedTreatmentVariables(string configId);
    public sealed virtual Task`1<IDictionary`2<string, object>> GetTreatmentVariablesAsync(string configId, CancellationToken token);
    public sealed virtual Task`1<string> GetStringTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public sealed virtual Task`1<Nullable`1<int>> GetIntTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public sealed virtual Task`1<Nullable`1<bool>> GetBoolTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public sealed virtual Task`1<Nullable`1<double>> GetDoubleTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.ExperimentationService/<GetTreatmentVariableInternalAsync>d__38`1")]
private Task`1<T> GetTreatmentVariableInternalAsync(string configId, string varName, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.ExperimentationService/<GetConfigDataInternalAsync>d__39")]
private Task`1<IDictionary`2<string, object>> GetConfigDataInternalAsync(string configId, CancellationToken token);
}
[ExcludeFromCodeCoverageAttribute]
public class Microsoft.VisualStudio.Experimentation.ExperimentationServiceInitializer : object {
    private static string localTestFlightsPathSuffix;
    private static string enabledFlightsKey;
    private static string disabledFlightsKey;
    private static string shippedFlightsKey;
    private static string setFlightsKey;
    [CompilerGeneratedAttribute]
private IExperimentationTelemetry <ExperimentationTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private IExperimentationFilterProvider <ExperimentationFilterProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyValueStorage <KeyValueStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private IExperimentationOptinStatusReader <ExperimentationOptinStatusReader>k__BackingField;
    [CompilerGeneratedAttribute]
private IFlightsProvider <FlightsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private SetFlightsProvider <SetFlightsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteFileReaderFactory <ShippedRemoteFileReaderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteFileReaderFactory <DisabledSetRemoteFileReaderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IFlightsStreamParser <FlightsStreamParser>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpWebRequestFactory <HttpWebRequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IRegistryTools3 <RegistryTools>k__BackingField;
    public IExperimentationTelemetry ExperimentationTelemetry { get; public set; }
    public IExperimentationFilterProvider ExperimentationFilterProvider { get; public set; }
    public IKeyValueStorage KeyValueStorage { get; public set; }
    public IExperimentationOptinStatusReader ExperimentationOptinStatusReader { get; public set; }
    internal IFlightsProvider FlightsProvider { get; internal set; }
    internal SetFlightsProvider SetFlightsProvider { get; internal set; }
    internal IRemoteFileReaderFactory ShippedRemoteFileReaderFactory { get; internal set; }
    internal IRemoteFileReaderFactory DisabledSetRemoteFileReaderFactory { get; internal set; }
    internal IFlightsStreamParser FlightsStreamParser { get; internal set; }
    internal IHttpWebRequestFactory HttpWebRequestFactory { get; internal set; }
    internal IRegistryTools3 RegistryTools { get; internal set; }
    private static ExperimentationServiceInitializer();
    [CompilerGeneratedAttribute]
public IExperimentationTelemetry get_ExperimentationTelemetry();
    [CompilerGeneratedAttribute]
public void set_ExperimentationTelemetry(IExperimentationTelemetry value);
    [CompilerGeneratedAttribute]
public IExperimentationFilterProvider get_ExperimentationFilterProvider();
    [CompilerGeneratedAttribute]
public void set_ExperimentationFilterProvider(IExperimentationFilterProvider value);
    [CompilerGeneratedAttribute]
public IKeyValueStorage get_KeyValueStorage();
    [CompilerGeneratedAttribute]
public void set_KeyValueStorage(IKeyValueStorage value);
    [CompilerGeneratedAttribute]
public IExperimentationOptinStatusReader get_ExperimentationOptinStatusReader();
    [CompilerGeneratedAttribute]
public void set_ExperimentationOptinStatusReader(IExperimentationOptinStatusReader value);
    [CompilerGeneratedAttribute]
internal IFlightsProvider get_FlightsProvider();
    [CompilerGeneratedAttribute]
internal void set_FlightsProvider(IFlightsProvider value);
    [CompilerGeneratedAttribute]
internal SetFlightsProvider get_SetFlightsProvider();
    [CompilerGeneratedAttribute]
internal void set_SetFlightsProvider(SetFlightsProvider value);
    [CompilerGeneratedAttribute]
internal IRemoteFileReaderFactory get_ShippedRemoteFileReaderFactory();
    [CompilerGeneratedAttribute]
internal void set_ShippedRemoteFileReaderFactory(IRemoteFileReaderFactory value);
    [CompilerGeneratedAttribute]
internal IRemoteFileReaderFactory get_DisabledSetRemoteFileReaderFactory();
    [CompilerGeneratedAttribute]
internal void set_DisabledSetRemoteFileReaderFactory(IRemoteFileReaderFactory value);
    [CompilerGeneratedAttribute]
internal IFlightsStreamParser get_FlightsStreamParser();
    [CompilerGeneratedAttribute]
internal void set_FlightsStreamParser(IFlightsStreamParser value);
    [CompilerGeneratedAttribute]
internal IHttpWebRequestFactory get_HttpWebRequestFactory();
    [CompilerGeneratedAttribute]
internal void set_HttpWebRequestFactory(IHttpWebRequestFactory value);
    [CompilerGeneratedAttribute]
internal IRegistryTools3 get_RegistryTools();
    [CompilerGeneratedAttribute]
internal void set_RegistryTools(IRegistryTools3 value);
    public static ExperimentationServiceInitializer BuildDefault();
    public ExperimentationServiceInitializer FillWithDefaults();
}
public enum Microsoft.VisualStudio.Experimentation.Filters : Enum {
    public int value__;
    public static Filters UserId;
    public static Filters ApplicationName;
    public static Filters ApplicationVersion;
    public static Filters ApplicationSku;
    public static Filters BranchBuildFrom;
    public static Filters IsInternal;
    public static Filters ChannelId;
}
internal class Microsoft.VisualStudio.Experimentation.FlightAllocation : object {
    private static char RegistrySplitCharacter;
    private static char NetworkSplitCharacter;
    [CompilerGeneratedAttribute]
private string <FlightName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllocationId>k__BackingField;
    private string registryFormat;
    public string FlightName { get; private set; }
    public string AllocationId { get; private set; }
    public FlightAllocation(string flight);
    public FlightAllocation(string flight, string allocation);
    private static FlightAllocation();
    [CompilerGeneratedAttribute]
public string get_FlightName();
    [CompilerGeneratedAttribute]
private void set_FlightName(string value);
    [CompilerGeneratedAttribute]
public string get_AllocationId();
    [CompilerGeneratedAttribute]
private void set_AllocationId(string value);
    public static FlightAllocation CreateFromNetworkString(string rawNetworkFlight);
    public static FlightAllocation CreateFromRegistryString(string rawRegistryFlight);
    public FlightAllocation ToLowerInvariant();
    public string ToRegistryString();
    public virtual string ToString();
    public sealed virtual bool Equals(FlightAllocation other);
    public virtual int GetHashCode();
    private static FlightAllocation CreationHelper(string flightString, char separator);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Experimentation.FlightAllocationExtensions : object {
    [ExtensionAttribute]
internal static HashSet`1<FlightAllocation> UnionWithFlights(IEnumerable`1<FlightAllocation> flights, IEnumerable`1<FlightAllocation> otherFlights, StringComparer comparer);
    [ExtensionAttribute]
internal static void ExceptWithFlights(HashSet`1<FlightAllocation> flights, IEnumerable`1<FlightAllocation> excludedFlights, StringComparer comparer);
}
internal class Microsoft.VisualStudio.Experimentation.FlightsEventArgs : EventArgs {
}
internal class Microsoft.VisualStudio.Experimentation.FlightsRemoteFileReader : TelemetryDisposableObject {
    private IRemoteControlClient remoteControlClient;
    public FlightsRemoteFileReader(IRemoteControlClient remoteControlClient);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.FlightsRemoteFileReader/<ReadFileAsync>d__2")]
public sealed virtual Task`1<Stream> ReadFileAsync();
    protected virtual void DisposeManagedResources();
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Experimentation.FlightsRemoteFileReaderFactoryBase : object {
    private static int DownloadIntervalInMin;
    private static string DefaultBaseUrl;
    private static string DefaultHostId;
    private string configPath;
    public FlightsRemoteFileReaderFactoryBase(string configPath);
    public sealed virtual IRemoteFileReader Instance();
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationFilterProvider {
    public abstract virtual string GetFilterValue(Filters filter);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationOptinStatusReader {
    public bool IsOptedIn { get; }
    public abstract virtual bool get_IsOptedIn();
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationService {
    public abstract virtual bool IsCachedFlightEnabled(string flight);
    public abstract virtual Task`1<bool> IsFlightEnabledAsync(string flight, CancellationToken token);
    public abstract virtual void Start();
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationService2 {
    public IEnumerable`1<string> AllEnabledCachedFlights { get; }
    public abstract virtual IEnumerable`1<string> get_AllEnabledCachedFlights();
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationService3 {
    public abstract virtual IDictionary`2<string, object> GetCachedTreatmentVariables(string configId);
    public abstract virtual Task`1<IDictionary`2<string, object>> GetTreatmentVariablesAsync(string configId, CancellationToken token);
    public abstract virtual Task`1<string> GetStringTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public abstract virtual Task`1<Nullable`1<int>> GetIntTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public abstract virtual Task`1<Nullable`1<bool>> GetBoolTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public abstract virtual Task`1<Nullable`1<double>> GetDoubleTreatmentVariableAsync(string configId, string varName, CancellationToken token);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationSetterService {
    public abstract virtual void SetFlight(string flightName, int timeoutInMinutes);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationStatusService {
    public abstract virtual bool QueryCachedFlightStatus(string flight);
    public abstract virtual Task`1<bool> QueryFlightStatusAsync(string flight, CancellationToken token);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationTelemetry {
    public abstract virtual void SetSharedProperty(string name, string value);
    public abstract virtual void PostEvent(string name, IDictionary`2<string, string> properties);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationTelemetry2 {
    public abstract virtual void PostFault(string eventName, string description);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationTelemetry3 {
    public abstract virtual void SetSharedProperty(string name, object value);
    public abstract virtual void PostEvent(string name, IDictionary`2<string, object> properties);
}
internal interface Microsoft.VisualStudio.Experimentation.IFlightsData {
    public IList`1<string> Flights { get; public set; }
    public IList`1<ConfigData> Configs { get; public set; }
    public string AssignmentContext { get; public set; }
    public abstract virtual IList`1<string> get_Flights();
    public abstract virtual void set_Flights(IList`1<string> value);
    public abstract virtual IList`1<ConfigData> get_Configs();
    public abstract virtual void set_Configs(IList`1<ConfigData> value);
    public abstract virtual string get_AssignmentContext();
    public abstract virtual void set_AssignmentContext(string value);
}
internal interface Microsoft.VisualStudio.Experimentation.IFlightsProvider {
    public IEnumerable`1<FlightAllocation> Flights { get; }
    public IEnumerable`1<ConfigData> Configs { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    public abstract virtual IEnumerable`1<FlightAllocation> get_Flights();
    public abstract virtual IEnumerable`1<ConfigData> get_Configs();
    public abstract virtual Task WaitForReady(CancellationToken token);
    public abstract virtual void Start();
}
internal interface Microsoft.VisualStudio.Experimentation.IFlightsStreamParser {
    public abstract virtual Task`1<T> ParseStreamAsync(Stream stream);
}
public interface Microsoft.VisualStudio.Experimentation.IKeyValueStorage {
    public abstract virtual T GetValue(string key, T defaultValue);
    public abstract virtual void SetValue(string key, T value);
}
internal class Microsoft.VisualStudio.Experimentation.JsonFlightsStreamParser : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.JsonFlightsStreamParser/<ParseStreamAsync>d__0`1")]
public sealed virtual Task`1<T> ParseStreamAsync(Stream stream);
}
internal class Microsoft.VisualStudio.Experimentation.LocalFlightsProvider : TelemetryDisposableObject {
    public static string PathToSettingsPrefix;
    public static string PathToConfigSettingsPrefix;
    private object lockObject;
    private IKeyValueStorage keyValueStorage;
    private string pathToSettings;
    private string pathToConfigSettings;
    private string pathToConfigIds;
    private object lockFlights;
    private IEnumerable`1<FlightAllocation> flights;
    private IEnumerable`1<ConfigData> configs;
    public IEnumerable`1<FlightAllocation> Flights { get; public set; }
    public IEnumerable`1<ConfigData> Configs { get; public set; }
    public LocalFlightsProvider(IKeyValueStorage keyValueStorage, string flightsKey);
    private static LocalFlightsProvider();
    public sealed virtual IEnumerable`1<FlightAllocation> get_Flights();
    public void set_Flights(IEnumerable`1<FlightAllocation> value);
    public sealed virtual IEnumerable`1<ConfigData> get_Configs();
    public void set_Configs(IEnumerable`1<ConfigData> value);
    public sealed virtual void add_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    public sealed virtual void remove_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    private IEnumerable`1<FlightAllocation> ReadFlightsOnce();
    private IEnumerable`1<ConfigData> ReadConfigsOnce();
    public sealed virtual void Start();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.LocalFlightsProvider/<WaitForReady>d__23")]
public sealed virtual Task WaitForReady(CancellationToken token);
}
internal class Microsoft.VisualStudio.Experimentation.MasterFlightsProvider : TelemetryDisposableObject {
    private IEnumerable`1<IFlightsProvider> inclusiveFlightsProviders;
    private IEnumerable`1<IFlightsProvider> exclusiveFlightsProviders;
    private IFlightsProvider shippedFlightsProvider;
    private bool isUserOptedIn;
    private HashSet`1<FlightAllocation> activeFlights;
    private IList`1<ConfigData> configs;
    [CompilerGeneratedAttribute]
private EventHandler`1<FlightsEventArgs> FlightsUpdated;
    public IEnumerable`1<FlightAllocation> Flights { get; }
    public IEnumerable`1<ConfigData> Configs { get; }
    public MasterFlightsProvider(IEnumerable`1<IFlightsProvider> inclusiveFlightsProviders, IEnumerable`1<IFlightsProvider> exclusiveFlightsProviders, IFlightsProvider shippedFlightsProvider, IExperimentationOptinStatusReader optinStatusReader);
    public sealed virtual IEnumerable`1<FlightAllocation> get_Flights();
    public sealed virtual IEnumerable`1<ConfigData> get_Configs();
    [CompilerGeneratedAttribute]
public sealed virtual void add_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    public sealed virtual void Start();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.MasterFlightsProvider/<WaitForReady>d__15")]
public sealed virtual Task WaitForReady(CancellationToken token);
    protected virtual void DisposeManagedResources();
    private void ForAllProviders(Action`1<IFlightsProvider> action);
    private void ForAllProviders(Action`1<IFlightsProvider> action, IEnumerable`1<IFlightsProvider> flightsProviders);
    private void OnProviderFlightsUpdated(object sender, FlightsEventArgs e);
    private HashSet`1<FlightAllocation> BuildListOfFlights();
    private IList`1<ConfigData> BuildListOfConfigs();
    private void OnFlightsUpdated();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_0(IFlightsProvider provider);
}
internal class Microsoft.VisualStudio.Experimentation.RemoteFlightsProvider`1 : CachedRemotePollerFlightsProviderBase`1<T> {
    private static int DefaultPollingIntervalInSecs;
    private string flightsKey;
    private Lazy`1<IRemoteFileReader> remoteFileReader;
    public RemoteFlightsProvider`1(IKeyValueStorage keyValueStorage, string flightsKey, IRemoteFileReaderFactory remoteFileFactory, IFlightsStreamParser flightsStreamParser);
    protected virtual void InternalDispose();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.RemoteFlightsProvider`1/<SendRemoteRequestInternalAsync>d__5")]
protected virtual Task`1<Stream> SendRemoteRequestInternalAsync();
    protected virtual string BuildFlightsKey();
}
internal class Microsoft.VisualStudio.Experimentation.SetFlightsProvider : TelemetryDisposableObject {
    private Lazy`1<LocalFlightsProvider> cachedFlightsProvider;
    private object lockObject;
    private HashSet`1 modreq(System.Runtime.CompilerServices.IsVolatile) flights;
    private IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) configs;
    public IEnumerable`1<FlightAllocation> Flights { get; }
    public IEnumerable`1<ConfigData> Configs { get; }
    public SetFlightsProvider(IKeyValueStorage keyValueStorage, string flightsKey);
    public sealed virtual IEnumerable`1<FlightAllocation> get_Flights();
    public sealed virtual IEnumerable`1<ConfigData> get_Configs();
    public sealed virtual void add_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    public sealed virtual void remove_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.SetFlightsProvider/<WaitForReady>d__12")]
public sealed virtual Task WaitForReady(CancellationToken token);
    public sealed virtual void Start();
    public void SetFlight(string flightName, int timeoutInMinutes);
    private IEnumerable`1<FlightAllocation> GetRawFlights();
    private IEnumerable`1<ConfigData> GetRawConfigs();
    private void SetRawFlights(IEnumerable`1<FlightAllocation> rawFlights);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Experimentation.SetFlightsProvider/<ConvertRawDataToPlainFlights>d__18")]
private IEnumerable`1<FlightAllocation> ConvertRawDataToPlainFlights(IEnumerable`1<FlightAllocation> rawFlights);
}
internal class Microsoft.VisualStudio.Experimentation.ShippedFlightsData : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <Flights>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConfigData> <Configs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssignmentContext>k__BackingField;
    [JsonPropertyAttribute]
public IList`1<string> Flights { get; public set; }
    [JsonPropertyAttribute]
public IList`1<ConfigData> Configs { get; public set; }
    [JsonPropertyAttribute]
public string AssignmentContext { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_Flights();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Flights(IList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ConfigData> get_Configs();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configs(IList`1<ConfigData> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssignmentContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AssignmentContext(string value);
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Experimentation.ShippedFlightsRemoteFileReaderFactory : FlightsRemoteFileReaderFactoryBase {
    private static string DefaultPath;
}
internal class Microsoft.VisualStudio.LocalLogger.DefaultTextWriterFactory : object {
    public sealed virtual TextWriter CreateTextWriter(string fullPathName);
}
public interface Microsoft.VisualStudio.LocalLogger.ILocalFileLogger {
    public bool Enabled { get; public set; }
    public string FullLogPath { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual string get_FullLogPath();
    public abstract virtual void Log(LocalLoggerSeverity severity, string componentId, string text);
}
internal interface Microsoft.VisualStudio.LocalLogger.ITextWriterFactory {
    public abstract virtual TextWriter CreateTextWriter(string fullPathName);
}
public class Microsoft.VisualStudio.LocalLogger.LocalFileLogger : object {
    private static string UnknownName;
    private static int sequenceNumber;
    private ITextWriterFactory textWriterFactory;
    private int disposeCount;
    private TextWriter writer;
    private bool isEnabled;
    [CompilerGeneratedAttribute]
private string <FullLogPath>k__BackingField;
    public bool Enabled { get; public set; }
    public string FullLogPath { get; }
    public LocalFileLogger(string logFilePath);
    internal LocalFileLogger(ITextWriterFactory textWriterFactory, string logFilePath);
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullLogPath();
    public sealed virtual void Log(LocalLoggerSeverity severity, string componentId, string text);
    public sealed virtual void Dispose();
    internal static string GenerateLogFileName();
    private void Dispose(bool disposing);
    private void CreateOrOpenFile();
    private void CloseFile();
}
public static class Microsoft.VisualStudio.LocalLogger.LocalFileLoggerService : object {
    private static object lockDefaultLoggerObject;
    [CompilerGeneratedAttribute]
private static ILocalFileLogger <DefaultLogger>k__BackingField;
    private static ILocalFileLogger DefaultLogger { get; private set; }
    public static ILocalFileLogger Default { get; }
    private static LocalFileLoggerService();
    [CompilerGeneratedAttribute]
private static ILocalFileLogger get_DefaultLogger();
    [CompilerGeneratedAttribute]
private static void set_DefaultLogger(ILocalFileLogger value);
    public static ILocalFileLogger get_Default();
}
public enum Microsoft.VisualStudio.LocalLogger.LocalLoggerSeverity : Enum {
    public int value__;
    public static LocalLoggerSeverity Info;
    public static LocalLoggerSeverity Warning;
    public static LocalLoggerSeverity Error;
    public static LocalLoggerSeverity Critical;
}
public class Microsoft.VisualStudio.LocalLogger.NullLocalFileLogger : object {
    [CompilerGeneratedAttribute]
private string <FullLogPath>k__BackingField;
    public bool Enabled { get; public set; }
    public string FullLogPath { get; }
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullLogPath();
    public sealed virtual void Log(LocalLoggerSeverity severity, string componentId, string text);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.RemoteSettings.ActionCategory : object {
    [CompilerGeneratedAttribute]
private string <CategoryId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WaitTimeSpan>k__BackingField;
    [JsonPropertyAttribute]
public string CategoryId { get; public set; }
    [JsonPropertyAttribute]
public string WaitTimeSpan { get; public set; }
    [CompilerGeneratedAttribute]
public virtual string get_CategoryId();
    [CompilerGeneratedAttribute]
public virtual void set_CategoryId(string value);
    [CompilerGeneratedAttribute]
public virtual string get_WaitTimeSpan();
    [CompilerGeneratedAttribute]
public virtual void set_WaitTimeSpan(string value);
}
internal class Microsoft.VisualStudio.RemoteSettings.ActionRequestParameters : object {
    [CompilerGeneratedAttribute]
private string <MachineId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VsoId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VsSku>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NotificationsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppIdPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MacAddressHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChannelId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChannelManifestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManifestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OsType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExeName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IsInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <CachedRuleIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionRole>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClrVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientSourceType>k__BackingField;
    [JsonPropertyAttribute]
public string MachineId { get; public set; }
    [JsonPropertyAttribute]
public string UserId { get; public set; }
    [JsonPropertyAttribute]
public string VsoId { get; public set; }
    [JsonPropertyAttribute]
public string Culture { get; public set; }
    [JsonPropertyAttribute]
public string Version { get; public set; }
    [JsonPropertyAttribute]
public string VsSku { get; public set; }
    [JsonPropertyAttribute]
public int NotificationsCount { get; public set; }
    [JsonPropertyAttribute]
public string AppIdPackage { get; public set; }
    [JsonPropertyAttribute]
public string MacAddressHash { get; public set; }
    [JsonPropertyAttribute]
public string ChannelId { get; public set; }
    [JsonPropertyAttribute]
public string ChannelManifestId { get; public set; }
    [JsonPropertyAttribute]
public string ManifestId { get; public set; }
    [JsonPropertyAttribute]
public string OsType { get; public set; }
    [JsonPropertyAttribute]
public string OsVersion { get; public set; }
    [JsonPropertyAttribute]
public string ExeName { get; public set; }
    [JsonPropertyAttribute]
public int IsInternal { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<string> CachedRuleIds { get; public set; }
    [JsonPropertyAttribute]
public string SessionId { get; public set; }
    [JsonPropertyAttribute]
public string SessionRole { get; public set; }
    [JsonPropertyAttribute]
public string ClrVersion { get; public set; }
    [JsonPropertyAttribute]
public string ProcessArchitecture { get; public set; }
    [JsonPropertyAttribute]
public string ClientSourceType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_MachineId();
    [CompilerGeneratedAttribute]
public void set_MachineId(string value);
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(string value);
    [CompilerGeneratedAttribute]
public string get_VsoId();
    [CompilerGeneratedAttribute]
public void set_VsoId(string value);
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_VsSku();
    [CompilerGeneratedAttribute]
public void set_VsSku(string value);
    [CompilerGeneratedAttribute]
public int get_NotificationsCount();
    [CompilerGeneratedAttribute]
public void set_NotificationsCount(int value);
    [CompilerGeneratedAttribute]
public string get_AppIdPackage();
    [CompilerGeneratedAttribute]
public void set_AppIdPackage(string value);
    [CompilerGeneratedAttribute]
public string get_MacAddressHash();
    [CompilerGeneratedAttribute]
public void set_MacAddressHash(string value);
    [CompilerGeneratedAttribute]
public string get_ChannelId();
    [CompilerGeneratedAttribute]
public void set_ChannelId(string value);
    [CompilerGeneratedAttribute]
public string get_ChannelManifestId();
    [CompilerGeneratedAttribute]
public void set_ChannelManifestId(string value);
    [CompilerGeneratedAttribute]
public string get_ManifestId();
    [CompilerGeneratedAttribute]
public void set_ManifestId(string value);
    [CompilerGeneratedAttribute]
public string get_OsType();
    [CompilerGeneratedAttribute]
public void set_OsType(string value);
    [CompilerGeneratedAttribute]
public string get_OsVersion();
    [CompilerGeneratedAttribute]
public void set_OsVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ExeName();
    [CompilerGeneratedAttribute]
public void set_ExeName(string value);
    [CompilerGeneratedAttribute]
public int get_IsInternal();
    [CompilerGeneratedAttribute]
public void set_IsInternal(int value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_CachedRuleIds();
    [CompilerGeneratedAttribute]
public void set_CachedRuleIds(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(string value);
    [CompilerGeneratedAttribute]
public string get_SessionRole();
    [CompilerGeneratedAttribute]
public void set_SessionRole(string value);
    [CompilerGeneratedAttribute]
public string get_ClrVersion();
    [CompilerGeneratedAttribute]
public void set_ClrVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ProcessArchitecture();
    [CompilerGeneratedAttribute]
public void set_ProcessArchitecture(string value);
    [CompilerGeneratedAttribute]
public string get_ClientSourceType();
    [CompilerGeneratedAttribute]
public void set_ClientSourceType(string value);
}
internal class Microsoft.VisualStudio.RemoteSettings.ActionResponse : object {
    [CompilerGeneratedAttribute]
private string <ActionPath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FlightName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionJson>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TriggerJson>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MaxWaitTimeSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendAlways>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Categories>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Origin>k__BackingField;
    [JsonPropertyAttribute]
public string ActionPath { get; public set; }
    [JsonPropertyAttribute]
public int Precedence { get; public set; }
    [JsonPropertyAttribute]
public string RuleId { get; public set; }
    [JsonPropertyAttribute]
public string ActionType { get; public set; }
    [JsonPropertyAttribute]
public string FlightName { get; public set; }
    [JsonPropertyAttribute]
public string ActionJson { get; public set; }
    [JsonPropertyAttribute]
public string TriggerJson { get; public set; }
    [JsonPropertyAttribute]
public string MaxWaitTimeSpan { get; public set; }
    [JsonPropertyAttribute]
public bool SendAlways { get; public set; }
    [JsonPropertyAttribute]
public IList`1<string> Categories { get; public set; }
    [JsonPropertyAttribute]
public string Origin { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ActionPath();
    [CompilerGeneratedAttribute]
public void set_ActionPath(string value);
    [CompilerGeneratedAttribute]
public virtual int get_Precedence();
    [CompilerGeneratedAttribute]
public virtual void set_Precedence(int value);
    [CompilerGeneratedAttribute]
public virtual string get_RuleId();
    [CompilerGeneratedAttribute]
public virtual void set_RuleId(string value);
    [CompilerGeneratedAttribute]
public virtual string get_ActionType();
    [CompilerGeneratedAttribute]
public virtual void set_ActionType(string value);
    [CompilerGeneratedAttribute]
public virtual string get_FlightName();
    [CompilerGeneratedAttribute]
public virtual void set_FlightName(string value);
    [CompilerGeneratedAttribute]
public virtual string get_ActionJson();
    [CompilerGeneratedAttribute]
public virtual void set_ActionJson(string value);
    [CompilerGeneratedAttribute]
public virtual string get_TriggerJson();
    [CompilerGeneratedAttribute]
public virtual void set_TriggerJson(string value);
    [CompilerGeneratedAttribute]
public virtual string get_MaxWaitTimeSpan();
    [CompilerGeneratedAttribute]
public virtual void set_MaxWaitTimeSpan(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_SendAlways();
    [CompilerGeneratedAttribute]
public virtual void set_SendAlways(bool value);
    [CompilerGeneratedAttribute]
public virtual IList`1<string> get_Categories();
    [CompilerGeneratedAttribute]
public virtual void set_Categories(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(string value);
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.RemoteSettings.ActionResponseBag : object {
    [CompilerGeneratedAttribute]
private string <ProductName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ActionResponse> <Actions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ActionCategory> <Categories>k__BackingField;
    [JsonPropertyAttribute]
public string ProductName { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<ActionResponse> Actions { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<ActionCategory> Categories { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProductName();
    [CompilerGeneratedAttribute]
public void set_ProductName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ActionResponse> get_Actions();
    [CompilerGeneratedAttribute]
public void set_Actions(IEnumerable`1<ActionResponse> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ActionCategory> get_Categories();
    [CompilerGeneratedAttribute]
public void set_Categories(IEnumerable`1<ActionCategory> value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.RemoteSettings.ActionResponseEx : object {
    private static Lazy`1<JsonConverter[]> matchConvertersLazy;
    private static ActionResponseEx();
    [ExtensionAttribute]
public static ActionWrapper`1<T> AsTypedAction(ActionResponse actionResponse);
    [ExtensionAttribute]
public static Dictionary`2<string, ITelemetryEventMatch> GetTriggers(ActionResponse actionResponse);
    [ExtensionAttribute]
public static Dictionary`2<string, ActionTriggerOptions> GetTriggerOptions(ActionResponse actionResponse);
}
public class Microsoft.VisualStudio.RemoteSettings.ActionSubscriptionDetails : object {
    public static string StartTrigger;
    public static string StopTrigger;
    [CompilerGeneratedAttribute]
private bool <TriggerAlways>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TriggerOnSubscribe>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryEvent <TelemetryEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <RegisteredTriggerNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TriggerName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, int> <TriggerSubscriptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryNotificationService <NotificationService>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TriggerLockObject>k__BackingField;
    public bool TriggerAlways { get; internal set; }
    public bool TriggerOnSubscribe { get; internal set; }
    public TelemetryEvent TelemetryEvent { get; internal set; }
    public IEnumerable`1<string> RegisteredTriggerNames { get; internal set; }
    public string TriggerName { get; internal set; }
    internal IDictionary`2<string, int> TriggerSubscriptions { get; internal set; }
    internal ITelemetryNotificationService NotificationService { get; internal set; }
    internal object TriggerLockObject { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_TriggerAlways();
    [CompilerGeneratedAttribute]
internal void set_TriggerAlways(bool value);
    [CompilerGeneratedAttribute]
public bool get_TriggerOnSubscribe();
    [CompilerGeneratedAttribute]
internal void set_TriggerOnSubscribe(bool value);
    [CompilerGeneratedAttribute]
public TelemetryEvent get_TelemetryEvent();
    [CompilerGeneratedAttribute]
internal void set_TelemetryEvent(TelemetryEvent value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_RegisteredTriggerNames();
    [CompilerGeneratedAttribute]
internal void set_RegisteredTriggerNames(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_TriggerName();
    [CompilerGeneratedAttribute]
internal void set_TriggerName(string value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, int> get_TriggerSubscriptions();
    [CompilerGeneratedAttribute]
internal void set_TriggerSubscriptions(IDictionary`2<string, int> value);
    [CompilerGeneratedAttribute]
internal ITelemetryNotificationService get_NotificationService();
    [CompilerGeneratedAttribute]
internal void set_NotificationService(ITelemetryNotificationService value);
    [CompilerGeneratedAttribute]
internal object get_TriggerLockObject();
    [CompilerGeneratedAttribute]
internal void set_TriggerLockObject(object value);
    public void Unsubscribe();
    public void UnsubscribeAll();
}
internal class Microsoft.VisualStudio.RemoteSettings.ActionTriggerOptions : object {
    [CompilerGeneratedAttribute]
private bool <TriggerOnSubscribe>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TriggerAlways>k__BackingField;
    [JsonPropertyAttribute]
public bool TriggerOnSubscribe { get; public set; }
    [JsonPropertyAttribute]
public bool TriggerAlways { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_TriggerOnSubscribe();
    [CompilerGeneratedAttribute]
public void set_TriggerOnSubscribe(bool value);
    [CompilerGeneratedAttribute]
public bool get_TriggerAlways();
    [CompilerGeneratedAttribute]
public void set_TriggerAlways(bool value);
}
public class Microsoft.VisualStudio.RemoteSettings.ActionWrapper`1 : object {
    [CompilerGeneratedAttribute]
private string <ActionPath>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FlightName>k__BackingField;
    [CompilerGeneratedAttribute]
private ActionSubscriptionDetails <Subscription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionJson>k__BackingField;
    public string ActionPath { get; internal set; }
    public T Action { get; internal set; }
    public int Precedence { get; internal set; }
    public string RuleId { get; internal set; }
    public string ActionType { get; internal set; }
    public string FlightName { get; internal set; }
    public ActionSubscriptionDetails Subscription { get; internal set; }
    internal string ActionJson { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_ActionPath();
    [CompilerGeneratedAttribute]
internal void set_ActionPath(string value);
    [CompilerGeneratedAttribute]
public T get_Action();
    [CompilerGeneratedAttribute]
internal void set_Action(T value);
    [CompilerGeneratedAttribute]
public int get_Precedence();
    [CompilerGeneratedAttribute]
internal void set_Precedence(int value);
    [CompilerGeneratedAttribute]
public string get_RuleId();
    [CompilerGeneratedAttribute]
internal void set_RuleId(string value);
    [CompilerGeneratedAttribute]
public string get_ActionType();
    [CompilerGeneratedAttribute]
internal void set_ActionType(string value);
    [CompilerGeneratedAttribute]
public string get_FlightName();
    [CompilerGeneratedAttribute]
internal void set_FlightName(string value);
    [CompilerGeneratedAttribute]
public ActionSubscriptionDetails get_Subscription();
    [CompilerGeneratedAttribute]
internal void set_Subscription(ActionSubscriptionDetails value);
    [CompilerGeneratedAttribute]
internal string get_ActionJson();
    [CompilerGeneratedAttribute]
internal void set_ActionJson(string value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.RemoteSettings.ActionWrapperEx : object {
    [ExtensionAttribute]
public static ActionWrapper`1<T> WithSubscriptionDetails(ActionWrapper`1<T> baseAction, ActionSubscriptionDetails details);
}
internal class Microsoft.VisualStudio.RemoteSettings.AsyncScopeParser : object {
    private string expression;
    private Stack`1<AsyncOperand> output;
    private Stack`1<Operator> operators;
    private IDictionary`2<string, IScopeFilterProvider> providedFilters;
    private Regex stringRegex;
    private int expressionIndex;
    internal AsyncScopeParser(string expression, IDictionary`2<string, IScopeFilterProvider> providedFilters);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.AsyncScopeParser/<RunAsync>d__14")]
public Task`1<bool> RunAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.AsyncScopeParser/<ParseOperatorAsync>d__15")]
private Task ParseOperatorAsync(Operator op);
    private void ParseOperand(AsyncOperand op);
    private Operator ScanOperator();
    private AsyncOperand ScanOperand();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.AsyncScopeParser/<EvaluateOutputAsync>d__19")]
private Task EvaluateOutputAsync();
    private string GetRestOfExpression();
    private static LazyOperand CastAppropiateSingle(IScopeFilterProvider provider);
    private static LazyOperand CastAppropiateMulti(IScopeFilterProvider provider, string subkey);
}
public class Microsoft.VisualStudio.RemoteSettings.BoolScopeValue : ScopeValue {
    private bool value;
    public BoolScopeValue(bool value);
    internal virtual AsyncOperand GetAsyncOperand();
    internal virtual Operand GetOperand();
}
internal class Microsoft.VisualStudio.RemoteSettings.CachedActionCategoryTime : object {
    [CompilerGeneratedAttribute]
private DateTime <LastSent>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <WaitTimeSpan>k__BackingField;
    public DateTime LastSent { get; public set; }
    public TimeSpan WaitTimeSpan { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_LastSent();
    [CompilerGeneratedAttribute]
public void set_LastSent(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_WaitTimeSpan();
    [CompilerGeneratedAttribute]
public void set_WaitTimeSpan(TimeSpan value);
}
internal class Microsoft.VisualStudio.RemoteSettings.CachedActionResponseTime : object {
    [CompilerGeneratedAttribute]
private DateTime <CachedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxWaitTimeSpan>k__BackingField;
    public DateTime CachedTime { get; public set; }
    public TimeSpan MaxWaitTimeSpan { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_CachedTime();
    [CompilerGeneratedAttribute]
public void set_CachedTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxWaitTimeSpan();
    [CompilerGeneratedAttribute]
public void set_MaxWaitTimeSpan(TimeSpan value);
}
internal class Microsoft.VisualStudio.RemoteSettings.CachedTargetedNotifications : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, CachedActionCategoryTime> <Categories>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, CachedActionResponseTime> <Actions>k__BackingField;
    public IDictionary`2<string, CachedActionCategoryTime> Categories { get; public set; }
    public IDictionary`2<string, CachedActionResponseTime> Actions { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, CachedActionCategoryTime> get_Categories();
    [CompilerGeneratedAttribute]
public void set_Categories(IDictionary`2<string, CachedActionCategoryTime> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, CachedActionResponseTime> get_Actions();
    [CompilerGeneratedAttribute]
public void set_Actions(IDictionary`2<string, CachedActionResponseTime> value);
}
internal class Microsoft.VisualStudio.RemoteSettings.CycleDetection : object {
    private static Regex scopeRegex;
    private static CycleDetection();
    public sealed virtual bool HasCycles(IEnumerable`1<Scope> scopes);
    internal static MatchCollection GetScopeMatches(string scopeString);
}
public class Microsoft.VisualStudio.RemoteSettings.DefaultRemoteSettingsFilterProvider : RemoteSettingsFilterProvider {
    private TelemetrySession session;
    private IProcessInformationProvider processInformationProvider;
    private IOSInformationProvider osInformationProvider;
    private IRegistryTools registryTools;
    private Lazy`1<string> partnerId;
    public DefaultRemoteSettingsFilterProvider(TelemetrySession telemetrySession);
    internal DefaultRemoteSettingsFilterProvider(TelemetrySession telemetrySession, IProcessInformationProvider processInformationProvider, IOSInformationProvider osInformationProvider, IRegistryTools registryTools);
    public virtual Guid GetMachineId();
    public virtual Guid GetUserId();
    public virtual string GetCulture();
    public virtual string GetApplicationName();
    public virtual string GetApplicationVersion();
    public virtual string GetMacAddressHash();
    public virtual string GetOsType();
    public virtual string GetOsVersion();
    public virtual bool GetIsUserInternal();
    public virtual string GetSessionRole();
    public virtual string GetClrVersion();
    public virtual string GetProcessArchitecture();
    public virtual string GetClientSourceType();
    private string InitializePartnerId();
    [CompilerGeneratedAttribute]
private string <.ctor>b__6_0();
}
internal class Microsoft.VisualStudio.RemoteSettings.DefaultRemoteSettingsTelemetry : object {
    private TelemetrySession telemetrySession;
    public DefaultRemoteSettingsTelemetry(TelemetrySession telemetrySession);
    public sealed virtual IRemoteSettingsTelemetryActivity CreateActivity(string name);
    public sealed virtual void PostEvent(string name, IDictionary`2<string, object> properties);
}
internal class Microsoft.VisualStudio.RemoteSettings.DefaultTargetedNotificationsTelemetry : object {
    private TelemetrySession telemetrySession;
    public string SessionId { get; }
    public DefaultTargetedNotificationsTelemetry(TelemetrySession telemetrySession);
    public sealed virtual string get_SessionId();
    public sealed virtual void PostCriticalFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
    public sealed virtual void PostDiagnosticFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
    public sealed virtual void PostGeneralFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
    public sealed virtual void PostSuccessfulOperation(string eventName, Dictionary`2<string, object> additionalProperties);
    private void PostEventInternal(TelemetryEvent telemetryEvent, Dictionary`2<string, object> additionalProperties);
}
internal class Microsoft.VisualStudio.RemoteSettings.DeserializedRemoteSettings : object {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Scope> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<RemoteSetting> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public ReadOnlyCollection`1<Scope> Scopes { get; }
    public ReadOnlyCollection`1<RemoteSetting> Settings { get; }
    public string Error { get; }
    public bool Successful { get; }
    public DeserializedRemoteSettings(ReadOnlyCollection`1<Scope> scopes, ReadOnlyCollection`1<RemoteSetting> settings, string error);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Scope> get_Scopes();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<RemoteSetting> get_Settings();
    [CompilerGeneratedAttribute]
public string get_Error();
    public bool get_Successful();
}
internal class Microsoft.VisualStudio.RemoteSettings.DirectoryReader : object {
    private string path;
    private string directoryName;
    private bool markProcessed;
    private IRemoteSettingsLogger logger;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public int Priority { get; private set; }
    public DirectoryReader(string rootPath, string directoryName, bool markProcessed, int priority, IRemoteSettingsLogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
private void set_Priority(int value);
    public sealed virtual IEnumerable`1<DirectoryReaderContext> ReadAllFiles();
}
internal class Microsoft.VisualStudio.RemoteSettings.DirectoryReaderContext : object {
    [CompilerGeneratedAttribute]
private string <DirectoryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public string DirectoryName { get; public set; }
    public string FileName { get; public set; }
    public Stream Stream { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DirectoryName();
    [CompilerGeneratedAttribute]
public void set_DirectoryName(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(Stream value);
}
public class Microsoft.VisualStudio.RemoteSettings.DoubleScopeValue : ScopeValue {
    private double value;
    public DoubleScopeValue(double value);
    internal virtual AsyncOperand GetAsyncOperand();
    internal virtual Operand GetOperand();
}
internal class Microsoft.VisualStudio.RemoteSettings.ExeNameScopeFilterProvider : object {
    private Lazy`1<StringScopeValue> exeName;
    public string Name { get; }
    public ExeNameScopeFilterProvider(RemoteSettingsFilterProvider filterProvider);
    public sealed virtual string get_Name();
    public sealed virtual StringScopeValue Provide();
}
internal class Microsoft.VisualStudio.RemoteSettings.FileActionResponse : ActionResponse {
    [CompilerGeneratedAttribute]
private int <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FlightName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionJson>k__BackingField;
    [JsonPropertyAttribute]
public int Precedence { get; public set; }
    [JsonPropertyAttribute]
public string FlightName { get; public set; }
    [JsonPropertyAttribute]
public string RuleId { get; public set; }
    [JsonPropertyAttribute]
public string ActionType { get; public set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("Microsoft.VisualStudio.RemoteSettings.TestActionJsonConverter")]
public string ActionJson { get; public set; }
    [CompilerGeneratedAttribute]
public virtual int get_Precedence();
    [CompilerGeneratedAttribute]
public virtual void set_Precedence(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FlightName();
    [CompilerGeneratedAttribute]
public virtual void set_FlightName(string value);
    [CompilerGeneratedAttribute]
public virtual string get_RuleId();
    [CompilerGeneratedAttribute]
public virtual void set_RuleId(string value);
    [CompilerGeneratedAttribute]
public virtual string get_ActionType();
    [CompilerGeneratedAttribute]
public virtual void set_ActionType(string value);
    [CompilerGeneratedAttribute]
public virtual string get_ActionJson();
    [CompilerGeneratedAttribute]
public virtual void set_ActionJson(string value);
    [OnDeserializedAttribute]
internal void OnDeserializedMethod(StreamingContext context);
}
internal class Microsoft.VisualStudio.RemoteSettings.FlightScopeFilterProvider : object {
    private IExperimentationService experimentationService;
    public string Name { get; }
    public FlightScopeFilterProvider(IExperimentationService experimentationService);
    public sealed virtual string get_Name();
    public sealed virtual BoolScopeValue Provide(string key);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.FlightScopeFilterProvider/<ProvideAsync>d__5")]
public sealed virtual Task`1<BoolScopeValue> ProvideAsync(string key);
}
internal class Microsoft.VisualStudio.RemoteSettings.GroupedRemoteSettings : Dictionary`2<string, RemoteSettingPossibilities> {
    public GroupedRemoteSettings(DeserializedRemoteSettings deserializedRemoteSettings, string origin);
    public void Merge(GroupedRemoteSettings buckets, IRemoteSettingsLogger logger);
}
public interface Microsoft.VisualStudio.RemoteSettings.ICollectionKeyValueStorage {
    public abstract virtual T GetValue(string collectionPath, string key, T defaultValue);
    public abstract virtual bool TryGetValue(string collectionPath, string key, T& value);
    public abstract virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public abstract virtual void SetValue(string collectionPath, string key, T value);
    public abstract virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public abstract virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public abstract virtual bool CollectionExists(string collectionPath);
    public abstract virtual bool PropertyExists(string collectionPath, string propertyName);
    public abstract virtual bool DeleteCollection(string collectionPath);
    public abstract virtual bool DeleteProperty(string collectionPath, string propertyName);
}
internal interface Microsoft.VisualStudio.RemoteSettings.ICycleDetection {
    public abstract virtual bool HasCycles(IEnumerable`1<Scope> scopes);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IDirectoryReader {
    public int Priority { get; }
    public abstract virtual IEnumerable`1<DirectoryReaderContext> ReadAllFiles();
    public abstract virtual int get_Priority();
}
internal interface Microsoft.VisualStudio.RemoteSettings.ILocalTestParser {
    public abstract virtual Task`1<IEnumerable`1<ActionResponse>> ParseStreamAsync(DirectoryReaderContext streamContext);
}
public interface Microsoft.VisualStudio.RemoteSettings.IMultiValueScopeFilterAsyncProvider`1 {
    public abstract virtual Task`1<T> ProvideAsync(string key);
}
public interface Microsoft.VisualStudio.RemoteSettings.IMultiValueScopeFilterProvider`1 {
    public abstract virtual T Provide(string key);
}
internal class Microsoft.VisualStudio.RemoteSettings.InternalScopeFilterProvider : object {
    private TelemetrySession telemetrySession;
    public string Name { get; }
    public InternalScopeFilterProvider(TelemetrySession telemetrySession);
    public sealed virtual string get_Name();
    public sealed virtual BoolScopeValue Provide();
}
public interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettings {
    [CompilerGeneratedAttribute]
public abstract virtual void add_SettingsUpdated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SettingsUpdated(EventHandler value);
    public abstract virtual T GetValue(string collectionPath, string key, T defaultValue);
    public abstract virtual bool TryGetValue(string collectionPath, string key, T& value);
    public abstract virtual Task`1<T> GetValueAsync(string collectionPath, string key, T defaultValue);
    public abstract virtual ValueKind GetValueKind(string collectionPath, string key);
    public abstract virtual Task`1<IEnumerable`1<ActionWrapper`1<T>>> GetActionsAsync(string actionPath);
    public abstract virtual void Start();
    public abstract virtual IRemoteSettings RegisterFilterProvider(IScopeFilterProvider scopeFilterProvider);
    public abstract virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public abstract virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public abstract virtual bool CollectionExists(string collectionPath);
    public abstract virtual bool PropertyExists(string collectionPath, string key);
}
public interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettings2 {
    public abstract virtual void SubscribeActions(string actionPath, Action`1<ActionWrapper`1<T>> callback);
    public abstract virtual void UnsubscribeActions(string actionPath);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsLogger {
    public bool LoggingEnabled { get; }
    public abstract virtual bool get_LoggingEnabled();
    public abstract virtual Task Start();
    public abstract virtual void LogVerbose(string message);
    public abstract virtual void LogVerbose(string message, object data);
    public abstract virtual void LogInfo(string message);
    public abstract virtual void LogError(string message);
    public abstract virtual void LogError(string message, Exception exception);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsParser {
    public abstract virtual VersionedDeserializedRemoteSettings TryParseVersionedStream(Stream stream);
    public abstract virtual DeserializedRemoteSettings TryParseFromJObject(JObject json, string globalScope);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsProvider {
    public string Name { get; }
    public abstract virtual bool TryGetValue(string collectionPath, string key, T& value);
    public abstract virtual string get_Name();
    public abstract virtual Task`1<GroupedRemoteSettings> Start();
    public abstract virtual Task`1<IEnumerable`1<ActionWrapper`1<T>>> GetActionsAsync(string actionPath);
    public abstract virtual Task SubscribeActionsAsync(string actionPath, Action`1<ActionWrapper`1<T>> callback);
    public abstract virtual void UnsubscribeActions(string actionPath);
    public abstract virtual Task`1<RemoteSettingsProviderResult`1<T>> TryGetValueAsync(string collectionPath, string key);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsStorageHandler {
    public abstract virtual Task`1<RemoteSettingsProviderResult`1<T>> TryGetValueAsync(string collectionPath, string key);
    public abstract virtual bool TryGetValue(string collectionPath, string key, T& value);
    public abstract virtual void SaveSettings(GroupedRemoteSettings remoteSettings);
    public abstract virtual void SaveNonScopedSetting(RemoteSetting setting);
    public abstract virtual void SaveNonScopedSettings(GroupedRemoteSettings groupedSettings);
    public abstract virtual void DeleteAllSettings();
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsStorageHandlerFactory {
    public abstract virtual IVersionedRemoteSettingsStorageHandler BuildVersioned(ICollectionKeyValueStorage storage, bool usePrefix, string fileName, IScopeParserFactory scopeParserFactory);
    public abstract virtual IRemoteSettingsStorageHandler Build(ICollectionKeyValueStorage storage, bool usePrefix, RemoteSettingsFilterProvider filterProvider, IScopeParserFactory scopeParserFactory);
    public abstract virtual IRemoteSettingsStorageHandler Build(ICollectionKeyValueStorage storage, bool usePrefix, string collectionPath, IScopeParserFactory scopeParserFactory);
}
public interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsTelemetry {
    public abstract virtual void PostEvent(string name, IDictionary`2<string, object> properties);
    public abstract virtual IRemoteSettingsTelemetryActivity CreateActivity(string name);
}
public interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsTelemetryActivity {
    public abstract virtual void Start();
    public abstract virtual void End();
    public abstract virtual void Post(IDictionary`2<string, object> properties);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsValidator {
    public abstract virtual void ValidateDeserialized(DeserializedRemoteSettings remoteSettings);
    public abstract virtual void ValidateStored();
}
public interface Microsoft.VisualStudio.RemoteSettings.IScopeFilterProvider {
    public string Name { get; }
    public abstract virtual string get_Name();
}
internal interface Microsoft.VisualStudio.RemoteSettings.IScopeParserFactory {
    public IDictionary`2<string, IScopeFilterProvider> ProvidedFilters { get; }
    public abstract virtual IDictionary`2<string, IScopeFilterProvider> get_ProvidedFilters();
    public abstract virtual bool Evaluate(string scopeExpression);
    public abstract virtual Task`1<bool> EvaluateAsync(string scopeExpression);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IScopesStorageHandler {
    public abstract virtual IEnumerable`1<string> GetAllScopes();
    public abstract virtual string GetScope(string scopeName);
}
internal interface Microsoft.VisualStudio.RemoteSettings.ISettingsCollection {
    public abstract virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public abstract virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public abstract virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public abstract virtual bool CollectionExists(string collectionPath);
    public abstract virtual bool PropertyExists(string collectionPath, string propertyName);
}
public interface Microsoft.VisualStudio.RemoteSettings.ISingleValueScopeFilterAsyncProvider`1 {
    public abstract virtual Task`1<T> ProvideAsync();
}
public interface Microsoft.VisualStudio.RemoteSettings.ISingleValueScopeFilterProvider`1 {
    public abstract virtual T Provide();
}
internal interface Microsoft.VisualStudio.RemoteSettings.IStableRemoteSettingsProvider {
    public abstract virtual bool IsStable(string collectionPath);
    public abstract virtual void MakeStable(string collectionPath, string key, T value);
}
internal interface Microsoft.VisualStudio.RemoteSettings.ITargetedNotificationsCacheStorageProvider {
    public abstract virtual CachedTargetedNotifications GetLocalCacheCopy();
    public abstract virtual void SetLocalCache(CachedTargetedNotifications newCache);
    public abstract virtual bool Lock(Nullable`1<int> timeoutMs);
    public abstract virtual void Unlock();
    public abstract virtual void Reset();
}
internal interface Microsoft.VisualStudio.RemoteSettings.ITargetedNotificationsParser {
    public abstract virtual Task`1<ActionResponseBag> ParseStreamAsync(Stream stream, CancellationToken cancellationToken);
}
internal interface Microsoft.VisualStudio.RemoteSettings.ITargetedNotificationsTelemetry {
    public string SessionId { get; }
    public abstract virtual string get_SessionId();
    public abstract virtual void PostSuccessfulOperation(string eventName, Dictionary`2<string, object> additionalProperties);
    public abstract virtual void PostDiagnosticFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
    public abstract virtual void PostGeneralFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
    public abstract virtual void PostCriticalFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IVersionedRemoteSettingsStorageHandler {
    public string FileVersion { get; }
    public abstract virtual string get_FileVersion();
    public abstract virtual void DeleteSettingsForFileVersion(string fileVersion);
    public abstract virtual bool DoSettingsNeedToBeUpdated(string newFileVersion);
    public abstract virtual void SaveSettings(VersionedDeserializedRemoteSettings remoteSettings);
    public abstract virtual void InvalidateFileVersion();
    public abstract virtual void CleanUpOldFileVersions(string newFileVersion);
}
internal class Microsoft.VisualStudio.RemoteSettings.LocalTestParser : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.LocalTestParser/<ParseStreamAsync>d__0")]
public sealed virtual Task`1<IEnumerable`1<ActionResponse>> ParseStreamAsync(DirectoryReaderContext streamContext);
}
internal class Microsoft.VisualStudio.RemoteSettings.LocalTestProvider : TargetedNotificationsProviderBase {
    private IEnumerable`1<IDirectoryReader> directories;
    private ILocalTestParser localTestParser;
    public string Name { get; }
    public LocalTestProvider(RemoteSettingsInitializer initializer);
    public virtual string get_Name();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.LocalTestProvider/<GetTargetedNotificationActionsAsync>d__5")]
protected virtual Task`1<ActionResponseBag> GetTargetedNotificationActionsAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.LocalTestProvider/<<GetTargetedNotificationActionsAsync>b__5_1>d")]
[CompilerGeneratedAttribute]
private Task`1<IEnumerable`1<ActionResponse>> <GetTargetedNotificationActionsAsync>b__5_1(DirectoryReaderContext x);
}
internal class Microsoft.VisualStudio.RemoteSettings.LoggingContext`1 : object {
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public string Context { get; public set; }
    public T Value { get; public set; }
    public LoggingContext`1(string context, T value);
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(string value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
internal class Microsoft.VisualStudio.RemoteSettings.MemoryKeyValueStorage : object {
    private Dictionary`2<string, KeyValueCollection> collections;
    public sealed virtual bool CollectionExists(string collectionPath);
    public sealed virtual bool PropertyExists(string collectionPath, string key);
    public sealed virtual bool DeleteCollection(string collectionPath);
    public sealed virtual bool DeleteProperty(string collectionPath, string propertyName);
    public sealed virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public sealed virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public sealed virtual T GetValue(string collectionPath, string key, T defaultValue);
    public sealed virtual bool TryGetValue(string collectionPath, string key, T& value);
    public sealed virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public sealed virtual void SetValue(string collectionPath, string key, T value);
    private void AddToParentCollections(string collectionPath);
    private bool TryGetValueInternal(string collectionPath, string key, T defaultValue, T& value);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteControlRemoteSettingsProvider : RemoteSettingsProviderBase {
    private static int DisposingIsStarted;
    private static int DisposingNotStarted;
    private static string RemoteSettingsTelemetryEventPath;
    private static string RemoteSettingsTelemetryPropertyPath;
    private IVersionedRemoteSettingsStorageHandler remoteSettingsStorageHandler;
    private IRemoteSettingsTelemetry remoteSettingsTelemetry;
    private Lazy`1<IRemoteFileReader> remoteFileReader;
    private IRemoteSettingsParser remoteSettingsParser;
    private IScopeParserFactory scopeParserFactory;
    private IRemoteSettingsValidator remoteSettingsValidator;
    private string fileName;
    private int startedDisposing;
    private CancellationTokenSource cancellationTokenSource;
    public string Name { get; }
    public RemoteControlRemoteSettingsProvider(RemoteSettingsInitializer initializer);
    public virtual string get_Name();
    public virtual Task`1<GroupedRemoteSettings> Start();
    protected virtual void DisposeManagedResources();
    private void ProcessRemoteSettingsFile(VersionedDeserializedRemoteSettings remoteSettings);
    private void ValidateStoredRemoteSettings();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteControlRemoteSettingsProvider/<<Start>b__16_0>d")]
[CompilerGeneratedAttribute]
private Task`1<GroupedRemoteSettings> <Start>b__16_0();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSetting : object {
    public static char Separator;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScopeString>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Origin>k__BackingField;
    public string Path { get; }
    public string Name { get; }
    public string ScopeString { get; public set; }
    public object Value { get; }
    public string Origin { get; public set; }
    public bool HasScope { get; }
    public RemoteSetting(string path, string name, object value, string scopeString);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_ScopeString();
    [CompilerGeneratedAttribute]
public void set_ScopeString(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public string get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(string value);
    public bool get_HasScope();
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingPossibilities : Dictionary`2<string, List`1<RemoteSetting>> {
}
public class Microsoft.VisualStudio.RemoteSettings.RemoteSettings : TelemetryDisposableObject {
    private static Lazy`1<RemoteSettings> defaultRemoteSettings;
    private IStableRemoteSettingsProvider stableRemoteSettingProvider;
    private List`1<IRemoteSettingsProvider> remoteSettingsProviders;
    private IScopeParserFactory scopeParserFactory;
    private IRemoteSettingsStorageHandler nonScopedStorageHandler;
    private Func`1<bool> isUpdateDisabled;
    private IRemoteSettingsLogger logger;
    private bool isStarted;
    internal Task StartTask;
    [CompilerGeneratedAttribute]
private EventHandler SettingsUpdated;
    internal IEnumerable`1<IRemoteSettingsProvider> AllRemoteSettingsProviders { get; }
    public static IRemoteSettings Default { get; }
    public RemoteSettings(RemoteSettingsInitializer initializer);
    private static RemoteSettings();
    [CompilerGeneratedAttribute]
public sealed virtual void add_SettingsUpdated(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SettingsUpdated(EventHandler value);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettings/<get_AllRemoteSettingsProviders>d__13")]
internal IEnumerable`1<IRemoteSettingsProvider> get_AllRemoteSettingsProviders();
    public static IRemoteSettings get_Default();
    public sealed virtual T GetValue(string collectionPath, string key, T defaultValue);
    public sealed virtual bool TryGetValue(string collectionPath, string key, T& value);
    public sealed virtual ValueKind GetValueKind(string collectionPath, string key);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettings/<GetValueAsync>d__20`1")]
public sealed virtual Task`1<T> GetValueAsync(string collectionPath, string key, T defaultValue);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettings/<GetActionsAsync>d__21`1")]
public sealed virtual Task`1<IEnumerable`1<ActionWrapper`1<T>>> GetActionsAsync(string actionPath);
    public sealed virtual void SubscribeActions(string actionPath, Action`1<ActionWrapper`1<T>> callback);
    public sealed virtual void UnsubscribeActions(string actionPath);
    public sealed virtual void Start();
    public sealed virtual IRemoteSettings RegisterFilterProvider(IScopeFilterProvider scopeFilterProvider);
    public sealed virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public sealed virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public sealed virtual bool CollectionExists(string collectionPath);
    public sealed virtual bool PropertyExists(string collectionPath, string key);
    protected virtual void DisposeManagedResources();
    private void RequiresStarted();
    private void OnRemoteSettingsApplied();
    [CompilerGeneratedAttribute]
private GroupedRemoteSettings <Start>b__24_2(GroupedRemoteSettings a, GroupedRemoteSettings b);
}
public abstract class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsFilterProvider : object {
    public virtual Guid GetMachineId();
    public virtual Guid GetUserId();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsFilterProvider/<GetVsIdAsync>d__2")]
public virtual Task`1<string> GetVsIdAsync();
    public virtual string GetCulture();
    public virtual string GetBranchBuildFrom();
    public virtual string GetApplicationName();
    public virtual string GetApplicationVersion();
    public virtual string GetVsSku();
    public virtual int GetNotificationsCount();
    public virtual Guid GetAppIdPackageGuid();
    public virtual string GetMacAddressHash();
    public virtual string GetChannelId();
    public virtual string GetChannelManifestId();
    public virtual string GetManifestId();
    public virtual string GetOsType();
    public virtual string GetOsVersion();
    public virtual bool GetIsUserInternal();
    public virtual string GetSessionRole();
    public virtual string GetClrVersion();
    public virtual string GetProcessArchitecture();
    public virtual string GetClientSourceType();
}
public class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsInitializer : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UsePathPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IScopeFilterProvider> <ScopeFilterProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteSettingsFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollectionKeyValueStorage <KeyValueStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private IExperimentationService <ExperimentationService>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryNotificationService <TelemetryNotificationService>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsTelemetry <Telemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private ITargetedNotificationsTelemetry <TargetedNotificationsTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private ITargetedNotificationsCacheStorageProvider <TargetedNotificationsCacheStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteSettingsFilterProvider <FilterProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollectionKeyValueStorage <NonScopedSettingsKeyValueStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <StableSettingRootSubCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private IScopeParserFactory <ScopeParserFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IVersionedRemoteSettingsStorageHandler <VersionedRemoteSettingsStorageHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsStorageHandler <CacheableRemoteSettingsStorageHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsStorageHandler <LocalTestRemoteSettingsStorageHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IDirectoryReader> <LocalTestDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IRemoteSettingsStorageHandler> <LiveRemoteSettingsStorageHandlerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsStorageHandler <NonScopedRemoteSettingsStorageHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteFileReaderFactory <RemoteFileReaderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsParser <RemoteSettingsParser>k__BackingField;
    [CompilerGeneratedAttribute]
private ITargetedNotificationsParser <TargetedNotificationsParser>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsValidator <RemoteSettingsValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Func`2<RemoteSettingsInitializer, IRemoteSettingsProvider>> <RemoteSettingsProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<RemoteSettingsInitializer, IStableRemoteSettingsProvider> <StableRemoteSettingsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpWebRequestFactory <HttpWebRequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<bool> <IsUpdatedDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private ILocalTestParser <LocalTestParser>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsLogger <RemoteSettingsLogger>k__BackingField;
    public Nullable`1<bool> UsePathPrefix { get; public set; }
    public IEnumerable`1<IScopeFilterProvider> ScopeFilterProviders { get; public set; }
    public string RemoteSettingsFileName { get; public set; }
    public ICollectionKeyValueStorage KeyValueStorage { get; public set; }
    public IExperimentationService ExperimentationService { get; public set; }
    public ITelemetryNotificationService TelemetryNotificationService { get; public set; }
    public IRemoteSettingsTelemetry Telemetry { get; public set; }
    internal ITargetedNotificationsTelemetry TargetedNotificationsTelemetry { get; internal set; }
    internal ITargetedNotificationsCacheStorageProvider TargetedNotificationsCacheStorage { get; internal set; }
    public RemoteSettingsFilterProvider FilterProvider { get; public set; }
    public ICollectionKeyValueStorage NonScopedSettingsKeyValueStorage { get; public set; }
    public IEnumerable`1<string> StableSettingRootSubCollections { get; public set; }
    internal IScopeParserFactory ScopeParserFactory { get; internal set; }
    internal IVersionedRemoteSettingsStorageHandler VersionedRemoteSettingsStorageHandler { get; internal set; }
    internal IRemoteSettingsStorageHandler CacheableRemoteSettingsStorageHandler { get; internal set; }
    internal IRemoteSettingsStorageHandler LocalTestRemoteSettingsStorageHandler { get; internal set; }
    internal IEnumerable`1<IDirectoryReader> LocalTestDirectories { get; internal set; }
    internal Func`1<IRemoteSettingsStorageHandler> LiveRemoteSettingsStorageHandlerFactory { get; internal set; }
    internal IRemoteSettingsStorageHandler NonScopedRemoteSettingsStorageHandler { get; internal set; }
    internal IRemoteFileReaderFactory RemoteFileReaderFactory { get; internal set; }
    internal IRemoteSettingsParser RemoteSettingsParser { get; internal set; }
    internal ITargetedNotificationsParser TargetedNotificationsParser { get; internal set; }
    internal IRemoteSettingsValidator RemoteSettingsValidator { get; internal set; }
    internal IEnumerable`1<Func`2<RemoteSettingsInitializer, IRemoteSettingsProvider>> RemoteSettingsProviders { get; internal set; }
    internal Func`2<RemoteSettingsInitializer, IStableRemoteSettingsProvider> StableRemoteSettingsProvider { get; internal set; }
    internal IHttpWebRequestFactory HttpWebRequestFactory { get; internal set; }
    internal Func`1<bool> IsUpdatedDisabled { get; internal set; }
    internal ILocalTestParser LocalTestParser { get; internal set; }
    internal IRemoteSettingsLogger RemoteSettingsLogger { get; internal set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UsePathPrefix();
    [CompilerGeneratedAttribute]
public void set_UsePathPrefix(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IScopeFilterProvider> get_ScopeFilterProviders();
    [CompilerGeneratedAttribute]
public void set_ScopeFilterProviders(IEnumerable`1<IScopeFilterProvider> value);
    [CompilerGeneratedAttribute]
public string get_RemoteSettingsFileName();
    [CompilerGeneratedAttribute]
public void set_RemoteSettingsFileName(string value);
    [CompilerGeneratedAttribute]
public ICollectionKeyValueStorage get_KeyValueStorage();
    [CompilerGeneratedAttribute]
public void set_KeyValueStorage(ICollectionKeyValueStorage value);
    [CompilerGeneratedAttribute]
public IExperimentationService get_ExperimentationService();
    [CompilerGeneratedAttribute]
public void set_ExperimentationService(IExperimentationService value);
    [CompilerGeneratedAttribute]
public ITelemetryNotificationService get_TelemetryNotificationService();
    [CompilerGeneratedAttribute]
public void set_TelemetryNotificationService(ITelemetryNotificationService value);
    [CompilerGeneratedAttribute]
public IRemoteSettingsTelemetry get_Telemetry();
    [CompilerGeneratedAttribute]
public void set_Telemetry(IRemoteSettingsTelemetry value);
    [CompilerGeneratedAttribute]
internal ITargetedNotificationsTelemetry get_TargetedNotificationsTelemetry();
    [CompilerGeneratedAttribute]
internal void set_TargetedNotificationsTelemetry(ITargetedNotificationsTelemetry value);
    [CompilerGeneratedAttribute]
internal ITargetedNotificationsCacheStorageProvider get_TargetedNotificationsCacheStorage();
    [CompilerGeneratedAttribute]
internal void set_TargetedNotificationsCacheStorage(ITargetedNotificationsCacheStorageProvider value);
    [CompilerGeneratedAttribute]
public RemoteSettingsFilterProvider get_FilterProvider();
    [CompilerGeneratedAttribute]
public void set_FilterProvider(RemoteSettingsFilterProvider value);
    [CompilerGeneratedAttribute]
public ICollectionKeyValueStorage get_NonScopedSettingsKeyValueStorage();
    [CompilerGeneratedAttribute]
public void set_NonScopedSettingsKeyValueStorage(ICollectionKeyValueStorage value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_StableSettingRootSubCollections();
    [CompilerGeneratedAttribute]
public void set_StableSettingRootSubCollections(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
internal IScopeParserFactory get_ScopeParserFactory();
    [CompilerGeneratedAttribute]
internal void set_ScopeParserFactory(IScopeParserFactory value);
    internal static RemoteSettingsInitializer BuildDefault();
    internal RemoteSettingsInitializer FillWithDefaults();
    [CompilerGeneratedAttribute]
internal IVersionedRemoteSettingsStorageHandler get_VersionedRemoteSettingsStorageHandler();
    [CompilerGeneratedAttribute]
internal void set_VersionedRemoteSettingsStorageHandler(IVersionedRemoteSettingsStorageHandler value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsStorageHandler get_CacheableRemoteSettingsStorageHandler();
    [CompilerGeneratedAttribute]
internal void set_CacheableRemoteSettingsStorageHandler(IRemoteSettingsStorageHandler value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsStorageHandler get_LocalTestRemoteSettingsStorageHandler();
    [CompilerGeneratedAttribute]
internal void set_LocalTestRemoteSettingsStorageHandler(IRemoteSettingsStorageHandler value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<IDirectoryReader> get_LocalTestDirectories();
    [CompilerGeneratedAttribute]
internal void set_LocalTestDirectories(IEnumerable`1<IDirectoryReader> value);
    [CompilerGeneratedAttribute]
internal Func`1<IRemoteSettingsStorageHandler> get_LiveRemoteSettingsStorageHandlerFactory();
    [CompilerGeneratedAttribute]
internal void set_LiveRemoteSettingsStorageHandlerFactory(Func`1<IRemoteSettingsStorageHandler> value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsStorageHandler get_NonScopedRemoteSettingsStorageHandler();
    [CompilerGeneratedAttribute]
internal void set_NonScopedRemoteSettingsStorageHandler(IRemoteSettingsStorageHandler value);
    [CompilerGeneratedAttribute]
internal IRemoteFileReaderFactory get_RemoteFileReaderFactory();
    [CompilerGeneratedAttribute]
internal void set_RemoteFileReaderFactory(IRemoteFileReaderFactory value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsParser get_RemoteSettingsParser();
    [CompilerGeneratedAttribute]
internal void set_RemoteSettingsParser(IRemoteSettingsParser value);
    [CompilerGeneratedAttribute]
internal ITargetedNotificationsParser get_TargetedNotificationsParser();
    [CompilerGeneratedAttribute]
internal void set_TargetedNotificationsParser(ITargetedNotificationsParser value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsValidator get_RemoteSettingsValidator();
    [CompilerGeneratedAttribute]
internal void set_RemoteSettingsValidator(IRemoteSettingsValidator value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<Func`2<RemoteSettingsInitializer, IRemoteSettingsProvider>> get_RemoteSettingsProviders();
    [CompilerGeneratedAttribute]
internal void set_RemoteSettingsProviders(IEnumerable`1<Func`2<RemoteSettingsInitializer, IRemoteSettingsProvider>> value);
    [CompilerGeneratedAttribute]
internal Func`2<RemoteSettingsInitializer, IStableRemoteSettingsProvider> get_StableRemoteSettingsProvider();
    [CompilerGeneratedAttribute]
internal void set_StableRemoteSettingsProvider(Func`2<RemoteSettingsInitializer, IStableRemoteSettingsProvider> value);
    [CompilerGeneratedAttribute]
internal IHttpWebRequestFactory get_HttpWebRequestFactory();
    [CompilerGeneratedAttribute]
internal void set_HttpWebRequestFactory(IHttpWebRequestFactory value);
    [CompilerGeneratedAttribute]
internal Func`1<bool> get_IsUpdatedDisabled();
    [CompilerGeneratedAttribute]
internal void set_IsUpdatedDisabled(Func`1<bool> value);
    [CompilerGeneratedAttribute]
internal ILocalTestParser get_LocalTestParser();
    [CompilerGeneratedAttribute]
internal void set_LocalTestParser(ILocalTestParser value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsLogger get_RemoteSettingsLogger();
    [CompilerGeneratedAttribute]
internal void set_RemoteSettingsLogger(IRemoteSettingsLogger value);
    internal string GetLocalAppDataRoot();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsJsonLogFile : BaseJsonLogFile`1<RemoteSettingsLogMessage> {
    public RemoteSettingsJsonLogFile(ITelemetryWriter writer);
    protected virtual string ConvertEventToString(RemoteSettingsLogMessage eventData);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsLogger : TelemetryDisposableObject {
    private static string RemoteSettingsLogFolderName;
    private ITelemetryLogFile`1<RemoteSettingsLogMessage> logFile;
    private ITelemetryLogSettingsProvider settingsProvider;
    private RemoteSettingsFilterProvider filterProvider;
    private bool loggingEnabled;
    private Lazy`1<ConcurrentQueue`1<RemoteSettingsLogMessage>> buffer;
    private bool isStarted;
    private object flushLock;
    public bool LoggingEnabled { get; }
    private ConcurrentQueue`1<RemoteSettingsLogMessage> Buffer { get; }
    public RemoteSettingsLogger(RemoteSettingsFilterProvider remoteSettingsFilterProvider, bool loggingEnabled);
    public RemoteSettingsLogger(RemoteSettingsFilterProvider filterProvider, bool loggingEnabled, ITelemetryLogFile`1<RemoteSettingsLogMessage> logFile, ITelemetryLogSettingsProvider settingsProvider);
    public sealed virtual bool get_LoggingEnabled();
    private ConcurrentQueue`1<RemoteSettingsLogMessage> get_Buffer();
    public sealed virtual Task Start();
    public sealed virtual void LogError(string message);
    public sealed virtual void LogError(string description, Exception exception);
    public sealed virtual void LogInfo(string message);
    public sealed virtual void LogVerbose(string message);
    public sealed virtual void LogVerbose(string message, object data);
    protected virtual void DisposeManagedResources();
    private void LogMessage(RemoteSettingsLogMessage message);
    private void LogMessageNoBuffer(RemoteSettingsLogMessage message);
    private void FlushBufferAndStart();
    [CompilerGeneratedAttribute]
private void <Start>b__14_0();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsParser : object {
    internal static string FileVersionNotFirstPropertyErrorMessage;
    internal static string ChangesetIdNotSecondPropertyErrorMessage;
    internal static string TypeNotSupportedErrorMessageFormat;
    internal static string ScopesWasNotObjectErrorMessage;
    internal static string ScopeWasNotStringErrorMessage;
    internal static string InvalidJsonErrorMessage;
    internal static string UnhandledExceptionErrorMessageFormat;
    private IRemoteSettingsValidator remoteSettingsValidator;
    public RemoteSettingsParser(IRemoteSettingsValidator remoteSettingsValidator);
    private static RemoteSettingsParser();
    public sealed virtual VersionedDeserializedRemoteSettings TryParseVersionedStream(Stream stream);
    public sealed virtual DeserializedRemoteSettings TryParseFromJObject(JObject json, string globalScope);
    private DeserializedRemoteSettings ParseInternal(Queue`1<PropertyEntry> q, string globalScope);
    private static RemoteSetting ProcessRemoteSetting(string propertyPath, string propertyName, object value, string globalScope);
}
internal abstract class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsProviderBase : TelemetryDisposableObject {
    protected IRemoteSettingsStorageHandler currentStorageHandler;
    protected Task`1<GroupedRemoteSettings> startTask;
    protected IRemoteSettingsLogger logger;
    public string Name { get; }
    public RemoteSettingsProviderBase(IRemoteSettingsStorageHandler remoteSettingsStorageHandler, IRemoteSettingsLogger logger);
    public abstract virtual string get_Name();
    public sealed virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public sealed virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public sealed virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public sealed virtual bool CollectionExists(string collectionPath);
    public sealed virtual bool PropertyExists(string collectionPath, string propertyName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsProviderBase/<TryGetValueAsync>d__11`1")]
public sealed virtual Task`1<RemoteSettingsProviderResult`1<T>> TryGetValueAsync(string collectionPath, string key);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsProviderBase/<GetActionsAsync>d__12`1")]
public virtual Task`1<IEnumerable`1<ActionWrapper`1<T>>> GetActionsAsync(string actionPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsProviderBase/<SubscribeActionsAsync>d__13`1")]
public virtual Task SubscribeActionsAsync(string actionPath, Action`1<ActionWrapper`1<T>> callback);
    public virtual void UnsubscribeActions(string actionPath);
    public sealed virtual bool TryGetValue(string collectionPath, string key, T& value);
    public abstract virtual Task`1<GroupedRemoteSettings> Start();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsProviderResult`1 : object {
    [CompilerGeneratedAttribute]
private bool <RetrievalSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public bool RetrievalSuccessful { get; public set; }
    public T Value { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_RetrievalSuccessful();
    [CompilerGeneratedAttribute]
public void set_RetrievalSuccessful(bool value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsRemoteFileReader : TelemetryDisposableObject {
    private IRemoteControlClient remoteControlClient;
    public RemoteSettingsRemoteFileReader(IRemoteControlClient remoteControlClient);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsRemoteFileReader/<ReadFileAsync>d__2")]
public sealed virtual Task`1<Stream> ReadFileAsync();
    protected virtual void DisposeManagedResources();
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsRemoteFileReaderFactory : object {
    private static TimeSpan DownloadInterval;
    private static string DefaultBaseUrl;
    private static string DefaultHostId;
    private static string DefaultPath;
    private string fileNameOverride;
    public RemoteSettingsRemoteFileReaderFactory(string fileNameOverride);
    private static RemoteSettingsRemoteFileReaderFactory();
    public sealed virtual IRemoteFileReader Instance();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsStorageHandler : object {
    private ICollectionKeyValueStorage remoteSettingsStorage;
    private IScopeParserFactory scopeParserFactory;
    private IRemoteSettingsLogger logger;
    private bool isVersioned;
    private static string FileVersionKey;
    private static string SettingsVersionKey;
    private static string Separator;
    private static string MultipleValueIndicator;
    internal static int SettingsVersion;
    internal string CollectionPathPrefix;
    public string FileVersion { get; public set; }
    public int StoredSettingsVersion { get; public set; }
    private string CurrentCollectionPath { get; }
    public RemoteSettingsStorageHandler(ICollectionKeyValueStorage storage, string collectionPathPrefix, IScopeParserFactory scopeParserFactory, bool isVersioned, IRemoteSettingsLogger logger);
    public sealed virtual string get_FileVersion();
    public void set_FileVersion(string value);
    public int get_StoredSettingsVersion();
    public void set_StoredSettingsVersion(int value);
    private string get_CurrentCollectionPath();
    public sealed virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public sealed virtual bool CollectionExists(string collectionPath);
    public sealed virtual bool PropertyExists(string collectionPath, string propertyName);
    public sealed virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsStorageHandler/<TryGetValueAsync>d__23`1")]
public sealed virtual Task`1<RemoteSettingsProviderResult`1<T>> TryGetValueAsync(string collectionPath, string key);
    public sealed virtual bool TryGetValue(string collectionPath, string key, T& value);
    public sealed virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public sealed virtual bool DoSettingsNeedToBeUpdated(string newFileVersion);
    public sealed virtual void DeleteSettingsForFileVersion(string fileVersion);
    public sealed virtual void SaveNonScopedSetting(RemoteSetting setting);
    public sealed virtual void SaveSettings(GroupedRemoteSettings remoteSettings);
    public sealed virtual void SaveNonScopedSettings(GroupedRemoteSettings groupedSettings);
    public sealed virtual void SaveSettings(VersionedDeserializedRemoteSettings remoteSettings);
    public sealed virtual void CleanUpOldFileVersions(string newFileVersion);
    public sealed virtual void DeleteAllSettings();
    public sealed virtual void InvalidateFileVersion();
    public sealed virtual IEnumerable`1<string> GetAllScopes();
    public sealed virtual string GetScope(string scopeName);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsStorageHandler/<GetPossibleRemoteSettingKeys>d__37")]
private IEnumerable`1<SplitKey> GetPossibleRemoteSettingKeys(string collectionPath, string key);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsStorageHandler/<EvaluateScopedSettingAsync>d__38")]
private Task`1<bool> EvaluateScopedSettingAsync(LoggingContext`1<string> context);
    private bool EvaluateScopedSetting(LoggingContext`1<string> context);
    private void SaveSettingsInternal(string newCollectionPath, GroupedRemoteSettings groupedSettings);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsStorageHandlerFactory : object {
    private static string PathPrefix;
    private static string PathFormatWithPrefix;
    private static string IsDisabledName;
    private static string IsLoggingEnabled;
    private static int RemoteSettingsExplicitlyDisabled;
    private static int RemoteSettingsLoggingEnabled;
    private IRemoteSettingsLogger logger;
    private Regex fileNameRegex;
    public RemoteSettingsStorageHandlerFactory(IRemoteSettingsLogger logger);
    public static Func`1<bool> BuildIsUpdateDisabled(ICollectionKeyValueStorage storage, bool usePrefix);
    public static Func`1<bool> BuildIsLoggingEnabled(ICollectionKeyValueStorage storage, bool usePrefix);
    public sealed virtual IVersionedRemoteSettingsStorageHandler BuildVersioned(ICollectionKeyValueStorage storage, bool usePrefix, string fileName, IScopeParserFactory scopeParserFactory);
    public sealed virtual IRemoteSettingsStorageHandler Build(ICollectionKeyValueStorage storage, bool usePrefix, RemoteSettingsFilterProvider filterProvider, IScopeParserFactory scopeParserFactory);
    public sealed virtual IRemoteSettingsStorageHandler Build(ICollectionKeyValueStorage storage, bool usePrefix, string collectionPath, IScopeParserFactory scopeParserFactory);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsValidationException : Exception {
    public RemoteSettingsValidationException(string description);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsValidator : object {
    internal static string CyclesDetectedMessage;
    private ICycleDetection cycleDetection;
    private IScopesStorageHandler scopesStorageHandler;
    public RemoteSettingsValidator(ICycleDetection cycleDetection, IScopesStorageHandler scopesStorageHandler);
    private static RemoteSettingsValidator();
    public sealed virtual void ValidateDeserialized(DeserializedRemoteSettings remoteSettings);
    public sealed virtual void ValidateStored();
    private void ValidateScopes(IEnumerable`1<Scope> scopes);
}
internal class Microsoft.VisualStudio.RemoteSettings.Scope : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScopeString>k__BackingField;
    public string Name { get; public set; }
    public string ScopeString { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ScopeString();
    [CompilerGeneratedAttribute]
public void set_ScopeString(string value);
}
internal class Microsoft.VisualStudio.RemoteSettings.ScopeParser : object {
    private string expression;
    private Stack`1<Operand> output;
    private Stack`1<Operator> operators;
    private IDictionary`2<string, IScopeFilterProvider> providedFilters;
    private Regex stringRegex;
    private int expressionIndex;
    internal ScopeParser(string expression, IDictionary`2<string, IScopeFilterProvider> providedFilters);
    public bool Run();
    private void ParseOperator(Operator op);
    private void ParseOperand(Operand op);
    private Operator ScanOperator();
    private Operand ScanOperand();
    private void EvaluateOutput();
    private string GetRestOfExpression();
}
internal class Microsoft.VisualStudio.RemoteSettings.ScopeParserException : Exception {
    public ScopeParserException(string description);
}
internal class Microsoft.VisualStudio.RemoteSettings.ScopeParserFactory : object {
    private IDictionary`2<string, IScopeFilterProvider> providedFilters;
    private IRemoteSettingsLogger logger;
    public IDictionary`2<string, IScopeFilterProvider> ProvidedFilters { get; }
    public ScopeParserFactory(RemoteSettingsInitializer initializer);
    public sealed virtual IDictionary`2<string, IScopeFilterProvider> get_ProvidedFilters();
    public sealed virtual bool Evaluate(string scopeExpression);
    public sealed virtual Task`1<bool> EvaluateAsync(string scopeExpression);
}
internal class Microsoft.VisualStudio.RemoteSettings.ScopeScopeFilterProvider : object {
    private IScopesStorageHandler storage;
    private IScopeParserFactory scopeParserFactory;
    public string Name { get; }
    public ScopeScopeFilterProvider(IScopesStorageHandler storage, IScopeParserFactory factory);
    public sealed virtual string get_Name();
    public sealed virtual BoolScopeValue Provide(string key);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.ScopeScopeFilterProvider/<ProvideAsync>d__6")]
public sealed virtual Task`1<BoolScopeValue> ProvideAsync(string key);
}
public abstract class Microsoft.VisualStudio.RemoteSettings.ScopeValue : object {
    internal abstract virtual Operand GetOperand();
    internal abstract virtual AsyncOperand GetAsyncOperand();
}
public enum Microsoft.VisualStudio.RemoteSettings.SettingsType : Enum {
    public int value__;
    public static SettingsType Invalid;
    public static SettingsType Int32;
    public static SettingsType Int64;
    public static SettingsType String;
}
internal class Microsoft.VisualStudio.RemoteSettings.StableRemoteSettingsProvider : RemoteSettingsProviderBase {
    private HashSet`1<string> stableSettingRootSubCollections;
    public string Name { get; }
    public StableRemoteSettingsProvider(RemoteSettingsInitializer initializer);
    public virtual string get_Name();
    public sealed virtual bool IsStable(string collectionPath);
    public sealed virtual void MakeStable(string collectionPath, string key, T value);
    public virtual Task`1<GroupedRemoteSettings> Start();
}
public class Microsoft.VisualStudio.RemoteSettings.StringScopeValue : ScopeValue {
    private string value;
    public StringScopeValue(string value);
    internal virtual AsyncOperand GetAsyncOperand();
    internal virtual Operand GetOperand();
}
internal class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsCacheProvider : object {
    [CompilerGeneratedAttribute]
private ITargetedNotificationsCacheStorageProvider <Storage>k__BackingField;
    private ITargetedNotificationsTelemetry telemetry;
    private TargetedNotificationsProviderBase tnProvider;
    private bool enforceCourtesy;
    private TimeSpan defaultMaxWaitTimeSpan;
    private bool responseUsesCachedRules;
    private ITargetedNotificationsCacheStorageProvider Storage { get; private set; }
    public TargetedNotificationsCacheProvider(bool enforceCourtesy, TargetedNotificationsProviderBase tnProvider, RemoteSettingsInitializer initializer);
    [CompilerGeneratedAttribute]
private ITargetedNotificationsCacheStorageProvider get_Storage();
    [CompilerGeneratedAttribute]
private void set_Storage(ITargetedNotificationsCacheStorageProvider value);
    public void MergeNewResponse(ActionResponseBag newResponse, IEnumerable`1<string> previouslyCachedRuleIds, Nullable`1<int> timeoutMs);
    public IEnumerable`1<string> GetAllCachedRuleIds(Nullable`1<int> timeoutMs);
    public ActionResponse GetSendableAction(ActionResponse action, Nullable`1<int> timeoutMs);
    public IEnumerable`1<ActionResponse> GetSendableActionsFromSet(IEnumerable`1<ActionResponse> actions, Nullable`1<int> timeoutMs);
}
internal class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsException : Exception {
    public TargetedNotificationsException(string message);
    public TargetedNotificationsException(string message, Exception innerException);
}
internal class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsJsonStorageProvider : object {
    private string cacheDirectory;
    private string cacheFileFullPath;
    private static string cacheLockName;
    private static string cacheFileName;
    private ITargetedNotificationsTelemetry telemetry;
    private Lazy`1<Mutex> cacheLock;
    public TargetedNotificationsJsonStorageProvider(RemoteSettingsInitializer initializer);
    public sealed virtual bool Lock(Nullable`1<int> timeoutMs);
    public sealed virtual void Unlock();
    public sealed virtual void Reset();
    public sealed virtual CachedTargetedNotifications GetLocalCacheCopy();
    public sealed virtual void SetLocalCache(CachedTargetedNotifications newCache);
    [CompilerGeneratedAttribute]
private Mutex <.ctor>b__6_0();
}
internal class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsParser : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsParser/<ParseStreamAsync>d__0")]
public sealed virtual Task`1<ActionResponseBag> ParseStreamAsync(Stream stream, CancellationToken cancellationToken);
}
internal class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProvider : TargetedNotificationsProviderBase {
    internal static string DefaultUrl;
    private static string DefaultContentType;
    private static int DefaultRequestTimeout;
    private IHttpWebRequestFactory webRequestFactory;
    private ITargetedNotificationsParser notificationsParser;
    private RemoteSettingsFilterProvider remoteSettingsFilterProvider;
    public string Name { get; }
    public TargetedNotificationsProvider(RemoteSettingsInitializer initializer);
    public virtual string get_Name();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProvider/<GetTargetedNotificationActionsAsync>d__9")]
protected virtual Task`1<ActionResponseBag> GetTargetedNotificationActionsAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProvider/<ResolveUrlRedirectAsync>d__10")]
private Task`1<string> ResolveUrlRedirectAsync(string url, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProvider/<SendTargetedNotificationsRequestAsync>d__11")]
private Task`1<Stream> SendTargetedNotificationsRequestAsync(IEnumerable`1<string> previouslyCachedRuleIds, CancellationToken cancelToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProvider/<BuildRequestParametersAsync>d__12")]
private Task`1<string> BuildRequestParametersAsync(IEnumerable`1<string> previouslyCachedRuleIds, CancellationToken cancellationToken);
    private static string HandleGuidParameter(Guid guid);
    private static int HandleBoolParameter(bool value);
}
internal abstract class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase : RemoteSettingsProviderBase {
    internal static string TargetedNotificationsTelemetryEventPath;
    internal static string TargetedNotificationsTelemetryPropertyPath;
    internal IDictionary`2<string, ActionCategory> ActionCategories;
    protected static string RemoteSettingsActionPath;
    protected bool useCache;
    protected bool enforceCourtesy;
    protected int cacheTimeoutMs;
    protected TimeSpan serviceQueryLoopTimeSpan;
    protected CancellationTokenSource cancellationTokenSource;
    protected IRemoteSettingsTelemetry remoteSettingsTelemetry;
    protected ITargetedNotificationsTelemetry targetedNotificationsTelemetry;
    protected TargetedNotificationsCacheProvider notificationAndCourtesyCache;
    protected Stopwatch apiTimer;
    protected int queryIteration;
    private static string RemoteSettingsTelemetryEventPath;
    private static string RemoteSettingsTelemetryPropertyPath;
    private static string TargetedNotificationsCacheableStorageCollectionPath;
    private IDictionary`2<string, Dictionary`2<string, ActionResponse>> tnActions;
    private SemaphoreSlim actionsAndCategoriesLock;
    private IDictionary`2<string, List`1<int>> tnSubscriptionIds;
    private IDictionary`2<string, Dictionary`2<Type, IList>> tnSubscriptionCallbacks;
    private object subscriptionLockObject;
    private IRemoteSettingsStorageHandler cacheableStorageHandler;
    private IRemoteSettingsStorageHandler liveStorageHandler;
    private IRemoteSettingsParser remoteSettingsParser;
    private IExperimentationService experimentationService;
    private ITelemetryNotificationService telemetryNotificationService;
    public TargetedNotificationsProviderBase(IRemoteSettingsStorageHandler cacheableStorageHandler, RemoteSettingsInitializer initializer);
    public virtual Task`1<GroupedRemoteSettings> Start();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<StartAgainAfter>d__29")]
internal Task StartAgainAfter(TimeSpan delayTime);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<GetActionsAsync>d__30`1")]
public virtual Task`1<IEnumerable`1<ActionWrapper`1<T>>> GetActionsAsync(string actionPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<SubscribeActionsAsync>d__31`1")]
public virtual Task SubscribeActionsAsync(string actionPath, Action`1<ActionWrapper`1<T>> callback);
    public virtual void UnsubscribeActions(string actionPath);
    protected virtual void DisposeManagedResources();
    protected abstract virtual Task`1<ActionResponseBag> GetTargetedNotificationActionsAsync();
    private void ProcessActionResponseBag(ActionResponseBag response);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<ProcessRemoteSettingsFromTargetedNotificationsAsync>d__36")]
private Task`1<GroupedRemoteSettings> ProcessRemoteSettingsFromTargetedNotificationsAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<GetActionsInternalAsync>d__37`1")]
private Task`1<IEnumerable`1<LoggingContext`1<ActionWrapper`1<T>>>> GetActionsInternalAsync(string actionPath, bool shouldCheckFlight);
    private bool IsValidTriggerConfiguration(Dictionary`2<string, ITelemetryEventMatch> triggers, Dictionary`2<string, ActionTriggerOptions> options);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<SubscribeActionsInternalAsync>d__39`1")]
private Task SubscribeActionsInternalAsync(string actionPath, Action`1<ActionWrapper`1<T>> callback, IEnumerable`1<string> previouslySubscribedRuleIds);
    private T GetValueOrDefaultFromCacheableStorage(string collectionPath, string key, T defaultValue);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<<Start>b__28_0>d")]
[CompilerGeneratedAttribute]
private Task`1<GroupedRemoteSettings> <Start>b__28_0();
    [CompilerGeneratedAttribute]
private GroupedRemoteSettings <ProcessRemoteSettingsFromTargetedNotificationsAsync>b__36_3(GroupedRemoteSettings a, GroupedRemoteSettings b);
}
internal class Microsoft.VisualStudio.RemoteSettings.TestActionJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public enum Microsoft.VisualStudio.RemoteSettings.ValueKind : Enum {
    public int value__;
    public static ValueKind Unknown;
    public static ValueKind String;
    public static ValueKind MultiString;
    public static ValueKind DWord;
    public static ValueKind QWord;
}
internal class Microsoft.VisualStudio.RemoteSettings.VersionedDeserializedRemoteSettings : DeserializedRemoteSettings {
    [CompilerGeneratedAttribute]
private string <FileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangesetId>k__BackingField;
    public string FileVersion { get; }
    public string ChangesetId { get; }
    public VersionedDeserializedRemoteSettings(ReadOnlyCollection`1<Scope> scopes, ReadOnlyCollection`1<RemoteSetting> settings, string fileVersion, string changesetId, string error);
    public VersionedDeserializedRemoteSettings(DeserializedRemoteSettings remoteSettings, string fileVersion, string changesetId);
    [CompilerGeneratedAttribute]
public string get_FileVersion();
    [CompilerGeneratedAttribute]
public string get_ChangesetId();
}
internal class Microsoft.VisualStudio.RemoteSettings.VersionScopeFilterProvider : object {
    private DoubleScopeValue unknown;
    private Lazy`1<FileVersion> fileVersionInfo;
    public string Name { get; }
    public VersionScopeFilterProvider(RemoteSettingsFilterProvider filterProvider);
    public sealed virtual string get_Name();
    public sealed virtual DoubleScopeValue Provide(string key);
}
internal class Microsoft.VisualStudio.Telemetry.ActionPriorityConstants : object {
    public static int ManifestExcludePriority;
    public static int ManifestExcludePropertyPriority;
    public static int CustomOptOutPriority;
    public static int ManifestOptOutPriority;
    public static int ManifestThrottlingPriority;
    public static int ManifestHashedPriority;
    public static int ManifestPiiPriority;
    public static int ManifestCredScanPriority;
    public static int MetricPriority;
    public static int SettingPriority;
    public static int CredScanPriority;
    public static int PiiPriority;
    public static int EnforceAIRestrictionPriority;
    public static int ComplexPropertyPriority;
    public static int SuppressEmptyPostPropertyPriority;
    public static int ThrottlingPriority;
    public static int ManifestRoutePriority;
}
internal static class Microsoft.VisualStudio.Telemetry.ArchitectureTools : object {
    private static Lazy`1<SystemInfo> systemInformation;
    private static Dictionary`2<ProcessorArchitectureType, string> processorArchitectureName;
    private static ushort PROCESS_INFORMATION_CLASS_22000_ProcessMachineTypeInfo;
    private static ArchitectureTools();
    internal static void GetImageFileMachineArchitectures(String& processArch, String& nativeMachineArch);
    private static void GetImageFileMachineArchitectures(ProcessorArchitectureType& processArch, ProcessorArchitectureType& nativeMachineArch);
    private static ProcessorArchitectureType ImageFileMachineToProcessArchitectureType(ushort imageFileMachine);
}
internal class Microsoft.VisualStudio.Telemetry.AssemblyPropertyProvider : object {
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
public class Microsoft.VisualStudio.Telemetry.AssetEvent : TelemetryEvent {
    private static string AssetEventPropertyPrefixName;
    private static string AssetIdPropertyName;
    private static string AssetEventVersionPropertyName;
    [CompilerGeneratedAttribute]
private string <AssetId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AssetEventVersion>k__BackingField;
    public string AssetId { get; }
    public int AssetEventVersion { get; }
    public AssetEvent(string eventName, string assetId, int assetEventVersion);
    public AssetEvent(string eventName, string assetId, int assetEventVersion, TelemetryEventCorrelation correlation);
    [CompilerGeneratedAttribute]
public string get_AssetId();
    [CompilerGeneratedAttribute]
public int get_AssetEventVersion();
}
public class Microsoft.VisualStudio.Telemetry.AssetService : object {
    private object locker;
    private ConcurrentDictionary`2<string, IAssetProvider> registeredProviders;
    private ConcurrentDictionary`2<CacheKey, TelemetryEventCorrelation> registeredCorrelations;
    private static Lazy`1<AssetService> lazyAssetService;
    [CompilerGeneratedAttribute]
private IAssetServiceThreadScheduler <ThreadScheduler>k__BackingField;
    private IAssetServiceThreadScheduler ThreadScheduler { get; }
    public static AssetService Instance { get; }
    internal AssetService(IAssetServiceThreadScheduler scheduler);
    private static AssetService();
    [CompilerGeneratedAttribute]
private IAssetServiceThreadScheduler get_ThreadScheduler();
    public static AssetService get_Instance();
    public void RegisterCorrelation(string assetTypeName, Guid assetId, TelemetryEventCorrelation correlation);
    public void RegisterCorrelation(string assetTypeName, string assetId, TelemetryEventCorrelation correlation);
    public void UnregisterCorrelation(string assetTypeName, Guid assetId);
    public void UnregisterCorrelation(string assetTypeName, string assetId);
    public void RegisterProvider(string assetTypeName, IAssetProvider assetProvider);
    public void UnregisterProvider(string assetTypeName);
    public TelemetryEventCorrelation GetCorrelation(string assetTypeName, Guid assetId);
    public TelemetryEventCorrelation GetCorrelation(string assetTypeName, string assetId);
}
internal abstract class Microsoft.VisualStudio.Telemetry.BaseHostRealtimePropertyProvider : object {
    private IHostInformationProvider hostInformationProvider;
    public BaseHostRealtimePropertyProvider(IHostInformationProvider hostInformationProvider);
    public sealed virtual void AddRealtimeSharedProperties(List`1<KeyValuePair`2<string, Func`1<object>>> sharedProperties, TelemetryContext telemetryContext);
    public abstract virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    [CompilerGeneratedAttribute]
private object <AddRealtimeSharedProperties>b__2_0();
}
internal abstract class Microsoft.VisualStudio.Telemetry.BaseJsonLogFile`1 : TelemetryDisposableObject {
    private object telemetryWriterLocker;
    private ITelemetryWriter telemetryWriter;
    private bool writeComma;
    private bool isInitialized;
    protected ITelemetryLogSettingsProvider settingsProvider;
    public BaseJsonLogFile`1(ITelemetryWriter writer);
    public sealed virtual void Initialize(ITelemetryLogSettingsProvider settingsProvider);
    public sealed virtual void WriteAsync(T eventData);
    protected abstract virtual string ConvertEventToString(T eventData);
    protected virtual void DisposeManagedResources();
    private void WriteHeader();
    private void WriteFooter();
}
internal static class Microsoft.VisualStudio.Telemetry.BiosFirmwareTableParser : object {
    private static string BiosSerialNumberNotAvailable;
    internal static int MinimumTableLength;
    [CompilerGeneratedAttribute]
private static Version <MinimumSupportedBiosVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static Dictionary`2<int, Func`3<BinaryReader, BiosInformation, BiosInformation>> <SectionProcessorLookup>k__BackingField;
    private static Version MinimumSupportedBiosVersion { get; }
    private static Dictionary`2<int, Func`3<BinaryReader, BiosInformation, BiosInformation>> SectionProcessorLookup { get; }
    private static BiosFirmwareTableParser();
    [CompilerGeneratedAttribute]
private static Version get_MinimumSupportedBiosVersion();
    [CompilerGeneratedAttribute]
private static Dictionary`2<int, Func`3<BinaryReader, BiosInformation, BiosInformation>> get_SectionProcessorLookup();
    internal static BiosInformation ParseBiosFirmwareTable(Byte[] biosFirmwareTable);
    private static int GoToNextSectionToParse(BinaryReader br);
    private static IList`1<string> GetSringsFromStringsSection(BinaryReader br);
    private static BiosInformation ProcessBiosSystemInformation(BinaryReader br, BiosInformation biosInformation);
    internal static BiosInformation ParseBiosFirmwareTable(Stream biosFirmwareTable);
}
internal enum Microsoft.VisualStudio.Telemetry.BiosFirmwareTableParserError : Enum {
    public int value__;
    public static BiosFirmwareTableParserError Success;
    public static BiosFirmwareTableParserError SpecVersionUnsupported;
    public static BiosFirmwareTableParserError TableTooSmall;
    public static BiosFirmwareTableParserError RequiredSectionNotFound;
    public static BiosFirmwareTableParserError SerialNumberOrdinalIndexOutOfBound;
}
internal class Microsoft.VisualStudio.Telemetry.BiosInformation : ValueType {
    public Version SpecVersion;
    public long TableSize;
    public string SerialNumber;
    public Guid UUID;
    public BiosFirmwareTableParserError Error;
}
internal enum Microsoft.VisualStudio.Telemetry.ChannelInternalSetting : Enum {
    public int value__;
    public static ChannelInternalSetting Undefined;
    public static ChannelInternalSetting ExplicitlyDisabled;
    public static ChannelInternalSetting ExplicitlyEnabled;
}
internal class Microsoft.VisualStudio.Telemetry.ClientSideThrottlingAction : object {
    private static long BaseThreshold;
    private static string UnknownValue;
    private HashSet`1<string> passthroughEvents;
    private HashSet`1<string> droppedEvents;
    private HashSet`1<string> noisyAllowedListEvents;
    private long counter;
    private long allowedListCounter;
    private double resetCounter;
    private long threshold;
    private DateTimeOffset bucketStartTime;
    public int Priority { get; }
    public ClientSideThrottlingAction(IEnumerable`1<string> passthroughEvents, double resetCounterOverride, long thresholdOverride);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void PostDiagnosticInformation(TelemetrySession mainSession, TelemetryManifest newManifest);
    public void AddPassthroughEventName(string eventName);
    private void Reset(TelemetrySession mainSession, TelemetryManifest newManifest, DateTimeOffset timeToReset);
}
internal class Microsoft.VisualStudio.Telemetry.CommonProperty.FileBasedKeyValuesLoader : object {
    internal static string LoadCommonPropsEventName;
    internal static string LoadCommonPropsFaultDescription;
    internal static string LoadCommonPropsFaultEventName;
    private static FileBasedKeyValuesLoader();
    public sealed virtual IDictionary`2<string, object> GetData(TelemetrySession session, string filePath);
}
internal interface Microsoft.VisualStudio.Telemetry.CommonProperty.IExternalKeyValuesLoader {
    public abstract virtual IDictionary`2<string, object> GetData(TelemetrySession session, string source);
}
internal class Microsoft.VisualStudio.Telemetry.ComplexObjectSerializerException : Exception {
    public ComplexObjectSerializerException(string message, Exception innerException);
}
internal class Microsoft.VisualStudio.Telemetry.ComplexPropertyAction : object {
    internal static int MaxSerializedLength;
    internal static string FailedToSerializePropertyName;
    internal static string TruncatedPropertyName;
    private IComplexObjectSerializerFactory serializerFactory;
    private IPiiPropertyProcessor piiProcessor;
    private Func`2<object, string> converterToHashValue;
    private Func`2<object, string> converterToRawValue;
    private IComplexObjectSerializer serializer;
    public int Priority { get; }
    public ComplexPropertyAction(IComplexObjectSerializerFactory serializerFactory, IPiiPropertyProcessor piiProcessor);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    private void EnsureSerializerIsInitialized();
    private void SerializeProperty(string propertyName, TelemetryComplexProperty propertyValue, IEventProcessorContext eventProcessorContext, List`1<KeyValuePair`2<string, string>> propertiesToModify);
    [CompilerGeneratedAttribute]
private string <.ctor>b__10_0(object value);
    [CompilerGeneratedAttribute]
private string <.ctor>b__10_1(object value);
}
internal class Microsoft.VisualStudio.Telemetry.CredScanAction : object {
    internal static string ElapsedTimePropertyName;
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
}
public static class Microsoft.VisualStudio.Telemetry.DataModelEventNameHelper : object {
    private static char Separator;
    public static void SetProductFeatureEntityName(OperationEvent operationEvent);
    public static void SetProductFeatureEntityName(FaultEvent faultEvent);
    public static void SetProductFeatureEntityName(AssetEvent assetEvent);
    private static void SetProductFeatureEntityName(string eventName, PrefixedNotConcurrent`1<object> reservedProperties);
    private static void ValidateEventName(string eventName);
}
public enum Microsoft.VisualStudio.Telemetry.DataModelEventType : Enum {
    public int value__;
    public static DataModelEventType UserTask;
    public static DataModelEventType Trace;
    public static DataModelEventType Operation;
    public static DataModelEventType Fault;
    public static DataModelEventType Asset;
}
internal static class Microsoft.VisualStudio.Telemetry.DataModelEventTypeNames : object {
    internal static string GetName(DataModelEventType eventType);
}
internal abstract class Microsoft.VisualStudio.Telemetry.DataModelPropertyAction`1 : object {
    private HashSet`1<string> properties;
    private static string UnknownValue;
    private int totalPropertyCount;
    private string flagPropertyName;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuffixName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DiagnosticName>k__BackingField;
    public int Priority { get; }
    public string SuffixName { get; }
    public string DiagnosticName { get; }
    public DataModelPropertyAction`1(int priority, string suffixName, string flagName, string diagnosticName);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public string get_SuffixName();
    [CompilerGeneratedAttribute]
public string get_DiagnosticName();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void PostDiagnosticInformation(TelemetrySession mainSession, TelemetryManifest newManifest);
}
internal class Microsoft.VisualStudio.Telemetry.DataModelPropertyNames : object {
    internal static string DataModelPrefix;
    internal static string DataModelSource;
    internal static string EventType;
    internal static string EventSchemaVersion;
    internal static string ProductName;
    internal static string FeatureName;
    internal static string EntityName;
    internal static string Severity;
    internal static string Correlation;
    internal static string CorrelationPrefix;
}
internal class Microsoft.VisualStudio.Telemetry.DefaultContextPropertyManager : TelemetryDisposableObject {
    private List`1<IPropertyProvider> propertyProviders;
    private CancellationTokenSource cancellationTokenSource;
    public DefaultContextPropertyManager(IEnumerable`1<IPropertyProvider> propertyProviders);
    public sealed virtual void AddPropertyProvider(IPropertyProvider propertyProvider);
    public sealed virtual void AddDefaultContextProperties(TelemetryContext telemetryContext);
    public sealed virtual void PostDefaultContextProperties(TelemetryContext telemetryContext);
    protected virtual void DisposeManagedResources();
    public sealed virtual void AddRealtimeDefaultContextProperties(TelemetryContext telemetryContext);
}
internal class Microsoft.VisualStudio.Telemetry.DiagnosticTelemetry : object {
    private ConcurrentDictionary`2<string, string> registrySettings;
    private static string RegistrySettingsPrefix;
    public sealed virtual void LogRegistrySettings(string settingsName, string value);
    public sealed virtual void PostDiagnosticTelemetryWhenSessionInitialized(TelemetrySession telemetrySession, IEnumerable`1<KeyValuePair`2<string, object>> propertyBag);
    private static bool ShouldHashTelemetryAssemblyPath(String& assemblyPath);
}
internal class Microsoft.VisualStudio.Telemetry.DisabledTelemetryChannelValidator : object {
    private IInternalSettings internalSettings;
    public DisabledTelemetryChannelValidator(IInternalSettings internalSettings);
    public sealed virtual bool IsValid(ISessionChannel channelToValidate);
}
internal class Microsoft.VisualStudio.Telemetry.EnforceAIRestrictionAction : object {
    private static int MaxPropertyNameLength;
    private static int MaxPropertyValueLength;
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    private static bool IsPropertyValueValid(string value);
    private static bool IsPropertyNameValid(string propertyName);
}
internal class Microsoft.VisualStudio.Telemetry.EnvironmentTools : object {
    public string Version { get; }
    public sealed virtual string get_Version();
    public sealed virtual string GetEnvironmentVariable(string key);
}
internal class Microsoft.VisualStudio.Telemetry.EventProcessor : TelemetryDisposableObject {
    private IEventProcessorContext eventProcessorContext;
    private TelemetrySession mainSession;
    private List`1<IEventProcessorAction> customActionList;
    private object updateManifestLock;
    private Lazy`1<ISensitiveDataScrubber> sensitiveDataScrubber;
    private static string RedactionString;
    private TelemetryManifest currentManifest;
    private bool diagnosticNeedsToBePosted;
    internal TelemetryManifest CurrentManifest { get; internal set; }
    internal IEventProcessorContext EventProcessorContext { get; }
    public EventProcessor(TelemetrySession session, IEventProcessorContext eventProcessorContext);
    internal TelemetryManifest get_CurrentManifest();
    internal void set_CurrentManifest(TelemetryManifest value);
    internal IEventProcessorContext get_EventProcessorContext();
    public sealed virtual void ProcessEvent(TelemetryEvent telemetryEvent);
    private static void ScrubPropertiesAndReservedProperties(TelemetryEvent telemetryEvent, ISensitiveDataScrubber scrubber);
    private static void ScrubProperties(IDictionary`2<string, object> properties, ISensitiveDataScrubber scrubber, bool scrubAllPersonalData);
    public void AddChannel(ISessionChannel channel);
    public sealed virtual void AddCustomAction(IEventProcessorAction eventProcessorAction);
    public void PostDiagnosticInformationIfNeeded();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.EventProcessor/<DisposeAndTransmitAsync>d__20")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    protected virtual void DisposeManagedResources();
    private void UpdateManifest(TelemetryManifest manifestToBeUpdated);
    private void PostDiagnosticInformation(TelemetryManifest newManifest);
    private IEnumerable`1<IEventProcessorAction> GetMergedCustomAndManifestActionsInOrder(IEnumerable`1<ITelemetryManifestAction> manifestActions);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0();
}
internal class Microsoft.VisualStudio.Telemetry.EventProcessorChannelBuilder : object {
    private IPersistentPropertyBag persistentPropertyBag;
    private ITelemetryScheduler telemetryScheduler;
    [CompilerGeneratedAttribute]
private EventProcessor <EventProcessor>k__BackingField;
    [CompilerGeneratedAttribute]
private EventProcessorChannel <EventProcessorChannel>k__BackingField;
    [CompilerGeneratedAttribute]
private EventProcessorContext <EventProcessorContext>k__BackingField;
    [CompilerGeneratedAttribute]
private EventProcessorRouter <EventProcessorRouter>k__BackingField;
    public EventProcessor EventProcessor { get; private set; }
    public EventProcessorChannel EventProcessorChannel { get; private set; }
    public EventProcessorContext EventProcessorContext { get; private set; }
    public EventProcessorRouter EventProcessorRouter { get; private set; }
    public EventProcessorChannelBuilder(IPersistentPropertyBag persistentPropertyBag, ITelemetryScheduler telemetryScheduler);
    [CompilerGeneratedAttribute]
public EventProcessor get_EventProcessor();
    [CompilerGeneratedAttribute]
private void set_EventProcessor(EventProcessor value);
    [CompilerGeneratedAttribute]
public EventProcessorChannel get_EventProcessorChannel();
    [CompilerGeneratedAttribute]
private void set_EventProcessorChannel(EventProcessorChannel value);
    [CompilerGeneratedAttribute]
public EventProcessorContext get_EventProcessorContext();
    [CompilerGeneratedAttribute]
private void set_EventProcessorContext(EventProcessorContext value);
    [CompilerGeneratedAttribute]
public EventProcessorRouter get_EventProcessorRouter();
    [CompilerGeneratedAttribute]
private void set_EventProcessorRouter(EventProcessorRouter value);
    public void Build(TelemetrySession hostSession);
    private EventProcessorChannel BuildChannel(IEventProcessor eventProcessor, TelemetrySession telemetrySession);
    private EventProcessor BuildProcessor(TelemetrySession hostSession, IEventProcessorContext context);
    private EventProcessorContext BuildContext(TelemetrySession hostSession, IEventProcessorRouter eventProcessorRouter);
    private EventProcessorRouter BuildRouter();
}
internal class Microsoft.VisualStudio.Telemetry.EventProcessorContext : TelemetryDisposableObject {
    private TelemetrySession hostTelemetrySession;
    private IEventProcessorRouter eventProcessorRouter;
    private TelemetryEvent workerTelemetryEvent;
    private Dictionary`2<string, object> excludedProperties;
    [CompilerGeneratedAttribute]
private bool <IsEventDropped>k__BackingField;
    [CompilerGeneratedAttribute]
private ThrottlingAction <ThrottlingAction>k__BackingField;
    public bool IsEventDropped { get; public set; }
    public ThrottlingAction ThrottlingAction { get; public set; }
    public TelemetrySession HostTelemetrySession { get; }
    public IEventProcessorRouter Router { get; }
    public TelemetryEvent TelemetryEvent { get; }
    public EventProcessorContext(TelemetrySession hostTelemetrySession, IEventProcessorRouter eventProcessorRouter);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEventDropped();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsEventDropped(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ThrottlingAction get_ThrottlingAction();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ThrottlingAction(ThrottlingAction value);
    public sealed virtual TelemetrySession get_HostTelemetrySession();
    public sealed virtual IEventProcessorRouter get_Router();
    public sealed virtual TelemetryEvent get_TelemetryEvent();
    public sealed virtual void InitForNewEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void ExcludePropertyFromEvent(string propertyName);
    public sealed virtual void IncludePropertyToEvent(string propertyName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.EventProcessorContext/<DisposeAndTransmitAsync>d__22")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    protected virtual void DisposeManagedResources();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0();
}
internal class Microsoft.VisualStudio.Telemetry.EventProcessorRouter : TelemetryDisposableObject {
    private static string ChannelUsedProperty;
    private IPersistentPropertyBag persistentPropertyBag;
    private Stopwatch disposeLatencyTimer;
    private RouteInformation[] routeInformation;
    private Dictionary`2<string, int> channelMapping;
    private ConcurrentBag`1<ISessionChannel> channelList;
    public EventProcessorRouter(IPersistentPropertyBag persistentPropertyBag);
    public sealed virtual void Reset();
    public sealed virtual bool TryGetRouteArgument(string channelId, IEnumerable`1& routeArguments);
    public sealed virtual bool TryAddRouteArgument(string channelId, ITelemetryManifestRouteArgs routeArguments);
    public sealed virtual void DisableChannel(string channelId);
    public sealed virtual bool IsChannelDisabled(string channelId);
    public sealed virtual void AddChannel(ISessionChannel channel);
    public sealed virtual void RouteEvent(TelemetryEvent telemetryEvent, string sessionId, bool isDropped);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.EventProcessorRouter/<DisposeAndTransmitAsync>d__14")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    protected virtual void DisposeManagedResources();
    private void DisposeStart();
    private void DisposeEnd();
    private void RemoveAllChannels();
    private void OnUpdateChannelList();
    public sealed virtual void UpdateDefaultChannel(bool useCollector);
}
public class Microsoft.VisualStudio.Telemetry.FaultEvent : TelemetryEvent {
    internal static string InternalFaultEventName;
    internal static int WatsonMaxParamLength;
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <WatsonSamplePercent>k__BackingField;
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <MaximumWatsonReportsPerSession>k__BackingField;
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <MinimumSecondsBetweenWatsonReports>k__BackingField;
    [ObsoleteAttribute("This property is obsolete. Use TelemetrySession.BucketFiltersToEnableWatsonForFaults to enable Watson reports for fault events. They are disabled by default.", "False")]
public static List`1<BucketFilter> BucketFiltersToDisableWatsonReport;
    [ObsoleteAttribute("This property is obsolete. Use TelemetrySession.BucketFiltersToAddDumpsToFaults to add process dumps to fault events. They are disabled by default.", "False")]
public static List`1<BucketFilter> BucketFiltersToAddProcessDump;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsIncludedInWatsonSample>k__BackingField;
    [CompilerGeneratedAttribute]
private WER_DUMP_TYPE <DumpCollectionType>k__BackingField;
    internal static string watsonEventTypeVisualStudioNonFatalErrors2;
    [CompilerGeneratedAttribute]
private string <WatsonEventType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SynchronousDumpCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ExceptionObject>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IFaultUtility, int> <GatherEventDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultSeverity <FaultSeverity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PostThisEventToTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BucketParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<int> <ListProcessIdsToDump>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ListFilesToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <SBuilderAdditionalUserErrorInfo>k__BackingField;
    internal FaultEventWatsonOptIn UserOptInToWatson;
    [CompilerGeneratedAttribute]
private bool <AddedErrorInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddedProcessDump>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddedFile>k__BackingField;
    public static Nullable`1<int> WatsonSamplePercent { get; public set; }
    public static Nullable`1<int> MaximumWatsonReportsPerSession { get; public set; }
    public static Nullable`1<int> MinimumSecondsBetweenWatsonReports { get; public set; }
    public Nullable`1<bool> IsIncludedInWatsonSample { get; public set; }
    public WER_DUMP_TYPE DumpCollectionType { get; public set; }
    public string WatsonEventType { get; public set; }
    public bool SynchronousDumpCollection { get; public set; }
    internal string Description { get; }
    internal Exception ExceptionObject { get; }
    internal Func`2<IFaultUtility, int> GatherEventDetails { get; }
    internal FaultSeverity FaultSeverity { get; internal set; }
    internal bool PostThisEventToTelemetry { get; internal set; }
    internal String[] BucketParameters { get; internal set; }
    internal List`1<int> ListProcessIdsToDump { get; }
    internal List`1<string> ListFilesToAdd { get; }
    internal StringBuilder SBuilderAdditionalUserErrorInfo { get; }
    internal bool AddedErrorInformation { get; internal set; }
    internal bool AddedProcessDump { get; internal set; }
    internal bool AddedFile { get; internal set; }
    public FaultEvent(string eventName, string description, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails);
    public FaultEvent(string eventName, string description, FaultSeverity faultSeverity, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails);
    private static FaultEvent();
    [CompilerGeneratedAttribute]
public static Nullable`1<int> get_WatsonSamplePercent();
    [CompilerGeneratedAttribute]
public static void set_WatsonSamplePercent(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public static Nullable`1<int> get_MaximumWatsonReportsPerSession();
    [CompilerGeneratedAttribute]
public static void set_MaximumWatsonReportsPerSession(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public static Nullable`1<int> get_MinimumSecondsBetweenWatsonReports();
    [CompilerGeneratedAttribute]
public static void set_MinimumSecondsBetweenWatsonReports(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsIncludedInWatsonSample();
    [CompilerGeneratedAttribute]
public void set_IsIncludedInWatsonSample(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public WER_DUMP_TYPE get_DumpCollectionType();
    [CompilerGeneratedAttribute]
public void set_DumpCollectionType(WER_DUMP_TYPE value);
    [CompilerGeneratedAttribute]
public string get_WatsonEventType();
    [CompilerGeneratedAttribute]
public void set_WatsonEventType(string value);
    [CompilerGeneratedAttribute]
public bool get_SynchronousDumpCollection();
    [CompilerGeneratedAttribute]
public void set_SynchronousDumpCollection(bool value);
    [CompilerGeneratedAttribute]
internal string get_Description();
    [CompilerGeneratedAttribute]
internal Exception get_ExceptionObject();
    [CompilerGeneratedAttribute]
internal Func`2<IFaultUtility, int> get_GatherEventDetails();
    [CompilerGeneratedAttribute]
internal FaultSeverity get_FaultSeverity();
    [CompilerGeneratedAttribute]
internal void set_FaultSeverity(FaultSeverity value);
    [CompilerGeneratedAttribute]
internal bool get_PostThisEventToTelemetry();
    [CompilerGeneratedAttribute]
internal void set_PostThisEventToTelemetry(bool value);
    [CompilerGeneratedAttribute]
internal String[] get_BucketParameters();
    [CompilerGeneratedAttribute]
internal void set_BucketParameters(String[] value);
    [CompilerGeneratedAttribute]
internal List`1<int> get_ListProcessIdsToDump();
    [CompilerGeneratedAttribute]
internal List`1<string> get_ListFilesToAdd();
    [CompilerGeneratedAttribute]
internal StringBuilder get_SBuilderAdditionalUserErrorInfo();
    [CompilerGeneratedAttribute]
internal bool get_AddedErrorInformation();
    [CompilerGeneratedAttribute]
internal void set_AddedErrorInformation(bool value);
    [CompilerGeneratedAttribute]
internal bool get_AddedProcessDump();
    [CompilerGeneratedAttribute]
internal void set_AddedProcessDump(bool value);
    [CompilerGeneratedAttribute]
internal bool get_AddedFile();
    [CompilerGeneratedAttribute]
internal void set_AddedFile(bool value);
    public sealed virtual void AddErrorInformation(string information);
    public sealed virtual void AddProcessDump(int pid);
    public sealed virtual void SetBucketParameter(int bucketNumber, string newBucketValue);
    public void SetAppName(string appName);
    public void SetAppVersion(string appVersion);
    public void SetFailureParameters(string failureParameter0, string failureParameter1, string failureParameter2, string failureParameter3, string failureParameter4);
    public void SetNonFailureParameters(string nonFailureParameter0, string nonFailureParameter1);
    internal static string TrucateToMaxWatsonParamLength(string input);
    public sealed virtual string GetBucketParameter(int bucketNumber);
    public sealed virtual void AddFile(string fullPathFileName);
    public virtual string ToString();
    internal static WER_DUMP_TYPE GetDumpTypeFromString(string dumpType);
    [CompilerGeneratedAttribute]
private void <AddErrorInformation>b__79_0(string line);
}
public enum Microsoft.VisualStudio.Telemetry.FaultSeverity : Enum {
    public int value__;
    public static FaultSeverity Uncategorized;
    public static FaultSeverity Diagnostic;
    public static FaultSeverity General;
    public static FaultSeverity Critical;
    public static FaultSeverity Crash;
}
internal class Microsoft.VisualStudio.Telemetry.FipsCompliantSha : object {
    public static ThreadLocal`1<HashAlgorithm> Sha256;
    private static FipsCompliantSha();
    private static HashAlgorithm CreateEncryptor();
}
internal enum Microsoft.VisualStudio.Telemetry.HashInput : Enum {
    public int value__;
    public static HashInput MachineId;
    public static HashInput UserId;
    public static HashInput RuleId;
    public static HashInput SamplingId;
    public static HashInput SessionId;
}
public interface Microsoft.VisualStudio.Telemetry.IAssetProvider {
    public abstract virtual bool PostAsset(string assetId, TelemetryEventCorrelation correlation);
}
internal interface Microsoft.VisualStudio.Telemetry.IAssetServiceThreadScheduler {
    public abstract virtual void Schedule(Action action);
}
internal interface Microsoft.VisualStudio.Telemetry.IChannelValidator {
    public abstract virtual bool IsValid(ISessionChannel channelToValidate);
}
internal interface Microsoft.VisualStudio.Telemetry.IComplexObjectSerializer {
    public abstract virtual string Serialize(object obj);
    public abstract virtual void SetTypeConverter(Type type, Func`2<object, string> converter);
    public abstract virtual bool WasConverterUsedForType(Type type);
}
internal interface Microsoft.VisualStudio.Telemetry.IComplexObjectSerializerFactory {
    public abstract virtual IComplexObjectSerializer Instance();
}
internal interface Microsoft.VisualStudio.Telemetry.IContextPropertyManager {
    public abstract virtual void AddPropertyProvider(IPropertyProvider propertyProvider);
    public abstract virtual void AddDefaultContextProperties(TelemetryContext telemetryContext);
    public abstract virtual void AddRealtimeDefaultContextProperties(TelemetryContext telemetryContext);
    public abstract virtual void PostDefaultContextProperties(TelemetryContext telemetryContext);
}
internal abstract class Microsoft.VisualStudio.Telemetry.IdentityInformationProvider : object {
    public static string HardwareIdEventFaultName;
    internal static string PersistedIdentityNotFoundTemplate;
    internal static string IdChangeCausedInvalidationTemplate;
    internal static string EventParameterLastValueSuffix;
    internal static string ConfigVersionInvalidationTemplate;
    internal static string PrimaryIdValueNoLongerExistsTemplate;
    internal static string PrimaryIdValueNoLongerExists;
    internal static string HardwarePersistenceDate;
    internal static string HardwarePersistenceAge;
    internal static string IsMachineStoreAccessiblePropertyName;
    internal static string HardwareIdNotObtained;
    internal static string HardwareIdNotPeristed;
    private static string ExceptionObtainingHardwareIdFaultDescription;
    private static Lazy`1<IPGlobalProperties> IpGlobalProperties;
    private Lazy`1<IPersistentPropertyBag> lazyMachineStore;
    private Lazy`1<Dictionary`2<string, MachineIdentitifier>> lazyMachineIdentifiers;
    internal static Dictionary`2<string, string> StoredPropertyNamesToInts;
    private static Lazy`1<PIIPropertyProcessor> LazyPiiPropertyProcessor;
    private static object LazyPiiPropertyProcessorLockObject;
    private INetworkInterfacesInformationProvider networkInterfacesInformationProvider;
    [CompilerGeneratedAttribute]
private List`1<Exception> <ExceptionsEncounteredObtainingHardwareId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> HardwareIdCalculationCompleted;
    [CompilerGeneratedAttribute]
private bool <PersistedIdWasInvalidated>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PersistedIdInvalidationReason>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AnyValueChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryManifestMachineIdentityConfig <MachineIdentityConfig>k__BackingField;
    private Dictionary`2<string, MachineIdentitifier> MachineIdentifiers { get; }
    private List`1<Exception> ExceptionsEncounteredObtainingHardwareId { get; }
    private bool IsMachineStoreAccessible { get; }
    internal static string DefaultStorageFileName { get; }
    internal string ConfigVersion { get; }
    internal string MinValidConfigVersion { get; }
    internal bool InvalidateOnPrimaryIdChange { get; }
    internal String[] HardwareIdValues { get; }
    public string PersistedSelectedMACAddress { get; }
    public string PersistedSelectedInterface { get; }
    public bool PersistedIdWasInvalidated { get; protected set; }
    public string PersistedIdInvalidationReason { get; protected set; }
    public bool AnyValueChanged { get; protected set; }
    public string HardwareId { get; }
    public string MachineName { get; }
    public string DNSDomain { get; }
    public string BiosSerialNumber { get; }
    public Guid BiosUUID { get; }
    public BiosFirmwareTableParserError BiosInformationError { get; }
    public Nullable`1<DateTime> HardwareIdDate { get; }
    public string SelectedMACAddress { get; }
    public List`1<NetworkInterfaceCardInformation> PrioritizedNetworkInterfaces { get; }
    public TelemetryManifestMachineIdentityConfig MachineIdentityConfig { get; private set; }
    private string SelectedNetworkInterfaceDescription { get; }
    protected IdentityInformationProvider(Func`1<IPersistentPropertyBag> createStore);
    private static IdentityInformationProvider();
    private Dictionary`2<string, MachineIdentitifier> get_MachineIdentifiers();
    [CompilerGeneratedAttribute]
private List`1<Exception> get_ExceptionsEncounteredObtainingHardwareId();
    private bool get_IsMachineStoreAccessible();
    internal static string get_DefaultStorageFileName();
    private static string JoinIdentifiers(IEnumerable`1<MachineIdentitifier> ids, Func`2<MachineIdentitifier, string> transform);
    internal string get_ConfigVersion();
    internal string get_MinValidConfigVersion();
    internal bool get_InvalidateOnPrimaryIdChange();
    internal String[] get_HardwareIdValues();
    public sealed virtual string get_PersistedSelectedMACAddress();
    public string get_PersistedSelectedInterface();
    [CompilerGeneratedAttribute]
public sealed virtual void add_HardwareIdCalculationCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_HardwareIdCalculationCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PersistedIdWasInvalidated();
    [CompilerGeneratedAttribute]
protected void set_PersistedIdWasInvalidated(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PersistedIdInvalidationReason();
    [CompilerGeneratedAttribute]
protected void set_PersistedIdInvalidationReason(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AnyValueChanged();
    [CompilerGeneratedAttribute]
protected void set_AnyValueChanged(bool value);
    public sealed virtual string get_HardwareId();
    public sealed virtual void GetHardwareIdWithCalculationCompletedEvent(Action`1<string> callback);
    public sealed virtual string get_MachineName();
    public sealed virtual string get_DNSDomain();
    public abstract virtual string get_BiosSerialNumber();
    public abstract virtual Guid get_BiosUUID();
    public abstract virtual BiosFirmwareTableParserError get_BiosInformationError();
    public sealed virtual Nullable`1<DateTime> get_HardwareIdDate();
    public sealed virtual string get_SelectedMACAddress();
    public sealed virtual List`1<NetworkInterfaceCardInformation> get_PrioritizedNetworkInterfaces();
    [CompilerGeneratedAttribute]
public sealed virtual TelemetryManifestMachineIdentityConfig get_MachineIdentityConfig();
    [CompilerGeneratedAttribute]
private void set_MachineIdentityConfig(TelemetryManifestMachineIdentityConfig value);
    public sealed virtual void Initialize(TelemetryContext telemetryContext, ITelemetryScheduler contextScheduler, TelemetryManifestMachineIdentityConfig machineIdentityConfig);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.IdentityInformationProvider/<CollectIdentifiers>d__82")]
public sealed virtual IEnumerable`1<KeyValuePair`2<string, object>> CollectIdentifiers(List`1<Exception> collectionExceptions);
    public sealed virtual void SchedulePostPersistedSharedPropertyAndSendAnyFaults(TelemetrySession telemetrySession, ITelemetryScheduler scheduler);
    private void PostAnyFaultsGettingHardwareId(TelemetrySession telemetrySession, CancellationToken cancellationToken);
    private void PostPersistedSharedProperties(TelemetrySession telemetrySession, CancellationToken cancellationToken);
    private string GetHardwareIdWithInvalidation();
    internal static string FormatPropertyValue(T value);
    private bool MACAddressStillExists(string mac);
    private bool NetworkInterfaceStillExists(string interfaceDescription);
    private Dictionary`2<string, MachineIdentitifier> ConfigureIdentities();
    private string get_SelectedNetworkInterfaceDescription();
    private static IPGlobalProperties InitializeIpGlobalProperties();
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MachineIdentitifier> <.ctor>b__27_0();
    [CompilerGeneratedAttribute]
private MachineIdentitifier <GetHardwareIdWithInvalidation>b__86_2(string name);
    [CompilerGeneratedAttribute]
private MachineIdentitifier <GetHardwareIdWithInvalidation>b__86_4(string name);
    [CompilerGeneratedAttribute]
private bool <GetHardwareIdWithInvalidation>b__86_5(MachineIdentitifier id);
    [CompilerGeneratedAttribute]
private MachineIdentitifier <GetHardwareIdWithInvalidation>b__86_0(string idName);
}
internal class Microsoft.VisualStudio.Telemetry.IdentityPropertyProvider : object {
    internal static string HardwareIdPropertyName;
    private static IdentityPropertyProvider();
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
internal class Microsoft.VisualStudio.Telemetry.IdentityTelemetry : object {
    public static string EvaluationValuesEventName;
    public static string EvaluationValuesEventFaultName;
    public static string ChangeDetectedPropertyName;
    internal static string propertyPrefix;
    [CompilerGeneratedAttribute]
private IIdentityInformationProvider <IdentityInformationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryScheduler <Scheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    private List`1<KeyValuePair`2<string, Exception>> exceptions;
    private bool SendIdentityValuesEvent { get; }
    public IIdentityInformationProvider IdentityInformationProvider { get; }
    private ITelemetryScheduler Scheduler { get; }
    private CancellationToken CancellationToken { get; }
    public IdentityTelemetry(IIdentityInformationProvider identityInformationProvider, ITelemetryScheduler scheduler);
    private static IdentityTelemetry();
    private bool get_SendIdentityValuesEvent();
    [CompilerGeneratedAttribute]
public sealed virtual IIdentityInformationProvider get_IdentityInformationProvider();
    [CompilerGeneratedAttribute]
private ITelemetryScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
private CancellationToken get_CancellationToken();
    public sealed virtual void PostIdentityTelemetryWhenSessionInitialized(TelemetrySession telemetrySession);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.IdentityTelemetry/<GetIdentityProperties>d__18")]
private IEnumerable`1<KeyValuePair`2<string, object>> GetIdentityProperties(CancellationToken cancellationToken);
    private void CollectAndSendIdentityEvaluationValuesEvent(TelemetrySession telemetrySession, CancellationToken cancellationToken);
}
internal interface Microsoft.VisualStudio.Telemetry.IDiagnosticTelemetry {
    public abstract virtual void LogRegistrySettings(string settingsName, string value);
    public abstract virtual void PostDiagnosticTelemetryWhenSessionInitialized(TelemetrySession telemetrySession, IEnumerable`1<KeyValuePair`2<string, object>> propertyBag);
}
internal interface Microsoft.VisualStudio.Telemetry.IEnvironmentTools {
    public string Version { get; }
    public abstract virtual string get_Version();
    public abstract virtual string GetEnvironmentVariable(string key);
}
internal interface Microsoft.VisualStudio.Telemetry.IEventProcessor {
    public abstract virtual void ProcessEvent(TelemetryEvent telemetryEvent);
    public abstract virtual void AddCustomAction(IEventProcessorAction eventProcessorAction);
    public abstract virtual Task DisposeAndTransmitAsync(CancellationToken token);
}
internal interface Microsoft.VisualStudio.Telemetry.IEventProcessorAction {
    public int Priority { get; }
    public abstract virtual int get_Priority();
    public abstract virtual bool Execute(IEventProcessorContext eventProcessorContext);
}
internal interface Microsoft.VisualStudio.Telemetry.IEventProcessorActionDiagnostics {
    public abstract virtual void PostDiagnosticInformation(TelemetrySession mainSession, TelemetryManifest newManifest);
}
internal interface Microsoft.VisualStudio.Telemetry.IEventProcessorContext {
    public bool IsEventDropped { get; public set; }
    public ThrottlingAction ThrottlingAction { get; public set; }
    public TelemetrySession HostTelemetrySession { get; }
    public IEventProcessorRouter Router { get; }
    public TelemetryEvent TelemetryEvent { get; }
    public abstract virtual bool get_IsEventDropped();
    public abstract virtual void set_IsEventDropped(bool value);
    public abstract virtual ThrottlingAction get_ThrottlingAction();
    public abstract virtual void set_ThrottlingAction(ThrottlingAction value);
    public abstract virtual TelemetrySession get_HostTelemetrySession();
    public abstract virtual IEventProcessorRouter get_Router();
    public abstract virtual TelemetryEvent get_TelemetryEvent();
    public abstract virtual void InitForNewEvent(TelemetryEvent telemetryEvent);
    public abstract virtual void ExcludePropertyFromEvent(string propertyName);
    public abstract virtual void IncludePropertyToEvent(string propertyName);
    public abstract virtual Task DisposeAndTransmitAsync(CancellationToken token);
}
internal interface Microsoft.VisualStudio.Telemetry.IEventProcessorRouter {
    public abstract virtual void Reset();
    public abstract virtual bool TryGetRouteArgument(string channelId, IEnumerable`1& routeArguments);
    public abstract virtual bool TryAddRouteArgument(string channelId, ITelemetryManifestRouteArgs routeArgument);
    public abstract virtual void DisableChannel(string channelId);
    public abstract virtual bool IsChannelDisabled(string channelId);
    public abstract virtual void AddChannel(ISessionChannel channel);
    public abstract virtual void RouteEvent(TelemetryEvent telemetryEvent, string sessionId, bool isDropped);
    public abstract virtual Task DisposeAndTransmitAsync(CancellationToken token);
    public abstract virtual void UpdateDefaultChannel(bool useCollector);
}
public interface Microsoft.VisualStudio.Telemetry.IFaultUtility {
    public abstract virtual void AddErrorInformation(string information);
    public abstract virtual void AddProcessDump(int pid);
    public abstract virtual void AddFile(string fullpathname);
    public abstract virtual void SetBucketParameter(int bucketNumber, string value);
    public abstract virtual string GetBucketParameter(int bucketNumber);
}
internal interface Microsoft.VisualStudio.Telemetry.IHostInformationProvider {
    public string ProcessName { get; }
    public UInt32 ProcessId { get; }
    public string ProcessExeVersion { get; }
    public Nullable`1<int> ProcessBuildNumber { get; }
    public bool IsDebuggerAttached { get; }
    public bool Is64BitProcess { get; }
    public string OSBitness { get; }
    public abstract virtual string get_ProcessName();
    public abstract virtual UInt32 get_ProcessId();
    public abstract virtual string get_ProcessExeVersion();
    public abstract virtual Nullable`1<int> get_ProcessBuildNumber();
    public abstract virtual bool get_IsDebuggerAttached();
    public abstract virtual bool get_Is64BitProcess();
    public abstract virtual string get_OSBitness();
}
internal interface Microsoft.VisualStudio.Telemetry.IIdentityInformationProvider {
    public bool AnyValueChanged { get; }
    public bool PersistedIdWasInvalidated { get; }
    public string PersistedIdInvalidationReason { get; }
    public string PersistedSelectedMACAddress { get; }
    public string MachineName { get; }
    public string DNSDomain { get; }
    public string BiosSerialNumber { get; }
    public Guid BiosUUID { get; }
    public string HardwareId { get; }
    public Nullable`1<DateTime> HardwareIdDate { get; }
    public BiosFirmwareTableParserError BiosInformationError { get; }
    public string SelectedMACAddress { get; }
    public List`1<NetworkInterfaceCardInformation> PrioritizedNetworkInterfaces { get; }
    public TelemetryManifestMachineIdentityConfig MachineIdentityConfig { get; }
    public abstract virtual bool get_AnyValueChanged();
    public abstract virtual bool get_PersistedIdWasInvalidated();
    public abstract virtual string get_PersistedIdInvalidationReason();
    public abstract virtual string get_PersistedSelectedMACAddress();
    public abstract virtual string get_MachineName();
    public abstract virtual string get_DNSDomain();
    public abstract virtual string get_BiosSerialNumber();
    public abstract virtual Guid get_BiosUUID();
    public abstract virtual string get_HardwareId();
    public abstract virtual Nullable`1<DateTime> get_HardwareIdDate();
    public abstract virtual BiosFirmwareTableParserError get_BiosInformationError();
    public abstract virtual string get_SelectedMACAddress();
    public abstract virtual List`1<NetworkInterfaceCardInformation> get_PrioritizedNetworkInterfaces();
    [CompilerGeneratedAttribute]
public abstract virtual void add_HardwareIdCalculationCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_HardwareIdCalculationCompleted(EventHandler`1<EventArgs> value);
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, object>> CollectIdentifiers(List`1<Exception> collectionExceptions);
    public abstract virtual void SchedulePostPersistedSharedPropertyAndSendAnyFaults(TelemetrySession telemetrySession, ITelemetryScheduler scheduler);
    public abstract virtual void GetHardwareIdWithCalculationCompletedEvent(Action`1<string> callback);
    public abstract virtual TelemetryManifestMachineIdentityConfig get_MachineIdentityConfig();
    public abstract virtual void Initialize(TelemetryContext telemetryContext, ITelemetryScheduler contextScheduler, TelemetryManifestMachineIdentityConfig machineIdentityConfig);
}
internal interface Microsoft.VisualStudio.Telemetry.IIdentityTelemetry {
    public IIdentityInformationProvider IdentityInformationProvider { get; }
    public abstract virtual IIdentityInformationProvider get_IdentityInformationProvider();
    public abstract virtual void PostIdentityTelemetryWhenSessionInitialized(TelemetrySession telemetrySession);
}
internal interface Microsoft.VisualStudio.Telemetry.IInternalSettings {
    public abstract virtual bool IsForcedUserExternal();
    public abstract virtual bool TryGetTestHostName(String& testHostName);
    public abstract virtual bool TryGetTestAppId(UInt32& testAppId);
    public abstract virtual ChannelInternalSetting GetChannelSettings(string channelId);
    public abstract virtual string GetIPGlobalConfigDomainName();
    public abstract virtual bool IsTelemetryDisabledCompletely();
    public abstract virtual bool IsLocalLoggerEnabled();
    public abstract virtual int FaultEventWatsonSamplePercent();
    public abstract virtual int FaultEventMaximumWatsonReportsPerSession();
    public abstract virtual int FaultEventMinimumSecondsBetweenWatsonReports();
}
internal interface Microsoft.VisualStudio.Telemetry.ILegacyApi {
    public abstract virtual Guid ReadSharedMachineId();
    public abstract virtual bool SetSharedMachineId(Guid machineId);
    public abstract virtual Guid ReadSharedUserId();
}
internal interface Microsoft.VisualStudio.Telemetry.IMachineInformationProvider {
    public Guid MachineId { get; }
    public abstract virtual Guid get_MachineId();
}
internal interface Microsoft.VisualStudio.Telemetry.IMACInformationProvider {
    [CompilerGeneratedAttribute]
public abstract virtual void add_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    public abstract virtual void RunProcessIfNecessary(Action`1<string> onComplete);
    public abstract virtual string GetMACAddressHash();
}
internal interface Microsoft.VisualStudio.Telemetry.INetworkInterfacesInformationProvider {
    public string SelectedMACAddress { get; }
    public List`1<NetworkInterfaceCardInformation> PrioritizedNetworkInterfaces { get; }
    public abstract virtual string get_SelectedMACAddress();
    public abstract virtual List`1<NetworkInterfaceCardInformation> get_PrioritizedNetworkInterfaces();
}
internal interface Microsoft.VisualStudio.Telemetry.INsBundleInformationProvider {
    public abstract virtual string GetName();
    public abstract virtual string GetVersion();
}
internal class Microsoft.VisualStudio.Telemetry.InternalChannelValidator : object {
    private IUserInformationProvider userInformationProvider;
    public InternalChannelValidator(IUserInformationProvider theUserInformationProvider);
    public sealed virtual bool IsValid(ISessionChannel channelToValidate);
}
internal class Microsoft.VisualStudio.Telemetry.InternalSettingsBase : object {
    internal static string TelemetryUserRegKeyPath;
    internal static string CompletelyDisabledTelemetryRegKeyName;
    internal static string LocalLoggerEnabledRegKeyName;
    internal static int LocalLoggerEnabled;
    internal static int CompletelyDisabledTelemetry;
    private static string RegKeyChannelSettings;
    private static int ChannelExplicitlyEnabled;
    private static int ChannelExplicitlyDisabled;
    private static string ForceExternalUserRegKeyName;
    private static int ForcedUserExternal;
    private static string TestHostNameRegKeyName;
    private static string TestAppIdRegKeyName;
    protected IRegistryTools registryTools;
    protected IDiagnosticTelemetry diagnosticTelemetry;
    public InternalSettingsBase(IDiagnosticTelemetry diagnosticTelemetry, IRegistryTools registryTools);
    public virtual ChannelInternalSetting GetChannelSettings(string channelId);
    public sealed virtual bool IsForcedUserExternal();
    public sealed virtual bool TryGetTestAppId(UInt32& testAppId);
    public sealed virtual bool TryGetTestHostName(String& testHostName);
    public sealed virtual string GetIPGlobalConfigDomainName();
    public sealed virtual bool IsTelemetryDisabledCompletely();
    public sealed virtual bool IsLocalLoggerEnabled();
    public virtual int FaultEventWatsonSamplePercent();
    public virtual int FaultEventMaximumWatsonReportsPerSession();
    public virtual int FaultEventMinimumSecondsBetweenWatsonReports();
}
internal interface Microsoft.VisualStudio.Telemetry.IPersistentPropertyBag {
    public abstract virtual void Persist();
    public abstract virtual void SetProperty(string propertyName, int value);
    public abstract virtual void SetProperty(string propertyName, string value);
    public abstract virtual void SetProperty(string propertyName, double value);
    public abstract virtual object GetProperty(string propertyName);
    public abstract virtual void RemoveProperty(string propertyName);
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, object>> GetAllProperties();
    public abstract virtual void Clear();
}
internal interface Microsoft.VisualStudio.Telemetry.IPiiPropertyProcessor {
    public abstract virtual Type TypeOfPiiProperty();
    public abstract virtual Type TypeOfHashedProperty();
    public abstract virtual object ConvertToRawValue(object value);
    public abstract virtual string ConvertToHashedValue(object value);
    public abstract virtual bool CanAddRawValue(IEventProcessorContext eventProcessorContext);
    public abstract virtual string BuildRawPropertyName(string propertyName);
}
internal interface Microsoft.VisualStudio.Telemetry.IProcessCreationTime {
    public abstract virtual long GetProcessCreationTime();
}
internal interface Microsoft.VisualStudio.Telemetry.IProcessTools {
    public abstract virtual void RunCommand(string commandName, Action`1<string> onProcessComplete);
    public abstract virtual void RunCommand(string commandName, Action`1<string> onProcessComplete, string commandArgs);
}
internal interface Microsoft.VisualStudio.Telemetry.IPropertyProvider {
    public abstract virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public abstract virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
internal interface Microsoft.VisualStudio.Telemetry.IRealtimePropertyProvider {
    public abstract virtual void AddRealtimeSharedProperties(List`1<KeyValuePair`2<string, Func`1<object>>> sharedProperties, TelemetryContext telemetryContext);
}
public interface Microsoft.VisualStudio.Telemetry.ISetTelemetrySession {
    public abstract virtual void SetSession(TelemetrySession session);
}
internal interface Microsoft.VisualStudio.Telemetry.IStreamParser {
    public abstract virtual Task`1<object> ParseAsync(TextReader stream);
}
internal interface Microsoft.VisualStudio.Telemetry.IStreamSerializer {
    public abstract virtual Task SerializeAsync(object objectToSerialize, TextWriter stream);
}
public interface Microsoft.VisualStudio.Telemetry.ITelemetryEtwProvider {
    public abstract virtual void WriteActivityStartEvent(TelemetryActivity activity);
    public abstract virtual void WriteActivityStopEvent(TelemetryActivity activity);
    public abstract virtual void WriteActivityEndWithDurationEvent(TelemetryActivity activity);
    public abstract virtual void WriteActivityPostEvent(TelemetryActivity activity, TelemetrySession session);
    public abstract virtual void WriteTelemetryPostEvent(TelemetryEvent telemetryEvent, TelemetrySession session);
}
public interface Microsoft.VisualStudio.Telemetry.ITelemetryEventMatch {
    public abstract virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryLogFile`1 {
    public abstract virtual void Initialize(ITelemetryLogSettingsProvider settingsProvider);
    public abstract virtual void WriteAsync(T telemetryEvent);
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryLogSettingsProvider {
    public IEnumerable`1<KeyValuePair`2<string, string>> MainIdentifiers { get; public set; }
    public string Path { get; public set; }
    public string Folder { get; public set; }
    public string FilePath { get; }
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_MainIdentifiers();
    public abstract virtual void set_MainIdentifiers(IEnumerable`1<KeyValuePair`2<string, string>> value);
    public abstract virtual string get_Path();
    public abstract virtual void set_Path(string value);
    public abstract virtual string get_Folder();
    public abstract virtual void set_Folder(string value);
    public abstract virtual string get_FilePath();
    public abstract virtual string GetCreateFolderPath();
    public abstract virtual int GetNextUniqueId();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestAction {
    public abstract virtual void Validate();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestManager {
    public bool ForcedReadManifest { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_UpdateTelemetryManifestStatusEvent(EventHandler`1<TelemetryManifestEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UpdateTelemetryManifestStatusEvent(EventHandler`1<TelemetryManifestEventArgs> value);
    public abstract virtual bool get_ForcedReadManifest();
    public abstract virtual void Start(string hostName, bool isDisposing);
    public abstract virtual bool ForceReadManifest();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestManagerBuilder {
    public abstract virtual ITelemetryManifestManager Build(TelemetrySession telemetrySession);
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestManagerSettings {
    public string BaseUrl { get; }
    public string HostId { get; }
    public string RelativePath { get; }
    public abstract virtual string get_BaseUrl();
    public abstract virtual string get_HostId();
    public abstract virtual string get_RelativePath();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch {
    public abstract virtual void ValidateItself();
    public abstract virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatchValue {
    public abstract virtual bool IsMatch(object valueToCompare);
    public abstract virtual void Validate();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestParser {
    public abstract virtual TelemetryManifest Parse(string jsonString);
}
public interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestRouteArgs {
    public abstract virtual void Validate();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryOptinStatusReader {
    public abstract virtual bool ReadIsOptedInStatus(string productVersion);
    public abstract virtual bool ReadIsOptedInStatus(TelemetrySession session);
}
public interface Microsoft.VisualStudio.Telemetry.ITelemetryPropertyBag`1 {
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryScheduler {
    public abstract virtual void Schedule(Action action, Nullable`1<CancellationToken> token);
    public abstract virtual void Schedule(Func`1<Task> actionTask, Nullable`1<CancellationToken> token);
    public abstract virtual void InitializeTimed(TimeSpan delay);
    public abstract virtual void ScheduleTimed(Action action, bool recurring);
    public abstract virtual void ScheduleTimed(Func`1<Task> actionTask, bool recurring);
    public abstract virtual bool CanEnterTimedDelegate();
    public abstract virtual void ExitTimedDelegate();
    public abstract virtual void CancelTimed(bool wait);
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal {
    public string SessionId { get; }
    public bool IsOptedIn { get; public set; }
    public bool UseCollector { get; public set; }
    public List`1<BucketFilter> BucketFiltersToEnableWatsonForFaults { get; public set; }
    public List`1<BucketFilter> BucketFiltersToAddDumpsToFaults { get; public set; }
    public string HostName { get; public set; }
    public CancellationToken CancellationToken { get; }
    public UInt32 AppId { get; public set; }
    public bool CanCollectPrivateInformation { get; }
    public bool IsUserMicrosoftInternal { get; }
    public string CalculatedSamplings { get; }
    public Guid MachineId { get; }
    public Guid UserId { get; }
    public string MacAddressHash { get; }
    unknown Action InitializedAction {public set; }
    public EventHandler`1<TelemetryTestChannelEventArgs> RawTelemetryEventReceived { get; public set; }
    public EventProcessor EventProcessor { get; }
    public TelemetryContext DefaultContext { get; }
    public ITelemetryManifestManager ManifestManager { get; }
    public TelemetrySessionSettings SessionSettings { get; }
    public long ProcessStartTime { get; }
    public int ProcessPid { get; }
    public bool IsSessionCloned { get; }
    public abstract virtual TelemetrySession GetHostTelemetrySession();
    public abstract virtual string get_SessionId();
    public abstract virtual bool get_IsOptedIn();
    public abstract virtual void set_IsOptedIn(bool value);
    public abstract virtual bool get_UseCollector();
    public abstract virtual void set_UseCollector(bool value);
    public abstract virtual List`1<BucketFilter> get_BucketFiltersToEnableWatsonForFaults();
    public abstract virtual void set_BucketFiltersToEnableWatsonForFaults(List`1<BucketFilter> value);
    public abstract virtual List`1<BucketFilter> get_BucketFiltersToAddDumpsToFaults();
    public abstract virtual void set_BucketFiltersToAddDumpsToFaults(List`1<BucketFilter> value);
    public abstract virtual string get_HostName();
    public abstract virtual void set_HostName(string value);
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual UInt32 get_AppId();
    public abstract virtual void set_AppId(UInt32 value);
    public abstract virtual bool get_CanCollectPrivateInformation();
    public abstract virtual bool get_IsUserMicrosoftInternal();
    public abstract virtual string get_CalculatedSamplings();
    public abstract virtual Guid get_MachineId();
    public abstract virtual Guid get_UserId();
    public abstract virtual string get_MacAddressHash();
    public abstract virtual void set_InitializedAction(Action value);
    public abstract virtual EventHandler`1<TelemetryTestChannelEventArgs> get_RawTelemetryEventReceived();
    public abstract virtual void set_RawTelemetryEventReceived(EventHandler`1<TelemetryTestChannelEventArgs> value);
    public abstract virtual EventProcessor get_EventProcessor();
    public abstract virtual TelemetryContext get_DefaultContext();
    public abstract virtual ITelemetryManifestManager get_ManifestManager();
    public abstract virtual TelemetrySessionSettings get_SessionSettings();
    public abstract virtual void Start(bool checkPendingAsimovEvents);
    public abstract virtual void UseVsIsOptedIn();
    public abstract virtual void UseVsIsOptedIn(string productVersion);
    public abstract virtual TelemetryContext CreateContext(string contextName);
    public abstract virtual TelemetryContext GetContext(string contextName);
    public abstract virtual void PostEvent(string eventName);
    public abstract virtual void PostEvent(TelemetryEvent telemetryEvent);
    public abstract virtual void PostMetricEvent(TelemetryMetricEvent metricEvent);
    public abstract virtual void PostProperty(string propertyName, object propertyValue);
    public abstract virtual void PostRecurringProperty(string propertyName, object propertyValue);
    public abstract virtual void AddSessionChannel(ISessionChannel sessionChannel);
    public abstract virtual string SerializeSettings();
    public abstract virtual void SetSharedProperty(string propertyName, object propertyValue);
    public abstract virtual void RemoveSharedProperty(string propertyName);
    public abstract virtual object GetSharedProperty(string propertyName);
    public abstract virtual object GetSharedPropertyAsObject(string propertyName);
    public abstract virtual void SetPersistedSharedProperty(string propertyName, string propertyValue);
    public abstract virtual void SetPersistedSharedProperty(string propertyName, double propertyValue);
    public abstract virtual void SetPersistedSharedProperty(string propertyName, object propertyValue, Action addToBagAction);
    public abstract virtual void RemovePersistedSharedProperty(string propertyName);
    public abstract virtual object GetPersistedSharedProperty(string propertyName);
    public abstract virtual void RegisterPropertyBag(string name, TelemetryPropertyBag propertyBag);
    public abstract virtual void UnregisterPropertyBag(string name);
    public abstract virtual TelemetryPropertyBag GetPropertyBag(string name);
    public abstract virtual Task DisposeToNetworkAsync(CancellationToken token);
    public abstract virtual void RegisterForReliabilityEvent();
    public abstract virtual long get_ProcessStartTime();
    public abstract virtual int get_ProcessPid();
    public abstract virtual void PostValidatedEvent(TelemetryEvent telemetryEvents);
    public abstract virtual bool get_IsSessionCloned();
    public abstract virtual bool GetCachedUseCollectorFromRegistry();
    public abstract virtual void AddContext(TelemetryContext telemetryContext);
    public abstract virtual void RemoveContext(TelemetryContext telemetryContext);
    public abstract virtual void AddSessionChannels(IEnumerable`1<ISessionChannel> channels);
    public abstract virtual bool SetUseCollectorToRegistry(Nullable`1<bool> value);
    public abstract virtual void AddContextProperties(TelemetryEvent telemetryEvent);
    public abstract virtual void ProcessManifestUseCollectorProperty(TelemetryManifest manifest);
    public abstract virtual void AddCommonProperties(IDictionary`2<string, object> properties);
    public abstract virtual bool TryAddCommonProperty(string propertyName, object propertyValue);
    public abstract virtual bool Equals(TelemetrySession other);
    public abstract virtual void LoadCommonProperties();
    public abstract virtual bool TryGetCommonPropertyValue(string propertyName, Object& value);
    public abstract virtual IDictionary`2<string, object> GetCommonPropertyDictionary();
}
public interface Microsoft.VisualStudio.Telemetry.ITelemetryTestChannel {
    public abstract virtual void OnPostEvent(object sender, TelemetryTestChannelEventArgs e);
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryWriter {
    public abstract virtual Task WriteLineAsync(string text);
}
internal interface Microsoft.VisualStudio.Telemetry.IUserInformationProvider {
    public bool CanCollectPrivateInformation { get; }
    public bool IsUserMicrosoftInternal { get; }
    public bool IsMicrosoftAADJoined { get; }
    public Guid UserId { get; }
    public UserType UserType { get; }
    public abstract virtual bool get_CanCollectPrivateInformation();
    public abstract virtual bool get_IsUserMicrosoftInternal();
    public abstract virtual bool get_IsMicrosoftAADJoined();
    public abstract virtual Guid get_UserId();
    public abstract virtual UserType get_UserType();
}
internal class Microsoft.VisualStudio.Telemetry.JsonComplexObjectSerializer : object {
    private static string SerializationErrorLabel;
    private Lazy`1<CustomJsonConverter> jsonConverter;
    public sealed virtual void SetTypeConverter(Type type, Func`2<object, string> converter);
    public sealed virtual string Serialize(object obj);
    public sealed virtual bool WasConverterUsedForType(Type type);
}
internal class Microsoft.VisualStudio.Telemetry.JsonComplexObjectSerializerFactory : object {
    public sealed virtual IComplexObjectSerializer Instance();
}
public abstract class Microsoft.VisualStudio.Telemetry.JsonCreationConverter`1 : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    internal abstract virtual T Create(Type objectType, JObject jsonObject);
    protected bool FieldExists(string fieldName, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonHelpers.CustomJsonConverter : JsonConverter {
    private Dictionary`2<Type, Func`2<object, string>> typeConverters;
    private HashSet`1<Type> usedConverter;
    public bool CanRead { get; }
    public void AddConverter(Type type, Func`2<object, string> converter);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
    public void ResetUsageInformation();
    public bool WasConverterUsed(Type typeOfConverter);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.JsonHelpers.JsonHelperExtensions : object {
    [ExtensionAttribute]
public static bool FieldExists(JObject jObject, string fieldName);
    [ExtensionAttribute]
public static ITelemetryManifestMatch CreateTelemetryManifestMatch(JObject jObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryEventMatchConverter : JsonCreationConverter`1<ITelemetryEventMatch> {
    internal virtual ITelemetryEventMatch Create(Type objectType, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestActionConverter : JsonCreationConverter`1<ITelemetryManifestAction> {
    internal virtual ITelemetryManifestAction Create(Type objectType, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestMatchConverter : JsonCreationConverter`1<ITelemetryManifestMatch> {
    internal virtual ITelemetryManifestMatch Create(Type objectType, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestMatchValueConverter : JsonCreationConverter`1<ITelemetryManifestMatchValue> {
    internal virtual ITelemetryManifestMatchValue Create(Type objectType, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestParser : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestParser/<ParseAsync>d__0")]
public sealed virtual Task`1<object> ParseAsync(TextReader stream);
    public sealed virtual TelemetryManifest Parse(string jsonString);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestRouteArgsConverter : JsonCreationConverter`1<ITelemetryManifestRouteArgs> {
    internal virtual ITelemetryManifestRouteArgs Create(Type objectType, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestSerializer : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestSerializer/<SerializeAsync>d__0")]
public sealed virtual Task SerializeAsync(object objectToSerialize, TextWriter stream);
}
internal class Microsoft.VisualStudio.Telemetry.LegacyApi : object {
    private static object userIdCalculation;
    private static string MachineIdRegPath;
    private static string MachineIdRegKey;
    private static string UserIdRegPath;
    private static string UserIdRegKey;
    private IRegistryTools registryTools;
    public LegacyApi(IRegistryTools registryTools);
    private static LegacyApi();
    public sealed virtual Guid ReadSharedMachineId();
    public sealed virtual bool SetSharedMachineId(Guid machineId);
    public sealed virtual Guid ReadSharedUserId();
    protected virtual string ReadMachineIdFromRegistry(IRegistryTools registry, string regPath, string regKey);
    protected virtual bool SaveMachineIdToRegistry(IRegistryTools registry, string regPath, string regKey, string machineId);
    private static string FormatGuid(Guid guid);
}
internal enum Microsoft.VisualStudio.Telemetry.LegacyDatapointType : Enum {
    public int value__;
    public static LegacyDatapointType Bool;
    public static LegacyDatapointType Dword;
    public static LegacyDatapointType Dword64;
    public static LegacyDatapointType String;
}
internal enum Microsoft.VisualStudio.Telemetry.LegacyStringTruncationRule : Enum {
    public int value__;
    public static LegacyStringTruncationRule Right;
    public static LegacyStringTruncationRule Left;
}
internal class Microsoft.VisualStudio.Telemetry.LinuxHostPropertyProvider : object {
    private IHostInformationProvider hostInfoProvider;
    private Version hostVersionInfo;
    public LinuxHostPropertyProvider(IHostInformationProvider theHostInfoProvider);
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
internal class Microsoft.VisualStudio.Telemetry.LinuxLocalePropertyProvider : MacLocalePropertyProvider {
}
internal class Microsoft.VisualStudio.Telemetry.LinuxMachinePropertyProvider : object {
    private IMachineInformationProvider machineInformationProvider;
    private IMACInformationProvider macInformationProvider;
    private static string MacAddressPropertyName;
    private static string MachineIdPropertyName;
    public LinuxMachinePropertyProvider(IMachineInformationProvider machineInformationProvider, IRegistryTools regTools, IMACInformationProvider macInformationProvider);
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
internal static class Microsoft.VisualStudio.Telemetry.MacHardwareIdentification : object {
    private static string CoreFoundationLibrary;
    private static IntPtr CoreFoundationLibraryHandle;
    private static IntPtr kCFTypeDictionaryKeyCallBacks;
    private static IntPtr kCFTypeDictionaryValueCallBacks;
    private static IntPtr kCFBooleanTrue;
    private static IntPtr kCFAllocatorDefault;
    private static int KERN_SUCCESS;
    private static string IOKitLibrary;
    private static IntPtr IOKitLibraryHandle;
    private static string kIOServicePlane;
    private static string kIOEthernetInterface;
    private static string kIOPrimaryInterface;
    private static string kIOPropertyMatchKey;
    private static string kIOMACAddress;
    private static IntPtr kIOMasterPortDefault;
    private static MacHardwareIdentification();
    public static bool TryGetFirstPrimaryMacAddress(String& macAddress);
    private static bool TryGetFirstPrimaryMacAddress(IntPtr interfaceIterator, String& macAddress);
    private static bool TryFindPrimaryEthernetInterfaces(IntPtr& interfaceIterator);
    private static IntPtr dlopen(string path, int mode);
    private static IntPtr dlsym(IntPtr handle, string symbol);
    private static void CFRelease(IntPtr obj);
    private static IntPtr CFStringCreateWithCString(IntPtr alloc, string str, CFStringEncoding encoding);
    private static IntPtr CFDictionaryCreateMutable(IntPtr allocator, IntPtr capacity, IntPtr keyCallBacks, IntPtr valueCallBacks);
    private static void CFDictionarySetValue(IntPtr theDict, IntPtr key, IntPtr value);
    private static void CFDataGetBytes(IntPtr theData, CFRange range, Byte[] buffer);
    private static IntPtr IOServiceMatching(string serviceName);
    private static int IOServiceGetMatchingServices(IntPtr masterPort, IntPtr matching, IntPtr& existing);
    private static void IOObjectRelease(IntPtr obj);
    private static IntPtr IOIteratorNext(IntPtr iter);
    private static int IORegistryEntryGetParentEntry(IntPtr entry, string plane, IntPtr& parent);
    private static IntPtr IORegistryEntryCreateCFProperty(IntPtr entry, IntPtr key, IntPtr allocator, UInt32 options);
}
internal class Microsoft.VisualStudio.Telemetry.MachineInformationProvider : object {
    private static object machineIdCalculationLock;
    private Lazy`1<Guid> machineId;
    private ILegacyApi legacyApi;
    private IUserInformationProvider userInformationProvider;
    private IMACInformationProvider macInformationProvider;
    public Guid MachineId { get; }
    public MachineInformationProvider(ILegacyApi legacyApi, IUserInformationProvider userInformationProvider, IMACInformationProvider macInformationProvider);
    private static MachineInformationProvider();
    public sealed virtual Guid get_MachineId();
    private Guid CalculateMachineId();
    private static Guid ConvertHexHashToGuid(string hex);
    [CompilerGeneratedAttribute]
private Guid <.ctor>b__5_0();
}
internal class Microsoft.VisualStudio.Telemetry.MachinePropertyBag : object {
    private string backUpStorageLocation;
    private string storageLocation;
    private Dictionary`2<string, object> store;
    private bool storeWasChanged;
    internal MachinePropertyBag(string storageLocation);
    internal static string GetBackupStoreLocation(string primaryLocation);
    public sealed virtual void Persist();
    public sealed virtual void Clear();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, object>> GetAllProperties();
    public sealed virtual object GetProperty(string propertyName);
    public sealed virtual void RemoveProperty(string propertyName);
    public sealed virtual void SetProperty(string propertyName, int value);
    public sealed virtual void SetProperty(string propertyName, string value);
    public sealed virtual void SetProperty(string propertyName, double value);
    private void Persist(string path);
    private void LoadStore();
    private bool ParseFromFile(string filepath);
    private void SetPropertyInternal(string propertyName, object value);
}
internal class Microsoft.VisualStudio.Telemetry.MacHostPropertyProvider : BaseHostRealtimePropertyProvider {
    private IHostInformationProvider hostInfoProvider;
    private INsBundleInformationProvider nsBundleInformationProvider;
    private Lazy`1<string> hostExeName;
    private Lazy`1<Version> hostVersionInfo;
    public MacHostPropertyProvider(IHostInformationProvider theHostInfoProvider, INsBundleInformationProvider theNsBundleInformationProvider);
    public virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    private string InitializeHostExeName();
    private Version InitializeHostVersionInfo();
    [CompilerGeneratedAttribute]
private string <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private Version <.ctor>b__4_1();
}
internal abstract class Microsoft.VisualStudio.Telemetry.MACInformationProvider : object {
    internal static string ZeroHash;
    private IProcessTools processTools;
    private IPersistentPropertyBag persistentStorage;
    private Lazy`1<string> persistedMAC;
    internal static string MacAddressKey;
    private static string MacRegex;
    private static string ZeroRegex;
    internal static string PersistRegex;
    private string command;
    private string commandArgs;
    private bool needToRunProcess;
    private object needToRunProcessLock;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> MACAddressHashCalculationCompleted;
    protected MACInformationProvider(IProcessTools processTools, IPersistentPropertyBag persistentStorage, string command, string commandArgs);
    private static MACInformationProvider();
    public sealed virtual void RunProcessIfNecessary(Action`1<string> onComplete);
    public sealed virtual string GetMACAddressHash();
    [CompilerGeneratedAttribute]
public sealed virtual void add_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    private string CalculateMACAddressHash();
    private string ParseMACAddress(string data);
    internal static string HashMACAddress(string macAddress);
    private void OnMACAddressHashCalculationCompletedEvent(EventArgs e);
    [CompilerGeneratedAttribute]
private string <.ctor>b__12_0();
}
internal class Microsoft.VisualStudio.Telemetry.MacLocalePropertyProvider : object {
    private Lazy`1<CultureInfo> systemInfo;
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private CultureInfo InitializeSystemInformation();
    [CompilerGeneratedAttribute]
private CultureInfo <.ctor>b__1_0();
}
internal class Microsoft.VisualStudio.Telemetry.MacMachinePropertyProvider : object {
    private static long MbInBytes;
    private static string NoneValue;
    private static string UnknownValue;
    private static string MacAddressPropertyName;
    private static string MachineIdPropertyName;
    private Lazy`1<SystemInfo> systemInformation;
    private IMachineInformationProvider machineInformationProvider;
    private IMACInformationProvider macInformationProvider;
    public MacMachinePropertyProvider(IMachineInformationProvider machineInformationProvider, IRegistryTools regTools, IMACInformationProvider macInformationProvider);
    private static MacMachinePropertyProvider();
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private SystemInfo InitializeSystemInformation();
    [CompilerGeneratedAttribute]
private SystemInfo <.ctor>b__8_0();
}
internal class Microsoft.VisualStudio.Telemetry.MacMACInformationProvider : object {
    private static string MacInformationProviderVersionKey;
    private static string MacInformationProviderVersion;
    private IPersistentPropertyBag persistentStorage;
    private ILegacyApi legacyApi;
    private Lazy`1<string> persistedMAC;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> MACAddressHashCalculationCompleted;
    public MacMACInformationProvider(IPersistentPropertyBag persistentStorage, ILegacyApi legacyApi);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    public sealed virtual string GetMACAddressHash();
    public sealed virtual void RunProcessIfNecessary(Action`1<string> onComplete);
    private string CalculateMACAddressHash();
    private string GetPersistedMacHash();
    private void OnMACAddressHashCalculationCompletedEvent(EventArgs e);
    [CompilerGeneratedAttribute]
private string <.ctor>b__5_0();
}
internal class Microsoft.VisualStudio.Telemetry.MacOSPropertyProvider : object {
    private static long MbInBytes;
    private IEnvironmentTools environmentTools;
    private Lazy`1<DisplayInformation> displayInfo;
    private Lazy`1<OSVersionInfo> operatingSystemVersionInfo;
    private Lazy`1<string> productNameInfo;
    private Lazy`1<RootDriveInfo> rootDriveInfo;
    private Lazy`1<Nullable`1<long>> totalVolumesSize;
    public MacOSPropertyProvider(IEnvironmentTools envTools);
    private static MacOSPropertyProvider();
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private DisplayInformation InitializeDisplayInfo();
    private OSVersionInfo InitializeOSVersionInfo();
    private string InitializeProductNameInfo();
    private RootDriveInfo InitializeRootDriveInfo();
    private Nullable`1<long> InitializeTotalVolumeSize();
    [CompilerGeneratedAttribute]
private DisplayInformation <.ctor>b__7_0();
    [CompilerGeneratedAttribute]
private OSVersionInfo <.ctor>b__7_1();
    [CompilerGeneratedAttribute]
private RootDriveInfo <.ctor>b__7_2();
    [CompilerGeneratedAttribute]
private Nullable`1<long> <.ctor>b__7_3();
    [CompilerGeneratedAttribute]
private string <.ctor>b__7_4();
}
internal class Microsoft.VisualStudio.Telemetry.MacUserPropertyProvider : object {
    private static string AdminValue;
    private static string NormalUserValue;
    private IUserInformationProvider userInfoProvider;
    private Lazy`1<bool> adminInformation;
    public MacUserPropertyProvider(IUserInformationProvider theUserInfoProvider);
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private bool InitializeAdminInformation();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__4_0();
}
internal class Microsoft.VisualStudio.Telemetry.MacVsOptinStatusReader : object {
    public sealed virtual bool ReadIsOptedInStatus(string productVersion);
    public sealed virtual bool ReadIsOptedInStatus(TelemetrySession session);
}
internal class Microsoft.VisualStudio.Telemetry.MetricAction : DataModelPropertyAction`1<TelemetryMetricProperty> {
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Counter`1 : CounterBase`1<T> {
    private MonotonicDirection direction;
    internal Counter`1(IMeter meter, string name, string unit, string description);
    protected virtual void RecordMeasurement(T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
}
internal abstract class Microsoft.VisualStudio.Telemetry.Metrics.CounterBase`1 : Instrument`1<T> {
    [CompilerGeneratedAttribute]
private T <Sum>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    public T Sum { get; private set; }
    public long Count { get; private set; }
    internal CounterBase`1(IMeter meter, string name, string unit, string description);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Sum();
    [CompilerGeneratedAttribute]
private void set_Sum(T value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(long value);
    public sealed virtual void Add(T delta);
    public sealed virtual void Add(T delta, KeyValuePair`2<string, object> tag);
    public sealed virtual void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    public sealed virtual void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    public sealed virtual void Add(T delta, KeyValuePair`2[] tags);
    public sealed virtual void Add(T delta, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    protected virtual void RecordMeasurement(T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.DataPointEqualityComparer`1 : object {
    public sealed virtual int Compare(T x, T y);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Events.TelemetryCounterEvent`1 : TelemetryMetricEvent {
    [CompilerGeneratedAttribute]
private IVSCounter`1<T> <Counter>k__BackingField;
    private static string CounterPrefix;
    private IVSCounter`1<T> Counter { get; private set; }
    public TelemetryCounterEvent`1(TelemetryEvent telemetryEvent, ICounter`1<T> counter);
    [CompilerGeneratedAttribute]
private IVSCounter`1<T> get_Counter();
    [CompilerGeneratedAttribute]
private void set_Counter(IVSCounter`1<T> value);
    protected virtual void SetMetricProperties();
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Events.TelemetryHistogramEvent`1 : TelemetryMetricEvent {
    [CompilerGeneratedAttribute]
private IVSHistogram`1<T> <Histogram>k__BackingField;
    private static string HistogramPrefix;
    private IVSHistogram`1<T> Histogram { get; private set; }
    public TelemetryHistogramEvent`1(TelemetryEvent telemetryEvent, IHistogram`1<T> histogram);
    [CompilerGeneratedAttribute]
private IVSHistogram`1<T> get_Histogram();
    [CompilerGeneratedAttribute]
private void set_Histogram(IVSHistogram`1<T> value);
    protected virtual void SetMetricProperties();
}
public abstract class Microsoft.VisualStudio.Telemetry.Metrics.Events.TelemetryMetricEvent : object {
    [CompilerGeneratedAttribute]
private TelemetryEvent <MetricEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstrument <Metric>k__BackingField;
    private static string MetricPrefix;
    private static string MeterPrefix;
    internal TelemetryEvent MetricEvent { get; private set; }
    internal IInstrument Metric { get; private set; }
    public TelemetryMetricEvent(TelemetryEvent telemetryEvent, IInstrument metric);
    [CompilerGeneratedAttribute]
internal TelemetryEvent get_MetricEvent();
    [CompilerGeneratedAttribute]
private void set_MetricEvent(TelemetryEvent value);
    [CompilerGeneratedAttribute]
internal IInstrument get_Metric();
    [CompilerGeneratedAttribute]
private void set_Metric(IInstrument value);
    internal void SetProperties();
    protected void SetCustomMetricProperty(string propertyKey, object content);
    protected abstract virtual void SetMetricProperties();
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Exceptions.InvalidBucketConfigurationException : ArgumentException {
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Exceptions.InvalidMeterNameException : FormatException {
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Exceptions.NonMonotonicOperationException : InvalidOperationException {
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Exceptions.RegisteredMetricLimitExceededException : InvalidOperationException {
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Exceptions.UnsupportedNumericStructException : FormatException {
}
internal static class Microsoft.VisualStudio.Telemetry.Metrics.GenericNumericUtility`1 : object {
    public static T Add(T a, T b);
    public static Nullable`1<double> Average(T sum, long count);
    public static int Compare(T a, T b);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Histogram`1 : Instrument`1<T> {
    [CompilerGeneratedAttribute]
private HistogramStatistics`1<T> <Statistics>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramBuckets`1<T> <Buckets>k__BackingField;
    private HistogramConfiguration configuration;
    public HistogramStatistics`1<T> Statistics { get; private set; }
    public HistogramBuckets`1<T> Buckets { get; private set; }
    private HistogramConfiguration Configuration { get; }
    internal Histogram`1(IMeter meter, string name, string unit, string description);
    internal Histogram`1(IMeter meter, string name, HistogramConfiguration configuration, string unit, string description);
    [CompilerGeneratedAttribute]
public sealed virtual HistogramStatistics`1<T> get_Statistics();
    [CompilerGeneratedAttribute]
private void set_Statistics(HistogramStatistics`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual HistogramBuckets`1<T> get_Buckets();
    [CompilerGeneratedAttribute]
private void set_Buckets(HistogramBuckets`1<T> value);
    private HistogramConfiguration get_Configuration();
    public sealed virtual void Record(T value);
    public sealed virtual void Record(T value, KeyValuePair`2<string, object> tag);
    public sealed virtual void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    public sealed virtual void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    public sealed virtual void Record(T value, KeyValuePair`2[] tags);
    public sealed virtual void Record(T value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    protected virtual void RecordMeasurement(T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.HistogramBucket`1 : object {
    [CompilerGeneratedAttribute]
private HistogramStatistics`1<T> <Statistics>k__BackingField;
    private double minBoundary;
    private double maxBoundary;
    internal double MinBoundary { get; }
    internal double MaxBoundary { get; }
    internal HistogramStatistics`1<T> Statistics { get; private set; }
    public HistogramBucket`1(double minBoundary, double maxBoundary, IMeter meter, HistogramConfiguration configuration);
    internal double get_MinBoundary();
    internal double get_MaxBoundary();
    [CompilerGeneratedAttribute]
internal HistogramStatistics`1<T> get_Statistics();
    [CompilerGeneratedAttribute]
private void set_Statistics(HistogramStatistics`1<T> value);
    internal bool IsCorrectBucket(T measurement);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.HistogramBuckets`1 : object {
    [CompilerGeneratedAttribute]
private HistogramBucket`1[] <Buckets>k__BackingField;
    internal HistogramBucket`1[] Buckets { get; private set; }
    public HistogramBuckets`1(IMeter meter, HistogramConfiguration configuration);
    [CompilerGeneratedAttribute]
internal HistogramBucket`1[] get_Buckets();
    [CompilerGeneratedAttribute]
private void set_Buckets(HistogramBucket`1[] value);
    internal void Record(T measurement);
    private void CreateBuckets(IMeter meter, HistogramConfiguration configuration);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.HistogramConfiguration : object {
    private Double[] explicitBuckets;
    private bool recordMinMax;
    private bool recordMedian;
    internal static Double[] DefaultHistogramBuckets;
    internal Double[] ExplicitBuckets { get; }
    internal bool RecordMinMax { get; }
    internal bool RecordMedian { get; }
    public HistogramConfiguration(Double[] explicitBucketBoundaries, bool recordMinMax, bool recordMedian);
    private static HistogramConfiguration();
    internal Double[] get_ExplicitBuckets();
    internal bool get_RecordMinMax();
    internal bool get_RecordMedian();
    private void ValidateBucketOrdering();
}
public class Microsoft.VisualStudio.Telemetry.Metrics.HistogramStatistics`1 : object {
    [CompilerGeneratedAttribute]
private IVSCounter`1<T> <Counter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<T> <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<T> <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FirstRecorded>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastRecorded>k__BackingField;
    private HistogramConfiguration configuration;
    private SortedList`2<T, T> dataPoints;
    public IVSCounter`1<T> Counter { get; private set; }
    public Nullable`1<T> Min { get; private set; }
    public Nullable`1<T> Max { get; private set; }
    public Nullable`1<double> Average { get; }
    public Nullable`1<double> Median { get; }
    public Nullable`1<DateTime> FirstRecorded { get; private set; }
    public Nullable`1<DateTime> LastRecorded { get; private set; }
    public HistogramStatistics`1(IMeter meter, HistogramConfiguration configuration);
    [CompilerGeneratedAttribute]
public IVSCounter`1<T> get_Counter();
    [CompilerGeneratedAttribute]
private void set_Counter(IVSCounter`1<T> value);
    [CompilerGeneratedAttribute]
public Nullable`1<T> get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(Nullable`1<T> value);
    [CompilerGeneratedAttribute]
public Nullable`1<T> get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(Nullable`1<T> value);
    public Nullable`1<double> get_Average();
    public Nullable`1<double> get_Median();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_FirstRecorded();
    [CompilerGeneratedAttribute]
private void set_FirstRecorded(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastRecorded();
    [CompilerGeneratedAttribute]
private void set_LastRecorded(Nullable`1<DateTime> value);
    internal void Record(T measurement);
    internal Nullable`1<double> CalculateMedian();
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.ICounter`1 {
    public abstract virtual void Add(T delta);
    public abstract virtual void Add(T delta, KeyValuePair`2<string, object> tag);
    public abstract virtual void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    public abstract virtual void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    public abstract virtual void Add(T delta, KeyValuePair`2[] tags);
    public abstract virtual void Add(T delta, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IHistogram`1 {
    public abstract virtual void Record(T value);
    public abstract virtual void Record(T value, KeyValuePair`2<string, object> tag);
    public abstract virtual void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    public abstract virtual void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    public abstract virtual void Record(T value, KeyValuePair`2[] tags);
    public abstract virtual void Record(T value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IInstrument {
    public string Name { get; }
    public string Description { get; }
    public IMeter Meter { get; }
    public string Unit { get; }
    public bool Enabled { get; }
    public bool IsObservable { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Description();
    public abstract virtual IMeter get_Meter();
    public abstract virtual string get_Unit();
    public abstract virtual bool get_Enabled();
    public abstract virtual bool get_IsObservable();
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IMeter {
    public string Name { get; }
    public string Version { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Version();
    public abstract virtual ICounter`1<T> CreateCounter(string name, string unit, string description);
    public abstract virtual ICounter`1<T> CreateUpDownCounter(string name, string unit, string description);
    public abstract virtual IVSCounter`1<T> CreateVSCounter(string name, string unit, string description);
    public abstract virtual IVSCounter`1<T> CreateVSUpDownCounter(string name, string unit, string description);
    public abstract virtual IHistogram`1<T> CreateHistogram(string name, string unit, string description);
    public abstract virtual IHistogram`1<T> CreateHistogram(string name, HistogramConfiguration configuration, string unit, string description);
    public abstract virtual IVSHistogram`1<T> CreateVSHistogram(string name, string unit, string description);
    public abstract virtual IVSHistogram`1<T> CreateVSHistogram(string name, HistogramConfiguration configuration, string unit, string description);
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IMeterProvider {
    public abstract virtual IMeter CreateMeter(string name);
    public abstract virtual IMeter CreateMeter(string name, string version);
}
public abstract class Microsoft.VisualStudio.Telemetry.Metrics.Instrument`1 : object {
    private string name;
    private string description;
    private IMeter meter;
    private string unit;
    protected static KeyValuePair`2[] EmptyTags;
    private KeyValuePair`2[] internalTags;
    private static int MAX_TAGS;
    public string Name { get; }
    public string Description { get; }
    public IMeter Meter { get; }
    public string Unit { get; }
    public bool Enabled { get; }
    public bool IsObservable { get; }
    protected KeyValuePair`2[] Tags { get; protected set; }
    internal Instrument`1(IMeter meter, string name, string unit, string description);
    private static Instrument`1();
    public sealed virtual string get_Name();
    public sealed virtual string get_Description();
    public sealed virtual IMeter get_Meter();
    public sealed virtual string get_Unit();
    public sealed virtual bool get_Enabled();
    public sealed virtual bool get_IsObservable();
    protected KeyValuePair`2[] get_Tags();
    protected void set_Tags(KeyValuePair`2[] value);
    protected void Publish();
    protected virtual void RecordMeasurement(T measurement);
    protected virtual void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag);
    protected virtual void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    protected virtual void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    protected abstract virtual void RecordMeasurement(T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IVSCounter`1 {
    public T Sum { get; }
    public long Count { get; }
    public abstract virtual T get_Sum();
    public abstract virtual long get_Count();
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IVSHistogram`1 {
    public HistogramStatistics`1<T> Statistics { get; }
    public HistogramBuckets`1<T> Buckets { get; }
    public abstract virtual HistogramStatistics`1<T> get_Statistics();
    public abstract virtual HistogramBuckets`1<T> get_Buckets();
}
internal enum Microsoft.VisualStudio.Telemetry.Metrics.Management.MetricDataType : Enum {
    public int value__;
    public static MetricDataType Integer;
    public static MetricDataType FloatingPoint;
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Management.RegisteredCounterSet : RegisteredMetricSetBase {
    protected virtual RegisteredMetric CreateRegisteredMetricInstrument(string key, string name, TelemetryEvent metricEvent, string units, string description, Double[] buckets);
    protected virtual void RecordIntegerData(string key, T data, TimeSpan timeout);
    protected virtual void RecordFloatingPointData(string key, T data, TimeSpan timeout);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Management.RegisteredHistogramSet : RegisteredMetricSetBase {
    protected virtual RegisteredMetric CreateRegisteredMetricInstrument(string key, string name, TelemetryEvent metricEvent, string units, string description, Double[] buckets);
    protected virtual void RecordIntegerData(string key, T data, TimeSpan timeout);
    protected virtual void RecordFloatingPointData(string key, T data, TimeSpan timeout);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Management.RegisteredMetric : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryMetricEvent <MetricEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Expiry>k__BackingField;
    internal string Key { get; private set; }
    internal TelemetryMetricEvent MetricEvent { get; private set; }
    internal DateTime Expiry { get; private set; }
    public RegisteredMetric(string key, TelemetryMetricEvent metricEvent);
    [CompilerGeneratedAttribute]
internal string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    [CompilerGeneratedAttribute]
internal TelemetryMetricEvent get_MetricEvent();
    [CompilerGeneratedAttribute]
private void set_MetricEvent(TelemetryMetricEvent value);
    [CompilerGeneratedAttribute]
internal DateTime get_Expiry();
    [CompilerGeneratedAttribute]
private void set_Expiry(DateTime value);
    public void UpdateExpirationTime(TimeSpan timeout);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Management.RegisteredMetricManager : object {
    [CompilerGeneratedAttribute]
private RegisteredCounterSet <Counters>k__BackingField;
    [CompilerGeneratedAttribute]
private RegisteredHistogramSet <Histograms>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetrySession <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private Timer <ExpirationTimer>k__BackingField;
    public static int DEFAULT_MAX_CONCURRENT_METRICS;
    public static int DEFAULT_TIMEOUT_IN_SECONDS;
    public int MaxConcurrentMetrics;
    private int timeoutInSeconds;
    private TimeSpan timeout;
    private object metricSetSync;
    private bool disposedValue;
    internal RegisteredCounterSet Counters { get; private set; }
    internal RegisteredHistogramSet Histograms { get; private set; }
    internal bool IsExpirationTimerRunning { get; }
    private TelemetrySession Session { get; private set; }
    private Timer ExpirationTimer { get; private set; }
    public int ConcurrentMetricsCount { get; }
    public RegisteredMetricManager(TelemetrySession session, int maxConcurrentMetrics, int timeoutInSeconds);
    [CompilerGeneratedAttribute]
internal RegisteredCounterSet get_Counters();
    [CompilerGeneratedAttribute]
private void set_Counters(RegisteredCounterSet value);
    [CompilerGeneratedAttribute]
internal RegisteredHistogramSet get_Histograms();
    [CompilerGeneratedAttribute]
private void set_Histograms(RegisteredHistogramSet value);
    internal bool get_IsExpirationTimerRunning();
    [CompilerGeneratedAttribute]
private TelemetrySession get_Session();
    [CompilerGeneratedAttribute]
private void set_Session(TelemetrySession value);
    [CompilerGeneratedAttribute]
private Timer get_ExpirationTimer();
    [CompilerGeneratedAttribute]
private void set_ExpirationTimer(Timer value);
    public int get_ConcurrentMetricsCount();
    public void RecordCounterData(string key, T data, string metricName, TelemetryEvent metricEvent);
    public void RecordHistogramData(string key, T data, string metricName, TelemetryEvent metricEvent, Double[] buckets);
    public void CloseCounter(TelemetrySession session, string key);
    public void CloseHistogram(TelemetrySession session, string key);
    private void RecordInternal(RegisteredMetricSetBase set, string key, T data, string metricName, TelemetryEvent metricEvent, Double[] buckets);
    private void CloseInternal(RegisteredMetricSetBase set, TelemetrySession session, string key);
    private void StartExpiryTimer();
    private void StopExpiryTimer();
    private void CloseExpired(object sender, ElapsedEventArgs e);
    private void CloseExpiredInSet(RegisteredMetricSetBase set, TelemetrySession session, DateTime currentTime);
    private void CloseExpiredInMetricType(RegisteredMetricSetBase set, List`1<string> keys, TelemetrySession session, DateTime currentTime);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal abstract class Microsoft.VisualStudio.Telemetry.Metrics.Management.RegisteredMetricSetBase : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, RegisteredMetric> <IntegerMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, RegisteredMetric> <FloatingPointMetrics>k__BackingField;
    protected static string RegisteredMetricMeterName;
    protected static string RegisteredMetricMeterVersion;
    internal Dictionary`2<string, RegisteredMetric> IntegerMetrics { get; internal set; }
    internal Dictionary`2<string, RegisteredMetric> FloatingPointMetrics { get; internal set; }
    internal int ConcurrentMetricsCount { get; }
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, RegisteredMetric> get_IntegerMetrics();
    [CompilerGeneratedAttribute]
internal void set_IntegerMetrics(Dictionary`2<string, RegisteredMetric> value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, RegisteredMetric> get_FloatingPointMetrics();
    [CompilerGeneratedAttribute]
internal void set_FloatingPointMetrics(Dictionary`2<string, RegisteredMetric> value);
    internal int get_ConcurrentMetricsCount();
    internal void Record(string key, T data, string metricName, TelemetryEvent metricEvent, TimeSpan timeout, Double[] buckets);
    protected abstract virtual RegisteredMetric CreateRegisteredMetricInstrument(string key, string name, TelemetryEvent metricEvent, string units, string description, Double[] buckets);
    protected abstract virtual void RecordIntegerData(string key, T data, TimeSpan timeout);
    protected abstract virtual void RecordFloatingPointData(string key, T data, TimeSpan timeout);
    internal RegisteredMetric GetMetric(string key);
    internal void CloseMetric(string key);
    private MetricDataType DetermineMetricDataType(Type specifiedType);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Meter : object {
    private string name;
    private string version;
    public string Name { get; }
    public string Version { get; }
    public Meter(string name);
    public Meter(string name, string version);
    public sealed virtual string get_Name();
    public sealed virtual string get_Version();
    public sealed virtual ICounter`1<T> CreateCounter(string name, string unit, string description);
    public sealed virtual ICounter`1<T> CreateUpDownCounter(string name, string unit, string description);
    public sealed virtual IVSCounter`1<T> CreateVSCounter(string name, string unit, string description);
    public sealed virtual IVSCounter`1<T> CreateVSUpDownCounter(string name, string unit, string description);
    public sealed virtual IHistogram`1<T> CreateHistogram(string name, string unit, string description);
    public sealed virtual IHistogram`1<T> CreateHistogram(string name, HistogramConfiguration configuration, string unit, string description);
    public sealed virtual IVSHistogram`1<T> CreateVSHistogram(string name, string unit, string description);
    public sealed virtual IVSHistogram`1<T> CreateVSHistogram(string name, HistogramConfiguration configuration, string unit, string description);
    public sealed virtual void Dispose();
    private static void ValidateNumericType(Type type);
}
internal enum Microsoft.VisualStudio.Telemetry.Metrics.MonotonicDirection : Enum {
    public int value__;
    public static MonotonicDirection Unknown;
    public static MonotonicDirection Negative;
    public static MonotonicDirection Positive;
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.UpDownCounter`1 : CounterBase`1<T> {
    internal UpDownCounter`1(IMeter meter, string name, string unit, string description);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.VSTelemetryMeterProvider : object {
    private static Regex InstrumentNameRegex;
    private static VSTelemetryMeterProvider();
    public sealed virtual IMeter CreateMeter(string name);
    public sealed virtual IMeter CreateMeter(string name, string version);
    public static bool IsValidInstrumentName(string instrumentName);
}
internal class Microsoft.VisualStudio.Telemetry.MonoFileTimeProcessCreationTime : object {
    public sealed virtual long GetProcessCreationTime();
}
internal class Microsoft.VisualStudio.Telemetry.MonoHostInformationProvider : object {
    private string name;
    private UInt32 id;
    private Nullable`1<int> buildNumber;
    private string exeVersion;
    private bool isProcessInitialized;
    private static object isInitializedLock;
    public string ProcessName { get; }
    public UInt32 ProcessId { get; }
    public string ProcessExeVersion { get; }
    public Nullable`1<int> ProcessBuildNumber { get; }
    public bool IsDebuggerAttached { get; }
    public bool Is64BitProcess { get; }
    public string OSBitness { get; }
    private static MonoHostInformationProvider();
    public sealed virtual string get_ProcessName();
    public sealed virtual UInt32 get_ProcessId();
    public sealed virtual string get_ProcessExeVersion();
    public sealed virtual Nullable`1<int> get_ProcessBuildNumber();
    public sealed virtual bool get_IsDebuggerAttached();
    public sealed virtual bool get_Is64BitProcess();
    public sealed virtual string get_OSBitness();
    private void InitializeFromCurrentProcess();
    private string InitializeName(FileVersionInfo hostVersionInfo);
    private FileVersionInfo GetFileVersionInfo(Process process);
    private string InitializeExeVersion(FileVersionInfo hostVersionInfo);
}
internal class Microsoft.VisualStudio.Telemetry.MonoIdentityInformationProvider : IdentityInformationProvider {
    private static Func`1<IPersistentPropertyBag> defaultStorage;
    private static string DefaultStorageLocation { get; }
    public string BiosSerialNumber { get; }
    public Guid BiosUUID { get; }
    public BiosFirmwareTableParserError BiosInformationError { get; }
    internal MonoIdentityInformationProvider(Func`1<IPersistentPropertyBag> store);
    private static MonoIdentityInformationProvider();
    private static string get_DefaultStorageLocation();
    public virtual string get_BiosSerialNumber();
    public virtual Guid get_BiosUUID();
    public virtual BiosFirmwareTableParserError get_BiosInformationError();
}
internal class Microsoft.VisualStudio.Telemetry.MonoInternalSettings : InternalSettingsBase {
    internal static string TelemetryUserDirKeyPath;
    private static int ChannelExplicitlyEnabled;
    private static int ChannelExplicitlyDisabled;
    private JObject channelSettingsJson;
    public MonoInternalSettings(IDiagnosticTelemetry diagnosticTelemetry, IRegistryTools registryTools);
    public virtual ChannelInternalSetting GetChannelSettings(string channelId);
    private void LoadChannelSettings();
}
internal class Microsoft.VisualStudio.Telemetry.MonoLegacyApi : LegacyApi {
    public MonoLegacyApi(IRegistryTools registryTools);
    protected virtual string ReadMachineIdFromRegistry(IRegistryTools registry, string regPath, string regKey);
    protected virtual bool SaveMachineIdToRegistry(IRegistryTools registry, string regPath, string regKey, string machineId);
}
internal class Microsoft.VisualStudio.Telemetry.MonoMACInformationProvider : MACInformationProvider {
    private static string Command;
    private static string CommandArgs;
    public MonoMACInformationProvider(IProcessTools processTools, IPersistentPropertyBag persistentStorage);
}
internal class Microsoft.VisualStudio.Telemetry.MonoProcessCreationTime : object {
    public sealed virtual long GetProcessCreationTime();
}
internal class Microsoft.VisualStudio.Telemetry.MonoRegistryPropertyBag : RegistryPropertyBag {
    public MonoRegistryPropertyBag(string processName);
    protected virtual IEnumerable`1<KeyValuePair`2<string, object>> ReadRegistryValues(string registryKeyName);
    protected virtual object GetProperty(string fullRegistryKeyName, string registryKeyName, string propertyName, object defaultValue);
    protected virtual void SetProperty(string registryKeyName, string propertyName, object value);
    protected virtual void RemoveProperty(string registryKeyName, string propertyName);
    protected virtual void Clear(string registryKeyName);
    protected virtual void SetAccessControl(RegistryKey key);
}
internal class Microsoft.VisualStudio.Telemetry.MonoUserInformationProvider : UserInformationProviderBase {
    public UserType UserType { get; }
    public MonoUserInformationProvider(IInternalSettings internalSettings, IEnvironmentTools envTools, ILegacyApi legacyApi, Nullable`1<Guid> userId);
    public virtual UserType get_UserType();
    protected virtual bool CalculateIsMicrosoftAADJoined();
}
internal static class Microsoft.VisualStudio.Telemetry.Native.Mac.MacFoundation : object {
}
internal static class Microsoft.VisualStudio.Telemetry.Native.Mac.MacRuntime : object {
    public static string LIBOBJC_DYLIB;
}
internal static class Microsoft.VisualStudio.Telemetry.NativeMethods : object {
    internal static ushort IMAGE_FILE_MACHINE_UNKNOWN;
    internal static ushort IMAGE_FILE_MACHINE_ARM64;
    internal static ushort IMAGE_FILE_MACHINE_AMD64;
    internal static ushort IMAGE_FILE_MACHINE_ARM;
    internal static ushort IMAGE_FILE_MACHINE_ARMNT;
    internal static ushort IMAGE_FILE_MACHINE_THUMB;
    internal static ushort IMAGE_FILE_MACHINE_M32R;
    internal static ushort IMAGE_FILE_MACHINE_I386;
    public static UInt32 FILE_RENAME_REPLACE_IF_EXISTS;
    public static UInt32 FILE_RENAME_POSIX_SEMANTICS;
    public static UInt32 FILE_RENAME_IGNORE_READONLY_ATTRIBUTE;
    public static UInt32 FILE_ATTRIBUTE_NORMAL;
    private static NativeMethods();
    internal static string GetFullProcessExeName();
    internal static UInt32 GetCurrentProcessId();
    internal static UInt32 GetCurrentThreadId();
    internal static bool IsDebuggerPresent();
    internal static UInt32 GetModuleFileName(IntPtr handleModule, StringBuilder filename, int size);
    internal static IntPtr GetCurrentProcess();
    internal static bool RtlGetVersion(OSVersionInfo& versionInfo);
    internal static bool GlobalMemoryStatusEx(MemoryStatus& bufferPointer);
    internal static bool GetNativeSystemInfo(SystemInfo& systemInfo);
    internal static bool IsOS(OSFeatureFlag featureFlag);
    internal static int GetDeviceCaps(IntPtr hdc, int index);
    internal static bool GetTokenInformation(IntPtr tokenHandle, int tokenInformationClass, IntPtr tokenInformation, int tokenInformationLength, Int32& returnLength);
    internal static Nullable`1<long> GetProcessCreationTime();
    internal static Nullable`1<ulong> GetProcessCreationFileTime();
    private static bool GetProcessTimes(IntPtr handleProcess, FILETIME& creationTime, FILETIME& exitTime, FILETIME& kernelTime, FILETIME& userTime);
    private static DateTime FiletimeToDateTime(FILETIME fileTime);
    private static ulong FiletimeToULong(FILETIME fileTime);
    internal static int EnumSystemFirmwareTables(FirmwareTableProviderSignature firmwareTableProviderSignature, IntPtr firmwareTableBuffer, int bufferSize);
    internal static int GetSystemFirmwareTable(FirmwareTableProviderSignature firmwareTableProviderSignature, int firmwareTableID, IntPtr firmwareTableBuffer, int bufferSize);
    public static bool IsWow64Process2(IntPtr process, UInt16& processMachine, UInt16& nativeMachine);
    internal static UInt32 WerRegisterCustomMetadata(string key, string value);
    public static void NetFreeAadJoinInformation(IntPtr pJoinInfo);
    public static int NetGetAadJoinInformation(string pcszTenantId, IntPtr& ppJoinInfo);
    public static int GetSystemMetrics(int smIndex);
    public static bool ProcessIdToSessionId(UInt32 dwProcessId, UInt32& pSessionId);
}
internal class Microsoft.VisualStudio.Telemetry.NetworkInterfaceCardInformation : object {
    public int SelectionRank;
    [JsonIgnoreAttribute]
public string MacAddress;
    public int SelectionTier;
    [JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public OperationalStatus OperationalStatus;
    [JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public NetworkInterfaceType NetworkInterfaceType;
    public string Description;
    public string Serialize();
}
internal class Microsoft.VisualStudio.Telemetry.NetworkInterfacesInformationProvider : object {
    private static Lazy`1<NetworkInterfaceInformation> networkInterfacesInformation;
    private static int NetworkInterfaceSelection_Tier1;
    private static int NetworkInterfaceSelection_Tier2;
    private static int NetworkInterfaceSelection_Tier3;
    private static int NetworkInterfaceSelection_ExcludedTier;
    private static int NetworkInterfaceSelection_Prioritization;
    private static int NetworkInterfaceSelection_Minor_Prioritization;
    private static int NetworkInterfaceSelection_Minor_Deprioritization;
    private static int NetworkInterfaceSelection_Deprioritization;
    private static Dictionary`2<NetworkInterfaceType, int> NetworkInterfaceTypeIdPriorities;
    private static Regex ExcludedNetworkInterfaceRegex;
    private static Regex MinorDeprioritizedNetworkInterfaceDescriptionRegex;
    private static Regex DeprioritizedNetworkInterfaceDescriptionRegex;
    private static Regex PrioritizedPhysicalManufacturersRegex;
    private static Regex KnownPhysicalManufacturersRegex;
    [CompilerGeneratedAttribute]
private List`1<SmaRule> <SelectedMacAddressRules>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IEnumerable`1<NetworkInterfaceCardInformation>> <GetAllNetworkInterfaceCardInformation>k__BackingField;
    public string SelectedMACAddress { get; }
    public List`1<NetworkInterfaceCardInformation> PrioritizedNetworkInterfaces { get; }
    private List`1<SmaRule> SelectedMacAddressRules { get; private set; }
    private Func`1<IEnumerable`1<NetworkInterfaceCardInformation>> GetAllNetworkInterfaceCardInformation { get; }
    public NetworkInterfacesInformationProvider(List`1<SmaRule> rules, Func`1<IEnumerable`1<NetworkInterfaceCardInformation>> getAllNetworkInterfaceCardInformation);
    private static NetworkInterfacesInformationProvider();
    public sealed virtual string get_SelectedMACAddress();
    public sealed virtual List`1<NetworkInterfaceCardInformation> get_PrioritizedNetworkInterfaces();
    [CompilerGeneratedAttribute]
private List`1<SmaRule> get_SelectedMacAddressRules();
    [CompilerGeneratedAttribute]
private void set_SelectedMacAddressRules(List`1<SmaRule> value);
    [CompilerGeneratedAttribute]
private Func`1<IEnumerable`1<NetworkInterfaceCardInformation>> get_GetAllNetworkInterfaceCardInformation();
    private NetworkInterfaceInformation InitializeNetworkInterfacesInformation();
    private int GetSelectionTeir(NetworkInterfaceCardInformation nic);
}
internal class Microsoft.VisualStudio.Telemetry.Notification.AsyncManualResetEvent : object {
    private TaskCompletionSource`1 modreq(System.Runtime.CompilerServices.IsVolatile) tcs;
    public Task WaitAsync();
    public void Set();
    public void Reset();
    [CompilerGeneratedAttribute]
private bool <Set>b__2_0();
}
internal interface Microsoft.VisualStudio.Telemetry.Notification.ITelemetryNotificationProvider {
    public abstract virtual void AttachChannel(ITelemetryTestChannel channel);
    public abstract virtual void DetachChannel(ITelemetryTestChannel channel);
    public abstract virtual void PostFaultEvent(string eventName, string description, Exception exception);
}
public interface Microsoft.VisualStudio.Telemetry.Notification.ITelemetryNotificationService {
    public abstract virtual int Subscribe(ITelemetryEventMatch eventMatch, Action`1<TelemetryEvent> handler, bool singleNotification);
    public abstract virtual void Unsubscribe(int subscriptionId);
}
internal class Microsoft.VisualStudio.Telemetry.Notification.NotificationTelemetryChannel : object {
    private Action`1<TelemetryEvent> handler;
    public NotificationTelemetryChannel(Action`1<TelemetryEvent> handler);
    public sealed virtual void OnPostEvent(object sender, TelemetryTestChannelEventArgs e);
}
internal class Microsoft.VisualStudio.Telemetry.Notification.TelemetryNotificationProvider : object {
    private ITelemetryTestChannel channel;
    private TelemetrySession telemetrySession;
    public TelemetryNotificationProvider(TelemetrySession session);
    public sealed virtual void AttachChannel(ITelemetryTestChannel channel);
    public sealed virtual void DetachChannel(ITelemetryTestChannel channel);
    public sealed virtual void PostFaultEvent(string eventName, string description, Exception exception);
}
public class Microsoft.VisualStudio.Telemetry.Notification.TelemetryNotificationService : object {
    private static Lazy`1<ITelemetryNotificationService> defaultLazy;
    private static string TelemetryNotificationBaseEventName;
    internal static string TelemetryNotificationFilterFaultEventName;
    internal static string TelemetryNotificationHandlerFaultEventName;
    private object lockObject;
    private Lazy`1<IDictionary`2<int, Subscription>> subscriptionsLazy;
    private ITelemetryNotificationProvider provider;
    private ITelemetryTestChannel channel;
    private int lastSubscriptionId;
    private ConcurrentQueue`1<TelemetryEvent> queueTelemetryEvents;
    internal AsyncManualResetEvent EventNewItemAvailableForNotification;
    private CancellationTokenSource cancellationTokenSource;
    public static ITelemetryNotificationService Default { get; }
    private IDictionary`2<int, Subscription> Subscriptions { get; }
    private static TelemetryNotificationService();
    internal TelemetryNotificationService(ITelemetryNotificationProvider provider);
    public static ITelemetryNotificationService get_Default();
    internal static void Initialize();
    public sealed virtual int Subscribe(ITelemetryEventMatch eventMatch, Action`1<TelemetryEvent> handler, bool singleNotification);
    public sealed virtual void Unsubscribe(int subscriptionId);
    private IDictionary`2<int, Subscription> get_Subscriptions();
    private void AttachChannel();
    private void DetachChannel();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Notification.TelemetryNotificationService/<ListenForEventsInQueue>d__23")]
private Task ListenForEventsInQueue();
    private void OnPostEvent(TelemetryEvent telemetryEvent);
    private void ProcessPostedEvents(TelemetryEvent telemetryEvent);
    private void PostFaultEvent(string eventName, ITelemetryEventMatch eventMatch, Exception exception);
    public sealed virtual void SetSession(TelemetrySession session);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Notification.TelemetryNotificationService/<<AttachChannel>b__21_0>d")]
[CompilerGeneratedAttribute]
private Task <AttachChannel>b__21_0();
}
internal class Microsoft.VisualStudio.Telemetry.NsBundleInformationProvider : object {
    public sealed virtual string GetVersion();
    public sealed virtual string GetName();
}
internal class Microsoft.VisualStudio.Telemetry.NullVsOptinStatusReader : object {
    public sealed virtual bool ReadIsOptedInStatus(string productVersion);
    public sealed virtual bool ReadIsOptedInStatus(TelemetrySession session);
}
public class Microsoft.VisualStudio.Telemetry.OperationEvent : TelemetryEvent {
    private static string OperationPropertyPrefixName;
    private static string ResultPropertyName;
    private static string ResultSummaryPropertyName;
    private static string StageTypePropertyName;
    private static string StartTimePropertyName;
    private static string EndTimePropertyName;
    private static string DurationPropertyName;
    private static string PostStartEventPropertyName;
    private TelemetryResult result;
    private string resultSummary;
    private OperationStageType stageType;
    private Nullable`1<double> duration;
    private Nullable`1<long> startTime;
    private Nullable`1<long> endTime;
    public TelemetryResult Result { get; private set; }
    public string ResultSummary { get; private set; }
    public OperationStageType StageType { get; internal set; }
    public Nullable`1<Guid> StartEndPairId { get; }
    public Nullable`1<double> Duration { get; private set; }
    public Nullable`1<long> StartTime { get; private set; }
    public Nullable`1<long> EndTime { get; private set; }
    public string ProductName { get; }
    public string FeatureName { get; }
    public string EntityName { get; }
    public OperationEvent(string eventName, TelemetryResult result, string resultSummary);
    internal OperationEvent(string eventName, OperationStageType stageType, TelemetryResult result, string resultSummary);
    internal OperationEvent(string eventName, DataModelEventType eventType, OperationStageType stageType, TelemetryResult result, string resultSummary);
    public TelemetryResult get_Result();
    private void set_Result(TelemetryResult value);
    public string get_ResultSummary();
    private void set_ResultSummary(string value);
    public OperationStageType get_StageType();
    internal void set_StageType(OperationStageType value);
    public Nullable`1<Guid> get_StartEndPairId();
    public Nullable`1<double> get_Duration();
    private void set_Duration(Nullable`1<double> value);
    public Nullable`1<long> get_StartTime();
    private void set_StartTime(Nullable`1<long> value);
    public Nullable`1<long> get_EndTime();
    private void set_EndTime(Nullable`1<long> value);
    public string get_ProductName();
    public string get_FeatureName();
    public string get_EntityName();
    public void Correlate(TelemetryEventCorrelation correlation, string description);
    internal void SetResultProperties(TelemetryResult result, string resultSummary);
    internal void SetTimeProperties(DateTime startTime, DateTime endTime, double durationInMilliseconds);
    internal void SetPostStartEventProperty(bool postStartEvent);
    private string GetOperationStageTypeName(OperationStageType operationType);
}
public enum Microsoft.VisualStudio.Telemetry.OperationStageType : Enum {
    public int value__;
    public static OperationStageType Atomic;
    public static OperationStageType Start;
    public static OperationStageType End;
}
internal class Microsoft.VisualStudio.Telemetry.OptOutAction : object {
    private HashSet`1<string> optoutFriendlyEvents;
    private HashSet`1<string> optoutFriendlyProperties;
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public void AddOptOutFriendlyEventName(string eventName);
    public void AddOptOutFriendlyPropertiesList(IEnumerable`1<string> propertyNameList);
}
internal class Microsoft.VisualStudio.Telemetry.PersistentSharedPropertyProvider : object {
    private IPersistentPropertyBag persistedSessionProperties;
    public PersistentSharedPropertyProvider(IPersistentPropertyBag persistentPropertyBag);
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
internal class Microsoft.VisualStudio.Telemetry.PiiAction : object {
    private static string UnknownValue;
    private HashSet`1<string> piiedProperties;
    private IPiiPropertyProcessor piiPropertyProcessor;
    private int totalPiiProperties;
    public int Priority { get; }
    public PiiAction(IPiiPropertyProcessor piiPropertyProcessor);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void PostDiagnosticInformation(TelemetrySession mainSession, TelemetryManifest newManifest);
}
internal class Microsoft.VisualStudio.Telemetry.PIIPropertyProcessor : object {
    private static string NotHashedPropertySuffix;
    private static string Key;
    private static ThreadLocal`1<HashAlgorithm> Encrypter;
    private static PIIPropertyProcessor();
    public sealed virtual string BuildRawPropertyName(string propertyName);
    public sealed virtual bool CanAddRawValue(IEventProcessorContext eventProcessorContext);
    public sealed virtual object ConvertToRawValue(object value);
    public sealed virtual string ConvertToHashedValue(object value);
    public sealed virtual Type TypeOfPiiProperty();
    public sealed virtual Type TypeOfHashedProperty();
    private static HashAlgorithm CreateEncryptor();
    private string HashPropertyValue(string value);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.Telemetry.PrefixedPropertyBag`1 : object {
    private string prefix;
    private IDictionary`2<string, TValue> withPrefix;
    public TValue Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal IEnumerable`1<KeyValuePair`2<string, TValue>> PrefixedEnumerable { get; }
    public PrefixedPropertyBag`1(IDictionary`2<string, TValue> backingDictionary, string prefix);
    public sealed virtual TValue get_Item(string key);
    public sealed virtual void set_Item(string key, TValue value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<string, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, TValue> item);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.PrefixedPropertyBag`1/<GetEnumerator>d__20")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, TValue>> GetEnumerator();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, TValue> item);
    public sealed virtual bool TryGetValue(string key, TValue& value);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.PrefixedPropertyBag`1/<System-Collections-IEnumerable-GetEnumerator>d__24")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void AddPrefixed(string key, TValue value);
    internal void RemovePrefixed(string key);
    internal TValue GetPrefixed(string key);
    internal IEnumerable`1<KeyValuePair`2<string, TValue>> get_PrefixedEnumerable();
    internal void AddRangePrefixed(IEnumerable`1<KeyValuePair`2<string, TValue>> source, bool forceUpdate);
    private void AssertIsPrefixed(string key);
    private string GetFullPropertyName(string shortName);
    private KeyValuePair`2<string, TValue> GetFullPropertyName(KeyValuePair`2<string, TValue> pair);
    private string GetShortPropertyName(string fullName);
    private KeyValuePair`2<string, TValue> GetShortPropertyName(KeyValuePair`2<string, TValue> pair);
    [CompilerGeneratedAttribute]
private string <get_Keys>b__7_0(KeyValuePair`2<string, TValue> kv);
}
internal class Microsoft.VisualStudio.Telemetry.ProcessTools : object {
    public sealed virtual void RunCommand(string commandName, Action`1<string> onProcessComplete);
    public sealed virtual void RunCommand(string commandName, Action`1<string> onProcessComplete, string commandArgs);
}
internal class Microsoft.VisualStudio.Telemetry.PropertyProviders.Linux.LinuxOSPropertyProvider : object {
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private string GetOSProductName();
}
internal class Microsoft.VisualStudio.Telemetry.RegistryChannelValidator : object {
    private IInternalSettings internalSettings;
    public RegistryChannelValidator(IInternalSettings internalSettings);
    public sealed virtual bool IsValid(ISessionChannel channelToValidate);
}
internal class Microsoft.VisualStudio.Telemetry.RegistryPropertyBag : object {
    private static string KeyPath;
    private static string StringPrefix;
    private static string DoublePrefix;
    private string keyName;
    private string fullKeyName;
    public RegistryPropertyBag(string processName);
    public virtual IEnumerable`1<KeyValuePair`2<string, object>> GetAllProperties();
    public sealed virtual object GetProperty(string propertyName);
    public sealed virtual void SetProperty(string propertyName, int value);
    public sealed virtual void SetProperty(string propertyName, string value);
    public sealed virtual void SetProperty(string propertyName, double value);
    public sealed virtual void RemoveProperty(string propertyName);
    public sealed virtual void Clear();
    protected virtual IEnumerable`1<KeyValuePair`2<string, object>> ReadRegistryValues(string registryKeyName);
    protected virtual object GetProperty(string fullRegistryKeyName, string registryKeyName, string propertyName, object defaultValue);
    protected virtual void SetProperty(string registryKeyName, string propertyName, object value);
    protected virtual void RemoveProperty(string registryKeyName, string propertyName);
    protected virtual void Clear(string registryKeyName);
    protected virtual void SetAccessControl(RegistryKey key);
    private void SetProperty(string propertyName, object value);
    private static object InterpretRegistryValue(object value);
    private static string StringPrefixScrubber(string valueAsString);
    private bool SafeRegistryCall(Action action);
    public sealed virtual void Persist();
    [CompilerGeneratedAttribute]
private void <Clear>b__12_0();
}
internal class Microsoft.VisualStudio.Telemetry.SensitiveDataScrubber.CredScanDataScrubber : object {
    private static string FILE_SYSTEM_PROVIDER;
    private static string FULL_TEXT_PROVIDER;
    private static Regex FileSystemProviderRegex;
    private static Regex FullTextProviderRegex;
    private static CredScanDataScrubber();
    public sealed virtual bool ContainsSensitiveData(string propertyValue, bool scrubAllTypesOfPersonalData);
}
internal interface Microsoft.VisualStudio.Telemetry.SensitiveDataScrubber.ISensitiveDataScrubber {
    public abstract virtual bool ContainsSensitiveData(string propertyValue, bool scrubAllTypesOfPersonalData);
}
internal class Microsoft.VisualStudio.Telemetry.SensitiveDataScrubber.SensitiveDataScrubber : object {
    private static RegexOptions Options;
    private Regex allPatternsRegexes;
    private static SubstringMatch[] substringMatches;
    private static List`1<string> additionalPatterns;
    private static SensitiveDataScrubber();
    public sealed virtual bool ContainsSensitiveData(string propertyValue, bool scrubAllTypesOfPersonalData);
    private static bool IsMatch(string value, SubstringMatch& substringMatch);
    private static string RemoveSubstring(string value, string substring);
}
internal class Microsoft.VisualStudio.Telemetry.Services.DefaultRegistryKeyValueStorage : object {
    private IRegistryTools3 registryTools;
    public DefaultRegistryKeyValueStorage(IRegistryTools3 registryTools);
    public sealed virtual bool CollectionExists(string collectionPath);
    public sealed virtual bool PropertyExists(string collectionPath, string key);
    public sealed virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public sealed virtual T GetValue(string key, T defaultValue);
    public sealed virtual T GetValue(string collectionPath, string key, T defaultValue);
    public sealed virtual bool TryGetValue(string collectionPath, string key, T& value);
    public sealed virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public sealed virtual void SetValue(string key, T value);
    public sealed virtual void SetValue(string collectionPath, string key, T value);
    private Tuple`2<string, string> GetPathComponents(string key);
    private bool GetValueInternal(string collectionPath, string key, T defaultValue, T& value);
    private void SetValueInternal(string collectionPath, string key, T value);
    public sealed virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public sealed virtual bool DeleteCollection(string collectionPath);
    public sealed virtual bool DeleteProperty(string collectionPath, string propertyName);
}
internal enum Microsoft.VisualStudio.Telemetry.Services.ErrorCode : Enum {
    public int value__;
    public static ErrorCode NoError;
    public static ErrorCode NullResponse;
    public static ErrorCode RequestTimedOut;
    public static ErrorCode WebExceptionThrown;
}
internal class Microsoft.VisualStudio.Telemetry.Services.FileVersion : object {
    [CompilerGeneratedAttribute]
private int <FileMajorPart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileMinorPart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileBuildPart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileRevisionPart>k__BackingField;
    public int FileMajorPart { get; private set; }
    public int FileMinorPart { get; private set; }
    public int FileBuildPart { get; private set; }
    public int FileRevisionPart { get; private set; }
    public FileVersion(FileVersionInfo fileVersionInfo);
    public FileVersion(int major, int minor, int build, int revision);
    public static bool TryParse(string fileVersion, FileVersion& value);
    [CompilerGeneratedAttribute]
public int get_FileMajorPart();
    [CompilerGeneratedAttribute]
private void set_FileMajorPart(int value);
    [CompilerGeneratedAttribute]
public int get_FileMinorPart();
    [CompilerGeneratedAttribute]
private void set_FileMinorPart(int value);
    [CompilerGeneratedAttribute]
public int get_FileBuildPart();
    [CompilerGeneratedAttribute]
private void set_FileBuildPart(int value);
    [CompilerGeneratedAttribute]
public int get_FileRevisionPart();
    [CompilerGeneratedAttribute]
private void set_FileRevisionPart(int value);
    public virtual string ToString();
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Telemetry.Services.HttpWebRequest : object {
    private HttpWebRequest request;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Url { get; }
    public string Method { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ContentType { get; public set; }
    public long ContentLength { get; public set; }
    public bool AllowAutoRedirect { get; public set; }
    public HttpWebRequest(string url);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Url();
    public sealed virtual string get_Method();
    public sealed virtual void set_Method(string value);
    public sealed virtual RequestCachePolicy get_CachePolicy();
    public sealed virtual void set_CachePolicy(RequestCachePolicy value);
    public sealed virtual string get_ContentType();
    public sealed virtual void set_ContentType(string value);
    public sealed virtual long get_ContentLength();
    public sealed virtual void set_ContentLength(long value);
    public sealed virtual bool get_AllowAutoRedirect();
    public sealed virtual void set_AllowAutoRedirect(bool value);
    public sealed virtual void AddHeaders(IEnumerable`1<KeyValuePair`2<string, string>> headers);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Services.HttpWebRequest/<GetResponseAsync>d__21")]
public sealed virtual Task`1<IHttpWebResponse> GetResponseAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Services.HttpWebRequest/<GetRequestStreamAsync>d__22")]
public sealed virtual Task`1<Stream> GetRequestStreamAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <GetResponseAsync>b__21_0();
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Telemetry.Services.HttpWebRequestFactory : object {
    public sealed virtual IHttpWebRequest Create(string url);
    public sealed virtual IHttpWebRequest Create(string url, IEnumerable`1<KeyValuePair`2<string, string>> queryParameters);
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Telemetry.Services.HttpWebResponse : object {
    [CompilerGeneratedAttribute]
private ErrorCode <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private WebExceptionStatus <ExceptionCode>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpWebResponse <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private WebHeaderCollection <Headers>k__BackingField;
    public ErrorCode ErrorCode { get; public set; }
    public WebExceptionStatus ExceptionCode { get; public set; }
    public HttpWebResponse Response { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ErrorCode get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(ErrorCode value);
    [CompilerGeneratedAttribute]
public sealed virtual WebExceptionStatus get_ExceptionCode();
    [CompilerGeneratedAttribute]
public void set_ExceptionCode(WebExceptionStatus value);
    [CompilerGeneratedAttribute]
public HttpWebResponse get_Response();
    [CompilerGeneratedAttribute]
public void set_Response(HttpWebResponse value);
    [CompilerGeneratedAttribute]
public sealed virtual HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public sealed virtual WebHeaderCollection get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Headers(WebHeaderCollection value);
    public sealed virtual Stream GetResponseStream();
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IHttpWebRequest {
    public string Url { get; }
    public string Method { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ContentType { get; public set; }
    public long ContentLength { get; public set; }
    public bool AllowAutoRedirect { get; public set; }
    public abstract virtual string get_Url();
    public abstract virtual string get_Method();
    public abstract virtual void set_Method(string value);
    public abstract virtual RequestCachePolicy get_CachePolicy();
    public abstract virtual void set_CachePolicy(RequestCachePolicy value);
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual long get_ContentLength();
    public abstract virtual void set_ContentLength(long value);
    public abstract virtual bool get_AllowAutoRedirect();
    public abstract virtual void set_AllowAutoRedirect(bool value);
    public abstract virtual void AddHeaders(IEnumerable`1<KeyValuePair`2<string, string>> headers);
    public abstract virtual Task`1<IHttpWebResponse> GetResponseAsync(CancellationToken token);
    public abstract virtual Task`1<Stream> GetRequestStreamAsync(CancellationToken token);
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IHttpWebRequestFactory {
    public abstract virtual IHttpWebRequest Create(string url);
    public abstract virtual IHttpWebRequest Create(string url, IEnumerable`1<KeyValuePair`2<string, string>> queryParameters);
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IHttpWebResponse {
    public ErrorCode ErrorCode { get; }
    public WebExceptionStatus ExceptionCode { get; }
    public HttpStatusCode StatusCode { get; }
    public WebHeaderCollection Headers { get; public set; }
    public abstract virtual ErrorCode get_ErrorCode();
    public abstract virtual WebExceptionStatus get_ExceptionCode();
    public abstract virtual HttpStatusCode get_StatusCode();
    public abstract virtual WebHeaderCollection get_Headers();
    public abstract virtual void set_Headers(WebHeaderCollection value);
    public abstract virtual Stream GetResponseStream();
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IOSInformationProvider {
    public abstract virtual string GetOSVersion();
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IProcessInformationProvider {
    public abstract virtual string GetExeName();
    public abstract virtual FileVersion GetProcessVersionInfo();
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IRemoteFileReader {
    public abstract virtual Task`1<Stream> ReadFileAsync();
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IRemoteFileReaderFactory {
    public abstract virtual IRemoteFileReader Instance();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Services.ListEx : object {
    [ExtensionAttribute]
public static void AddIfNotEmpty(List`1<string> parts, string v);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Services.NativeFlagsEx : object {
    [ExtensionAttribute]
internal static FILE_ACCESS_FLAGS ToFILE_ACCESS_FLAGS(FileAccess fileAccess);
    [ExtensionAttribute]
internal static FILE_SHARE_MODE ToFILE_SHARE_MODE(FileShare fileShare);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Services.ObjectEx : object {
    [ExtensionAttribute]
public static bool TryConvertToType(object originalValue, T defaultValue, T& returnValue);
}
internal class Microsoft.VisualStudio.Telemetry.Services.OSInformationProvider : object {
    private static string OSCurrentVersionRegistryPath;
    private static string UBRRegistryKey;
    private static string BuildLabRegistryKey;
    private IRegistryTools registryTools;
    public OSInformationProvider(IRegistryTools registryTools);
    public sealed virtual string GetOSVersion();
    private OSVersionInfo InitializeOSVersionInfo();
}
internal class Microsoft.VisualStudio.Telemetry.Services.ProcessInformationProvider : object {
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual string GetExeName();
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual FileVersion GetProcessVersionInfo();
    [ExcludeFromCodeCoverageAttribute]
private string GetFullProcessExeName();
}
internal static class Microsoft.VisualStudio.Telemetry.Services.ReparsePointAware : object {
    private static string DevicePathPrefix;
    public static void RequireSamePath(SafeFileHandle handle, string expectedPath);
    public static void RequireNoReparsePoints(string expectedPath, bool asDirectory);
    public static void DeleteFile(string path);
    public static void MoveFile(string sourceFileName, string destFileName);
    public static void WriteAllText(string path, string contents);
    public static StreamWriter CreateText(string path);
    public static FileStream OpenWrite(string path);
    public static FileStream OpenRead(string path);
    public static FileStream OpenFile(string path, FileMode mode, FileAccess access, FileShare share);
    public static void SetFileAttributeNormal(string path);
    public static DirectoryInfo CreateDirectory(string path);
    public static SafeFileHandle PinAndRequireNoReparsePoints(string expectedPath, bool asDirectory);
    public static SafeFileHandle PinHandle(string fullPath, bool asDirectory);
    public static string GetFinalPath(SafeFileHandle handle);
    public static bool HasReparsePoints(SafeFileHandle safeHandle, string expectedPath);
    private static void ThrowIfFalse(bool condition);
    private static void SetDeleteOnClose(SafeHandle handle);
    private static bool RenameFileByHandle(SafeHandle handle, string targetFileName);
    private static FileStream SafeCreateOrOpenFile(string path, FileAccess fileAccess, FileShare fileShare);
    private static SafeFileHandle SafeCreateNewFile(string path, FileAccess fileAccess, FileShare fileShare);
    private static SafeFileHandle SafeOpenExistingFile(string path, FileAccess fileAccess, FileShare fileShare);
    private static SafeFileHandle UnsafeCreateDirectoryInternal(string path);
    private static void SafeSetFileAttributesNormal(string path);
    private static SafeFileHandle UnsafeCreateFileStub(string lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, SafeHandle hTemplateFile);
    internal static SafeFileHandle TESTUSEONLY_CreateFileStub(string lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
    internal static void TESTUSEONLY_SetDeleteOnClose(SafeHandle handle);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Services.StringEx : object {
    private static int MaxPath;
    private static Char[] buffer;
    private static StringEx();
    [ExtensionAttribute]
public static string NormalizePath(string path);
    [ExtensionAttribute]
public static string GetRootSubCollectionOfPath(string path);
    private static bool IsSkippable(char c);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Services.TaskEx : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Services.TaskEx/<WithCancellation>d__0`1")]
[ExtensionAttribute]
public static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken cancellationToken);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.AsimovAppInsightsClientWrapper : BaseAppInsightsClientWrapper {
    private static int MaxTransmissionBufferCapacity;
    private static string TransportUtc;
    private static string TransportVortex;
    private static string UtcInstalledYes;
    private static string UtcInstalledNo;
    private static string UtcInstalledUnknown;
    private bool isUtcEnabled;
    private TelemetrySession hostTelemetrySession;
    private StorageBase storage;
    private IProcessLockFactory processLockFactory;
    private Transport usedTransport;
    public AsimovAppInsightsClientWrapper(bool isUtcEnabled, string instrumentationKey, TelemetrySession hostTelemetrySession, StorageBase storage, IProcessLockFactory processLockFactory);
    public virtual bool TryGetTransport(String& transportUsed);
    protected virtual ITelemetryChannel CreateAppInsightsChannel(TelemetryConfiguration config);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.AsimovAppInsightsSessionChannel : BaseAppInsightsSessionChannel {
    private static string DefaultAsimovIKey;
    private static string DefaultAppInsightsIKey;
    private static string AppInsightsPersistencePath;
    private string channelId;
    private bool isUtcEnabled;
    private TelemetrySession hostTelemetrySession;
    private IStorageBuilder storageBuilder;
    private IProcessLockFactory processLockFactory;
    protected string FolderNameSuffix { get; }
    internal string IKey { get; }
    public string ChannelId { get; }
    public AsimovAppInsightsSessionChannel(string channelId, bool isUtcEnabled, string instrumentationKey, string userId, ChannelProperties channelProperties, TelemetrySession hostTelemetrySession, IStorageBuilder storageBuilder, IProcessLockFactory processLockFactory);
    protected virtual string get_FolderNameSuffix();
    internal virtual string get_IKey();
    public virtual string get_ChannelId();
    internal void CheckPendingEventsAndStartChannel(string sessionId);
    protected virtual IAppInsightsClientWrapper CreateAppInsightsClientWrapper();
    private bool TryUploadPendingFiles(string environmentFolderName, string sessionId);
    internal virtual void AppendCommonSchemaVersion(EventTelemetry eventTelemetry);
}
internal abstract class Microsoft.VisualStudio.Telemetry.SessionChannel.BaseAppInsightsClientWrapper : TelemetryDisposableObject {
    private string instrumentationKey;
    private TelemetryClient appInsightsClient;
    private ITelemetryChannel appInsightsChannel;
    public string InstrumentationKey { get; }
    public BaseAppInsightsClientWrapper(string instrumentationKey);
    public sealed virtual string get_InstrumentationKey();
    public abstract virtual bool TryGetTransport(String& transportUsed);
    public sealed virtual void Initialize(string sessionId, string userId);
    public sealed virtual void TrackEvent(EventTelemetry ev);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.SessionChannel.BaseAppInsightsClientWrapper/<DisposeAndTransmitAsync>d__10")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    protected abstract virtual ITelemetryChannel CreateAppInsightsChannel(TelemetryConfiguration config);
    protected virtual void DisposeManagedResources();
    private void DisposeChannel();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0();
}
internal abstract class Microsoft.VisualStudio.Telemetry.SessionChannel.BaseAppInsightsSessionChannel : TelemetryDisposableObject {
    protected string InstrumentationKey;
    protected string UserId;
    private Lazy`1<string> transportUsed;
    private static string SequenceNumberPropertyName;
    private bool isChannelStarted;
    private IAppInsightsClientWrapper appInsightsClient;
    private int eventCounter;
    private ChannelProperties channelProperties;
    public string ChannelId { get; }
    public string TransportUsed { get; }
    public ChannelProperties Properties { get; public set; }
    public bool IsStarted { get; }
    internal string IKey { get; }
    protected string PersistenceFolderName { get; }
    protected string FolderNameSuffix { get; }
    public BaseAppInsightsSessionChannel(string instrumentationKey, string userId, IAppInsightsClientWrapper overridedClientWrapper, ChannelProperties defaultChannelProperties);
    public abstract virtual string get_ChannelId();
    public sealed virtual string get_TransportUsed();
    public sealed virtual ChannelProperties get_Properties();
    public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual void Start(string sessionId);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.SessionChannel.BaseAppInsightsSessionChannel/<DisposeAndTransmitAsync>d__17")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    public sealed virtual bool get_IsStarted();
    internal abstract virtual string get_IKey();
    protected string get_PersistenceFolderName();
    protected abstract virtual string get_FolderNameSuffix();
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    internal abstract virtual void AppendCommonSchemaVersion(EventTelemetry eventTelemetry);
    protected abstract virtual IAppInsightsClientWrapper CreateAppInsightsClientWrapper();
    protected virtual void DisposeManagedResources();
    private void EnsureChannelIsStarted();
    [CompilerGeneratedAttribute]
private string <.ctor>b__15_0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0();
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Telemetry.SessionChannel.ChannelProperties : Enum {
    public int value__;
    public static ChannelProperties None;
    public static ChannelProperties Default;
    public static ChannelProperties InternalOnly;
    public static ChannelProperties Test;
    public static ChannelProperties NotForUnitTest;
    public static ChannelProperties DevChannel;
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.CollectorClientWrapper : BaseAppInsightsClientWrapper {
    private static int MaxTransmissionBufferCapacity;
    private static string TransportUtc;
    private static string TransportCollector;
    private static string UtcInstalledYes;
    private static string UtcInstalledNo;
    private static string UtcInstalledUnknown;
    private bool isUtcEnabled;
    private TelemetrySession hostTelemetrySession;
    private StorageBase storage;
    private IProcessLockFactory processLockFactory;
    private Transport usedTransport;
    public CollectorClientWrapper(bool isUtcEnabled, string instrumentationKey, TelemetrySession hostTelemetrySession, StorageBase storage, IProcessLockFactory processLockFactory);
    public virtual bool TryGetTransport(String& transportUsed);
    protected virtual ITelemetryChannel CreateAppInsightsChannel(TelemetryConfiguration config);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.CollectorSessionChannel : BaseAppInsightsSessionChannel {
    private static string AppInsightsPersistencePath;
    private string channelId;
    private bool isUtcEnabled;
    private TelemetrySession hostTelemetrySession;
    private IStorageBuilder storageBuilder;
    private IProcessLockFactory processLockFactory;
    private string iKey;
    public string ChannelId { get; }
    protected string FolderNameSuffix { get; }
    internal string IKey { get; }
    public CollectorSessionChannel(string channelId, bool isUtcEnabled, string instrumentationKey, string userId, ChannelProperties channelProperties, TelemetrySession hostTelemetrySession, IStorageBuilder storageBuilder, IProcessLockFactory processLockFactory);
    public virtual string get_ChannelId();
    protected virtual string get_FolderNameSuffix();
    internal virtual string get_IKey();
    internal void CheckPendingEventsAndStartChannel(string sessionId);
    protected virtual IAppInsightsClientWrapper CreateAppInsightsClientWrapper();
    private bool TryUploadPendingFiles(string environmentFolderName, string sessionId);
    internal virtual void AppendCommonSchemaVersion(EventTelemetry eventTelemetry);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.DefaultAppInsightsClientWrapper : BaseAppInsightsClientWrapper {
    private static int MaxTransmissionBufferCapacity;
    private StorageBase storage;
    private IProcessLockFactory processLockFactory;
    public DefaultAppInsightsClientWrapper(string instrumentationKey, StorageBase storage, IProcessLockFactory processLockFactory);
    public virtual bool TryGetTransport(String& transportUsed);
    protected virtual ITelemetryChannel CreateAppInsightsChannel(TelemetryConfiguration config);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.DefaultAppInsightsSessionChannel : BaseAppInsightsSessionChannel {
    private IStorageBuilder storageBuilder;
    private IProcessLockFactory processLockFactory;
    public string ChannelId { get; }
    internal string IKey { get; }
    protected string FolderNameSuffix { get; }
    public DefaultAppInsightsSessionChannel(string instrumentationKey, string userId);
    public DefaultAppInsightsSessionChannel(string instrumentationKey, string userId, IStorageBuilder storageBuilder, IProcessLockFactory processLockFactory);
    public virtual string get_ChannelId();
    internal virtual string get_IKey();
    protected virtual string get_FolderNameSuffix();
    protected virtual IAppInsightsClientWrapper CreateAppInsightsClientWrapper();
    internal virtual void AppendCommonSchemaVersion(EventTelemetry eventTelemetry);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.EventProcessorChannel : TelemetryDisposableObject {
    private static int SchedulerDelay;
    private ConcurrentQueue`1<TelemetryEvent> queue;
    private IEventProcessor eventProcessor;
    private ITelemetryScheduler scheduler;
    private TelemetrySession telemetrySession;
    private bool hasProcessedEvents;
    private Action initializedAction;
    public string ChannelId { get; }
    public ChannelProperties Properties { get; public set; }
    public bool IsStarted { get; }
    public string TransportUsed { get; }
    unknown Action InitializedAction {internal set; }
    internal EventProcessorChannel(IEventProcessor theEventProcessor, ITelemetryScheduler theScheduler, TelemetrySession telemetrySession);
    public sealed virtual string get_ChannelId();
    public sealed virtual ChannelProperties get_Properties();
    public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public sealed virtual void Start(string sessionId);
    public sealed virtual bool get_IsStarted();
    public sealed virtual string get_TransportUsed();
    public void ProcessEvents();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.SessionChannel.EventProcessorChannel/<DisposeAndTransmitAsync>d__21")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    internal void set_InitializedAction(Action value);
    protected virtual void DisposeManagedResources();
    private void DisposeInit();
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.GlobalTelemetryTestChannel : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<TelemetryTestChannelEventArgs> EventPosted;
    private static GlobalTelemetryTestChannel PrivateInstance;
    public string ChannelId { get; }
    public bool IsStarted { get; }
    public ChannelProperties Properties { get; public set; }
    public string TransportUsed { get; }
    public static GlobalTelemetryTestChannel Instance { get; }
    private static GlobalTelemetryTestChannel();
    [CompilerGeneratedAttribute]
public void add_EventPosted(EventHandler`1<TelemetryTestChannelEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventPosted(EventHandler`1<TelemetryTestChannelEventArgs> value);
    public sealed virtual string get_ChannelId();
    public sealed virtual bool get_IsStarted();
    public sealed virtual ChannelProperties get_Properties();
    public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual string get_TransportUsed();
    public static GlobalTelemetryTestChannel get_Instance();
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public void ClearEventSubscribers();
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public sealed virtual void Start(string sessionId);
    public virtual string ToString();
}
internal interface Microsoft.VisualStudio.Telemetry.SessionChannel.IAppInsightsClientWrapper {
    public string InstrumentationKey { get; }
    public abstract virtual string get_InstrumentationKey();
    public abstract virtual void Initialize(string sessionId, string userId);
    public abstract virtual void TrackEvent(EventTelemetry ev);
    public abstract virtual bool TryGetTransport(String& transportUsed);
}
internal interface Microsoft.VisualStudio.Telemetry.SessionChannel.IAppInsightsLifecycleManager {
    public abstract virtual void ApplicationStart();
    public abstract virtual void ApplicationStop();
}
public interface Microsoft.VisualStudio.Telemetry.SessionChannel.IDisposeAndTransmit {
    public abstract virtual Task DisposeAndTransmitAsync(CancellationToken token);
}
public interface Microsoft.VisualStudio.Telemetry.SessionChannel.ISessionChannel {
    public string ChannelId { get; }
    public string TransportUsed { get; }
    public ChannelProperties Properties { get; public set; }
    public bool IsStarted { get; }
    public abstract virtual string get_ChannelId();
    public abstract virtual string get_TransportUsed();
    public abstract virtual ChannelProperties get_Properties();
    public abstract virtual void set_Properties(ChannelProperties value);
    public abstract virtual bool get_IsStarted();
    public abstract virtual void PostEvent(TelemetryEvent telemetryEvent);
    public abstract virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public abstract virtual void Start(string sessionId);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.TelemetryBufferChannel : object {
    private ConcurrentQueue`1<TelemetryEvent> eventBuffer;
    public string ChannelId { get; }
    public string TransportUsed { get; }
    public ChannelProperties Properties { get; public set; }
    public bool IsStarted { get; }
    public sealed virtual string get_ChannelId();
    public sealed virtual string get_TransportUsed();
    public sealed virtual ChannelProperties get_Properties();
    public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public sealed virtual void Start(string sessionID);
    public sealed virtual bool get_IsStarted();
    public bool TryDequeue(TelemetryEvent& telemetryEvent);
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.TelemetryLogToFileChannel : TelemetryDisposableObject {
    private static string TelemetryLogFolderName;
    private ITelemetryLogFile`1<TelemetryEvent> logFile;
    private ITelemetryLogSettingsProvider settingsProvider;
    private ChannelProperties channelProperties;
    private bool isChannelStarted;
    public string ChannelId { get; }
    public string TransportUsed { get; }
    public ChannelProperties Properties { get; public set; }
    public bool IsStarted { get; }
    internal TelemetryLogToFileChannel(ITelemetryLogSettingsProvider settingsProvider, ITelemetryLogFile`1<TelemetryEvent> logFile);
    public sealed virtual string get_ChannelId();
    public sealed virtual string get_TransportUsed();
    public sealed virtual ChannelProperties get_Properties();
    public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public sealed virtual void Start(string sessionID);
    public sealed virtual bool get_IsStarted();
    protected virtual void DisposeManagedResources();
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.WatsonSessionChannel : object {
    [CompilerGeneratedAttribute]
private TelemetrySession <TelemetrySession>k__BackingField;
    [CompilerGeneratedAttribute]
private static Random <Random>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <NumberOfWatsonReportsThisSession>k__BackingField;
    [CompilerGeneratedAttribute]
private static DateTime <DateTimeOfLastWatsonReport>k__BackingField;
    public static string MaxWatsonReportsReached;
    [CompilerGeneratedAttribute]
private int <FaultEventWatsonSamplePercent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FaultEventMaximumWatsonReportsPerSession>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FaultEventMinimumSecondsBetweenWatsonReports>k__BackingField;
    [CompilerGeneratedAttribute]
private ChannelProperties <Properties>k__BackingField;
    private TelemetrySession TelemetrySession { get; }
    internal static Random Random { get; }
    internal static int NumberOfWatsonReportsThisSession { get; internal set; }
    internal static DateTime DateTimeOfLastWatsonReport { get; internal set; }
    public int FaultEventWatsonSamplePercent { get; }
    public int FaultEventMaximumWatsonReportsPerSession { get; }
    public int FaultEventMinimumSecondsBetweenWatsonReports { get; }
    public string ChannelId { get; }
    public bool IsStarted { get; }
    public ChannelProperties Properties { get; public set; }
    public string TransportUsed { get; }
    public WatsonSessionChannel(TelemetrySession telemetrySession, int faultEventWatsonSamplePercent, int faultEventMaximumWatsonReportsPerSession, int faultEventMinimumSecondsBetweenWatsonReports);
    private static WatsonSessionChannel();
    [CompilerGeneratedAttribute]
private TelemetrySession get_TelemetrySession();
    [CompilerGeneratedAttribute]
internal static Random get_Random();
    [CompilerGeneratedAttribute]
internal static int get_NumberOfWatsonReportsThisSession();
    [CompilerGeneratedAttribute]
internal static void set_NumberOfWatsonReportsThisSession(int value);
    [CompilerGeneratedAttribute]
internal static DateTime get_DateTimeOfLastWatsonReport();
    [CompilerGeneratedAttribute]
internal static void set_DateTimeOfLastWatsonReport(DateTime value);
    [CompilerGeneratedAttribute]
public int get_FaultEventWatsonSamplePercent();
    [CompilerGeneratedAttribute]
public int get_FaultEventMaximumWatsonReportsPerSession();
    [CompilerGeneratedAttribute]
public int get_FaultEventMinimumSecondsBetweenWatsonReports();
    public sealed virtual string get_ChannelId();
    public sealed virtual bool get_IsStarted();
    [CompilerGeneratedAttribute]
public sealed virtual ChannelProperties get_Properties();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual string get_TransportUsed();
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public sealed virtual void Start(string sessionId);
}
internal class Microsoft.VisualStudio.Telemetry.SettingAction : DataModelPropertyAction`1<TelemetrySettingProperty> {
}
internal class Microsoft.VisualStudio.Telemetry.SuppressEmptyPostPropertyEventAction : object {
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryActivity : TelemetryEvent {
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    private Guid correlationId;
    private Guid parentCorrelationId;
    public Guid CorrelationId { get; }
    internal Guid ParentCorrelationId { get; }
    internal DateTime StartTime { get; private set; }
    internal DateTime EndTime { get; private set; }
    public TelemetryActivity(string eventName);
    public TelemetryActivity(string eventName, Guid parentCorrelationId);
    public Guid get_CorrelationId();
    internal Guid get_ParentCorrelationId();
    [CompilerGeneratedAttribute]
internal DateTime get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
internal DateTime get_EndTime();
    [CompilerGeneratedAttribute]
private void set_EndTime(DateTime value);
    public void Start();
    public void End();
    public void End(TimeSpan duration);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryActivity/<GetDefaultEventProperties>d__19")]
protected virtual IEnumerable`1<KeyValuePair`2<string, object>> GetDefaultEventProperties(long eventTime, long processStartTime, string sessionId);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<KeyValuePair`2<string, object>> <>n__0(long eventTime, long processStartTime, string sessionId);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryComplexProperty : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public TelemetryComplexProperty(object val);
    [CompilerGeneratedAttribute]
public object get_Value();
    [ExcludeFromCodeCoverageAttribute]
public virtual string ToString();
}
public class Microsoft.VisualStudio.Telemetry.TelemetryContext : TelemetryDisposableObject {
    private static int SchedulerDelay;
    private static string ContextPropertyPrefix;
    private static string ContextEventPrefix;
    private static string ContextEventCreate;
    private static string ContextEventClose;
    private static string ContextEventPostProperty;
    private PrefixedConcurrent`1<object> sharedProperties;
    private PrefixedConcurrent`1<Func`1<object>> realtimeSharedProperties;
    private ITelemetrySessionInternal telemetrySessionInternal;
    private bool overrideInit;
    private object disposeLocker;
    private ITelemetryScheduler scheduler;
    private ConcurrentQueue`1<PostPropertyEntry> postedProperties;
    private DateTime contextStart;
    private bool disposedContextPart;
    [CompilerGeneratedAttribute]
private string <ContextName>k__BackingField;
    public IDictionary`2<string, object> SharedProperties { get; }
    public IDictionary`2<string, Func`1<object>> RealtimeSharedProperties { get; }
    public bool HasSharedProperties { get; }
    public string ContextName { get; private set; }
    internal TelemetryContext(string contextName, ITelemetrySessionInternal telemetrySessionInternal, ITelemetryScheduler theScheduler, bool theOverrideInit, Action`1<TelemetryContext> initializationAction);
    public IDictionary`2<string, object> get_SharedProperties();
    public IDictionary`2<string, Func`1<object>> get_RealtimeSharedProperties();
    public bool get_HasSharedProperties();
    [CompilerGeneratedAttribute]
public string get_ContextName();
    [CompilerGeneratedAttribute]
private void set_ContextName(string value);
    public void PostProperty(string propertyName, object propertyValue);
    internal void PostProperty(string propertyName, object propertyValue, bool isReserved);
    internal void FlushPostedProperties();
    internal static bool IsContextNameValid(string contextName);
    internal void ProcessEvent(TelemetryEvent telemetryEvent, bool overwriteExisting);
    internal void ProcessEventRealtime(TelemetryEvent telemetryEvent);
    internal static void ValidateEvent(TelemetryEvent telemetryEvent);
    internal static void ValidatePropertyName(string propertyName);
    internal static bool IsPropertyNameReserved(string propertyName);
    internal static bool IsEventNameContextPostProperty(string eventName);
    protected virtual void DisposeManagedResources();
    private static void ValidateEventName(TelemetryEvent telemetryEvent);
    private static void ValidateEventProperties(TelemetryEvent telemetryEvent);
    private static string BuildEventName(string eventName);
    private TelemetryEvent BuildStartEvent();
    private TelemetryEvent BuildCloseEvent();
    private void AddReservedPropertiesToTheEvent(TelemetryEvent telemetryEvent);
    private TelemetryEvent CreateTelemetryEvent(string eventName);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryCredScanProperty : object {
    [CompilerGeneratedAttribute]
private string <StringValue>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ElapsedTimeInMs>k__BackingField;
    internal static string ReplacementText;
    private CredScanDataScrubber scrubber;
    public string StringValue { get; }
    public long ElapsedTimeInMs { get; }
    public TelemetryCredScanProperty(object val);
    private static TelemetryCredScanProperty();
    [CompilerGeneratedAttribute]
public string get_StringValue();
    [CompilerGeneratedAttribute]
public long get_ElapsedTimeInMs();
}
public abstract class Microsoft.VisualStudio.Telemetry.TelemetryDataModelProperty : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public TelemetryDataModelProperty(object val);
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual string ToString();
}
public abstract class Microsoft.VisualStudio.Telemetry.TelemetryDisposableObject : object {
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    protected void RequiresNotDisposed();
    protected virtual void DisposeManagedResources();
}
public class Microsoft.VisualStudio.Telemetry.TelemetryEvent : object {
    private static int SchemaVersion;
    private static string DataModelApiSource;
    private static TelemetrySeverity DefaultSeverity;
    internal static string ReservedPropertyPrefix;
    private string eventName;
    private NotConcurrent`1<object> eventProperties;
    private PrefixedNotConcurrent`1<object> reservedEventProperties;
    private HashSet`1<TelemetryPropertyBag> sharedPropertyBags;
    private Guid eventId;
    private TelemetrySeverity severity;
    [CompilerGeneratedAttribute]
private Dictionary`2<TelemetryEventCorrelation, string> <CorrelatedWith>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptOutFriendly>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventSchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryEventCorrelation <Correlation>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <PostTimestamp>k__BackingField;
    internal Dictionary`2<TelemetryEventCorrelation, string> CorrelatedWith { get; private set; }
    public bool IsOptOutFriendly { get; public set; }
    public TelemetrySeverity Severity { get; public set; }
    public DataModelEventType EventType { get; }
    public int EventSchemaVersion { get; }
    public string DataSource { get; }
    public TelemetryEventCorrelation Correlation { get; private set; }
    public string Name { get; }
    public IDictionary`2<string, object> Properties { get; }
    public bool HasProperties { get; }
    internal DateTimeOffset PostTimestamp { get; internal set; }
    public HashSet`1<TelemetryPropertyBag> SharedPropertyBags { get; }
    internal PrefixedNotConcurrent`1<object> ReservedProperties { get; }
    internal bool HasReservedProperties { get; }
    public TelemetryEvent(string eventName);
    public TelemetryEvent(string eventName, TelemetrySeverity severity);
    internal TelemetryEvent(string eventName, TelemetrySeverity severity, DataModelEventType eventType);
    internal TelemetryEvent(string eventName, TelemetrySeverity severity, TelemetryEventCorrelation correlation);
    [CompilerGeneratedAttribute]
internal Dictionary`2<TelemetryEventCorrelation, string> get_CorrelatedWith();
    [CompilerGeneratedAttribute]
private void set_CorrelatedWith(Dictionary`2<TelemetryEventCorrelation, string> value);
    [CompilerGeneratedAttribute]
public bool get_IsOptOutFriendly();
    [CompilerGeneratedAttribute]
public void set_IsOptOutFriendly(bool value);
    public TelemetrySeverity get_Severity();
    public void set_Severity(TelemetrySeverity value);
    public DataModelEventType get_EventType();
    [CompilerGeneratedAttribute]
public int get_EventSchemaVersion();
    public string get_DataSource();
    [CompilerGeneratedAttribute]
public TelemetryEventCorrelation get_Correlation();
    [CompilerGeneratedAttribute]
private void set_Correlation(TelemetryEventCorrelation value);
    public void Correlate(TelemetryEventCorrelation[] correlations);
    internal TelemetryEvent BuildChannelEvent(long processStartTime, string sessionId);
    internal TelemetryEvent CloneTelemetryEvent();
    protected void CorrelateWithDescription(TelemetryEventCorrelation correlation, string description);
    public string get_Name();
    public IDictionary`2<string, object> get_Properties();
    public bool get_HasProperties();
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_PostTimestamp();
    [CompilerGeneratedAttribute]
internal void set_PostTimestamp(DateTimeOffset value);
    public HashSet`1<TelemetryPropertyBag> get_SharedPropertyBags();
    internal PrefixedNotConcurrent`1<object> get_ReservedProperties();
    internal bool get_HasReservedProperties();
    internal static bool IsPropertyNameReserved(string propertyName);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryEvent/<GetDefaultEventProperties>d__57")]
protected virtual IEnumerable`1<KeyValuePair`2<string, object>> GetDefaultEventProperties(long eventTime, long processStartTime, string sessionId);
    private static KeyValuePair`2<string, object> AsReservedProperty(KeyValuePair`2<string, object> property);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryEvent/<GetCorrelatedWithProperties>d__59")]
private IEnumerable`1<KeyValuePair`2<string, object>> GetCorrelatedWithProperties();
    private IEnumerable`1<KeyValuePair`2<string, object>> GetAllProperties(long eventTime, long processStartTime, string sessionId);
    private void InitDataModelBasicProperties();
    public virtual string ToString();
}
public class Microsoft.VisualStudio.Telemetry.TelemetryEventCorrelation : ValueType {
    public static TelemetryEventCorrelation Empty;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DataModelEventType <EventType>k__BackingField;
    [JsonPropertyAttribute]
internal Guid Id { get; private set; }
    internal bool IsEmpty { get; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
internal DataModelEventType EventType { get; private set; }
    internal TelemetryEventCorrelation(Guid id, DataModelEventType eventType);
    private static TelemetryEventCorrelation();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    internal bool get_IsEmpty();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal DataModelEventType get_EventType();
    [CompilerGeneratedAttribute]
private void set_EventType(DataModelEventType value);
    public string Serialize();
    public static TelemetryEventCorrelation Deserialize(string jsonString);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.TelemetryEventCorrelationCodeContract : object {
    [ExtensionAttribute]
internal static void RequireNotEmpty(TelemetryEventCorrelation correlation, string argumentName);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryEventMatchByName : object {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFullNameCheck>k__BackingField;
    public string EventName { get; private set; }
    public bool IsFullNameCheck { get; private set; }
    public TelemetryEventMatchByName(string eventName, bool isFullNameCheck);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
private void set_EventName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsFullNameCheck();
    [CompilerGeneratedAttribute]
private void set_IsFullNameCheck(bool value);
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryHashedProperty : object {
    [CompilerGeneratedAttribute]
private string <StringValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RawValue>k__BackingField;
    public string StringValue { get; }
    public object RawValue { get; }
    public TelemetryHashedProperty(object val);
    [CompilerGeneratedAttribute]
public string get_StringValue();
    [CompilerGeneratedAttribute]
public object get_RawValue();
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryJsonLogFile : BaseJsonLogFile`1<TelemetryEvent> {
    public TelemetryJsonLogFile(ITelemetryWriter writer);
    protected virtual string ConvertEventToString(TelemetryEvent eventData);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryLogSettingsProvider : object {
    private static int fileVersion;
    private static int processId;
    private static int appDomainId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, string>> <MainIdentifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Folder>k__BackingField;
    public string FileNameFormatString { get; }
    public IEnumerable`1<KeyValuePair`2<string, string>> MainIdentifiers { get; public set; }
    public int ProcessId { get; }
    public int AppDomainId { get; }
    public string Path { get; public set; }
    public string Folder { get; public set; }
    public string FilePath { get; }
    private static TelemetryLogSettingsProvider();
    public string get_FileNameFormatString();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_MainIdentifiers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MainIdentifiers(IEnumerable`1<KeyValuePair`2<string, string>> value);
    public int get_ProcessId();
    public int get_AppDomainId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Path(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Folder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Folder(string value);
    public sealed virtual string get_FilePath();
    public sealed virtual string GetCreateFolderPath();
    public sealed virtual int GetNextUniqueId();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifest : object {
    public static UInt32 FormatVersion;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCollector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ThrottlingThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ThrottlingTimerReset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldSendAliasForAllInternalUsers>k__BackingField;
    [JsonIgnoreAttribute]
private HashSet`1<string> invalidRules;
    [CompilerGeneratedAttribute]
private int <InvalidActionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TelemetryManifestRule> <Rules>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryManifestMachineIdentityConfig <MachineIdentityConfig>k__BackingField;
    [JsonPropertyAttribute]
public string Version { get; public set; }
    [DefaultValueAttribute("False")]
[JsonPropertyAttribute]
public bool UseCollector { get; public set; }
    [JsonPropertyAttribute]
public string Etag { get; public set; }
    [JsonPropertyAttribute]
public long ThrottlingThreshold { get; public set; }
    [JsonPropertyAttribute]
public double ThrottlingTimerReset { get; public set; }
    [DefaultValueAttribute("True")]
[JsonPropertyAttribute]
public bool ShouldSendAliasForAllInternalUsers { get; public set; }
    [JsonIgnoreAttribute]
public IEnumerable`1<string> InvalidRules { get; }
    [JsonIgnoreAttribute]
public int InvalidActionCount { get; private set; }
    [JsonPropertyAttribute]
public IEnumerable`1<TelemetryManifestRule> Rules { get; public set; }
    [JsonPropertyAttribute]
public TelemetryManifestMachineIdentityConfig MachineIdentityConfig { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_UseCollector();
    [CompilerGeneratedAttribute]
public void set_UseCollector(bool value);
    [CompilerGeneratedAttribute]
public string get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(string value);
    [CompilerGeneratedAttribute]
public long get_ThrottlingThreshold();
    [CompilerGeneratedAttribute]
public void set_ThrottlingThreshold(long value);
    [CompilerGeneratedAttribute]
public double get_ThrottlingTimerReset();
    [CompilerGeneratedAttribute]
public void set_ThrottlingTimerReset(double value);
    [CompilerGeneratedAttribute]
public bool get_ShouldSendAliasForAllInternalUsers();
    [CompilerGeneratedAttribute]
public void set_ShouldSendAliasForAllInternalUsers(bool value);
    public IEnumerable`1<string> get_InvalidRules();
    [CompilerGeneratedAttribute]
public int get_InvalidActionCount();
    [CompilerGeneratedAttribute]
private void set_InvalidActionCount(int value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TelemetryManifestRule> get_Rules();
    [CompilerGeneratedAttribute]
public void set_Rules(IEnumerable`1<TelemetryManifestRule> value);
    [CompilerGeneratedAttribute]
public TelemetryManifestMachineIdentityConfig get_MachineIdentityConfig();
    [CompilerGeneratedAttribute]
public void set_MachineIdentityConfig(TelemetryManifestMachineIdentityConfig value);
    public static TelemetryManifest BuildDefaultManifest();
    public IEnumerable`1<ITelemetryManifestAction> GetActionsForEvent(TelemetryEvent telemetryEvent);
    public void Validate();
    internal string CalculateAllSamplings(TelemetrySession session);
    internal IEnumerable`1<Path> GetAllSamplings();
    [OnDeserializedAttribute]
internal void ValidateAfterDeserialization(StreamingContext context);
    [CompilerGeneratedAttribute]
private bool <Validate>b__42_0(TelemetryManifestRule rule);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionCredScan : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Properties>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<string> Properties { get; public set; }
    public int Priority { get; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IEnumerable`1<string> value);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionDoNotThrottle : TelemetryManifestActionThrottleBase {
    protected virtual void ExecuteThrottlingAction(IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionExclude : object {
    [JsonIgnoreAttribute]
private bool excludeAll;
    [JsonIgnoreAttribute]
private IEnumerable`1<string> channelsToExclude;
    [JsonPropertyAttribute]
public IEnumerable`1<string> ExcludeForChannels { get; public set; }
    [JsonIgnoreAttribute]
public int Priority { get; }
    public IEnumerable`1<string> get_ExcludeForChannels();
    public void set_ExcludeForChannels(IEnumerable`1<string> value);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionExcludeProperty : object {
    [CompilerGeneratedAttribute]
private string <ExcludeProperty>k__BackingField;
    [JsonPropertyAttribute]
public string ExcludeProperty { get; public set; }
    [JsonIgnoreAttribute]
public int Priority { get; }
    [CompilerGeneratedAttribute]
public string get_ExcludeProperty();
    [CompilerGeneratedAttribute]
public void set_ExcludeProperty(string value);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionHashed : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Properties>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<string> Properties { get; public set; }
    [JsonIgnoreAttribute]
public int Priority { get; }
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<string> get_Properties();
    [CompilerGeneratedAttribute]
public virtual void set_Properties(IEnumerable`1<string> value);
    public virtual int get_Priority();
    public virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public virtual void Validate();
}
internal abstract class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutBase : object {
    [JsonIgnoreAttribute]
public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public virtual void Validate();
    protected abstract virtual void ExecuteOptOutAction(IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutExcludeEvents : TelemetryManifestActionOptOutBase {
    protected virtual void ExecuteOptOutAction(IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutExcludeProperties : TelemetryManifestActionOptOutPropertiesBase {
    [JsonPropertyAttribute]
public IEnumerable`1<string> Properties { get; public set; }
    public IEnumerable`1<string> get_Properties();
    public void set_Properties(IEnumerable`1<string> value);
    protected virtual void ProcessPropertyName(string propertyName, IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutIncludeEvents : TelemetryManifestActionOptOutBase {
    protected virtual void ExecuteOptOutAction(IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutIncludeProperties : TelemetryManifestActionOptOutPropertiesBase {
    [JsonPropertyAttribute]
public IEnumerable`1<string> Properties { get; public set; }
    public IEnumerable`1<string> get_Properties();
    public void set_Properties(IEnumerable`1<string> value);
    protected virtual void ProcessPropertyName(string propertyName, IEventProcessorContext eventProcessorContext);
}
internal abstract class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutPropertiesBase : TelemetryManifestActionOptOutBase {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <PropertiesImpl>k__BackingField;
    [JsonIgnoreAttribute]
protected IEnumerable`1<string> PropertiesImpl { get; protected set; }
    [CompilerGeneratedAttribute]
protected IEnumerable`1<string> get_PropertiesImpl();
    [CompilerGeneratedAttribute]
protected void set_PropertiesImpl(IEnumerable`1<string> value);
    public virtual void Validate();
    protected virtual void ExecuteOptOutAction(IEventProcessorContext eventProcessorContext);
    protected abstract virtual void ProcessPropertyName(string propertyName, IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionPii : TelemetryManifestActionHashed {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Properties>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<string> Properties { get; public set; }
    [JsonIgnoreAttribute]
public int Priority { get; }
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<string> get_Properties();
    [CompilerGeneratedAttribute]
public virtual void set_Properties(IEnumerable`1<string> value);
    public virtual int get_Priority();
    public virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionRoute : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TelemetryManifestRouter> <Route>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<TelemetryManifestRouter> Route { get; public set; }
    [JsonIgnoreAttribute]
public int Priority { get; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<TelemetryManifestRouter> get_Route();
    [CompilerGeneratedAttribute]
public void set_Route(IEnumerable`1<TelemetryManifestRouter> value);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionThrottle : TelemetryManifestActionThrottleBase {
    protected virtual void ExecuteThrottlingAction(IEventProcessorContext eventProcessorContext);
}
internal abstract class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionThrottleBase : object {
    [JsonIgnoreAttribute]
public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public virtual void Validate();
    protected abstract virtual void ExecuteThrottlingAction(IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private TelemetryManifest <TelemetryManifest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    public TelemetryManifest TelemetryManifest { get; }
    public bool IsSuccess { get; }
    public TelemetryManifestEventArgs(TelemetryManifest telemetryManifest);
    [CompilerGeneratedAttribute]
public TelemetryManifest get_TelemetryManifest();
    [CompilerGeneratedAttribute]
public bool get_IsSuccess();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestInvalidAction : object {
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestInvalidMatchItem : object {
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestInvalidMatchValueItem : object {
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestInvalidRouteArgs : object {
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestLegacyDatapointRouteArgs : object {
    [CompilerGeneratedAttribute]
private UInt32 <DatapointId>k__BackingField;
    [CompilerGeneratedAttribute]
private LegacyDatapointType <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private LegacyStringTruncationRule <TruncationRule>k__BackingField;
    [JsonPropertyAttribute]
public UInt32 DatapointId { get; public set; }
    [JsonPropertyAttribute]
public LegacyDatapointType DataType { get; public set; }
    [JsonPropertyAttribute]
public string ParameterName { get; public set; }
    [JsonPropertyAttribute]
public LegacyStringTruncationRule TruncationRule { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_DatapointId();
    [CompilerGeneratedAttribute]
public void set_DatapointId(UInt32 value);
    [CompilerGeneratedAttribute]
public LegacyDatapointType get_DataType();
    [CompilerGeneratedAttribute]
public void set_DataType(LegacyDatapointType value);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public void set_ParameterName(string value);
    [CompilerGeneratedAttribute]
public LegacyStringTruncationRule get_TruncationRule();
    [CompilerGeneratedAttribute]
public void set_TruncationRule(LegacyStringTruncationRule value);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestLegacyStreamPropertyRouteArgs : object {
    [CompilerGeneratedAttribute]
private LegacyDatapointType <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private LegacyStringTruncationRule <TruncationRule>k__BackingField;
    [JsonPropertyAttribute]
public LegacyDatapointType DataType { get; public set; }
    [JsonPropertyAttribute]
public string PropertyName { get; public set; }
    [JsonPropertyAttribute]
public LegacyStringTruncationRule TruncationRule { get; public set; }
    [CompilerGeneratedAttribute]
public LegacyDatapointType get_DataType();
    [CompilerGeneratedAttribute]
public void set_DataType(LegacyDatapointType value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public LegacyStringTruncationRule get_TruncationRule();
    [CompilerGeneratedAttribute]
public void set_TruncationRule(LegacyStringTruncationRule value);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestLegacyStreamRouteArgs : object {
    [CompilerGeneratedAttribute]
private UInt32 <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITelemetryManifestRouteArgs> <Properties>k__BackingField;
    [JsonPropertyAttribute]
public UInt32 StreamId { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<ITelemetryManifestRouteArgs> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(UInt32 value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ITelemetryManifestRouteArgs> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IEnumerable`1<ITelemetryManifestRouteArgs> value);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMachineIdentityConfig : object {
    private static string DefaultMinValidConfigVersion;
    internal static string DefaultConfigVersion;
    [CompilerGeneratedAttribute]
private String[] <HardwareIdComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SmaRule> <SmaRules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendValuesEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinValidConfigVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InvalidateOnPrimaryIdChange>k__BackingField;
    public static TelemetryManifestMachineIdentityConfig DefaultConfig { get; }
    [JsonPropertyAttribute]
public String[] HardwareIdComponents { get; public set; }
    [JsonPropertyAttribute]
public string ConfigVersion { get; public set; }
    [JsonPropertyAttribute]
public List`1<SmaRule> SmaRules { get; public set; }
    [JsonPropertyAttribute]
public bool SendValuesEvent { get; public set; }
    [JsonPropertyAttribute]
public string MinValidConfigVersion { get; public set; }
    [JsonPropertyAttribute]
public bool InvalidateOnPrimaryIdChange { get; public set; }
    public static TelemetryManifestMachineIdentityConfig get_DefaultConfig();
    [CompilerGeneratedAttribute]
public String[] get_HardwareIdComponents();
    [CompilerGeneratedAttribute]
public void set_HardwareIdComponents(String[] value);
    [CompilerGeneratedAttribute]
public string get_ConfigVersion();
    [CompilerGeneratedAttribute]
public void set_ConfigVersion(string value);
    [CompilerGeneratedAttribute]
public List`1<SmaRule> get_SmaRules();
    [CompilerGeneratedAttribute]
public void set_SmaRules(List`1<SmaRule> value);
    [CompilerGeneratedAttribute]
public bool get_SendValuesEvent();
    [CompilerGeneratedAttribute]
public void set_SendValuesEvent(bool value);
    [CompilerGeneratedAttribute]
public string get_MinValidConfigVersion();
    [CompilerGeneratedAttribute]
public void set_MinValidConfigVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_InvalidateOnPrimaryIdChange();
    [CompilerGeneratedAttribute]
public void set_InvalidateOnPrimaryIdChange(bool value);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestManager : TelemetryDisposableObject {
    private static int RemoteControlReadFileTelemetryFrequency;
    private static TimeSpan DownloadInterval;
    private static TimeSpan ReadInterval;
    private static TimeSpan ForceReadDelay;
    private ITelemetryManifestParser manifestParser;
    private ITelemetryScheduler scheduler;
    private TelemetrySession mainSession;
    private IRemoteControlClient remoteControlClient;
    private ITelemetryManifestManagerSettings settings;
    private CancellationTokenSource tokenSource;
    private bool isStarted;
    [CompilerGeneratedAttribute]
private EventHandler`1<TelemetryManifestEventArgs> UpdateTelemetryManifestStatusEvent;
    [CompilerGeneratedAttribute]
private bool <ForcedReadManifest>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryManifest <CurrentManifest>k__BackingField;
    public bool ForcedReadManifest { get; private set; }
    internal TelemetryManifest CurrentManifest { get; private set; }
    public TelemetryManifestManager(IRemoteControlClient theRemoteControlClient, ITelemetryManifestManagerSettings theSettings, ITelemetryManifestParser theManifestParser, ITelemetryScheduler theScheduler, TelemetrySession theMainSession);
    private static TelemetryManifestManager();
    [CompilerGeneratedAttribute]
public sealed virtual void add_UpdateTelemetryManifestStatusEvent(EventHandler`1<TelemetryManifestEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_UpdateTelemetryManifestStatusEvent(EventHandler`1<TelemetryManifestEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ForcedReadManifest();
    [CompilerGeneratedAttribute]
private void set_ForcedReadManifest(bool value);
    [CompilerGeneratedAttribute]
internal TelemetryManifest get_CurrentManifest();
    [CompilerGeneratedAttribute]
private void set_CurrentManifest(TelemetryManifest value);
    public sealed virtual void Start(string hostName, bool isDisposing);
    public sealed virtual bool ForceReadManifest();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryManifestManager/<Check>d__25")]
internal Task Check();
    protected virtual void DisposeManagedResources();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryManifestManager/<Check>d__27")]
private Task Check(BehaviorOnStale staleBehavior, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryManifestManager/<LoadManifest>d__28")]
private Task LoadManifest(BehaviorOnStale staleBehavior, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryManifestManager/<ReadAndParseManifest>d__29")]
private Task`1<Tuple`2<TelemetryManifest, long>> ReadAndParseManifest(BehaviorOnStale staleBehavior);
    private void OnUpdateTelemetryManifestStatusEvent(TelemetryManifestEventArgs e);
    private void InstrumentLoad(TelemetryManifest telemetryManifest, long streamSize, string message, string errorDetails, double duration);
    [CompilerGeneratedAttribute]
private void <.ctor>b__22_0(string eventName, IDictionary`2<string, object> properties, IDictionary`2<string, object> piiProperties);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestManagerBuilder : object {
    private object remoteControlClient;
    private ITelemetryManifestManagerSettings settings;
    private ITelemetryManifestParser manifestParser;
    private ITelemetryScheduler scheduler;
    public TelemetryManifestManagerBuilder(object theRemoteControlClient, ITelemetryManifestManagerSettings theSettings, ITelemetryManifestParser theManifestParser, ITelemetryScheduler theScheduler);
    public sealed virtual ITelemetryManifestManager Build(TelemetrySession telemetrySession);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestManagerSettings : object {
    private string urlFilePath;
    private string urlFilePattern;
    [CompilerGeneratedAttribute]
private string <HostId>k__BackingField;
    public string BaseUrl { get; }
    public string HostId { get; }
    public string RelativePath { get; }
    public TelemetryManifestManagerSettings(string hostName, string theUrlFilePattern);
    public sealed virtual string get_BaseUrl();
    [CompilerGeneratedAttribute]
public sealed virtual string get_HostId();
    public sealed virtual string get_RelativePath();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchAnd : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITelemetryManifestMatch> <And>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<ITelemetryManifestMatch> And { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<ITelemetryManifestMatch> get_And();
    [CompilerGeneratedAttribute]
public void set_And(IEnumerable`1<ITelemetryManifestMatch> value);
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchEventName : object {
    [JsonIgnoreAttribute]
private TelemetryEventMatchByName eventMatchFilter;
    [JsonPropertyAttribute]
public string EventName { get; public set; }
    public string get_EventName();
    public void set_EventName(string value);
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchExtension : object {
    [ExtensionAttribute]
public static IEnumerable`1<ITelemetryManifestMatch> GetDescendants(ITelemetryManifestMatch match);
    [ExtensionAttribute]
public static IEnumerable`1<ITelemetryManifestMatch> GetDescendantsAndItself(ITelemetryManifestMatch match);
    [ExtensionAttribute]
public static void Validate(ITelemetryManifestMatch match);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchNot : object {
    [CompilerGeneratedAttribute]
private ITelemetryManifestMatch <Not>k__BackingField;
    [JsonPropertyAttribute]
public ITelemetryManifestMatch Not { get; public set; }
    [CompilerGeneratedAttribute]
public ITelemetryManifestMatch get_Not();
    [CompilerGeneratedAttribute]
public void set_Not(ITelemetryManifestMatch value);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchNot/<GetChildren>d__4")]
public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchOr : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITelemetryManifestMatch> <Or>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<ITelemetryManifestMatch> Or { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<ITelemetryManifestMatch> get_Or();
    [CompilerGeneratedAttribute]
public void set_Or(IEnumerable`1<ITelemetryManifestMatch> value);
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchPropertyValue : object {
    [JsonIgnoreAttribute]
private string propertyName;
    [CompilerGeneratedAttribute]
private ITelemetryManifestMatchValue <Value>k__BackingField;
    [JsonPropertyAttribute]
public string Property { get; public set; }
    [JsonPropertyAttribute]
public ITelemetryManifestMatchValue Value { get; public set; }
    public string get_Property();
    public void set_Property(string value);
    [CompilerGeneratedAttribute]
public ITelemetryManifestMatchValue get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(ITelemetryManifestMatchValue value);
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchSampling : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Rate>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<HashInput> <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSampleActive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCalculateCalled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRateTooLow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRateTooHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInputStringEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InputString>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Hash>k__BackingField;
    [JsonPropertyAttribute]
public string Name { get; public set; }
    [JsonPropertyAttribute]
public double Rate { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<HashInput> Inputs { get; public set; }
    [JsonIgnoreAttribute]
public bool IsSampleActive { get; public set; }
    [JsonIgnoreAttribute]
public bool IsCalculateCalled { get; private set; }
    [JsonIgnoreAttribute]
public bool IsRateTooLow { get; private set; }
    [JsonIgnoreAttribute]
public bool IsRateTooHigh { get; private set; }
    [JsonIgnoreAttribute]
public bool IsInputStringEmpty { get; private set; }
    [JsonIgnoreAttribute]
public string InputString { get; private set; }
    [JsonIgnoreAttribute]
public ulong Hash { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public double get_Rate();
    [CompilerGeneratedAttribute]
public void set_Rate(double value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<HashInput> get_Inputs();
    [CompilerGeneratedAttribute]
public void set_Inputs(IEnumerable`1<HashInput> value);
    [CompilerGeneratedAttribute]
public bool get_IsSampleActive();
    [CompilerGeneratedAttribute]
public void set_IsSampleActive(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCalculateCalled();
    [CompilerGeneratedAttribute]
private void set_IsCalculateCalled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRateTooLow();
    [CompilerGeneratedAttribute]
private void set_IsRateTooLow(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRateTooHigh();
    [CompilerGeneratedAttribute]
private void set_IsRateTooHigh(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInputStringEmpty();
    [CompilerGeneratedAttribute]
private void set_IsInputStringEmpty(bool value);
    [CompilerGeneratedAttribute]
public string get_InputString();
    [CompilerGeneratedAttribute]
private void set_InputString(string value);
    [CompilerGeneratedAttribute]
public ulong get_Hash();
    [CompilerGeneratedAttribute]
private void set_Hash(ulong value);
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public string GetFullName(TelemetryManifestRule rule);
    public void CalculateIsSampleActive(TelemetryManifestRule rule, TelemetrySession session);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
    [CompilerGeneratedAttribute]
private bool <CalculateIsSampleActive>b__43_0(Tuple`2<HashInput, string> t);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueContains : object {
    [CompilerGeneratedAttribute]
private string <Contains>k__BackingField;
    [JsonPropertyAttribute]
public string Contains { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Contains();
    [CompilerGeneratedAttribute]
public void set_Contains(string value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueEndsWith : object {
    [CompilerGeneratedAttribute]
private string <EndsWith>k__BackingField;
    [JsonPropertyAttribute]
public string EndsWith { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EndsWith();
    [CompilerGeneratedAttribute]
public void set_EndsWith(string value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueEq : object {
    [CompilerGeneratedAttribute]
private string <Eq>k__BackingField;
    [JsonPropertyAttribute]
public string Eq { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Eq();
    [CompilerGeneratedAttribute]
public void set_Eq(string value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueExists : object {
    [CompilerGeneratedAttribute]
private bool <Exists>k__BackingField;
    [JsonPropertyAttribute]
public bool Exists { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Exists();
    [CompilerGeneratedAttribute]
public void set_Exists(bool value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueGt : object {
    [CompilerGeneratedAttribute]
private double <Gt>k__BackingField;
    [JsonPropertyAttribute]
public double Gt { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Gt();
    [CompilerGeneratedAttribute]
public void set_Gt(double value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueLt : object {
    [CompilerGeneratedAttribute]
private double <Lt>k__BackingField;
    [JsonPropertyAttribute]
public double Lt { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Lt();
    [CompilerGeneratedAttribute]
public void set_Lt(double value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueStartsWith : object {
    [CompilerGeneratedAttribute]
private string <StartsWith>k__BackingField;
    [JsonPropertyAttribute]
public string StartsWith { get; public set; }
    [CompilerGeneratedAttribute]
public string get_StartsWith();
    [CompilerGeneratedAttribute]
public void set_StartsWith(string value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestParserException : Exception {
    public TelemetryManifestParserException(string description, Exception innerException);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestRouter : object {
    [CompilerGeneratedAttribute]
private string <ChannelId>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryManifestRouteArgs <Args>k__BackingField;
    [JsonPropertyAttribute]
public string ChannelId { get; public set; }
    [JsonPropertyAttribute]
public ITelemetryManifestRouteArgs Args { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ChannelId();
    [CompilerGeneratedAttribute]
public void set_ChannelId(string value);
    [CompilerGeneratedAttribute]
public ITelemetryManifestRouteArgs get_Args();
    [CompilerGeneratedAttribute]
public void set_Args(ITelemetryManifestRouteArgs value);
    public virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestRule : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InvalidActionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryManifestMatch <When>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITelemetryManifestAction> <Actions>k__BackingField;
    [JsonPropertyAttribute]
public string Name { get; public set; }
    [JsonIgnoreAttribute]
public int InvalidActionCount { get; private set; }
    [JsonPropertyAttribute]
public ITelemetryManifestMatch When { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<ITelemetryManifestAction> Actions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_InvalidActionCount();
    [CompilerGeneratedAttribute]
private void set_InvalidActionCount(int value);
    [CompilerGeneratedAttribute]
public ITelemetryManifestMatch get_When();
    [CompilerGeneratedAttribute]
public void set_When(ITelemetryManifestMatch value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ITelemetryManifestAction> get_Actions();
    [CompilerGeneratedAttribute]
public void set_Actions(IEnumerable`1<ITelemetryManifestAction> value);
    public IEnumerable`1<TelemetryManifestMatchSampling> GetAllSamplings();
    public string CalculateAllSamplings(TelemetrySession session);
    public virtual void Validate();
    [CompilerGeneratedAttribute]
private bool <Validate>b__18_0(ITelemetryManifestAction action);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestValidationException : Exception {
    public TelemetryManifestValidationException(string description);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryMetricProperty : TelemetryDataModelProperty {
    public TelemetryMetricProperty(double val);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryNullEtwProvider : object {
    public sealed virtual void WriteActivityEndWithDurationEvent(TelemetryActivity activity);
    public sealed virtual void WriteActivityPostEvent(TelemetryActivity activity, TelemetrySession session);
    public sealed virtual void WriteActivityStartEvent(TelemetryActivity activity);
    public sealed virtual void WriteActivityStopEvent(TelemetryActivity activity);
    public sealed virtual void WriteTelemetryPostEvent(TelemetryEvent telemetryEvent, TelemetrySession session);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryPiiProperty : TelemetryHashedProperty {
    public TelemetryPiiProperty(object val);
    public virtual string ToString();
}
public class Microsoft.VisualStudio.Telemetry.TelemetryPropertyBag : Concurrent`1<object> {
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Telemetry.TelemetryPropertyBags : object {
    internal static StringComparer KeyComparer;
    private static TelemetryPropertyBags();
    [ExtensionAttribute]
public static bool HasProperties(ITelemetryPropertyBag`1<TValue> bag);
}
public enum Microsoft.VisualStudio.Telemetry.TelemetryResult : Enum {
    public int value__;
    public static TelemetryResult None;
    public static TelemetryResult Success;
    public static TelemetryResult Failure;
    public static TelemetryResult UserFault;
    public static TelemetryResult UserCancel;
}
public static class Microsoft.VisualStudio.Telemetry.TelemetryResultStrings : object {
    internal static string GetString(TelemetryResult result);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryScheduler : object {
    internal static int IsInProgressOfProcessingEvent;
    internal static int NotInProgressOfProcessingEvent;
    private int isInProcess;
    private TelemetryTaskTimer taskTimer;
    internal int IsInProgress { get; }
    internal int get_IsInProgress();
    public sealed virtual void Schedule(Func`1<Task> actionTask, Nullable`1<CancellationToken> token);
    public sealed virtual void Schedule(Action action, Nullable`1<CancellationToken> token);
    public sealed virtual void InitializeTimed(TimeSpan delay);
    public sealed virtual void ScheduleTimed(Func`1<Task> actionTask, bool recurring);
    public sealed virtual void ScheduleTimed(Action action, bool recurring);
    public sealed virtual bool CanEnterTimedDelegate();
    public sealed virtual void ExitTimedDelegate();
    public sealed virtual void CancelTimed(bool wait);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryScope`1 : object {
    [CompilerGeneratedAttribute]
private TelemetrySession <TelemetrySession>k__BackingField;
    private static int ScopeIsEnded;
    private static int ScopeIsNotEnded;
    private int isEnded;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private T <EndEvent>k__BackingField;
    private TelemetrySession TelemetrySession { get; private set; }
    private DateTime StartTime { get; private set; }
    public bool IsEnd { get; }
    public T EndEvent { get; }
    public TelemetryEventCorrelation Correlation { get; }
    internal TelemetryScope`1(TelemetrySession telemetrySession, string eventName, CreateNewEvent<T> createNewEvent, TelemetryScopeSettings settings);
    [CompilerGeneratedAttribute]
private TelemetrySession get_TelemetrySession();
    [CompilerGeneratedAttribute]
private void set_TelemetrySession(TelemetrySession value);
    [CompilerGeneratedAttribute]
private DateTime get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTime value);
    public bool get_IsEnd();
    [CompilerGeneratedAttribute]
public T get_EndEvent();
    public TelemetryEventCorrelation get_Correlation();
    public void End(TelemetryResult result, string resultSummary);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryScopeSettings : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <StartEventProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetrySeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptOutFriendly>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryEventCorrelation[] <Correlations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PostStartEvent>k__BackingField;
    public IDictionary`2<string, object> StartEventProperties { get; public set; }
    public TelemetrySeverity Severity { get; public set; }
    public bool IsOptOutFriendly { get; public set; }
    public TelemetryEventCorrelation[] Correlations { get; public set; }
    public bool PostStartEvent { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_StartEventProperties();
    [CompilerGeneratedAttribute]
public void set_StartEventProperties(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public TelemetrySeverity get_Severity();
    [CompilerGeneratedAttribute]
public void set_Severity(TelemetrySeverity value);
    [CompilerGeneratedAttribute]
public bool get_IsOptOutFriendly();
    [CompilerGeneratedAttribute]
public void set_IsOptOutFriendly(bool value);
    [CompilerGeneratedAttribute]
public TelemetryEventCorrelation[] get_Correlations();
    [CompilerGeneratedAttribute]
public void set_Correlations(TelemetryEventCorrelation[] value);
    [CompilerGeneratedAttribute]
public bool get_PostStartEvent();
    [CompilerGeneratedAttribute]
public void set_PostStartEvent(bool value);
}
[CLSCompliantAttribute("False")]
public static class Microsoft.VisualStudio.Telemetry.TelemetryService : object {
    private static object lockDefaultSessionCreation;
    [CompilerGeneratedAttribute]
private static TelemetrySession <InternalDefaultSession>k__BackingField;
    [CompilerGeneratedAttribute]
private static ITelemetryEtwProvider <TelemetryEventSource>k__BackingField;
    internal static TelemetrySession InternalDefaultSession { get; internal set; }
    public static TelemetrySession DefaultSession { get; }
    public static AssetService AssetService { get; }
    internal static ITelemetryEtwProvider TelemetryEventSource { get; internal set; }
    private static TelemetryService();
    [CompilerGeneratedAttribute]
internal static TelemetrySession get_InternalDefaultSession();
    [CompilerGeneratedAttribute]
internal static void set_InternalDefaultSession(TelemetrySession value);
    public static TelemetrySession get_DefaultSession();
    public static AssetService get_AssetService();
    [CompilerGeneratedAttribute]
internal static ITelemetryEtwProvider get_TelemetryEventSource();
    [CompilerGeneratedAttribute]
internal static void set_TelemetryEventSource(ITelemetryEtwProvider value);
    public static void SetDefaultSession(TelemetrySession telemetrySession);
    public static bool TrySetDefaultSession(TelemetrySession telemetrySession);
    public static TelemetrySession CreateAndGetDefaultSession(string appInsightsIKey, string asimovIKey);
    public static TelemetrySession CreateAndGetDefaultSession(string collectorApiKey);
    public static TelemetrySession CreateAndGetDefaultSession(string appInsightsIKey, string asimovIKey, string collectorApiKey);
    public static void AttachTestChannel(ITelemetryTestChannel channel);
    public static void DetachTestChannel(ITelemetryTestChannel channel);
    public static void InitializeEtwProvider(ITelemetryEtwProvider provider);
    internal static void EnsureEtwProviderInitialized();
}
public class Microsoft.VisualStudio.Telemetry.TelemetrySession : TelemetryDisposableObject {
    public static string ValueNotAvailable;
    public static string DefaultContextName;
    private ITelemetrySessionInternal internalTelemetrySessionObject;
    internal bool UseCollector { get; internal set; }
    public string SessionId { get; }
    public bool IsOptedIn { get; public set; }
    public List`1<BucketFilter> BucketFiltersToEnableWatsonForFaults { get; public set; }
    public List`1<BucketFilter> BucketFiltersToAddDumpsToFaults { get; public set; }
    public string HostName { get; public set; }
    public CancellationToken CancellationToken { get; }
    [CLSCompliantAttribute("False")]
public UInt32 AppId { get; public set; }
    public bool CanCollectPrivateInformation { get; }
    public bool IsUserMicrosoftInternal { get; }
    public string CalculatedSamplings { get; }
    public Guid MachineId { get; }
    public Guid UserId { get; }
    public string MacAddressHash { get; }
    public long TimeSinceSessionStart { get; }
    unknown Action InitializedAction {internal set; }
    internal EventHandler`1<TelemetryTestChannelEventArgs> RawTelemetryEventReceived { get; internal set; }
    internal EventProcessor EventProcessor { get; }
    internal TelemetryContext DefaultContext { get; }
    internal bool IsSessionCloned { get; }
    internal TelemetrySessionSettings SessionSettings { get; }
    internal ITelemetryManifestManager ManifestManager { get; }
    internal long ProcessStartTime { get; }
    internal int ProcessPid { get; }
    public TelemetrySession(string serializedSession);
    internal TelemetrySession(TelemetrySessionSettings telemetrySessionSettings);
    internal TelemetrySession(string serializedSession, TelemetrySessionInitializer initializerObject);
    internal TelemetrySession(TelemetrySessionSettings settings, bool isCloned, TelemetrySessionInitializer initializerObject);
    internal ITelemetrySessionInternal GetTelemetrySessionInternal();
    internal void SetTelemetrySessionInternal(ITelemetrySessionInternal internalSession);
    internal bool get_UseCollector();
    internal void set_UseCollector(bool value);
    public string get_SessionId();
    public bool get_IsOptedIn();
    public void set_IsOptedIn(bool value);
    public List`1<BucketFilter> get_BucketFiltersToEnableWatsonForFaults();
    public void set_BucketFiltersToEnableWatsonForFaults(List`1<BucketFilter> value);
    public List`1<BucketFilter> get_BucketFiltersToAddDumpsToFaults();
    public void set_BucketFiltersToAddDumpsToFaults(List`1<BucketFilter> value);
    public string get_HostName();
    public void set_HostName(string value);
    public CancellationToken get_CancellationToken();
    public UInt32 get_AppId();
    public void set_AppId(UInt32 value);
    public bool get_CanCollectPrivateInformation();
    public bool get_IsUserMicrosoftInternal();
    public string get_CalculatedSamplings();
    public Guid get_MachineId();
    public Guid get_UserId();
    public string get_MacAddressHash();
    public long get_TimeSinceSessionStart();
    internal void set_InitializedAction(Action value);
    internal EventHandler`1<TelemetryTestChannelEventArgs> get_RawTelemetryEventReceived();
    internal void set_RawTelemetryEventReceived(EventHandler`1<TelemetryTestChannelEventArgs> value);
    internal EventProcessor get_EventProcessor();
    internal TelemetryContext get_DefaultContext();
    internal bool get_IsSessionCloned();
    internal TelemetrySessionSettings get_SessionSettings();
    internal ITelemetryManifestManager get_ManifestManager();
    public void Start();
    public void UseVsIsOptedIn(string productVersion);
    public void UseVsIsOptedIn();
    public TelemetryContext CreateContext(string contextName);
    public TelemetryContext GetContext(string contextName);
    public void PostEvent(string eventName);
    public void PostEvent(TelemetryEvent telemetryEvent);
    public void PostMetricEvent(TelemetryMetricEvent metricEvent);
    public void PostProperty(string propertyName, object propertyValue);
    public void PostRecurringProperty(string propertyName, object propertyValue);
    public void AddSessionChannel(ISessionChannel sessionChannel);
    public string SerializeSettings();
    public void SetSharedProperty(string propertyName, object propertyValue);
    public void RemoveSharedProperty(string propertyName);
    public object GetSharedProperty(string propertyName);
    public object GetSharedPropertyAsObject(string propertyName);
    public void SetPersistedSharedProperty(string propertyName, string propertyValue);
    public void SetPersistedSharedProperty(string propertyName, double propertyValue);
    public void RemovePersistedSharedProperty(string propertyName);
    public object GetPersistedSharedProperty(string propertyName);
    public void RegisterPropertyBag(string name, TelemetryPropertyBag propertyBag);
    public void UnregisterPropertyBag(string name);
    public TelemetryPropertyBag GetPropertyBag(string name);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetrySession/<DisposeToNetworkAsync>d__82")]
public Task DisposeToNetworkAsync(CancellationToken token);
    public void RegisterForReliabilityEvent();
    internal long get_ProcessStartTime();
    internal int get_ProcessPid();
    internal void Start(bool checkPendingAsimovEvents);
    internal static TelemetrySession Create();
    internal static TelemetrySession Create(TelemetrySessionInitializer initializerObject);
    internal bool Equals(TelemetrySession other);
    internal void PostValidatedEvent(TelemetryEvent telemetryEvent);
    internal void AddContext(TelemetryContext telemetryContext);
    internal void RemoveContext(TelemetryContext telemetryContext);
    internal void AddSessionChannels(IEnumerable`1<ISessionChannel> channels);
    internal bool GetCachedUseCollectorFromRegistry();
    internal bool SetUseCollectorToRegistry(Nullable`1<bool> value);
    internal void AddContextProperties(TelemetryEvent telemetryEvent);
    internal static string Guard(Func`1<string> provider, string defaultValue);
    internal static void ValidateEvent(TelemetryEvent telemetryEvent);
    internal void ProcessManifestUseCollectorProperty(TelemetryManifest manifest);
    public virtual string ToString();
    protected virtual void DisposeManagedResources();
    public void AddCommonPropertyRange(IDictionary`2<string, object> properties);
    public bool TryAddCommonProperty(string propertyName, object propertyValue);
    public bool TryGetCommonPropertyValue(string propertyName, Object& value);
    public IDictionary`2<string, object> GetCommonPropertyDictionary();
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Telemetry.TelemetrySessionCommandLineExtensions : object {
    internal static string CommandLineFlagsEventName;
    internal static string CommandLineFlagsPropertiesPrefix;
    internal static string CommandLineFlagsArgumentsCountProperty;
    internal static string CommandLineFlagsFlagsCountProperty;
    internal static string CommandLineFlagsFirstFlagProperty;
    internal static string CommandLineFlagsFlagsProperty;
    [CompilerGeneratedAttribute]
private static Func`1<String[]> <GetCommandLineArgsFunc>k__BackingField;
    internal static Func`1<String[]> GetCommandLineArgsFunc { get; internal set; }
    private static TelemetrySessionCommandLineExtensions();
    [ExtensionAttribute]
public static void PostCommandLineFlags(TelemetrySession session, String[] flagPrefixes);
    [ExtensionAttribute]
public static void PostCommandLineFlags(TelemetrySession session, IEnumerable`1<string> flagPrefixes, IDictionary`2<string, object> additionalProperties);
    [CompilerGeneratedAttribute]
internal static Func`1<String[]> get_GetCommandLineArgsFunc();
    [CompilerGeneratedAttribute]
internal static void set_GetCommandLineArgsFunc(Func`1<String[]> value);
    private static CommandLineFlagsInfo ComputeCommandLineFlags(IEnumerable`1<string> flagPrefixes);
    private static String[] GetCommandLineArgs();
    [ExtensionAttribute]
private static Tuple`2<bool, string> TryGetValidFlag(string argument, String[] flagPrefixes);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Telemetry.TelemetrySessionExtensions : object {
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostUserTask(TelemetrySession session, string eventName, TelemetryResult result, string resultSummary, TelemetryEventCorrelation[] correlatedWith);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostOperation(TelemetrySession session, string eventName, TelemetryResult result, string resultSummary, TelemetryEventCorrelation[] correlatedWith);
    [ExtensionAttribute]
public static TelemetryScope`1<UserTaskEvent> StartUserTask(TelemetrySession session, string eventName);
    [ExtensionAttribute]
public static TelemetryScope`1<UserTaskEvent> StartUserTask(TelemetrySession session, string eventName, TelemetrySeverity severity);
    [ExtensionAttribute]
public static TelemetryScope`1<UserTaskEvent> StartUserTask(TelemetrySession session, string eventName, TelemetrySeverity severity, IDictionary`2<string, object> startEventProperties);
    [ExtensionAttribute]
public static TelemetryScope`1<UserTaskEvent> StartUserTask(TelemetrySession session, string eventName, TelemetrySeverity severity, IDictionary`2<string, object> startEventProperties, TelemetryEventCorrelation[] correlations);
    [ExtensionAttribute]
public static TelemetryScope`1<UserTaskEvent> StartUserTask(TelemetrySession session, string eventName, TelemetryScopeSettings settings);
    [ExtensionAttribute]
public static TelemetryScope`1<OperationEvent> StartOperation(TelemetrySession session, string eventName);
    [ExtensionAttribute]
public static TelemetryScope`1<OperationEvent> StartOperation(TelemetrySession session, string eventName, TelemetrySeverity severity);
    [ExtensionAttribute]
public static TelemetryScope`1<OperationEvent> StartOperation(TelemetrySession session, string eventName, TelemetrySeverity severity, IDictionary`2<string, object> startEventProperties);
    [ExtensionAttribute]
public static TelemetryScope`1<OperationEvent> StartOperation(TelemetrySession session, string eventName, TelemetrySeverity severity, IDictionary`2<string, object> startEventProperties, TelemetryEventCorrelation[] correlations);
    [ExtensionAttribute]
public static TelemetryScope`1<OperationEvent> StartOperation(TelemetrySession session, string eventName, TelemetryScopeSettings settings);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, FaultSeverity faultSeverity);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, Exception exceptionObject);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, FaultSeverity faultSeverity, Exception exceptionObject);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, FaultSeverity faultSeverity, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails, TelemetryEventCorrelation[] correlatedWith);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, FaultSeverity faultSeverity, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails, TelemetryEventCorrelation[] correlatedWith);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostAsset(TelemetrySession telemetrySession, string eventName, string assetId, int assetEventVersion, IDictionary`2<string, object> properties, TelemetryEventCorrelation[] correlatedWith);
    [ExtensionAttribute]
private static TelemetryEventCorrelation PostOperationHelper(TelemetrySession session, Func`1<T> createEvent, TelemetryEventCorrelation[] correlatedWith);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetrySessionInitializer : object {
    [CompilerGeneratedAttribute]
private CancellationTokenSource <CancellationTokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppInsightsInstrumentationKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AsimovInstrumentationKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectorApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IDiagnosticTelemetry <DiagnosticTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentityTelemetry <IdentityTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnvironmentTools <EnvironmentTools>k__BackingField;
    [CompilerGeneratedAttribute]
private IRegistryTools4 <RegistryTools>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryOptinStatusReader <OptinStatusReader>k__BackingField;
    [CompilerGeneratedAttribute]
private IProcessTools <ProcessTools>k__BackingField;
    [CompilerGeneratedAttribute]
private ILegacyApi <LegacyApi>k__BackingField;
    [CompilerGeneratedAttribute]
private IInternalSettings <InternalSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IHostInformationProvider <HostInformationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IMachineInformationProvider <MachineInformationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IMACInformationProvider <MACInformationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IUserInformationProvider <UserInformationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryScheduler <EventProcessorScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryScheduler <ContextScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryScheduler <RecurringPropertyUpdateScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryScheduler <RecurringPropertyScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryManifestManagerBuilder <TelemetryManifestManagerBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IContextPropertyManager <DefaultContextPropertyManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IPersistentPropertyBag <PersistentStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private IPersistentPropertyBag <PersistentSharedProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IPersistentPropertyBag <PersistentPropertyBag>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IChannelValidator> <ChannelValidators>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ISessionChannel> <ChannelsToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IEventProcessorAction> <CustomActionToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPropertyProvider> <PropertyProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private EventProcessorChannelBuilder <EventProcessorChannelBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private WatsonSessionChannelBuilder <WatsonSessionChannelBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IProcessCreationTime <ProcessCreationTime>k__BackingField;
    public CancellationTokenSource CancellationTokenSource { get; public set; }
    public string SessionId { get; public set; }
    public string AppInsightsInstrumentationKey { get; public set; }
    public string AsimovInstrumentationKey { get; public set; }
    public string CollectorApiKey { get; public set; }
    public IDiagnosticTelemetry DiagnosticTelemetry { get; public set; }
    public IIdentityTelemetry IdentityTelemetry { get; public set; }
    public IEnvironmentTools EnvironmentTools { get; public set; }
    public IRegistryTools4 RegistryTools { get; public set; }
    public ITelemetryOptinStatusReader OptinStatusReader { get; public set; }
    public IProcessTools ProcessTools { get; public set; }
    public ILegacyApi LegacyApi { get; public set; }
    public IInternalSettings InternalSettings { get; public set; }
    public IHostInformationProvider HostInformationProvider { get; public set; }
    public IMachineInformationProvider MachineInformationProvider { get; public set; }
    public IMACInformationProvider MACInformationProvider { get; public set; }
    public IUserInformationProvider UserInformationProvider { get; public set; }
    public ITelemetryScheduler EventProcessorScheduler { get; public set; }
    public ITelemetryScheduler ContextScheduler { get; public set; }
    public ITelemetryScheduler RecurringPropertyUpdateScheduler { get; public set; }
    public ITelemetryScheduler RecurringPropertyScheduler { get; public set; }
    public ITelemetryManifestManagerBuilder TelemetryManifestManagerBuilder { get; public set; }
    public IContextPropertyManager DefaultContextPropertyManager { get; public set; }
    public IPersistentPropertyBag PersistentStorage { get; public set; }
    public IPersistentPropertyBag PersistentSharedProperties { get; public set; }
    public IPersistentPropertyBag PersistentPropertyBag { get; public set; }
    public IEnumerable`1<IChannelValidator> ChannelValidators { get; public set; }
    public IEnumerable`1<ISessionChannel> ChannelsToAdd { get; public set; }
    public IEnumerable`1<IEventProcessorAction> CustomActionToAdd { get; public set; }
    public IEnumerable`1<IPropertyProvider> PropertyProviders { get; public set; }
    public EventProcessorChannelBuilder EventProcessorChannelBuilder { get; public set; }
    public WatsonSessionChannelBuilder WatsonSessionChannelBuilder { get; public set; }
    public IProcessCreationTime ProcessCreationTime { get; public set; }
    public static TelemetrySessionInitializer Default { get; }
    [CompilerGeneratedAttribute]
public CancellationTokenSource get_CancellationTokenSource();
    [CompilerGeneratedAttribute]
public void set_CancellationTokenSource(CancellationTokenSource value);
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(string value);
    [CompilerGeneratedAttribute]
public string get_AppInsightsInstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_AppInsightsInstrumentationKey(string value);
    [CompilerGeneratedAttribute]
public string get_AsimovInstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_AsimovInstrumentationKey(string value);
    [CompilerGeneratedAttribute]
public string get_CollectorApiKey();
    [CompilerGeneratedAttribute]
public void set_CollectorApiKey(string value);
    [CompilerGeneratedAttribute]
public IDiagnosticTelemetry get_DiagnosticTelemetry();
    [CompilerGeneratedAttribute]
public void set_DiagnosticTelemetry(IDiagnosticTelemetry value);
    [CompilerGeneratedAttribute]
public IIdentityTelemetry get_IdentityTelemetry();
    [CompilerGeneratedAttribute]
public void set_IdentityTelemetry(IIdentityTelemetry value);
    [CompilerGeneratedAttribute]
public IEnvironmentTools get_EnvironmentTools();
    [CompilerGeneratedAttribute]
public void set_EnvironmentTools(IEnvironmentTools value);
    [CompilerGeneratedAttribute]
public IRegistryTools4 get_RegistryTools();
    [CompilerGeneratedAttribute]
public void set_RegistryTools(IRegistryTools4 value);
    [CompilerGeneratedAttribute]
public ITelemetryOptinStatusReader get_OptinStatusReader();
    [CompilerGeneratedAttribute]
public void set_OptinStatusReader(ITelemetryOptinStatusReader value);
    [CompilerGeneratedAttribute]
public IProcessTools get_ProcessTools();
    [CompilerGeneratedAttribute]
public void set_ProcessTools(IProcessTools value);
    [CompilerGeneratedAttribute]
public ILegacyApi get_LegacyApi();
    [CompilerGeneratedAttribute]
public void set_LegacyApi(ILegacyApi value);
    [CompilerGeneratedAttribute]
public IInternalSettings get_InternalSettings();
    [CompilerGeneratedAttribute]
public void set_InternalSettings(IInternalSettings value);
    [CompilerGeneratedAttribute]
public IHostInformationProvider get_HostInformationProvider();
    [CompilerGeneratedAttribute]
public void set_HostInformationProvider(IHostInformationProvider value);
    [CompilerGeneratedAttribute]
public IMachineInformationProvider get_MachineInformationProvider();
    [CompilerGeneratedAttribute]
public void set_MachineInformationProvider(IMachineInformationProvider value);
    [CompilerGeneratedAttribute]
public IMACInformationProvider get_MACInformationProvider();
    [CompilerGeneratedAttribute]
public void set_MACInformationProvider(IMACInformationProvider value);
    [CompilerGeneratedAttribute]
public IUserInformationProvider get_UserInformationProvider();
    [CompilerGeneratedAttribute]
public void set_UserInformationProvider(IUserInformationProvider value);
    [CompilerGeneratedAttribute]
public ITelemetryScheduler get_EventProcessorScheduler();
    [CompilerGeneratedAttribute]
public void set_EventProcessorScheduler(ITelemetryScheduler value);
    [CompilerGeneratedAttribute]
public ITelemetryScheduler get_ContextScheduler();
    [CompilerGeneratedAttribute]
public void set_ContextScheduler(ITelemetryScheduler value);
    [CompilerGeneratedAttribute]
public ITelemetryScheduler get_RecurringPropertyUpdateScheduler();
    [CompilerGeneratedAttribute]
public void set_RecurringPropertyUpdateScheduler(ITelemetryScheduler value);
    [CompilerGeneratedAttribute]
public ITelemetryScheduler get_RecurringPropertyScheduler();
    [CompilerGeneratedAttribute]
public void set_RecurringPropertyScheduler(ITelemetryScheduler value);
    [CompilerGeneratedAttribute]
public ITelemetryManifestManagerBuilder get_TelemetryManifestManagerBuilder();
    [CompilerGeneratedAttribute]
public void set_TelemetryManifestManagerBuilder(ITelemetryManifestManagerBuilder value);
    [CompilerGeneratedAttribute]
public IContextPropertyManager get_DefaultContextPropertyManager();
    [CompilerGeneratedAttribute]
public void set_DefaultContextPropertyManager(IContextPropertyManager value);
    [CompilerGeneratedAttribute]
public IPersistentPropertyBag get_PersistentStorage();
    [CompilerGeneratedAttribute]
public void set_PersistentStorage(IPersistentPropertyBag value);
    [CompilerGeneratedAttribute]
public IPersistentPropertyBag get_PersistentSharedProperties();
    [CompilerGeneratedAttribute]
public void set_PersistentSharedProperties(IPersistentPropertyBag value);
    [CompilerGeneratedAttribute]
public IPersistentPropertyBag get_PersistentPropertyBag();
    [CompilerGeneratedAttribute]
public void set_PersistentPropertyBag(IPersistentPropertyBag value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IChannelValidator> get_ChannelValidators();
    [CompilerGeneratedAttribute]
public void set_ChannelValidators(IEnumerable`1<IChannelValidator> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ISessionChannel> get_ChannelsToAdd();
    [CompilerGeneratedAttribute]
public void set_ChannelsToAdd(IEnumerable`1<ISessionChannel> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IEventProcessorAction> get_CustomActionToAdd();
    [CompilerGeneratedAttribute]
public void set_CustomActionToAdd(IEnumerable`1<IEventProcessorAction> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IPropertyProvider> get_PropertyProviders();
    [CompilerGeneratedAttribute]
public void set_PropertyProviders(IEnumerable`1<IPropertyProvider> value);
    [CompilerGeneratedAttribute]
public EventProcessorChannelBuilder get_EventProcessorChannelBuilder();
    [CompilerGeneratedAttribute]
public void set_EventProcessorChannelBuilder(EventProcessorChannelBuilder value);
    [CompilerGeneratedAttribute]
public WatsonSessionChannelBuilder get_WatsonSessionChannelBuilder();
    [CompilerGeneratedAttribute]
public void set_WatsonSessionChannelBuilder(WatsonSessionChannelBuilder value);
    [CompilerGeneratedAttribute]
public IProcessCreationTime get_ProcessCreationTime();
    [CompilerGeneratedAttribute]
public void set_ProcessCreationTime(IProcessCreationTime value);
    public static TelemetrySessionInitializer get_Default();
    public static TelemetrySessionInitializer FromSessionSettings(TelemetrySessionSettings telemetrySessionSettings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetrySessionInitializer/<CreateSessionChannels>d__135")]
public IEnumerable`1<ISessionChannel> CreateSessionChannels(TelemetrySession telemetrySession, bool checkPendingAsimovEvents);
    public void Validate();
    private static TelemetrySessionInitializer BuildInitializer(TelemetrySessionSettings telemetrySessionSettings);
    private static ILegacyApi GetLegacyApi(IRegistryTools registryTools);
    private static IMACInformationProvider GetMACInformationProvider(IProcessTools processTools, IPersistentPropertyBag persistentStorage, ILegacyApi legacyApi);
    private static IHostInformationProvider GetHostInformationProvider();
    private static IIdentityInformationProvider GetIdentityInformationProvider();
    private static IUserInformationProvider GetUserInformationProvider(IRegistryTools registryTools, IInternalSettings internalSettings, IEnvironmentTools environmentTools, ILegacyApi legacyApi, TelemetrySessionSettings telemetrySessionSettings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetrySessionInitializer/<GetPropertyProviders>d__143")]
private static IEnumerable`1<IPropertyProvider> GetPropertyProviders(IRegistryTools registryTools, IEnvironmentTools environmentTools, IHostInformationProvider host, IMachineInformationProvider machine, IMACInformationProvider macAddress, IUserInformationProvider user, IPersistentPropertyBag sharedProperties, IIdentityInformationProvider identity);
    private static IStorageBuilder GetStorageBuilder();
    internal static IProcessCreationTime GetProcessCreationTime(string collectorKey);
    private static IInternalSettings GetInternalSettings(IDiagnosticTelemetry diagnosticTelemetry, IRegistryTools registryTools);
    private static ITelemetryOptinStatusReader GetOptInStatusReader(IRegistryTools2 registryTools);
    private static IPersistentPropertyBag CreatePersistentPropertyBag(string processName);
    private static IProcessLockFactory GetProcessLock();
}
internal abstract class Microsoft.VisualStudio.Telemetry.TelemetrySessionInternalBase : TelemetryDisposableObject {
    protected static string UseCollectorRegKeyName;
    protected string useCollectorRegKeyPath;
    private static string CommonPropertyBagPathEnvironmentVariableName;
    public static string ValueNotAvailable;
    public static string DefaultContextName;
    private static int WaitForPendingPostingTimeout;
    private static int DisposingIsStarted;
    private static int DisposingNotStarted;
    private static int RecurringPropertyUpdateDelaySeconds;
    private static int RecurringPropertyDelayMinutes;
    protected TelemetrySessionInitializer sessionInitializer;
    private Concurrent`1<TelemetryContext> sessionContexts;
    private LinkedList`1<TelemetryContext> sessionContextStack;
    private object startedLock;
    private object initializedLock;
    private Concurrent`1<TelemetryPropertyBag> propertyBagDictionary;
    private Concurrent`1<object> recurringProperties;
    protected Concurrent`1<object> commonProperties;
    private IMachineInformationProvider machineInformationProvider;
    private IMACInformationProvider macInformationProvider;
    private IUserInformationProvider userInformationProvider;
    private TelemetryContext defaultContext;
    protected TelemetrySessionSettings sessionSettings;
    private IContextPropertyManager defaultContextPropertyManager;
    private EventProcessorChannel eventProcessorChannel;
    private IEnumerable`1<IChannelValidator> channelValidators;
    private Lazy`1<ITelemetryManifestManager> telemetryManifestManager;
    private IPersistentPropertyBag persistentPropertyBag;
    private IPersistentPropertyBag persistentSharedProperties;
    private ITelemetryScheduler contextScheduler;
    private ITelemetryScheduler recurringPropertyUpdateScheduler;
    private ITelemetryScheduler recurringPropertyScheduler;
    private CancellationTokenSource cancellationTokenSource;
    private IDiagnosticTelemetry diagnosticTelemetry;
    private IIdentityTelemetry identityTelemetry;
    private ITelemetryOptinStatusReader optinStatusReader;
    private HashSet`1<string> defaultSessionChannelsId;
    private bool isSessionCloned;
    private Lazy`1<string> previousSessionShutdownRegistryPath;
    [CompilerGeneratedAttribute]
private bool <UseCollector>k__BackingField;
    private ReaderWriterLockSlim customEventPostProtection;
    private TelemetryBufferChannel telemetryBufferChannel;
    private WatsonSessionChannel watsonSessionChannel;
    private Stopwatch disposeLatencyTimer;
    private int numberOfDroppedEventsInDisposing;
    private bool isSessionStarted;
    private bool isInitialized;
    private bool isManifestCompleted;
    private bool isMACAddressCompleted;
    private bool isHardwareIdCompleted;
    private int startedDisposing;
    [CompilerGeneratedAttribute]
private ProductTarget <ProductScenario>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CalculatedSamplings>k__BackingField;
    private EventHandler`1<TelemetryTestChannelEventArgs> rawTelemetryEventReceived;
    [CompilerGeneratedAttribute]
private EventProcessor <EventProcessor>k__BackingField;
    private TelemetrySession hostTelemetrySession;
    public bool UseCollector { get; public set; }
    public string SessionId { get; }
    public ProductTarget ProductScenario { get; internal set; }
    public bool IsOptedIn { get; public set; }
    public List`1<BucketFilter> BucketFiltersToEnableWatsonForFaults { get; public set; }
    public List`1<BucketFilter> BucketFiltersToAddDumpsToFaults { get; public set; }
    public string HostName { get; public set; }
    public CancellationToken CancellationToken { get; }
    public UInt32 AppId { get; public set; }
    public bool CanCollectPrivateInformation { get; }
    public bool IsUserMicrosoftInternal { get; }
    public string CalculatedSamplings { get; private set; }
    public Guid MachineId { get; }
    public Guid UserId { get; }
    public string MacAddressHash { get; }
    unknown Action InitializedAction {public set; }
    public EventHandler`1<TelemetryTestChannelEventArgs> RawTelemetryEventReceived { get; public set; }
    private EventProcessor Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.EventProcessor { get; }
    private TelemetryContext Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.DefaultContext { get; }
    private ITelemetryManifestManager Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.ManifestManager { get; }
    private TelemetrySessionSettings Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.SessionSettings { get; }
    private bool Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.IsSessionCloned { get; }
    internal EventProcessor EventProcessor { get; }
    internal TelemetryContext DefaultContext { get; }
    internal bool IsSessionCloned { get; }
    internal ITelemetryManifestManager ManifestManager { get; }
    internal TelemetrySessionSettings SessionSettings { get; }
    public long ProcessStartTime { get; }
    public int ProcessPid { get; }
    internal TelemetrySessionInternalBase(TelemetrySessionSettings settings, bool isCloned, TelemetrySessionInitializer initializerObject, TelemetrySession session);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseCollector();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseCollector(bool value);
    public sealed virtual string get_SessionId();
    [CompilerGeneratedAttribute]
public ProductTarget get_ProductScenario();
    [CompilerGeneratedAttribute]
internal void set_ProductScenario(ProductTarget value);
    public sealed virtual bool get_IsOptedIn();
    public sealed virtual void set_IsOptedIn(bool value);
    public sealed virtual List`1<BucketFilter> get_BucketFiltersToEnableWatsonForFaults();
    public sealed virtual void set_BucketFiltersToEnableWatsonForFaults(List`1<BucketFilter> value);
    public sealed virtual List`1<BucketFilter> get_BucketFiltersToAddDumpsToFaults();
    public sealed virtual void set_BucketFiltersToAddDumpsToFaults(List`1<BucketFilter> value);
    public sealed virtual string get_HostName();
    public sealed virtual void set_HostName(string value);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual UInt32 get_AppId();
    public sealed virtual void set_AppId(UInt32 value);
    public sealed virtual bool get_CanCollectPrivateInformation();
    public sealed virtual bool get_IsUserMicrosoftInternal();
    [CompilerGeneratedAttribute]
public sealed virtual string get_CalculatedSamplings();
    [CompilerGeneratedAttribute]
private void set_CalculatedSamplings(string value);
    public sealed virtual Guid get_MachineId();
    public sealed virtual Guid get_UserId();
    public sealed virtual string get_MacAddressHash();
    public sealed virtual void set_InitializedAction(Action value);
    public sealed virtual EventHandler`1<TelemetryTestChannelEventArgs> get_RawTelemetryEventReceived();
    public sealed virtual void set_RawTelemetryEventReceived(EventHandler`1<TelemetryTestChannelEventArgs> value);
    private sealed virtual override EventProcessor Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.get_EventProcessor();
    private sealed virtual override TelemetryContext Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.get_DefaultContext();
    private sealed virtual override ITelemetryManifestManager Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.get_ManifestManager();
    private sealed virtual override TelemetrySessionSettings Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.get_SessionSettings();
    private sealed virtual override bool Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.get_IsSessionCloned();
    [CompilerGeneratedAttribute]
internal EventProcessor get_EventProcessor();
    internal TelemetryContext get_DefaultContext();
    internal bool get_IsSessionCloned();
    internal ITelemetryManifestManager get_ManifestManager();
    internal TelemetrySessionSettings get_SessionSettings();
    public sealed virtual void UseVsIsOptedIn(string productVersion);
    public sealed virtual void UseVsIsOptedIn();
    public sealed virtual TelemetryContext CreateContext(string contextName);
    public sealed virtual TelemetryContext GetContext(string contextName);
    public sealed virtual void PostEvent(string eventName);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostMetricEvent(TelemetryMetricEvent metricEvent);
    public sealed virtual void PostProperty(string propertyName, object propertyValue);
    public sealed virtual void PostRecurringProperty(string propertyName, object propertyValue);
    public sealed virtual void AddSessionChannel(ISessionChannel sessionChannel);
    public sealed virtual string SerializeSettings();
    public sealed virtual void SetSharedProperty(string propertyName, object propertyValue);
    public sealed virtual void RemoveSharedProperty(string propertyName);
    public sealed virtual object GetSharedProperty(string propertyName);
    public sealed virtual object GetSharedPropertyAsObject(string propertyName);
    public sealed virtual void RemovePersistedSharedProperty(string propertyName);
    public sealed virtual object GetPersistedSharedProperty(string propertyName);
    public sealed virtual void RegisterPropertyBag(string name, TelemetryPropertyBag propertyBag);
    public sealed virtual void UnregisterPropertyBag(string name);
    public sealed virtual TelemetryPropertyBag GetPropertyBag(string name);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetrySessionInternalBase/<DisposeToNetworkAsync>d__140")]
public sealed virtual Task DisposeToNetworkAsync(CancellationToken token);
    protected abstract virtual string InitializeReliabilityRegistryPath();
    protected abstract virtual string GetUseCollectorRegKeyPath();
    public sealed virtual void RegisterForReliabilityEvent();
    private void SetReliabiltyValuesInRegistry(string regPath);
    private string GetExeName();
    public sealed virtual long get_ProcessStartTime();
    public sealed virtual int get_ProcessPid();
    public sealed virtual void Start(bool checkPendingAsimovEvents);
    private void SetSharedPropertiesFromSessionSettings();
    public sealed virtual bool Equals(TelemetrySession other);
    public sealed virtual void PostValidatedEvent(TelemetryEvent telemetryEvent);
    private void AddAdditionalProperties(TelemetryEvent channelTelemetryEvent);
    public sealed virtual void AddContext(TelemetryContext telemetryContext);
    public sealed virtual void RemoveContext(TelemetryContext telemetryContext);
    public sealed virtual void AddSessionChannels(IEnumerable`1<ISessionChannel> channels);
    protected virtual void DisposeManagedResources();
    private bool DisposeStart();
    private void DisposeEnd();
    private bool IsValidChannel(ISessionChannel sessionChannel);
    private static void RequiresNotDefaultContextName(string contextName);
    private void PostProcessedEvent(TelemetryEvent telemetryEvent);
    public abstract virtual bool GetCachedUseCollectorFromRegistry();
    public sealed virtual bool SetUseCollectorToRegistry(Nullable`1<bool> value);
    private TelemetryContext CreateDefaultContext();
    private void InitializeWithDefaultChannels(bool checkPendingAsimovEvents);
    private void SetOptedInProperty();
    private void SetInternalInformationProperties(TelemetryManifest telemetryManifest);
    private void SetInternalUserNameIfApplicable(TelemetryManifest telemetryManifest);
    private void SetInternalComputerNameIfApplicable();
    private void SetInternalDomainNameIfApplicable();
    public sealed virtual void AddContextProperties(TelemetryEvent telemetryEvent);
    public sealed virtual void SetPersistedSharedProperty(string propertyName, string propertyValue);
    public sealed virtual void SetPersistedSharedProperty(string propertyName, double propertyValue);
    public sealed virtual void SetPersistedSharedProperty(string propertyName, object propertyValue, Action addToBagAction);
    private void FlushRecurringProperties();
    private void TelemetryManifestUpdateStatus(object sender, TelemetryManifestEventArgs e);
    public sealed virtual void ProcessManifestUseCollectorProperty(TelemetryManifest manifest);
    private void MACAddressHashCalculationCompleted(object sender, EventArgs e);
    private void HardwareIdCalculationCompleted(object sender, EventArgs e);
    private void InitializeSession();
    private bool ValidateHostName(string hostName);
    private void IndicateNormalShutdown();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetrySessionInternalBase/<StartReliabilityHeartbeat>d__185")]
private Task StartReliabilityHeartbeat();
    private static void SetRegistryFromCurrentUserRoot(string regKeyPath, string regKeyName, object value, RegistryValueKind kind);
    public sealed virtual void AddCommonProperties(IDictionary`2<string, object> properties);
    public sealed virtual bool TryAddCommonProperty(string propertyName, object propertyValue);
    public sealed virtual bool TryGetCommonPropertyValue(string propertyName, Object& value);
    private void AddCommonPropertiesToEvent(TelemetryEvent channelTelemetryEvent);
    public sealed virtual IDictionary`2<string, object> GetCommonPropertyDictionary();
    public virtual string ToString();
    public sealed virtual TelemetrySession GetHostTelemetrySession();
    public sealed virtual void LoadCommonProperties();
    private void LoadCommonPropertiesFromFile();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetrySessionInternalVS : TelemetrySessionInternalBase {
    internal TelemetrySessionInternalVS(TelemetrySessionSettings settings, bool isCloned, TelemetrySessionInitializer initializerObject, TelemetrySession session);
    protected virtual string InitializeReliabilityRegistryPath();
    protected virtual string GetUseCollectorRegKeyPath();
    public virtual bool GetCachedUseCollectorFromRegistry();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetrySessionInternalVSCode : TelemetrySessionInternalBase {
    internal TelemetrySessionInternalVSCode(TelemetrySessionSettings settings, bool isCloned, TelemetrySessionInitializer initializerObject, TelemetrySession session);
    protected virtual string InitializeReliabilityRegistryPath();
    protected virtual string GetUseCollectorRegKeyPath();
    public virtual bool GetCachedUseCollectorFromRegistry();
}
[DataContractAttribute]
internal class Microsoft.VisualStudio.Telemetry.TelemetrySessionSettings : object {
    private static string DefaultHostName;
    private static UInt32 DefaultAppId;
    [CompilerGeneratedAttribute]
private bool <IsOptedIn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitialSession>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppInsightsInstrumentationKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AsimovInstrumentationKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectorApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <AppId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ProcessStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VSExeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SkuName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BucketFilter> <BucketFiltersToEnableWatsonForFaults>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BucketFilter> <BucketFiltersToAddDumpsToFaults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanOverrideHostName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanOverrideAppId>k__BackingField;
    [DataMemberAttribute]
public bool IsOptedIn { get; public set; }
    [DataMemberAttribute]
public bool IsInitialSession { get; public set; }
    [DataMemberAttribute]
public string HostName { get; public set; }
    [DataMemberAttribute]
public string AppInsightsInstrumentationKey { get; public set; }
    [DataMemberAttribute]
public string AsimovInstrumentationKey { get; public set; }
    [DataMemberAttribute]
public string CollectorApiKey { get; public set; }
    [DataMemberAttribute]
public UInt32 AppId { get; public set; }
    [DataMemberAttribute]
public Nullable`1<Guid> UserId { get; public set; }
    [DataMemberAttribute]
public string Id { get; public set; }
    [DataMemberAttribute]
public long ProcessStartTime { get; public set; }
    [DataMemberAttribute]
public string VSExeVersion { get; public set; }
    [DataMemberAttribute]
public string SkuName { get; public set; }
    [DataMemberAttribute]
public List`1<BucketFilter> BucketFiltersToEnableWatsonForFaults { get; public set; }
    [DataMemberAttribute]
public List`1<BucketFilter> BucketFiltersToAddDumpsToFaults { get; public set; }
    [IgnoreDataMemberAttribute]
public bool CanOverrideHostName { get; private set; }
    [IgnoreDataMemberAttribute]
public bool CanOverrideAppId { get; private set; }
    public TelemetrySessionSettings(string id, IInternalSettings internalSettings, string appInsightsIKey, string asimovIKey, string collectorApiKey, IProcessCreationTime processCreation);
    [CompilerGeneratedAttribute]
public bool get_IsOptedIn();
    [CompilerGeneratedAttribute]
public void set_IsOptedIn(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInitialSession();
    [CompilerGeneratedAttribute]
public void set_IsInitialSession(bool value);
    [CompilerGeneratedAttribute]
public string get_HostName();
    [CompilerGeneratedAttribute]
public void set_HostName(string value);
    [CompilerGeneratedAttribute]
public string get_AppInsightsInstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_AppInsightsInstrumentationKey(string value);
    [CompilerGeneratedAttribute]
public string get_AsimovInstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_AsimovInstrumentationKey(string value);
    [CompilerGeneratedAttribute]
public string get_CollectorApiKey();
    [CompilerGeneratedAttribute]
public void set_CollectorApiKey(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_AppId();
    [CompilerGeneratedAttribute]
public void set_AppId(UInt32 value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public long get_ProcessStartTime();
    [CompilerGeneratedAttribute]
public void set_ProcessStartTime(long value);
    [CompilerGeneratedAttribute]
public string get_VSExeVersion();
    [CompilerGeneratedAttribute]
public void set_VSExeVersion(string value);
    [CompilerGeneratedAttribute]
public string get_SkuName();
    [CompilerGeneratedAttribute]
public void set_SkuName(string value);
    [CompilerGeneratedAttribute]
public List`1<BucketFilter> get_BucketFiltersToEnableWatsonForFaults();
    [CompilerGeneratedAttribute]
public void set_BucketFiltersToEnableWatsonForFaults(List`1<BucketFilter> value);
    [CompilerGeneratedAttribute]
public List`1<BucketFilter> get_BucketFiltersToAddDumpsToFaults();
    [CompilerGeneratedAttribute]
public void set_BucketFiltersToAddDumpsToFaults(List`1<BucketFilter> value);
    [CompilerGeneratedAttribute]
public bool get_CanOverrideHostName();
    [CompilerGeneratedAttribute]
private void set_CanOverrideHostName(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanOverrideAppId();
    [CompilerGeneratedAttribute]
private void set_CanOverrideAppId(bool value);
    internal static bool IsSessionIdValid(string sessionID);
    internal static TelemetrySessionSettings Parse(string serializedSession);
    public virtual bool Equals(object other);
    public virtual string ToString();
    internal static string GetFaultEventBucketFilterJson(List`1<BucketFilter> bucketFilters);
    public virtual int GetHashCode();
    private static string StringToJsonValue(string value);
    private static TelemetrySessionSettings Deserialize(string settings);
    private static bool IsSerializedSessionValid(string serializedSession);
}
public class Microsoft.VisualStudio.Telemetry.TelemetrySettingProperty : TelemetryDataModelProperty {
    public TelemetrySettingProperty(object val);
}
public enum Microsoft.VisualStudio.Telemetry.TelemetrySeverity : Enum {
    public int value__;
    public static TelemetrySeverity High;
    public static TelemetrySeverity Normal;
    public static TelemetrySeverity Low;
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryTaskTimer : TelemetryDisposableObject {
    public static TimeSpan InfiniteTimeSpan;
    private TimeSpan delay;
    private CancellationTokenSource tokenSource;
    private Task delayTask;
    private Task currentTask;
    public TimeSpan Delay { get; public set; }
    public bool IsStarted { get; }
    public TelemetryTaskTimer(TimeSpan taskDelay);
    private static TelemetryTaskTimer();
    public TimeSpan get_Delay();
    public void set_Delay(TimeSpan value);
    public bool get_IsStarted();
    public void Start(Action elapsed, bool infinite);
    public void Start(Func`1<Task> elapsed, bool infinite);
    public void Cancel();
    public void WaitThenCancel();
    protected virtual void DisposeManagedResources();
    private static void CancelAndDispose(CancellationTokenSource tokenSource);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryTestChannelEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private TelemetryEvent <Event>k__BackingField;
    public TelemetryEvent Event { get; public set; }
    [CompilerGeneratedAttribute]
public TelemetryEvent get_Event();
    [CompilerGeneratedAttribute]
public void set_Event(TelemetryEvent value);
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryTextWriter : object {
    private TextWriter writer;
    public TelemetryTextWriter(string filePath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryTextWriter/<WriteLineAsync>d__2")]
public sealed virtual Task WriteLineAsync(string text);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryVsOptinStatusReader : object {
    private static string GlobalPolicyOptedInRegistryPath;
    private static string LocalOptedInRegistryPath;
    private static string LocalOptedInRootRegistryPath;
    private static string OptedInRegistryKeyName;
    private static int UserIsOptedInValue;
    private IRegistryTools2 registryTools;
    public TelemetryVsOptinStatusReader(IRegistryTools2 registryTools);
    public sealed virtual bool ReadIsOptedInStatus(string productVersion);
    public sealed virtual bool ReadIsOptedInStatus(TelemetrySession session);
    private bool KeyMatchesSqmFormat(string key);
    private bool TryGlobalPolicyOptedInStatus(Boolean& optedIn);
}
internal enum Microsoft.VisualStudio.Telemetry.ThrottlingAction : Enum {
    public int value__;
    public static ThrottlingAction Default;
    public static ThrottlingAction Throttle;
    public static ThrottlingAction DoNotThrottle;
}
internal class Microsoft.VisualStudio.Telemetry.Tools.ProductDetectionTools : object {
    internal static ProductTarget GetProduct(TelemetrySessionSettings settings);
    private static ProductTarget GetProduct(string asimovIKey, string collectorApiKey);
}
internal enum Microsoft.VisualStudio.Telemetry.Tools.ProductTarget : Enum {
    public int value__;
    public static ProductTarget VSCode;
    public static ProductTarget Other;
}
internal static class Microsoft.VisualStudio.Telemetry.TypeTools : object {
    public static bool IsNumericType(Type t);
    public static bool TryConvertToUInt(object o, UInt32& result);
    public static bool TryConvertToInt(object o, Int32& result);
    public static string ConvertToString(object o);
    private static bool GuardConvert(Func`2<object, T> convertFunc, object from, T& res);
}
internal abstract class Microsoft.VisualStudio.Telemetry.UserInformationProviderBase : object {
    private static string FullUserDomainEnvironmentKey;
    protected static string MicrosoftTenantId;
    private Lazy`1<bool> canCollectPrivateInformation;
    private Lazy`1<bool> isUserMicrosoftInternal;
    private Lazy`1<bool> isMicrosoftAADJoined;
    private Lazy`1<Guid> userId;
    private IEnvironmentTools environmentTools;
    private IInternalSettings internalSettings;
    private ILegacyApi legacyApi;
    private static HashSet`1<string> CanCollectPrivateInformationDomainList;
    private static HashSet`1<string> MicrosoftInternalDomainList;
    public bool CanCollectPrivateInformation { get; }
    public bool IsUserMicrosoftInternal { get; }
    public bool IsMicrosoftAADJoined { get; }
    public Guid UserId { get; }
    public UserType UserType { get; }
    public UserInformationProviderBase(IInternalSettings internalSettings, IEnvironmentTools envTools, ILegacyApi legacyApi, Nullable`1<Guid> userId);
    private static UserInformationProviderBase();
    public sealed virtual bool get_CanCollectPrivateInformation();
    public sealed virtual bool get_IsUserMicrosoftInternal();
    public sealed virtual bool get_IsMicrosoftAADJoined();
    public sealed virtual Guid get_UserId();
    public abstract virtual UserType get_UserType();
    protected abstract virtual bool CalculateIsMicrosoftAADJoined();
    private bool CalculateIsInternal();
    private bool CalculateCanCollectPrivateInformation();
    private bool ValidateDomainInformation(HashSet`1<string> domainList);
}
public class Microsoft.VisualStudio.Telemetry.UserTaskEvent : OperationEvent {
    public UserTaskEvent(string eventName, TelemetryResult result, string resultSummary);
    internal UserTaskEvent(string eventName, OperationStageType stageType, TelemetryResult result, string resultSummary);
}
internal enum Microsoft.VisualStudio.Telemetry.UserType : Enum {
    public int value__;
    public static UserType External;
    public static UserType Internal;
    public static UserType DevDiv;
    public static UserType Lab;
}
internal class Microsoft.VisualStudio.Telemetry.WatsonSessionChannelBuilder : object {
    private int faultEventSamplePercent;
    private int faultEventMaximumWatsonReportsPerSession;
    private int faultEventMinimumSecondsBetweenWatsonReports;
    private ChannelProperties properties;
    [CompilerGeneratedAttribute]
private WatsonSessionChannel <WatsonSessionChannel>k__BackingField;
    public WatsonSessionChannel WatsonSessionChannel { get; private set; }
    public WatsonSessionChannelBuilder(int faultEventSamplePercent, int faultEventMaximumWatsonReportsPerSession, int faultEventMinimumSecondsBetweenWatsonReports, ChannelProperties properties);
    [CompilerGeneratedAttribute]
public WatsonSessionChannel get_WatsonSessionChannel();
    [CompilerGeneratedAttribute]
private void set_WatsonSessionChannel(WatsonSessionChannel value);
    public void Build(TelemetrySession hostSession);
}
public enum Microsoft.VisualStudio.Telemetry.WER_DUMP_TYPE : Enum {
    public int value__;
    public static WER_DUMP_TYPE WerDumpTypeMicroDump;
    public static WER_DUMP_TYPE WerDumpTypeMiniDump;
    public static WER_DUMP_TYPE WerDumpTypeHeapDump;
    public static WER_DUMP_TYPE WerDumpTypeTriageDump;
    public static WER_DUMP_TYPE WerDumpTypeMax;
}
[DataContractAttribute]
public class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.BucketFilter : object {
    private static String[] bucketParameterNames;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WatsonEventType>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BucketParameterFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AdditionalProperties>k__BackingField;
    [DataMemberAttribute]
public Guid Id { get; public set; }
    [DataMemberAttribute]
public string WatsonEventType { get; public set; }
    [DataMemberAttribute]
public String[] BucketParameterFilters { get; public set; }
    [DataMemberAttribute]
public Dictionary`2<string, string> AdditionalProperties { get; public set; }
    public BucketFilter(Guid id, string watsonEventType);
    private static BucketFilter();
    public static int IndexOfBucketParameter(string bucketParameterName);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public string get_WatsonEventType();
    [CompilerGeneratedAttribute]
public void set_WatsonEventType(string value);
    [CompilerGeneratedAttribute]
public String[] get_BucketParameterFilters();
    [CompilerGeneratedAttribute]
public void set_BucketParameterFilters(String[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(Dictionary`2<string, string> value);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.DefaultWerReportImplementation : object {
    public sealed virtual SafeWerReportHandle WerReportCreateEx(string pwzEventType, WER_REPORT_TYPE repType, IntPtr pReportInformation);
    public sealed virtual int WerReportSetParameter(SafeWerReportHandle hReportHandle, int dwparamID, string pwzName, string pwzValue);
    public sealed virtual int WerReportAddDump(SafeWerReportHandle hReportHandle, IntPtr hProcess, IntPtr hThread, WER_DUMP_TYPE dumpType, IntPtr pExceptionParam, IntPtr pDumpCustomOptions, int dwFlags);
    public sealed virtual int WerReportSubmitEx(SafeWerReportHandle hReportHandle, WER_CONSENT consent, int dwFlags);
    public sealed virtual int WerReportAddFile(SafeWerReportHandle hReportHandle, string pwxPath, WER_FILE_TYPE repFileType, int dwFileFlags);
}
internal interface Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.IWerReport {
    public abstract virtual SafeWerReportHandle WerReportCreateEx(string pwzEventType, WER_REPORT_TYPE repType, IntPtr pReportInformation);
    public abstract virtual int WerReportSetParameter(SafeWerReportHandle hReportHandle, int dwparamID, string pwzName, string pwzValue);
    public abstract virtual int WerReportAddDump(SafeWerReportHandle hReportHandle, IntPtr hProcess, IntPtr hThread, WER_DUMP_TYPE dumpType, IntPtr pExceptionParam, IntPtr pDumpCustomOptions, int dwFlags);
    public abstract virtual int WerReportAddFile(SafeWerReportHandle hReportHandle, string pwxPath, WER_FILE_TYPE repFileType, int dwFileFlags);
    public abstract virtual int WerReportSubmitEx(SafeWerReportHandle hReportHandle, WER_CONSENT consent, int dwFlags);
}
internal static class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.NativeMethods : object {
    internal static UInt32 WER_E_LENGTH_EXCEEDED;
    public static int WER_BUCKETPARAM_MAXLENGTH;
    public static int WerReportCreate(string pwzEventType, WER_REPORT_TYPE repType, IntPtr pReportInformation, SafeWerReportHandle& phReportHandle);
    public static int WerReportSetParameter(SafeWerReportHandle hReportHandle, int dwparamID, string pwzName, string pwzValue);
    public static int WerReportSetUIOption(SafeWerReportHandle hReportHandle, WER_REPORT_UI repUITypeID, string pwzValue);
    public static int WerReportAddDump(SafeWerReportHandle hReportHandle, IntPtr hProcess, IntPtr hThread, WER_DUMP_TYPE dumpType, IntPtr pExceptionParam, IntPtr pDumpCustomOptions, int dwFlags);
    public static int WerReportSubmit(SafeWerReportHandle hReportHandle, WER_CONSENT consent, int dwFlags, WER_SUBMIT_RESULT& pSubmitResult);
    public static IntPtr GetCurrentProcess();
    public static int WerReportAddFile(SafeWerReportHandle hReportHandle, string pwxPath, WER_FILE_TYPE repFileType, int dwFileFlags);
    public static int WaitForMultipleObjects(UInt32 handleCount, IntPtr[] waitHandles, bool waitAll, UInt32 millisecondsTimeout);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.NoPumpSyncContext : SynchronizationContext {
    private static SynchronizationContext DefaultInstance;
    public static SynchronizationContext Default { get; }
    private static NoPumpSyncContext();
    public static SynchronizationContext get_Default();
    public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
}
public class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.SafeWerReportHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeWerReportHandle(IntPtr handle);
    protected virtual bool ReleaseHandle();
    private static int WerReportCloseHandle(IntPtr phReportHandle);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport : object {
    public static int DefaultWatsonSamplePercent;
    public static int DefaultMaximumWatsonReportsPerSession;
    public static int DefaultMinimumSecondsBetweenWatsonReports;
    [CompilerGeneratedAttribute]
private FaultEvent <FaultEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetrySession <TelemetrySession>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <SBuilderErrorInfo>k__BackingField;
    internal static string UnknownBucketValue;
    internal static int NumberOfBucketParameters;
    internal static string ExceptionDataModelPrefix;
    private static String[] bucketNames;
    public static int P0AppNameIndex;
    public static int P1AppVersionIndex;
    public static int P2TelemetryNameIndex;
    public static int P3failureParam0Index;
    public static int P3ExceptionTypeDefaultIndex;
    public static int P4failureParam1Index;
    public static int P4ModuleNameDefaultIndex;
    public static int P5failureParam2Index;
    public static int P5MethodNameDefaultIndex;
    public static int P6failureParam3Index;
    public static int P7failureParam4Index;
    public static int P8nonFailureParam0Index;
    public static int P9nonFailureParam1Index;
    private FaultEvent FaultEvent { get; }
    private TelemetrySession TelemetrySession { get; }
    internal StringBuilder SBuilderErrorInfo { get; }
    public WatsonReport(FaultEvent faultEvent, TelemetrySession telemetrySession);
    private static WatsonReport();
    [CompilerGeneratedAttribute]
private FaultEvent get_FaultEvent();
    [CompilerGeneratedAttribute]
private TelemetrySession get_TelemetrySession();
    [CompilerGeneratedAttribute]
internal StringBuilder get_SBuilderErrorInfo();
    public void PostWatsonReport(int maxReportsPerSession, int minSecondsBetweenReports);
    private void LogTelemetryAboutExtraDataAddedToFaultEvent();
    private void LogExceptionToTelemetry(Exception ex);
    private bool GetReportInfo(bool queue, DateTime startTime, DateTime endTime);
    private WER_SUBMIT_RESULT SendWatsonReport(bool fullCab, bool sendParams, DateTime& startTime, DateTime& endTime);
    private void AddFilesToReport(WerReportBuilder reportBuilder);
    private WER_SUBMIT_RESULT SubmitReport(WerReportBuilder reportBuilder, int watsonFlags, DateTime& startTime, DateTime& endTime);
    private void SetReportParameters(WerReportBuilder reportBuilder);
    private void AddDumpsToReport(WerReportBuilder reportBuilder);
    private void AddErrorInfoFile(WerReportBuilder reportBuilder);
    private void SetDumpTypeFaultEventProperties();
    private void AddBucketParametersToEventProperties();
    internal BucketFilter GetMatchingBucketFilter(List`1<BucketFilter> bucketFilters, string bucketFilterTelemetryPropertyNamePrefix);
    private void SendSupplementalInfoEvent(Guid correlationId);
    private static bool ShouldSendSupplementalInfoTelemetryEvent();
    private static int GetFaultEventDumpModeRemoteSettingValue();
    private void TrySetBucketParameter(int bucketNum, string value);
    private bool GetBlameFromFrame(StackFrame frame, String& methodName, String& fileName, String& offset);
    private void SetInitialBucketParameters();
    internal static IEnumerable`1<StackFrame> RemoveFrames(StackFrame[] frames);
    internal static string FormatException(Exception ex);
    internal static string FormatExceptionStack(Exception ex, bool shorten);
    internal static string FormatStackTrace(IEnumerable`1<StackFrame> stackFrames, int maxLength, bool shorten);
    internal static string FormatMethodName(MethodBase method, bool shortened);
    private void SetBucketParametersForModule(string filename, string methodName, string offset);
    internal void AddExceptionInfoToIncludedFile(Exception exceptionObject);
    private void AddStackToFile(string desc, string stack, int indentLevel);
    private void AddPropertiesForExceptionObject(Exception exceptionObject);
    private void AddStackToTelemetryReport(string stackTrace, string message, bool exceptionStack);
    private Exception GetInnerMostException(Exception exceptionObject, Func`2<Exception, bool> exceptionChainRestraint);
}
public enum Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WER_Bucket : Enum {
    public int value__;
    public static WER_Bucket WER_P0;
    public static WER_Bucket WER_P1;
    public static WER_Bucket WER_P2;
    public static WER_Bucket WER_P3;
    public static WER_Bucket WER_P4;
    public static WER_Bucket WER_P5;
    public static WER_Bucket WER_P6;
    public static WER_Bucket WER_P7;
    public static WER_Bucket WER_P8;
    public static WER_Bucket WER_P9;
}
internal enum Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WER_CONSENT : Enum {
    public int value__;
    public static WER_CONSENT WerConsentNotAsked;
    public static WER_CONSENT WerConsentApproved;
    public static WER_CONSENT WerConsentDenied;
    public static WER_CONSENT WerConsentAlwaysPrompt;
    public static WER_CONSENT WerConsentMax;
}
internal enum Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WER_FILE_TYPE : Enum {
    public int value__;
    public static WER_FILE_TYPE WerFileTypeHeapdump;
    public static WER_FILE_TYPE WerFileTypeMicrodump;
    public static WER_FILE_TYPE WerFileTypeMinidump;
    public static WER_FILE_TYPE WerFileTypeUserDocument;
    public static WER_FILE_TYPE WerFileTypeOther;
}
internal enum Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WER_REPORT_TYPE : Enum {
    public int value__;
    public static WER_REPORT_TYPE WerReportNonCritical;
    public static WER_REPORT_TYPE WerReportCritical;
    public static WER_REPORT_TYPE WerReportApplicationCrash;
    public static WER_REPORT_TYPE WerReportApplicationHang;
    public static WER_REPORT_TYPE WerReportKernel;
    public static WER_REPORT_TYPE WerReportInvalid;
}
internal enum Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WER_REPORT_UI : Enum {
    public int value__;
    public static WER_REPORT_UI WerUIAdditionalDataDlgHeader;
    public static WER_REPORT_UI WerUIIconFilePath;
    public static WER_REPORT_UI WerUIConsentDlgHeader;
    public static WER_REPORT_UI WerUIConsentDlgBody;
    public static WER_REPORT_UI WerUIOnlineSolutionCheckText;
    public static WER_REPORT_UI WerUIOfflineSolutionCheckText;
    public static WER_REPORT_UI WerUICloseText;
    public static WER_REPORT_UI WerUICloseDlgHeader;
    public static WER_REPORT_UI WerUICloseDlgBody;
    public static WER_REPORT_UI WerUICloseDlgButtonText;
    public static WER_REPORT_UI WerUICustomActionButtonText;
    public static WER_REPORT_UI WerUIMax;
}
internal enum Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WER_SUBMIT_RESULT : Enum {
    public int value__;
    public static WER_SUBMIT_RESULT WerReportQueued;
    public static WER_SUBMIT_RESULT WerReportUploaded;
    public static WER_SUBMIT_RESULT WerReportDebug;
    public static WER_SUBMIT_RESULT WerReportFailed;
    public static WER_SUBMIT_RESULT WerDisabled;
    public static WER_SUBMIT_RESULT WerReportCancelled;
    public static WER_SUBMIT_RESULT WerDisabledQueue;
    public static WER_SUBMIT_RESULT WerReportAsync;
    public static WER_SUBMIT_RESULT WerCustomAction;
    public static WER_SUBMIT_RESULT WerThrottled;
}
internal class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WerReportBuilder : object {
    private SafeWerReportHandle reportHandle;
    private WerReportBuilder(string watsonEventType, WER_REPORT_TYPE reportType);
    internal static WerReportBuilder Create(string watsonEventType, WER_REPORT_TYPE reportType);
    internal bool AddDump(Process proc, WER_DUMP_TYPE dumpType);
    internal bool AddFile(string filePath, int dwFileFlags);
    internal bool SetParameter(int paramId, string paramName, string paramValue);
    internal WER_SUBMIT_RESULT SubmitReport(WER_CONSENT werConsent, int dwFlags);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WerReportShim : object {
    private static IWerReport implementation;
    private static WerReportShim();
    internal static void SetImplementation(IWerReport implementation);
    public static SafeWerReportHandle WerReportCreate(string pwzEventType, WER_REPORT_TYPE repType, IntPtr pReportInformation);
    public static int WerReportSetParameter(SafeWerReportHandle hReportHandle, int dwparamID, string pwzName, string pwzValue);
    public static int WerReportAddDump(SafeWerReportHandle hReportHandle, IntPtr hProcess, IntPtr hThread, WER_DUMP_TYPE dumpType, IntPtr pExceptionParam, IntPtr pDumpCustomOptions, int dwFlags);
    public static int WerReportAddFile(SafeWerReportHandle hReportHandle, string pwxPath, WER_FILE_TYPE repFileType, int dwFileFlags);
    public static int WerReportSubmit(SafeWerReportHandle hReportHandle, WER_CONSENT consent, int dwFlags);
}
public class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WerStoreApi : object {
    private static Nullable`1<bool> doesInterfaceExist;
    private static string WerDllName;
    public static bool IsStoreInterfacePresent { get; }
    private static UInt32 GetSystemDirectory(StringBuilder lpBuffer, UInt32 uSize);
    private static IntPtr LoadLibrary(string fileName);
    private static IntPtr FreeLibrary(IntPtr hLib);
    private static IntPtr GetProcAddress(IntPtr hModule, string lpProcName);
    private static int WerStoreOpen(REPORT_STORE_TYPES storeType, IntPtr& hResportStore);
    private static void WerStoreClose(IntPtr hResportStore);
    private static UInt32 WerStoreGetNextReportKey(IntPtr hResportStore, IntPtr& reportKeyPtr);
    private static UInt32 WerStoreQueryReportMetadataV2(IntPtr hResportStore, string reportKey, ReportMetaData& report);
    public static bool get_IsStoreInterfacePresent();
    public static IWerStore GetStore(REPORT_STORE_TYPES type);
    private static Guid ToManagedGuid(GUID nativeGuid);
    private static DateTime FiletimeToDateTime(FILETIME fileTime);
}
internal static class Microsoft.VisualStudio.Telemetry.WindowsFirmwareInformationProvider : object {
    internal static Byte[] GetSystemFirmwareTable(FirmwareTableProviderSignature provider, string table);
    internal static Byte[] GetSystemFirmwareTable(FirmwareTableProviderSignature provider, int table);
    internal static String[] EnumSystemFirmwareTables(FirmwareTableProviderSignature provider);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsHostInformationProvider : object {
    private Lazy`1<string> name;
    private Lazy`1<UInt32> id;
    private Lazy`1<FileVersionInfo> hostVersionInfo;
    private Lazy`1<Nullable`1<int>> buildNumber;
    private Lazy`1<string> exeVersion;
    private static string UnknownName;
    public string ProcessName { get; }
    public UInt32 ProcessId { get; }
    public Nullable`1<int> ProcessBuildNumber { get; }
    public string ProcessExeVersion { get; }
    public bool IsDebuggerAttached { get; }
    public bool Is64BitProcess { get; }
    public string OSBitness { get; }
    public sealed virtual string get_ProcessName();
    public sealed virtual UInt32 get_ProcessId();
    public sealed virtual Nullable`1<int> get_ProcessBuildNumber();
    public sealed virtual string get_ProcessExeVersion();
    public sealed virtual bool get_IsDebuggerAttached();
    public sealed virtual bool get_Is64BitProcess();
    public sealed virtual string get_OSBitness();
    private static string InitializeName();
    private static UInt32 InitializeId();
    private static FileVersionInfo InitializeHostVersionInfo();
    private Nullable`1<int> InitializeBuildNumber();
    private string InitializeExeVersion();
    [CompilerGeneratedAttribute]
private Nullable`1<int> <.ctor>b__20_0();
    [CompilerGeneratedAttribute]
private string <.ctor>b__20_1();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsHostPropertyProvider : BaseHostRealtimePropertyProvider {
    private IHostInformationProvider hostInfoProvider;
    private IRegistryTools registryTools;
    private Lazy`1<bool> isRDPSession;
    private static string TerminalServerRegistryPath;
    private static string GlassSessionIdRegistryKey;
    public WindowsHostPropertyProvider(IHostInformationProvider theHostInfoProvider, IRegistryTools regTools);
    public virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private bool InitializeIsRDPSession();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__5_0();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsIdentityInformationProvider : IdentityInformationProvider {
    private static Func`1<IPersistentPropertyBag> defaultStorage;
    private static Lazy`1<BiosInformation> biosInformation;
    private static string DefaultStorageLocation { get; }
    public string BiosSerialNumber { get; }
    public Guid BiosUUID { get; }
    public BiosFirmwareTableParserError BiosInformationError { get; }
    internal WindowsIdentityInformationProvider(Func`1<IPersistentPropertyBag> store);
    private static WindowsIdentityInformationProvider();
    private static string get_DefaultStorageLocation();
    public virtual string get_BiosSerialNumber();
    public virtual Guid get_BiosUUID();
    public virtual BiosFirmwareTableParserError get_BiosInformationError();
    private static BiosInformation InitializeBiosInformation();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsInternalSettings : InternalSettingsBase {
    private static string FaultEventWatsonSampleRateRegKeyName;
    private static string FaultEventMaximumWatsonReportsPerSessionRegKeyName;
    private static string FaultEventMinimumSecondsBetweenWatsonReportsRegKeyName;
    private static string GlobalPolicySqmClientRegistryPath;
    private static string MsftInternalRegistryKeyName;
    private static string EventTagTelemetryRegKeyName;
    public WindowsInternalSettings(IDiagnosticTelemetry diagnosticTelemetry, IRegistryTools registryTools);
    public virtual int FaultEventWatsonSamplePercent();
    public virtual int FaultEventMaximumWatsonReportsPerSession();
    public virtual int FaultEventMinimumSecondsBetweenWatsonReports();
    public string GetUserEventTag();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsLocalePropertyProvider : object {
    private static string SystemLocaleRegistryPath;
    private static string SystemLocaleRegistryKey;
    private Lazy`1<CultureInfo> systemInfo;
    private IRegistryTools registryTools;
    public WindowsLocalePropertyProvider(IRegistryTools regTools);
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private CultureInfo InitializeSystemInformation();
    [CompilerGeneratedAttribute]
private CultureInfo <.ctor>b__4_0();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsMachinePropertyProvider : object {
    internal static string ProcessArchPropertyName;
    private static ulong MbInBytes;
    private static string AzureVMImageNameKey;
    private static string HardwareDescriptionRegistryPath;
    private static string HardwareProcessNameRegistryKey;
    private static string HardwareCPUSpeedRegistryKey;
    private static string NoneValue;
    private static string TelemetryLocalMachineRegistryPath;
    private static string UnknownValue;
    private static string MacAddressPropertyName;
    private static string MachineIdPropertyName;
    private static string MachineArchPropertyName;
    private static string IsVirtualMachinePropertyName;
    private static string VirtualMachineTypePropertyName;
    private static UInt32 VMType_Unknown;
    private static string SystemInformationRegistryPath;
    private static string SkuNameRegistryKey;
    private static string Win365RegistryPath;
    private static string Win365PartnerIdRegistryKey;
    private static string DevBoxPartnerId;
    private static string DevBoxPropertyName;
    private static string Win365PartnerIdPropertyName;
    private static string Win365SkuNamePropertyName;
    private Lazy`1<MemoryStatus> memoryInformation;
    private Lazy`1<SystemInfo> systemInformation;
    private Lazy`1<string> processorDescription;
    private Lazy`1<Nullable`1<int>> processorFrequency;
    private Lazy`1<string> azureVMImageName;
    private Lazy`1<bool> isVirtualMachine;
    private Lazy`1<string> virtualMachineType;
    private Lazy`1<UInt32> virtualMachineTypeValue;
    private Lazy`1<string> win365PartnerId;
    private Lazy`1<string> win365SkuName;
    private Lazy`1<bool> isDevBox;
    private IMachineInformationProvider machineInformationProvider;
    private IRegistryTools registryTools;
    private IMACInformationProvider macInformationProvider;
    private IPersistentPropertyBag persistentPropertyBag;
    [CompilerGeneratedAttribute]
private string <ProcessArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MachineArchitecture>k__BackingField;
    private string ProcessArchitecture { get; }
    private string MachineArchitecture { get; }
    public WindowsMachinePropertyProvider(IMachineInformationProvider machineInformationProvider, IRegistryTools regTools, IMACInformationProvider macInformationProvider, IPersistentPropertyBag persistentPropertyBag);
    private static WindowsMachinePropertyProvider();
    [CompilerGeneratedAttribute]
private string get_ProcessArchitecture();
    [CompilerGeneratedAttribute]
private string get_MachineArchitecture();
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private void PostVirtualMachineTypeTelemetry(TelemetryContext telemetryContext);
    private MemoryStatus InitializeOSMemoryInformation();
    private SystemInfo InitializeSystemInformation();
    private string InitializeProcessorDescription();
    private string InitializeAzureVMImageName();
    internal bool IsVirtualMachine();
    private string InitializeVirtualMachineType();
    internal static string GetWin365PartnerId(IRegistryTools registryTools);
    private string InitializeWin365SkuName();
    private bool InitializeIsDevBox();
    private UInt32 InitializeVirtualMachineTypeValue();
    private UInt32 GetVirtualMachineTypeValue();
    private static string GetValue(ManagementBaseObject collection, string value);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsMACInformationProvider : MACInformationProvider {
    private static string Command;
    public WindowsMACInformationProvider(IProcessTools processTools, IPersistentPropertyBag persistentStorage);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsOSPropertyProvider : object {
    private static long MbInBytes;
    private static string OnValue;
    private static string OffValue;
    private static string OSCurrentVersionRegistryPath;
    private static string BuildLabRegistryKey;
    private static string CurrentBuildRegistryKey;
    private static string ProductNameRegistryKey;
    private static string UBRRegistryKey;
    private static string ClrInstalledVersionRegistryPath;
    private static string ReleaseKey;
    private IEnvironmentTools environmentTools;
    private IRegistryTools registryTools;
    private Lazy`1<string> buildLabInfo;
    private Lazy`1<DisplayInformation> displayInfo;
    private Lazy`1<OSVersionInfo> operatingSystemVersionInfo;
    private Lazy`1<string> productNameInfo;
    private Lazy`1<RootDriveInfo> rootDriveInfo;
    private Lazy`1<Nullable`1<long>> totalVolumesSize;
    private Lazy`1<int> clrInstalledVersion;
    private Lazy`1<string> clrRunningVersion;
    public WindowsOSPropertyProvider(IEnvironmentTools envTools, IRegistryTools regTools);
    private static WindowsOSPropertyProvider();
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private string InitializeBuildLabInfo();
    private int InitializeClrInstalledVersion();
    private string InitializeClrRunningVersion();
    private DisplayInformation InitializeDisplayInfo();
    private OSVersionInfo InitializeOSVersionInfo();
    private string InitializeProductNameInfo();
    private RootDriveInfo InitializeRootDriveInfo();
    private Nullable`1<long> InitializeTotalVolumeSize();
    [CompilerGeneratedAttribute]
private string <.ctor>b__20_0();
    [CompilerGeneratedAttribute]
private DisplayInformation <.ctor>b__20_1();
    [CompilerGeneratedAttribute]
private OSVersionInfo <.ctor>b__20_2();
    [CompilerGeneratedAttribute]
private string <.ctor>b__20_3();
    [CompilerGeneratedAttribute]
private RootDriveInfo <.ctor>b__20_4();
    [CompilerGeneratedAttribute]
private Nullable`1<long> <.ctor>b__20_5();
    [CompilerGeneratedAttribute]
private int <.ctor>b__20_6();
    [CompilerGeneratedAttribute]
private string <.ctor>b__20_7();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsProcessCreationTime : object {
    public sealed virtual long GetProcessCreationTime();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsUserInformationProvider : UserInformationProviderBase {
    private static string SqmUserTypeRegistryPath;
    private static string SqmUserTypeRegistryKey;
    private IRegistryTools registryTools;
    private Lazy`1<UserType> userType;
    internal Lazy`1<string> AADTenantId;
    public UserType UserType { get; }
    public WindowsUserInformationProvider(IRegistryTools regTools, IInternalSettings internalSettings, IEnvironmentTools envTools, ILegacyApi legacyApi, Nullable`1<Guid> userId);
    public virtual UserType get_UserType();
    protected virtual bool CalculateIsMicrosoftAADJoined();
    private UserType CalculateUserType();
    private string GetAADTenantId();
    [CompilerGeneratedAttribute]
private UserType <.ctor>b__5_0();
    [CompilerGeneratedAttribute]
private string <.ctor>b__5_1();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsUserPropertyProvider : object {
    private static string AdminValue;
    private static string NormalUserValue;
    private IUserInformationProvider userInfoProvider;
    private Lazy`1<bool> userAdminInformation;
    private Lazy`1<bool> processAdminInformation;
    public WindowsUserPropertyProvider(IUserInformationProvider theUserInfoProvider);
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private bool InitializeProcessAdminInformation();
    private bool InitializeUserAdminInformation();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__5_0();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__5_1();
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[ExtensionAttribute]
internal static class System.TimeSpanEx : object {
    public static TimeSpan Parse(string value, CultureInfo info);
    public static bool TryParse(string value, CultureInfo info, TimeSpan& output);
    [ExtensionAttribute]
public static string ToString(TimeSpan timeSpan, CultureInfo info, string format);
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.4.231.31994")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
internal static class Windows.Win32.Constants : object {
    internal static UInt32 DELETE;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 GENERIC_WRITE;
}
[IsReadOnlyAttribute]
internal class Windows.Win32.Foundation.BOOL : ValueType {
    private int value;
    internal int Value { get; }
    internal BOOL(bool value);
    internal BOOL(int value);
    internal int get_Value();
    public static bool op_Implicit(BOOL value);
    public static BOOL op_Implicit(bool value);
    public static BOOL op_Explicit(int value);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.BOOLEAN : ValueType {
    internal byte Value;
    internal BOOLEAN(byte value);
    public static byte op_Implicit(BOOLEAN value);
    public static BOOLEAN op_Explicit(byte value);
    public static bool op_Equality(BOOLEAN left, BOOLEAN right);
    public static bool op_Inequality(BOOLEAN left, BOOLEAN right);
    public sealed virtual bool Equals(BOOLEAN other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.HANDLE : ValueType {
    internal IntPtr Value;
    internal bool IsNull { get; }
    internal HANDLE(IntPtr value);
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HANDLE value);
    public static HANDLE op_Explicit(IntPtr value);
    public static bool op_Equality(HANDLE left, HANDLE right);
    public static bool op_Inequality(HANDLE left, HANDLE right);
    public sealed virtual bool Equals(HANDLE other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.HINSTANCE : ValueType {
    internal IntPtr Value;
    internal bool IsNull { get; }
    internal HINSTANCE(IntPtr value);
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HINSTANCE value);
    public static HINSTANCE op_Explicit(IntPtr value);
    public static bool op_Equality(HINSTANCE left, HINSTANCE right);
    public static bool op_Inequality(HINSTANCE left, HINSTANCE right);
    public sealed virtual bool Equals(HINSTANCE other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class Windows.Win32.Foundation.PCWSTR : ValueType {
    internal Char* Value;
    internal int Length { get; }
    private string DebuggerDisplay { get; }
    internal PCWSTR(Char* value);
    public static Char* op_Explicit(PCWSTR value);
    public static PCWSTR op_Implicit(Char* value);
    public static PCWSTR op_Implicit(PWSTR value);
    public sealed virtual bool Equals(PCWSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Length();
    public virtual string ToString();
    internal ReadOnlySpan`1<char> AsSpan();
    private string get_DebuggerDisplay();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.PWSTR : ValueType {
    internal Char* Value;
    internal int Length { get; }
    internal PWSTR(Char* value);
    public static Char* op_Implicit(PWSTR value);
    public static PWSTR op_Implicit(Char* value);
    public static bool op_Equality(PWSTR left, PWSTR right);
    public static bool op_Inequality(PWSTR left, PWSTR right);
    public sealed virtual bool Equals(PWSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Length();
    public virtual string ToString();
    internal Span`1<char> AsSpan();
}
internal static class Windows.Win32.PInvoke : object {
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL FreeLibrary(HINSTANCE hLibModule);
    internal static UInt32 GetModuleFileName(SafeHandle hModule, PWSTR lpFilename, UInt32 nSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetModuleFileName(HINSTANCE hModule, PWSTR lpFilename, UInt32 nSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL CloseHandle(HANDLE hObject);
    internal static UInt32 GetFinalPathNameByHandle(SafeHandle hFile, PWSTR lpszFilePath, UInt32 cchFilePath, FILE_NAME dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetFinalPathNameByHandle(HANDLE hFile, PWSTR lpszFilePath, UInt32 cchFilePath, FILE_NAME dwFlags);
    internal static BOOL GetFileInformationByHandle(SafeHandle hFile, BY_HANDLE_FILE_INFORMATION& lpFileInformation);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetFileInformationByHandle(HANDLE hFile, BY_HANDLE_FILE_INFORMATION* lpFileInformation);
    internal static SafeFileHandle CreateFile(string lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, SafeHandle hTemplateFile);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE CreateFile(PCWSTR lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, HANDLE hTemplateFile);
    internal static BOOL GetProcessInformation(SafeHandle hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, Void* ProcessInformation, UInt32 ProcessInformationSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, Void* ProcessInformation, UInt32 ProcessInformationSize);
    internal static SafeFileHandle GetCurrentProcess_SafeHandle();
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE GetCurrentProcess();
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static PWSTR GetCommandLine();
    internal static BOOL SetFileInformationByHandle(SafeHandle hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
    internal static SafeFileHandle ReOpenFile(SafeHandle hOriginalFile, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE ReOpenFile(HANDLE hOriginalFile, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
}
internal class Windows.Win32.Security.SECURITY_ATTRIBUTES : ValueType {
    internal UInt32 nLength;
    internal Void* lpSecurityDescriptor;
    internal BOOL bInheritHandle;
}
internal class Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION : ValueType {
    internal UInt32 dwFileAttributes;
    internal FILETIME ftCreationTime;
    internal FILETIME ftLastAccessTime;
    internal FILETIME ftLastWriteTime;
    internal UInt32 dwVolumeSerialNumber;
    internal UInt32 nFileSizeHigh;
    internal UInt32 nFileSizeLow;
    internal UInt32 nNumberOfLinks;
    internal UInt32 nFileIndexHigh;
    internal UInt32 nFileIndexLow;
}
[FlagsAttribute]
internal enum Windows.Win32.Storage.FileSystem.FILE_ACCESS_FLAGS : Enum {
    public UInt32 value__;
    public static FILE_ACCESS_FLAGS FILE_READ_DATA;
    public static FILE_ACCESS_FLAGS FILE_LIST_DIRECTORY;
    public static FILE_ACCESS_FLAGS FILE_WRITE_DATA;
    public static FILE_ACCESS_FLAGS FILE_ADD_FILE;
    public static FILE_ACCESS_FLAGS FILE_APPEND_DATA;
    public static FILE_ACCESS_FLAGS FILE_ADD_SUBDIRECTORY;
    public static FILE_ACCESS_FLAGS FILE_CREATE_PIPE_INSTANCE;
    public static FILE_ACCESS_FLAGS FILE_READ_EA;
    public static FILE_ACCESS_FLAGS FILE_WRITE_EA;
    public static FILE_ACCESS_FLAGS FILE_EXECUTE;
    public static FILE_ACCESS_FLAGS FILE_TRAVERSE;
    public static FILE_ACCESS_FLAGS FILE_DELETE_CHILD;
    public static FILE_ACCESS_FLAGS FILE_READ_ATTRIBUTES;
    public static FILE_ACCESS_FLAGS FILE_WRITE_ATTRIBUTES;
    public static FILE_ACCESS_FLAGS READ_CONTROL;
    public static FILE_ACCESS_FLAGS SYNCHRONIZE;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_REQUIRED;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_READ;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_WRITE;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_EXECUTE;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_ALL;
    public static FILE_ACCESS_FLAGS SPECIFIC_RIGHTS_ALL;
    public static FILE_ACCESS_FLAGS FILE_ALL_ACCESS;
    public static FILE_ACCESS_FLAGS FILE_GENERIC_READ;
    public static FILE_ACCESS_FLAGS FILE_GENERIC_WRITE;
    public static FILE_ACCESS_FLAGS FILE_GENERIC_EXECUTE;
}
internal class Windows.Win32.Storage.FileSystem.FILE_BASIC_INFO : ValueType {
    internal long CreationTime;
    internal long LastAccessTime;
    internal long LastWriteTime;
    internal long ChangeTime;
    internal UInt32 FileAttributes;
}
internal enum Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION : Enum {
    public UInt32 value__;
    public static FILE_CREATION_DISPOSITION CREATE_NEW;
    public static FILE_CREATION_DISPOSITION CREATE_ALWAYS;
    public static FILE_CREATION_DISPOSITION OPEN_EXISTING;
    public static FILE_CREATION_DISPOSITION OPEN_ALWAYS;
    public static FILE_CREATION_DISPOSITION TRUNCATE_EXISTING;
}
internal class Windows.Win32.Storage.FileSystem.FILE_DISPOSITION_INFO : ValueType {
    internal BOOLEAN DeleteFileA;
}
[FlagsAttribute]
internal enum Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES : Enum {
    public UInt32 value__;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_READONLY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_HIDDEN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_SYSTEM;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_DIRECTORY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_ARCHIVE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_DEVICE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NORMAL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_TEMPORARY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_SPARSE_FILE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_REPARSE_POINT;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_COMPRESSED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_OFFLINE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_ENCRYPTED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_INTEGRITY_STREAM;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_VIRTUAL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NO_SCRUB_DATA;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_EA;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_PINNED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_UNPINNED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_RECALL_ON_OPEN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_WRITE_THROUGH;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OVERLAPPED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_NO_BUFFERING;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_RANDOM_ACCESS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_SEQUENTIAL_SCAN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_DELETE_ON_CLOSE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_BACKUP_SEMANTICS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_POSIX_SEMANTICS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_SESSION_AWARE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OPEN_REPARSE_POINT;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OPEN_NO_RECALL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_FIRST_PIPE_INSTANCE;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_ANONYMOUS;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_IDENTIFICATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_IMPERSONATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_DELEGATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_CONTEXT_TRACKING;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_EFFECTIVE_ONLY;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_SQOS_PRESENT;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_VALID_SQOS_FLAGS;
}
internal enum Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS : Enum {
    public int value__;
    public static FILE_INFO_BY_HANDLE_CLASS FileBasicInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStandardInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileNameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileRenameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileDispositionInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAllocationInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileEndOfFileInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStreamInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileCompressionInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAttributeTagInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdBothDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdBothDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIoPriorityHintInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileRemoteProtocolInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileFullDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileFullDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStorageInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAlignmentInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdExtdDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdExtdDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileDispositionInfoEx;
    public static FILE_INFO_BY_HANDLE_CLASS FileRenameInfoEx;
    public static FILE_INFO_BY_HANDLE_CLASS FileCaseSensitiveInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileNormalizedNameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS MaximumFileInfoByHandleClass;
}
internal enum Windows.Win32.Storage.FileSystem.FILE_NAME : Enum {
    public UInt32 value__;
    public static FILE_NAME FILE_NAME_NORMALIZED;
    public static FILE_NAME FILE_NAME_OPENED;
}
[FlagsAttribute]
internal enum Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE : Enum {
    public UInt32 value__;
    public static FILE_SHARE_MODE FILE_SHARE_NONE;
    public static FILE_SHARE_MODE FILE_SHARE_DELETE;
    public static FILE_SHARE_MODE FILE_SHARE_READ;
    public static FILE_SHARE_MODE FILE_SHARE_WRITE;
}
internal enum Windows.Win32.System.Threading.PROCESS_INFORMATION_CLASS : Enum {
    public int value__;
    public static PROCESS_INFORMATION_CLASS ProcessMemoryPriority;
    public static PROCESS_INFORMATION_CLASS ProcessMemoryExhaustionInfo;
    public static PROCESS_INFORMATION_CLASS ProcessAppMemoryInfo;
    public static PROCESS_INFORMATION_CLASS ProcessInPrivateInfo;
    public static PROCESS_INFORMATION_CLASS ProcessPowerThrottling;
    public static PROCESS_INFORMATION_CLASS ProcessReservedValue1;
    public static PROCESS_INFORMATION_CLASS ProcessTelemetryCoverageInfo;
    public static PROCESS_INFORMATION_CLASS ProcessProtectionLevelInfo;
    public static PROCESS_INFORMATION_CLASS ProcessLeapSecondInfo;
    public static PROCESS_INFORMATION_CLASS ProcessInformationClassMax;
}
