[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.ArrayExtensions : object {
    [ExtensionAttribute]
public static T& DangerousGetReference(T[] array);
    [ExtensionAttribute]
public static T& DangerousGetReferenceAt(T[] array, int i);
    [ExtensionAttribute]
public static int Count(T[] array, T value);
    [ExtensionAttribute]
public static SpanEnumerable`1<T> Enumerate(T[] array);
    [ExtensionAttribute]
public static SpanTokenizer`1<T> Tokenize(T[] array, T separator);
    [ExtensionAttribute]
public static int GetDjb2HashCode(T[] array);
    [ExtensionAttribute]
public static bool IsCovariant(T[] array);
    private static void ThrowOverflowException();
    [ExtensionAttribute]
public static T& DangerousGetReference(T[0...,0...] array);
    [ExtensionAttribute]
public static T& DangerousGetReferenceAt(T[0...,0...] array, int i, int j);
    [ExtensionAttribute]
public static RefEnumerable`1<T> GetRow(T[0...,0...] array, int row);
    [ExtensionAttribute]
public static RefEnumerable`1<T> GetColumn(T[0...,0...] array, int column);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span2D`1<T> AsSpan2D(T[0...,0...] array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span2D`1<T> AsSpan2D(T[0...,0...] array, int row, int column, int height, int width);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory2D`1<T> AsMemory2D(T[0...,0...] array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory2D`1<T> AsMemory2D(T[0...,0...] array, int row, int column, int height, int width);
    [ExtensionAttribute]
public static Span`1<T> GetRowSpan(T[0...,0...] array, int row);
    [ExtensionAttribute]
public static Memory`1<T> GetRowMemory(T[0...,0...] array, int row);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[0...,0...] array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[0...,0...] array);
    [ExtensionAttribute]
public static int Count(T[0...,0...] array, T value);
    [ExtensionAttribute]
public static int GetDjb2HashCode(T[0...,0...] array);
    [ExtensionAttribute]
public static bool IsCovariant(T[0...,0...] array);
    private static void ThrowArrayTypeMismatchException();
    private static void ThrowArgumentOutOfRangeExceptionForRow();
    private static void ThrowArgumentOutOfRangeExceptionForColumn();
    [ExtensionAttribute]
public static T& DangerousGetReference(T[0...,0...,0...] array);
    [ExtensionAttribute]
public static T& DangerousGetReferenceAt(T[0...,0...,0...] array, int i, int j, int k);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[0...,0...,0...] array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[0...,0...,0...] array);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[0...,0...,0...] array, int depth);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[0...,0...,0...] array, int depth);
    [ExtensionAttribute]
public static Span2D`1<T> AsSpan2D(T[0...,0...,0...] array, int depth);
    [ExtensionAttribute]
public static Memory2D`1<T> AsMemory2D(T[0...,0...,0...] array, int depth);
    [ExtensionAttribute]
public static int Count(T[0...,0...,0...] array, T value);
    [ExtensionAttribute]
public static int GetDjb2HashCode(T[0...,0...,0...] array);
    [ExtensionAttribute]
public static bool IsCovariant(T[0...,0...,0...] array);
    private static void ThrowArgumentOutOfRangeExceptionForDepth();
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.ArrayPoolBufferWriterExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Stream AsStream(ArrayPoolBufferWriter`1<byte> writer);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.ArrayPoolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Resize(ArrayPool`1<T> pool, T[]& array, int newSize, bool clearArray);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.BoolExtensions : object {
    [ExtensionAttribute]
public static byte ToByte(bool flag);
    [ExtensionAttribute]
public static int ToBitwiseMask32(bool flag);
    [ExtensionAttribute]
public static long ToBitwiseMask64(bool flag);
}
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class Microsoft.Toolkit.HighPerformance.Box`1 : object {
    [NullableContextAttribute("1")]
public static Box`1<T> GetFrom(object obj);
    [NullableContextAttribute("1")]
public static Box`1<T> DangerousGetFrom(object obj);
    [NullableContextAttribute("1")]
public static bool TryGetFrom(object obj, Box`1& box);
    public static T op_Implicit(Box`1<T> box);
    public static Box`1<T> op_Implicit(T value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static void ThrowInvalidCastExceptionForGetFrom();
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.BoxExtensions : object {
    [ExtensionAttribute]
public static T& GetReference(Box`1<T> box);
}
public enum Microsoft.Toolkit.HighPerformance.Buffers.AllocationMode : Enum {
    public int value__;
    public static AllocationMode Default;
    public static AllocationMode Clear;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("Microsoft.Toolkit.HighPerformance.Buffers.Views.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class Microsoft.Toolkit.HighPerformance.Buffers.ArrayPoolBufferWriter`1 : object {
    private static int DefaultInitialBufferSize;
    private ArrayPool`1<T> pool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private T[] array;
    private int index;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Memory`1<T> System.Buffers.IMemoryOwner<T>.Memory { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyMemory`1<T> WrittenMemory { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayPoolBufferWriter`1(ArrayPool`1<T> pool);
    public ArrayPoolBufferWriter`1(int initialCapacity);
    public ArrayPoolBufferWriter`1(ArrayPool`1<T> pool, int initialCapacity);
    protected virtual override void Finalize();
    private sealed virtual override Memory`1<T> System.Buffers.IMemoryOwner<T>.get_Memory();
    public sealed virtual ReadOnlyMemory`1<T> get_WrittenMemory();
    public sealed virtual ReadOnlySpan`1<T> get_WrittenSpan();
    public sealed virtual int get_WrittenCount();
    public sealed virtual int get_Capacity();
    public sealed virtual int get_FreeCapacity();
    public sealed virtual void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckBufferAndEnsureCapacity(int sizeHint);
    private void ResizeBuffer(int sizeHint);
    public sealed virtual void Dispose();
    public virtual string ToString();
    private static void ThrowArgumentOutOfRangeExceptionForNegativeCount();
    private static void ThrowArgumentOutOfRangeExceptionForNegativeSizeHint();
    private static void ThrowArgumentExceptionForAdvancedTooFar();
    private static void ThrowObjectDisposedException();
}
[NullableContextAttribute("2")]
public interface Microsoft.Toolkit.HighPerformance.Buffers.IBuffer`1 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyMemory`1<T> WrittenMemory { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public abstract virtual ReadOnlyMemory`1<T> get_WrittenMemory();
    public abstract virtual ReadOnlySpan`1<T> get_WrittenSpan();
    public abstract virtual int get_WrittenCount();
    public abstract virtual int get_Capacity();
    public abstract virtual int get_FreeCapacity();
    public abstract virtual void Clear();
}
internal class Microsoft.Toolkit.HighPerformance.Buffers.Internals.ArrayMemoryManager`2 : MemoryManager`1<TTo> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TFrom[] array;
    private int offset;
    private int length;
    public ArrayMemoryManager`2(TFrom[] array, int offset, int length);
    public virtual Span`1<TTo> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
    protected virtual void Dispose(bool disposing);
    public sealed virtual Memory`1<T> GetMemory(int offset, int length);
    private static void ThrowArgumentOutOfRangeExceptionForInvalidIndex();
}
internal interface Microsoft.Toolkit.HighPerformance.Buffers.Internals.Interfaces.IMemoryManager {
    public abstract virtual Memory`1<T> GetMemory(int offset, int length);
}
internal class Microsoft.Toolkit.HighPerformance.Buffers.Internals.ProxyMemoryManager`2 : MemoryManager`1<TTo> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MemoryManager`1<TFrom> memoryManager;
    private int offset;
    private int length;
    public ProxyMemoryManager`2(MemoryManager`1<TFrom> memoryManager, int offset, int length);
    public virtual Span`1<TTo> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
    protected virtual void Dispose(bool disposing);
    public sealed virtual Memory`1<T> GetMemory(int offset, int length);
    private static void ThrowArgumentExceptionForInvalidIndex();
    private static void ThrowArgumentExceptionForInvalidAlignment();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.Toolkit.HighPerformance.Buffers.Internals.RawObjectMemoryManager`1 : MemoryManager`1<T> {
    private object instance;
    private IntPtr offset;
    private int length;
    public RawObjectMemoryManager`1(object instance, IntPtr offset, int length);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
    protected virtual void Dispose(bool disposing);
    private static void ThrowArgumentOutOfRangeExceptionForInvalidElementIndex();
}
internal class Microsoft.Toolkit.HighPerformance.Buffers.Internals.StringMemoryManager`1 : MemoryManager`1<TTo> {
    [NullableAttribute("1")]
private string text;
    private int offset;
    private int length;
    [NullableContextAttribute("1")]
public StringMemoryManager`1(string text, int offset, int length);
    public virtual Span`1<TTo> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
    protected virtual void Dispose(bool disposing);
    public sealed virtual Memory`1<T> GetMemory(int offset, int length);
    private static void ThrowArgumentOutOfRangeExceptionForInvalidIndex();
}
[DebuggerTypeProxyAttribute("Microsoft.Toolkit.HighPerformance.Buffers.Views.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class Microsoft.Toolkit.HighPerformance.Buffers.MemoryBufferWriter`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Memory`1<T> memory;
    private int index;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyMemory`1<T> WrittenMemory { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public MemoryBufferWriter`1(Memory`1<T> memory);
    public sealed virtual ReadOnlyMemory`1<T> get_WrittenMemory();
    public sealed virtual ReadOnlySpan`1<T> get_WrittenSpan();
    public sealed virtual int get_WrittenCount();
    public sealed virtual int get_Capacity();
    public sealed virtual int get_FreeCapacity();
    public sealed virtual void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void ValidateSizeHint(int sizeHint);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private static void ThrowArgumentOutOfRangeExceptionForNegativeCount();
    private static void ThrowArgumentOutOfRangeExceptionForNegativeSizeHint();
    private static void ThrowArgumentExceptionForAdvancedTooFar();
    private static void ThrowArgumentExceptionForCapacityExceeded();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("Microsoft.Toolkit.HighPerformance.Buffers.Views.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class Microsoft.Toolkit.HighPerformance.Buffers.MemoryOwner`1 : object {
    private int start;
    private int length;
    private ArrayPool`1<T> pool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private T[] array;
    public static MemoryOwner`1<T> Empty { get; }
    public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Memory`1<T> Memory { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span`1<T> Span { get; }
    private MemoryOwner`1(int length, ArrayPool`1<T> pool, AllocationMode mode);
    private MemoryOwner`1(int start, int length, ArrayPool`1<T> pool, T[] array);
    protected virtual override void Finalize();
    public static MemoryOwner`1<T> get_Empty();
    public static MemoryOwner`1<T> Allocate(int size);
    public static MemoryOwner`1<T> Allocate(int size, ArrayPool`1<T> pool);
    public static MemoryOwner`1<T> Allocate(int size, AllocationMode mode);
    public static MemoryOwner`1<T> Allocate(int size, ArrayPool`1<T> pool, AllocationMode mode);
    public int get_Length();
    public sealed virtual Memory`1<T> get_Memory();
    public Span`1<T> get_Span();
    public T& DangerousGetReference();
    public ArraySegment`1<T> DangerousGetArray();
    public MemoryOwner`1<T> Slice(int start, int length);
    public sealed virtual void Dispose();
    public virtual string ToString();
    private static void ThrowObjectDisposedException();
    private static void ThrowInvalidOffsetException();
    private static void ThrowInvalidLengthException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("Microsoft.Toolkit.HighPerformance.Buffers.Views.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class Microsoft.Toolkit.HighPerformance.Buffers.SpanOwner`1 : ValueType {
    private int length;
    private ArrayPool`1<T> pool;
    private T[] array;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SpanOwner`1<T> Empty { get; }
    public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span`1<T> Span { get; }
    private SpanOwner`1(int length, ArrayPool`1<T> pool, AllocationMode mode);
    public static SpanOwner`1<T> get_Empty();
    public static SpanOwner`1<T> Allocate(int size);
    public static SpanOwner`1<T> Allocate(int size, ArrayPool`1<T> pool);
    public static SpanOwner`1<T> Allocate(int size, AllocationMode mode);
    public static SpanOwner`1<T> Allocate(int size, ArrayPool`1<T> pool, AllocationMode mode);
    public int get_Length();
    public Span`1<T> get_Span();
    public T& DangerousGetReference();
    public ArraySegment`1<T> DangerousGetArray();
    public void Dispose();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Toolkit.HighPerformance.Buffers.StringPool : object {
    private static int DefaultSize;
    private static int MinimumSize;
    private FixedSizePriorityMap[] maps;
    private int numberOfMaps;
    [CompilerGeneratedAttribute]
private static StringPool <Shared>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public static StringPool Shared { get; }
    public int Size { get; }
    public StringPool(int minimumSize);
    private static StringPool();
    [CompilerGeneratedAttribute]
public static StringPool get_Shared();
    [CompilerGeneratedAttribute]
public int get_Size();
    public void Add(string value);
    public string GetOrAdd(string value);
    [NullableContextAttribute("0")]
public string GetOrAdd(ReadOnlySpan`1<char> span);
    public string GetOrAdd(ReadOnlySpan`1<byte> span, Encoding encoding);
    [NullableContextAttribute("0")]
public bool TryGet(ReadOnlySpan`1<char> span, String& value);
    public void Reset();
    [NullableContextAttribute("0")]
private static int GetHashCode(ReadOnlySpan`1<char> span);
    private static void ThrowArgumentOutOfRangeException();
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__FindFactors|5_0(int size, int factor, Int32& x, Int32& y);
}
internal class Microsoft.Toolkit.HighPerformance.Buffers.Views.MemoryDebugView`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private T[] <Items>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("2")]
public T[] Items { get; }
    public MemoryDebugView`1(ArrayPoolBufferWriter`1<T> arrayPoolBufferWriter);
    public MemoryDebugView`1(MemoryBufferWriter`1<T> memoryBufferWriter);
    public MemoryDebugView`1(MemoryOwner`1<T> memoryOwner);
    public MemoryDebugView`1(SpanOwner`1<T> spanOwner);
    [CompilerGeneratedAttribute]
public T[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlyRefEnumerable`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlySpan`1<T> span;
    private int step;
    public int Length { get; }
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    private ReadOnlyRefEnumerable`1(ReadOnlySpan`1<T> span, int step);
    internal ReadOnlyRefEnumerable`1(T& reference, int length, int step);
    public static ReadOnlyRefEnumerable`1<T> DangerousCreate(T& value, int length, int step);
    public int get_Length();
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(Index index);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public void CopyTo(RefEnumerable`1<T> destination);
    public bool TryCopyTo(RefEnumerable`1<T> destination);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public T[] ToArray();
    public static ReadOnlyRefEnumerable`1<T> op_Implicit(RefEnumerable`1<T> enumerable);
    private static void ThrowArgumentOutOfRangeExceptionForLength();
    private static void ThrowArgumentOutOfRangeExceptionForStep();
    private static void ThrowArgumentExceptionForDestinationTooShort();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanEnumerable`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlySpan`1<T> span;
    private int index;
    public Item<T> Current { get; }
    public ReadOnlySpanEnumerable`1(ReadOnlySpan`1<T> span);
    [IsReadOnlyAttribute]
public ReadOnlySpanEnumerable`1<T> GetEnumerator();
    public bool MoveNext();
    [IsReadOnlyAttribute]
public Item<T> get_Current();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanTokenizer`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlySpan`1<T> span;
    private T separator;
    private int start;
    private int end;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<T> Current { get; }
    public ReadOnlySpanTokenizer`1(ReadOnlySpan`1<T> span, T separator);
    [IsReadOnlyAttribute]
public ReadOnlySpanTokenizer`1<T> GetEnumerator();
    public bool MoveNext();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<T> get_Current();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Span`1<T> Span;
    internal int Step;
    public int Length { get; }
    public T& Item { get; }
    public T& Item { get; }
    internal RefEnumerable`1(T& reference, int length, int step);
    public static RefEnumerable`1<T> DangerousCreate(T& value, int length, int step);
    public int get_Length();
    public T& get_Item(int index);
    public T& get_Item(Index index);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public void Clear();
    public void CopyTo(RefEnumerable`1<T> destination);
    public bool TryCopyTo(RefEnumerable`1<T> destination);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    internal void CopyFrom(ReadOnlySpan`1<T> source);
    public bool TryCopyFrom(ReadOnlySpan`1<T> source);
    public void Fill(T value);
    public T[] ToArray();
    private static void ThrowArgumentOutOfRangeExceptionForLength();
    private static void ThrowArgumentOutOfRangeExceptionForStep();
    private static void ThrowArgumentExceptionForDestinationTooShort();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Toolkit.HighPerformance.Enumerables.SpanEnumerable`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Span`1<T> span;
    private int index;
    public Item<T> Current { get; }
    public SpanEnumerable`1(Span`1<T> span);
    [IsReadOnlyAttribute]
public SpanEnumerable`1<T> GetEnumerator();
    public bool MoveNext();
    [IsReadOnlyAttribute]
public Item<T> get_Current();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Toolkit.HighPerformance.Enumerables.SpanTokenizer`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Span`1<T> span;
    private T separator;
    private int start;
    private int end;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span`1<T> Current { get; }
    public SpanTokenizer`1(Span`1<T> span, T separator);
    [IsReadOnlyAttribute]
public SpanTokenizer`1<T> GetEnumerator();
    public bool MoveNext();
    [IsReadOnlyAttribute]
public Span`1<T> get_Current();
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.HashCodeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Add(HashCode& hashCode, ReadOnlySpan`1<T> span);
}
public static class Microsoft.Toolkit.HighPerformance.Helpers.BitHelper : object {
    public static bool HasFlag(UInt32 value, int n);
    public static bool HasLookupFlag(UInt32 table, int x, int min);
    public static bool HasZeroByte(UInt32 value);
    public static bool HasZeroByte(ulong value);
    public static bool HasByteEqualTo(UInt32 value, byte target);
    public static bool HasByteEqualTo(ulong value, byte target);
    public static void SetFlag(UInt32& value, int n, bool flag);
    public static UInt32 SetFlag(UInt32 value, int n, bool flag);
    public static UInt32 ExtractRange(UInt32 value, byte start, byte length);
    public static void SetRange(UInt32& value, byte start, byte length, UInt32 flags);
    public static UInt32 SetRange(UInt32 value, byte start, byte length, UInt32 flags);
    public static bool HasFlag(ulong value, int n);
    public static bool HasLookupFlag(ulong table, int x, int min);
    public static void SetFlag(UInt64& value, int n, bool flag);
    public static ulong SetFlag(ulong value, int n, bool flag);
    public static ulong ExtractRange(ulong value, byte start, byte length);
    public static void SetRange(UInt64& value, byte start, byte length, ulong flags);
    public static ulong SetRange(ulong value, byte start, byte length, ulong flags);
}
public class Microsoft.Toolkit.HighPerformance.Helpers.HashCode`1 : ValueType {
    public static int Combine(ReadOnlySpan`1<T> span);
    internal static int CombineValues(ReadOnlySpan`1<T> span);
}
public interface Microsoft.Toolkit.HighPerformance.Helpers.IAction {
    public abstract virtual void Invoke(int i);
}
public interface Microsoft.Toolkit.HighPerformance.Helpers.IAction2D {
    public abstract virtual void Invoke(int i, int j);
}
[NullableContextAttribute("1")]
public interface Microsoft.Toolkit.HighPerformance.Helpers.IInAction`1 {
    public abstract virtual void Invoke(T& modreq(System.Runtime.InteropServices.InAttribute) item);
}
internal static class Microsoft.Toolkit.HighPerformance.Helpers.Internals.BitOperations : object {
    public static int RoundUpPowerOfTwo(int x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Toolkit.HighPerformance.Helpers.Internals.RefEnumerableHelper : object {
    public static void Clear(T& r0, IntPtr length, IntPtr step);
    public static void CopyTo(T& sourceRef, T& destinationRef, IntPtr length, IntPtr sourceStep);
    public static void CopyTo(T& sourceRef, T& destinationRef, IntPtr length, IntPtr sourceStep, IntPtr destinationStep);
    public static void CopyFrom(T& sourceRef, T& destinationRef, IntPtr length, IntPtr sourceStep);
    public static void Fill(T& r0, IntPtr length, IntPtr step, T value);
}
internal static class Microsoft.Toolkit.HighPerformance.Helpers.Internals.RuntimeHelpers : object {
    public static int ConvertLength(int length);
    [NullableContextAttribute("1")]
public static IntPtr GetArrayNativeLength(T[] array);
    [NullableContextAttribute("1")]
public static IntPtr GetArrayNativeLength(Array array);
    [NullableContextAttribute("2")]
public static IntPtr GetArrayDataByteOffset();
    [NullableContextAttribute("2")]
public static IntPtr GetArray2DDataByteOffset();
    [NullableContextAttribute("2")]
public static IntPtr GetArray3DDataByteOffset();
}
internal static class Microsoft.Toolkit.HighPerformance.Helpers.Internals.SpanHelper : object {
    [NullableContextAttribute("1")]
public static IntPtr Count(T& r0, IntPtr length, T value);
    [NullableContextAttribute("1")]
private static IntPtr CountSequential(T& r0, IntPtr length, T value);
    private static IntPtr CountSimd(T& r0, IntPtr length, T value);
    private static IntPtr GetUpperBound();
    private static IntPtr CastToNativeInt(T value);
    [NullableContextAttribute("1")]
public static int GetDjb2HashCode(T& r0, IntPtr length);
    public static int GetDjb2LikeByteHash(Byte& r0, IntPtr length);
}
[NullableContextAttribute("1")]
public interface Microsoft.Toolkit.HighPerformance.Helpers.IRefAction`1 {
    public abstract virtual void Invoke(T& item);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.Helpers.ObjectMarshal : object {
    [NullableContextAttribute("1")]
public static IntPtr DangerousGetObjectDataByteOffset(object obj, T& data);
    [NullableContextAttribute("1")]
public static T& DangerousGetObjectDataReferenceAt(object obj, IntPtr offset);
    [ExtensionAttribute]
public static bool TryUnbox(object obj, T& value);
    public static T& DangerousUnbox(object obj);
}
public static class Microsoft.Toolkit.HighPerformance.Helpers.ParallelHelper : object {
    public static void For(Range range);
    public static void For(Range range, int minimumActionsPerThread);
    public static void For(Range range, TAction& action);
    public static void For(Range range, TAction& action, int minimumActionsPerThread);
    public static void For(int start, int end);
    public static void For(int start, int end, int minimumActionsPerThread);
    public static void For(int start, int end, TAction& action);
    public static void For(int start, int end, TAction& action, int minimumActionsPerThread);
    public static void For2D(Range i, Range j);
    public static void For2D(Range i, Range j, int minimumActionsPerThread);
    public static void For2D(Range i, Range j, TAction& action);
    public static void For2D(Range i, Range j, TAction& action, int minimumActionsPerThread);
    public static void For2D(Rectangle area);
    public static void For2D(Rectangle area, int minimumActionsPerThread);
    public static void For2D(Rectangle area, TAction& action);
    public static void For2D(Rectangle area, TAction& action, int minimumActionsPerThread);
    public static void For2D(int top, int bottom, int left, int right);
    public static void For2D(int top, int bottom, int left, int right, int minimumActionsPerThread);
    public static void For2D(int top, int bottom, int left, int right, TAction& action);
    public static void For2D(int top, int bottom, int left, int right, TAction& action, int minimumActionsPerThread);
    public static void ForEach(ReadOnlyMemory`1<TItem> memory);
    public static void ForEach(ReadOnlyMemory`1<TItem> memory, int minimumActionsPerThread);
    public static void ForEach(ReadOnlyMemory`1<TItem> memory, TAction& action);
    public static void ForEach(ReadOnlyMemory`1<TItem> memory, TAction& action, int minimumActionsPerThread);
    public static void ForEach(ReadOnlyMemory2D`1<TItem> memory);
    public static void ForEach(ReadOnlyMemory2D`1<TItem> memory, int minimumActionsPerThread);
    public static void ForEach(ReadOnlyMemory2D`1<TItem> memory, TAction& action);
    public static void ForEach(ReadOnlyMemory2D`1<TItem> memory, TAction& action, int minimumActionsPerThread);
    public static void ForEach(Memory`1<TItem> memory);
    public static void ForEach(Memory`1<TItem> memory, int minimumActionsPerThread);
    public static void ForEach(Memory`1<TItem> memory, TAction& action);
    public static void ForEach(Memory`1<TItem> memory, TAction& action, int minimumActionsPerThread);
    public static void ForEach(Memory2D`1<TItem> memory);
    public static void ForEach(Memory2D`1<TItem> memory, int minimumActionsPerThread);
    public static void ForEach(Memory2D`1<TItem> memory, TAction& action);
    public static void ForEach(Memory2D`1<TItem> memory, TAction& action, int minimumActionsPerThread);
    private static void ThrowArgumentOutOfRangeExceptionForInvalidMinimumActionsPerThread();
    private static void ThrowArgumentOutOfRangeExceptionForStartGreaterThanEnd();
    [NullableContextAttribute("1")]
private static void ThrowArgumentExceptionForRangeIndexFromEnd(string name);
    private static void ThrowArgumentOutOfRangeExceptionForTopGreaterThanBottom();
    private static void ThrowArgumentOutOfRangeExceptionForLeftGreaterThanRight();
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.IBufferWriterExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Stream AsStream(IBufferWriter`1<byte> writer);
    [ExtensionAttribute]
public static void Write(IBufferWriter`1<byte> writer, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Write(IBufferWriter`1<T> writer, T value);
    [ExtensionAttribute]
public static void Write(IBufferWriter`1<byte> writer, ReadOnlySpan`1<T> span);
    private static void ThrowArgumentExceptionForEndOfBuffer();
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.IMemoryOwnerExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Stream AsStream(IMemoryOwner`1<byte> memoryOwner);
}
internal static class Microsoft.Toolkit.HighPerformance.Memory.Internals.OverflowHelper : object {
    public static void EnsureIsInNativeIntRange(int height, int width, int pitch);
    public static int ComputeInt32Area(int height, int width, int pitch);
}
internal static class Microsoft.Toolkit.HighPerformance.Memory.Internals.ThrowHelper : object {
    public static void ThrowArgumentExceptionForManagedType();
    public static void ThrowArgumentExceptionForDestinationTooShort();
    public static void ThrowArgumentExceptionForDestinationWithNotSameShape();
    public static void ThrowArrayTypeMismatchException();
    public static void ThrowArgumentExceptionForUnsupportedType();
    public static void ThrowIndexOutOfRangeException();
    public static void ThrowArgumentException();
    public static void ThrowArgumentOutOfRangeExceptionForDepth();
    public static void ThrowArgumentOutOfRangeExceptionForRow();
    public static void ThrowArgumentOutOfRangeExceptionForColumn();
    public static void ThrowArgumentOutOfRangeExceptionForOffset();
    public static void ThrowArgumentOutOfRangeExceptionForHeight();
    public static void ThrowArgumentOutOfRangeExceptionForWidth();
    public static void ThrowArgumentOutOfRangeExceptionForPitch();
}
internal class Microsoft.Toolkit.HighPerformance.Memory.Views.MemoryDebugView2D`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private T[0...,0...] <Items>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("2")]
public T[0...,0...] Items { get; }
    public MemoryDebugView2D`1(Memory2D`1<T> memory);
    public MemoryDebugView2D`1(ReadOnlyMemory2D`1<T> memory);
    public MemoryDebugView2D`1(Span2D`1<T> span);
    public MemoryDebugView2D`1(ReadOnlySpan2D`1<T> span);
    [CompilerGeneratedAttribute]
public T[0...,0...] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.Toolkit.HighPerformance.Memory.Views.MemoryDebugView2D`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class Microsoft.Toolkit.HighPerformance.Memory2D`1 : ValueType {
    [NullableAttribute("2")]
private object instance;
    private IntPtr offset;
    private int height;
    private int width;
    private int pitch;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Memory2D`1<T> Empty { get; }
    public bool IsEmpty { get; }
    [NativeIntegerAttribute]
public IntPtr Length { get; }
    public int Height { get; }
    public int Width { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span2D`1<T> Span { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Memory2D`1<T> Item { get; }
    public Memory2D`1(T[] array, int height, int width);
    public Memory2D`1(T[] array, int offset, int height, int width, int pitch);
    public Memory2D`1(T[0...,0...] array);
    public Memory2D`1(T[0...,0...] array, int row, int column, int height, int width);
    public Memory2D`1(T[0...,0...,0...] array, int depth);
    public Memory2D`1(T[0...,0...,0...] array, int depth, int row, int column, int height, int width);
    public Memory2D`1(MemoryManager`1<T> memoryManager, int height, int width);
    public Memory2D`1(MemoryManager`1<T> memoryManager, int offset, int height, int width, int pitch);
    internal Memory2D`1(Memory`1<T> memory, int height, int width);
    internal Memory2D`1(Memory`1<T> memory, int offset, int height, int width, int pitch);
    private Memory2D`1(object instance, IntPtr offset, int height, int width, int pitch);
    public static Memory2D`1<T> DangerousCreate(object instance, T& value, int height, int width, int pitch);
    public static Memory2D`1<T> get_Empty();
    public bool get_IsEmpty();
    public IntPtr get_Length();
    public int get_Height();
    public int get_Width();
    public Span2D`1<T> get_Span();
    public Memory2D`1<T> get_Item(Range rows, Range columns);
    public Memory2D`1<T> Slice(int row, int column, int height, int width);
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public void CopyTo(Memory2D`1<T> destination);
    public bool TryCopyTo(Memory2D`1<T> destination);
    public MemoryHandle Pin();
    public bool TryGetMemory(Memory`1& memory);
    public T[0...,0...] ToArray();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Memory2D`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    public static Memory2D`1<T> op_Implicit(T[0...,0...] array);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.MemoryExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory2D`1<T> AsMemory2D(Memory`1<T> memory, int height, int width);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory2D`1<T> AsMemory2D(Memory`1<T> memory, int offset, int height, int width, int pitch);
    [ExtensionAttribute]
public static Memory`1<byte> AsBytes(Memory`1<T> memory);
    [ExtensionAttribute]
public static Memory`1<TTo> Cast(Memory`1<TFrom> memory);
    [ExtensionAttribute]
public static Stream AsStream(Memory`1<byte> memory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
public class Microsoft.Toolkit.HighPerformance.NullableReadOnlyRef`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlySpan`1<T> span;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static NullableReadOnlyRef`1<T> Null { get; }
    public bool HasValue { get; }
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Value { get; }
    public NullableReadOnlyRef`1(T& value);
    private NullableReadOnlyRef`1(ReadOnlySpan`1<T> span);
    public static NullableReadOnlyRef`1<T> get_Null();
    public bool get_HasValue();
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Value();
    public static NullableReadOnlyRef`1<T> op_Implicit(Ref`1<T> reference);
    public static NullableReadOnlyRef`1<T> op_Implicit(ReadOnlyRef`1<T> reference);
    public static NullableReadOnlyRef`1<T> op_Implicit(NullableRef`1<T> reference);
    public static T op_Explicit(NullableReadOnlyRef`1<T> reference);
    private static void ThrowInvalidOperationException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
public class Microsoft.Toolkit.HighPerformance.NullableRef`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Span`1<T> Span;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static NullableRef`1<T> Null { get; }
    public bool HasValue { get; }
    public T& Value { get; }
    public NullableRef`1(T& value);
    private NullableRef`1(Span`1<T> span);
    public static NullableRef`1<T> get_Null();
    public bool get_HasValue();
    public T& get_Value();
    public static NullableRef`1<T> op_Implicit(Ref`1<T> reference);
    public static T op_Explicit(NullableRef`1<T> reference);
    private static void ThrowInvalidOperationException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.Toolkit.HighPerformance.Memory.Views.MemoryDebugView2D`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class Microsoft.Toolkit.HighPerformance.ReadOnlyMemory2D`1 : ValueType {
    [NullableAttribute("2")]
private object instance;
    private IntPtr offset;
    private int height;
    private int width;
    private int pitch;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadOnlyMemory2D`1<T> Empty { get; }
    public bool IsEmpty { get; }
    [NativeIntegerAttribute]
public IntPtr Length { get; }
    public int Height { get; }
    public int Width { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan2D`1<T> Span { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyMemory2D`1<T> Item { get; }
    public ReadOnlyMemory2D`1(string text, int height, int width);
    public ReadOnlyMemory2D`1(string text, int offset, int height, int width, int pitch);
    public ReadOnlyMemory2D`1(T[] array, int height, int width);
    public ReadOnlyMemory2D`1(T[] array, int offset, int height, int width, int pitch);
    public ReadOnlyMemory2D`1(T[0...,0...] array);
    public ReadOnlyMemory2D`1(T[0...,0...] array, int row, int column, int height, int width);
    public ReadOnlyMemory2D`1(T[0...,0...,0...] array, int depth);
    public ReadOnlyMemory2D`1(T[0...,0...,0...] array, int depth, int row, int column, int height, int width);
    public ReadOnlyMemory2D`1(MemoryManager`1<T> memoryManager, int height, int width);
    public ReadOnlyMemory2D`1(MemoryManager`1<T> memoryManager, int offset, int height, int width, int pitch);
    internal ReadOnlyMemory2D`1(ReadOnlyMemory`1<T> memory, int height, int width);
    internal ReadOnlyMemory2D`1(ReadOnlyMemory`1<T> memory, int offset, int height, int width, int pitch);
    private ReadOnlyMemory2D`1(object instance, IntPtr offset, int height, int width, int pitch);
    public static ReadOnlyMemory2D`1<T> DangerousCreate(object instance, T& value, int height, int width, int pitch);
    public static ReadOnlyMemory2D`1<T> get_Empty();
    public bool get_IsEmpty();
    public IntPtr get_Length();
    public int get_Height();
    public int get_Width();
    public ReadOnlySpan2D`1<T> get_Span();
    public ReadOnlyMemory2D`1<T> get_Item(Range rows, Range columns);
    public ReadOnlyMemory2D`1<T> Slice(int row, int column, int height, int width);
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public void CopyTo(Memory2D`1<T> destination);
    public bool TryCopyTo(Memory2D`1<T> destination);
    public MemoryHandle Pin();
    public bool TryGetMemory(ReadOnlyMemory`1& memory);
    public T[0...,0...] ToArray();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReadOnlyMemory2D`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    public static ReadOnlyMemory2D`1<T> op_Implicit(T[0...,0...] array);
    public static ReadOnlyMemory2D`1<T> op_Implicit(Memory2D`1<T> memory);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.ReadOnlyMemoryExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ReadOnlyMemory2D`1<T> AsMemory2D(ReadOnlyMemory`1<T> memory, int height, int width);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ReadOnlyMemory2D`1<T> AsMemory2D(ReadOnlyMemory`1<T> memory, int offset, int height, int width, int pitch);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<byte> AsBytes(ReadOnlyMemory`1<T> memory);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<TTo> Cast(ReadOnlyMemory`1<TFrom> memory);
    [ExtensionAttribute]
public static Stream AsStream(ReadOnlyMemory`1<byte> memory);
    [CompilerGeneratedAttribute]
internal static ReadOnlyMemory`1<TTo> <Cast>g__ThrowArgumentExceptionForUnsupportedMemory|3_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
public class Microsoft.Toolkit.HighPerformance.ReadOnlyRef`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ReadOnlySpan`1<T> Span;
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Value { get; }
    public ReadOnlyRef`1(T& value);
    [NullableContextAttribute("0")]
public ReadOnlyRef`1(Void* pointer);
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Value();
    public static ReadOnlyRef`1<T> op_Implicit(Ref`1<T> reference);
    public static T op_Implicit(ReadOnlyRef`1<T> reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.Toolkit.HighPerformance.Memory.Views.MemoryDebugView2D`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlySpan`1<T> span;
    private int width;
    private int stride;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadOnlySpan2D`1<T> Empty { get; }
    public bool IsEmpty { get; }
    [NativeIntegerAttribute]
public IntPtr Length { get; }
    public int Height { get; }
    public int Width { get; }
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan2D`1<T> Item { get; }
    internal ReadOnlySpan2D`1(T& value, int height, int width, int pitch);
    [NullableContextAttribute("0")]
public ReadOnlySpan2D`1(Void* pointer, int height, int width, int pitch);
    public ReadOnlySpan2D`1(T[] array, int height, int width);
    public ReadOnlySpan2D`1(T[] array, int offset, int height, int width, int pitch);
    public ReadOnlySpan2D`1(T[0...,0...] array);
    public ReadOnlySpan2D`1(T[0...,0...] array, int row, int column, int height, int width);
    public ReadOnlySpan2D`1(T[0...,0...,0...] array, int depth);
    public ReadOnlySpan2D`1(T[0...,0...,0...] array, int depth, int row, int column, int height, int width);
    internal ReadOnlySpan2D`1(ReadOnlySpan`1<T> span, int height, int width);
    internal ReadOnlySpan2D`1(ReadOnlySpan`1<T> span, int offset, int height, int width, int pitch);
    public static ReadOnlySpan2D`1<T> DangerousCreate(T& value, int height, int width, int pitch);
    public static ReadOnlySpan2D`1<T> get_Empty();
    public bool get_IsEmpty();
    public IntPtr get_Length();
    public int get_Height();
    public int get_Width();
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int row, int column);
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(Index row, Index column);
    public ReadOnlySpan2D`1<T> get_Item(Range rows, Range columns);
    public void CopyTo(Span`1<T> destination);
    public void CopyTo(Span2D`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span2D`1<T> destination);
    [EditorBrowsableAttribute("1")]
public T& GetPinnableReference();
    public T& DangerousGetReference();
    public T& DangerousGetReferenceAt(int i, int j);
    public ReadOnlySpan2D`1<T> Slice(int row, int column, int height, int width);
    public ReadOnlySpan`1<T> GetRowSpan(int row);
    public bool TryGetSpan(ReadOnlySpan`1& span);
    public T[0...,0...] ToArray();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(ReadOnlySpan2D`1<T> left, ReadOnlySpan2D`1<T> right);
    public static bool op_Inequality(ReadOnlySpan2D`1<T> left, ReadOnlySpan2D`1<T> right);
    public static ReadOnlySpan2D`1<T> op_Implicit(T[0...,0...] array);
    public static ReadOnlySpan2D`1<T> op_Implicit(Span2D`1<T> span);
    public ReadOnlyRefEnumerable`1<T> GetRow(int row);
    public ReadOnlyRefEnumerable`1<T> GetColumn(int column);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions : object {
    [ExtensionAttribute]
public static T& DangerousGetReference(ReadOnlySpan`1<T> span);
    [ExtensionAttribute]
public static T& DangerousGetReferenceAt(ReadOnlySpan`1<T> span, int i);
    [ExtensionAttribute]
public static T& DangerousGetReferenceAt(ReadOnlySpan`1<T> span, IntPtr i);
    [ExtensionAttribute]
public static T& modreq(System.Runtime.InteropServices.InAttribute) DangerousGetLookupReferenceAt(ReadOnlySpan`1<T> span, int i);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ReadOnlySpan2D`1<T> AsSpan2D(ReadOnlySpan`1<T> span, int height, int width);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ReadOnlySpan2D`1<T> AsSpan2D(ReadOnlySpan`1<T> span, int offset, int height, int width, int pitch);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, T& value);
    [ExtensionAttribute]
public static int Count(ReadOnlySpan`1<T> span, T value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ReadOnlySpanEnumerable`1<T> Enumerate(ReadOnlySpan`1<T> span);
    [ExtensionAttribute]
public static ReadOnlySpanTokenizer`1<T> Tokenize(ReadOnlySpan`1<T> span, T separator);
    [ExtensionAttribute]
public static int GetDjb2HashCode(ReadOnlySpan`1<T> span);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(ReadOnlySpan`1<T> span, RefEnumerable`1<T> destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryCopyTo(ReadOnlySpan`1<T> span, RefEnumerable`1<T> destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
public class Microsoft.Toolkit.HighPerformance.Ref`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Span`1<T> Span;
    public T& Value { get; }
    public Ref`1(T& value);
    [NullableContextAttribute("0")]
public Ref`1(Void* pointer);
    public T& get_Value();
    public static T op_Implicit(Ref`1<T> reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.Toolkit.HighPerformance.Memory.Views.MemoryDebugView2D`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class Microsoft.Toolkit.HighPerformance.Span2D`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Span`1<T> span;
    private int width;
    internal int Stride;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Span2D`1<T> Empty { get; }
    public bool IsEmpty { get; }
    [NativeIntegerAttribute]
public IntPtr Length { get; }
    public int Height { get; }
    public int Width { get; }
    public T& Item { get; }
    public T& Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span2D`1<T> Item { get; }
    internal Span2D`1(T& value, int height, int width, int pitch);
    [NullableContextAttribute("0")]
public Span2D`1(Void* pointer, int height, int width, int pitch);
    public Span2D`1(T[] array, int height, int width);
    public Span2D`1(T[] array, int offset, int height, int width, int pitch);
    public Span2D`1(T[0...,0...] array);
    public Span2D`1(T[0...,0...] array, int row, int column, int height, int width);
    public Span2D`1(T[0...,0...,0...] array, int depth);
    public Span2D`1(T[0...,0...,0...] array, int depth, int row, int column, int height, int width);
    internal Span2D`1(Span`1<T> span, int height, int width);
    internal Span2D`1(Span`1<T> span, int offset, int height, int width, int pitch);
    public static Span2D`1<T> DangerousCreate(T& value, int height, int width, int pitch);
    public static Span2D`1<T> get_Empty();
    public bool get_IsEmpty();
    public IntPtr get_Length();
    public int get_Height();
    public int get_Width();
    public T& get_Item(int row, int column);
    public T& get_Item(Index row, Index column);
    public Span2D`1<T> get_Item(Range rows, Range columns);
    public void Clear();
    public void CopyTo(Span`1<T> destination);
    public void CopyTo(Span2D`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span2D`1<T> destination);
    public void Fill(T value);
    [EditorBrowsableAttribute("1")]
public T& GetPinnableReference();
    public T& DangerousGetReference();
    public T& DangerousGetReferenceAt(int i, int j);
    public Span2D`1<T> Slice(int row, int column, int height, int width);
    public Span`1<T> GetRowSpan(int row);
    public bool TryGetSpan(Span`1& span);
    public T[0...,0...] ToArray();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Span2D`1<T> left, Span2D`1<T> right);
    public static bool op_Inequality(Span2D`1<T> left, Span2D`1<T> right);
    public static Span2D`1<T> op_Implicit(T[0...,0...] array);
    public RefEnumerable`1<T> GetRow(int row);
    public RefEnumerable`1<T> GetColumn(int column);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.SpanExtensions : object {
    [ExtensionAttribute]
public static T& DangerousGetReference(Span`1<T> span);
    [ExtensionAttribute]
public static T& DangerousGetReferenceAt(Span`1<T> span, int i);
    [ExtensionAttribute]
public static T& DangerousGetReferenceAt(Span`1<T> span, IntPtr i);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span2D`1<T> AsSpan2D(Span`1<T> span, int height, int width);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span2D`1<T> AsSpan2D(Span`1<T> span, int offset, int height, int width, int pitch);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Span`1<byte> AsBytes(Span`1<T> span);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Span`1<TTo> Cast(Span`1<TFrom> span);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, T& value);
    [ExtensionAttribute]
public static int Count(Span`1<T> span, T value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SpanEnumerable`1<T> Enumerate(Span`1<T> span);
    [ExtensionAttribute]
public static SpanTokenizer`1<T> Tokenize(Span`1<T> span, T separator);
    [ExtensionAttribute]
public static int GetDjb2HashCode(Span`1<T> span);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(Span`1<T> span, RefEnumerable`1<T> destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryCopyTo(Span`1<T> span, RefEnumerable`1<T> destination);
    internal static void ThrowArgumentOutOfRangeExceptionForInvalidReference();
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.SpinLockExtensions : object {
    public static UnsafeLock Enter(SpinLock* spinLock);
    [ExtensionAttribute]
public static Lock Enter(SpinLock& spinLock);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.StreamExtensions : object {
    [ExtensionAttribute]
public static T Read(Stream stream);
    [ExtensionAttribute]
public static void Write(Stream stream, T& value);
    private static void ThrowInvalidOperationExceptionForEndOfStream();
}
[IsReadOnlyAttribute]
internal class Microsoft.Toolkit.HighPerformance.Streams.ArrayBufferWriterOwner : ValueType {
    [NullableAttribute("1")]
private ArrayPoolBufferWriter`1<byte> writer;
    [NullableContextAttribute("1")]
public ArrayBufferWriterOwner(ArrayPoolBufferWriter`1<byte> writer);
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
}
[IsReadOnlyAttribute]
internal class Microsoft.Toolkit.HighPerformance.Streams.ArrayOwner : ValueType {
    [NullableAttribute("1")]
private Byte[] array;
    private int offset;
    private int length;
    public static ArrayOwner Empty { get; }
    public int Length { get; }
    public Span`1<byte> Span { get; }
    [NullableContextAttribute("1")]
public ArrayOwner(Byte[] array, int offset, int length);
    public static ArrayOwner get_Empty();
    public sealed virtual int get_Length();
    public sealed virtual Span`1<byte> get_Span();
}
[IsReadOnlyAttribute]
internal class Microsoft.Toolkit.HighPerformance.Streams.IBufferWriterOwner : ValueType {
    [NullableAttribute("1")]
private IBufferWriter`1<byte> writer;
    [NullableContextAttribute("1")]
public IBufferWriterOwner(IBufferWriter`1<byte> writer);
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
}
internal class Microsoft.Toolkit.HighPerformance.Streams.IBufferWriterStream`1 : Stream {
    private TWriter bufferWriter;
    private bool disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public IBufferWriterStream`1(TWriter bufferWriter);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [NullableContextAttribute("1")]
public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    [NullableContextAttribute("1")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [NullableContextAttribute("2")]
public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    [NullableContextAttribute("2")]
public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
}
internal class Microsoft.Toolkit.HighPerformance.Streams.IMemoryOwnerStream`1 : MemoryStream`1<TSource> {
    [NullableAttribute("1")]
private IDisposable disposable;
    public IMemoryOwnerStream`1(TSource source, IDisposable disposable);
    protected virtual void Dispose(bool disposing);
}
internal interface Microsoft.Toolkit.HighPerformance.Streams.ISpanOwner {
    public int Length { get; }
    public Span`1<byte> Span { get; }
    public abstract virtual int get_Length();
    public abstract virtual Span`1<byte> get_Span();
}
[IsReadOnlyAttribute]
internal class Microsoft.Toolkit.HighPerformance.Streams.MemoryManagerOwner : ValueType {
    [NullableAttribute("1")]
private MemoryManager`1<byte> memoryManager;
    private int offset;
    private int length;
    public int Length { get; }
    public Span`1<byte> Span { get; }
    [NullableContextAttribute("1")]
public MemoryManagerOwner(MemoryManager`1<byte> memoryManager, int offset, int length);
    public sealed virtual int get_Length();
    public sealed virtual Span`1<byte> get_Span();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Toolkit.HighPerformance.Streams.MemoryStream : object {
    [NullableContextAttribute("0")]
public static Stream Create(ReadOnlyMemory`1<byte> memory, bool isReadOnly);
    public static Stream Create(IMemoryOwner`1<byte> memoryOwner);
    private static Stream ThrowNotSupportedExceptionForInvalidMemory();
    public static Exception GetNotSupportedException();
    public static void ThrowNotSupportedException();
    public static void ThrowArgumentExceptionForEndOfStreamOnWrite();
    public static long ThrowArgumentExceptionForSeekOrigin();
    private static void ThrowArgumentOutOfRangeExceptionForPosition();
    private static void ThrowArgumentNullExceptionForBuffer();
    private static void ThrowArgumentOutOfRangeExceptionForOffset();
    private static void ThrowArgumentOutOfRangeExceptionForCount();
    private static void ThrowArgumentExceptionForLength();
    private static void ThrowObjectDisposedException();
    public static void ValidatePosition(long position, int length);
    [NullableContextAttribute("2")]
public static void ValidateBuffer(Byte[] buffer, int offset, int count);
    public static void ValidateCanWrite(bool canWrite);
    public static void ValidateDisposed(bool disposed);
}
internal class Microsoft.Toolkit.HighPerformance.Streams.MemoryStream`1 : Stream {
    private bool isReadOnly;
    private TSource source;
    private int position;
    private bool disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream`1(TSource source, bool isReadOnly);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    [NullableContextAttribute("1")]
public sealed virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public sealed virtual void Flush();
    [NullableContextAttribute("1")]
public sealed virtual Task FlushAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    [NullableContextAttribute("2")]
public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual int ReadByte();
    [NullableContextAttribute("2")]
public sealed virtual void Write(Byte[] buffer, int offset, int count);
    public sealed virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
public sealed virtual void CopyTo(Stream destination, int bufferSize);
    public sealed virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public sealed virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public sealed virtual int Read(Span`1<byte> buffer);
    public sealed virtual void Write(ReadOnlySpan`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Toolkit.HighPerformance.StringExtensions : object {
    [ExtensionAttribute]
public static Char& DangerousGetReference(string text);
    [ExtensionAttribute]
public static Char& DangerousGetReferenceAt(string text, int i);
    [ExtensionAttribute]
public static int Count(string text, char c);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ReadOnlySpanEnumerable`1<char> Enumerate(string text);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ReadOnlySpanTokenizer`1<char> Tokenize(string text, char separator);
    [ExtensionAttribute]
public static int GetDjb2HashCode(string text);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[AttributeUsageAttribute("1774")]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.3.37.35081")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
