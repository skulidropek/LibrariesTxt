[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ObsoleteAttribute("Use ProjectType instead since it has a distinction between Console (.NET) and Console (Core).")]
public enum Microsoft.VisualStudio.Containers.Tools.Common.AppType : Enum {
    public int value__;
    public static AppType AspNet;
    public static AppType AspNetCore;
    public static AppType Console;
}
public class Microsoft.VisualStudio.Containers.Tools.Common.AspNetCoreBindingAddress : object {
    private static string UnixPipeHostPrefix;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathBase>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    public string Host { get; private set; }
    public string PathBase { get; private set; }
    public int Port { get; internal set; }
    public string Scheme { get; private set; }
    public bool IsUnixPipe { get; }
    public string UnixPipePath { get; }
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
private void set_Host(string value);
    [CompilerGeneratedAttribute]
public string get_PathBase();
    [CompilerGeneratedAttribute]
private void set_PathBase(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
internal void set_Port(int value);
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
private void set_Scheme(string value);
    public bool get_IsUnixPipe();
    public string get_UnixPipePath();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static AspNetCoreBindingAddress Parse(string address);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.AspNetCoreUtilities : object {
    public static bool TryGetContainerPortFromEnvironmentVariables(IDictionary`2<string, string> environmentVariables, string urlScheme, Int32& port);
    public static bool TryGetContainerPortsFromEnvironmentVariables(IDictionary`2<string, string> environmentVariables, string urlScheme, ICollection`1& ports);
    public static bool TryParsePortFromAspNetUrls(string aspnetCoreUrls, string urlScheme, Int32& port);
    public static bool TryParsePortsFromAspNetUrls(string aspnetCoreUrls, string urlScheme, ICollection`1& ports);
    public static bool TryParsePortFromUrls(IEnumerable`1<string> urls, string urlScheme, Int32& port);
    public static bool TryParsePortsFromUrls(IEnumerable`1<string> urls, string urlScheme, ICollection`1& ports);
    private static bool TryGetAllPorts(string portsString, ICollection`1& ports);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.AsyncProgress`1 : object {
    private Action`1<T> action;
    public AsyncProgress`1(Action`1<T> action);
    public sealed virtual void Report(T value);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.AzureFunctionsUtilities : object {
    private static string LocalConnectionString;
    private static string HostConnectionString;
    public static IEnumerable`1<KeyValuePair`2<string, string>> GetLocalSettingsForFunctions(string projectDirectory, string userSecretsId, ContainerDevelopmentMode developmentMode, ILoggingService logger);
    private static void AddValues(Dictionary`2<string, string> environmentVariables, string key, JToken valueToken, ILoggingService logger);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Caching.FileBasedCache : object {
    private static string CacheFileExtension;
    private string cacheDirectory;
    public FileBasedCache(string cacheDirectory);
    public sealed virtual string Get(string key);
    public sealed virtual void Set(string key, string value);
    public sealed virtual void Remove(string key);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Caching.FileBasedCache/<GetAsync>d__6")]
public sealed virtual Task`1<string> GetAsync(string key);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Caching.FileBasedCache/<SetAsync>d__7")]
public sealed virtual Task SetAsync(string key, string value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Caching.FileBasedCache/<TemporarilySetAsync>d__8")]
public sealed virtual Task`1<IDisposable> TemporarilySetAsync(string key, string value);
    public sealed virtual Task RemoveAsync(string key);
    private string GetCacheFilePath(string key);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.Caching.FileBasedCacheExtensions : object {
    [ExtensionAttribute]
public static bool TryGetContainerDevelopmentMode(IFileBasedCache cache, ContainerDevelopmentMode& containerDevelopmentMode);
    [ExtensionAttribute]
public static bool TrySetContainerDevelopmentMode(IFileBasedCache cache, string containerDevelopmentMode);
    [ExtensionAttribute]
public static void SetContainerDevelopmentMode(IFileBasedCache cache, Nullable`1<ContainerDevelopmentMode> containerDevelopmentMode);
    [ExtensionAttribute]
public static bool TryGetTargetFramework(IFileBasedCache cache, TargetFramework& targetFramework);
    [ExtensionAttribute]
public static bool TrySetTargetFramework(IFileBasedCache cache, string targetFramework);
    [ExtensionAttribute]
public static void SetTargetFramework(IFileBasedCache cache, Nullable`1<TargetFramework> targetFramework);
    [ExtensionAttribute]
public static bool TryGetTargetOS(IFileBasedCache cache, OperatingSystemName& targetOS);
    [ExtensionAttribute]
public static bool TrySetTargetOS(IFileBasedCache cache, string targetOS);
    [ExtensionAttribute]
public static void SetTargetOS(IFileBasedCache cache, Nullable`1<OperatingSystemName> targetOS);
    [ExtensionAttribute]
public static string GetImageBuildContextHash(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetImageBuildContextHash(IFileBasedCache cache, string imageBuildContextHash);
    [ExtensionAttribute]
public static string GetContainerRunContextHash(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetContainerRunContextHash(IFileBasedCache cache, string containerRunContext);
    [ExtensionAttribute]
public static string GetContainerId(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetContainerId(IFileBasedCache cache, string containerId);
    [ExtensionAttribute]
public static string GetContainerName(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetContainerName(IFileBasedCache cache, string containerName);
    [ExtensionAttribute]
public static string GetImageId(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetImageId(IFileBasedCache cache, string imageId);
    [ExtensionAttribute]
public static void SetAbsoluteOutputAssemblyPath(IFileBasedCache cache, string absoluteOutputAssemblyPath);
    [ExtensionAttribute]
public static string GetAbsoluteOutputAssemblyPath(IFileBasedCache cache);
    [ExtensionAttribute]
public static string GetRelativeOutputAssemblyPath(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetAdditionalProbingPaths(IFileBasedCache cache, string probingPaths);
    [ExtensionAttribute]
public static string GetAdditionalProbingPaths(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetVsDbgScript(IFileBasedCache cache, string vsDbgScript);
    [ExtensionAttribute]
public static string GetVsDbgScript(IFileBasedCache cache);
    [ExtensionAttribute]
public static string GetDebuggeeProgram(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetDebuggeeProgram(IFileBasedCache cache, string debuggeeProgram);
    [ExtensionAttribute]
public static string GetDebuggeeArguments(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetDebuggeeArguments(IFileBasedCache cache, string debuggeeArguments);
    [ExtensionAttribute]
public static string GetDebuggeeWorkingDirectory(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetDebuggeeWorkingDirectory(IFileBasedCache cache, string debuggeeWorkingDirectory);
    [ExtensionAttribute]
public static string GetFastModeProjectMountDirectory(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetFastModeProjectMountDirectory(IFileBasedCache cache, string fastModeProjectMountDirectory);
    [ExtensionAttribute]
public static string GetDebuggeeKillProcessCommand(IFileBasedCache cache);
    [ExtensionAttribute]
public static void SetDebuggeeKillProcessCommand(IFileBasedCache cache, string debuggeeKillProcessCommand);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Caching.FileBasedCacheExtensions/<GetVolumeMappingsAsync>d__36")]
[ExtensionAttribute]
public static Task`1<List`1<VolumeMapping>> GetVolumeMappingsAsync(IFileBasedCache cache);
    [ExtensionAttribute]
public static Task SetVolumeMappingsAsync(IFileBasedCache cache, List`1<VolumeMapping> volumeMappings);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Caching.FileBasedCacheExtensions/<GetProfilerLaunchInfoAsync>d__38")]
[ExtensionAttribute]
public static Task`1<ProfilerLaunchInfo> GetProfilerLaunchInfoAsync(IFileBasedCache cache);
    [ExtensionAttribute]
public static Task`1<IDisposable> TemporarilySetProfilerLaunchInfoAsync(IFileBasedCache cache, ProfilerLaunchInfo profilerLaunchInfo);
    [ExtensionAttribute]
public static Task SetProfilerLaunchInfoAsync(IFileBasedCache cache, ProfilerLaunchInfo profilerLaunchInfo);
    [ExtensionAttribute]
public static bool TryGet(IFileBasedCache cache, TEnum& value);
    [ExtensionAttribute]
public static bool TrySet(IFileBasedCache cache, string value);
    [ExtensionAttribute]
public static void Set(IFileBasedCache cache, Nullable`1<TEnum> value);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Caching.IFileBasedCache {
    public abstract virtual string Get(string key);
    public abstract virtual void Set(string key, string value);
    public abstract virtual void Remove(string key);
    public abstract virtual Task`1<string> GetAsync(string key);
    public abstract virtual Task SetAsync(string key, string value);
    public abstract virtual Task`1<IDisposable> TemporarilySetAsync(string key, string value);
    public abstract virtual Task RemoveAsync(string key);
}
[DataContractAttribute]
public class Microsoft.VisualStudio.Containers.Tools.Common.Caching.ProfilerLaunchInfo : object {
    [CompilerGeneratedAttribute]
private string <HostFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HostPort>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ContainerPort>k__BackingField;
    [DataMemberAttribute]
public string HostFolder { get; }
    [DataMemberAttribute]
public int HostPort { get; }
    [DataMemberAttribute]
public int ContainerPort { get; }
    public ProfilerLaunchInfo(string hostFolder, int hostPort, int containerPort);
    [CompilerGeneratedAttribute]
public string get_HostFolder();
    [CompilerGeneratedAttribute]
public int get_HostPort();
    [CompilerGeneratedAttribute]
public int get_ContainerPort();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.CommandLineClient : Singleton`2<ICommandLineClient, CommandLineClient> {
    public sealed virtual Task`1<CommandLineResult> ExecuteCommandLineAsync(CommandLineParameters commandLineParameters, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool killChildProcess, CancellationToken cancellationToken);
    public sealed virtual Task`1<CommandLineResult> ExecuteCommandLineAsync(string fileName, string arguments, string workingDirectory, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool killChildProcess, CancellationToken cancellationToken);
    public sealed virtual RunningCommandLineResult StartCommandLine(CommandLineParameters commandLineParameters, Func`2<StreamWriter, ILogger> loggerFactory, CommandLineLoggingOptions commandLineLoggingOptions, bool killChildProcess, CancellationToken cancellationToken);
    protected virtual RunningCommandLineResult StartCommandLineCore(CommandLineParameters commandLineParameters, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool killChildProcess, CancellationToken cancellationToken);
    protected virtual RunningCommandLineResult StartCommandLineCore(CommandLineParameters commandLineParameters, Func`2<StreamWriter, ILogger> loggerFactory, CommandLineLoggingOptions commandLineLoggingOptions, bool killChildProcess, CancellationToken cancellationToken);
    public sealed virtual RunningProcessResult StartCommandLine(CommandLineParameters commandLineParameters, bool killChildProcess, CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.CommandLineLoggingOptions : object {
    [CompilerGeneratedAttribute]
private LoggerVerbosity <CommandLoggingVerbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <OutputLoggingVerbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <ErrorLoggingVerbosity>k__BackingField;
    public LoggerVerbosity CommandLoggingVerbosity { get; public set; }
    public LoggerVerbosity OutputLoggingVerbosity { get; public set; }
    public LoggerVerbosity ErrorLoggingVerbosity { get; public set; }
    [CompilerGeneratedAttribute]
public LoggerVerbosity get_CommandLoggingVerbosity();
    [CompilerGeneratedAttribute]
public void set_CommandLoggingVerbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public LoggerVerbosity get_OutputLoggingVerbosity();
    [CompilerGeneratedAttribute]
public void set_OutputLoggingVerbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public LoggerVerbosity get_ErrorLoggingVerbosity();
    [CompilerGeneratedAttribute]
public void set_ErrorLoggingVerbosity(LoggerVerbosity value);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.CommandLineParameters : object {
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateNoWindow>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RedirectErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RedirectStdOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RedirectStdInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseShellExecute>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessWindowStyle <WindowStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunElevated>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <StandardOutputEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <StandardErrorEncoding>k__BackingField;
    public string Arguments { get; public set; }
    public bool CreateNoWindow { get; public set; }
    public string Command { get; public set; }
    public IDictionary`2<string, string> EnvironmentVariables { get; public set; }
    public bool RedirectErrors { get; public set; }
    public bool RedirectStdOutput { get; public set; }
    public bool RedirectStdInput { get; public set; }
    public bool UseShellExecute { get; public set; }
    public ProcessWindowStyle WindowStyle { get; public set; }
    public string WorkingDirectory { get; public set; }
    public bool RunElevated { get; public set; }
    public Encoding StandardOutputEncoding { get; public set; }
    public Encoding StandardErrorEncoding { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public bool get_CreateNoWindow();
    [CompilerGeneratedAttribute]
public void set_CreateNoWindow(bool value);
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_RedirectErrors();
    [CompilerGeneratedAttribute]
public void set_RedirectErrors(bool value);
    [CompilerGeneratedAttribute]
public bool get_RedirectStdOutput();
    [CompilerGeneratedAttribute]
public void set_RedirectStdOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_RedirectStdInput();
    [CompilerGeneratedAttribute]
public void set_RedirectStdInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseShellExecute();
    [CompilerGeneratedAttribute]
public void set_UseShellExecute(bool value);
    [CompilerGeneratedAttribute]
public ProcessWindowStyle get_WindowStyle();
    [CompilerGeneratedAttribute]
public void set_WindowStyle(ProcessWindowStyle value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_RunElevated();
    [CompilerGeneratedAttribute]
public void set_RunElevated(bool value);
    [CompilerGeneratedAttribute]
public Encoding get_StandardOutputEncoding();
    [CompilerGeneratedAttribute]
public void set_StandardOutputEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public Encoding get_StandardErrorEncoding();
    [CompilerGeneratedAttribute]
public void set_StandardErrorEncoding(Encoding value);
    public ProcessStartInfo ToProcessStartInfo();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.CommandLineResult : object {
    [CompilerGeneratedAttribute]
private CommandLineParameters <CommandLineParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <StandardOutputLines>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <StandardErrorLines>k__BackingField;
    public CommandLineParameters CommandLineParameters { get; }
    public int ExitCode { get; }
    public IReadOnlyList`1<string> StandardOutputLines { get; }
    public IReadOnlyList`1<string> StandardErrorLines { get; }
    public CommandLineResult(CommandLineParameters commandLineParameters, int exitCode, IEnumerable`1<string> standardOutputLines, IEnumerable`1<string> standardErrorLines);
    [CompilerGeneratedAttribute]
public CommandLineParameters get_CommandLineParameters();
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_StandardOutputLines();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_StandardErrorLines();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.Config : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<int> <ports>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <environmentVariables>k__BackingField;
    [JsonConverterAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.PortsConverter")]
[JsonPropertyAttribute("ExposedPorts")]
public IEnumerable`1<int> ports { get; public set; }
    [JsonConverterAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.EnvironmentVariablesConverter")]
[JsonPropertyAttribute("Env")]
public Dictionary`2<string, string> environmentVariables { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<int> get_ports();
    [CompilerGeneratedAttribute]
public void set_ports(IEnumerable`1<int> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_environmentVariables();
    [CompilerGeneratedAttribute]
public void set_environmentVariables(Dictionary`2<string, string> value);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.ContainerImageBuildContext : object {
    [CompilerGeneratedAttribute]
private string <BuildArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DockerfilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DockerIgnoreFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Pull>k__BackingField;
    public string BuildArguments { get; public set; }
    public string DockerfilePath { get; public set; }
    public string DockerIgnoreFilePath { get; public set; }
    public string BuildContext { get; public set; }
    public string Repository { get; public set; }
    public string Tag { get; public set; }
    public string Stage { get; public set; }
    public bool Pull { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BuildArguments();
    [CompilerGeneratedAttribute]
public void set_BuildArguments(string value);
    [CompilerGeneratedAttribute]
public string get_DockerfilePath();
    [CompilerGeneratedAttribute]
public void set_DockerfilePath(string value);
    [CompilerGeneratedAttribute]
public string get_DockerIgnoreFilePath();
    [CompilerGeneratedAttribute]
public void set_DockerIgnoreFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_BuildContext();
    [CompilerGeneratedAttribute]
public void set_BuildContext(string value);
    [CompilerGeneratedAttribute]
public string get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(string value);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
    [CompilerGeneratedAttribute]
public string get_Stage();
    [CompilerGeneratedAttribute]
public void set_Stage(string value);
    [CompilerGeneratedAttribute]
public bool get_Pull();
    [CompilerGeneratedAttribute]
public void set_Pull(bool value);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.Client.ContainerImageBuildContextExtensions : object {
    [ExtensionAttribute]
public static string GetBase64EncodedSHA256HashString(ContainerImageBuildContext context);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.ContainerIPAddress : object {
    [CompilerGeneratedAttribute]
private string <IPAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Network>k__BackingField;
    public string IPAddress { get; }
    public string Network { get; }
    public ContainerIPAddress(string ipAddress, string network);
    [CompilerGeneratedAttribute]
public string get_IPAddress();
    [CompilerGeneratedAttribute]
public string get_Network();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.ContainerPortMapping : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <HostPort>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ContainerPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Protocol>k__BackingField;
    public Nullable`1<int> HostPort { get; }
    public int ContainerPort { get; }
    public string Protocol { get; }
    public ContainerPortMapping(Nullable`1<int> hostPort, int containerPort, string protocol);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_HostPort();
    [CompilerGeneratedAttribute]
public int get_ContainerPort();
    [CompilerGeneratedAttribute]
public string get_Protocol();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.ContainerRunContext : object {
    [CompilerGeneratedAttribute]
private string <RunArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImageNameOrId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Entrypoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntrypointArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<VolumeMapping> <VolumeMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <EnvironmentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<int, int> <PortMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PublishAllPorts>k__BackingField;
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    public string RunArguments { get; public set; }
    public string ImageNameOrId { get; public set; }
    public string Entrypoint { get; public set; }
    public string EntrypointArguments { get; public set; }
    public IReadOnlyCollection`1<VolumeMapping> VolumeMappings { get; public set; }
    public IReadOnlyCollection`1<string> EnvironmentFiles { get; public set; }
    public IReadOnlyCollection`1<string> EnvironmentVariables { get; public set; }
    public IReadOnlyDictionary`2<int, int> PortMappings { get; public set; }
    public string ContainerName { get; public set; }
    public bool PublishAllPorts { get; public set; }
    public string User { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RunArguments();
    [CompilerGeneratedAttribute]
public void set_RunArguments(string value);
    [CompilerGeneratedAttribute]
public string get_ImageNameOrId();
    [CompilerGeneratedAttribute]
public void set_ImageNameOrId(string value);
    [CompilerGeneratedAttribute]
public string get_Entrypoint();
    [CompilerGeneratedAttribute]
public void set_Entrypoint(string value);
    [CompilerGeneratedAttribute]
public string get_EntrypointArguments();
    [CompilerGeneratedAttribute]
public void set_EntrypointArguments(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<VolumeMapping> get_VolumeMappings();
    [CompilerGeneratedAttribute]
public void set_VolumeMappings(IReadOnlyCollection`1<VolumeMapping> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_EnvironmentFiles();
    [CompilerGeneratedAttribute]
public void set_EnvironmentFiles(IReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(IReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<int, int> get_PortMappings();
    [CompilerGeneratedAttribute]
public void set_PortMappings(IReadOnlyDictionary`2<int, int> value);
    [CompilerGeneratedAttribute]
public string get_ContainerName();
    [CompilerGeneratedAttribute]
public void set_ContainerName(string value);
    [CompilerGeneratedAttribute]
public bool get_PublishAllPorts();
    [CompilerGeneratedAttribute]
public void set_PublishAllPorts(bool value);
    [CompilerGeneratedAttribute]
public string get_User();
    [CompilerGeneratedAttribute]
public void set_User(string value);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.Client.ContainerRunContextExtensions : object {
    [ExtensionAttribute]
public static string GetBase64EncodedSHA256HashString(ContainerRunContext context);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.DistrolessHelperUtilities : object {
    private static string GetBaseCommand(OperatingSystemName osName);
    public static string GetWaitCommand(OperatingSystemName osName);
    public static string GetDirectoryItemCountCommand(OperatingSystemName osName, string directoryPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DistrolessHelperUtilities/<GetDirectoryItemCountAsync>d__3")]
public static Task`1<int> GetDirectoryItemCountAsync(string containerId, OperatingSystemName osName, string directoryPath, bool throwOnError);
    public static string GetPathExistsCommand(OperatingSystemName osName, string filePath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DistrolessHelperUtilities/<CheckPathExistsAsync>d__5")]
public static Task`1<bool> CheckPathExistsAsync(string containerId, OperatingSystemName osName, string filePath, bool throwOnError);
    public static string GetStopCommand(OperatingSystemName osName, String[] processNames);
    public Task StopProcessAsync(string containerId, OperatingSystemName osName, string processName, bool throwOnError);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DistrolessHelperUtilities/<StopProcessesAsync>d__8")]
public static Task StopProcessesAsync(string containerId, OperatingSystemName osName, String[] processNames, bool throwOnError);
    public static bool IsDistrolessHelperSupported(ProjectType projectType, Nullable`1<ContainerDevelopmentMode> developmentMode, Version netCoreVersion);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient : Singleton`2<IDockerClient, DockerClient> {
    private static string DockerCommand;
    private static int DockerPullExitCodeCtrlC;
    private static int DockerPullExitCodeForciblyClosed;
    private static Regex PortRegex;
    private static DockerClient();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<BuildImageAsync>d__4")]
public sealed virtual Task`1<bool> BuildImageAsync(ContainerImageBuildContext context, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<RunContainerAsync>d__5")]
public sealed virtual Task`1<string> RunContainerAsync(ContainerRunContext context, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> BuildImageAsync(string dockerfilePath, string buildContext, string tag, string stage, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetContainerIdAsync>d__7")]
public sealed virtual Task`1<string> GetContainerIdAsync(IDictionary`2<string, string> labels, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetContainerIdsAsync>d__8")]
public sealed virtual Task`1<IEnumerable`1<string>> GetContainerIdsAsync(IDictionary`2<string, string> labels, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetContainerIdAsync>d__9")]
public sealed virtual Task`1<string> GetContainerIdAsync(string containerName, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetAllContainerNamesAsync>d__10")]
public sealed virtual Task`1<IEnumerable`1<string>> GetAllContainerNamesAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetContainerStateAsync>d__11")]
public sealed virtual Task`1<ContainerState> GetContainerStateAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<StartContainerAsync>d__12")]
public sealed virtual Task`1<bool> StartContainerAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<UnpauseContainerAsync>d__13")]
public sealed virtual Task`1<bool> UnpauseContainerAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<IsContainerRunningAsync>d__14")]
public sealed virtual Task`1<bool> IsContainerRunningAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetImageDetails>d__15")]
public sealed virtual Task`1<ImageDetails> GetImageDetails(string imageId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> ExecAsync(bool interactive, bool detach, string containerId, string command, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> ExecAsync(bool interactive, bool detach, string containerId, string command, IReadOnlyDictionary`2<string, string> environmentVariables, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<ExecAsync>d__18")]
public sealed virtual Task`1<string> ExecAsync(bool interactive, bool detach, string containerId, string command, IReadOnlyDictionary`2<string, string> environmentVariables, string workingDirectory, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    public sealed virtual RunningCommandLineResult StartExecInteractive(string containerId, string command, IReadOnlyDictionary`2<string, string> environmentVariables, string workingDirectory, Func`2<StreamWriter, ILogger> loggerFactory, bool killChildProcess, CancellationToken cancellationToken);
    public sealed virtual RunningProcessResult StartExec(string containerId, string command, IReadOnlyDictionary`2<string, string> environmentVariables, string workingDirectory, bool killChildProcess, CancellationToken cancellationToken);
    private static string GetExecOptions(bool interactive, bool detach, IReadOnlyDictionary`2<string, string> environmentVariables, string workingDirectory);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<RemoveContainerAsync>d__22")]
public sealed virtual Task`1<bool> RemoveContainerAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<KillAsync>d__23")]
public sealed virtual Task`1<string> KillAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetIPAddressesAsync>d__24")]
public sealed virtual Task`1<String[]> GetIPAddressesAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetIPAddressInfoAsync>d__25")]
public sealed virtual Task`1<IEnumerable`1<ContainerIPAddress>> GetIPAddressInfoAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<RemoveDanglingImagesAsync>d__26")]
public sealed virtual Task`1<string> RemoveDanglingImagesAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetHostPortsAsync>d__27")]
public sealed virtual Task`1<Int32[]> GetHostPortsAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetExposedPortsAsync>d__28")]
public sealed virtual Task`1<Int32[]> GetExposedPortsAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetPortMappingsAsync>d__29")]
public sealed virtual Task`1<IEnumerable`1<ContainerPortMapping>> GetPortMappingsAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetServerOperatingSystemAsync>d__30")]
public sealed virtual Task`1<string> GetServerOperatingSystemAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<PullWithConsoleAsync>d__31")]
public sealed virtual Task`1<bool> PullWithConsoleAsync(IEnumerable`1<string> imagesToPull, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<SwitchDockerOperatingSystemAsync>d__32")]
public sealed virtual Task`1<string> SwitchDockerOperatingSystemAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<PullAsync>d__33")]
public sealed virtual Task`1<string> PullAsync(string image, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<CheckIfImageExistsAsync>d__34")]
public sealed virtual Task`1<bool> CheckIfImageExistsAsync(string image, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetExistingImagesAsync>d__35")]
public sealed virtual Task`1<IEnumerable`1<string>> GetExistingImagesAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetImageIdAsync>d__36")]
public sealed virtual Task`1<string> GetImageIdAsync(string imageName, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<LoginAsync>d__37")]
public sealed virtual Task`1<CommandLineResult> LoginAsync(string serverName, string userName, string password, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<TagAsync>d__38")]
public sealed virtual Task`1<bool> TagAsync(string sourceImageName, string targetImageName, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<PushAsync>d__39")]
public sealed virtual Task`1<bool> PushAsync(string imageName, IReadOnlyDictionary`2<string, string> additionalEnvironmentVariables, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetDockerVersionInfoAsync>d__40")]
public sealed virtual Task`1<DockerVersionInfo> GetDockerVersionInfoAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetDockerVersionAsync>d__41")]
public sealed virtual Task`1<string> GetDockerVersionAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<GetDockerComposeVersionAsync>d__42")]
public sealed virtual Task`1<string> GetDockerComposeVersionAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerClient/<DirectoryOrFileExistsInContainerAsync>d__43")]
public sealed virtual Task`1<bool> DirectoryOrFileExistsInContainerAsync(string containerId, string path, OperatingSystemName targetOS, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    private string GetDockerVersionOutputIfNoError(CommandLineResult commandLineResult);
    private static string GetFirstOutputLineIfNotError(CommandLineResult commandLineResult);
    private static string GetAllOutputLinesIfNotError(CommandLineResult commandLineResult);
    private static string StripShaImageTag(string imageId);
    private static CommandLineParameters GetDockerParameters(string arguments);
    private static CommandLineParameters GetDockerComposeParameters(string arguments);
    private static CommandLineParameters GetParameters(string command, string arguments);
    private static bool TryParseContainerPortInfo(string containerPortInfo, Int32& containerPort, String& protocol);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerPathHelper : object {
    private static string DockerCliExecutableName;
    private static string DefaultDockerCliPath;
    private static string DockerRegistryKeyName;
    public static string FindDockerCliPath();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.DockerVersionInfo : object {
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientExperimental>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerExperimental>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DockerComposeVersion>k__BackingField;
    public string ClientVersion { get; public set; }
    public string ClientExperimental { get; public set; }
    public string ServerVersion { get; public set; }
    public string ServerExperimental { get; public set; }
    public string DockerComposeVersion { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientVersion();
    [CompilerGeneratedAttribute]
public void set_ClientVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ClientExperimental();
    [CompilerGeneratedAttribute]
public void set_ClientExperimental(string value);
    [CompilerGeneratedAttribute]
public string get_ServerVersion();
    [CompilerGeneratedAttribute]
public void set_ServerVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ServerExperimental();
    [CompilerGeneratedAttribute]
public void set_ServerExperimental(string value);
    [CompilerGeneratedAttribute]
public string get_DockerComposeVersion();
    [CompilerGeneratedAttribute]
public void set_DockerComposeVersion(string value);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.EnvironmentVariablesConverter : JsonConverter`1<Dictionary`2<string, string>> {
    public virtual Dictionary`2<string, string> ReadJson(JsonReader reader, Type objectType, Dictionary`2<string, string> existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, Dictionary`2<string, string> value, JsonSerializer serializer);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Client.ICommandLineClient {
    public abstract virtual Task`1<CommandLineResult> ExecuteCommandLineAsync(string fileName, string arguments, string workingDirectory, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool killChildProcess, CancellationToken cancellationToken);
    public abstract virtual Task`1<CommandLineResult> ExecuteCommandLineAsync(CommandLineParameters commandLineParameters, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool killChildProcess, CancellationToken cancellationToken);
    public abstract virtual RunningCommandLineResult StartCommandLine(CommandLineParameters commandLineParameters, Func`2<StreamWriter, ILogger> loggerFactory, CommandLineLoggingOptions commandLineLoggingOptions, bool killChildProcess, CancellationToken cancellationToken);
    public abstract virtual RunningProcessResult StartCommandLine(CommandLineParameters commandLineParameters, bool killChildProcess, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Client.IDockerClient {
    public abstract virtual Task`1<bool> BuildImageAsync(string dockerfilePath, string buildContext, string tag, string stage, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> BuildImageAsync(ContainerImageBuildContext context, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> RunContainerAsync(ContainerRunContext context, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetContainerIdAsync(string containerName, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetContainerIdAsync(IDictionary`2<string, string> labels, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetContainerIdsAsync(IDictionary`2<string, string> labels, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetAllContainerNamesAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<ContainerState> GetContainerStateAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> StartContainerAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> UnpauseContainerAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> RemoveContainerAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> ExecAsync(bool interactive, bool detach, string containerId, string command, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> ExecAsync(bool interactive, bool detach, string containerId, string command, IReadOnlyDictionary`2<string, string> environmentVariables, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> ExecAsync(bool interactive, bool detach, string containerId, string command, IReadOnlyDictionary`2<string, string> environmentVariables, string workingDirectory, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, bool throwOnError, CancellationToken cancellationToken);
    public abstract virtual RunningCommandLineResult StartExecInteractive(string containerId, string command, IReadOnlyDictionary`2<string, string> environmentVariables, string workingDirectory, Func`2<StreamWriter, ILogger> loggerFactory, bool killChildProcess, CancellationToken cancellationToken);
    public abstract virtual RunningProcessResult StartExec(string containerId, string command, IReadOnlyDictionary`2<string, string> environmentVariables, string workingDirectory, bool killChildProcess, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> KillAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<String[]> GetIPAddressesAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<ContainerIPAddress>> GetIPAddressInfoAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> RemoveDanglingImagesAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<ContainerPortMapping>> GetPortMappingsAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<Int32[]> GetHostPortsAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<Int32[]> GetExposedPortsAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetServerOperatingSystemAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> PullWithConsoleAsync(IEnumerable`1<string> imageNames, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> SwitchDockerOperatingSystemAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> PullAsync(string image, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> CheckIfImageExistsAsync(string image, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetExistingImagesAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetImageIdAsync(string imageName, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsContainerRunningAsync(string containerId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<CommandLineResult> LoginAsync(string serverName, string userName, string password, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> TagAsync(string sourceImageName, string targetImageName, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> PushAsync(string imageName, IReadOnlyDictionary`2<string, string> additionalEnvironmentVariables, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<DockerVersionInfo> GetDockerVersionInfoAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetDockerVersionAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetDockerComposeVersionAsync(ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> DirectoryOrFileExistsInContainerAsync(string containerId, string path, OperatingSystemName targetOS, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImageDetails> GetImageDetails(string imageId, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.ImageDetails : object {
    [CompilerGeneratedAttribute]
private Config <config>k__BackingField;
    [JsonPropertyAttribute("Config")]
public Config config { get; public set; }
    [CompilerGeneratedAttribute]
public Config get_config();
    [CompilerGeneratedAttribute]
public void set_config(Config value);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.PortsConverter : JsonConverter`1<IEnumerable`1<int>> {
    public virtual IEnumerable`1<int> ReadJson(JsonReader reader, Type objectType, IEnumerable`1<int> existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, IEnumerable`1<int> value, JsonSerializer serializer);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.RunningCommandLineResult : object {
    [CompilerGeneratedAttribute]
private CommandLineParameters <CommandLineParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<int> <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<IReadOnlyList`1<string>> <StandardOutputLines>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<IReadOnlyList`1<string>> <StandardErrorLines>k__BackingField;
    public CommandLineParameters CommandLineParameters { get; }
    public Task`1<int> ExitCode { get; }
    public Task`1<IReadOnlyList`1<string>> StandardOutputLines { get; }
    public Task`1<IReadOnlyList`1<string>> StandardErrorLines { get; }
    public RunningCommandLineResult(CommandLineParameters commandLineParameters, Task`1<int> exitCode, Task`1<IReadOnlyList`1<string>> standardOutputLines, Task`1<IReadOnlyList`1<string>> standardErrorLines);
    [CompilerGeneratedAttribute]
public CommandLineParameters get_CommandLineParameters();
    [CompilerGeneratedAttribute]
public Task`1<int> get_ExitCode();
    [CompilerGeneratedAttribute]
public Task`1<IReadOnlyList`1<string>> get_StandardOutputLines();
    [CompilerGeneratedAttribute]
public Task`1<IReadOnlyList`1<string>> get_StandardErrorLines();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Client.RunningCommandLineResult/<GetResultAsync>d__13")]
public Task`1<CommandLineResult> GetResultAsync();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.RunningProcessResult : object {
    [CompilerGeneratedAttribute]
private CommandLineParameters <CommandLineParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Process <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<int> <ExitCode>k__BackingField;
    public CommandLineParameters CommandLineParameters { get; }
    public Process Process { get; }
    public Task`1<int> ExitCode { get; }
    public RunningProcessResult(CommandLineParameters commandLineParameters, Process process, Task`1<int> exitCode);
    [CompilerGeneratedAttribute]
public CommandLineParameters get_CommandLineParameters();
    [CompilerGeneratedAttribute]
public Process get_Process();
    [CompilerGeneratedAttribute]
public Task`1<int> get_ExitCode();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Client.VolumeMapping : object {
    [CompilerGeneratedAttribute]
private string <SourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReadOnly>k__BackingField;
    public string SourcePath { get; }
    public string TargetPath { get; }
    public Nullable`1<bool> ReadOnly { get; }
    public VolumeMapping(string sourcePath, string targetPath);
    [JsonConstructorAttribute]
public VolumeMapping(string sourcePath, string targetPath, Nullable`1<bool> readOnly);
    [CompilerGeneratedAttribute]
public string get_SourcePath();
    [CompilerGeneratedAttribute]
public string get_TargetPath();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReadOnly();
    public string ToVolumeMappingString();
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.CollectionExtensions : object {
    [ExtensionAttribute]
public static bool AddRange(ISet`1<T> set, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void AddRange(IDictionary`2<TKey, TValue> target, IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, bool forceUpdate);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> Merge(IDictionary`2<TKey, TValue> dict1, IEnumerable`1<KeyValuePair`2<TKey, TValue>> dict2);
    [ExtensionAttribute]
public static void AddToList(IDictionary`2<TKey, TCollection> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static IEnumerable`1<T> EmptyIfNull(IEnumerable`1<T> enumeration);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.CollectionExtensions/<AllAsync>d__6`1")]
[ExtensionAttribute]
public static Task`1<bool> AllAsync(IEnumerable`1<T> collection, Func`2<T, Task`1<bool>> predicate);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.CollectionExtensions/<AnyAsync>d__7`1")]
[ExtensionAttribute]
public static Task`1<bool> AnyAsync(IEnumerable`1<T> collection, Func`2<T, Task`1<bool>> predicate);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.CollectionExtensions/<FirstAsync>d__8`1")]
[ExtensionAttribute]
public static Task`1<T> FirstAsync(IEnumerable`1<T> collection, Func`2<T, Task`1<bool>> predicate);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.CollectionExtensions/<FirstOrDefaultAsync>d__9`1")]
[ExtensionAttribute]
public static Task`1<T> FirstOrDefaultAsync(IEnumerable`1<T> collection, Func`2<T, Task`1<bool>> predicate);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.CollectionExtensions/<WhereAsync>d__10`1")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<T>> WhereAsync(IEnumerable`1<T> collection, Func`2<T, Task`1<bool>> predicate);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.CollectionExtensions/<ToListAsync>d__12`1")]
[ExtensionAttribute]
public static Task`1<List`1<T>> ToListAsync(IAsyncEnumerable`1<T> source, CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.CommandLineInfo : object {
    [CompilerGeneratedAttribute]
private string <Program>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TelemetrySafeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorOutput>k__BackingField;
    public string Program { get; public set; }
    public string Arguments { get; public set; }
    public string TelemetrySafeArguments { get; public set; }
    public Nullable`1<int> ExitCode { get; public set; }
    public string StandardOutput { get; public set; }
    public string ErrorOutput { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Program();
    [CompilerGeneratedAttribute]
public void set_Program(string value);
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public string get_TelemetrySafeArguments();
    [CompilerGeneratedAttribute]
public void set_TelemetrySafeArguments(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ExitCode();
    [CompilerGeneratedAttribute]
public void set_ExitCode(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_StandardOutput();
    [CompilerGeneratedAttribute]
public void set_StandardOutput(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorOutput();
    [CompilerGeneratedAttribute]
public void set_ErrorOutput(string value);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.Constants : object {
}
public enum Microsoft.VisualStudio.Containers.Tools.Common.ContainerCreationResult : Enum {
    public int value__;
    public static ContainerCreationResult Unknown;
    public static ContainerCreationResult Skipped;
    public static ContainerCreationResult NoConflict;
    public static ContainerCreationResult Conflict;
}
public enum Microsoft.VisualStudio.Containers.Tools.Common.ContainerDevelopmentMode : Enum {
    public int value__;
    public static ContainerDevelopmentMode Regular;
    public static ContainerDevelopmentMode Fast;
}
public enum Microsoft.VisualStudio.Containers.Tools.Common.ContainerErrorSeverity : Enum {
    public int value__;
    public static ContainerErrorSeverity Error;
    public static ContainerErrorSeverity Info;
    public static ContainerErrorSeverity Warning;
    public static ContainerErrorSeverity Critical;
}
public class Microsoft.VisualStudio.Containers.Tools.Common.ContainerIdComparer : EqualityComparer`1<string> {
    private static int MaxLengthComparison;
    public static ContainerIdComparer Default;
    private static ContainerIdComparer();
    public virtual bool Equals(string id1, string id2);
    public virtual int GetHashCode(string id);
}
[AttributeUsageAttribute("1")]
public class Microsoft.VisualStudio.Containers.Tools.Common.ContainerMetadataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Name { get; public set; }
    public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.VisualStudio.Containers.Tools.Common.ContainerNuGetVolumeMappingsCollection : object {
    private static string FallbackPathWindows;
    private static string FallbackPathLinux;
    private static string UserPackagesPathWindows;
    private static string UserPackagesPathLinux;
    private IReadOnlyDictionary`2<string, string> hostToContainerVolumeMapping;
    [CompilerGeneratedAttribute]
private string <UserPackageFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerPathsToFallbackPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalProbingPaths>k__BackingField;
    public string UserPackageFolder { get; }
    public string ContainerPathsToFallbackPackages { get; }
    public string AdditionalProbingPaths { get; }
    public string Item { get; }
    public IEnumerable`1<string> HostPaths { get; }
    public IEnumerable`1<string> ContainerPaths { get; }
    public IEnumerable`1<string> Keys { get; }
    public IEnumerable`1<string> Values { get; }
    public int Count { get; }
    public ContainerNuGetVolumeMappingsCollection(OperatingSystemName targetOS, string userPackageFolder, string fallbackFolders);
    [CompilerGeneratedAttribute]
public string get_UserPackageFolder();
    [CompilerGeneratedAttribute]
public string get_ContainerPathsToFallbackPackages();
    [CompilerGeneratedAttribute]
public string get_AdditionalProbingPaths();
    public sealed virtual string get_Item(string key);
    public IEnumerable`1<string> get_HostPaths();
    public IEnumerable`1<string> get_ContainerPaths();
    public sealed virtual IEnumerable`1<string> get_Keys();
    public sealed virtual IEnumerable`1<string> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    public sealed virtual bool TryGetValue(string key, String& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static void CreateNuGetVolumeMapping(OperatingSystemName targetOS, string userPackageFolder, string fallbackFolders, IReadOnlyDictionary`2& hostToContainerMapping, String& containerPaths);
    private string BuildAdditionalProbingPaths();
}
public enum Microsoft.VisualStudio.Containers.Tools.Common.ContainerOperatingSystemFlavor : Enum {
    public int value__;
    public static ContainerOperatingSystemFlavor Unknown;
    public static ContainerOperatingSystemFlavor DebianStretch;
    public static ContainerOperatingSystemFlavor DebianBuster;
    public static ContainerOperatingSystemFlavor Alpine;
    public static ContainerOperatingSystemFlavor UbuntuBionic;
    public static ContainerOperatingSystemFlavor NanoServer;
    public static ContainerOperatingSystemFlavor ServerCore;
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.ContainerOperatingSystemFlavorUtilities : object {
    private static string DebianStretchHint;
    private static string DebianBusterHint;
    private static string AlpineHint;
    private static string UbuntuBionicHint;
    private static string NanoServerHint;
    private static string ServerCoreHint;
    public static bool TryGetFlavor(string imageName, ContainerOperatingSystemFlavor& flavor);
}
public enum Microsoft.VisualStudio.Containers.Tools.Common.ContainerState : Enum {
    public int value__;
    public static ContainerState Unknown;
    public static ContainerState Created;
    public static ContainerState Restarting;
    public static ContainerState Removing;
    public static ContainerState Running;
    public static ContainerState Paused;
    public static ContainerState Exited;
    public static ContainerState Dead;
}
public class Microsoft.VisualStudio.Containers.Tools.Common.ContainerToolsException : Exception {
    private static String[] WellKnownFiles;
    private static String[] WellKnownExtensions;
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private ContainerErrorSeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultingUserFileInfo <FaultingUserFile>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandLineInfo <CommandLine>k__BackingField;
    public string ErrorCode { get; public set; }
    public ContainerErrorSeverity Severity { get; public set; }
    public FaultingUserFileInfo FaultingUserFile { get; public set; }
    public CommandLineInfo CommandLine { get; public set; }
    [ObsoleteAttribute("Use constructor with error code instead. Suppress if absolutely necessary.")]
public ContainerToolsException(string message);
    [ObsoleteAttribute("Use constructor with error code instead. Suppress if absolutely necessary.")]
public ContainerToolsException(string message, Exception innerException);
    public ContainerToolsException(string errorCode, string message, Exception innerException);
    protected ContainerToolsException(SerializationInfo info, StreamingContext context);
    private static ContainerToolsException();
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(string value);
    [CompilerGeneratedAttribute]
public ContainerErrorSeverity get_Severity();
    [CompilerGeneratedAttribute]
public void set_Severity(ContainerErrorSeverity value);
    [CompilerGeneratedAttribute]
public FaultingUserFileInfo get_FaultingUserFile();
    [CompilerGeneratedAttribute]
public void set_FaultingUserFile(FaultingUserFileInfo value);
    [CompilerGeneratedAttribute]
public CommandLineInfo get_CommandLine();
    [CompilerGeneratedAttribute]
public void set_CommandLine(CommandLineInfo value);
    public static bool TryWrap(Exception innerException, ContainerToolsException& result);
    public virtual string ToString();
    public void SetTelemetryProperties(Dictionary`2<string, string> props);
    private string GetTelemetryFaultingUserFile();
    private static void AppendLine(StringBuilder sb, string format, Object[] args);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.ContainerToolsExceptionExtensions : object {
    private static Regex ContainerNameConflict;
    private static ContainerToolsExceptionExtensions();
    [ExtensionAttribute]
public static bool IsContainerNameConflictException(ContainerToolsException ex);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.DaemonUtilities : object {
    private static AsyncLocal`1<bool> UseWslTestInstance;
    private static Lazy`1<bool> UseWslDaemonProvider;
    private static AsyncLocal`1<bool> SupportsWindowsTestInstance;
    private static Lazy`1<bool> SupportsWindowsProvider;
    public static bool UseWslDaemon { get; internal set; }
    public static bool SupportsWindows { get; internal set; }
    private static DaemonUtilities();
    public static bool get_UseWslDaemon();
    internal static void set_UseWslDaemon(bool value);
    public static bool get_SupportsWindows();
    internal static void set_SupportsWindows(bool value);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.Debugging.BlazorUtilities : object {
    public static Task ContainerizeBlazorStaticWebAssetsManifestAsync(string manifestFilePath, string manifestDestinationFilePath, IReadOnlyList`1<VolumeMapping> volumeMappings, OperatingSystemName targetOS);
    public static Task ContainerizeBlazorStaticWebAssetsManifestAsync(string manifestFilePath, string manifestDestinationFilePath, PathUpdater pathUpdater);
    public static Task ContainerizeJsonBlazorStaticWebAssetsManifestAsync(string manifestFilePath, string manifestDestinationFilePath, IReadOnlyList`1<VolumeMapping> volumeMappings, OperatingSystemName targetOS);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Debugging.BlazorUtilities/<ContainerizeJsonBlazorStaticWebAssetsManifestAsync>d__3")]
public static Task ContainerizeJsonBlazorStaticWebAssetsManifestAsync(string manifestFilePath, string manifestDestinationFilePath, PathUpdater pathUpdater);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.Debugging.HotReloadProxyUtilities : object {
    private static string FallbackVersionFolder;
    [ObsoleteAttribute("Use the version from the MappedTools folder instead")]
public static string GetHotReloadProxyFromVsPath(string devEnvFolder, OperatingSystemName operatingSystemName, Version netCoreVersion);
    public static string GetHotReloadProxy(string baseHotReloadProxyFolder, OperatingSystemName operatingSystemName, Version netCoreVersion);
    public static string GetHotReloadProxy(string baseHotReloadProxyFolder, OperatingSystemName operatingSystemName, Architecture architecture, Version netCoreVersion, bool useBackCompatRuntime);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.Debugging.IISUtilities : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Debugging.IISUtilities/<WaitForDebugResponseAsync>d__0")]
public static Task WaitForDebugResponseAsync(Uri endpoint, ILogger logger, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Debugging.IOneCoreMsVsMonHelper {
    public abstract virtual MsVsMonPathResolutionResult ResolveOneCoreMsVsMonPath(string sourceDirectory, bool ensureBitsPresent);
    public abstract virtual MsVsMonPathResolutionResult ResolveOneCoreMsVsMonPath(string sourceDirectory, string utilsDirectory, bool ensureBitsPresent);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Debugging.IVsDbgHelper {
    public abstract virtual Task`1<string> EnsureLatestVsDbgAsync(VsDbgOptions options, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.Debugging.MappedToolsUtilities : object {
    private static string FallbackVersionFolder;
    public static string GetToolsFromVsPath(string devEnvFolder, OperatingSystemName operatingSystemName, Version netCoreVersion);
    public static string GetTools(string baseToolsFolder, OperatingSystemName operatingSystemName, Version netCoreVersion);
    public static string GetTools(string baseToolsFolder, OperatingSystemName operatingSystemName, Architecture architecture, Version netCoreVersion);
    public static string GetTools(string baseToolsFolder, string runtimeId, Version netCoreVersion);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Debugging.MsVsMonPathResolutionResult : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Warnings>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Errors>k__BackingField;
    public string Path { get; public set; }
    public IList`1<string> Warnings { get; }
    public IList`1<string> Errors { get; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Warnings();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Errors();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Debugging.OneCoreMsVsMonHelper : Singleton`2<IOneCoreMsVsMonHelper, OneCoreMsVsMonHelper> {
    private static string Architecture;
    private static string CoreClrFolderName;
    private static string LibFolderName;
    private static string TargetFolderName;
    private static string UtilsFolderName;
    public sealed virtual MsVsMonPathResolutionResult ResolveOneCoreMsVsMonPath(string sourceDirectory, bool ensureBitsPresent);
    public sealed virtual MsVsMonPathResolutionResult ResolveOneCoreMsVsMonPath(string sourceDirectory, string utilsDirectory, bool ensureBitsPresent);
    private static string AppendMsVsMonVersionNumber(string oneCoreMsVsMonPath, string sourceDirectory);
    private static void CopyDebuggerFiles(DebuggerFilePaths debuggerFilePaths, MsVsMonPathResolutionResult result);
    private static void CopyUtils(DebuggerFilePaths debuggerFilePaths, MsVsMonPathResolutionResult result);
    private static bool ShouldCopyDebuggerFiles(DebuggerFilePaths debuggerFilePaths);
    private static bool ShouldCopyUtils(DebuggerFilePaths debuggerFilePaths);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Debugging.PathUpdater : MulticastDelegate {
    public PathUpdater(object object, IntPtr method);
    public virtual bool Invoke(string hostPath, String& targetPath);
    public virtual IAsyncResult BeginInvoke(string hostPath, String& targetPath, AsyncCallback callback, object object);
    public virtual bool EndInvoke(String& targetPath, IAsyncResult result);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.Debugging.PathUpdaters : object {
    public static PathUpdater CreateForVolumes(IReadOnlyList`1<VolumeMapping> volumeMappings, OperatingSystemName targetOS);
}
[ObsoleteAttribute("Use the version from the MappedTools folder instead")]
public static class Microsoft.VisualStudio.Containers.Tools.Common.Debugging.TokenProxyUtilities : object {
    private static string FallbackVersionFolder;
    public static string GetTokenProxyFromVsPath(string devEnvFolder, OperatingSystemName operatingSystemName, Version netCoreVersion);
    public static string GetTokenProxy(string baseTokenProxyFolder, OperatingSystemName operatingSystemName, Version netCoreVersion);
    public static string GetTokenProxy(string baseTokenProxyFolder, OperatingSystemName operatingSystemName, Architecture architecture, Version netCoreVersion);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Debugging.VsDbgHelper : Singleton`2<IVsDbgHelper, VsDbgHelper> {
    private static string RuntimeVersion;
    private static string DefaultRuntime;
    private static String[] X64RuntimeIds;
    private static String[] Arm64RuntimeIds;
    private static string VsDbgBaseDirectory;
    private static string GetVsDbgScriptPath;
    private static Uri GetVsDbgScriptUrl;
    private static string ScriptCommand;
    public static string SmartRunVsDbgScript;
    public static string SmartX64RunVsDbgScript;
    public static string SmartX64Arm64RunVsDbgScript;
    public static string SimpleRunVsDbgScript;
    private ILoggingService loggingService;
    private static VsDbgHelper();
    [ImportingConstructorAttribute]
public VsDbgHelper(ILoggingService loggingService);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Debugging.VsDbgHelper/<EnsureLatestVsDbgAsync>d__16")]
public sealed virtual Task`1<string> EnsureLatestVsDbgAsync(VsDbgOptions options, ILogger logger, CommandLineLoggingOptions commandLineLoggingOptions, CancellationToken cancellationToken);
    private static bool ShouldDownloadVsDbg(IList`1<string> runtimeIds);
    private static string GetPathForRuntime(string runtimeId);
    public static string GetSimpleRunScriptForRuntime(string runtimeId);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Debugging.VsDbgOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnsureBitsPresent>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncludeArm64Bits>k__BackingField;
    public Nullable`1<bool> EnsureBitsPresent { get; public set; }
    public Nullable`1<bool> IncludeArm64Bits { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnsureBitsPresent();
    [CompilerGeneratedAttribute]
public void set_EnsureBitsPresent(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncludeArm64Bits();
    [CompilerGeneratedAttribute]
public void set_IncludeArm64Bits(Nullable`1<bool> value);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Dockerfile.FromStatement : object {
    [CompilerGeneratedAttribute]
private string <ImageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StageName>k__BackingField;
    public string ImageName { get; public set; }
    public string Platform { get; public set; }
    public string StageName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ImageName();
    [CompilerGeneratedAttribute]
public void set_ImageName(string value);
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public void set_Platform(string value);
    [CompilerGeneratedAttribute]
public string get_StageName();
    [CompilerGeneratedAttribute]
public void set_StageName(string value);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.Dockerfile.Tokens : object {
    public static string As;
    public static string Comment;
    public static string From;
    public static string Arg;
    public static string Platform;
}
public class Microsoft.VisualStudio.Containers.Tools.Common.DockerfileParser : object {
    private String[] lines;
    public DockerfileParser(string dockerfilePath);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.DockerfileParser/<GetImageNames>d__2")]
public IEnumerable`1<string> GetImageNames();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.DockerfileParser/<GetTargetNames>d__3")]
public IEnumerable`1<string> GetTargetNames();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.DockerfileParser/<GetArgs>d__4")]
public IEnumerable`1<string> GetArgs();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.DockerfileParser/<GetFromStatements>d__5")]
public IEnumerable`1<FromStatement> GetFromStatements();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.DockerfileParser/<GetLinesByToken>d__6")]
private IEnumerable`1<String[]> GetLinesByToken(string token);
    private static String[] ReadDockerfile(string dockerfilePath);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.DockerProfileSettings : object {
    private static string HttpPortProperty;
    private static string SslPortProperty;
    private static string UseSslProperty;
    private static string PublishAllPortsProperty;
    private static string EnvironmentVariablesProperty;
    private static string CommandNameProperty;
    private static string ProfilesProperty;
    private static string DefaultLaunchSettingsPath;
    private Lazy`1<int> containerHttpPort;
    private Lazy`1<int> containerSslPort;
    private static string DockerProfileJsonPath;
    [CompilerGeneratedAttribute]
private string <CommandName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HttpPort>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SslPort>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PublishAllPorts>k__BackingField;
    [JsonPropertyAttribute("useSSL")]
private Nullable`1<bool> useSsl;
    [CompilerGeneratedAttribute]
private string <DockerfileRunArguments>k__BackingField;
    [JsonPropertyAttribute("commandName")]
public string CommandName { get; public set; }
    [JsonPropertyAttribute("httpPort")]
public int HttpPort { get; public set; }
    [JsonPropertyAttribute("sslPort")]
public int SslPort { get; public set; }
    [JsonPropertyAttribute("environmentVariables")]
public IDictionary`2<string, string> EnvironmentVariables { get; private set; }
    [JsonPropertyAttribute("publishAllPorts")]
public Nullable`1<bool> PublishAllPorts { get; public set; }
    [JsonPropertyAttribute("DockerfileRunArguments")]
public string DockerfileRunArguments { get; public set; }
    [JsonIgnoreAttribute]
public bool UseSsl { get; }
    [JsonIgnoreAttribute]
public int ContainerHttpPort { get; }
    [JsonIgnoreAttribute]
public int ContainerSslPort { get; }
    private static DockerProfileSettings();
    [CompilerGeneratedAttribute]
public string get_CommandName();
    [CompilerGeneratedAttribute]
public void set_CommandName(string value);
    [CompilerGeneratedAttribute]
public int get_HttpPort();
    [CompilerGeneratedAttribute]
public void set_HttpPort(int value);
    [CompilerGeneratedAttribute]
public int get_SslPort();
    [CompilerGeneratedAttribute]
public void set_SslPort(int value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
private void set_EnvironmentVariables(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PublishAllPorts();
    [CompilerGeneratedAttribute]
public void set_PublishAllPorts(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_DockerfileRunArguments();
    [CompilerGeneratedAttribute]
public void set_DockerfileRunArguments(string value);
    public bool get_UseSsl();
    public int get_ContainerHttpPort();
    public int get_ContainerSslPort();
    public static DockerProfileSettings GetProfileSettingsForAspNetCore(string projectDirectory, bool iisOnly, bool canDoRandomPorts, string activeProfileName);
    public static DockerProfileSettings SafeGetProfileSettings(string projectDirectory, string activeProfileName);
    public static IEnumerable`1<DockerProfileSettings> SafeGetAllProfileSettings(string projectDirectory);
    public static DockerProfileSettings CreateNewDockerProfileSettingsForAspNetCore(string projectDirectory);
    public static DockerProfileSettings CreateNewDockerProfileSettings();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.DockerProfileSettings/<ResolveDynamicHostPortsIfNecessaryAsync>d__48")]
public Task ResolveDynamicHostPortsIfNecessaryAsync(string containerId, CancellationToken cancellationToken);
    public Dictionary`2<string, object> ToSettingsDictionary();
    public Dictionary`2<int, int> ToPortMappings();
    private bool TryGetContainerPortFromEnvironmentVariable(string urlScheme, Int32& port);
    [CompilerGeneratedAttribute]
private int <.ctor>b__42_0();
    [CompilerGeneratedAttribute]
private int <.ctor>b__42_1();
    [CompilerGeneratedAttribute]
private bool <ResolveDynamicHostPortsIfNecessaryAsync>b__48_0(ContainerPortMapping m);
    [CompilerGeneratedAttribute]
private bool <ResolveDynamicHostPortsIfNecessaryAsync>b__48_1(ContainerPortMapping m);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.DotNetRuntimeUtilities : object {
    public static string GetRuntimeID(OperatingSystemName operatingSystemName);
    public static string GetRuntimeID(OperatingSystemName operatingSystemName, Architecture architecture);
    public static string GetRuntimeID(OperatingSystemName operatingSystemName, Architecture architecture, bool isAlpine);
    public static string GetRuntimeIDBackCompat(OperatingSystemName operatingSystemName);
    public static string GetRuntimeIDBackCompat(OperatingSystemName operatingSystemName, Architecture architecture);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.DotNetRuntimeUtilities/<GetRuntimeIDOfContainerAsync>d__5")]
public static Task`1<string> GetRuntimeIDOfContainerAsync(string containerId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.DotNetRuntimeUtilities/<GetRuntimeIDOfContainerWithFallbackAsync>d__6")]
public static Task`1<string> GetRuntimeIDOfContainerWithFallbackAsync(string containerId, OperatingSystemName containerOS, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.DotNetRuntimeUtilities/<IsContainerAlpineFallback>d__7")]
private static Task`1<bool> IsContainerAlpineFallback(string containerId, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.EnumExtensions : object {
    [ExtensionAttribute]
public static string GetDescription(Enum value);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.ErrorCodes : object {
    public static string UnknownError;
    public static string DockerDriveNotShared;
    public static string DockerForWindowsNotInstalled;
    public static string DockerNotRunning;
    public static string UnableToGetDockerServerOS;
    public static string ProjectTargetOSDoesNotMatchDockerServerOS;
    public static string DockerRunningInErrorState;
    public static string VsDbgDownloadFailedUsingExistingCopy;
    public static string VsDbgDownloadFailedNoExistingCopy;
    public static string DriveSharingCredentialsPossiblyInvalid;
    public static string NotInDockerGroup;
    public static string PortsInUse;
    public static string MissingDockerfile;
    public static string UnsupportedProjectType;
    public static string DockerBuildFailed;
    public static string DockerRunFailed;
    public static string IncorrectBuildContext;
    public static string IncorrectSolutionStructure;
    public static string DockerfileParsingError;
    public static string VolumeMappingError;
    public static string UnauthorizedAccessError;
    public static string SecurityError;
    public static string InvalidPathError;
    public static string FileOrDirectoryNotFoundError;
    public static string IOException;
    public static string DockerPullFailed;
    public static string LaunchSettingsParsingError;
    public static string DevCertsFailed;
    public static string InvalidLaunchUrl;
    public static string DockerExecFailed;
    public static string InternalError;
    public static string UnsupportedOS;
    public static string HyperVFeatureFailed;
    public static string ContainersFeatureFailed;
    public static string UnrecognizedWindowsFeature;
    public static string DockerDesktopMSIDownloadFailed;
    public static string DockerDesktopInstallationFailed;
    public static string ContainerizingBlazorManifestFailed;
    public static string ContainerNotRunningError;
    public static string BinariesAtUnexpectedLocation;
    public static string DebuggedProgramExitedWithUnexpectedExitCode;
    public static string DockerForWindowsInstallationIncomplete;
    public static string ReferenceOutSideBuildContext;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.ExceptionExtensions : object {
    [ExtensionAttribute]
public static string GetDisplayMessage(Exception ex);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.FaultingUserFileInfo : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LineStart>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ColumnStart>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LineEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ColumnEnd>k__BackingField;
    public string FilePath { get; public set; }
    public Nullable`1<int> LineStart { get; public set; }
    public Nullable`1<int> ColumnStart { get; public set; }
    public Nullable`1<int> LineEnd { get; public set; }
    public Nullable`1<int> ColumnEnd { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LineStart();
    [CompilerGeneratedAttribute]
public void set_LineStart(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ColumnStart();
    [CompilerGeneratedAttribute]
public void set_ColumnStart(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LineEnd();
    [CompilerGeneratedAttribute]
public void set_LineEnd(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ColumnEnd();
    [CompilerGeneratedAttribute]
public void set_ColumnEnd(Nullable`1<int> value);
    public static FaultingUserFileInfo TryFindLocationInFileByString(string canaryString, string filePath);
    public static FaultingUserFileInfo TryFindLocationInFileByJsonPath(string canaryJsonPath, string filePath);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.FileSystem : Singleton`2<IFileSystem, FileSystem> {
    public sealed virtual string CreateUniqueTempDirectory();
    public sealed virtual string CreateUniqueDirectory(string parentDirectory);
    public sealed virtual DirectoryInfo DirectoryCreateDirectory(string path);
    public sealed virtual void DirectoryDelete(string path, bool recursive);
    public sealed virtual IEnumerable`1<string> DirectoryEnumerateFiles(string path, string searchPattern);
    public sealed virtual IEnumerable`1<string> DirectoryEnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> DirectoryEnumerateFileSystemEntries(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual String[] DirectoryGetDirectories(string path);
    public sealed virtual String[] DirectoryGetDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual string DirectoryGetDirectoryRoot(string path);
    public sealed virtual String[] DirectoryGetFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual DirectoryInfo DirectoryGetParent(string path);
    public sealed virtual void FileAppendAllText(string path, string contents);
    public sealed virtual void FileCopy(string sourcePath, string destPath, bool overwrite);
    public sealed virtual Stream FileCreate(string path);
    public sealed virtual void FileCreateEmpty(string path);
    public sealed virtual void FileDelete(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual DateTime FileGetLastWriteTimeUtc(string path);
    public sealed virtual long FileGetLength(string path);
    public sealed virtual void FileMove(string sourceFileName, string destFileName);
    public sealed virtual Stream FileOpen(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual Byte[] FileReadAllBytes(string path);
    public sealed virtual string FileReadAllText(string path);
    public sealed virtual String[] FileReadAllLines(string path);
    public sealed virtual IEnumerable`1<string> FileReadLines(string path);
    public sealed virtual void FileSetAttributes(string path, FileAttributes attributes);
    public sealed virtual void FileWriteAllLines(string path, String[] contents);
    public sealed virtual void FileWriteAllText(string path, string contents);
    public sealed virtual string PathGetTempFileName();
    public sealed virtual void FileSetLastWriteTime(string path, DateTime lastWriteTime);
    public sealed virtual string GetCaseSensitiveFullPath(string path);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.FileSystemExtensions : object {
    [ExtensionAttribute]
public static void DirectoryCopy(IFileSystem fileSystem, string sourceDirectory, string destinationDirectory, bool overwrite);
    [ExtensionAttribute]
public static bool DirectoryCopyEx(IFileSystem fileSystem, string sourceDirectory, string destinationDirectory, bool overwrite, String[] excludedDirectories);
    [ExtensionAttribute]
public static string GetProductVersion(IFileSystem fileSystem, string filePath);
    [ExtensionAttribute]
public static string GetUniqueFileName(IFileSystem fileSystem, string proposedFilePath);
    [ExtensionAttribute]
public static void SafeDirectoryDelete(IFileSystem fileSystem, string directoryPath, bool recursive);
    [ExtensionAttribute]
public static void SafeFileDelete(IFileSystem fileSystem, string filePath);
    [ExtensionAttribute]
public static String[] SafeFileReadAllLines(IFileSystem fileSystem, string filePath);
    [ExtensionAttribute]
public static bool IsFileLocked(IFileSystem fileSystem, string filePath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.FileSystemExtensions/<FileDeleteWithRetryAsync>d__8")]
[ExtensionAttribute]
public static Task`1<bool> FileDeleteWithRetryAsync(IFileSystem fileSystem, string filePath, TimeSpan maxWaitTime, TimeSpan delayBetweenAttempts);
    [ExtensionAttribute]
public static Task WaitForFileDeleteAsync(IFileSystem fileSystem, string filePath, ILogger logger, string waitForFileDeleteMessage, CancellationToken cancellationToken);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.HashCode : object {
    public static int Combine(int h1, int h2);
    public static int Combine(int h1, int h2, int h3);
    public static int Combine(int h1, int h2, int h3, int h4);
    public static int Combine(int h1, int h2, int h3, int h4, int h5);
    public static int Combine(int h1, int h2, int h3, int h4, int h5, int h6);
    public static int Combine(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    public static int Combine(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.HashUtilities : object {
    public static string GetBase64EncodedSHA256HashCode(string strToHash);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.IFileSystem {
    public abstract virtual string CreateUniqueTempDirectory();
    public abstract virtual string CreateUniqueDirectory(string parentDirectory);
    public abstract virtual DirectoryInfo DirectoryCreateDirectory(string path);
    public abstract virtual IEnumerable`1<string> DirectoryEnumerateFiles(string path, string searchPattern);
    public abstract virtual IEnumerable`1<string> DirectoryEnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> DirectoryEnumerateFileSystemEntries(string path);
    public abstract virtual void DirectoryDelete(string path, bool recursive);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual String[] DirectoryGetDirectories(string path);
    public abstract virtual String[] DirectoryGetDirectories(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual string DirectoryGetDirectoryRoot(string path);
    public abstract virtual String[] DirectoryGetFiles(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual DirectoryInfo DirectoryGetParent(string path);
    public abstract virtual void FileAppendAllText(string path, string contents);
    public abstract virtual void FileCopy(string sourcePath, string destPath, bool overwrite);
    public abstract virtual Stream FileCreate(string path);
    public abstract virtual void FileCreateEmpty(string path);
    public abstract virtual void FileDelete(string path);
    public abstract virtual bool FileExists(string path);
    public abstract virtual DateTime FileGetLastWriteTimeUtc(string path);
    public abstract virtual long FileGetLength(string path);
    public abstract virtual void FileMove(string sourceFileName, string destFileName);
    public abstract virtual Stream FileOpen(string path, FileMode mode, FileAccess access, FileShare share);
    public abstract virtual Byte[] FileReadAllBytes(string path);
    public abstract virtual string FileReadAllText(string path);
    public abstract virtual String[] FileReadAllLines(string path);
    public abstract virtual IEnumerable`1<string> FileReadLines(string path);
    public abstract virtual void FileSetAttributes(string path, FileAttributes attributes);
    public abstract virtual void FileWriteAllLines(string path, String[] contents);
    public abstract virtual void FileWriteAllText(string path, string contents);
    public abstract virtual string PathGetTempFileName();
    public abstract virtual void FileSetLastWriteTime(string path, DateTime lastWriteTime);
    public abstract virtual string GetCaseSensitiveFullPath(string path);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.ImageNamesToScaffold : ValueType {
    [CompilerGeneratedAttribute]
private string <RuntimeImageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FinalRuntimeImageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SdkImageName>k__BackingField;
    public string RuntimeImageName { get; public set; }
    public string FinalRuntimeImageName { get; public set; }
    public string SdkImageName { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_RuntimeImageName();
    [CompilerGeneratedAttribute]
public void set_RuntimeImageName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FinalRuntimeImageName();
    [CompilerGeneratedAttribute]
public void set_FinalRuntimeImageName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_SdkImageName();
    [CompilerGeneratedAttribute]
public void set_SdkImageName(string value);
}
public enum Microsoft.VisualStudio.Containers.Tools.Common.ImageSku : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("DefaultImageSku", "Microsoft.VisualStudio.Containers.Tools.Common.Resources")]
public static ImageSku Default;
    [DescriptionAttribute("Windows Nano Server")]
public static ImageSku WindowsNano;
    [DescriptionAttribute("Windows Server Core")]
public static ImageSku WindowsServerCore;
    [DescriptionAttribute("Debian")]
public static ImageSku Debian;
    [DescriptionAttribute("Ubuntu")]
public static ImageSku Ubuntu;
    [DescriptionAttribute("Alpine")]
public static ImageSku Alpine;
    [DescriptionAttribute("Chiseled Ubuntu")]
public static ImageSku UbuntuChiseled;
}
public class Microsoft.VisualStudio.Containers.Tools.Common.ImageSkuInformation : object {
    [CompilerGeneratedAttribute]
private ImageSku <ImageSku>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    public ImageSku ImageSku { get; }
    public string Tag { get; }
    public ImageSkuInformation(ImageSku imageSku, string tag);
    [CompilerGeneratedAttribute]
public ImageSku get_ImageSku();
    [CompilerGeneratedAttribute]
public string get_Tag();
    public virtual string ToString();
}
public enum Microsoft.VisualStudio.Containers.Tools.Common.ImageType : Enum {
    public int value__;
    public static ImageType Runtime;
    public static ImageType FinalRuntime;
    public static ImageType Sdk;
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.ImageUtilities : object {
    private static string Registry;
    private static string RegistryMcr;
    private static string AspNetFramework;
    private static string WcfNetFramework;
    private static string DotNetFrameworkSdk;
    private static string DotNetFrameworkRuntime;
    private static string DotNetAspNetRuntime;
    private static string DotNetRuntime;
    private static string DotNetRuntimeDeps;
    private static string DotNetSdk;
    private static string AzureFunctionsRuntime;
    private static string AzureFunctionsIsolatedRuntime;
    private static string AzureFunctionsInProcessRuntime;
    private static string WinServerCore;
    private static string NanoServer;
    private static string PreviewTag;
    private static string LTSC2019;
    private static string W1809;
    private static string Alpine;
    private static string Debian;
    private static string Jammy;
    private static string Noble;
    private static string Chiseled;
    private static string Extra;
    private static bool UsePreviewFallback;
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.ImageUtilities/<GetImageNameToScaffoldAsync>d__25")]
public static Task`1<string> GetImageNameToScaffoldAsync(OperatingSystemName targetOS, TargetFramework targetFramework, ProjectType projectType, ImageType imageType, Version netCoreVersion, bool isWcfServiceProject, Version azureFunctionsVersion, ImageSku requestSpecificSku, bool invariantGlobalization);
    public static ImageSku GetImageSkuIfRequestedIsNotAllowed(ImageType imageType, ProjectType projectType, ImageSku requestedImageSku);
    public static IEnumerable`1<ImageSku> GetAllowedSkus(OperatingSystemName targetOS, ProjectType projectType, ImageType imageType, Version netCoreVersion);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.ImageUtilities/<GetAllowedSkusWithInformation>d__28")]
public static Task`1<IEnumerable`1<ImageSkuInformation>> GetAllowedSkusWithInformation(TargetFramework targetFramework, OperatingSystemName targetOS, ProjectType projectType, ImageType imageType, Version netCoreVersion, bool invariantGlobalization);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.ImageUtilities/<GetDotNetCoreImageNamesToScaffoldAsync>d__29")]
private static Task`1<string> GetDotNetCoreImageNamesToScaffoldAsync(OperatingSystemName targetOS, ProjectType projectType, ImageType imageType, Version netCoreVersion, Version azureFunctionsVersion, ImageSku requestedImageSku, bool invariantGlobalization);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.ImageUtilities/<ResolveDotNetCoreImageTag>d__30")]
private static Task`1<string> ResolveDotNetCoreImageTag(OperatingSystemName targetOS, ProjectType projectType, ImageType imageType, Version netCoreVersion, ImageSku requestedImageSku, bool invariantGlobalization);
    private static string ResolveDotNetCoreImageTag(OperatingSystemName targetOS, ProjectType projectType, ImageType imageType, Version netCoreVersion, ImageSku requestedImageSku, bool invariantGlobalization, bool shouldUsePreviewTag);
    private static string GetSkuTagPart(OperatingSystemName targetOS, ImageType imageType, bool invariantGlobalization, ImageSku requestedImageSku, Version netCoreVersion, ProjectType projectType);
    private static string GetLinuxDistro(ImageType imageType, bool invariantGlobalization, ImageSku requestedImageSku, Version netCoreVersion);
    private static string GetUbuntuTag(bool isChiseled, bool invariantGlobalization, Version netCoreVersion);
    private static string ResolveDotNetCoreImageBase(ProjectType projectType, ImageType imageType, OperatingSystemName targetOS);
    private static string GetDotNetFrameworkImageNameToScaffold(ProjectType projectType, ImageType imageType, bool isWcfServiceProject);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.ImageUtilities/<ShouldUsePreviewTagAsync>d__37")]
private static Task`1<bool> ShouldUsePreviewTagAsync(Version netCoreVersion);
    private static string GetWindowsTagPart(Version netCoreVersion, ProjectType projectType, ImageType imageType, ImageSku requestedImageSku);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.ImageUtilities/<GetAllowedWindowsSkus>d__39")]
private static IEnumerable`1<ImageSku> GetAllowedWindowsSkus(ProjectType projectType, ImageType imageType, Version netCoreVersion);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.ImageUtilities/<GetAllowedLinuxSkus>d__40")]
private static IEnumerable`1<ImageSku> GetAllowedLinuxSkus(ImageType imageType, ProjectType projectType);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.IProjectCapabilityChecker {
    public abstract virtual Task`1<bool> HasCapabilityAsync(string capabilityName);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.IRetryPolicy {
    public string FailureMessage { get; }
    public bool ThrowOnFailure { get; }
    public abstract virtual string get_FailureMessage();
    public abstract virtual bool get_ThrowOnFailure();
    public abstract virtual bool ShouldRetry(int attemptNumber, DateTime startTimeUtc, TimeSpan& delayBetweenAttempts);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.IUniqueNameSuffixStrategy {
    public abstract virtual string GetSuffix(int index);
}
public enum Microsoft.VisualStudio.Containers.Tools.Common.LaunchOperationType : Enum {
    public int value__;
    public static LaunchOperationType Debug;
    public static LaunchOperationType NoDebug;
    public static LaunchOperationType Warmup;
}
public class Microsoft.VisualStudio.Containers.Tools.Common.LaunchSettingsServerBinding : object {
    private static string DefaultLaunchSettingsPath;
    public static string IISSettings;
    public static string IISExpress;
    [CompilerGeneratedAttribute]
private string <ApplicationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SSLPort>k__BackingField;
    [JsonPropertyAttribute]
public string ApplicationUrl { get; public set; }
    [JsonPropertyAttribute]
public int SSLPort { get; public set; }
    public bool SSLEnabled { get; }
    [CompilerGeneratedAttribute]
public string get_ApplicationUrl();
    [CompilerGeneratedAttribute]
public void set_ApplicationUrl(string value);
    [CompilerGeneratedAttribute]
public int get_SSLPort();
    [CompilerGeneratedAttribute]
public void set_SSLPort(int value);
    public bool get_SSLEnabled();
    public IDictionary`2<string, int> GetPortMappings();
    public static bool TryParse(string filePath, LaunchSettingsServerBinding& launchSettingsServerBinding);
    public static LaunchSettingsServerBinding GetIISServerBinding(string jsonSettings, string jsonPath, string originalFilePath);
    public static LaunchSettingsServerBinding GetFirstServerBinding(string jsonSettings, string originalFilePath, bool preferHttps);
    public static bool HasHttpsEnabledProfile(string projectDirectory);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.LocalizedCategoryAttribute : CategoryAttribute {
    private ResourceManager resourceManager;
    public LocalizedCategoryAttribute(string categoryResourceName, Type resourceTypeClass);
    protected virtual string GetLocalizedString(string value);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.LocalizedDescriptionAttribute : DescriptionAttribute {
    private ResourceManager resourceManager;
    public string Description { get; }
    public LocalizedDescriptionAttribute(string descriptionResourceName, Type resourceTypeClass);
    public virtual string get_Description();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.LocalizedDisplayNameAttribute : DisplayNameAttribute {
    private ResourceManager resourceManager;
    public string DisplayName { get; }
    public LocalizedDisplayNameAttribute(string displayResourceName, Type resourceTypeClass);
    public virtual string get_DisplayName();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.LocalizedEnumConverter : EnumConverter {
    public LocalizedEnumConverter(Type enumType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object enumValue, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object stringValue);
    private string GetLocalizedValue(object enumValue);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Logging.IBuildLogger {
    public abstract virtual void LogBuildMessage(string message, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber);
    public abstract virtual void LogBuildWarning(string message, string warningCode, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber);
    public abstract virtual void LogBuildError(string message, string errorCode, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.Logging.IBuildLoggerExtensions : object {
    [ExtensionAttribute]
public static void Log(IBuildLogger logger, LoggerVerbosity verbosity, string message, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Logging.ILogger {
    public LoggerVerbosity Verbosity { get; public set; }
    public abstract virtual LoggerVerbosity get_Verbosity();
    public abstract virtual void set_Verbosity(LoggerVerbosity value);
    public abstract virtual void LogMessage(string message);
    public abstract virtual void LogVerbose(string message);
    public abstract virtual void LogCritical(string message);
    public abstract virtual void LogWarning(string message, string warningCode);
    public abstract virtual void LogError(string message, string errorCode);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.Logging.ILoggerExtensions : object {
    [ExtensionAttribute]
public static void Log(ILogger logger, LoggerVerbosity verbosity, string message);
    [ExtensionAttribute]
public static void Log(ILogger logger, LoggerVerbosity verbosity, string message, string code);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Logging.Logger : object {
    private IProgress`1<string> progress;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    public LoggerVerbosity Verbosity { get; public set; }
    public Logger(IProgress`1<string> progress);
    public Logger(IProgress`1<string> progress, LoggerVerbosity verbosity);
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual void LogError(string message, string errorCode);
    public sealed virtual void LogBuildError(string message, string errorCode, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber);
    public sealed virtual void LogCritical(string message);
    public sealed virtual void LogMessage(string message);
    public sealed virtual void LogBuildMessage(string message, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber);
    public sealed virtual void LogVerbose(string message);
    public sealed virtual void LogWarning(string message, string warningCode);
    public sealed virtual void LogBuildWarning(string message, string warningCode, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber);
    private void LogForBuild(string message, string code, string codeFormat, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Containers.Tools.Common.Logging.LoggerVerbosity : Enum {
    public int value__;
    public static LoggerVerbosity None;
    public static LoggerVerbosity Error;
    public static LoggerVerbosity Warning;
    public static LoggerVerbosity Critical;
    public static LoggerVerbosity Message;
    public static LoggerVerbosity Verbose;
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.Logging.LogLevel : object {
    public static LoggerVerbosity CommandLineOutput;
    public static LoggerVerbosity Quiet;
    public static LoggerVerbosity Normal;
    public static LoggerVerbosity Detailed;
    private static LogLevel();
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.LogUtilities : object {
    private static Lazy`1<Regex> RemoveAnsiEscapeSequenceRegex;
    private static LogUtilities();
    public static string SafeRemoveAnsiEscapeSequences(string message);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.NameUtilities : object {
    private static Regex ImageNameRegex;
    private static Regex AllNumbersRegex;
    private static Regex ValidContainerNameRegex;
    private static Regex DisAllowedContainerCharactersRegex;
    private static NameUtilities();
    public static string CanonicalizeImageName(string imageName);
    public static string CanonicalizeContainerName(string candidateContainerName, string defaultValueSuffix);
    public static string GetUniqueName(IEnumerable`1<string> existingNames, string suggestedName, Func`2<int, string> generateIndexSuffix, StringComparison stringComparison);
    public static string GetUniqueName(IEnumerable`1<string> existingNames, string suggestedName, Func`3<string, int, string> generateName, StringComparison stringComparison);
    private static bool IsUnique(IEnumerable`1<string> existingNames, string suggestedName, StringComparison stringComparison);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.NetworkUtilities : object {
    public static int SeekAvailablePort(int startPort, HashSet`1<int> disallowedPorts);
    public static HashSet`1<int> GetTcpPortsInUse();
    public static HashSet`1<int> GetUdpPortsInUse();
    public static HashSet`1<int> GetPortsInUse(bool tcp, bool udp);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.NetworkUtilities/<DownloadFileAsync>d__4")]
public static Task`1<bool> DownloadFileAsync(Uri url, string destinationFilePath, Func`2<Exception, bool> shouldSuppressException, ILoggingService loggingService, CancellationToken cancellationToken);
}
public enum Microsoft.VisualStudio.Containers.Tools.Common.OperatingSystemName : Enum {
    public int value__;
    public static OperatingSystemName Windows;
    public static OperatingSystemName Linux;
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.OperatingSystemUtilities : object {
    private static Version Windows10RS3MinVersion;
    private static Version Windows10RS4MinVersion;
    private static Version Windows10RS5MinVersion;
    private static Version Windows1019H1MinVersion;
    private static Version Windows1019H2MinVersion;
    private static Version Windows1020H1MinVersion;
    private static OperatingSystemUtilities();
    public static bool OperatingSystemIsArm64Mac();
    public static bool OperatingSystemIsUnix();
    public static bool OperatingSystemIsWindows10RS3OrNewer();
    public static bool OperatingSystemIsWindows10RS4OrNewer();
    public static bool OperatingSystemIsWindows10RS5OrNewer();
    public static bool OperatingSystemIsWindows1019H1OrNewer();
    public static bool OperatingSystemIsWindows1019H2OrNewer();
    public static bool OperatingSystemIsWindows1020H1OrNewer();
    public static bool OperatingSystemIsWindows10OrHigher();
    public static bool OperatingSystemIsWindowsServer();
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.PathUtilities : object {
    public static string GetRelativePath(string rootPath, bool rootPathIsFile, string absolutePath, bool absolutePathIsFile);
    private static string GetRelativePathCore(string rootDirectoryPath, string absolutePath, bool absolutePathIsFile, bool ignoreCase, char directorySeparatorChar);
    public static string GetFullPathFromRelativePath(string pathRoot, string possiblyRelativePath);
    public static string EnsureCorrectSeparatorForCurrentOS(string path);
    public static string EnsureCorrectSeparator(string path, OperatingSystemName osName);
    public static string EscapeBackslashCharacter(string path);
    public static string EnsureSlashAsSeparator(string path);
    public static string EnsureBackSlashAsSeparator(string path);
    public static string EnsureLeadingSlash(string path);
    public static string EnsureLeadingBackSlash(string path);
    public static string EnsureLeadingDot(string path);
    public static string RemoveTrailingSeparator(string path);
    public static string EnsureTrailingSeparator(string path);
    public static string EnsureTrailingSeparator(string path, OperatingSystemName osName);
    public static string EnsureTrailingChar(string path, char trailingChar);
    public static string EnsureLeadingChar(string path, char leadingChar);
    public static string RemoveLeadingChar(string path, char leadingChar);
    public static string RemoveTrailingChar(string path, char trailingChar);
    public static bool IsDirectorySeparator(char inputChar);
    public static bool IsPathWithinDirectory(string targetPath, string possiblyParentDirectory);
    public static string GetUniquePath(string suggestedPath);
    private static bool IsUniquePath(string fullPath);
    public static bool TryGetContainerPath(string hostPath, IReadOnlyList`1<VolumeMapping> volumeMappings, OperatingSystemName targetOS, String& containerPath);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.CompositePrerequisite : object {
    private IReadOnlyList`1<IPrerequisite> prerequisites;
    public CompositePrerequisite(IPrerequisite[] prerequisites);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.CompositePrerequisite/<EvaluateAsync>d__2")]
public sealed virtual Task`1<PrerequisiteEvaluationResult> EvaluateAsync(CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.DockerForWindowsDriveSharingPrerequisite : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.DockerForWindowsDriveSharingPrerequisite/<EvaluateAsync>d__0")]
public sealed virtual Task`1<PrerequisiteEvaluationResult> EvaluateAsync(CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.DockerForWindowsInstalledPrerequisite : object {
    private static string DockerExecutableName;
    private static string DockerCLIExecutableName;
    public sealed virtual Task`1<PrerequisiteEvaluationResult> EvaluateAsync(CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.DockerForWindowsRunningPrerequisite : object {
    private static string DockerPipeName;
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.DockerForWindowsRunningPrerequisite/<EvaluateAsync>d__1")]
public sealed virtual Task`1<PrerequisiteEvaluationResult> EvaluateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.DockerForWindowsRunningPrerequisite/<IsDockerFunctioningAsync>d__2")]
private static Task`1<bool> IsDockerFunctioningAsync(CancellationToken cancellationToken);
    private static bool IsUserInDockerGroup();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.DockerTargetOSCheckPrerequisite : object {
    private OperatingSystemName targetOS;
    public DockerTargetOSCheckPrerequisite(OperatingSystemName targetOS);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.DockerTargetOSCheckPrerequisite/<EvaluateAsync>d__2")]
public sealed virtual Task`1<PrerequisiteEvaluationResult> EvaluateAsync(CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.IPrerequisite {
    public abstract virtual Task`1<PrerequisiteEvaluationResult> EvaluateAsync(CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.PrerequisiteEvaluationResult : object {
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WarningMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WarningCode>k__BackingField;
    public bool HasError { get; }
    public bool HasWarning { get; }
    public string ErrorMessage { get; }
    public string ErrorCode { get; public set; }
    public string WarningMessage { get; public set; }
    public string WarningCode { get; public set; }
    public PrerequisiteEvaluationResult(string errorMessage);
    public PrerequisiteEvaluationResult(string errorMessage, string errorCode);
    public bool get_HasError();
    public bool get_HasWarning();
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(string value);
    [CompilerGeneratedAttribute]
public string get_WarningMessage();
    [CompilerGeneratedAttribute]
public void set_WarningMessage(string value);
    [CompilerGeneratedAttribute]
public string get_WarningCode();
    [CompilerGeneratedAttribute]
public void set_WarningCode(string value);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.ValidDriveSharingCredentialsPrerequisite : object {
    private static bool ValidDriveSharingCredentialsFound;
    private Func`1<string> getContainerId;
    private ILoggingService loggingService;
    private OperatingSystemName targetOS;
    public ValidDriveSharingCredentialsPrerequisite(Func`1<string> getContainerId, OperatingSystemName targetOS, ILoggingService loggingService);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Prerequisites.ValidDriveSharingCredentialsPrerequisite/<EvaluateAsync>d__5")]
public sealed virtual Task`1<PrerequisiteEvaluationResult> EvaluateAsync(CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.ProjectCapabilityChecker : object {
    private HashSet`1<string> capabilities;
    public ProjectCapabilityChecker(IEnumerable`1<string> capabilities);
    public sealed virtual Task`1<bool> HasCapabilityAsync(string capabilityName);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Containers.Tools.Common.ProjectType : Enum {
    public int value__;
    public static ProjectType Unknown;
    public static ProjectType AnyAzureFunctions;
    public static ProjectType Aot;
    public static ProjectType AspNet;
    public static ProjectType AspNetCore;
    public static ProjectType Console;
    public static ProjectType ConsoleCore;
    public static ProjectType AzureFunctionsIntegrated;
    public static ProjectType AzureFunctionsIsolated;
    public static ProjectType WorkerService;
    public static ProjectType WindowsForms;
    public static ProjectType WPF;
    public static ProjectType AspNetCoreAot;
    public static ProjectType ConsoleCoreAot;
    public static ProjectType WorkerServiceAot;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.ProjectTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsAnyAzureFunctions(ProjectType projectType);
    [ExtensionAttribute]
public static bool IsAnyAot(ProjectType projectType);
    [ExtensionAttribute]
public static bool IsAnyAspNetCore(ProjectType projectType);
    [ExtensionAttribute]
public static bool IsAnyConsoleCore(ProjectType projectType);
    [ExtensionAttribute]
public static bool IsAnyWorkerServiceCore(ProjectType projectType);
    [ExtensionAttribute]
public static bool IsAnyAzureFunctionsIntegrated(ProjectType projectType);
    [ExtensionAttribute]
public static bool IsAnyAzureFunctionsIsolated(ProjectType projectType);
    [ExtensionAttribute]
public static bool IsAspNetFullFramework(ProjectType projectType);
    [ExtensionAttribute]
public static bool IsConsoleFullFramework(ProjectType projectType);
    [ExtensionAttribute]
private static bool HasFlagFast(ProjectType projectType, ProjectType flag);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.ProjectUtilities : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.ProjectUtilities/<GetProjectTypeAsync>d__0")]
public static Task`1<ProjectType> GetProjectTypeAsync(string projectTypeGuids, string projectOutputType, bool publishAot, string functionsExecutionModel, IProjectCapabilityChecker capabilityChecker);
    private static bool ContainsWebProjectFlavorGuid(string projectTypeGuidsString);
    private static bool ContainsWPFFlavorGuid(string projectTypeGuidsString);
    public static TargetFramework GetTargetFramework(string targetFrameworkIdentifier);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Reactive.AggregateProgress`1 : object {
    private List`1<IProgress`1<T>> progresses;
    public AggregateProgress`1(IEnumerable`1<IProgress`1<T>> progresses);
    public AggregateProgress`1(IProgress`1[] progresses);
    public sealed virtual void Report(T value);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Reactive.Observable`1 : ObservableBase`1<T> {
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(T value);
}
public abstract class Microsoft.VisualStudio.Containers.Tools.Common.Reactive.ObservableBase`1 : object {
    private bool isDone;
    private ConcurrentDictionary`2<Subscription<T>, IObserver`1<T>> observers;
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
    protected void NotifyNext(T value);
    protected void NotifyCompleted();
    protected void NotifyError(Exception error);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Reactive.ObservableProgress`1 : ObservableBase`1<T> {
    public sealed virtual void Report(T value);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Reactive.Observer`1 : object {
    private Action onCompleted;
    private Action`1<Exception> onError;
    private Action`1<T> onNext;
    public Observer`1(Action`1<T> onNext, Action onCompleted, Action`1<Exception> onError);
    private sealed virtual override void System.IObserver<T>.OnCompleted();
    private sealed virtual override void System.IObserver<T>.OnError(Exception error);
    private sealed virtual override void System.IObserver<T>.OnNext(T value);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.Containers.Tools.Common.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AddCertificateWarning { get; }
    internal static string ArgumentExceptionEmptyString { get; }
    internal static string CertToolCriticalError { get; }
    internal static string CertToolErrorCreatingTheCertificate { get; }
    internal static string CertToolErrorExportingTheCertificate { get; }
    internal static string CertToolErrorMessageWithDetails { get; }
    internal static string CertToolErrorSavingTheCertificate { get; }
    internal static string CertToolErrorTrustingTheCertificate { get; }
    internal static string CertToolFailedToStartDevCerts { get; }
    internal static string CertToolUnableToResolveDotnetVersion { get; }
    internal static string CertToolUnkownError { get; }
    internal static string CopyingDebuggerFilesFailed { get; }
    internal static string CopyingUtilitiesFailed { get; }
    internal static string DefaultImageSku { get; }
    internal static string DockerAutoPullCancelInfoMessage { get; }
    internal static string DockerAutoPullMessage { get; }
    internal static string DockerCommandFailed { get; }
    internal static string DockerPrerequisiteDockerForWindowsInstallationIncomplete { get; }
    internal static string DockerPrerequisiteDockerForWindowsNotInstalled { get; }
    internal static string DockerPrerequisiteDriveNotShared { get; }
    internal static string DockerPrerequisiteNotInDockerGroup { get; }
    internal static string DockerPrerequisiteNotRunning { get; }
    internal static string DockerPrerequisiteRunningInErrorState { get; }
    internal static string DockerPrerequisiteUnableToGetServerOS { get; }
    internal static string DockerPrerequisiteUnableToGetTargetOS { get; }
    internal static string DriveSharingCredentialsPossiblyInvalid { get; }
    internal static string ErrorMessageMustBeProvidedWithErrorCode { get; }
    internal static string ErrorParsingIISExpressLaunchSettings { get; }
    internal static string ErrorParsingLaunchSettings { get; }
    internal static string ExceptionColumnEnd { get; }
    internal static string ExceptionColumnStart { get; }
    internal static string ExceptionCommandError { get; }
    internal static string ExceptionCommandLine { get; }
    internal static string ExceptionCommandOutput { get; }
    internal static string ExceptionErrorCode { get; }
    internal static string ExceptionExitCode { get; }
    internal static string ExceptionFile { get; }
    internal static string ExceptionLineEnd { get; }
    internal static string ExceptionLineStart { get; }
    internal static string ExceptionSeverity { get; }
    internal static string FileNotFound { get; }
    internal static string InvalidStringComparisonEnumValue { get; }
    internal static string LogBuildMessage { get; }
    internal static string LogBuildMessageLocationStart { get; }
    internal static string LogBuildMessageLocationStartAndEnd { get; }
    internal static string LogCodeErrorFormat { get; }
    internal static string LogCodeMessageFormat { get; }
    internal static string LogCodeWarningFormat { get; }
    internal static string NoValidImage { get; }
    internal static string ProjectTargetOSDoesNotMatchDockerServerOS { get; }
    internal static string RestartDockerDesktopWarningMessage { get; }
    internal static string RetryPolicyLimitedAttemptsFailure { get; }
    internal static string RetryPolicyLimitedTimeFailure { get; }
    internal static string RetryPolicyNoRetriesFailure { get; }
    internal static string SkuInformationDisplayFormat { get; }
    internal static string TryingToConnectForDebugging { get; }
    internal static string UnexpectedErrorInCheckingFileDirectoryExists { get; }
    internal static string UnknownProjectTypeHasNoImageNames { get; }
    internal static string VsDbgDownloadFailedNoExistingCopy { get; }
    internal static string VsDbgDownloadFailedUsingExistingCopy { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AddCertificateWarning();
    internal static string get_ArgumentExceptionEmptyString();
    internal static string get_CertToolCriticalError();
    internal static string get_CertToolErrorCreatingTheCertificate();
    internal static string get_CertToolErrorExportingTheCertificate();
    internal static string get_CertToolErrorMessageWithDetails();
    internal static string get_CertToolErrorSavingTheCertificate();
    internal static string get_CertToolErrorTrustingTheCertificate();
    internal static string get_CertToolFailedToStartDevCerts();
    internal static string get_CertToolUnableToResolveDotnetVersion();
    internal static string get_CertToolUnkownError();
    internal static string get_CopyingDebuggerFilesFailed();
    internal static string get_CopyingUtilitiesFailed();
    internal static string get_DefaultImageSku();
    internal static string get_DockerAutoPullCancelInfoMessage();
    internal static string get_DockerAutoPullMessage();
    internal static string get_DockerCommandFailed();
    internal static string get_DockerPrerequisiteDockerForWindowsInstallationIncomplete();
    internal static string get_DockerPrerequisiteDockerForWindowsNotInstalled();
    internal static string get_DockerPrerequisiteDriveNotShared();
    internal static string get_DockerPrerequisiteNotInDockerGroup();
    internal static string get_DockerPrerequisiteNotRunning();
    internal static string get_DockerPrerequisiteRunningInErrorState();
    internal static string get_DockerPrerequisiteUnableToGetServerOS();
    internal static string get_DockerPrerequisiteUnableToGetTargetOS();
    internal static string get_DriveSharingCredentialsPossiblyInvalid();
    internal static string get_ErrorMessageMustBeProvidedWithErrorCode();
    internal static string get_ErrorParsingIISExpressLaunchSettings();
    internal static string get_ErrorParsingLaunchSettings();
    internal static string get_ExceptionColumnEnd();
    internal static string get_ExceptionColumnStart();
    internal static string get_ExceptionCommandError();
    internal static string get_ExceptionCommandLine();
    internal static string get_ExceptionCommandOutput();
    internal static string get_ExceptionErrorCode();
    internal static string get_ExceptionExitCode();
    internal static string get_ExceptionFile();
    internal static string get_ExceptionLineEnd();
    internal static string get_ExceptionLineStart();
    internal static string get_ExceptionSeverity();
    internal static string get_FileNotFound();
    internal static string get_InvalidStringComparisonEnumValue();
    internal static string get_LogBuildMessage();
    internal static string get_LogBuildMessageLocationStart();
    internal static string get_LogBuildMessageLocationStartAndEnd();
    internal static string get_LogCodeErrorFormat();
    internal static string get_LogCodeMessageFormat();
    internal static string get_LogCodeWarningFormat();
    internal static string get_NoValidImage();
    internal static string get_ProjectTargetOSDoesNotMatchDockerServerOS();
    internal static string get_RestartDockerDesktopWarningMessage();
    internal static string get_RetryPolicyLimitedAttemptsFailure();
    internal static string get_RetryPolicyLimitedTimeFailure();
    internal static string get_RetryPolicyNoRetriesFailure();
    internal static string get_SkuInformationDisplayFormat();
    internal static string get_TryingToConnectForDebugging();
    internal static string get_UnexpectedErrorInCheckingFileDirectoryExists();
    internal static string get_UnknownProjectTypeHasNoImageNames();
    internal static string get_VsDbgDownloadFailedNoExistingCopy();
    internal static string get_VsDbgDownloadFailedUsingExistingCopy();
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.Retry : object {
    private static Func`3<TimeSpan, CancellationToken, Task> DelayFactory;
    private static IEnumerable`1<Type> DefaultThrownExceptionTypes;
    private static Retry();
    public static Task`1<TryResult`1<T>> WithPolicyAsync(IRetryPolicy retryPolicy, Func`1<Task`1<T>> taskFactory, bool configureAwaitValue, CancellationToken cancellationToken);
    public static Task`1<TryResult`1<T>> WithPolicyAsync(IRetryPolicy retryPolicy, Func`1<Task`1<T>> taskFactory, Func`3<T, Exception, bool> evaluator, bool configureAwaitValue, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Retry/<WithPolicyAsync>d__4`1")]
public static Task`1<TryResult`1<T>> WithPolicyAsync(IRetryPolicy retryPolicy, Func`1<Task`1<T>> taskFactory, Func`3<T, Exception, bool> evaluator, IEnumerable`1<Type> thrownExceptionTypes, bool configureAwaitValue, CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.RetryFailureException`1 : Exception {
    [CompilerGeneratedAttribute]
private T <Result>k__BackingField;
    public T Result { get; }
    public RetryFailureException`1(string message);
    public RetryFailureException`1(string message, Exception innerException);
    public RetryFailureException`1(string message, T result, Exception innerException);
    protected RetryFailureException`1(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public T get_Result();
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.RetryPolicies : object {
    public static IRetryPolicy NoRetries(bool throwOnFailure);
    public static IRetryPolicy MaxTries(int maxTries, bool throwOnFailure);
    public static IRetryPolicy MaxTries(int maxTries, TimeSpan delayBetweenAttempts, bool throwOnFailure);
    public static IRetryPolicy MaxTime(TimeSpan maxTime, bool throwOnFailure);
    public static IRetryPolicy MaxTime(TimeSpan maxTime, TimeSpan delayBetweenAttempts, bool throwOnFailure);
    public static IRetryPolicy Infinite(TimeSpan delayBetweenAttempts);
}
internal static class Microsoft.VisualStudio.Containers.Tools.Common.SafeNativeMethods : object {
    internal static bool IsOS(int os);
    internal static bool WaitNamedPipe(string name, int timeout);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.Scaffolder.CreateCopyFileCommandUtilities : object {
    public static string CreateCopyFilesForBuildCommands(string solutionDirectory, IEnumerable`1<string> projectFilePaths);
    private static string CreateCopyFileCommands(string solutionDirectory, IEnumerable`1<string> projectFilePaths, string fileName);
    private static IEnumerable`1<string> GatherRequiredFilePaths(string solutionDirectory, IEnumerable`1<string> projectFilePaths, string fileName);
    private static string EnsureValidTargetRelativeDirPath(string relativeDirPath);
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.Scaffolder.TemplateParser : object {
    private static string IfToken;
    private static string ElseToken;
    private static string EndIfToken;
    private static string ConditionalFormat;
    private static Regex ConditionalMacroRegex;
    private static Regex TwoPartConditionalMacroRegex;
    private static TemplateParser();
    [ConditionalAttribute("DEBUG")]
private static void DebugFail(string message);
    public static string ReplaceParameters(string content, string templateFilePath, IReadOnlyDictionary`2<string, string> parameters);
    private static TemplateNode ParseTemplate(string templateText);
    private static ValueTuple`2<TemplateNode, int> ParseConditionalNode(string templateText, MatchCollection tokenMatches, int ifIndex);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.SecureStringExtensions : object {
    [ExtensionAttribute]
[SecurityCriticalAttribute]
public static string ConvertToUnsecureString(SecureString secureString);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Services.DotnetCoreVersionStatusService : Singleton`2<IDotnetCoreVersionStatusService, DotnetCoreVersionStatusService> {
    private ProductCollection products;
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Services.DotnetCoreVersionStatusService/<GetSupportPhaseAsync>d__2")]
public sealed virtual Task`1<SupportPhase> GetSupportPhaseAsync(Version netCoreVersion);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Services.DotnetCoreVersionStatusService/<IsOutOfSupportAsync>d__3")]
public sealed virtual Task`1<Nullable`1<bool>> IsOutOfSupportAsync(Version netCoreVersion);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Services.DotnetCoreVersionStatusService/<GetProductForVersionAsync>d__4")]
private Task`1<Product> GetProductForVersionAsync(Version netCoreVersion);
    private Task`1<ProductCollection> GetReleasesFromNuGetAsync();
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Services.IDotnetCoreVersionStatusService {
    public abstract virtual Task`1<SupportPhase> GetSupportPhaseAsync(Version netCoreVersion);
    public abstract virtual Task`1<Nullable`1<bool>> IsOutOfSupportAsync(Version netCoreVersion);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Services.Logging.IErrorReportingExceptionFilter {
    public abstract virtual Task`1<Nullable`1<bool>> ShouldReportErrorAsync(Exception e, ILogContext context, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Services.Logging.IErrorReportingMessageFilter {
    public abstract virtual Task`1<string> GetMessageForExceptionAsync(Exception e, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Services.Logging.IErrorReportingService {
    public abstract virtual Task ReportErrorUIAsync(string title, Exception e, ILogContext context, IDictionary`2<string, object> additionalState, CancellationToken cancellationToken);
    public abstract virtual Task ReportErrorUIAsync(string title, string message, Exception e, ILogContext context, IDictionary`2<string, object> additionalState, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Services.Logging.ILogContext {
    public abstract virtual void WriteContext(object message);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Services.Logging.ILoggingService {
    public bool IsLoggingEnabled { get; public set; }
    public string LogFilePath { get; }
    public abstract virtual bool get_IsLoggingEnabled();
    public abstract virtual void set_IsLoggingEnabled(bool value);
    public abstract virtual string get_LogFilePath();
    public abstract virtual void LogObject(object messageObj, bool forceWrite);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Services.Logging.LoggingService : object {
    private Lazy`1<TextWriter> writer;
    private object writeLock;
    private Lazy`1<string> logFilePath;
    [CompilerGeneratedAttribute]
private bool <IsLoggingEnabled>k__BackingField;
    public bool IsLoggingEnabled { get; public set; }
    public string LogFilePath { get; }
    public LoggingService(string diagnosticsFolder, bool isLoggingEnabled);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLoggingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsLoggingEnabled(bool value);
    public sealed virtual string get_LogFilePath();
    public sealed virtual void LogObject(object messageObj, bool forceWrite);
    public sealed virtual void Dispose();
    private static string GetLogFilePath(string diagnosticsFolder);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.Services.Logging.LoggingServiceExtensions : object {
    [ExtensionAttribute]
public static void LogInvariant(ILoggingService loggingService, FormattableString formattable, Exception ex, ILogContext context, IDictionary`2<string, object> additionalState, bool forceWrite);
    [ExtensionAttribute]
public static void Log(ILoggingService loggingService, string message, Exception ex, ILogContext context, IDictionary`2<string, object> additionalState, bool forceWrite);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Services.SSL.AspNetCoreDeveloperCertificatesTool : object {
    private static int CertificateToolTimeoutInSeconds;
    private static string CheckForTrustCmdLineArgs;
    private static string TrustCmdLineArgs;
    private static string ExportCmdLineArgs;
    private static string SetKestrelPasswordCmdLineArgs;
    private static string DotNetVersionCmdLineArgs;
    private static string DotNetToolsRelPath;
    private static string DotNetExeName;
    private ILoggingService loggingService;
    private string dotNetCoreVersion;
    [ImportingConstructorAttribute]
public AspNetCoreDeveloperCertificatesTool(ILoggingService loggingService);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Services.SSL.AspNetCoreDeveloperCertificatesTool/<IsCertificateTrustedAsync>d__11")]
public sealed virtual Task`1<bool> IsCertificateTrustedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Services.SSL.AspNetCoreDeveloperCertificatesTool/<TrustAndExportCertficateAsync>d__12")]
public sealed virtual Task`1<bool> TrustAndExportCertficateAsync(string pfxExportPath, SecureString pfxPassword, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Services.SSL.AspNetCoreDeveloperCertificatesTool/<ExportCertficateAsync>d__13")]
public sealed virtual Task`1<bool> ExportCertficateAsync(string pfxExportPath, SecureString pfxPassword, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Services.SSL.AspNetCoreDeveloperCertificatesTool/<SetKestrelDevelopmentPasswordAsync>d__14")]
public sealed virtual Task`1<bool> SetKestrelDevelopmentPasswordAsync(string projectFullPath, SecureString pfxPassword, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Services.SSL.AspNetCoreDeveloperCertificatesTool/<ExecuteTimedOperationAsync>d__15")]
private Task`1<bool> ExecuteTimedOperationAsync(string command, string workingDirectory, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Services.SSL.AspNetCoreDeveloperCertificatesTool/<RunToolAsync>d__16")]
private Task`1<CommandLineResult> RunToolAsync(string cmdLineArgs, string workingDirectory, CancellationToken cancellationToken);
    private static bool ProcessExitCode(CommandLineResult result);
    private static void EnsureDotNetToolsDirectoryIsOnPath();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Containers.Tools.Common.Services.SSL.AspNetCoreDeveloperCertificatesTool/<ValidateDotNetCoreVersionAsync>d__19")]
private Task ValidateDotNetCoreVersionAsync();
}
internal enum Microsoft.VisualStudio.Containers.Tools.Common.Services.SSL.CertToolStatusCodes : Enum {
    public int value__;
    public static CertToolStatusCodes CriticalError;
    public static CertToolStatusCodes Success;
    public static CertToolStatusCodes ErrorCreatingTheCertificate;
    public static CertToolStatusCodes ErrorSavingTheCertificate;
    public static CertToolStatusCodes ErrorExportingTheCertificate;
    public static CertToolStatusCodes ErrorTrustingTheCertificate;
    public static CertToolStatusCodes UserCancel;
    public static CertToolStatusCodes ErrorNoValidCertificateFound;
    public static CertToolStatusCodes CertificateNotTrusted;
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Services.SSL.IAspNetCoreDeveloperCertificatesTool {
    public abstract virtual Task`1<bool> IsCertificateTrustedAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> TrustAndExportCertficateAsync(string pfxExportPath, SecureString pfxPassword, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> ExportCertficateAsync(string pfxExportPath, SecureString pfxPassword, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> SetKestrelDevelopmentPasswordAsync(string projectFullPath, SecureString password, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Containers.Tools.Common.Services.SSL.IAspNetSSLCertificateService {
    public abstract virtual Task TrustAndExportCertificateAsync(string pfxExportPath, string projectFullPath, SecureString pfxPassword, CancellationToken cancellationToken);
    public abstract virtual Task TrustAndExportCertificateAsync(string pfxExportPath, string projectFullPath, SecureString pfxPassword, string promptSettingName, CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Singleton`2 : object {
    private static TInterface instance;
    private static AsyncLocal`1<TInterface> testInstance;
    public static TInterface Current { get; public set; }
    public static TInterface get_Current();
    public static void set_Current(TInterface value);
    public static void SetCurrent(TInterface value);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.StringExtensions : object {
    [ExtensionAttribute]
public static string Replace(string text, string oldValue, string newValue, StringComparison comparison);
    [ExtensionAttribute]
public static bool Contains(string text, string value, StringComparison comparison);
    [ExtensionAttribute]
public static ulong GetFnv1aHashCode(string value, Encoding encoding);
    [ExtensionAttribute]
public static SecureString ToSecureString(string value, bool makeReadOnly);
    private static ulong GetFnv1aHashCode(Byte[] value);
    private static string ReplaceImpl(string text, string oldValue, string newValue, StringComparison comparison);
}
public enum Microsoft.VisualStudio.Containers.Tools.Common.TargetFramework : Enum {
    public int value__;
    public static TargetFramework DotNetCore;
    public static TargetFramework DotNetFramework;
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.TargetFrameworkUtilities : object {
    public static Version DotnetCore20Version;
    public static Version DotnetCore21Version;
    public static Version DotnetCore22Version;
    public static Version DotnetCore30Version;
    public static Version DotnetCore31Version;
    public static Version DotnetCore50Version;
    public static Version DotnetCore60Version;
    public static Version DotnetCore70Version;
    public static Version DotnetCore80Version;
    public static Version DotnetCore90Version;
    public static Version LatestDotnetGAVersion;
    private static TargetFrameworkUtilities();
    [ObsoleteAttribute("Use ParseTargetFrameworkVersion instead", "True")]
public static Version ExtractNetCoreAppVersion(string targetFrameworkWithVersion);
    public static Version ParseTargetFrameworkVersion(string targetFrameworkVersion);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.TryResult`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public bool Success { get; }
    public T Value { get; }
    public Exception Exception { get; }
    public string ErrorMessage { get; }
    public TryResult`1(T value, Exception exception, string errorMessage);
    public bool get_Success();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
}
public abstract class Microsoft.VisualStudio.Containers.Tools.Common.UI.ObservableObject : object {
    [CompilerGeneratedAttribute]
private PropertyChangingEventHandler PropertyChanging;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected bool SetPropertyValue(T& property, T value, IEqualityComparer`1<T> comparer, string propertyName);
    protected void OnPropertyChanging(string propertyName);
    protected void OnPropertyChanged(string propertyName);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.UI.ViewModelCommand : object {
    private Action`1<object> onExecute;
    private Func`2<object, bool> onCanExecute;
    [CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    public ViewModelCommand(Action`1<object> onExecute);
    public ViewModelCommand(Action`1<object> onExecute, Func`2<object, bool> onCanExecute);
    public void NotifyCanExecuteChanged();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public sealed virtual bool CanExecute(object parameter);
    public sealed virtual void Execute(object parameter);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.UniqueNameCopySuffixStrategy : object {
    public sealed virtual string GetSuffix(int index);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.UniqueNameIndexSuffixStrategy : object {
    public sealed virtual string GetSuffix(int index);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Versioning.MixedTypeComparisonToken : object {
    private VersionSubtokenType tokenType;
    private int numericValue;
    private string stringValue;
    private string rawToken;
    public VersionSubtokenType TokenType { get; }
    public double NumericValue { get; }
    public string StringValue { get; }
    public MixedTypeComparisonToken(string rawToken);
    private void EnsureParsed();
    public virtual string ToString();
    public VersionSubtokenType get_TokenType();
    public double get_NumericValue();
    public string get_StringValue();
    public int CompareTo(MixedTypeComparisonToken otherToken);
    public static int Compare(MixedTypeComparisonToken token1, MixedTypeComparisonToken token2);
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Versioning.SemanticVersion : object {
    private static Char[] LeadingVersionChars;
    private static Regex SemanticVersionRegex;
    private int hashCode;
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Patch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersionComponentizedString <BuildMetadataComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrereleaseVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersionComponentizedString <PrereleaseVersionComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalText>k__BackingField;
    public int Major { get; private set; }
    public int Minor { get; private set; }
    public int Patch { get; private set; }
    public string BuildMetadata { get; private set; }
    public SemanticVersionComponentizedString BuildMetadataComponents { get; private set; }
    public string PrereleaseVersion { get; private set; }
    public SemanticVersionComponentizedString PrereleaseVersionComponents { get; private set; }
    public string OriginalText { get; private set; }
    private SemanticVersion(string originalText);
    private static SemanticVersion();
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
private void set_Major(int value);
    [CompilerGeneratedAttribute]
public int get_Minor();
    [CompilerGeneratedAttribute]
private void set_Minor(int value);
    [CompilerGeneratedAttribute]
public int get_Patch();
    [CompilerGeneratedAttribute]
private void set_Patch(int value);
    [CompilerGeneratedAttribute]
public string get_BuildMetadata();
    [CompilerGeneratedAttribute]
private void set_BuildMetadata(string value);
    [CompilerGeneratedAttribute]
public SemanticVersionComponentizedString get_BuildMetadataComponents();
    [CompilerGeneratedAttribute]
private void set_BuildMetadataComponents(SemanticVersionComponentizedString value);
    [CompilerGeneratedAttribute]
public string get_PrereleaseVersion();
    [CompilerGeneratedAttribute]
private void set_PrereleaseVersion(string value);
    [CompilerGeneratedAttribute]
public SemanticVersionComponentizedString get_PrereleaseVersionComponents();
    [CompilerGeneratedAttribute]
private void set_PrereleaseVersionComponents(SemanticVersionComponentizedString value);
    [CompilerGeneratedAttribute]
public string get_OriginalText();
    [CompilerGeneratedAttribute]
private void set_OriginalText(string value);
    public static SemanticVersion Parse(string value);
    public sealed virtual int CompareTo(SemanticVersion other);
    public sealed virtual bool Equals(SemanticVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Microsoft.VisualStudio.Containers.Tools.Common.Versioning.SemanticVersionComponentizedString : object {
    private string rawString;
    private IReadOnlyList`1<MixedTypeComparisonToken> parts;
    private static Regex PartsplitterRegex;
    public IReadOnlyList`1<MixedTypeComparisonToken> Parts { get; }
    public SemanticVersionComponentizedString(string rawString);
    private static SemanticVersionComponentizedString();
    public IReadOnlyList`1<MixedTypeComparisonToken> get_Parts();
    private void EnsureParsed();
    public int CompareTo(SemanticVersionComponentizedString otherVersion);
    public static int Compare(SemanticVersionComponentizedString components1, SemanticVersionComponentizedString components2);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Containers.Tools.Common.Versioning.SemanticVersionExtensions : object {
    [ExtensionAttribute]
public static bool IsNullOrEmpty(SemanticVersion version);
}
public enum Microsoft.VisualStudio.Containers.Tools.Common.Versioning.VersionSubtokenType : Enum {
    public int value__;
    public static VersionSubtokenType Unknown;
    public static VersionSubtokenType Numeric;
    public static VersionSubtokenType String;
}
public static class Microsoft.VisualStudio.Containers.Tools.Common.WslPathUtilities : object {
    public static string WslShare;
    public static string AltWslShare;
    public static string DefaultAutoMountRoot;
    public static string ConvertToMountPath(string windowsPath);
    public static string ConvertToMountPath(string autoMountRoot, string windowsPath);
    public static PathUpdater GetPathUpdater(string autoMountRoot);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
