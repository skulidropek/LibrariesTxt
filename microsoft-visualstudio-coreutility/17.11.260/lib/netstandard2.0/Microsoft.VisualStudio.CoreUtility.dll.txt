[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Core.Imaging.ImageId : ValueType {
    public Guid Guid;
    public int Id;
    public ImageId(Guid guid, int id);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override bool System.IEquatable<Microsoft.VisualStudio.Core.Imaging.ImageId>.Equals(ImageId other);
    public virtual bool Equals(object other);
    public static bool op_Equality(ImageId left, ImageId right);
    public static bool op_Inequality(ImageId left, ImageId right);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Text.INonJoinableTaskTrackerInternal {
    public abstract virtual void Register(Task task);
}
internal abstract class Microsoft.VisualStudio.Text.RefCountedObjectBase : object {
    internal int _refCount;
    public void AddRef();
    public void ReleaseRef();
    protected abstract virtual void InitializeRefCountedObject();
    protected abstract virtual void ReleaseRefCountedObject();
    protected void EnsureInitialized();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal {
    public bool IsInternalUser { get; }
    public bool CanCollectPrivateInformation { get; }
    public abstract virtual void PostEvent(string key, Object[] namesAndProperties);
    public abstract virtual void PostDelay(string operation, TimeSpan duration, IContentType contentType);
    public abstract virtual void PostEvent(string key, IReadOnlyList`1<object> namesAndProperties);
    public abstract virtual void PostEvent(TelemetryEventType eventType, string eventName, TelemetryResult result, ValueTuple`2[] namesAndProperties);
    public abstract virtual void PostEvent(TelemetryEventType eventType, string eventName, TelemetryResult result, IReadOnlyList`1<ValueTuple`2<string, object>> namesAndProperties);
    public abstract virtual void PostFault(string eventName, string description, Exception exceptionObject, string additionalErrorInfo, Nullable`1<bool> isIncludedInWatsonSample, Object[] correlations);
    public abstract virtual void AdjustCounter(string key, string name, int delta);
    public abstract virtual void PostCounters();
    public abstract virtual object CreateTelemetryOperationEventScope(string eventName, TelemetrySeverity severity, Object[] correlations, IDictionary`2<string, object> startingProperties);
    public abstract virtual object GetCorrelationFromTelemetryScope(object telemetryScope);
    public abstract virtual void EndTelemetryScope(object telemetryScope, TelemetryResult result, string summary);
    public abstract virtual void RecordEventData(object source, string eventKey, T eventData);
    public abstract virtual bool get_IsInternalUser();
    public abstract virtual bool get_CanCollectPrivateInformation();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Text.Utilities.IPerformanceMarkerBlockProvider {
    public abstract virtual IDisposable CreateBlock(string blockName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Text.Utilities.TelemetryComplexProperty : object {
    [CompilerGeneratedAttribute]
private object <Property>k__BackingField;
    public object Property { get; }
    public TelemetryComplexProperty(object property);
    [CompilerGeneratedAttribute]
public object get_Property();
}
internal enum Microsoft.VisualStudio.Text.Utilities.TelemetryEventType : Enum {
    public int value__;
    public static TelemetryEventType UserTask;
    public static TelemetryEventType Trace;
    public static TelemetryEventType Operation;
    public static TelemetryEventType Fault;
    public static TelemetryEventType Asset;
}
internal enum Microsoft.VisualStudio.Text.Utilities.TelemetryResult : Enum {
    public int value__;
    public static TelemetryResult None;
    public static TelemetryResult Success;
    public static TelemetryResult Failure;
    public static TelemetryResult UserFault;
    public static TelemetryResult UserCancel;
}
internal enum Microsoft.VisualStudio.Text.Utilities.TelemetrySeverity : Enum {
    public int value__;
    public static TelemetrySeverity Low;
    public static TelemetrySeverity Normal;
    public static TelemetrySeverity High;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.AppliesToProjectAttribute : SingletonBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private string <AppliesTo>k__BackingField;
    public string AppliesTo { get; }
    public AppliesToProjectAttribute(string appliesToExpression);
    [CompilerGeneratedAttribute]
public string get_AppliesTo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Microsoft.VisualStudio.Utilities.ArrayBuilder`1/DebuggerProxy")]
public class Microsoft.VisualStudio.Utilities.ArrayBuilder`1 : object {
    private Builder<T> _builder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; public set; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public ImmutableArray`1<T> ToImmutableAndClear();
    public sealed virtual int get_Count();
    public void set_Count(int value);
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public void SetItem(int index, T value);
    public void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public void Clear();
    public bool Contains(T item);
    public int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex, int count);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public int FindIndex(Func`3<T, TArg, bool> match, TArg arg);
    public int FindIndex(int startIndex, Func`3<T, TArg, bool> match, TArg arg);
    public int FindIndex(int startIndex, int count, Func`3<T, TArg, bool> match, TArg arg);
    public bool Remove(T element);
    public void RemoveAt(int index);
    public void RemoveLast();
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> compare);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public void CopyTo(T[] array, int start);
    public T Last();
    [NullableContextAttribute("2")]
internal T LastOrDefault();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    [NullableContextAttribute("0")]
public ImmutableArray`1<U> ToDowncastedImmutable();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public sealed virtual void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items, Func`2<U, T> selector);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ArrayBuilder`1<U> items, int start, int length);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(ImmutableArray`1<T> items, int start, int length);
    public void AddRange(ImmutableArray`1<S> items);
    public void AddRange(T[] items, int start, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
    public void RemoveDuplicates();
    public void SortAndRemoveDuplicates(IComparer`1<T> comparer);
    public ImmutableArray`1<S> SelectDistinct(Func`2<T, S> selector);
    internal static PooledDisposer`1<ArrayBuilder`1<T>> GetInstance(ArrayBuilder`1& instance);
    internal static PooledDisposer`1<ArrayBuilder`1<T>> GetInstance(int capacity, ArrayBuilder`1& instance);
    internal static PooledDisposer`1<ArrayBuilder`1<T>> GetInstance(int capacity, T fillWithValue, ArrayBuilder`1& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.BaseDefinitionAttribute : MultipleBaseMetadataAttribute {
    private string baseDefinition;
    public string BaseDefinition { get; }
    public BaseDefinitionAttribute(string name);
    public string get_BaseDefinition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Utilities.BaseProxyService`1 : object {
    [NullableAttribute("2")]
private T bestImpl;
    protected IEnumerable`1<Lazy`2<T, IOrderable>> UnorderedImplementations { get; protected set; }
    protected T BestImplementation { get; }
    protected abstract virtual IEnumerable`1<Lazy`2<T, IOrderable>> get_UnorderedImplementations();
    protected abstract virtual void set_UnorderedImplementations(IEnumerable`1<Lazy`2<T, IOrderable>> value);
    protected virtual T get_BestImplementation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.BaseUtility.DefaultEditorOptionValueAttribute : SingletonBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private object <DefaultEditorOptionValue>k__BackingField;
    public object DefaultEditorOptionValue { get; }
    public DefaultEditorOptionValueAttribute(object defaultEditorOptionValue);
    [CompilerGeneratedAttribute]
public object get_DefaultEditorOptionValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Utilities.Boxes : object {
    public static object BoxedTrue;
    public static object BoxedFalse;
    public static object BoxedByteZero;
    public static object BoxedSByteZero;
    public static object BoxedInt16Zero;
    public static object BoxedUInt16Zero;
    public static object BoxedInt32Zero;
    public static object BoxedInt32One;
    public static object BoxedUInt32Zero;
    public static object BoxedInt64Zero;
    public static object BoxedUInt64Zero;
    public static object BoxedSingleZero;
    public static object BoxedDoubleZero;
    public static object BoxedDecimalZero;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Object[] s_boxedAsciiChars;
    private static Boxes();
    public static object Box(bool b);
    public static object Box(byte b);
    public static object Box(sbyte sb);
    public static object Box(short s);
    public static object Box(ushort us);
    public static object Box(int i);
    public static object Box(UInt32 u);
    public static object Box(long l);
    public static object Box(ulong ul);
    public static object Box(float f);
    public static object Box(double d);
    public static object Box(char c);
    public static object Box(decimal d);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison : object {
    private static TextInfo s_unicodeCultureTextInfo;
    private static OneToOneUnicodeComparer s_comparer;
    public static StringComparer Comparer { get; }
    private static CaseInsensitiveComparison();
    private static CultureInfo GetUnicodeCulture();
    public static char ToLower(char c);
    private static char ToLowerNonAscii(char c);
    public static StringComparer get_Comparer();
    public static bool Equals(string left, string right);
    [NullableContextAttribute("0")]
public static bool Equals(ReadOnlySpan`1<char> left, ReadOnlySpan`1<char> right);
    public static bool EndsWith(string value, string possibleEnd);
    public static bool StartsWith(string value, string possibleStart);
    public static int Compare(string left, string right);
    [NullableContextAttribute("0")]
public static int Compare(ReadOnlySpan`1<char> left, ReadOnlySpan`1<char> right);
    public static int GetHashCode(string value);
    public static void ToLower(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.ContentTypeAttribute : MultipleBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private string <ContentTypes>k__BackingField;
    public string ContentTypes { get; }
    public ContentTypeAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_ContentTypes();
}
public class Microsoft.VisualStudio.Utilities.ContentTypeDefinition : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.VisualStudio.Utilities.DefaultOrderings : object {
    public static string Lowest;
    public static string Low;
    public static string Default;
    public static string High;
    public static string Highest;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Use LocalizedNameAttribute instead.")]
public class Microsoft.VisualStudio.Utilities.DisplayNameAttribute : SingletonBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    public string DisplayName { get; }
    public DisplayNameAttribute(string displayName);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
}
public class Microsoft.VisualStudio.Utilities.DynamicVisibilityAttribute : SingletonBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private bool <DynamicVisibility>k__BackingField;
    public bool DynamicVisibility { get; }
    public DynamicVisibilityAttribute(bool dynamicVisibility);
    [CompilerGeneratedAttribute]
public bool get_DynamicVisibility();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Utilities.EligibleFactory`2 : object {
    [CompilerGeneratedAttribute]
private Lazy`2<TExtensionFactory, TMetadataView> <BestFactory>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Lazy`2<TExtensionFactory, TMetadataView> <ReplacedFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplacesOnlyIfCreated>k__BackingField;
    public Lazy`2<TExtensionFactory, TMetadataView> BestFactory { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Lazy`2<TExtensionFactory, TMetadataView> ReplacedFactory { get; }
    public bool ReplacesOnlyIfCreated { get; }
    public EligibleFactory`2(Lazy`2<TExtensionFactory, TMetadataView> bestFactory, Lazy`2<TExtensionFactory, TMetadataView> replacedFactory, bool replacesOnlyIfCreated);
    [CompilerGeneratedAttribute]
public Lazy`2<TExtensionFactory, TMetadataView> get_BestFactory();
    [CompilerGeneratedAttribute]
public Lazy`2<TExtensionFactory, TMetadataView> get_ReplacedFactory();
    [CompilerGeneratedAttribute]
public bool get_ReplacesOnlyIfCreated();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.Utilities.ExportImplementationAttribute : ExportAttribute {
    internal static string ImplementationContractName;
    public ExportImplementationAttribute(Type contractType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.FeatureChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public string FeatureName { get; }
    public bool IsEnabled { get; }
    public FeatureChangedEventArgs(string featureName, bool isEnabled);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
}
public class Microsoft.VisualStudio.Utilities.FeatureDefinition : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.FeatureUpdatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    public string FeatureName { get; }
    public FeatureUpdatedEventArgs(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.FileExtensionAttribute : SingletonBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private string <FileExtension>k__BackingField;
    public string FileExtension { get; }
    public FileExtensionAttribute(string fileExtension);
    [CompilerGeneratedAttribute]
public string get_FileExtension();
}
public class Microsoft.VisualStudio.Utilities.FileExtensionToContentTypeDefinition : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.FileNameAttribute : SingletonBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public string FileName { get; }
    public FileNameAttribute(string fileName);
    [CompilerGeneratedAttribute]
public string get_FileName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Utilities.FileNameUtilities : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static bool IsFileName(string path);
    private static int IndexOfExtension(string path);
    [NullableContextAttribute("0")]
private static int IndexOfExtension(ReadOnlySpan`1<char> path);
    internal static string GetExtension(string path);
    [NullableContextAttribute("0")]
internal static ReadOnlyMemory`1<char> GetExtension(ReadOnlyMemory`1<char> path);
    private static string RemoveExtension(string path);
    internal static string ChangeExtension(string path, string extension);
    internal static int IndexOfFileName(string path);
    internal static string GetFileName(string path, bool includeExtension);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.Utilities.FrugalList`1 : object {
    private static int InitialTailSize;
    private static List`1<T> UnitaryTail;
    private T head;
    private List`1<T> tail;
    public int Count { get; }
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public FrugalList`1(IList`1<T> elements);
    private static FrugalList`1();
    public sealed virtual int get_Count();
    public void AddRange(IList`1<T> list);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void Add(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public bool Contains(T item, IEqualityComparer`1<T> comparer);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public FrugalEnumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Utilities.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int Combine(T newKeyPart, int currentKey);
    [NullableContextAttribute("2")]
internal static int CombineValues(IEnumerable`1<T> values, int maxItemsToHash);
    internal static int CombineValues(ImmutableDictionary`2<TKey, TValue> values, int maxItemsToHash);
    [NullableContextAttribute("2")]
internal static int CombineValues(T[] values, int maxItemsToHash);
    [NullableContextAttribute("2")]
internal static int CombineValues(ImmutableArray`1<T> values, int maxItemsToHash);
    internal static int CombineValues(IEnumerable`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int CombineValues(ImmutableArray`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int GetFNVHashCode(Byte[] data);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ReadOnlySpan`1<byte> data, Boolean& isAscii);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ReadOnlySpan`1<char> data);
    internal static int GetFNVHashCode(string text, int start, int length);
    internal static int GetCaseInsensitiveFNVHashCode(string text);
    [NullableContextAttribute("0")]
internal static int GetCaseInsensitiveFNVHashCode(ReadOnlySpan`1<char> data);
    internal static int GetFNVHashCode(string text, int start);
    internal static int GetFNVHashCode(string text);
    internal static int GetFNVHashCode(StringBuilder text);
    internal static int GetFNVHashCode(Char[] text, int start, int length);
    internal static int GetFNVHashCode(char ch);
    internal static int CombineFNVHash(int hashCode, string text);
    internal static int CombineFNVHash(int hashCode, char ch);
    [NullableContextAttribute("0")]
internal static int CombineFNVHash(int hashCode, ReadOnlySpan`1<char> data);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IContentType {
    public string TypeName { get; }
    public string DisplayName { get; }
    public IEnumerable`1<IContentType> BaseTypes { get; }
    public abstract virtual string get_TypeName();
    public abstract virtual string get_DisplayName();
    public abstract virtual bool IsOfType(string type);
    public abstract virtual IEnumerable`1<IContentType> get_BaseTypes();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IContentTypeDefinition {
    public string Name { get; }
    public IEnumerable`1<string> BaseDefinitions { get; }
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<string> get_BaseDefinitions();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IContentTypeDefinitionSource {
    public IEnumerable`1<IContentTypeDefinition> Definitions { get; }
    public abstract virtual IEnumerable`1<IContentTypeDefinition> get_Definitions();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IContentTypeMetadata {
    public IEnumerable`1<string> ContentTypes { get; }
    public abstract virtual IEnumerable`1<string> get_ContentTypes();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IContentTypeRegistryService {
    public IContentType UnknownContentType { get; }
    public IEnumerable`1<IContentType> ContentTypes { get; }
    public abstract virtual IContentType GetContentType(string typeName);
    public abstract virtual IContentType AddContentType(string typeName, IEnumerable`1<string> baseTypeNames);
    public abstract virtual void RemoveContentType(string typeName);
    public abstract virtual IContentType get_UnknownContentType();
    public abstract virtual IEnumerable`1<IContentType> get_ContentTypes();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IContentTypeRegistryService2 {
    public abstract virtual string GetMimeType(IContentType type);
    public abstract virtual IContentType GetContentTypeForMimeType(string mimeType);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IDecorated {
    public ImageId Icon { get; }
    public string DescriptionText { get; }
    public abstract virtual ImageId get_Icon();
    public abstract virtual string get_DescriptionText();
}
public interface Microsoft.VisualStudio.Utilities.IFeatureController {
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IFeatureCookie {
    public bool IsEnabled { get; }
    public string FeatureName { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_StateChanged(EventHandler`1<FeatureChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StateChanged(EventHandler`1<FeatureChangedEventArgs> value);
    public abstract virtual bool get_IsEnabled();
    public abstract virtual string get_FeatureName();
}
public interface Microsoft.VisualStudio.Utilities.IFeatureDisableToken {
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Utilities.IFeatureFlagsAdapter {
    public abstract virtual bool IsFeatureEnabled(string featureName, bool defaultValue);
    public abstract virtual void EnableFeatureFlag(string featureName, bool featureFlagValue);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IFeatureService {
    public abstract virtual bool IsEnabled(string featureName);
    public abstract virtual IFeatureDisableToken Disable(string featureName, IFeatureController controller);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StateUpdated(EventHandler`1<FeatureUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StateUpdated(EventHandler`1<FeatureUpdatedEventArgs> value);
    public abstract virtual IFeatureCookie GetCookie(string featureName);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IFeatureServiceFactory {
    public IFeatureService GlobalFeatureService { get; }
    public abstract virtual IFeatureService get_GlobalFeatureService();
    public abstract virtual IFeatureService GetOrCreate(IPropertyOwner scope);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService {
    public abstract virtual IContentType GetContentTypeForExtension(string extension);
    public abstract virtual IEnumerable`1<string> GetExtensionsForContentType(IContentType contentType);
    public abstract virtual void AddFileExtension(string extension, IContentType contentType);
    public abstract virtual void RemoveFileExtension(string extension);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService2 {
    public abstract virtual IContentType GetContentTypeForFileName(string name);
    public abstract virtual IContentType GetContentTypeForFileNameOrExtension(string name);
    public abstract virtual IEnumerable`1<string> GetFileNamesForContentType(IContentType contentType);
    public abstract virtual void AddFileName(string name, IContentType contentType);
    public abstract virtual void RemoveFileName(string name);
}
public interface Microsoft.VisualStudio.Utilities.IFilePathToContentTypeProvider {
    public abstract virtual bool TryGetContentTypeForFilePath(string filePath, IContentType& contentType);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IFileToContentTypeService {
    public abstract virtual IContentType GetContentTypeForFilePath(string filePath);
    public abstract virtual IContentType GetContentTypeForFilePathOnly(string filePath);
    public abstract virtual IContentType GetContentTypeForFileName(string name);
    public abstract virtual IContentType GetContentTypeForFileNameOrExtension(string name);
    public abstract virtual IEnumerable`1<string> GetFileNamesForContentType(IContentType contentType);
    public abstract virtual void AddFileName(string name, IContentType contentType);
    public abstract virtual void RemoveFileName(string name);
    public abstract virtual IContentType GetContentTypeForExtension(string extension);
    public abstract virtual IEnumerable`1<string> GetExtensionsForContentType(IContentType contentType);
    public abstract virtual void AddFileExtension(string extension, IContentType contentType);
    public abstract virtual void RemoveFileExtension(string extension);
}
public interface Microsoft.VisualStudio.Utilities.IGuardedOperations {
    public abstract virtual void CallExtensionPoint(Action call);
    public abstract virtual void CallExtensionPoint(object errorSource, Action call);
    public abstract virtual void CallExtensionPoint(object errorSource, Action call, Predicate`1<Exception> exceptionGuardFilter);
    public abstract virtual T CallExtensionPoint(Func`1<T> call, T valueOnThrow);
    public abstract virtual T CallExtensionPoint(object errorSource, Func`1<T> call, T valueOnThrow);
    public abstract virtual Task CallExtensionPointAsync(Func`1<Task> asyncAction);
    public abstract virtual Task CallExtensionPointAsync(object errorSource, Func`1<Task> asyncAction);
    public abstract virtual Task`1<T> CallExtensionPointAsync(Func`1<Task`1<T>> asyncCall, T valueOnThrow);
    public abstract virtual Task`1<T> CallExtensionPointAsync(object errorSource, Func`1<Task`1<T>> asyncCall, T valueOnThrow);
    public abstract virtual IEnumerable`1<Lazy`2<TExtensionFactory, TMetadataView>> FindEligibleFactories(IEnumerable`1<Lazy`2<TExtensionFactory, TMetadataView>> lazyFactories, IContentType dataContentType, IContentTypeRegistryService contentTypeRegistryService);
    public abstract virtual void HandleException(object errorSource, Exception e);
    public abstract virtual TExtension InstantiateExtension(object errorSource, Lazy`1<TExtension> provider);
    public abstract virtual TExtension InstantiateExtension(object errorSource, Lazy`2<TExtension, TMetadata> provider);
    public abstract virtual TExtensionInstance InstantiateExtension(object errorSource, Lazy`2<TExtension, TMetadata> provider, Func`2<TExtension, TExtensionInstance> getter);
    public abstract virtual TExtension InvokeBestMatchingFactory(IList`1<Lazy`2<TExtension, TMetadataView>> providerHandles, IContentType dataContentType, IContentTypeRegistryService contentTypeRegistryService, object errorSource);
    public abstract virtual TExtensionInstance InvokeBestMatchingFactory(IList`1<Lazy`2<TExtensionFactory, TMetadataView>> providerHandles, IContentType dataContentType, Func`2<TExtensionFactory, TExtensionInstance> getter, IContentTypeRegistryService contentTypeRegistryService, object errorSource);
    public abstract virtual List`1<TExtensionInstance> InvokeEligibleFactories(IEnumerable`1<Lazy`2<TExtensionFactory, TMetadataView>> lazyFactories, Func`2<TExtensionFactory, TExtensionInstance> getter, IContentType dataContentType, IContentTypeRegistryService contentTypeRegistryService, object errorSource);
    public abstract virtual List`1<TExtensionInstance> InvokeMatchingFactories(IEnumerable`1<Lazy`2<TExtensionFactory, TMetadataView>> lazyFactories, Func`2<TExtensionFactory, TExtensionInstance> getter, IContentType dataContentType, object errorSource);
    public abstract virtual void RaiseEvent(object sender, EventHandler eventHandlers);
    public abstract virtual void RaiseEvent(object sender, EventHandler`1<TArgs> eventHandlers, TArgs args);
    public abstract virtual Task RaiseEventOnBackgroundAsync(object sender, AsyncEventHandler`1<TArgs> eventHandlers, TArgs args);
    public abstract virtual bool TryCastToType(object toCast, TArgs& casted);
}
public interface Microsoft.VisualStudio.Utilities.IGuardedOperations2 {
    public abstract virtual void LogException(object errorSource, Exception e);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Utilities.IGuardedOperationsInternal {
    public abstract virtual T CallExtensionPoint(object errorSource, Func`1<T> call, T valueOnThrow, Predicate`1<Exception> exceptionToIgnore, Predicate`1<Exception> exceptionToHandle);
    public abstract virtual IEnumerable`1<EligibleFactory`2<TExtensionFactory, TMetadataView>> FindAllEligibleFactories(IEnumerable`1<Lazy`2<TExtensionFactory, TMetadataView>> lazyFactories, IContentType dataContentType, IContentTypeRegistryService contentTypeRegistryService);
    public abstract virtual Lazy`2<TExtension, TMetadataView> FindBestMatchingFactory(IList`1<Lazy`2<TExtension, TMetadataView>> providerHandles, IContentType dataContentType, IContentTypeRegistryService contentTypeRegistryService);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.ILivingObjectDiagnostics`1 {
    public abstract virtual bool HasProbablyLeaked(T trackedObject);
    public abstract virtual string GetPreview(T trackedObject);
    public abstract virtual string GetDescription(T trackedObject);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IMemoryLeakTrackerService {
    public bool WasCacheResettedBefore { get; }
    public bool IsTracking { get; public set; }
    public abstract virtual void TrackObject(T objectToTrack, string identifier, ILivingObjectDiagnostics`1<T> objectDiagnosticsHelper);
    public abstract virtual IReadOnlyList`1<LivingObjectRecord`1<T>> GetLivingObjects();
    public abstract virtual IReadOnlyList`1<LivingObjectRecord> GetLivingObjects();
    public abstract virtual void RefreshWeakRefrenceCache();
    public abstract virtual void ClearCache();
    public abstract virtual bool get_WasCacheResettedBefore();
    public abstract virtual bool get_IsTracking();
    public abstract virtual void set_IsTracking(bool value);
}
internal class Microsoft.VisualStudio.Utilities.ImportImplementationAttribute : ImportAttribute {
    [NullableContextAttribute("1")]
public ImportImplementationAttribute(Type contractType);
}
public class Microsoft.VisualStudio.Utilities.ImportImplementationsAttribute : ImportManyAttribute {
    [NullableContextAttribute("1")]
public ImportImplementationsAttribute(Type contractType);
}
[NullableContextAttribute("2")]
public interface Microsoft.VisualStudio.Utilities.INameAndReplacesMetadata {
    [DefaultValueAttribute("")]
public string Name { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultValueAttribute("")]
public IEnumerable`1<string> Replaces { get; }
    [DefaultValueAttribute("")]
public IEnumerable`1<bool> ReplacesOnlyIfCreated { get; }
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<string> get_Replaces();
    public abstract virtual IEnumerable`1<bool> get_ReplacesOnlyIfCreated();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.INamed {
    public string DisplayName { get; }
    public abstract virtual string get_DisplayName();
}
public interface Microsoft.VisualStudio.Utilities.INamedContentTypeMetadata {
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IOrderable {
    public string Name { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultValueAttribute("")]
public IEnumerable`1<string> Before { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultValueAttribute("")]
public IEnumerable`1<string> After { get; }
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<string> get_Before();
    public abstract virtual IEnumerable`1<string> get_After();
}
internal interface Microsoft.VisualStudio.Utilities.IPooled {
    public abstract virtual void Free();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.IPropertyOwner {
    public PropertyCollection Properties { get; }
    public abstract virtual PropertyCollection get_Properties();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.ITelemetryIdProvider`1 {
    public abstract virtual bool TryGetTelemetryId(TId& telemetryId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Utilities.LivingObjectRecord : object {
    public bool HasProbablyLeaked { get; }
    public string Identifier { get; }
    public string Preview { get; }
    public string Description { get; }
    public abstract virtual bool get_HasProbablyLeaked();
    public abstract virtual string get_Identifier();
    public abstract virtual string get_Preview();
    public abstract virtual string get_Description();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.LivingObjectRecord`1 : LivingObjectRecord {
    private string identifier;
    private bool hasProbablyLeaked;
    private string preview;
    private string description;
    [CompilerGeneratedAttribute]
private T <LivingObject>k__BackingField;
    public T LivingObject { get; }
    public bool HasProbablyLeaked { get; }
    public string Identifier { get; }
    public string Preview { get; }
    public string Description { get; }
    public LivingObjectRecord`1(T livingObject, string identifier, string description, bool hasProbablyLeaked, string preview);
    [CompilerGeneratedAttribute]
public T get_LivingObject();
    public virtual bool get_HasProbablyLeaked();
    public virtual string get_Identifier();
    public virtual string get_Preview();
    public virtual string get_Description();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.LocalizedNameAttribute : SingletonBaseMetadataAttribute {
    private string localizedName;
    public string LocalizedName { get; }
    public LocalizedNameAttribute(Type type, string resourceId);
    public LocalizedNameAttribute(Type type, string resourceStreamName, string resourceId);
    public string get_LocalizedName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("452")]
public class Microsoft.VisualStudio.Utilities.MimeTypeAttribute : SingletonBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private string <MimeType>k__BackingField;
    public string MimeType { get; }
    public MimeTypeAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_MimeType();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("452")]
public abstract class Microsoft.VisualStudio.Utilities.MultipleBaseMetadataAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.NameAttribute : SingletonBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public NameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.ObjectPool`1 : object {
    [NullableAttribute("2")]
private T _firstItem;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Element[] _items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    internal ObjectPool`1(Func`2<ObjectPool`1<T>, T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
public class Microsoft.VisualStudio.Utilities.OptionUserModifiableAttribute : SingletonBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private bool <OptionUserModifiable>k__BackingField;
    public bool OptionUserModifiable { get; }
    public OptionUserModifiableAttribute(bool userModifiable);
    [CompilerGeneratedAttribute]
public bool get_OptionUserModifiable();
}
public class Microsoft.VisualStudio.Utilities.OptionUserVisibleAttribute : SingletonBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private bool <OptionUserVisible>k__BackingField;
    public bool OptionUserVisible { get; }
    public OptionUserVisibleAttribute(bool userVisible);
    [CompilerGeneratedAttribute]
public bool get_OptionUserVisible();
}
public class Microsoft.VisualStudio.Utilities.OrderAttribute : MultipleBaseMetadataAttribute {
    private string before;
    private string after;
    public string Before { get; public set; }
    public string After { get; public set; }
    public string get_Before();
    public void set_Before(string value);
    public string get_After();
    public void set_After(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.VisualStudio.Utilities.Orderer : object {
    private static string HighestUC;
    private static string HighUC;
    private static string DefaultUC;
    private static string LowUC;
    private static string LowestUC;
    private static Orderer();
    public static IList`1<Lazy`2<TValue, TMetadata>> Order(IEnumerable`1<Lazy`2<TValue, TMetadata>> itemsToOrder);
    private static void PrepareGraph(IEnumerable`1<Lazy`2<TValue, TMetadata>> items, Queue`1<Node`2<TValue, TMetadata>> roots, List`1<Node`2<TValue, TMetadata>> unsortedItems);
    private static void AddPlaceHolders(Dictionary`2<string, Node`2<TValue, TMetadata>> map, String[] names);
    private static void AddToAfterHighest(IEnumerable`1<Node`2<TValue, TMetadata>> nodes, HashSet`1<Node`2<TValue, TMetadata>> afterHighest);
    private static void AddToBeforeLowest(IEnumerable`1<Node`2<TValue, TMetadata>> nodes, HashSet`1<Node`2<TValue, TMetadata>> beforeLowest);
    private static IList`1<Lazy`2<TValue, TMetadata>> TopologicalSort(Queue`1<Node`2<TValue, TMetadata>> roots, List`1<Node`2<TValue, TMetadata>> unsortedItems);
    private static void AddToRoots(Queue`1<Node`2<TValue, TMetadata>> roots, List`1<Node`2<TValue, TMetadata>> newRoots);
    private static Node`2<TValue, TMetadata> BreakCircularReference(List`1<Node`2<TValue, TMetadata>> unsortedItems);
    private static List`1<List`1<Node`2<TValue, TMetadata>>> FindCycles(List`1<Node`2<TValue, TMetadata>> unsortedItems);
    private static void FindCycles(Node`2<TValue, TMetadata> node, Stack`1<Node`2<TValue, TMetadata>> stack, Int32& index, List`1<List`1<Node`2<TValue, TMetadata>>> cycles);
}
internal enum Microsoft.VisualStudio.Utilities.PathKind : Enum {
    public int value__;
    public static PathKind Empty;
    public static PathKind Relative;
    public static PathKind RelativeToCurrentDirectory;
    public static PathKind RelativeToCurrentParent;
    public static PathKind RelativeToCurrentRoot;
    public static PathKind RelativeToDriveDirectory;
    public static PathKind Absolute;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Utilities.PathUtilities : object {
    internal static char AltDirectorySeparatorChar;
    internal static string ParentRelativeDirectory;
    internal static string ThisDirectory;
    internal static string DirectorySeparatorStr;
    internal static char VolumeSeparatorChar;
    private static Char[] s_pathChars;
    public static IEqualityComparer`1<string> Comparer;
    internal static char DirectorySeparatorChar { get; }
    internal static bool IsUnixLikePlatform { get; }
    private static PathUtilities();
    internal static char get_DirectorySeparatorChar();
    internal static bool get_IsUnixLikePlatform();
    public static bool IsDirectorySeparator(char c);
    public static bool IsAnyDirectorySeparator(char c);
    public static string TrimTrailingSeparators(string s);
    public static string EnsureTrailingSeparator(string s);
    [NullableContextAttribute("2")]
public static string GetFileName(string path, bool includeExtension);
    [NullableContextAttribute("2")]
public static string GetDirectoryName(string path);
    [NullableContextAttribute("2")]
internal static string GetDirectoryName(string path, bool isUnixLike);
    internal static bool IsSameDirectoryOrChildOf(string child, string parent);
    [NullableContextAttribute("2")]
public static string GetPathRoot(string path);
    [NullableContextAttribute("2")]
private static string GetPathRoot(string path, bool isUnixLike);
    private static string GetWindowsRoot(string path);
    private static int ConsumeDirectorySeparators(string path, int length, int i);
    private static string GetUnixRoot(string path);
    [NullableContextAttribute("2")]
public static PathKind GetPathKind(string path);
    [NullableContextAttribute("2")]
public static bool IsAbsolute(string path);
    private static bool IsDriveRootedAbsolutePath(string path);
    public static string CombineAbsoluteAndRelativePaths(string root, string relativePath);
    [NullableContextAttribute("2")]
public static string CombinePossiblyRelativeAndRelativePaths(string root, string relativePath);
    public static string CombinePathsUnchecked(string root, string relativePath);
    [NullableContextAttribute("2")]
public static string CombinePaths(string root, string path);
    private static string RemoveTrailingDirectorySeparator(string path);
    public static bool IsFilePath(string assemblyDisplayNameOrPath);
    public static bool ContainsPathComponent(string path, string component, bool ignoreCase);
    public static string GetRelativePath(string directory, string fullPath);
    public static bool IsChildPath(string parentPath, string childPath);
    private static string GetRelativeChildPath(string parentPath, string childPath);
    private static String[] GetPathParts(string path);
    public static bool PathsEqual(string path1, string path2);
    private static bool PathsEqual(string path1, string path2, int length);
    private static bool PathCharEqual(char x, char y);
    [NullableContextAttribute("2")]
private static int PathHashCode(string path);
    public static string NormalizePathPrefix(string filePath, ImmutableArray`1<KeyValuePair`2<string, string>> pathMap);
    [NullableContextAttribute("2")]
public static bool IsValidFilePath(string fullPath);
    public static string NormalizeWithForwardSlash(string p);
}
internal static class Microsoft.VisualStudio.Utilities.PlatformInformation : object {
    public static bool IsWindows { get; }
    public static bool IsUnix { get; }
    public static bool get_IsWindows();
    public static bool get_IsUnix();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Utilities.PooledDelegates : object {
    [NullableContextAttribute("1")]
private static Releaser GetPooledDelegate(TUnboundDelegate unboundDelegate, TArg argument, TBoundDelegate& boundDelegate);
    [NullableContextAttribute("1")]
public static Releaser GetPooledAction(Action`1<TArg> unboundAction, TArg argument, Action& boundAction);
    [NullableContextAttribute("1")]
public static Releaser GetPooledAction(Action`2<T1, TArg> unboundAction, TArg argument, Action`1& boundAction);
    [NullableContextAttribute("1")]
public static Releaser GetPooledAction(Action`3<T1, T2, TArg> unboundAction, TArg argument, Action`2& boundAction);
    public static Releaser GetPooledAction(Action`4<T1, T2, T3, TArg> unboundAction, TArg argument, Action`3& boundAction);
    [NullableContextAttribute("1")]
public static Releaser GetPooledFunction(Func`2<TArg, TResult> unboundFunction, TArg argument, Func`1& boundFunction);
    [NullableContextAttribute("1")]
public static Releaser GetPooledFunction(Func`3<T1, TArg, TResult> unboundFunction, TArg argument, Func`2& boundFunction);
    public static Releaser GetPooledFunction(Func`4<T1, T2, TArg, TResult> unboundFunction, TArg argument, Func`3& boundFunction);
    public static Releaser GetPooledFunction(Func`5<T1, T2, T3, TArg, TResult> unboundFunction, TArg argument, Func`4& boundFunction);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Utilities.PooledDictionary`2 : Dictionary`2<K, V> {
    private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool, IEqualityComparer`1<K> keyComparer);
    private static PooledDictionary`2();
    public ImmutableDictionary`2<K, V> ToImmutableDictionaryAndFree();
    public ImmutableDictionary`2<K, V> ToImmutableDictionary();
    public sealed virtual void Free();
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool(IEqualityComparer`1<K> keyComparer);
    public static PooledDictionary`2<K, V> GetInstance();
    internal static PooledDisposer`1<PooledDictionary`2<K, V>> GetInstance(PooledDictionary`2& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.VisualStudio.Utilities.PooledDisposer`1 : ValueType {
    private TPoolable _pooledObject;
    public PooledDisposer`1(TPoolable instance);
    private sealed virtual override void System.IDisposable.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Utilities.PooledHashSet`1 : HashSet`1<T> {
    private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool, IEqualityComparer`1<T> equalityComparer);
    private static PooledHashSet`1();
    public sealed virtual void Free();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool(IEqualityComparer`1<T> equalityComparer);
    public static PooledHashSet`1<T> GetInstance();
    internal static PooledDisposer`1<PooledHashSet`1<T>> GetInstance(PooledHashSet`1& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.VisualStudio.Utilities.PooledList`1 : List`1<T> {
    private ObjectPool`1<PooledList`1<T>> _pool;
    private static ObjectPool`1<PooledList`1<T>> s_poolInstance;
    private PooledList`1(ObjectPool`1<PooledList`1<T>> pool);
    private static PooledList`1();
    public sealed virtual void Free();
    public static ObjectPool`1<PooledList`1<T>> CreatePool();
    public static PooledList`1<T> GetInstance();
    public static PooledDisposer`1<PooledList`1<T>> GetInstance(PooledList`1& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.Utilities.PooledReadOnlyList`1 : object {
    private static int s_minimumArrayLengthForPool;
    private static ObjectPool`1<Builder<T>> s_arrayBuilderPool;
    private object _gate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Builder<T> _pooledBuilder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ImmutableArray`1<T>> _immutableArray;
    [CompilerGeneratedAttribute]
private static PooledReadOnlyList`1<T> <Empty>k__BackingField;
    public static PooledReadOnlyList`1<T> Empty { get; }
    public T Item { get; }
    public int Count { get; }
    private PooledReadOnlyList`1(Builder<T> pooledBuilder, Nullable`1<ImmutableArray`1<T>> immutableArray);
    private static PooledReadOnlyList`1();
    [CompilerGeneratedAttribute]
public static PooledReadOnlyList`1<T> get_Empty();
    public sealed virtual T get_Item(int index);
    public sealed virtual int get_Count();
    public ImmutableArray`1<T> AsImmutableArray();
    public static PooledReadOnlyList`1<T> Create(IEnumerable`1<T> items);
    public static PooledReadOnlyList`1<T> Create(ImmutableArray`1<T> items);
    internal void Free();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Utilities.PooledReadOnlyList`1/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static int CalculateMaximumSmallObjectArrayLength();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.PooledStopwatch : Stopwatch {
    private static ObjectPool`1<PooledStopwatch> s_poolInstance;
    private ObjectPool`1<PooledStopwatch> _pool;
    private PooledStopwatch(ObjectPool`1<PooledStopwatch> pool);
    private static PooledStopwatch();
    public sealed virtual void Dispose();
    public void Free();
    public static ObjectPool`1<PooledStopwatch> CreatePool();
    public static PooledStopwatch StartInstance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.PooledStringBuilder : object {
    public StringBuilder Builder;
    private ObjectPool`1<PooledStringBuilder> _pool;
    private static ObjectPool`1<PooledStringBuilder> s_poolInstance;
    public int Length { get; }
    private PooledStringBuilder(ObjectPool`1<PooledStringBuilder> pool);
    private static PooledStringBuilder();
    public int get_Length();
    public sealed virtual void Free();
    [ObsoleteAttribute("Consider calling ToStringAndFree instead.")]
public string ToString();
    public string ToStringAndFree();
    public string ToStringAndFree(int startIndex, int length);
    public static ObjectPool`1<PooledStringBuilder> CreatePool(int size);
    public static PooledStringBuilder GetInstance();
    public static StringBuilder op_Implicit(PooledStringBuilder obj);
    internal static PooledDisposer`1<PooledStringBuilder> GetInstance(StringBuilder& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames : object {
    public static string Editor;
    public static string Popup;
    public static string InteractivePopup;
    public static string Completion;
    public static string AsyncCompletion;
    public static string CodeCleanup;
}
public class Microsoft.VisualStudio.Utilities.PriorityAttribute : SingletonBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public int Priority { get; }
    public PriorityAttribute(int priority);
    [CompilerGeneratedAttribute]
public int get_Priority();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.VisualStudio.Utilities.PropertyCollection : object {
    private HybridDictionary properties;
    private object syncLock;
    public object Item { get; public set; }
    public ReadOnlyCollection`1<KeyValuePair`2<object, object>> PropertyList { get; }
    public void AddProperty(object key, object property);
    public bool RemoveProperty(object key);
    public T GetOrCreateSingletonProperty(object key, Func`1<T> creator);
    public T GetOrCreateSingletonProperty(Func`1<T> creator);
    public TProperty GetProperty(object key);
    public object GetProperty(object key);
    public bool TryGetProperty(object key, TProperty& property);
    public T Exchange(object key, T value);
    public T CompareExchange(object key, T value, T comparand);
    public bool ContainsProperty(object key);
    public object get_Item(object key);
    public void set_Item(object key, object value);
    public ReadOnlyCollection`1<KeyValuePair`2<object, object>> get_PropertyList();
    private void SetProperty(object key, object property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Utilities.ProtocolConversions : object {
    private static Char[] s_dirSeparators;
    private static ProtocolConversions();
    public static bool TryGetUriFromFilePath(string absolutePath, Uri& uri);
    public static Uri GetUriFromFilePath(string absolutePath);
    internal static string GetAbsoluteUriString(string absolutePath);
    private static bool IsAscii(string filePath);
    [CompilerGeneratedAttribute]
internal static string <GetAbsoluteUriString>g__EscapeUriPart|3_0(string stringToEscape);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("452")]
public abstract class Microsoft.VisualStudio.Utilities.SingletonBaseMetadataAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.VisualStudio.Utilities.StandardContentTypeNames : object {
    public static string Any;
    public static string Text;
    public static string Code;
    public static string Projection;
    public static string Inert;
}
internal class Microsoft.VisualStudio.Utilities.TelemetryTaskDuration : object {
    [NullableAttribute("2")]
private PooledStopwatch stopwatch;
    private TimeSpan finalDuration;
    public TimeSpan Duration { get; }
    public TimeSpan get_Duration();
    [NullableContextAttribute("1")]
internal static TelemetryTaskDuration CreateAndStart();
    internal void Pause();
    internal void Continue();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.TypeConversionAttribute : SingletonBaseMetadataAttribute {
    private Type from;
    private Type to;
    public string FromFullName { get; }
    public string ToFullName { get; }
    public TypeConversionAttribute(Type from, Type to);
    public string get_FromFullName();
    public string get_ToFullName();
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.5.107.25444")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
