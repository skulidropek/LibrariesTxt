internal class Microsoft.Internal.Performance.CodeMarkerExStartEnd : ValueType {
    private int _end;
    private Byte[] _aBuff;
    internal CodeMarkerExStartEnd(int begin, int end, Byte[] aBuff, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, Guid guidData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, string stringData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, UInt32 uintData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, ulong ulongData, bool correlated);
    public sealed virtual void Dispose();
}
internal class Microsoft.Internal.Performance.CodeMarkers : object {
    public static CodeMarkers Instance;
    private static string AtomName;
    private static string TestDllName;
    private static string ProductDllName;
    private State state;
    private RegistryView registryView;
    private string regroot;
    private Nullable`1<bool> shouldUseTestDll;
    private static Byte[] CorrelationMarkBytes;
    public bool IsEnabled { get; }
    public bool ShouldUseTestDll { get; }
    private static CodeMarkers();
    public bool get_IsEnabled();
    public bool get_ShouldUseTestDll();
    public bool CodeMarker(int nTimerID);
    public bool CodeMarkerEx(int nTimerID, Byte[] aBuff);
    public void SetStateDLLException();
    public bool CodeMarkerEx(int nTimerID, Guid guidData);
    public bool CodeMarkerEx(int nTimerID, string stringData);
    internal static Byte[] StringToBytesZeroTerminated(string stringData);
    public static Byte[] AttachCorrelationId(Byte[] buffer, Guid correlationId);
    public bool CodeMarkerEx(int nTimerID, UInt32 uintData);
    public bool CodeMarkerEx(int nTimerID, ulong ulongData);
    private static bool UsePrivateCodeMarkers(string regRoot, RegistryView registryView);
}
internal class Microsoft.Internal.Performance.CodeMarkerStartEnd : ValueType {
    private int _end;
    private Byte[] _buffer;
    internal CodeMarkerStartEnd(int begin, int end, bool correlated);
    public sealed virtual void Dispose();
    private void CodeMarker(int id);
}
public class Microsoft.Internal.VisualStudio.PlatformUI.ImageHelper : AxHost {
    private static double LogicalDpi;
    public static Image ImageFromIPicture(object pic);
    public static BitmapSource BitmapSourceFromIPicture(object pic);
    public static BitmapSource BitmapSourceFromBitmap(Bitmap bitmap);
    public static BitmapSource BitmapSourceFromIconLocation(string filename, int index, bool large);
    public static bool TryParseIconLocation(string resource, String& filename, Int32& index);
    public static object IPictureFromBitmapSource(BitmapSource bitmapSource);
    public static object IPictureFromBitmap(Bitmap bitmap);
    private static IntPtr DIBFromBitmap(Bitmap bitmap);
    public static IntPtr DIBFromBitmapSource(BitmapSource source);
    public static Bitmap BitmapFromBitmapSource(BitmapSource bitmapSource);
    public static Size GetBitmapSize(IntPtr bitmapHandle);
    public static Size GetIconSize(IntPtr iconHandle);
    public static BitmapSource BitmapSourceFromHandle(IntPtr handle, Int32Rect rect);
    public static Bitmap ReadBitmapFromFile(string file);
    private static bool TryConvertPixelFormat(PixelFormat format, PixelFormat& drawingPixelFormat);
    public static Byte[] GetBitmapBits(Bitmap bitmap);
    public static Byte[] GetIconBits(Icon icon, Size desiredSize);
    public static Byte[] GetIconBits(Icon icon);
    public static Byte[] GetBitmapSourceBits(BitmapSource bitmap);
    public static List`1<ImageSource> ImageSourcesFromBitmap(Bitmap bitmap);
    public static BitmapPalette BitmapPaletteFromColorPalette(ColorPalette palette);
    public static PixelFormat PixelFormatFromDrawingPixelFormat(PixelFormat format);
}
public class Microsoft.VisualStudio.Imaging.ActualDpiConverter : ValueConverter`2<double, double> {
    public static ActualDpiConverter Instance;
    private static ActualDpiConverter();
    protected virtual double Convert(double dpi, object parameter, CultureInfo culture);
}
public class Microsoft.VisualStudio.Imaging.ActualGrayscaleBiasColorConverter : MultiValueConverter`3<Nullable`1<Color>, bool, Color> {
    public static ActualGrayscaleBiasColorConverter Instance;
    private static ActualGrayscaleBiasColorConverter();
    protected virtual Color Convert(Nullable`1<Color> grayscaleBiasColor, bool highContrast, object parameter, CultureInfo culture);
}
public class Microsoft.VisualStudio.Imaging.ActualHighContrastConverter : MultiValueConverter`3<Nullable`1<bool>, bool, bool> {
    public static ActualHighContrastConverter Instance;
    private static ActualHighContrastConverter();
    protected virtual bool Convert(Nullable`1<bool> highContrast, bool systemHighContrast, object parameter, CultureInfo culture);
}
public class Microsoft.VisualStudio.Imaging.ActualImageLibraryConverter : MultiValueConverter`3<ImageLibrary, ImageLibrary, ImageLibrary> {
    public static ActualImageLibraryConverter Instance;
    private static ActualImageLibraryConverter();
    protected virtual ImageLibrary Convert(ImageLibrary library, ImageLibrary fallbackLibrary, object parameter, CultureInfo culture);
}
public class Microsoft.VisualStudio.Imaging.BitmapLocker : object {
    private Bitmap _bitmap;
    private BitmapData _bitmapData;
    public Bitmap Bitmap { get; }
    public BitmapData BitmapData { get; }
    public BitmapLocker(Bitmap bitmap);
    public BitmapLocker(Bitmap bitmap, ImageLockMode mode);
    public BitmapLocker(Bitmap bitmap, ImageLockMode mode, Rectangle rect);
    public Bitmap get_Bitmap();
    public BitmapData get_BitmapData();
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.Imaging.BitmapSourceDescriptor : CustomImageDescriptor {
    private BitmapSource _bitmap;
    public BitmapSourceDescriptor(BitmapSource bitmap);
    protected virtual BitmapSource LoadManagedImage(JoinableTaskFactory jtf, Int16Size deviceSize);
}
internal class Microsoft.VisualStudio.Imaging.BubbleCountToTextConverter : MultiValueConverter`3<int, int, string> {
    protected virtual string Convert(int count, int maxCount, object parameter, CultureInfo culture);
}
internal class Microsoft.VisualStudio.Imaging.BubbleCountToVisibilityConverter : ValueConverter`2<int, Visibility> {
    protected virtual Visibility Convert(int count, object parameter, CultureInfo culture);
}
internal class Microsoft.VisualStudio.Imaging.BubbleHeightConverter : MultiValueConverter`3<double, Thickness, double> {
    protected virtual double Convert(double fontHeight, Thickness borderThickness, object parameter, CultureInfo culture);
}
[DefaultMemberAttribute("Item")]
internal abstract class Microsoft.VisualStudio.Imaging.BundleCollection`1 : object {
    private ImmutableList`1<T> _bundles;
    private static int SerializationVersion;
    public int Count { get; }
    public T Item { get; }
    protected BundleCollection`1(VersionedBinaryReader reader);
    internal void Serialize(VersionedBinaryWriter writer);
    protected abstract virtual T CreateBundleForSearch(ImageMoniker moniker);
    public int get_Count();
    public T get_Item(int index);
    public bool Contains(ImageMoniker moniker);
    public bool Contains(T item);
    public int IndexOf(ImageMoniker moniker);
    public int IndexOf(T item);
    public sealed virtual bool TryGetBundle(ImageMoniker moniker, T& bundle);
    public int Insert(T item);
    public IEnumerable`1<T> InsertRange(IEnumerable`1<T> items);
    public bool Remove(ImageMoniker moniker);
    public virtual string ToString();
    [ConditionalAttribute("DEBUG")]
private void AssertSorted();
    public sealed virtual IEnumerable`1<ImageMoniker> GetMonikers();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Imaging.CodeMarkerUtilities : object {
    public static Byte[] BuildRealizedImagePayload(ImageMoniker moniker, ImageAttributes attributes, SourceDescriptor source, bool canTheme);
    public static Byte[] BuildFetchedImagePayload(ImageMoniker moniker, ImageAttributes attributes);
    public static Byte[] BuildFetchedImagePayload(ImageMoniker moniker, ImageAttributes attributes, string filename);
    private static Byte[] Concatenate(Byte[][] payloadChunks);
    private static Byte[] Concatenate(IEnumerable`1<Byte[]> payloadChunks);
    [ExtensionAttribute]
private static Byte[] MakePayload(T value);
    [ExtensionAttribute]
private static Byte[] MakePayload(string value);
    [ExtensionAttribute]
private static Byte[] MakePayload(Guid value);
    [ExtensionAttribute]
private static Byte[] MakePayload(UInt32 value);
    [ExtensionAttribute]
private static Byte[] MakePayload(ulong value);
    private static int AppendPayloadChunk(Byte[] chunk, Byte[] payload, int offset);
}
internal class Microsoft.VisualStudio.Imaging.ColorSwatch : Control {
    public static DependencyProperty ColorProperty;
    public Color Color { get; public set; }
    private static ColorSwatch();
    public Color get_Color();
    public void set_Color(Color value);
}
internal class Microsoft.VisualStudio.Imaging.ColorToBrushConverter : ValueConverter`2<Color, Brush> {
    protected virtual Brush Convert(Color color, object parameter, CultureInfo culture);
}
internal class Microsoft.VisualStudio.Imaging.ColorToTextConverter : ValueConverter`2<Color, string> {
    protected virtual string Convert(Color color, object parameter, CultureInfo culture);
}
internal class Microsoft.VisualStudio.Imaging.CompositeImageBundle : ImageBundle {
    private ImageCompositionLayer[] _layers;
    private Int16Size _virtualSize;
    public CompositeImageBundle(ImageMoniker moniker, Int16Size virtualSize, ImageCompositionLayer[] layers);
    protected virtual object RealizeNativeFormatResource(ImageLibrary library, ImageAttributes attributes);
    private static BitmapSource DetectAndRemoveOptOutPixel(BitmapSource source, Boolean& canTheme);
    private static Alignment AlignmentFromHorizontal(UInt32 horizontalAlignment);
    private static Alignment AlignmentFromVertical(UInt32 verticalAlignment);
    private static int Align(int deviceOffset, int deviceLayerSize, int deviceImageSize, Alignment alignment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Imaging.ContrastEvaluator : DisposableObject {
    private static byte AllowedBackgroundChannelVariance;
    private static ReusableArray`1<byte> AntiAntiAliasingBuffer;
    private int byteCount;
    private PixelBuffer pixels;
    private int width;
    private int height;
    private int stride;
    private SimpleColor background;
    private byte minimumContrastEvaluationAlpha;
    private double minimumPassingPixelRatio;
    private double minimumContrastRatio;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReusableResourceHolder`1<Byte[]> antiAntiAliasingBufferHolder;
    private Lazy`1<PixelBuffer> antiAntiAliasingBufferLazy;
    public ContrastEvaluator(Byte[] pixels, int width, int height, SimpleColor background, byte minimumContrastEvaluationAlpha, double minimumPassingPixelRatio, double minimumContrastRatio);
    private static ContrastEvaluator();
    public void HighlightEdgePixels();
    public void HighlightLowContrastPixels();
    public bool ImageHasSufficientContrast();
    protected virtual void DisposeManagedResources();
    private void HighlightPixel(int i);
    private bool HasSufficientContrast(int i);
    private SimpleColor GetColor(int i);
    private bool IsOnEdgeOrAdjacentToBackgroundPixel(int i);
    private bool IsBackgroundPixelOrOutOfBounds(int i);
    private bool IsBackgroundPixel(int i);
    private byte Alpha(int i);
    private bool IsOutOfBounds(int i);
    private int Above(int i);
    private int Below(int i);
    private int LeftOf(int i);
    private int RightOf(int i);
    private bool IsCloseToBackground(SimpleColor color);
    private PixelBuffer RemoveAntiAliasing();
    private bool IsAntiAliasingSequence(SimpleColor[] pixels);
    private SimpleColor[] ChangeMiddleValueToBackground(SimpleColor[] pixels);
}
public class Microsoft.VisualStudio.Imaging.Converters.ImageMonikerToCrispImageConverter : ValueConverter`2<ImageMoniker, CrispImage> {
    protected virtual CrispImage Convert(ImageMoniker source, object parameter, CultureInfo culture);
}
public class Microsoft.VisualStudio.Imaging.CrispImage : Image {
    private static ImageLibrary _defaultImageLibrary;
    [CompilerGeneratedAttribute]
private static EventHandler Created;
    [CompilerGeneratedAttribute]
private static EventHandler DefaultImageLibraryChanged;
    public static PropertyInfo DefaultImageLibraryProperty;
    [CompilerGeneratedAttribute]
private static double <DefaultDpi>k__BackingField;
    public static DependencyProperty ActualDpiProperty;
    public static DependencyProperty ActualImageLibraryProperty;
    public static DependencyProperty ActualGrayscaleBiasColorProperty;
    public static DependencyProperty ActualHighContrastProperty;
    public static DependencyProperty DpiProperty;
    public static DependencyProperty GrayscaleProperty;
    public static DependencyProperty GrayscaleBiasColorProperty;
    public static DependencyProperty HighContrastProperty;
    public static DependencyProperty ImageLibraryProperty;
    internal static DependencyProperty InternalMonikerProperty;
    public static DependencyProperty MonikerProperty;
    public static DependencyProperty ScaleFactorProperty;
    public static DependencyProperty ShowDiagnosticToolTipProperty;
    public static DependencyProperty SystemHighContrastProperty;
    public static ImageLibrary DefaultImageLibrary { get; public set; }
    public static double DefaultDpi { get; }
    public double ActualDpi { get; }
    public ImageLibrary ActualImageLibrary { get; }
    public Color ActualGrayscaleBiasColor { get; }
    public bool ActualHighContrast { get; }
    public bool Grayscale { get; public set; }
    internal ImageMoniker InternalMoniker { get; }
    public ImageMoniker Moniker { get; public set; }
    public bool SystemHighContrast { get; }
    private static CrispImage();
    [CompilerGeneratedAttribute]
public static void add_Created(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_Created(EventHandler value);
    [CompilerGeneratedAttribute]
public static void add_DefaultImageLibraryChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_DefaultImageLibraryChanged(EventHandler value);
    public static ImageLibrary get_DefaultImageLibrary();
    public static void set_DefaultImageLibrary(ImageLibrary value);
    [CompilerGeneratedAttribute]
public static double get_DefaultDpi();
    public double get_ActualDpi();
    public ImageLibrary get_ActualImageLibrary();
    public Color get_ActualGrayscaleBiasColor();
    public bool get_ActualHighContrast();
    public static double GetDpi(DependencyObject element);
    public static void SetDpi(DependencyObject element, double value);
    public bool get_Grayscale();
    public void set_Grayscale(bool value);
    public static Nullable`1<Color> GetGrayscaleBiasColor(DependencyObject element);
    public static void SetGrayscaleBiasColor(DependencyObject element, Nullable`1<Color> value);
    public static Nullable`1<bool> GetHighContrast(DependencyObject element);
    public static void SetHighContrast(DependencyObject element, Nullable`1<bool> value);
    public static ImageLibrary GetImageLibrary(DependencyObject element);
    public static void SetImageLibrary(DependencyObject element, ImageLibrary value);
    internal ImageMoniker get_InternalMoniker();
    public ImageMoniker get_Moniker();
    public void set_Moniker(ImageMoniker value);
    public static double GetScaleFactor(DependencyObject element);
    public static void SetScaleFactor(DependencyObject element, double value);
    public static bool GetShowDiagnosticToolTip(DependencyObject element);
    public static void SetShowDiagnosticToolTip(DependencyObject element, bool value);
    public bool get_SystemHighContrast();
    private static void OnImageLibraryCreated(object sender, EventArgs e);
    private static void OnImageLibraryDisposed(object sender, EventArgs e);
    private void DisplayDpiChanged(object sender, RoutedEventArgs e);
    private void InitializeBindings();
    private void InitializeLibraryBindings();
    private void InitializeDpiBindings();
    private void InitializeGrayscaleBiasColorBindings();
    private void InitializeHighContrastBindings();
    private void InitializeMonikerBindings();
}
internal class Microsoft.VisualStudio.Imaging.CrispImageSourceConverter : MultiValueConverter`12<ImageLibrary, ImageMoniker, double, double, Color, bool, Color, bool, double, double, bool, ImageSource> {
    protected virtual ImageSource Convert(ImageLibrary library, ImageMoniker moniker, double logicalWidth, double logicalHeight, Color background, bool grayscale, Color biasColor, bool highContrast, double dpi, double scaleFactor, bool isLibraryInitialized, object parameter, CultureInfo culture);
    internal static ImageSource ConvertCore(ImageLibrary library, ImageMoniker moniker, double logicalWidth, double logicalHeight, Color background, bool grayscale, Color biasColor, bool highContrast, double dpi, double scaleFactor);
    private static bool ValidateDimensions(double logicalWidth, double logicalHeight, double logicalMin, double logicalMax);
}
internal class Microsoft.VisualStudio.Imaging.CrispImageToolTip : ToolTip {
    private static CrispImageToolTip();
}
public class Microsoft.VisualStudio.Imaging.CrispImageWithCount : Control {
    public static DependencyProperty BubbleBorderBrushProperty;
    public static DependencyProperty BubbleBorderThicknessProperty;
    private static Brush DefaultBubbleBackgroundBrush;
    public static DependencyProperty BubbleBackgroundProperty;
    private static Brush DefaultBubbleForegroundBrush;
    public static DependencyProperty BubbleForegroundProperty;
    public static DependencyProperty CountProperty;
    public static DependencyProperty GrayscaleProperty;
    private static double DefaultImageHeight;
    public static DependencyProperty ImageHeightProperty;
    private static double DefaultImageWidth;
    public static DependencyProperty ImageWidthProperty;
    public static DependencyProperty MaxCountProperty;
    public static DependencyProperty MonikerProperty;
    private static VerticalAlignment DefaultVerticalBubbleAlignment;
    public static DependencyProperty VerticalBubbleAlignmentProperty;
    public Brush BubbleBorderBrush { get; public set; }
    public Thickness BubbleBorderThickness { get; public set; }
    public Brush BubbleBackground { get; public set; }
    public Brush BubbleForeground { get; public set; }
    public int Count { get; public set; }
    public bool Grayscale { get; public set; }
    public double ImageHeight { get; public set; }
    public double ImageWidth { get; public set; }
    public int MaxCount { get; public set; }
    public ImageMoniker Moniker { get; public set; }
    public VerticalAlignment VerticalBubbleAlignment { get; public set; }
    private static CrispImageWithCount();
    public Brush get_BubbleBorderBrush();
    public void set_BubbleBorderBrush(Brush value);
    public Thickness get_BubbleBorderThickness();
    public void set_BubbleBorderThickness(Thickness value);
    public Brush get_BubbleBackground();
    public void set_BubbleBackground(Brush value);
    public Brush get_BubbleForeground();
    public void set_BubbleForeground(Brush value);
    public int get_Count();
    public void set_Count(int value);
    public bool get_Grayscale();
    public void set_Grayscale(bool value);
    public double get_ImageHeight();
    public void set_ImageHeight(double value);
    private static bool IsValidImageDimension(object valueAsObject);
    public double get_ImageWidth();
    public void set_ImageWidth(double value);
    public int get_MaxCount();
    public void set_MaxCount(int value);
    public ImageMoniker get_Moniker();
    public void set_Moniker(ImageMoniker value);
    public VerticalAlignment get_VerticalBubbleAlignment();
    public void set_VerticalBubbleAlignment(VerticalAlignment value);
    private static object CoerceVerticalBubbleAlignment(DependencyObject d, object baseValue);
}
internal abstract class Microsoft.VisualStudio.Imaging.CustomImageDescriptor : SourceDescriptor {
    protected CustomImageDescriptor(Int16Size deviceSize);
    protected virtual Byte[] GetNativeResourceBytesCore();
    protected virtual void SerializeCore(VersionedBinaryWriter writer);
}
internal class Microsoft.VisualStudio.Imaging.DemandLoadBitmapSourceDescriptor : CustomImageDescriptor {
    private string _sourcePath;
    private Uri _sourceUri;
    public DemandLoadBitmapSourceDescriptor(string sourcePath, bool isSizeNeutral);
    protected virtual void DetermineDeviceSizes(Int16Size& minDeviceSize, Int16Size& maxDeviceSize);
    protected virtual BitmapSource LoadManagedImage(JoinableTaskFactory jtf, Int16Size deviceSize);
    [CompilerGeneratedAttribute]
private Int16Size <DetermineDeviceSizes>g__GetPngSize|3_0();
}
[ObsoleteAttribute("Use Microsoft.VisualStudio.Imaging.CrispImage instead.")]
public class Microsoft.VisualStudio.Imaging.Dpi.DpiPrescaleImageSourceConverter : ValueConverter`2<ImageSource, ImageSource> {
    protected DpiHelper DpiHelper { get; }
    protected virtual DpiHelper get_DpiHelper();
    protected virtual ImageSource Convert(ImageSource inputImage, object parameter, CultureInfo culture);
    internal static ImageSource InternalConvert(ImageSource inputImage);
}
[ObsoleteAttribute("Use Microsoft.VisualStudio.Imaging.CrispImage instead.")]
public class Microsoft.VisualStudio.Imaging.Dpi.DpiPrescaleThemedImageConverter : MultiValueConverter`4<ImageSource, Color, bool, Image> {
    protected DpiHelper DpiHelper { get; }
    protected virtual DpiHelper get_DpiHelper();
    protected virtual Image Convert(ImageSource inputImage, Color backgroundColor, bool isEnabled, object parameter, CultureInfo culture);
    protected Image Convert(ImageSource inputImage, Color backgroundColor, bool isEnabled, bool isHighContrast, object parameter, CultureInfo culture);
}
[ObsoleteAttribute("Use Microsoft.VisualStudio.Imaging.CrispImage instead.")]
public class Microsoft.VisualStudio.Imaging.Dpi.DpiPrescaleThemedImageSourceConverter : MultiValueConverter`4<ImageSource, Color, bool, ImageSource> {
    protected DpiHelper DpiHelper { get; }
    protected virtual DpiHelper get_DpiHelper();
    protected virtual ImageSource Convert(ImageSource inputImage, Color backgroundColor, bool isEnabled, object parameter, CultureInfo culture);
    internal static ImageSource InternalConvert(ImageSource inputImage, Color backgroundColor, bool isEnabled, object parameter, CultureInfo culture);
    internal static ImageSource InternalConvert(ImageSource inputImage, Color backgroundColor, bool isEnabled, bool isHighContrast, object parameter, CultureInfo culture);
}
internal class Microsoft.VisualStudio.Imaging.DrawingImageDescriptor : CustomImageDescriptor {
    private DrawingImage _image;
    public DrawingImageDescriptor(DrawingImage image);
    protected virtual BitmapSource LoadManagedImage(JoinableTaskFactory jtf, Int16Size deviceSize);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Imaging.ExtensionMethods : object {
    [ExtensionAttribute]
public static bool IsNullImage(ImageMoniker moniker);
    [ExtensionAttribute]
public static string ToStringEx(ImageMoniker moniker);
    [ExtensionAttribute]
public static string ToStringEx(ImageMoniker moniker, string format);
    [ExtensionAttribute]
internal static ImageMoniker ToInternalType(ImageMoniker moniker);
    [ExtensionAttribute]
internal static ImageAttributes ToInternalType(ImageAttributes attributes);
    [ExtensionAttribute]
private static double GetDpi(ImageAttributes attributes);
    [ExtensionAttribute]
private static ImageFormat ToImageFormat(_UIDataFormat format);
    [ExtensionAttribute]
private static ImageKind ToImageKind(_UIImageType imageType, _UIDataFormat format);
    private static Color ComputeBackground(UInt32 vsBackground);
}
public class Microsoft.VisualStudio.Imaging.HslColor : ValueType {
    private static double ByteMaxAsDouble;
    private static double MinAlpha;
    private static double MaxAlpha;
    private static double MinHue;
    private static double MaxHue;
    private static double MinSaturation;
    private static double MaxSaturation;
    private static double MinLuminosity;
    private static double MaxLuminosity;
    private double _hue;
    private double _saturation;
    private double _luminosity;
    private double _alpha;
    public double Hue { get; public set; }
    public double Saturation { get; public set; }
    public double Luminosity { get; public set; }
    public double Alpha { get; public set; }
    public HslColor(double hue, double saturation, double luminosity);
    public HslColor(double hue, double saturation, double luminosity, double alpha);
    public double get_Hue();
    public void set_Hue(double value);
    public double get_Saturation();
    public void set_Saturation(double value);
    public double get_Luminosity();
    public void set_Luminosity(double value);
    public double get_Alpha();
    public void set_Alpha(double value);
    public static HslColor FromColor(Color color);
    internal static HslColor FromSimpleColor(SimpleColor color);
    private static HslColor FromARGB(byte a, byte r, byte g, byte b);
    public Color ToColor();
    internal SimpleColor ToSimpleColor();
    private ValueTuple`4<byte, byte, byte, byte> ToARGB();
    private static double ModOne(double value);
    private static double ComputeRGBComponent(double p, double q, double tC);
    private static double LimitRange(double value, double min, double max);
}
internal interface Microsoft.VisualStudio.Imaging.IBundleCollection`1 {
    public abstract virtual IEnumerable`1<ImageMoniker> GetMonikers();
    public abstract virtual bool TryGetBundle(ImageMoniker moniker, T& bundle);
}
internal class Microsoft.VisualStudio.Imaging.ImageAttributes : ValueType {
    private Nullable`1<Color> _grayscaleBiasColor;
    private byte _packedFields;
    private static byte KindMask;
    private static int KindShift;
    private static byte FormatMask;
    private static int FormatShift;
    private static byte GrayscaleMask;
    private static int GrayscaleShift;
    private static byte HighContrastMask;
    private static int HighContrastShift;
    public Int16Size DeviceSize;
    public Nullable`1<Color> Background;
    public ImageKind Kind { get; public set; }
    public ImageFormat Format { get; public set; }
    public bool Grayscale { get; public set; }
    public Color GrayscaleBiasColor { get; public set; }
    public bool HighContrast { get; public set; }
    public bool EnhanceContrastIfNecessary { get; }
    public bool HasLightBackground { get; }
    public bool HasDarkBackground { get; }
    public ImageAttributes(Int16Size deviceSize);
    public ImageAttributes(Int16Size deviceSize, ImageKind kind, ImageFormat format);
    public ImageAttributes(Int16Size deviceSize, ImageKind kind, ImageFormat format, Nullable`1<Color> background, bool grayscale, Color grayscaleBiasColor, bool highContrast);
    public ImageKind get_Kind();
    public void set_Kind(ImageKind value);
    public ImageFormat get_Format();
    public void set_Format(ImageFormat value);
    public bool get_Grayscale();
    public void set_Grayscale(bool value);
    public Color get_GrayscaleBiasColor();
    public void set_GrayscaleBiasColor(Color value);
    public bool get_HighContrast();
    public void set_HighContrast(bool value);
    public bool get_EnhanceContrastIfNecessary();
    public bool get_HasLightBackground();
    public bool get_HasDarkBackground();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public static bool op_Equality(ImageAttributes attr1, ImageAttributes attr2);
    public static bool op_Inequality(ImageAttributes attr1, ImageAttributes attr2);
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(ImageAttributes other);
    private int GetPackedValue(byte mask, int shift);
    private void SetPackedValue(byte mask, int shift, byte value);
}
internal class Microsoft.VisualStudio.Imaging.ImageAttributeTuple : object {
    [CompilerGeneratedAttribute]
private object <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCached>k__BackingField;
    public object Image { get; public set; }
    public ImageAttributes Attributes { get; public set; }
    public bool IsCached { get; public set; }
    public bool ShouldBeCached { get; }
    [CompilerGeneratedAttribute]
public object get_Image();
    [CompilerGeneratedAttribute]
public void set_Image(object value);
    [CompilerGeneratedAttribute]
public ImageAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(ImageAttributes value);
    [CompilerGeneratedAttribute]
public bool get_IsCached();
    [CompilerGeneratedAttribute]
public void set_IsCached(bool value);
    public bool get_ShouldBeCached();
}
internal abstract class Microsoft.VisualStudio.Imaging.ImageBundle : ResourceBundle {
    protected static ImageFormat NativeFormat;
    protected static ImageKind NativeKind;
    protected ImageBundle(ImageMoniker moniker);
    protected ImageBundle(VersionedBinaryReader reader);
    public static ImageBundle CreateBundleForSearch(ImageMoniker moniker);
    [ConditionalAttribute("TRACE")]
public void Trace(ITracer tracer, TraceEventType eventType);
    protected virtual void TraceCore(ITracer tracer, TraceEventType eventType);
    public virtual RealizedImageInformation GetImage(ImageLibrary library, ImageAttributes attributes);
    protected virtual Type GetExpectedImageType(ImageAttributes attributes);
}
internal class Microsoft.VisualStudio.Imaging.ImageBundleCollection : BundleCollection`1<ImageBundle> {
    private ImageBundleCollection(VersionedBinaryReader reader);
    internal static ImageBundleCollection Deserialize(VersionedBinaryReader reader);
    protected virtual ImageBundle CreateBundleForSearch(ImageMoniker moniker);
}
internal class Microsoft.VisualStudio.Imaging.ImageCacheEventArgs : EventArgs {
    private ImageMoniker _moniker;
    private ImageAttributes _attributes;
    private object _image;
    public ImageMoniker Moniker { get; }
    public ImageAttributes Attributes { get; }
    public object Image { get; }
    public ImageCacheEventArgs(ImageMoniker moniker, ImageAttributes attributes, object image);
    public ImageMoniker get_Moniker();
    public ImageAttributes get_Attributes();
    public object get_Image();
}
public static class Microsoft.VisualStudio.Imaging.ImageConverter : object {
    private static ReusableMemoryStream reusableMemoryStream;
    private static ImageConverter();
    public static BitmapSource BitmapSourceFromBitmap(Bitmap bitmap);
    public static Bitmap BitmapFromBitmapSource(BitmapSource bitmapSource);
    public static IntPtr HiconFromBitmapSource(BitmapSource bitmapSource);
    public static Byte[] ExtractPixelSection(Byte[] sourcePixels, int sourceBitsPerPixel, int sourceStride, Int32Rect sectionRect);
    public static Byte[] ExtractPixelSection(Byte[] sourcePixels, int sourceBitsPerPixel, int sourceStride, Int32Rect sectionRect, Color[] transparentColors);
}
internal class Microsoft.VisualStudio.Imaging.ImageEntry : object {
    private object _imageOrImageReference;
    [CompilerGeneratedAttribute]
private ImageAttributes <Attributes>k__BackingField;
    private object ImageOrImageReference { get; private set; }
    private WeakReference`1<object> WeakImage { get; }
    public ImageAttributes Attributes { get; }
    public object Image { get; }
    public bool IsCollected { get; }
    public ImageEntry(ImageAttributes attributes, object image, ReferenceKind refKind);
    private object get_ImageOrImageReference();
    private void set_ImageOrImageReference(object value);
    private WeakReference`1<object> get_WeakImage();
    [CompilerGeneratedAttribute]
public ImageAttributes get_Attributes();
    public object get_Image();
    public bool get_IsCollected();
    public bool IsImageValid();
    public void SetImage(object image, ReferenceKind refKind);
    public virtual string ToString();
    private void SetWrappedImage(object wrappedImage, ReferenceKind refKind);
    private object GetWrappedImage();
    private static object WrapImage(ImageAttributes attributes, object image);
    private static object UnwrapImage(object image);
}
internal class Microsoft.VisualStudio.Imaging.ImageEntryCollection : object {
    private ImmutableList`1<ImageEntry> _entries;
    public int Count { get; }
    public int get_Count();
    public void SetImage(ImageAttributes attributes, object image, ReferenceKind referenceKind);
    public bool TryGetImage(ImageAttributes attributes, Object& image);
    private ImageEntry FindEntry(ImageAttributes attributes, bool returnCollectedEntry);
    private static void ValidateImageType(object image, ImageFormat format, ImageKind kind);
}
public class Microsoft.VisualStudio.Imaging.ImageEventArgs : EventArgs {
    private ImageMoniker _moniker;
    private string _manifestFilename;
    private Guid _packageGuid;
    public ImageMoniker Moniker { get; }
    public string ManifestFilename { get; }
    public Guid PackageGuid { get; }
    public ImageEventArgs(ImageMoniker moniker, string manifestFilename, Guid packageGuid);
    public ImageMoniker get_Moniker();
    public string get_ManifestFilename();
    public Guid get_PackageGuid();
}
public enum Microsoft.VisualStudio.Imaging.ImageFormat : Enum {
    public int value__;
    public static ImageFormat WPF;
    public static ImageFormat WinForms;
    public static ImageFormat Win32;
}
public enum Microsoft.VisualStudio.Imaging.ImageKind : Enum {
    public int value__;
    public static ImageKind Bitmap;
    public static ImageKind Icon;
    public static ImageKind ImageList;
}
[GuidAttribute("8fa80f44-0b82-4a81-9264-ca9e36fa70e4")]
public class Microsoft.VisualStudio.Imaging.ImageLibrary : DisposableObject {
    public static Int16Size NeutralSize;
    public static Int16Size UnknownSize;
    public static Color DefaultGrayscaleBiasColor;
    public static Color HighContrastGrayscaleBiasColor;
    public static ImageMoniker InvalidImageMoniker;
    internal static ImageMoniker PlaceholderImageMoniker;
    internal static Color DefaultDebugColor;
    internal static Color DefaultAlternateDebugColor;
    private static Encoding DefaultSerializationEncoding;
    internal static string XamlFileExtension;
    internal static string PngFileExtension;
    private static String[] SupportedFileTypes;
    private ImageBundleCollection _imageBundles;
    private ImageListBundleCollection _imageListBundles;
    private Lazy`1<WeakBundleCollection`1<ImageBundle>> _customImageBundles;
    private Lazy`1<WeakBundleCollection`1<ImageListBundle>> _customImageListBundles;
    private List`1<ManifestDescriptor> _manifestDescriptors;
    private Lazy`1<IReadOnlyList`1<ManifestDescriptor>> _manifestDescriptorsRO;
    private ITracer _tracer;
    internal Guid CustomMonikerGuid;
    private int _lastCustomImageId;
    private static int DictionaryConcurrencyLevel;
    private static int DictionaryInitialCapacity;
    private Lazy`1<IDictionary`2<string, ImageBundle>> _extensionToBundleMap;
    private Lazy`1<IDictionary`2<string, ImageBundle>> _progIdToBundleMap;
    private static ReusableStringBuilder _reusableBuilder;
    private bool _initialized;
    [CompilerGeneratedAttribute]
private static EventHandler ImageLibraryCreated;
    [CompilerGeneratedAttribute]
private static EventHandler ImageLibraryDisposed;
    [CompilerGeneratedAttribute]
private EventHandler InitializedChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<TelemetryEventArgs> BuildLibraryCache;
    [CompilerGeneratedAttribute]
private EventHandler`1<TelemetryEventArgs> ProcessManifest;
    private static int SerializationVersion;
    private static string StreamMarker;
    [CompilerGeneratedAttribute]
private bool <DebugMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <DebugColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <AlternateDebugColor>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImageLibrary <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseAsyncCrispImageConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private JoinableTaskFactory <JoinableTaskFactory>k__BackingField;
    public EventHandler`1<ImageEventArgs> BeforeImageRealized;
    internal EventHandler`1<ImageCacheEventArgs> AfterImageRealized;
    public bool Initialized { get; private set; }
    public ITracer Tracer { get; }
    internal int LastCustomImageId { get; }
    internal IReadOnlyList`1<ManifestDescriptor> ManifestDescriptors { get; }
    public bool DebugMode { get; public set; }
    public Color DebugColor { get; public set; }
    public Color AlternateDebugColor { get; public set; }
    public static ImageLibrary Default { get; internal set; }
    public bool UseAsyncCrispImageConverter { get; public set; }
    internal JoinableTaskFactory JoinableTaskFactory { get; }
    public ImageLibrary(JoinableTaskFactory jtf, bool isDefault, ITracer tracer);
    private ImageLibrary(JoinableTaskFactory jtf, Stream stream, bool isDefault, ITracer tracer);
    private static ImageLibrary();
    [CompilerGeneratedAttribute]
public static void add_ImageLibraryCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ImageLibraryCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public static void add_ImageLibraryDisposed(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ImageLibraryDisposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_InitializedChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_InitializedChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_BuildLibraryCache(EventHandler`1<TelemetryEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BuildLibraryCache(EventHandler`1<TelemetryEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ProcessManifest(EventHandler`1<TelemetryEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessManifest(EventHandler`1<TelemetryEventArgs> value);
    protected virtual void DisposeManagedResources();
    public void Serialize(Stream stream);
    public static ImageLibrary Deserialize(JoinableTaskFactory jtf, Stream stream, bool isDefault, ITracer tracer);
    public bool get_Initialized();
    private void set_Initialized(bool value);
    public int GetImageCount();
    internal int GetCustomImageCount();
    public int GetImageListCount();
    internal int GetCustomImageListCount();
    public IEnumerable`1<ImageMoniker> GetImageMonikers();
    public IEnumerable`1<ImageMoniker> GetImageListMonikers();
    public ITracer get_Tracer();
    internal int get_LastCustomImageId();
    internal IReadOnlyList`1<ManifestDescriptor> get_ManifestDescriptors();
    [CompilerGeneratedAttribute]
public bool get_DebugMode();
    [CompilerGeneratedAttribute]
public void set_DebugMode(bool value);
    [CompilerGeneratedAttribute]
public Color get_DebugColor();
    [CompilerGeneratedAttribute]
public void set_DebugColor(Color value);
    [CompilerGeneratedAttribute]
public Color get_AlternateDebugColor();
    [CompilerGeneratedAttribute]
public void set_AlternateDebugColor(Color value);
    [CompilerGeneratedAttribute]
public static ImageLibrary get_Default();
    [CompilerGeneratedAttribute]
internal static void set_Default(ImageLibrary value);
    [CompilerGeneratedAttribute]
public bool get_UseAsyncCrispImageConverter();
    [CompilerGeneratedAttribute]
public void set_UseAsyncCrispImageConverter(bool value);
    [CompilerGeneratedAttribute]
internal JoinableTaskFactory get_JoinableTaskFactory();
    public static ImageLibrary Load(JoinableTaskFactory jtf, string manifest, bool isDefault, ITracer tracer);
    public static ImageLibrary Load(JoinableTaskFactory jtf, string manifest, bool preloadResources, bool isDefault, ITracer tracer);
    internal static ImageLibrary Load(JoinableTaskFactory jtf, string manifest, bool isDefault, bool preloadResources, ITracer tracer, ProcessedManifest& processedManifest);
    public static ImageLibrary Load(JoinableTaskFactory jtf, IEnumerable`1<string> manifests, bool isDefault, ITracer tracer);
    public static ImageLibrary Load(JoinableTaskFactory jtf, IEnumerable`1<string> manifests, bool preloadResources, bool isDefault, ITracer tracer);
    internal static ImageLibrary Load(JoinableTaskFactory jtf, IEnumerable`1<string> manifests, bool isDefault, bool preloadResources, ITracer tracer, List`1<ProcessedManifest> processedManifests);
    private ProcessedManifest Load(string manifest, ManifestReader reader);
    internal static void InsertRange(ProcessedManifest processedManifest, BundleCollection`1<T> collection, IEnumerable`1<T> bundlesToInsert);
    public object GetImage(ImageMoniker moniker, ImageAttributes attributes);
    internal object GetImage(ImageMoniker moniker, ImageAttributes attributes);
    private object GetImageCore(ImageMoniker moniker, ImageAttributes attributes, int beginCodeMarker, int endCodeMarker, string imageType, IBundleCollection`1[] collections);
    public UInt32 GetImageMonikerType(ImageMoniker moniker);
    public ImageMoniker[] GetImageListMonikers(ImageMoniker imageListMoniker);
    public void AddMonikerFormattingDescriptor(string name, Guid guid, Func`1<IReadOnlyDictionary`2<int, string>> imageNameMapFactory);
    public void ResetFormattingDescriptors();
    public IImageHandle AddCustomCompositeImage(Int16Size virtualSize, ImageCompositionLayer[] layers);
    internal IImageHandle AddCustomImage(string uriString, Int16Size size, bool canTheme);
    public IImageHandle AddCustomImage(ImageSource bitmap, bool canTheme);
    private IImageHandle AddCustomImage(SourceDescriptor source, bool canTheme);
    public IImageHandle AddCustomImage(IEnumerable`1<string> sources, bool canTheme);
    private void AddCustomImage(ImageBundle bundle);
    public bool RemoveCustomImage(IImageHandle handle);
    internal bool RemoveCustomImage(ImageMoniker moniker);
    public IImageHandle AddCustomImageList(ImageMoniker[] imageEntryMonikers);
    internal IImageHandle AddCustomImageList(ImageMoniker[] imageEntryMonikers);
    public bool RemoveCustomImageList(IImageHandle handle);
    internal bool RemoveCustomImageList(ImageMoniker moniker);
    public bool TryGetMonikerForExtension(string extension, bool canTheme, ImageMoniker& moniker);
    internal bool TryGetBundleForExtension(string extension, bool canTheme, ImageBundle& bundle);
    public bool TryGetMonikerForProgId(string progId, bool canTheme, ImageMoniker& moniker);
    internal bool TryGetBundleForProgId(string progId, bool canTheme, ImageBundle& bundle);
    internal void RaiseBeforeImageRealized(ResourceBundle bundle);
    internal void RaiseAfterImageRealized(ImageMoniker moniker, ImageAttributes attributes, object image);
    internal bool IsCustomImageMoniker(ImageMoniker moniker);
    private bool TryAddImageBundleForProgId(string progId, bool canTheme, ImageBundle& bundle);
    private ImageMoniker GenerateCustomImageMoniker(bool canDelete);
    private bool CanDeleteMoniker(ImageMoniker moniker);
    private static string TryGetProgIdForExtension(string extension);
    private static string GetDefaultIconResource(string progId);
    private static bool TryParseIconLocation(string resource, String& filename, Int32& index);
    internal bool TryGetBundle(ImageMoniker moniker, ImageBundle& bundle);
    internal bool TryGetBundle(ImageMoniker moniker, ImageListBundle& bundle);
    private bool TryGetBundle(ImageMoniker moniker, T& bundle, IBundleCollection`1[] collections);
    private IEnumerable`1<ImageMoniker> ConcatCollections(IBundleCollection`1[] collections);
    internal static ReusableResourceHolder`1<StringBuilder> AcquireStringBuilder();
    private static IDisposable TelemetryBlock(object sender, EventHandler`1<TelemetryEventArgs> handler, string context);
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ManifestDescriptor> <.ctor>b__42_0();
}
internal class Microsoft.VisualStudio.Imaging.ImageListBundle : ResourceBundle {
    private static ImageKind NativeKind;
    private ImageMoniker[] _imageEntryMonikers;
    private static int SerializationVersion;
    internal ImageMoniker[] ImageEntryMonikers { get; }
    internal int ImageEntryCount { get; }
    public ImageListBundle(ImageMoniker imageListMoniker, ImageMoniker[] imageEntryMonikers);
    private ImageListBundle(ImageMoniker moniker);
    internal ImageListBundle(VersionedBinaryReader reader);
    protected virtual void SerializeCore(VersionedBinaryWriter writer);
    internal ImageMoniker[] get_ImageEntryMonikers();
    internal int get_ImageEntryCount();
    public static ImageListBundle CreateBundleForSearch(ImageMoniker moniker);
    public virtual RealizedImageInformation GetImage(ImageLibrary library, ImageAttributes attributes);
    protected virtual Type GetExpectedImageType(ImageAttributes attributes);
    protected virtual object RealizeNativeFormatResource(ImageLibrary library, ImageAttributes attributes);
    private TBitmap[] GetImagesForImageList(ImageLibrary library, ImageAttributes attributes, Func`4<ImageLibrary, ImageMoniker, ImageAttributes, TBitmap> imageCreator);
    private static Bitmap GetDrawingBitmap(ImageLibrary library, ImageMoniker moniker, ImageAttributes attributes);
    private static Win32Bitmap GetWin32Bitmap(ImageLibrary library, ImageMoniker moniker, ImageAttributes attributes);
    private object CreateWinFormsImageList(Int16Size size, Bitmap[] bitmaps);
    private object CreateWin32ImageList(Int16Size size, Win32Bitmap[] bitmaps);
    private static IntPtr CreateAlmostTransparentImage(int pixelWidth, int pixelHeight);
    [ConditionalAttribute("TRACE")]
public void Trace(ITracer tracer, TraceEventType eventType);
}
internal class Microsoft.VisualStudio.Imaging.ImageListBundleCollection : BundleCollection`1<ImageListBundle> {
    private ImageListBundleCollection(VersionedBinaryReader reader);
    internal static ImageListBundleCollection Deserialize(VersionedBinaryReader reader);
    protected virtual ImageListBundle CreateBundleForSearch(ImageMoniker moniker);
}
internal class Microsoft.VisualStudio.Imaging.ImageMoniker : ValueType {
    public Guid Guid;
    public int Id;
    public static char ImageMonikerSeparator;
    public static char AlternateImageMonikerSeparator;
    public static char FilenameImageMonikerSeparator;
    private static List`1<FormattingDescriptor> _formattingDescriptors;
    private static int SerializationVersion;
    public ImageMoniker(Guid guid, int id);
    private ImageMoniker(VersionedBinaryReader reader);
    private static ImageMoniker();
    internal void Serialize(VersionedBinaryWriter writer);
    internal static ImageMoniker Deserialize(VersionedBinaryReader reader);
    public virtual string ToString();
    public string ToString(string format);
    public ImageMoniker ToInteropType();
    public static void AddFormattingDescriptor(string name, Guid guid, Func`1<IReadOnlyDictionary`2<int, string>> imageNameMapFactory);
    public static void ResetFormattingDescriptors();
    public static bool op_Equality(ImageMoniker moniker1, ImageMoniker moniker2);
    public static bool op_Inequality(ImageMoniker moniker1, ImageMoniker moniker2);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    private string FormatWithDescriptors();
    public virtual int GetHashCode();
    public static bool TryParse(string s, ImageMoniker& imageMoniker);
    public static bool TryParse(string s, Guid& imageGuid, Int32& imageId);
    public static bool op_Equality(ImageMoniker moniker1, ImageMoniker moniker2);
    public static bool op_Inequality(ImageMoniker moniker1, ImageMoniker moniker2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImageMoniker other);
    public sealed virtual int CompareTo(ImageMoniker other);
}
public class Microsoft.VisualStudio.Imaging.ImageMonikerConverter : MultiValueConverter`3<Guid, int, ImageMoniker> {
    protected virtual ImageMoniker Convert(Guid guid, int id, object parameter, CultureInfo culture);
    protected virtual void ConvertBack(ImageMoniker moniker, Guid& guid, Int32& id, object parameter, CultureInfo culture);
}
internal class Microsoft.VisualStudio.Imaging.ImageSizeConverter : MultiValueConverter`3<double, double, string> {
    protected virtual string Convert(double width, double height, object parameter, CultureInfo culture);
}
public static class Microsoft.VisualStudio.Imaging.ImagingUtilities : object {
    public static bool TryParseImageMoniker(string s, ImageMoniker& moniker);
    public static string ConvertMonikerToString(ImageMoniker moniker);
    public static string ConvertMonikerToString(ImageMoniker moniker, string format);
    public static void ValidateImageAttributesFlags(_ImageAttributesFlags flags);
    public static void ValidateAttributes(ImageAttributes attributes);
    internal static void ValidateAttributes(ImageAttributes attributes);
    internal static void ValidateKind(ImageKind kind);
    internal static void ValidateFormat(ImageFormat format);
    internal static bool IsValidHICON(IntPtr hIcon);
    internal static bool IsValidHBITMAP(IntPtr hBitmap);
    internal static bool IsValidHIMAGELIST(IntPtr hImageList);
}
internal class Microsoft.VisualStudio.Imaging.InternalImageMonikerConverter : ValueConverter`2<ImageMoniker, ImageMoniker> {
    internal static InternalImageMonikerConverter Instance;
    private static InternalImageMonikerConverter();
    protected virtual ImageMoniker Convert(ImageMoniker moniker, object parameter, CultureInfo culture);
    protected virtual ImageMoniker ConvertBack(ImageMoniker moniker, object parameter, CultureInfo culture);
}
internal interface Microsoft.VisualStudio.Imaging.IStringTable {
    public int Capacity { get; }
    public abstract virtual int get_Capacity();
    public abstract virtual int Intern(string value);
    public abstract virtual string Get(int index);
}
public class Microsoft.VisualStudio.Imaging.ManifestDescriptor : ValueType {
    private string _filename;
    private Guid _packageGuid;
    private static int SerializationVersion;
    public string Filename { get; }
    public Guid PackageGuid { get; }
    public ManifestDescriptor(string filename, Guid packageGuid);
    private ManifestDescriptor(VersionedBinaryReader reader);
    public void Serialize(VersionedBinaryWriter writer);
    public static ManifestDescriptor Deserialize(VersionedBinaryReader reader);
    public string get_Filename();
    public Guid get_PackageGuid();
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(ManifestDescriptor d1, ManifestDescriptor d2);
    public static bool op_Inequality(ManifestDescriptor d1, ManifestDescriptor d2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ManifestDescriptor other);
}
public class Microsoft.VisualStudio.Imaging.ManifestParseException : Exception {
    public static XmlSeverityType DefaultSeverity;
    [CompilerGeneratedAttribute]
private XmlSeverityType <Severity>k__BackingField;
    public XmlSeverityType Severity { get; private set; }
    public ManifestParseException(XmlSeverityType severity);
    public ManifestParseException(Exception innerException);
    public ManifestParseException(XmlSeverityType severity, Exception innerException);
    public ManifestParseException(string message);
    public ManifestParseException(string message, XmlSeverityType severity);
    public ManifestParseException(string message, Exception innerException);
    public ManifestParseException(string message, XmlSeverityType severity, Exception innerException);
    [CompilerGeneratedAttribute]
public XmlSeverityType get_Severity();
    [CompilerGeneratedAttribute]
private void set_Severity(XmlSeverityType value);
}
internal class Microsoft.VisualStudio.Imaging.ManifestReader : object {
    private static Uri SchemaUri;
    internal static String[] BuiltInSymbolNames;
    private XmlReaderSettings _readerSettings;
    private HashSet`1<string> _alreadyProcessedManifests;
    private bool _preloadResources;
    public ManifestReader(bool preloadResources);
    private static ManifestReader();
    public ProcessedManifest Read(string manifestFile, ITracer tracer);
    internal ProcessedManifest Read(string manifestFile, ITracer tracer, bool symbolsOnly);
    internal ProcessedManifest Read(TextReader reader, string manifestFile, ITracer tracer, bool symbolsOnly);
    private void AddBuiltInSymbols(ProcessedManifest processedManifest, string manifestFile);
    private string AddEnvironmentSymbol(ProcessedManifest processedManifest, string variable);
    private void ProcessSymbols(ProcessedManifest processedManifest, Object[] symbols, ITracer tracer);
    private static void AddUserSymbol(ProcessedManifest processedManifest, KeyValuePair`2<string, object> entry);
    private KeyValuePair`2<string, object> ProcessSymbol(ProcessedManifest processedManifest, object symbol, ITracer tracer);
    private KeyValuePair`2<string, object> ImportSymbols(ProcessedManifest processedManifest, string manifestName, ITracer tracer);
    private static void ProcessImages(ProcessedManifest processedManifest, ImageManifestImage[] images, bool preloadResources);
    private static ImageBundle ProcessImage(ProcessedManifest processedManifest, ImageManifestImage image, bool preloadResources);
    private static ICollection`1<SourceDescriptor> ProcessSources(ProcessedManifest processedManifest, ImageManifestImageSource[] sources, bool preloadResources);
    private static SourceDescriptor ProcessSource(ProcessedManifest processedManifest, ImageManifestImageSource source, bool preloadResources);
    private static SourceBackground GetBackground(ImageManifestImageSource source);
    private static NativeResource ProcessNativeResource(ProcessedManifest processedManifest, ImageManifestImageSourceNativeResource element);
    private static void ProcessImageLists(ProcessedManifest processedManifest, ImageManifestImageList[] imageLists);
    private static ImageListBundle ProcessImageList(ProcessedManifest processedManifest, ImageManifestImageList imageList);
    private static ImageMoniker[] ProcessContainedImages(ProcessedManifest processedManifest, ImageMoniker imageListMoniker, ImageManifestImageListContainedImage[] containedImages);
    private static ImageMoniker ProcessContainedImage(ProcessedManifest processedManifest, ImageMoniker imageListMoniker, ImageManifestImageListContainedImage contained);
    private static void ProcessPackageGuid(ProcessedManifest processedManifest, string packageGuid);
    private static bool IsCatchableException(Exception ex);
    private static void ProcessManifestSection(ProcessedManifest processedManifest, Action action);
    private static TResult ProcessManifestElement(TElement element, Func`2<TElement, TResult> process);
    private static ImageMoniker CreateImageMoniker(ImageManifestImage image, ProcessedManifest processedManifest);
    private static ImageMoniker CreateImageMoniker(ImageManifestImageList imageList, ProcessedManifest processedManifest);
    private static ImageMoniker CreateImageMoniker(ImageManifestImageListContainedImage contained, ProcessedManifest processedManifest);
    private static ImageMoniker CreateImageMoniker(string guidString, string idString, ProcessedManifest processedManifest);
    private static XmlSchemaValidationException CreateSchemaValidationException(object obj, Exception innerException);
    private static string ToString(object obj);
    private static bool IsBuiltInSymbol(string symbol);
    private static bool IsUserSymbol(string symbol);
}
internal class Microsoft.VisualStudio.Imaging.MonikerAttributeTuple : ValueType {
    [CompilerGeneratedAttribute]
private ImageMoniker <Moniker>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageAttributes <Attributes>k__BackingField;
    public ImageMoniker Moniker { get; }
    public ImageAttributes Attributes { get; }
    public MonikerAttributeTuple(ImageMoniker moniker, ImageAttributes attributes);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ImageMoniker get_Moniker();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ImageAttributes get_Attributes();
    public static bool op_Equality(MonikerAttributeTuple tuple1, MonikerAttributeTuple tuple2);
    public static bool op_Inequality(MonikerAttributeTuple tuple1, MonikerAttributeTuple tuple2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MonikerAttributeTuple other);
    public virtual int GetHashCode();
}
internal class Microsoft.VisualStudio.Imaging.NativeResource : object {
    private NativeResourceIdentifier _id;
    private NativeResourceKind _kind;
    private Nullable`1<NativeResourceIdentifier> _mappedId;
    private static int SerializationVersion;
    [CompilerGeneratedAttribute]
private bool <IdIsIndex>k__BackingField;
    public NativeResourceIdentifier Id { get; }
    public NativeResourceKind Kind { get; public set; }
    public bool IdIsIndex { get; public set; }
    private NativeResourceIdentifier ResourceLookupType { get; }
    public NativeResource(int id, NativeResourceKind kind, bool idIsIndex);
    protected NativeResource(VersionedBinaryReader reader);
    internal void Serialize(VersionedBinaryWriter writer);
    internal static NativeResource Deserialize(VersionedBinaryReader reader);
    public NativeResourceIdentifier get_Id();
    public NativeResourceKind get_Kind();
    public void set_Kind(NativeResourceKind value);
    [CompilerGeneratedAttribute]
public bool get_IdIsIndex();
    [CompilerGeneratedAttribute]
public void set_IdIsIndex(bool value);
    private NativeResourceIdentifier get_ResourceLookupType();
    public Byte[] GetBytes(string filename);
    public BitmapSource LoadImageFromIcon(string filename, Int16Size size);
    public virtual string ToString();
    private NativeResourceIdentifier MapIndexToId(IntPtr moduleHandle);
    private void EnumResources(IntPtr moduleHandle, Func`3<object, object, bool> callback);
    private IntPtr FindResource(IntPtr moduleHandle);
    private static void ValidateKind(NativeResourceKind kind);
    private static void ThrowLastWin32Error();
    private static object IntPtrToObject(IntPtr value);
}
internal enum Microsoft.VisualStudio.Imaging.NativeResourceKind : Enum {
    public int value__;
    public static NativeResourceKind XAML;
    public static NativeResourceKind PNG;
    public static NativeResourceKind Icon;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Imaging.PixelBuffer : object {
    private int width;
    private int height;
    private int byteCount;
    [CompilerGeneratedAttribute]
private Byte[] <PixelBytes>k__BackingField;
    public Byte[] PixelBytes { get; }
    public PixelBuffer(Byte[] pixelBytes, int width, int height);
    [CompilerGeneratedAttribute]
public Byte[] get_PixelBytes();
    public void AlphaBlendWithBackground(SimpleColor background);
    public void ReplacePixels(int sequenceLength, Func`2<SimpleColor[], bool> predicate, Func`2<SimpleColor[], SimpleColor[]> transform, SimpleColor background);
    public SimpleColor GetColor(int i);
    public void SetColor(int i, SimpleColor color);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Imaging.PixelBuffer/<GetPixelSequences>d__11")]
private IEnumerable`1<PixelSequence> GetPixelSequences(int sequenceLength);
    private PixelSequence SequenceUpwardFrom(int x, int y, int length);
    private PixelSequence SequenceDownwardFrom(int x, int y, int length);
    private PixelSequence SequenceLeftwardFrom(int x, int y, int length);
    private PixelSequence SequenceRightwardFrom(int x, int y, int length);
    private int GetIndex(int x, int y);
}
internal class Microsoft.VisualStudio.Imaging.ProcessedManifest : object {
    private string _filename;
    private ITracer _tracer;
    private Dictionary`2<string, object> _symbols;
    private Lazy`1<IReadOnlyDictionary`2<string, object>> _symbolsRO;
    private BundleCollection`1<ImageBundle> _images;
    private BundleCollection`1<ImageListBundle> _imageLists;
    private List`1<Exception> _exceptions;
    private Lazy`1<IReadOnlyList`1<Exception>> _exceptionsRO;
    private Regex _regex;
    [CompilerGeneratedAttribute]
private Guid <PackageGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BuiltInSymbolCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UserSymbolCount>k__BackingField;
    public Guid PackageGuid { get; public set; }
    public string Filename { get; }
    public IReadOnlyDictionary`2<string, object> Symbols { get; }
    public int BuiltInSymbolCount { get; private set; }
    public int UserSymbolCount { get; private set; }
    public int SymbolCount { get; }
    public BundleCollection`1<ImageBundle> Images { get; }
    public BundleCollection`1<ImageListBundle> ImageLists { get; }
    public IReadOnlyList`1<Exception> Exceptions { get; }
    public ProcessedManifest(string filename, ITracer tracer);
    [CompilerGeneratedAttribute]
public Guid get_PackageGuid();
    [CompilerGeneratedAttribute]
public void set_PackageGuid(Guid value);
    public string get_Filename();
    public IReadOnlyDictionary`2<string, object> get_Symbols();
    [CompilerGeneratedAttribute]
public int get_BuiltInSymbolCount();
    [CompilerGeneratedAttribute]
private void set_BuiltInSymbolCount(int value);
    [CompilerGeneratedAttribute]
public int get_UserSymbolCount();
    [CompilerGeneratedAttribute]
private void set_UserSymbolCount(int value);
    public int get_SymbolCount();
    public BundleCollection`1<ImageBundle> get_Images();
    public BundleCollection`1<ImageListBundle> get_ImageLists();
    public IReadOnlyList`1<Exception> get_Exceptions();
    public void AddUserSymbol(string symbol, object value);
    public void AddBuiltInSymbol(string symbol, string value);
    public string ResolveSymbols(string s);
    public void AddException(Exception ex);
    [ConditionalAttribute("TRACE")]
internal void Trace(Predicate`1<string> symbolPredicate, bool symbolsOnly);
    [ConditionalAttribute("TRACE")]
private void TraceSymbols(Predicate`1<string> symbolPredicate);
    [ConditionalAttribute("TRACE")]
private void TraceImages();
    [ConditionalAttribute("TRACE")]
private void TraceImageLists();
    [ConditionalAttribute("TRACE")]
private void TraceCount(TraceEventType eventType, int count, string singularText);
    [ConditionalAttribute("TRACE")]
private void TraceException(Exception ex);
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <.ctor>b__9_0();
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Exception> <.ctor>b__9_1();
}
internal class Microsoft.VisualStudio.Imaging.RealizedImageInformation : object {
    [CompilerGeneratedAttribute]
private ImageAttributeTuple <RequestedImage>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageAttributeTuple <NativeImage>k__BackingField;
    public ImageAttributeTuple RequestedImage { get; }
    public ImageAttributeTuple NativeImage { get; }
    [CompilerGeneratedAttribute]
public ImageAttributeTuple get_RequestedImage();
    [CompilerGeneratedAttribute]
public ImageAttributeTuple get_NativeImage();
}
internal enum Microsoft.VisualStudio.Imaging.ReferenceKind : Enum {
    public int value__;
    public static ReferenceKind Weak;
    public static ReferenceKind Strong;
    public static ReferenceKind Default;
}
internal abstract class Microsoft.VisualStudio.Imaging.ResourceBundle : object {
    public static int InvalidManifestDescriptorIndex;
    private static ReferenceKind DefaultReferenceKind;
    private ImageMoniker _moniker;
    private ImageEntryCollection _realizedImages;
    private static int SerializationVersion;
    [CompilerGeneratedAttribute]
private int <ManifestDescriptorIndex>k__BackingField;
    public ImageMoniker Moniker { get; }
    public int ManifestDescriptorIndex { get; public set; }
    public int RealizedImageCount { get; }
    private ImageEntryCollection RealizedImages { get; }
    private ImageMoniker Microsoft.VisualStudio.Imaging.Interop.IImageHandle.Moniker { get; }
    protected ResourceBundle(ImageMoniker moniker);
    protected ResourceBundle(VersionedBinaryReader reader);
    internal void Serialize(VersionedBinaryWriter writer);
    protected virtual void SerializeCore(VersionedBinaryWriter writer);
    internal static ResourceBundle Deserialize(VersionedBinaryReader reader);
    private void WriteSerializedType(BinaryWriter writer);
    private static SerializedType ReadSerializedType(BinaryReader reader);
    public ImageMoniker get_Moniker();
    [CompilerGeneratedAttribute]
public int get_ManifestDescriptorIndex();
    [CompilerGeneratedAttribute]
public void set_ManifestDescriptorIndex(int value);
    public int get_RealizedImageCount();
    private ImageEntryCollection get_RealizedImages();
    public abstract virtual RealizedImageInformation GetImage(ImageLibrary library, ImageAttributes attributes);
    protected RealizedImageInformation GetResource(ImageLibrary library, ImageAttributes desiredAttributes, ImageFormat nativeFormat, ImageKind nativeKind);
    private RealizedImageInformation GetResourceCore(ImageLibrary library, ImageAttributes desiredAttributes, ImageFormat nativeFormat, ImageKind nativeKind);
    protected abstract virtual object RealizeNativeFormatResource(ImageLibrary library, ImageAttributes attributes);
    [ConditionalAttribute("DEBUG")]
private void ValidateImageType(object image, ImageAttributes attributes);
    protected abstract virtual Type GetExpectedImageType(ImageAttributes attributes);
    private object ConvertImage(object image, ImageFormat originalFormat, ImageAttributes desiredAttributes);
    public virtual void CacheImage(ImageLibrary library, ImageAttributeTuple tuple);
    private static ReferenceKind ReferenceKindFromAttributes(ImageAttributes attributes);
    private static ReferenceKind ReferenceKindFromFormat(ImageFormat format);
    private object ConvertBitmap(object image, ImageFormat originalFormat, ImageAttributes desiredAttributes);
    private object ConvertIcon(object image, ImageFormat originalFormat, ImageAttributes desiredAttributes);
    private object ConvertImageList(object image, ImageFormat originalFormat, ImageAttributes desiredAttributes);
    private static void ValidateConversionParameters(object image, ImageFormat originalFormat, ImageAttributes desiredAttributes, ImageFormat expectedOriginalFormat);
    private static Exception MakeBadConversionException(ImageFormat originalFormat, ImageAttributes desiredAttributes);
    public virtual string ToString();
    public virtual int GetHashCode();
    public static bool op_Equality(ResourceBundle bundle1, ResourceBundle bundle2);
    public static bool op_Inequality(ResourceBundle bundle1, ResourceBundle bundle2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ResourceBundle other);
    public sealed virtual int CompareTo(ResourceBundle other);
    private sealed virtual override ImageMoniker Microsoft.VisualStudio.Imaging.Interop.IImageHandle.get_Moniker();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.Imaging.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Error_CannotRemoveImageForProgId { get; }
    internal static string Error_CannotRemoveManifestImage { get; }
    internal static string Error_CannotRemoveManifestImageList { get; }
    internal static string Error_CannotReplaceExistingImage { get; }
    internal static string Error_CannotReplaceExistingImageList { get; }
    internal static string Error_DefaultImageLibraryAlreadyExists { get; }
    internal static string Error_DuplicateFormattingDescriptor { get; }
    internal static string Error_DuplicateMoniker { get; }
    internal static string Error_EmptyImageSources { get; }
    internal static string Error_InsufficientImageListImages { get; }
    internal static string Error_InsufficientImageSources { get; }
    internal static string Error_InvalidAttributesStructSize { get; }
    internal static string Error_InvalidDpi { get; }
    internal static string Error_InvalidFlagsValue { get; }
    internal static string Error_InvalidFormatString { get; }
    internal static string Error_InvalidHeightRange { get; }
    internal static string Error_InvalidImageFormat { get; }
    internal static string Error_InvalidImageFormatEnum { get; }
    internal static string Error_InvalidImageHorizontalAlignment { get; }
    internal static string Error_InvalidImageKind { get; }
    internal static string Error_InvalidImageMoniker { get; }
    internal static string Error_InvalidImageSize { get; }
    internal static string Error_InvalidImageType { get; }
    internal static string Error_InvalidImageTypeValue { get; }
    internal static string Error_InvalidImageVerticalAlignment { get; }
    internal static string Error_InvalidNativeResourceKind { get; }
    internal static string Error_InvalidPackageGuid { get; }
    internal static string Error_InvalidWidthRange { get; }
    internal static string Error_NonWhiteGrayscaleBiasColor { get; }
    internal static string Error_NotIcon { get; }
    internal static string Error_NoWpfImageList { get; }
    internal static string Error_NoWpfImageList1 { get; }
    internal static string Error_PictureIsNotBitmap { get; }
    internal static string Error_SymbolAlreadyDefined { get; }
    internal static string Error_UndefinedSymbol { get; }
    internal static string Error_UnexpectedImageType { get; }
    internal static string Error_UnexpectedStreamFormat { get; }
    internal static string Error_UnknownImage { get; }
    internal static string Error_UnknownImageList { get; }
    internal static string Error_UnknownSerializationType { get; }
    internal static string Error_UnsupportedContentType { get; }
    internal static string Error_UnsupportedElementType { get; }
    internal static string Error_UnsupportedImageConversionKind { get; }
    internal static string Error_UnsupportedImageFileType { get; }
    internal static string Error_UnsupportedImageSourceType { get; }
    internal static string Error_UnsupportedNativeResourceType { get; }
    internal static string Error_UnsupportedUri { get; }
    internal static string Error_ValueNonreal { get; }
    internal static string Error_ValueTooLarge { get; }
    internal static string Error_ValueTooSmall { get; }
    internal static string ExcessBubbleCountFormat { get; }
    internal static string GeneralSerializationError { get; }
    internal static string ValidateError_BitmapNotBgra32 { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Error_CannotRemoveImageForProgId();
    internal static string get_Error_CannotRemoveManifestImage();
    internal static string get_Error_CannotRemoveManifestImageList();
    internal static string get_Error_CannotReplaceExistingImage();
    internal static string get_Error_CannotReplaceExistingImageList();
    internal static string get_Error_DefaultImageLibraryAlreadyExists();
    internal static string get_Error_DuplicateFormattingDescriptor();
    internal static string get_Error_DuplicateMoniker();
    internal static string get_Error_EmptyImageSources();
    internal static string get_Error_InsufficientImageListImages();
    internal static string get_Error_InsufficientImageSources();
    internal static string get_Error_InvalidAttributesStructSize();
    internal static string get_Error_InvalidDpi();
    internal static string get_Error_InvalidFlagsValue();
    internal static string get_Error_InvalidFormatString();
    internal static string get_Error_InvalidHeightRange();
    internal static string get_Error_InvalidImageFormat();
    internal static string get_Error_InvalidImageFormatEnum();
    internal static string get_Error_InvalidImageHorizontalAlignment();
    internal static string get_Error_InvalidImageKind();
    internal static string get_Error_InvalidImageMoniker();
    internal static string get_Error_InvalidImageSize();
    internal static string get_Error_InvalidImageType();
    internal static string get_Error_InvalidImageTypeValue();
    internal static string get_Error_InvalidImageVerticalAlignment();
    internal static string get_Error_InvalidNativeResourceKind();
    internal static string get_Error_InvalidPackageGuid();
    internal static string get_Error_InvalidWidthRange();
    internal static string get_Error_NonWhiteGrayscaleBiasColor();
    internal static string get_Error_NotIcon();
    internal static string get_Error_NoWpfImageList();
    internal static string get_Error_NoWpfImageList1();
    internal static string get_Error_PictureIsNotBitmap();
    internal static string get_Error_SymbolAlreadyDefined();
    internal static string get_Error_UndefinedSymbol();
    internal static string get_Error_UnexpectedImageType();
    internal static string get_Error_UnexpectedStreamFormat();
    internal static string get_Error_UnknownImage();
    internal static string get_Error_UnknownImageList();
    internal static string get_Error_UnknownSerializationType();
    internal static string get_Error_UnsupportedContentType();
    internal static string get_Error_UnsupportedElementType();
    internal static string get_Error_UnsupportedImageConversionKind();
    internal static string get_Error_UnsupportedImageFileType();
    internal static string get_Error_UnsupportedImageSourceType();
    internal static string get_Error_UnsupportedNativeResourceType();
    internal static string get_Error_UnsupportedUri();
    internal static string get_Error_ValueNonreal();
    internal static string get_Error_ValueTooLarge();
    internal static string get_Error_ValueTooSmall();
    internal static string get_ExcessBubbleCountFormat();
    internal static string get_GeneralSerializationError();
    internal static string get_ValidateError_BitmapNotBgra32();
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
[XmlRootAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifest : object {
    [XmlArrayItemAttribute("Guid", "Microsoft.VisualStudio.Imaging.Serialization.ImageManifestGuid")]
[XmlArrayItemAttribute("ID", "Microsoft.VisualStudio.Imaging.Serialization.ImageManifestID")]
[XmlArrayItemAttribute("Import", "Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImport")]
[XmlArrayItemAttribute("String", "Microsoft.VisualStudio.Imaging.Serialization.ImageManifestString")]
public Object[] Symbols;
    [XmlArrayItemAttribute("Image")]
public ImageManifestImage[] Images;
    [XmlArrayItemAttribute("ImageList")]
public ImageManifestImageList[] ImageLists;
    [XmlAttributeAttribute]
public string PackageGuid;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestGuid : object {
    [XmlAttributeAttribute]
public string Name;
    [XmlAttributeAttribute]
public string Value;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestID : object {
    [XmlAttributeAttribute]
public string Name;
    [XmlAttributeAttribute]
public int Value;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImage : object {
    [XmlElementAttribute("Source")]
public ImageManifestImageSource[] Source;
    [XmlAttributeAttribute]
public string Guid;
    [XmlAttributeAttribute]
public string ID;
    [XmlAttributeAttribute]
public bool AllowColorInversion;
    [XmlIgnoreAttribute]
public bool AllowColorInversionSpecified;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageList : object {
    [XmlElementAttribute("ContainedImage")]
public ImageManifestImageListContainedImage[] ContainedImage;
    [XmlAttributeAttribute]
public string Guid;
    [XmlAttributeAttribute]
public string ID;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageListContainedImage : object {
    [XmlAttributeAttribute]
public string Guid;
    [XmlAttributeAttribute]
public string ID;
    [XmlAttributeAttribute]
public bool External;
    [XmlIgnoreAttribute]
public bool ExternalSpecified;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageSource : object {
    [XmlElementAttribute("DimensionRange", "Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageSourceDimensionRange")]
[XmlElementAttribute("Dimensions", "Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageSourceDimensions")]
[XmlElementAttribute("Size", "Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageSourceSize")]
[XmlElementAttribute("SizeRange", "Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageSourceSizeRange")]
public object Item;
    public ImageManifestImageSourceNativeResource NativeResource;
    [XmlAttributeAttribute]
public string Uri;
    [XmlAttributeAttribute]
public ST_SourceBackgroundType Background;
    [XmlIgnoreAttribute]
public bool BackgroundSpecified;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageSourceDimensionRange : object {
    [XmlAttributeAttribute]
public int MinWidth;
    [XmlAttributeAttribute]
public int MinHeight;
    [XmlAttributeAttribute]
public int MaxWidth;
    [XmlAttributeAttribute]
public int MaxHeight;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageSourceDimensions : object {
    [XmlAttributeAttribute]
public int Width;
    [XmlAttributeAttribute]
public int Height;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageSourceNativeResource : object {
    [XmlAttributeAttribute]
public string ID;
    [XmlAttributeAttribute]
public string Type;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageSourceSize : object {
    [XmlAttributeAttribute]
public int Value;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImageSourceSizeRange : object {
    [XmlAttributeAttribute]
public int MinSize;
    [XmlAttributeAttribute]
public int MaxSize;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestImport : object {
    [XmlAttributeAttribute]
public string Manifest;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Imaging.Serialization.ImageManifestString : object {
    [XmlAttributeAttribute]
public string Name;
    [XmlAttributeAttribute]
public string Value;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.18408")]
[XmlTypeAttribute]
public enum Microsoft.VisualStudio.Imaging.Serialization.ST_SourceBackgroundType : Enum {
    public int value__;
    public static ST_SourceBackgroundType Light;
    public static ST_SourceBackgroundType Dark;
    public static ST_SourceBackgroundType HighContrast;
    public static ST_SourceBackgroundType HighContrastLight;
    public static ST_SourceBackgroundType HighContrastDark;
}
internal class Microsoft.VisualStudio.Imaging.SimpleColor : ValueType {
    private static double ByteMaxAsDouble;
    internal static ImmutableArray`1<double> ScaledChannelValues;
    public static SimpleColor Black;
    public static SimpleColor HotPink;
    public static SimpleColor White;
    [CompilerGeneratedAttribute]
private byte <A>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <R>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <G>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <B>k__BackingField;
    public byte A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    private static SimpleColor();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public byte get_A();
    [CompilerGeneratedAttribute]
public void set_A(byte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public byte get_R();
    [CompilerGeneratedAttribute]
public void set_R(byte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public byte get_G();
    [CompilerGeneratedAttribute]
public void set_G(byte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public byte get_B();
    [CompilerGeneratedAttribute]
public void set_B(byte value);
    public static SimpleColor FromArgb(byte a, byte r, byte g, byte b);
    public static SimpleColor FromRgb(byte r, byte g, byte b);
    public static SimpleColor FromRgba(UInt32 rgba);
    public static bool op_Equality(SimpleColor color1, SimpleColor color2);
    public static bool op_Inequality(SimpleColor color1, SimpleColor color2);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public SimpleColor BlendWith(SimpleColor foreground);
    public double ContrastWith(SimpleColor other);
    [CompilerGeneratedAttribute]
internal static byte <BlendWith>g__BlendChannel|29_0(int foreground, int background, <>c__DisplayClass29_0& );
    [CompilerGeneratedAttribute]
internal static double <ContrastWith>g__GetLuminance|30_0(SimpleColor sc);
}
internal class Microsoft.VisualStudio.Imaging.SingleImageBundle : ImageBundle {
    private object _sources;
    private bool _canTheme;
    private static int SerializationVersion;
    public SingleImageBundle(ImageMoniker moniker, SourceDescriptor source, bool canTheme);
    public SingleImageBundle(ImageMoniker moniker, ICollection`1<SourceDescriptor> sources, bool canTheme);
    internal SingleImageBundle(VersionedBinaryReader reader);
    public static ImageBundle Create(ImageMoniker moniker, string filename, int index, bool canTheme);
    protected virtual void SerializeCore(VersionedBinaryWriter writer);
    public void AddSource(SourceDescriptor source);
    internal SourceDescriptor[] GetAllSources();
    protected virtual object RealizeNativeFormatResource(ImageLibrary library, ImageAttributes attributes);
    internal IEnumerable`1<SourceDescriptor> GetMatchingSources(ImageAttributes attributes);
    private IEnumerable`1<SourceDescriptor> GetMatches(IEnumerable`1<SourceDescriptor> sources, ImageAttributes attributes);
    private IEnumerable`1<SourceDescriptor> Sort(IEnumerable`1<SourceDescriptor> sources, ImageAttributes attributes);
    protected virtual void TraceCore(ITracer tracer, TraceEventType eventType);
}
internal enum Microsoft.VisualStudio.Imaging.SourceBackground : Enum {
    public byte value__;
    public static SourceBackground Any;
    public static SourceBackground Light;
    public static SourceBackground Dark;
    public static SourceBackground HighContrast;
    public static SourceBackground HighContrastLight;
    public static SourceBackground HighContrastDark;
}
internal abstract class Microsoft.VisualStudio.Imaging.SourceDescriptor : object {
    private static Uri DefaultBaseUri;
    private NativeResource _nativeResource;
    private SourceBackground _background;
    private Int16Size _minDeviceSize;
    private Int16Size _maxDeviceSize;
    private static int SerializationVersion;
    public Int16Size MinDeviceSize { get; }
    public Int16Size MaxDeviceSize { get; }
    public bool IsSizeKnown { get; }
    public NativeResource NativeResource { get; }
    public bool IsNativeResource { get; }
    public SourceBackground Background { get; }
    public bool CanTheme { get; }
    public bool IsAnyBackground { get; }
    public bool IsDarkBackground { get; }
    public bool IsHighContrast { get; }
    public bool IsLightBackground { get; }
    public bool IsSizeNeutral { get; }
    public string SizeString { get; }
    protected SourceDescriptor(Int16Size minDeviceSize, Int16Size maxDeviceSize, NativeResource nativeResource, SourceBackground background);
    protected SourceDescriptor(VersionedBinaryReader reader);
    private static SourceDescriptor();
    internal void Serialize(VersionedBinaryWriter writer);
    protected virtual void SerializeCore(VersionedBinaryWriter writer);
    internal static SourceDescriptor Deserialize(VersionedBinaryReader reader);
    private void WriteSerializedType(BinaryWriter writer);
    private static SerializedType ReadSerializedType(BinaryReader reader);
    public Int16Size get_MinDeviceSize();
    public Int16Size get_MaxDeviceSize();
    public bool get_IsSizeKnown();
    public NativeResource get_NativeResource();
    public bool get_IsNativeResource();
    public SourceBackground get_Background();
    public bool get_CanTheme();
    public bool get_IsAnyBackground();
    public bool get_IsDarkBackground();
    public bool get_IsHighContrast();
    public bool get_IsLightBackground();
    public virtual bool get_IsSizeNeutral();
    public Byte[] GetNativeResourceBytes();
    protected abstract virtual Byte[] GetNativeResourceBytesCore();
    protected virtual BitmapSource LoadImageFromNativeIcon(Int16Size size);
    public virtual string ToString();
    protected virtual void ToStringCore(StringBuilder builder);
    public bool MatchesSize(Int16Size size);
    public string get_SizeString();
    public BitmapSource LoadImage(JoinableTaskFactory jtf, ImageMoniker moniker, ImageAttributes attributes, bool canTheme, bool debugMode, Color debugColor);
    private BitmapSource LoadNativeImage(JoinableTaskFactory jtf, Int16Size deviceSize);
    protected abstract virtual BitmapSource LoadManagedImage(JoinableTaskFactory jtf, Int16Size deviceSize);
    protected static BitmapSource LoadXamlImage(JoinableTaskFactory jtf, Uri source, Int16Size deviceSize);
    protected static BitmapSource LoadXamlImage(JoinableTaskFactory jtf, Stream stream, Int16Size deviceSize);
    protected static BitmapSource LoadXamlImage(JoinableTaskFactory jtf, string xaml, Int16Size deviceSize);
    private static BitmapSource LoadXamlImage(object imageAsObject, Int16Size deviceSize);
    protected static BitmapSource LoadBitmappedImage(JoinableTaskFactory jtf, Stream stream, Int16Size deviceSize);
    protected virtual void DetermineDeviceSizes(Int16Size& minDeviceSize, Int16Size& maxDeviceSize);
    protected static BitmapSource StretchImage(BitmapSource image, Int16Size deviceSize);
    private static BitmapScalingMode SelectScalingMode(int scalingPercent);
    protected static BitmapSource RasterizeElement(FrameworkElement element, Int16Size deviceSize);
    private static BitmapSource ThemeImage(BitmapSource image, ImageAttributes attributes, bool canTheme);
    private static BitmapSource AddDebugShading(BitmapSource image, Color debugColor);
    private static Uri MakeAbsoluteUri(Uri uri);
    private static Uri CreateDefaultBaseUri();
}
public class Microsoft.VisualStudio.Imaging.TelemetryEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IDisposable <Disposer>k__BackingField;
    public string Context { get; }
    public IDisposable Disposer { get; public set; }
    public TelemetryEventArgs(string context);
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public IDisposable get_Disposer();
    [CompilerGeneratedAttribute]
public void set_Disposer(IDisposable value);
}
internal class Microsoft.VisualStudio.Imaging.TernaryStringTable : object {
    private static int RootParentNodeId;
    private static int EmptyStringId;
    private List`1<ReadOnlyMemory`1<char>> _cachedSplitList;
    private List`1<Node> _nodes;
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    public int Capacity { get; }
    public TernaryStringTable(int capacity);
    public sealed virtual int get_Capacity();
    public sealed virtual int Intern(string value);
    public sealed virtual string Get(int index);
    internal List`1<ReadOnlyMemory`1<char>> Split(string text);
    private int Compare(string left, ReadOnlySpan`1<char> right);
    public static int GetHashCode(ReadOnlySpan`1<char> s);
    private int NewNode(int parentId, string value);
}
internal enum Microsoft.VisualStudio.Imaging.TryGetImageResult : Enum {
    public int value__;
    public static TryGetImageResult Unknown;
    public static TryGetImageResult MonikerNotFound;
    public static TryGetImageResult Failed;
    public static TryGetImageResult Succeeded;
}
internal enum Microsoft.VisualStudio.Imaging.UriResourceType : Enum {
    public int value__;
    public static UriResourceType Unknown;
    public static UriResourceType Png;
    public static UriResourceType Baml;
    public static UriResourceType Xaml;
}
internal class Microsoft.VisualStudio.Imaging.UriSourceDescriptor : SourceDescriptor {
    private static int DefaultInitialTableCapacity;
    private static int _initialTableCapacity;
    private int _uriStringIndex;
    private WeakReference`1<Uri> _weakUri;
    [CompilerGeneratedAttribute]
private UriResourceType <ResourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ResourceByteArray>k__BackingField;
    private static IStringTable _table;
    private static int SerializationVersion;
    public Uri Uri { get; }
    public static int TableCapacity { get; }
    internal UriResourceType ResourceType { get; }
    internal Byte[] ResourceByteArray { get; }
    private static IStringTable Table { get; }
    private string UriString { get; }
    public UriSourceDescriptor(string uriString, Int16Size deviceSize, NativeResource nativeResource, SourceBackground background, bool preloadResource);
    public UriSourceDescriptor(string uriString, Int16Size minDeviceSize, Int16Size maxDeviceSize, NativeResource nativeResource, SourceBackground background, bool preloadResource);
    public UriSourceDescriptor(VersionedBinaryReader reader);
    private static UriSourceDescriptor();
    public Uri get_Uri();
    public static int get_TableCapacity();
    [CompilerGeneratedAttribute]
internal UriResourceType get_ResourceType();
    [CompilerGeneratedAttribute]
internal Byte[] get_ResourceByteArray();
    private static IStringTable get_Table();
    private string get_UriString();
    public static void SetInitialTableCapacity(int capacity);
    internal static void ResetStringTable();
    protected virtual void SerializeCore(VersionedBinaryWriter writer);
    protected virtual Byte[] GetNativeResourceBytesCore();
    protected virtual void ToStringCore(StringBuilder builder);
    protected virtual BitmapSource LoadManagedImage(JoinableTaskFactory jtf, Int16Size deviceSize);
    protected virtual BitmapSource LoadImageFromNativeIcon(Int16Size size);
    private static Uri MakeUri(string uriString);
    private static void ValidateUriString(string uriString);
    private static bool IsFileUri(Uri uri);
    private UriResourceType GetResourceType(string contentType);
    private UriResourceType FetchResourceStream(Uri uri, Stream& stream);
}
internal class Microsoft.VisualStudio.Imaging.WeakBundleCollection`1 : object {
    private WeakValueDictionary`2<ImageMoniker, T> _bundles;
    public int GetCount();
    public bool Contains(ImageMoniker moniker);
    public sealed virtual IEnumerable`1<ImageMoniker> GetMonikers();
    public sealed virtual bool TryGetBundle(ImageMoniker moniker, T& bundle);
    public void Insert(T bundle);
    public bool Remove(ImageMoniker moniker);
}
internal class Microsoft.VisualStudio.PlatformUI.ACCEL : ValueType {
    private byte fVirt;
    private ushort key;
    private ushort cmd;
}
internal class Microsoft.VisualStudio.PlatformUI.BITMAP : ValueType {
    public int bmType;
    public int bmWidth;
    public int bmHeight;
    public int bmWidthBytes;
    public ushort bmPlanes;
    public ushort bmBitsPixel;
    public IntPtr bmBits;
}
internal class Microsoft.VisualStudio.PlatformUI.COLORREF : ValueType {
    public UInt32 dwColor;
    public COLORREF(UInt32 dwColor);
    public COLORREF(Color color);
    public Color GetMediaColor();
}
internal static class Microsoft.VisualStudio.PlatformUI.DragDropConstants : object {
    public static int DRAGDROP_S_CANCEL;
    public static int DRAGDROP_S_DROP;
    public static int DRAGDROP_S_USEDEFAULTCURSORS;
}
public class Microsoft.VisualStudio.PlatformUI.GrayscaleBitmapSourceConverter : ValueConverter`2<BitmapSource, BitmapSource> {
    private static Color DefaultBiasColor;
    private static int BytesPerPixelBgra32;
    private static GrayscaleBitmapSourceConverter();
    protected virtual BitmapSource Convert(BitmapSource image, object parameter, CultureInfo culture);
    public static BitmapSource ConvertCore(BitmapSource image, Color biasColor);
    public static Color GetBiasColor(object parameter);
    private static BitmapSource ConvertToGrayScale(BitmapSource image, Color biasColor);
}
public class Microsoft.VisualStudio.PlatformUI.GrayscaleImageConverter : ValueConverter`2<BitmapSource, Image> {
    protected virtual Image Convert(BitmapSource inputImage, object parameter, CultureInfo culture);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.PlatformUI.ILC : Enum {
    public UInt32 value__;
    public static ILC ILC_MASK;
    public static ILC ILC_COLOR;
    public static ILC ILC_COLORDDB;
    public static ILC ILC_COLOR4;
    public static ILC ILC_COLOR8;
    public static ILC ILC_COLOR16;
    public static ILC ILC_COLOR24;
    public static ILC ILC_COLOR32;
    public static ILC ILC_PALETTE;
    public static ILC ILC_MIRROR;
    public static ILC ILC_PERITEMMIRROR;
    public static ILC ILC_ORIGINALSIZE;
    public static ILC ILC_HIGHQUALITYSCALE;
}
internal class Microsoft.VisualStudio.PlatformUI.IMAGEINFO : ValueType {
    public IntPtr hbmImage;
    public IntPtr hbmMask;
    public int Unused1;
    public int Unused2;
    public RECT rcImage;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.PlatformUI.ImageThemingUtilities : object {
    private static ConcurrentDictionary`2<WeakImageCacheKey, ConditionalWeakTable`2<BitmapSource, BitmapSource>> weakImageCache;
    internal static int BytesPerPixelBgra32;
    private static ReusableArray`1<byte> conversionBuffer;
    private static ReusableArray`1<byte> backupBuffer;
    private static float BlueChannelWeight;
    private static float GreenChannelWeight;
    private static float RedChannelWeight;
    private static double HaloLuminosity;
    private static double HighContrastCutOffLuminosity;
    [CompilerGeneratedAttribute]
private static bool <EnhanceContrastIfNecessaryByDefault>k__BackingField;
    public static DependencyProperty ImageBackgroundColorProperty;
    public static DependencyProperty ThemeScrollBarsProperty;
    [CompilerGeneratedAttribute]
private static EventHandler`1<DependencyPropertyChangedEventArgs> ThemeScrollBarsChanged;
    [CompilerGeneratedAttribute]
private static bool <IsImageThemingEnabled>k__BackingField;
    public static bool EnhanceContrastIfNecessaryByDefault { get; public set; }
    public static bool IsImageThemingEnabled { get; public set; }
    private static ImageThemingUtilities();
    public static void ClearWeakImageCache();
    [CompilerGeneratedAttribute]
public static bool get_EnhanceContrastIfNecessaryByDefault();
    [CompilerGeneratedAttribute]
public static void set_EnhanceContrastIfNecessaryByDefault(bool value);
    public static Color GetImageBackgroundColor(DependencyObject obj);
    public static void SetImageBackgroundColor(DependencyObject obj, Color value);
    public static Nullable`1<bool> GetThemeScrollBars(DependencyObject element);
    public static void SetThemeScrollBars(DependencyObject element, Nullable`1<bool> value);
    private static void OnThemeScrollBarsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
public static void add_ThemeScrollBarsChanged(EventHandler`1<DependencyPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ThemeScrollBarsChanged(EventHandler`1<DependencyPropertyChangedEventArgs> value);
    public static void GrayscaleDIBits(Byte[] pixels, int pixelLength, Color biasColor);
    internal static ReusableResourceHolder`1<Byte[]> AcquireConversionBuffer(int size);
    public static BitmapSource GetOrCreateThemedBitmapSource(BitmapSource inputImage, Color backgroundColor, bool isEnabled, Color grayscaleBiasColor);
    public static BitmapSource GetOrCreateThemedBitmapSource(BitmapSource inputImage, Color backgroundColor, bool isEnabled, Color grayscaleBiasColor, bool isHighContrast, bool enhanceContrastIfNecessary);
    public static BitmapSource GetOrCreateThemedBitmapSource(BitmapSource inputImage, Color backgroundColor, bool isEnabled, Color grayscaleBiasColor, bool isHighContrast);
    private static BitmapSource CreateThemedBitmapSource(BitmapSource inputImage, Color backgroundColor, bool isEnabled, Color grayscaleBiasColor, bool isHighContrast, bool enhanceContrastIfNecessary);
    public static Bitmap GetThemedBitmap(Bitmap source, Color backgroundColor);
    public static Bitmap GetThemedBitmap(Bitmap source, Color backgroundColor, bool isHighContrast);
    public static Bitmap GetThemedBitmap(Bitmap source, UInt32 backgroundColor);
    public static Bitmap GetThemedBitmap(Bitmap source, UInt32 backgroundColor, bool isHighContrast);
    [CompilerGeneratedAttribute]
public static bool get_IsImageThemingEnabled();
    [CompilerGeneratedAttribute]
public static void set_IsImageThemingEnabled(bool value);
    public static bool ThemeDIBits(int pixelCount, Byte[] pixels, int width, int height, bool isTopDownBitmap, UInt32 backgroundRgba);
    public static bool ThemeDIBits(int pixelCount, Byte[] pixels, int width, int height, bool isTopDownBitmap, UInt32 backgroundRgba, bool isHighContrast);
    public static bool ThemeDIBits(int pixelCount, Byte[] pixels, int width, int height, bool isTopDownBitmap, UInt32 backgroundRgba, bool isHighContrast, bool enhanceContrastIfNecessary);
    private static bool HasAlphaChannel(int pixelCount, Byte[] pixels);
    private static bool ShouldRenderIconsWithEnhancedContrast(HslColor background);
    public static bool IsOptOutPixelSet(Byte[] pixels, int width, int height, bool isTopDownBitmap);
    public static bool IsOptOutPixelSet(Byte* pPixelBytes, int width, int height, bool isTopDownBitmap);
    public static void ClearOptOutPixel(Byte[] pixels, int width, int height, bool isTopDownBitmap);
    public static void ClearOptOutPixel(Byte* pPixelBytes, int width, int height, bool isTopDownBitmap);
    public static BitmapSource SetOptOutPixel(BitmapSource source);
    public static BitmapSource ModifyBitmap(BitmapSource source, ModifyPixelCallback modifier);
    public static void SetOptOutPixel(Byte[] pixels, int width, int height, bool isTopDownBitmap);
    public static void SetOptOutPixel(Byte* pPixelBytes, int width, int height, bool isTopDownBitmap);
    private static int ComputeOffsetToOptOutPixel(int width, int height, bool isTopDownBitmap);
    public static void ThemePixel(Byte& r, Byte& g, Byte& b, HslColor background);
    public static void ThemePixel(Byte& r, Byte& g, Byte& b, HslColor background, bool isHighContrast);
    private static void ThemePixelWithoutExtraContrast(Byte& r, Byte& g, Byte& b, HslColor background, bool isHighContrast);
    public static void ThemePixelWithExtraContrast(Byte& r, Byte& g, Byte& b, HslColor background);
    private static double TransformLuminosity(double hue, double saturation, double luminosity, HslColor background);
    [ExtensionAttribute]
public static bool IsDark(Color color);
    [ExtensionAttribute]
internal static bool IsDark(SimpleColor color);
    [ExtensionAttribute]
public static bool IsLight(Color color);
}
internal class Microsoft.VisualStudio.PlatformUI.LOGFONT : ValueType {
    public int lfHeight;
    public int lfWidth;
    public int lfEscapement;
    public int lfOrientation;
    public int lfWeight;
    public byte lfItalic;
    public byte lfUnderline;
    public byte lfStrikeOut;
    public byte lfCharSet;
    public byte lfOutPrecision;
    public byte lfClipPrecision;
    public byte lfQuality;
    public byte lfPitchAndFamily;
    public string lfFaceName;
}
internal class Microsoft.VisualStudio.PlatformUI.MINMAXINFO : ValueType {
    public POINT ptReserved;
    public POINT ptMaxSize;
    public POINT ptMaxPosition;
    public POINT ptMinTrackSize;
    public POINT ptMaxTrackSize;
}
internal class Microsoft.VisualStudio.PlatformUI.MONITORINFO : ValueType {
    public UInt32 cbSize;
    public RECT rcMonitor;
    public RECT rcWork;
    public UInt32 dwFlags;
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.PlatformUI.NativeMethods : object {
    public static int MAX_PATH;
    private static int vsmNotifyOwnerActivate;
    private static int vsmProcessUIBackgroundPriorityTaskQueue;
    public static UInt32 TOKEN_QUERY;
    public static long SECURITY_MANDATORY_UNTRUSTED_RID;
    public static long SECURITY_MANDATORY_LOW_RID;
    public static long SECURITY_MANDATORY_MEDIUM_RID;
    public static long SECURITY_MANDATORY_HIGH_RID;
    public static long SECURITY_MANDATORY_SYSTEM_RID;
    public static long SECURITY_MANDATORY_PROTECTED_PROCESS_RID;
    public static int RT_CURSOR;
    public static int RT_BITMAP;
    public static int RT_ICON;
    public static int RT_MENU;
    public static int RT_DIALOG;
    public static int RT_STRING;
    public static int RT_FONTDIR;
    public static int RT_FONT;
    public static int RT_ACCELERATOR;
    public static int RT_RCDATA;
    public static int RT_MESSAGETABLE;
    public static int RT_GROUP_CURSOR;
    public static int RT_GROUP_ICON;
    public static int RT_VERSION;
    public static int RT_DLGINCLUDE;
    public static int RT_PLUGPLAY;
    public static int RT_VXD;
    public static int RT_ANICURSOR;
    public static int RT_ANIICON;
    public static int RT_HTML;
    public static int RT_MANIFEST;
    private static byte KeyDown;
    public static UInt32 MAPVK_VK_TO_VSC;
    public static UInt32 MAPVK_VSC_TO_VK;
    public static UInt32 MAPVK_VK_TO_CHAR;
    public static UInt32 MAPVK_VSC_TO_VK_EX;
    public static int VK_LBUTTON;
    public static int VK_RBUTTON;
    public static int VK_MBUTTON;
    public static int VK_XBUTTON1;
    public static int VK_XBUTTON2;
    public static int VK_TAB;
    public static int VK_SHIFT;
    public static int VK_CONTROL;
    public static int VK_MENU;
    public static int VK_SPACE;
    public static int VK_LSHIFT;
    public static int VK_RSHIFT;
    public static int VK_LCONTROL;
    public static int VK_RCONTROL;
    public static int VK_LMENU;
    public static int VK_RMENU;
    public static int VK_LWIN;
    public static int VK_RWIN;
    public static int VK_F1;
    public static int VK_F4;
    public static int VK_ESC;
    public static int VK_RETURN;
    public static int MK_CONTROL;
    public static int MK_LBUTTON;
    public static int MK_MBUTTON;
    public static int MK_RBUTTON;
    public static int MK_SHIFT;
    public static int MK_XBUTTON1;
    public static int MK_XBUTTON2;
    public static int XBUTTON1;
    public static int XBUTTON2;
    public static int RPC_E_SERVERCALL_RETRYLATER;
    public static int RPC_E_SERVERCALL_REJECTED;
    public static int RPC_E_RETRY;
    public static int RPC_E_DISCONNECTED;
    public static int RPC_E_SYS_CALL_FAILED;
    public static int E_SHARING_VIOLATION;
    internal static int ICON_FORMAT_VERSION;
    internal static int LR_DEFAULTCOLOR;
    internal static int PICTYPE_UNINITIALIZED;
    internal static int PICTYPE_NONE;
    internal static int PICTYPE_BITMAP;
    internal static int PICTYPE_METAFILE;
    internal static int PICTYPE_ICON;
    internal static int PICTYPE_ENHMETAFILE;
    internal static int BITMAPINFO_MAX_COLORSIZE;
    internal static int DIB_RGB_COLORS;
    internal static int DIB_PAL_COLORS;
    internal static int AC_SRC_OVER;
    internal static int AC_SRC_ALPHA;
    internal static int ULW_ALPHA;
    internal static int BI_RGB;
    internal static int BI_RLE8;
    internal static int BI_RLE4;
    internal static int BI_BITFIELDS;
    internal static int BI_JPEG;
    internal static int BI_PNG;
    public static int TRUE;
    public static int FALSE;
    public static IntPtr HRGN_NONE;
    public static int DCX_WINDOW;
    public static int DCX_CACHE;
    public static int DCX_NORESETATTRS;
    public static int DCX_CLIPCHILDREN;
    public static int DCX_CLIPSIBLINGS;
    public static int DCX_PARENTCLIP;
    public static int DCX_EXCLUDERGN;
    public static int DCX_INTERSECTRGN;
    public static int DCX_EXCLUDEUPDATE;
    public static int DCX_INTERSECTUPDATE;
    public static int DCX_LOCKWINDOWUPDATE;
    public static int ILD_NORMAL;
    public static int ILD_TRANSPARENT;
    public static int ILD_MASK;
    public static int ILD_IMAGE;
    public static int ILD_ROP;
    public static int ILD_BLEND25;
    public static int ILD_BLEND50;
    public static int ILD_OVERLAYMASK;
    public static int ILD_SELECTED;
    public static int ILD_FOCUS;
    public static int ILD_BLEND;
    public static int GA_PARENT;
    public static int GA_ROOT;
    public static int GA_ROOTOWNER;
    public static int GW_FIRST;
    public static int GW_LAST;
    public static int GW_HWNDNEXT;
    public static int GW_HWNDPREV;
    public static int GW_OWNER;
    public static int GW_CHILD;
    public static int HTNOWHERE;
    public static int HTCLIENT;
    public static int HTCAPTION;
    public static int HTSYSMENU;
    public static int HTLEFT;
    public static int HTRIGHT;
    public static int HTTOP;
    public static int HTTOPLEFT;
    public static int HTTOPRIGHT;
    public static int HTBOTTOM;
    public static int HTBOTTOMLEFT;
    public static int HTBOTTOMRIGHT;
    public static int ICON_BIG;
    public static int ICON_SMALL;
    public static int LWA_COLORKEY;
    public static int LWA_ALPHA;
    public static int LOGPIXELSX;
    public static int LOGPIXELSY;
    public static int MA_ACTIVATE;
    public static int MA_ACTIVATEANDEAT;
    public static int MA_NOACTIVATE;
    public static int MA_NOACTIVATEANDEAT;
    public static int MONITOR_DEFAULTTONEAREST;
    public static int SW_HIDE;
    public static int SW_SHOWNORMAL;
    public static int SW_NORMAL;
    public static int SW_SHOWMINIMIZED;
    public static int SW_SHOWMAXIMIZED;
    public static int SW_MAXIMIZE;
    public static int SW_SHOWNOACTIVATE;
    public static int SW_SHOW;
    public static int SW_MINIMIZE;
    public static int SW_SHOWMINNOACTIVE;
    public static int SW_SHOWNA;
    public static int SW_RESTORE;
    public static int SW_SHOWDEFAULT;
    public static int SW_FORCEMINIMIZE;
    public static int SW_MAX;
    public static int SW_PARENTCLOSING;
    public static int SW_OTHERZOOM;
    public static int SW_PARENTOPENING;
    public static int SW_OTHERUNZOOM;
    public static int WA_INACTIVE;
    public static int WA_ACTIVE;
    public static int WA_CLICKACTIVE;
    public static int SC_SIZE;
    public static int SC_MOVE;
    public static int SC_MINIMIZE;
    public static int SC_MAXIMIZE;
    public static int SC_NEXTWINDOW;
    public static int SC_PREVWINDOW;
    public static int SC_CLOSE;
    public static int SC_VSCROLL;
    public static int SC_HSCROLL;
    public static int SC_MOUSEMENU;
    public static int SC_KEYMENU;
    public static int SC_ARRANGE;
    public static int SC_RESTORE;
    public static int SC_TASKLIST;
    public static int SC_SCREENSAVE;
    public static int SC_HOTKEY;
    public static int SC_DEFAULT;
    public static int SC_MONITORPOWER;
    public static int SC_CONTEXTHELP;
    public static int SC_SEPARATOR;
    public static int SM_SWAPBUTTON;
    public static int SM_MENUDROPALIGNMENT;
    public static int SPI_SETHIGHCONTRAST;
    public static int SPI_GETNONCLIENTMETRICS;
    public static int SPI_SETNONCLIENTMETRICS;
    public static int SWP_NOSIZE;
    public static int SWP_NOMOVE;
    public static int SWP_NOZORDER;
    public static int SWP_NOREDRAW;
    public static int SWP_NOACTIVATE;
    public static int SWP_FRAMECHANGED;
    public static int SWP_SHOWWINDOW;
    public static int SWP_HIDEWINDOW;
    public static int SWP_NOCOPYBITS;
    public static int SWP_NOOWNERZORDER;
    public static int SWP_NOSENDCHANGING;
    public static int SWP_DEFERERASE;
    public static int SWP_ASYNCWINDOWPOS;
    public static IntPtr HWND_TOP;
    public static IntPtr HWND_BOTTOM;
    public static IntPtr HWND_TOPMOST;
    public static IntPtr HWND_NOTOPMOST;
    public static IntPtr HWND_BROADCAST;
    public static UInt32 TPM_LEFTBUTTON;
    public static UInt32 TPM_RIGHTBUTTON;
    public static UInt32 TPM_LEFTALIGN;
    public static UInt32 TPM_CENTERALIGN;
    public static UInt32 TPM_RIGHTALIGN;
    public static UInt32 TPM_TOPALIGN;
    public static UInt32 TPM_VCENTERALIGN;
    public static UInt32 TPM_BOTTOMALIGN;
    public static UInt32 TPM_HORIZONTAL;
    public static UInt32 TPM_VERTICAL;
    public static UInt32 TPM_NONOTIFY;
    public static UInt32 TPM_RETURNCMD;
    public static UInt32 TPM_RECURSE;
    public static UInt32 TPM_HORPOSANIMATION;
    public static UInt32 TPM_HORNEGANIMATION;
    public static UInt32 TPM_VERPOSANIMATION;
    public static UInt32 TPM_VERNEGANIMATION;
    public static UInt32 TPM_NOANIMATION;
    public static UInt32 TPM_LAYOUTRTL;
    public static UInt32 TPM_WORKAREA;
    public static int WM_NULL;
    public static int WM_CREATE;
    public static int WM_DESTROY;
    public static int WM_MOVE;
    public static int WM_SIZE;
    public static int WM_ACTIVATE;
    public static int WM_SETFOCUS;
    public static int WM_KILLFOCUS;
    public static int WM_ENABLE;
    public static int WM_SETREDRAW;
    public static int WM_SETTEXT;
    public static int WM_GETTEXT;
    public static int WM_GETTEXTLENGTH;
    public static int WM_PAINT;
    public static int WM_CLOSE;
    public static int WM_QUERYENDSESSION;
    public static int WM_QUERYOPEN;
    public static int WM_ENDSESSION;
    public static int WM_QUIT;
    public static int WM_ERASEBKGND;
    public static int WM_SYSCOLORCHANGE;
    public static int WM_SHOWWINDOW;
    public static int WM_WININICHANGE;
    public static int WM_SETTINGCHANGE;
    public static int WM_DEVMODECHANGE;
    public static int WM_ACTIVATEAPP;
    public static int WM_FONTCHANGE;
    public static int WM_TIMECHANGE;
    public static int WM_CANCELMODE;
    public static int WM_SETCURSOR;
    public static int WM_MOUSEACTIVATE;
    public static int WM_CHILDACTIVATE;
    public static int WM_QUEUESYNC;
    public static int WM_GETMINMAXINFO;
    public static int WM_PAINTICON;
    public static int WM_ICONERASEBKGND;
    public static int WM_NEXTDLGCTL;
    public static int WM_SPOOLERSTATUS;
    public static int WM_DRAWITEM;
    public static int WM_MEASUREITEM;
    public static int WM_DELETEITEM;
    public static int WM_VKEYTOITEM;
    public static int WM_CHARTOITEM;
    public static int WM_SETFONT;
    public static int WM_GETFONT;
    public static int WM_SETHOTKEY;
    public static int WM_GETHOTKEY;
    public static int WM_QUERYDRAGICON;
    public static int WM_COMPAREITEM;
    public static int WM_GETOBJECT;
    public static int WM_COMPACTING;
    public static int WM_COMMNOTIFY;
    public static int WM_WINDOWPOSCHANGING;
    public static int WM_WINDOWPOSCHANGED;
    public static int WM_POWER;
    public static int WM_COPYDATA;
    public static int WM_CANCELJOURNAL;
    public static int WM_NOTIFY;
    public static int WM_INPUTLANGCHANGEREQUEST;
    public static int WM_INPUTLANGCHANGE;
    public static int WM_TCARD;
    public static int WM_HELP;
    public static int WM_USERCHANGED;
    public static int WM_NOTIFYFORMAT;
    public static int WM_CONTEXTMENU;
    public static int WM_STYLECHANGING;
    public static int WM_STYLECHANGED;
    public static int WM_DISPLAYCHANGE;
    public static int WM_GETICON;
    public static int WM_SETICON;
    public static int WM_NCCREATE;
    public static int WM_NCDESTROY;
    public static int WM_NCCALCSIZE;
    public static int WM_NCHITTEST;
    public static int WM_NCPAINT;
    public static int WM_NCACTIVATE;
    public static int WM_GETDLGCODE;
    public static int WM_SYNCPAINT;
    public static int WM_NCMOUSEMOVE;
    public static int WM_NCLBUTTONDOWN;
    public static int WM_NCLBUTTONUP;
    public static int WM_NCLBUTTONDBLCLK;
    public static int WM_NCRBUTTONDOWN;
    public static int WM_NCRBUTTONUP;
    public static int WM_NCRBUTTONDBLCLK;
    public static int WM_NCMBUTTONDOWN;
    public static int WM_NCMBUTTONUP;
    public static int WM_NCMBUTTONDBLCLK;
    public static int WM_NCXBUTTONDOWN;
    public static int WM_NCXBUTTONUP;
    public static int WM_NCXBUTTONDBLCLK;
    public static int WM_NCUAHDRAWCAPTION;
    public static int WM_NCUAHDRAWFRAME;
    public static int WM_INPUT;
    public static int WM_KEYFIRST;
    public static int WM_KEYDOWN;
    public static int WM_KEYUP;
    public static int WM_CHAR;
    public static int WM_DEADCHAR;
    public static int WM_SYSKEYDOWN;
    public static int WM_SYSKEYUP;
    public static int WM_SYSCHAR;
    public static int WM_SYSDEADCHAR;
    public static int WM_UNICHAR;
    public static int WM_KEYLAST;
    public static int WM_IME_STARTCOMPOSITION;
    public static int WM_IME_ENDCOMPOSITION;
    public static int WM_IME_COMPOSITION;
    public static int WM_IME_KEYLAST;
    public static int WM_INITDIALOG;
    public static int WM_COMMAND;
    public static int WM_SYSCOMMAND;
    public static int WM_TIMER;
    public static int WM_HSCROLL;
    public static int WM_VSCROLL;
    public static int WM_INITMENU;
    public static int WM_INITMENUPOPUP;
    public static int WM_MENUSELECT;
    public static int WM_MENUCHAR;
    public static int WM_ENTERIDLE;
    public static int WM_MENURBUTTONUP;
    public static int WM_MENUDRAG;
    public static int WM_MENUGETOBJECT;
    public static int WM_UNINITMENUPOPUP;
    public static int WM_MENUCOMMAND;
    public static int WM_CHANGEUISTATE;
    public static int WM_UPDATEUISTATE;
    public static int WM_QUERYUISTATE;
    public static int WM_CTLCOLOR;
    public static int WM_CTLCOLORMSGBOX;
    public static int WM_CTLCOLOREDIT;
    public static int WM_CTLCOLORLISTBOX;
    public static int WM_CTLCOLORBTN;
    public static int WM_CTLCOLORDLG;
    public static int WM_CTLCOLORSCROLLBAR;
    public static int WM_CTLCOLORSTATIC;
    public static int WM_MOUSEFIRST;
    public static int WM_MOUSEMOVE;
    public static int WM_LBUTTONDOWN;
    public static int WM_LBUTTONUP;
    public static int WM_LBUTTONDBLCLK;
    public static int WM_RBUTTONDOWN;
    public static int WM_RBUTTONUP;
    public static int WM_RBUTTONDBLCLK;
    public static int WM_MBUTTONDOWN;
    public static int WM_MBUTTONUP;
    public static int WM_MBUTTONDBLCLK;
    public static int WM_MOUSEWHEEL;
    public static int WM_XBUTTONDOWN;
    public static int WM_XBUTTONUP;
    public static int WM_XBUTTONDBLCLK;
    public static int WM_MOUSELAST;
    public static int WM_PARENTNOTIFY;
    public static int WM_ENTERMENULOOP;
    public static int WM_EXITMENULOOP;
    public static int WM_NEXTMENU;
    public static int WM_SIZING;
    public static int WM_CAPTURECHANGED;
    public static int WM_MOVING;
    public static int WM_POWERBROADCAST;
    public static int WM_DEVICECHANGE;
    public static int WM_MDICREATE;
    public static int WM_MDIDESTROY;
    public static int WM_MDIACTIVATE;
    public static int WM_MDIRESTORE;
    public static int WM_MDINEXT;
    public static int WM_MDIMAXIMIZE;
    public static int WM_MDITILE;
    public static int WM_MDICASCADE;
    public static int WM_MDIICONArANGE;
    public static int WM_MDIGETACTIVE;
    public static int WM_MDISETMENU;
    public static int WM_ENTERSIZEMOVE;
    public static int WM_EXITSIZEMOVE;
    public static int WM_DROPFILES;
    public static int WM_MDIREFRESHMENU;
    public static int WM_IME_SETCONTEXT;
    public static int WM_IME_NOTIFY;
    public static int WM_IME_CONTROL;
    public static int WM_IME_COMPOSITIONFULL;
    public static int WM_IME_SELECT;
    public static int WM_IME_CHAR;
    public static int WM_IME_REQUEST;
    public static int WM_IME_KEYDOWN;
    public static int WM_IME_KEYUP;
    public static int WM_MOUSEHOVER;
    public static int WM_MOUSELEAVE;
    public static int WM_NCMOUSELEAVE;
    public static int WM_WTSSESSION_CHANGE;
    public static int WM_TABLET_FIRST;
    public static int WM_TABLET_LAST;
    public static int WM_CUT;
    public static int WM_COPY;
    public static int WM_PASTE;
    public static int WM_CLEAR;
    public static int WM_UNDO;
    public static int WM_RENDERFORMAT;
    public static int WM_RENDERALLFORMATS;
    public static int WM_DESTROYCLIPBOARD;
    public static int WM_DRAWCLIPBOARD;
    public static int WM_PAINTCLIPBOARD;
    public static int WM_VSCROLLCLIPBOARD;
    public static int WM_SIZECLIPBOARD;
    public static int WM_ASKCBFORMATNAME;
    public static int WM_CHANGECBCHAIN;
    public static int WM_HSCROLLCLIPBOARD;
    public static int WM_QUERYNEWPALETTE;
    public static int WM_PALETTEISCHANGING;
    public static int WM_PALETTECHANGED;
    public static int WM_HOTKEY;
    public static int WM_PRINT;
    public static int WM_PRINTCLIENT;
    public static int WM_APPCOMMAND;
    public static int WM_THEMECHANGED;
    public static int WM_HANDHELDFIRST;
    public static int WM_HANDHELDLAST;
    public static int WM_AFXFIRST;
    public static int WM_AFXLAST;
    public static int WM_PENWINFIRST;
    public static int WM_PENWINLAST;
    public static int WM_USER;
    public static int WM_REFLECT;
    public static int WM_APP;
    public static int WS_OVERLAPPED;
    public static int WS_POPUP;
    public static int WS_CHILD;
    public static int WS_MINIMIZE;
    public static int WS_VISIBLE;
    public static int WS_DISABLED;
    public static int WS_CLIPSIBLINGS;
    public static int WS_CLIPCHILDREN;
    public static int WS_MAXIMIZE;
    public static int WS_CAPTION;
    public static int WS_BORDER;
    public static int WS_DLGFRAME;
    public static int WS_VSCROLL;
    public static int WS_HSCROLL;
    public static int WS_SYSMENU;
    public static int WS_THICKFRAME;
    public static int WS_GROUP;
    public static int WS_TABSTOP;
    public static int WS_MINIMIZEBOX;
    public static int WS_MAXIMIZEBOX;
    public static int WS_TILED;
    public static int WS_ICONIC;
    public static int WS_SIZEBOX;
    public static int WS_TILEDWINDOW;
    public static int WS_OVERLAPPEDWINDOW;
    public static int WS_POPUPWINDOW;
    public static int WS_CHILDWINDOW;
    public static int WS_EX_DLGMODALFRAME;
    public static int WS_EX_NOPARENTNOTIFY;
    public static int WS_EX_TOPMOST;
    public static int WS_EX_ACCEPTFILES;
    public static int WS_EX_TRANSPARENT;
    public static int WS_EX_MDICHILD;
    public static int WS_EX_TOOLWINDOW;
    public static int WS_EX_WINDOWEDGE;
    public static int WS_EX_CLIENTEDGE;
    public static int WS_EX_CONTEXTHELP;
    public static int WS_EX_RIGHT;
    public static int WS_EX_LEFT;
    public static int WS_EX_RTLREADING;
    public static int WS_EX_LTRREADING;
    public static int WS_EX_LEFTSCROLLBAR;
    public static int WS_EX_RIGHTSCROLLBAR;
    public static int WS_EX_CONTROLPARENT;
    public static int WS_EX_STATICEDGE;
    public static int WS_EX_APPWINDOW;
    public static int WS_EX_OVERLAPPEDWINDOW;
    public static int WS_EX_PALETTEWINDOW;
    public static int WS_EX_LAYERED;
    public static int WS_EX_NOINHERITLAYOUT;
    public static int WS_EX_LAYOUTRTL;
    public static int WS_EX_COMPOSITED;
    public static int WS_EX_NOACTIVATE;
    public static int CBN_ERRSPACE;
    public static int CBN_SELCHANGE;
    public static int CBN_DBLCLK;
    public static int CBN_SETFOCUS;
    public static int CBN_KILLFOCUS;
    public static int CBN_EDITCHANGE;
    public static int CBN_EDITUPDATE;
    public static int CBN_DROPDOWN;
    public static int CBN_CLOSEUP;
    public static int CBN_SELENDOK;
    public static int CBN_SELENDCANCEL;
    public static int UIS_SET;
    public static int UIS_CLEAR;
    public static int UIS_INITIALIZE;
    public static int UISF_HIDEFOCUS;
    public static int UISF_HIDEACCEL;
    public static int UISF_ACTIVE;
    internal static UInt32 CLSCTX_INPROC_SERVER;
    public static int CHILDID_SELF;
    public static UInt32 MF_BYCOMMAND;
    public static UInt32 MF_BYPOSITION;
    public static UInt32 MF_ENABLED;
    public static UInt32 MF_GRAYED;
    public static UInt32 MF_DISABLED;
    private static int VBM__BASE;
    public static int VSINPUT_PROCESSING_MSG;
    internal static int PSN_APPLY;
    internal static int PSN_KILLACTIVE;
    internal static int PSN_RESET;
    internal static int PSN_SETACTIVE;
    internal static int PSN_QUERYCANCEL;
    internal static int QS_KEY;
    internal static int QS_MOUSEMOVE;
    internal static int QS_MOUSEBUTTON;
    internal static int QS_POSTMESSAGE;
    internal static int QS_TIMER;
    internal static int QS_PAINT;
    internal static int QS_SENDMESSAGE;
    internal static int QS_HOTKEY;
    internal static int QS_ALLPOSTMESSAGE;
    internal static int QS_MOUSE;
    internal static int QS_INPUT;
    internal static int QS_ALLEVENTS;
    internal static int QS_ALLINPUT;
    internal static int QS_EVENT;
    internal static int PM_NOREMOVE;
    internal static int PM_REMOVE;
    internal static int PM_NOYIELD;
    internal static int MWMO_WAITALL;
    internal static int MWMO_ALERTABLE;
    internal static int MWMO_INPUTAVAILABLE;
    internal static int DLGC_WANTARROWS;
    internal static int DLGC_WANTTAB;
    internal static int DLGC_WANTALLKEYS;
    internal static int DLGC_WANTMESSAGE;
    internal static int DLGC_HASSETSEL;
    internal static int DLGC_DEFPUSHBUTTON;
    internal static int DLGC_UNDEFPUSHBUTTON;
    internal static int DLGC_RADIOBUTTON;
    internal static int DLGC_WANTCHARS;
    internal static int DLGC_STATIC;
    internal static int DLGC_BUTTON;
    public static int NOTIFYOWNERACTIVATE { get; }
    public static int PROCESSUIBACKGROUNDTASKS { get; }
    internal static ModifierKeys ModifierKeys { get; }
    private static NativeMethods();
    public static int get_NOTIFYOWNERACTIVATE();
    public static int get_PROCESSUIBACKGROUNDTASKS();
    public static IntPtr SetCursor(IntPtr hCursor);
    public static IntPtr GetCapture();
    public static bool ShowOwnedPopups(IntPtr hwnd, bool fShow);
    private static bool GetWindowPlacement(IntPtr hwnd, WINDOWPLACEMENT lpwndpl);
    public static WINDOWPLACEMENT GetWindowPlacement(IntPtr hwnd);
    internal static bool GetCursorPos(POINT& point);
    [DefaultDllImportSearchPathsAttribute("4096")]
public static bool GetNamedPipeClientProcessId(IntPtr pipeHandle, Int32& clientProcessId);
    public static bool OpenProcessToken(IntPtr processHandle, UInt32 desiredAccess, IntPtr& tokenHandle);
    [DefaultDllImportSearchPathsAttribute("4096")]
public static bool GetTokenInformation(IntPtr tokenHandle, TOKEN_INFORMATION_CLASS tokenInformationClass, IntPtr tokenInformation, UInt32 tokenInformationLength, UInt32& returnLength);
    [DefaultDllImportSearchPathsAttribute("4096")]
public static IntPtr GetSidSubAuthority(IntPtr pSid, int nSubAuthority);
    internal static Point GetCursorPos();
    public static int GetSysColor(int nIndex);
    internal static int GetSystemMetrics(int index);
    internal static bool SystemParametersInfo(int uiAction, int uiParam, NONCLIENTMETRICS& pvParam, int fWinIni);
    internal static IntPtr GetSystemMenu(IntPtr hwnd, bool bRevert);
    internal static int TrackPopupMenuEx(IntPtr hmenu, UInt32 fuFlags, int x, int y, IntPtr hwnd, IntPtr lptpm);
    internal static bool EnableMenuItem(IntPtr menu, UInt32 uIDEnableItem, UInt32 uEnable);
    public static int RegisterWindowMessage(string lpString);
    internal static short GetAsyncKeyState(int vKey);
    public static int GetMessagePos();
    public static int MsgWaitForMultipleObjectsEx(int nCount, IntPtr[] pHandles, int dwMilliseconds, int dwWakeMask, int dwFlags);
    internal static short GetKeyState(int vKey);
    internal static bool IsKeyPressed(int vKey);
    private static IntPtr LoadLibraryEx(string filename, IntPtr hReservedNull, LoadLibraryFlags flags);
    public static IntPtr LoadLibraryEx(string filename, LoadLibraryFlags flags);
    public static IntPtr LoadLibraryAsDataFile(string filename);
    public static bool FreeLibrary(IntPtr handle);
    public static IntPtr FindResource(IntPtr hModule, int lpName, int lpType);
    public static IntPtr FindResource(IntPtr hModule, int lpName, string lpType);
    public static IntPtr FindResource(IntPtr hModule, string lpName, int lpType);
    public static IntPtr FindResource(IntPtr hModule, string lpName, string lpType);
    public static IntPtr FindResource(IntPtr hModule, NativeResourceIdentifier nameId, NativeResourceIdentifier typeId);
    public static IntPtr LoadResource(IntPtr hModule, IntPtr hResInfo);
    public static IntPtr LockResource(IntPtr hResData);
    public static int SizeofResource(IntPtr hModule, IntPtr hResInfo);
    public static IntPtr EnumResourceNames(IntPtr hModule, string type, EnumResourceNameProc callback, IntPtr lParam);
    public static IntPtr EnumResourceNames(IntPtr hModule, int id, EnumResourceNameProc callback, IntPtr lParam);
    public static IntPtr EnumResourceNames(IntPtr hModule, NativeResourceIdentifier id, EnumResourceNameProc callback, IntPtr lParam);
    public static IntPtr LoadImage(IntPtr hModule, string name, LoadImageType type, int cx, int cy, LoadImageFlags flags);
    public static IntPtr LoadImage(IntPtr hModule, int id, LoadImageType type, int cx, int cy, LoadImageFlags flags);
    public static IntPtr LoadImage(IntPtr hModule, NativeResourceIdentifier id, LoadImageType type, int cx, int cy, LoadImageFlags flags);
    internal static bool IsLeftButtonPressed();
    internal static bool IsRightButtonPressed();
    internal static bool IsControlPressed();
    internal static bool IsShiftPressed();
    internal static bool IsAltPressed();
    internal static ModifierKeys get_ModifierKeys();
    internal static IntPtr MakeParam(int lowWord, int highWord);
    internal static int GetXLParam(int lParam);
    internal static int GetYLParam(int lParam);
    internal static int HiWord(int value);
    internal static int LoWord(int value);
    internal static bool ScreenToClient(IntPtr hWnd, POINT& point);
    internal static bool GetKeyboardState(Byte* lpKeyState);
    internal static UInt32 MapVirtualKey(UInt32 uCode, UInt32 uMapType);
    internal static IntPtr MonitorFromWindow(IntPtr handle, int flags);
    internal static IntPtr MonitorFromPoint(POINT pt, int flags);
    public static IntPtr GetForegroundWindow();
    public static UInt32 GetWindowThreadProcessId(IntPtr hWnd, UInt32& processId);
    internal static bool BringWindowToTop(IntPtr hWnd);
    internal static bool ClientToScreen(IntPtr hWnd, POINT& point);
    internal static IntPtr DefWindowProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
    public static bool EnumThreadWindows(UInt32 dwThreadId, EnumWindowsProc lpfn, IntPtr lParam);
    public static bool EnumChildWindows(IntPtr hwndParent, EnumWindowsProc lpEnumFunc, IntPtr lParam);
    public static bool SetWindowText(IntPtr hWnd, string lpString);
    public static bool PostMessage(IntPtr hWnd, int nMsg, IntPtr wParam, IntPtr lParam);
    public static bool PostThreadMessage(UInt32 threadId, UInt32 msg, IntPtr wParam, IntPtr lParam);
    internal static bool PrintWindow(IntPtr hwnd, IntPtr hDC, UInt32 nFlags);
    internal static bool PrintWindow(HandleRef hwnd, HandleRef hDC, UInt32 nFlags);
    internal static int GetBitmapBits(IntPtr hbmp, int cbBuffer, Byte[] lpvBits);
    internal static int GetBitmapBits(IntPtr hbmp, int cbBuffer, IntPtr lpvBits);
    internal static int GetDIBits(IntPtr hdc, IntPtr hbmp, UInt32 uStartScan, UInt32 cScanLines, Byte[] lpvBits, BITMAPINFO& lpbmi, UInt32 uUsage);
    internal static IntPtr CreateBitmap(int nWidth, int nHeight, UInt32 cPlanes, UInt32 cBitsPerPel, IntPtr lpvBits);
    internal static IntPtr GetDC(IntPtr hWnd);
    internal static IntPtr GetDC(HandleRef hWnd);
    internal static IntPtr GetDCEx(IntPtr hWnd, IntPtr hrgnClip, int dwFlags);
    internal static int ReleaseDC(IntPtr hWnd, IntPtr hDC);
    internal static int ReleaseDC(HandleRef hWnd, HandleRef hDC);
    internal static bool DeleteDC(IntPtr hdc);
    internal static bool DeleteDC(HandleRef hdc);
    internal static IntPtr CreateCompatibleDC(IntPtr hdc);
    internal static IntPtr CreateCompatibleDC(HandleRef hdc);
    internal static IntPtr CreateCompatibleBitmap(IntPtr hdc, int nWidth, int nHeight);
    internal static IntPtr CreateCompatibleBitmap(HandleRef hdc, int nWidth, int nHeight);
    internal static IntPtr SelectObject(IntPtr hdc, IntPtr hgdiobj);
    internal static IntPtr SelectObject(HandleRef hdc, IntPtr hgdiobj);
    internal static int GetDeviceCaps(IntPtr hdc, int nIndex);
    internal static IntPtr CreateRoundRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidthEllipse, int nHeightEllipse);
    internal static IntPtr CreateRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);
    internal static IntPtr CreateRectRgnIndirect(RECT& lprc);
    private static int CombineRgn(IntPtr hrngDest, IntPtr hrgnSrc1, IntPtr hrgnSrc2, int fnCombineMode);
    internal static int CombineRgn(IntPtr hrnDest, IntPtr hrgnSrc1, IntPtr hrgnSrc2, CombineMode combineMode);
    internal static int SetWindowRgn(IntPtr hWnd, IntPtr hRgn, bool redraw);
    internal static bool PostMessage(IntPtr hwnd, int msg);
    internal static bool PostMessage(IntPtr hwnd, int msg, IntPtr wParam);
    internal static IntPtr SetCapture(IntPtr hWnd);
    internal static bool ReleaseCapture();
    public static IntPtr SendMessage(IntPtr hWnd, int nMsg, IntPtr wParam, IntPtr lParam);
    internal static IntPtr SendMessage(IntPtr hwnd, int msg);
    internal static IntPtr SendMessage(IntPtr hwnd, int msg, IntPtr wParam);
    public static IntPtr SetFocus(IntPtr hWnd);
    public static IntPtr SetActiveWindow(IntPtr hWnd);
    public static IntPtr GetWindow(IntPtr hwnd, int nCmd);
    public static bool GetWindowInfo(IntPtr hwnd, WINDOWINFO& pwi);
    public static int GetMessageTime();
    public static bool IsWindowEnabled(IntPtr hwnd);
    public static bool IsWindowVisible(IntPtr hwnd);
    public static bool IsIconic(IntPtr hwnd);
    public static bool IsZoomed(IntPtr hwnd);
    internal static bool IsWindow(IntPtr hWnd);
    public static int OleSetContainedObject(IntPtr punkObj, bool fVisible);
    public static int OleRun(IntPtr punkObj);
    public static int CopyAcceleratorTable(IntPtr hAccelSrc, ACCEL[] lpAccelDst, int cAccelEntries);
    public static IntPtr GetFocus();
    public static IntPtr GetActiveWindow();
    public static bool IsChild(IntPtr hWndParent, IntPtr hWnd);
    public static bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, int flags);
    public static int ImageList_Draw(HandleRef hImageList, int i, HandleRef hdc, int x, int y, int fStyle);
    private static int GetWindowLong(IntPtr hWnd, int nIndex);
    private static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex);
    [ExtensionAttribute]
public static bool SetWindowSubclass(IntPtr hwnd, SubclassProc callback, UIntPtr id, IntPtr refData);
    public static IntPtr DefSubclassProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam);
    public static bool RemoveWindowSubclass(IntPtr hwnd, SubclassProc callback, UIntPtr id);
    public static IntPtr GetWindowLongPtr(IntPtr hWnd, GWLP nIndex);
    public static int GetWindowLong(IntPtr hWnd, GWL nIndex);
    public static bool GetWindowRect(IntPtr hwnd, RECT& lpRect);
    public static bool GetClientRect(IntPtr hwnd, RECT& lpRect);
    private static int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);
    private static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    public static IntPtr SetWindowLongPtr(IntPtr hWnd, GWLP nIndex, IntPtr dwNewLong);
    public static IntPtr SetWndProc(IntPtr hWnd, WndProc newWndProc);
    public static int SetWindowLong(IntPtr hWnd, GWL nIndex, int dwNewLong);
    public static bool SetLayeredWindowAttributes(IntPtr hwnd, int crKey, byte bAlpha, int dwFlags);
    public static ushort RegisterClassEx(WNDCLASSEX& lpWndClass);
    public static ushort RegisterClass(WNDCLASS& lpWndClass);
    public static IntPtr OpenEvent(UInt32 dwDesiredAccess, bool bInheritHandle, string lpName);
    public static bool SetEvent(IntPtr hEvent);
    public static bool CloseHandle(IntPtr handle);
    public static UInt32 GetCurrentThreadId();
    public static UInt32 GetCurrentProcessId();
    public static IntPtr SetWindowsHookEx(WindowsHookType hookType, WindowsHookProc hookProc, IntPtr module, UInt32 threadId);
    public static IntPtr CallNextHookEx(IntPtr hhk, CbtHookAction code, IntPtr wParam, IntPtr lParam);
    public static bool UnhookWindowsHookEx(IntPtr hhk);
    public static int VariantClear(VARIANT& var);
    private static int VariantChangeType(Object& pvargDest, Object& pvarSrc, VARIANTFLAGS wFlags, ushort vt);
    public static int VariantChangeType(Object& pvargDest, Object& pvarSrc, VARIANTFLAGS wFlags, VarEnum vt);
    public static IntPtr GetStockObject(int fnObject);
    public static IntPtr GetStockObject(StockObjects objectID);
    public static IntPtr CreateWindowEx(int dwExStyle, IntPtr classAtom, string lpWindowName, int dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    public static IntPtr CreateWindowEx(int dwExStyle, string className, string lpWindowName, int dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    public static IntPtr GetModuleHandle(string moduleName);
    public static bool GetFileInformationByHandleEx(IntPtr hFile, UInt32 FileInformationClass, _FILE_STANDARD_INFO& lpFileInformation, UInt32 dwBufferSize);
    public static bool GetFileInformationByHandleEx(IntPtr hFile, UInt32 FileInformationClass, _FILE_COMPRESSION_INFORMATION& lpFileInformation, UInt32 dwBufferSize);
    public static bool GetDiskFreeSpace(string lpRootPathName, UInt32& lpSectorsPerCluster, UInt32& lpBytesPerSector, UInt32& lpNumberOfFreeClusters, UInt32& lpTotalNumberOfClusters);
    public static bool GetVolumeInformation(string RootPathName, StringBuilder VolumeNameBuffer, int VolumeNameSize, UInt32& VolumeSerialNumber, UInt32& MaximumComponentLength, FileSystemFeature& FileSystemFlags, StringBuilder FileSystemNameBuffer, int nFileSystemNameSize);
    public static bool DeviceIoControl(IntPtr hDevice, int dwIoControlCode, Int16& InBuffer, int nInBufferSize, IntPtr OutBuffer, int nOutBufferSize, Int32& pBytesReturned, IntPtr lpOverlapped);
    public static bool TranslateMessage(MSG& lpMsg);
    public static IntPtr DispatchMessage(MSG& lpmsg);
    public static bool PeekMessage(MSG& lpMsg, IntPtr hWnd, UInt32 wMsgFilterMin, UInt32 wMsgFilterMax, UInt32 wRemoveMsg);
    public static IntPtr CreateSolidBrush(int colorref);
    public static bool DeleteObject(IntPtr hObject);
    public static bool DeleteObject(HandleRef hObject);
    public static bool ShowWindow(IntPtr hwnd, int code);
    public static bool MoveWindow(IntPtr hwnd, int x, int y, int width, int height, bool repaint);
    public static bool DestroyWindow(IntPtr hwnd);
    public static bool UnregisterClass(IntPtr classAtom, IntPtr hInstance);
    public static bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDest, POINT& pptDest, Win32SIZE& psize, IntPtr hdcSrc, POINT& pptSrc, UInt32 crKey, BLENDFUNCTION& pblend, UInt32 dwFlags);
    public static bool RedrawWindow(IntPtr hWnd, IntPtr lprcUpdate, IntPtr hrgnUpdate, RedrawWindowFlags flags);
    public static IntPtr WindowFromPoint(POINT pt);
    public static IntPtr GetAncestor(IntPtr hWnd, int flags);
    public static bool FillRect(IntPtr hDC, RECT& rect, IntPtr hbrush);
    public static IntPtr GetParent(IntPtr hWnd);
    public static bool SetProp(IntPtr hwnd, string propName, IntPtr value);
    public static IntPtr GetProp(IntPtr hwnd, string propName);
    public static IntPtr RemoveProp(IntPtr hwnd, string propName);
    public static IntPtr SetParent(IntPtr hChild, IntPtr hNewParent);
    public static int RevokeDragDrop(IntPtr hwnd);
    public static bool PathIsNetworkPath(string path);
    public static int ExtractIconEx(string szFileName, int nIconIndex, IntPtr* phiconLarge, IntPtr* phiconSmall, int nIcons);
    public static SafeIcon ExtractIcon(string filename, int index, bool large);
    public static IntPtr SHGetFileInfo(string pszPath, UInt32 dwFileAttributes, SHFILEINFO& psfi, UInt32 cbFileInfo, SHGFI uFlags);
    private static void SHAddToRecentDocs(SHARD uFlags, string pv);
    internal static void SHAddToRecentDocs(string path);
    public static bool DestroyIcon(IntPtr hIcon);
    public static bool GetIconInfo(IntPtr hIcon, ICONINFO& piconinfo);
    internal static IntPtr ImageList_Create(int cx, int cy, ILC flags, int cInitial, int cGrow);
    internal static IntPtr ImageList_Destroy(IntPtr himl);
    internal static int ImageList_Add(IntPtr himl, IntPtr hbmImage, IntPtr hbmMask);
    internal static int ImageList_GetImageCount(IntPtr himl);
    internal static IntPtr ImageList_GetIcon(IntPtr himl, int i, UInt32 flags);
    internal static bool ImageList_GetIconSize(IntPtr himl, Int32& cx, Int32& cy);
    internal static bool ImageList_GetImageInfo(IntPtr himl, int i, IMAGEINFO& pImageInfo);
    internal static int ImageList_GetBkColor(IntPtr himl);
    internal static int GetObject(IntPtr hGdiObj, int cbBuffer, IntPtr lpvObject);
    internal static int GetObject(IntPtr hGdiObj, int cbBuffer, BITMAP bm);
    internal static GdiObjectType GetObjectType(IntPtr hGdiObj);
    internal static bool EnumDisplayMonitors(IntPtr hdc, IntPtr lprcClip, EnumMonitorsDelegate lpfnEnum, IntPtr dwData);
    internal static bool IntersectRect(RECT& lprcDst, RECT& lprcSrc1, RECT& lprcSrc2);
    internal static bool PtInRect(RECT& lprc, POINT pt);
    internal static bool GetMonitorInfo(IntPtr hMonitor, MONITORINFO& monitorInfo);
    internal static IntPtr CreateIconFromResourceEx(Byte[] pbIconBits, int cbIconBits, bool fIcon, int dwVersion, int cxDesired, int cyDesired, int flags);
    internal static int OleCreatePictureIndirect(PictDescBitmap& pictdesc, Guid& iid, bool fOwn, Object& ppVoid);
    internal static void CopyMemory(IntPtr Destination, IntPtr Source, UInt32 Length);
    internal static IntPtr CreateDIBSection(IntPtr hdc, BITMAPINFO& pbmi, UInt32 iUsage, IntPtr& ppvBits, IntPtr hSection, UInt32 dwOffset);
    internal static bool AlphaBlend(IntPtr hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, IntPtr hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION pfn);
    private static WINDOWPOS LParamToWindowPos(IntPtr lParam);
    public static UInt32 GetWindowPosFlags(IntPtr lParam);
    public static Size GetWindowPosSize(IntPtr lParam);
    public static int BooleanToNativeBOOL(bool value);
    public static int GET_SC_WPARAM(IntPtr wParam);
    internal static bool IsDialogMessage(IntPtr hDlg, MSG& lpMsg);
    internal static IntPtr GetNextDlgTabItem(IntPtr hDlg, IntPtr hCtl, bool bPrevious);
    internal static IntPtr GetTopWindow(IntPtr parent);
    internal static IntPtr GetCurrentThread();
    internal static bool SetThreadPriority(IntPtr hThread, ThreadPriority nPriority);
    public static UInt32 GetPrivateProfileString(string section, string key, string defaultValue, StringBuilder buffer, UInt32 bufferCharLength, string path);
    public static int GetPrivateProfileInt(string section, string key, int defaultValue, string path);
    public static int WritePrivateProfileString(string section, string key, string value, string path);
}
internal class Microsoft.VisualStudio.PlatformUI.NativeResourceIdentifier : ValueType {
    private int _integerId;
    private string _stringId;
    public object Id { get; }
    public int IntegerId { get; }
    public string StringId { get; }
    public bool IsIntegerId { get; }
    public bool IsStringId { get; }
    public NativeResourceIdentifier(int id);
    public NativeResourceIdentifier(string id);
    public NativeResourceIdentifier(object id);
    public object get_Id();
    public int get_IntegerId();
    public string get_StringId();
    public bool get_IsIntegerId();
    public bool get_IsStringId();
    public virtual string ToString();
    private static void ValidateStringId(string id);
}
internal class Microsoft.VisualStudio.PlatformUI.NMHDR : ValueType {
    public IntPtr hwndFrom;
    public IntPtr idFrom;
    public int code;
}
internal class Microsoft.VisualStudio.PlatformUI.NONCLIENTMETRICS : ValueType {
    public int cbSize;
    public int iBorderWidth;
    public int iScrollWidth;
    public int iScrollHeight;
    public int iCaptionWidth;
    public int iCaptionHeight;
    public LOGFONT lfCaptionFont;
    public int iSmCaptionWidth;
    public int iSmCaptionHeight;
    public LOGFONT lfSmCaptionFont;
    public int iMenuWidth;
    public int iMenuHeight;
    public LOGFONT lfMenuFont;
    public LOGFONT lfStatusFont;
    public LOGFONT lfMessageFont;
    public int iPaddedBorderWidth;
}
internal enum Microsoft.VisualStudio.PlatformUI.OLEIVERB : Enum {
    public int value__;
    public static OLEIVERB OLEIVERB_PRIMARY;
    public static OLEIVERB OLEIVERB_SHOW;
    public static OLEIVERB OLEIVERB_OPEN;
    public static OLEIVERB OLEIVERB_HIDE;
    public static OLEIVERB OLEIVERB_UIACTIVATE;
    public static OLEIVERB OLEIVERB_INPLACEACTIVATE;
    public static OLEIVERB OLEIVERB_DISCARDUNDOSTATE;
}
internal class Microsoft.VisualStudio.PlatformUI.POINT : ValueType {
    public int x;
    public int y;
}
internal class Microsoft.VisualStudio.PlatformUI.PSHNOTIFY : ValueType {
    public NMHDR hdr;
    public IntPtr lparam;
}
internal class Microsoft.VisualStudio.PlatformUI.RECT : ValueType {
    public int Left;
    public int Top;
    public int Right;
    public int Bottom;
    public Point Position { get; }
    public Size Size { get; }
    public int Height { get; public set; }
    public int Width { get; public set; }
    public RECT(int left, int top, int right, int bottom);
    public RECT(Rect rect);
    public Point get_Position();
    public Size get_Size();
    public Int32Rect ToInt32Rect();
    public void Offset(int dx, int dy);
    public int get_Height();
    public void set_Height(int value);
    public int get_Width();
    public void set_Width(int value);
}
internal class Microsoft.VisualStudio.PlatformUI.RGBQUAD : ValueType {
    private byte rgbBlue;
    private byte rgbGreen;
    private byte rgbRed;
    private byte rgbReserved;
    public static RGBQUAD FromDWORD(UInt32 rgbq);
    public static RGBQUAD FromMediaColor(Color color);
    public Color ToMediaColor();
}
internal class Microsoft.VisualStudio.PlatformUI.SafeIcon : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeIcon(IntPtr icon, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.VisualStudio.PlatformUI.SHFILEINFO : ValueType {
    public IntPtr hIcon;
    public int iIcon;
    public UInt32 dwAttributes;
    public string szDisplayName;
    public string szTypeName;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.PlatformUI.SHGFI : Enum {
    public UInt32 value__;
    public static SHGFI Icon;
    public static SHGFI DisplayName;
    public static SHGFI TypeName;
    public static SHGFI Attributes;
    public static SHGFI IconLocation;
    public static SHGFI ExeType;
    public static SHGFI SysIconIndex;
    public static SHGFI LinkOverlay;
    public static SHGFI Selected;
    public static SHGFI Attr_Specified;
    public static SHGFI LargeIcon;
    public static SHGFI SmallIcon;
    public static SHGFI OpenIcon;
    public static SHGFI ShellIconSize;
    public static SHGFI PIDL;
    public static SHGFI UseFileAttributes;
    public static SHGFI AddOverlays;
    public static SHGFI OverlayIndex;
}
internal class Microsoft.VisualStudio.PlatformUI.StreamConsts : object {
    public static int LOCK_WRITE;
    public static int LOCK_EXCLUSIVE;
    public static int LOCK_ONLYONCE;
    public static int STATFLAG_DEFAULT;
    public static int STATFLAG_NONAME;
    public static int STATFLAG_NOOPEN;
    public static int STGC_DEFAULT;
    public static int STGC_OVERWRITE;
    public static int STGC_ONLYIFCURRENT;
    public static int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE;
    public static int STREAM_SEEK_SET;
    public static int STREAM_SEEK_CUR;
    public static int STREAM_SEEK_END;
}
public class Microsoft.VisualStudio.PlatformUI.ThemedImageConverter : MultiValueConverter`4<ImageSource, Color, bool, Image> {
    protected virtual Image Convert(ImageSource inputImage, Color backgroundColor, bool isEnabled, object parameter, CultureInfo culture);
}
public class Microsoft.VisualStudio.PlatformUI.ThemedImageSourceConverter : MultiValueConverter`4<ImageSource, Color, bool, ImageSource> {
    internal static ImageSource ConvertCore(ImageSource inputImage, Color backgroundColor, bool isEnabled, bool isHighContrast, Nullable`1<bool> enhanceContrastIfNecessary, object parameter);
    public static ImageSource ConvertCore(ImageSource inputImage, Color backgroundColor, bool isEnabled, bool isHighContrast, object parameter);
    public static ImageSource ConvertCore(ImageSource inputImage, Color backgroundColor, bool isEnabled, object parameter);
    protected virtual ImageSource Convert(ImageSource inputImage, Color backgroundColor, bool isEnabled, object parameter, CultureInfo culture);
}
internal enum Microsoft.VisualStudio.PlatformUI.VARIANTFLAGS : Enum {
    public ushort value__;
    public static VARIANTFLAGS NONE;
    public static VARIANTFLAGS VARIANT_NOVALUEPROP;
    public static VARIANTFLAGS VARIANT_ALPHABOOL;
    public static VARIANTFLAGS VARIANT_NOUSEROVERRIDE;
    public static VARIANTFLAGS VARIANT_LOCALBOOL;
}
internal class Microsoft.VisualStudio.PlatformUI.Win32SIZE : ValueType {
    public int cx;
    public int cy;
}
internal class Microsoft.VisualStudio.PlatformUI.WINDOWINFO : ValueType {
    public int cbSize;
    public RECT rcWindow;
    public RECT rcClient;
    public int dwStyle;
    public int dwExStyle;
    public UInt32 dwWindowStatus;
    public UInt32 cxWindowBorders;
    public UInt32 cyWindowBorders;
    public ushort atomWindowType;
    public ushort wCreatorVersion;
}
internal class Microsoft.VisualStudio.PlatformUI.WINDOWPLACEMENT : object {
    public int length;
    public int flags;
    public int showCmd;
    public POINT ptMinPosition;
    public POINT ptMaxPosition;
    public RECT rcNormalPosition;
}
internal class Microsoft.VisualStudio.PlatformUI.WINDOWPOS : object {
    public IntPtr hwnd;
    public IntPtr hwndInsertAfter;
    public int x;
    public int y;
    public int cx;
    public int cy;
    public UInt32 flags;
}
internal class Microsoft.VisualStudio.PlatformUI.WNDCLASS : ValueType {
    public UInt32 style;
    public Delegate lpfnWndProc;
    public int cbClsExtra;
    public int cbWndExtra;
    public IntPtr hInstance;
    public IntPtr hIcon;
    public IntPtr hCursor;
    public IntPtr hbrBackground;
    public string lpszMenuName;
    public string lpszClassName;
}
internal class Microsoft.VisualStudio.PlatformUI.WNDCLASSEX : ValueType {
    public UInt32 cbSize;
    public UInt32 style;
    public Delegate lpfnWndProc;
    public int cbClsExtra;
    public int cbWndExtra;
    public IntPtr hInstance;
    public IntPtr hIcon;
    public IntPtr hCursor;
    public IntPtr hbrBackground;
    public string lpszMenuName;
    public string lpszClassName;
    public IntPtr hIconSm;
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.133.12845")]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string RootNamespace;
    private static ThisAssembly();
}
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "8.0.5.0")]
[EditorBrowsableAttribute("1")]
public class XamlGeneratedNamespace.GeneratedInternalTypeHelper : InternalTypeHelper {
    protected virtual object CreateInstance(Type type, CultureInfo culture);
    protected virtual object GetPropertyValue(PropertyInfo propertyInfo, object target, CultureInfo culture);
    protected virtual void SetPropertyValue(PropertyInfo propertyInfo, object target, object value, CultureInfo culture);
    protected virtual Delegate CreateDelegate(Type delegateType, object target, string handler);
    protected virtual void AddEventHandler(EventInfo eventInfo, object target, Delegate handler);
}
