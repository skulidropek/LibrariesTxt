[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ObsoleteAttribute("EventSourceWriter is no longer supported. Please post events via the PostEvent method on the TelemetrySession.")]
public class Microsoft.VisualStudio.ApplicationInsights.Channel.EventSourceWriter : object {
    private string instrumentationKey;
    private EventSource eventSource;
    private EventSourceOptions eventSourceOptions;
    private bool disposed;
    internal Guid ProviderId { get; }
    internal string ProviderName { get; }
    internal string InstrumentationKey { get; }
    internal EventSourceWriter(string instrumentationKey, bool developerMode);
    internal Guid get_ProviderId();
    internal string get_ProviderName();
    internal string get_InstrumentationKey();
    public sealed virtual void Dispose();
    internal void WriteTelemetry(ITelemetry telemetryItem);
    internal void WriteEvent(string eventName, TelemetryContext context, T data);
    private static string RemoveInvalidInstrumentationKeyChars(string input);
    private void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.FlushManager : object {
    private TelemetryBuffer telemetryBuffer;
    private AutoResetEvent flushWaitHandle;
    private StorageBase storage;
    private int disposeCount;
    private bool flushLoopEnabled;
    [CompilerGeneratedAttribute]
private TimeSpan <FlushDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <EndpointAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    internal TimeSpan FlushDelay { get; internal set; }
    internal Uri EndpointAddress { get; internal set; }
    private string ApiKey { get; }
    internal FlushManager(StorageBase storage, TelemetryBuffer telemetryBuffer, string apiKey, bool supportAutoFlush);
    internal FlushManager(StorageBase storage, TelemetryBuffer telemetryBuffer, bool supportAutoFlush);
    [CompilerGeneratedAttribute]
internal TimeSpan get_FlushDelay();
    [CompilerGeneratedAttribute]
internal void set_FlushDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
internal Uri get_EndpointAddress();
    [CompilerGeneratedAttribute]
internal void set_EndpointAddress(Uri value);
    [CompilerGeneratedAttribute]
private string get_ApiKey();
    public sealed virtual void Dispose();
    internal void Flush();
    private void FlushLoop();
    private void OnTelemetryBufferFull();
}
public class Microsoft.VisualStudio.ApplicationInsights.Channel.InMemoryChannel : object {
    private TelemetryBuffer buffer;
    private InMemoryTransmitter transmitter;
    private bool developerMode;
    private int bufferSize;
    public bool DeveloperMode { get; public set; }
    public TimeSpan SendingInterval { get; public set; }
    public string EndpointAddress { get; public set; }
    [ObsoleteAttribute("This value is now obsolete and will be removed in next release, use SendingInterval instead.")]
public double DataUploadIntervalInSeconds { get; public set; }
    public int MaxTelemetryBufferCapacity { get; public set; }
    internal InMemoryChannel(TelemetryBuffer telemetryBuffer, InMemoryTransmitter transmitter);
    public sealed virtual bool get_DeveloperMode();
    public sealed virtual void set_DeveloperMode(bool value);
    public TimeSpan get_SendingInterval();
    public void set_SendingInterval(TimeSpan value);
    public sealed virtual string get_EndpointAddress();
    public sealed virtual void set_EndpointAddress(string value);
    public double get_DataUploadIntervalInSeconds();
    public void set_DataUploadIntervalInSeconds(double value);
    public int get_MaxTelemetryBufferCapacity();
    public void set_MaxTelemetryBufferCapacity(int value);
    public sealed virtual void Send(ITelemetry item);
    public sealed virtual void Flush();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.InMemoryChannel/<FlushAndTransmitAsync>d__23")]
public sealed virtual Task FlushAndTransmitAsync(CancellationToken token);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.InMemoryTransmitter : object {
    private TelemetryBuffer buffer;
    private object sendingLockObj;
    private AutoResetEvent startRunnerEvent;
    private bool enabled;
    private int disposeCount;
    private TimeSpan sendingInterval;
    private Uri endpointAddress;
    internal Uri EndpointAddress { get; internal set; }
    internal TimeSpan SendingInterval { get; internal set; }
    internal InMemoryTransmitter(TelemetryBuffer buffer);
    internal Uri get_EndpointAddress();
    internal void set_EndpointAddress(Uri value);
    internal TimeSpan get_SendingInterval();
    internal void set_SendingInterval(TimeSpan value);
    public sealed virtual void Dispose();
    internal void Flush();
    private void Runner();
    private void OnBufferFull();
    private void DequeueAndSend();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.InMemoryTransmitter/<SendAsync>d__19")]
private Task SendAsync(IEnumerable`1<ITelemetry> telemetryItems);
    private void Dispose(bool disposing);
}
public interface Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry {
    public DateTimeOffset Timestamp { get; public set; }
    public TelemetryContext Context { get; }
    public string Sequence { get; public set; }
    public abstract virtual DateTimeOffset get_Timestamp();
    public abstract virtual void set_Timestamp(DateTimeOffset value);
    public abstract virtual TelemetryContext get_Context();
    public abstract virtual string get_Sequence();
    public abstract virtual void set_Sequence(string value);
    public abstract virtual void Sanitize();
}
public interface Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetryChannel {
    public bool DeveloperMode { get; public set; }
    public string EndpointAddress { get; public set; }
    public abstract virtual bool get_DeveloperMode();
    public abstract virtual void set_DeveloperMode(bool value);
    public abstract virtual string get_EndpointAddress();
    public abstract virtual void set_EndpointAddress(string value);
    public abstract virtual void Send(ITelemetry item);
    public abstract virtual void Flush();
    public abstract virtual Task FlushAndTransmitAsync(CancellationToken token);
}
internal static class Microsoft.VisualStudio.ApplicationInsights.Channel.JsonSerializer : object {
    private static UTF8Encoding TransmissionEncoding;
    internal static string CompressionType { get; }
    private static JsonSerializer();
    internal static string get_CompressionType();
    internal static Byte[] Serialize(IEnumerable`1<ITelemetry> telemetryItems, bool compress);
    internal static Byte[] Serialize(ITelemetry telemetryItem, bool compress);
    internal static string SerializeAsString(IEnumerable`1<ITelemetry> telemetryItems);
    internal static string SerializeAsString(ITelemetry telemetry);
    private static void ConvertExceptionTree(Exception exception, ExceptionDetails parentExceptionDetails, List`1<ExceptionDetails> exceptions);
    private static void SerializeExceptions(IEnumerable`1<ExceptionDetails> exceptions, IJsonWriter writer);
    private static void SerializeStackFrame(StackFrame frame, IJsonWriter writer);
    private static Stream CreateCompressedStream(Stream stream);
    private static void SerializeTelemetryItem(ITelemetry telemetryItem, JsonWriter jsonWriter);
    private static void SeializeToStream(IEnumerable`1<ITelemetry> telemetryItems, TextWriter streamWriter);
    private static void SerializeEventTelemetry(EventTelemetry eventTelemetry, JsonWriter writer);
    private static void SerializeExceptionTelemetry(ExceptionTelemetry exceptionTelemetry, JsonWriter writer);
    private static void SerializeMetricTelemetry(MetricTelemetry metricTelemetry, JsonWriter writer);
    private static void SerializePageViewTelemetry(PageViewTelemetry pageViewTelemetry, JsonWriter writer);
    private static void SerializeRemoteDependencyTelemetry(RemoteDependencyTelemetry remoteDependencyTelemetry, JsonWriter writer);
    private static void SerializeRequestTelemetry(RequestTelemetry requestTelemetry, JsonWriter jsonWriter);
    private static void SerializeSessionStateTelemetry(SessionStateTelemetry sessionStateTelemetry, JsonWriter jsonWriter);
    private static void SerializeTraceTelemetry(TraceTelemetry traceTelemetry, JsonWriter writer);
    private static void SerializePerformanceCounter(PerformanceCounterTelemetry performanceCounter, JsonWriter writer);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.PersistenceChannel : object {
    internal TelemetryBuffer TelemetryBuffer;
    internal PersistenceTransmitter Transmitter;
    private FlushManager flushManager;
    private bool developerMode;
    private int disposeCount;
    private int telemetryBufferSize;
    private StorageBase storage;
    [CompilerGeneratedAttribute]
private double <StopUploadAfterIntervalInSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTransmissionBufferCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTransmissionSenderCapacity>k__BackingField;
    public string StorageUniqueFolder { get; }
    public bool DeveloperMode { get; public set; }
    public TimeSpan SendingInterval { get; public set; }
    public TimeSpan FlushInterval { get; public set; }
    public string EndpointAddress { get; public set; }
    public int MaxTelemetryBufferCapacity { get; public set; }
    public ulong MaxTransmissionStorageCapacity { get; public set; }
    public UInt32 MaxTransmissionStorageFilesCapacity { get; public set; }
    [ObsoleteAttribute("This value is now obsolete and will be removed in next release. Currently it does nothing.")]
public double StopUploadAfterIntervalInSeconds { get; public set; }
    [ObsoleteAttribute("This value is now obsolete and will be removed in next release, use FlushInterval instead.")]
public double DataUploadIntervalInSeconds { get; public set; }
    [ObsoleteAttribute("This value is now obsolete and will be removed in next release. Currently it does nothing.")]
public int MaxTransmissionBufferCapacity { get; public set; }
    [ObsoleteAttribute("This value is now obsolete and will be removed in next release, use the sendersCount parameter in the constructor instead.")]
public int MaxTransmissionSenderCapacity { get; public set; }
    public PersistenceChannel(TelemetrySession hostSession, StorageBase storage, IProcessLockFactory processLockFactory, string apiKey, int sendersCount);
    public string get_StorageUniqueFolder();
    public sealed virtual bool get_DeveloperMode();
    public sealed virtual void set_DeveloperMode(bool value);
    public TimeSpan get_SendingInterval();
    public void set_SendingInterval(TimeSpan value);
    public TimeSpan get_FlushInterval();
    public void set_FlushInterval(TimeSpan value);
    public sealed virtual string get_EndpointAddress();
    public sealed virtual void set_EndpointAddress(string value);
    public int get_MaxTelemetryBufferCapacity();
    public void set_MaxTelemetryBufferCapacity(int value);
    public ulong get_MaxTransmissionStorageCapacity();
    public void set_MaxTransmissionStorageCapacity(ulong value);
    public UInt32 get_MaxTransmissionStorageFilesCapacity();
    public void set_MaxTransmissionStorageFilesCapacity(UInt32 value);
    [CompilerGeneratedAttribute]
public double get_StopUploadAfterIntervalInSeconds();
    [CompilerGeneratedAttribute]
public void set_StopUploadAfterIntervalInSeconds(double value);
    public double get_DataUploadIntervalInSeconds();
    public void set_DataUploadIntervalInSeconds(double value);
    [CompilerGeneratedAttribute]
public int get_MaxTransmissionBufferCapacity();
    [CompilerGeneratedAttribute]
public void set_MaxTransmissionBufferCapacity(int value);
    [CompilerGeneratedAttribute]
public int get_MaxTransmissionSenderCapacity();
    [CompilerGeneratedAttribute]
public void set_MaxTransmissionSenderCapacity(int value);
    public sealed virtual void Dispose();
    public sealed virtual void Send(ITelemetry item);
    public sealed virtual void Flush();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistenceChannel/<FlushAndTransmitAsync>d__49")]
public sealed virtual Task FlushAndTransmitAsync(CancellationToken token);
    public sealed virtual void Initialize(TelemetryConfiguration configuration);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.PersistenceTransmitter : object {
    private IProcessLock locker;
    private ConcurrentBag`1<Sender> senders;
    private StorageBase storage;
    private CancellationTokenSource sendingCancellationTokenSource;
    private int disposeCount;
    private AutoResetEvent eventToKeepMutexThreadAlive;
    [CompilerGeneratedAttribute]
private TimeSpan <SendingInterval>k__BackingField;
    internal string StorageUniqueFolder { get; }
    internal TimeSpan SendingInterval { get; internal set; }
    internal PersistenceTransmitter(StorageBase storage, int sendersCount, bool createSenders);
    internal PersistenceTransmitter(StorageBase storage, int sendersCount, IProcessLockFactory processLockFactory, bool createSenders);
    internal string get_StorageUniqueFolder();
    [CompilerGeneratedAttribute]
internal TimeSpan get_SendingInterval();
    [CompilerGeneratedAttribute]
internal void set_SendingInterval(TimeSpan value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistenceTransmitter/<FlushAsync>d__14")]
public Task FlushAsync(CancellationToken token);
    public sealed virtual void Dispose();
    private void AcquireMutex(Action action);
    private void CreateSenders(int sendersCount);
    private void StopSenders();
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.PersistentStorage : StorageBase {
    private ConcurrentDictionary`2<string, string> filesToDelete;
    private object peekLockObj;
    private DirectoryInfo storageFolder;
    private int transmissionsDropped;
    private bool storageFolderInitialized;
    private object storageFolderLock;
    private IStorageBuilder storageBuilder;
    internal PersistenceVersion PersistenceVersion;
    internal string FolderName { get; }
    internal bool StorageFolderInitialized { get; internal set; }
    internal DirectoryInfo StorageFolder { get; }
    internal PersistentStorage(string uniqueStorageFolderName, PersistenceVersion version);
    internal virtual string get_FolderName();
    internal bool get_StorageFolderInitialized();
    internal void set_StorageFolderInitialized(bool value);
    internal virtual DirectoryInfo get_StorageFolder();
    internal virtual IEnumerable`1<StorageTransmission> PeekAll(CancellationToken token);
    internal virtual StorageTransmission Peek();
    internal virtual void Delete(StorageTransmission item);
    private void TryRemoveFilesToDelete();
    private bool TryAndLogDeleteFile(string fullFilePath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistentStorage/<EnqueueAsync>d__21")]
internal virtual Task EnqueueAsync(Transmission transmission);
    private StorageTransmission BuildTransmissionFromFile(FileInfo file);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistentStorage/<GetFilteredFiles>d__23")]
private IEnumerable`1<FileInfo> GetFilteredFiles();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistentStorage/<GetDeletableFilesForExtension>d__24")]
private IEnumerable`1<FileInfo> GetDeletableFilesForExtension(string fileExt);
    private string BuildFullFileNameWithoutExtension();
    private string BuildNewFullFileNameWithSameDate(string name);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistentStorage/<SaveTransmissionToFileAsync>d__27")]
private static Task SaveTransmissionToFileAsync(Transmission transmission, string fileFullName, PersistenceVersion version);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.PersistentStorage/<LoadTransmissionFromFileAsync>d__28")]
private static Task`1<StorageTransmission> LoadTransmissionFromFileAsync(FileInfo file, PersistenceVersion version);
    private static string GetApplicationIdentity();
    internal static string GetSHA256Hash(string input, string defaultValue);
    private DirectoryInfo GetStorageDirectory();
    private bool IsStorageLimitsReached();
    private IEnumerable`1<FileInfo> GetFiles(string filter);
    private void DeleteObsoleteFiles();
    private void TryDeleteBrokenFiles();
    private bool CanDelete(FileInfo fileInfo);
    internal static string GeneratePersistentStorageFolderSuffix(PersistenceVersion version, string iKey, string globalStorageUri);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.Sender : object {
    private static int TriggerCountStaleHashCheck;
    private static TimeSpan StaleHashPeriod;
    protected AutoResetEvent DelayHandler;
    private TimeSpan sendingIntervalOnNoData;
    private TimeSpan maxIntervalBetweenRetries;
    private AutoResetEvent stoppedHandler;
    private LinkedList`1<Tuple`2<DateTime, string>> listOfTransmissionHash;
    private Dictionary`2<string, LinkedListNode`1<Tuple`2<DateTime, string>>> setOfTransmissionHash;
    private object hashLock;
    private int checkStaleHashCount;
    private bool stopped;
    private TimeSpan drainingTimeout;
    private StorageBase storage;
    private int disposeCount;
    private PersistenceTransmitter transmitter;
    private TimeSpan SendingInterval { get; }
    internal Sender(StorageBase storage, PersistenceTransmitter transmitter, bool startSending);
    private static Sender();
    private TimeSpan get_SendingInterval();
    public sealed virtual void Dispose();
    internal Task StopAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.Sender/<FlushAllAsync>d__20")]
internal Task FlushAllAsync(CancellationToken token);
    protected void SendLoop();
    protected virtual bool Send(StorageTransmission transmission, TimeSpan& nextSendInterval);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.Sender/<SendAsync>d__23")]
private Task`1<Tuple`2<bool, TimeSpan>> SendAsync(StorageTransmission transmission, CancellationToken token, TimeSpan sendInterval);
    private void CleanupStaleTransmissionHash();
    private static void LogInterval(TimeSpan prevSendInterval, TimeSpan nextSendInterval);
    private static Nullable`1<int> GetStatusCode(WebException e);
    private static bool IsRetryable(Nullable`1<int> httpStatusCode, WebExceptionStatus webExceptionStatus);
    private TimeSpan CalculateNextInterval(Nullable`1<int> httpStatusCode, TimeSpan currentSendInterval, TimeSpan maxInterval);
    [CompilerGeneratedAttribute]
private void <StopAsync>b__19_0();
}
internal abstract class Microsoft.VisualStudio.ApplicationInsights.Channel.StorageBase : object {
    protected IDictionary`2<string, string> peekedTransmissions;
    [CompilerGeneratedAttribute]
private ulong <CapacityInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxFiles>k__BackingField;
    internal ulong CapacityInBytes { get; internal set; }
    internal UInt32 MaxFiles { get; internal set; }
    internal string FolderName { get; }
    internal DirectoryInfo StorageFolder { get; }
    [CompilerGeneratedAttribute]
internal ulong get_CapacityInBytes();
    [CompilerGeneratedAttribute]
internal void set_CapacityInBytes(ulong value);
    [CompilerGeneratedAttribute]
internal UInt32 get_MaxFiles();
    [CompilerGeneratedAttribute]
internal void set_MaxFiles(UInt32 value);
    internal abstract virtual string get_FolderName();
    internal abstract virtual DirectoryInfo get_StorageFolder();
    internal abstract virtual StorageTransmission Peek();
    internal abstract virtual IEnumerable`1<StorageTransmission> PeekAll(CancellationToken token);
    internal abstract virtual void Delete(StorageTransmission transmission);
    internal abstract virtual Task EnqueueAsync(Transmission transmission);
    protected void OnPeekedItemDisposed(string fileName);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.StorageTransmission : Transmission {
    internal static string BrokenFileExtension;
    internal Action`1<StorageTransmission> Disposing;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullFilePath>k__BackingField;
    public VisualStudioCodeTelemetryLevel TelemetryLevel { get; }
    internal string FileName { get; private set; }
    internal string FullFilePath { get; private set; }
    private string Microsoft.VisualStudio.Telemetry.Collector.IEmittedTelemetryEvent.ApiKey { get; }
    protected StorageTransmission(string fullPath, Uri address, Byte[] content, string contentType, string apiKey, string contentEncoding);
    protected StorageTransmission(string fullPath, TransmissionFile trnInternal);
    public sealed virtual VisualStudioCodeTelemetryLevel get_TelemetryLevel();
    [CompilerGeneratedAttribute]
internal string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
internal string get_FullFilePath();
    [CompilerGeneratedAttribute]
private void set_FullFilePath(string value);
    private sealed virtual override string Microsoft.VisualStudio.Telemetry.Collector.IEmittedTelemetryEvent.get_ApiKey();
    public sealed virtual void Delete();
    public sealed virtual void Dispose();
    public virtual string ToString();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.StorageTransmission/<CreateFromStreamAsync>d__19")]
internal static Task`1<StorageTransmission> CreateFromStreamAsync(Stream stream, string fileName, PersistenceVersion version);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.StorageTransmission/<SaveAsync>d__20")]
internal static Task SaveAsync(Transmission transmission, Stream stream, PersistenceVersion version);
    private void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.TelemetryBuffer : object {
    public Action OnFull;
    private static int DefaultCapacity;
    private object lockObj;
    private int capacity;
    private List`1<ITelemetry> items;
    public int Capacity { get; public set; }
    public int get_Capacity();
    public void set_Capacity(int value);
    public void Enqueue(ITelemetry item);
    public IEnumerable`1<ITelemetry> Dequeue();
}
public class Microsoft.VisualStudio.ApplicationInsights.Channel.Transmission : object {
    internal static string ContentTypeHeader;
    internal static string ContentEncodingHeader;
    internal static string GlobalStorageUriPropertyName;
    internal static string TelemetryLevelPropertyName;
    private static string Key;
    private static HashAlgorithm Encryptor;
    private static object hashLock;
    private static TimeSpan DefaultTimeout;
    private int isSending;
    private string contentHash;
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    private TransmissionFile transmissionFile;
    public Uri EndpointAddress { get; }
    public Byte[] Content { get; }
    public string ContentHash { get; }
    public string ContentType { get; }
    public string ContentEncoding { get; }
    public TimeSpan Timeout { get; private set; }
    internal TransmissionFile TransmissionFile { get; }
    public string EventTelemetryLevel { get; public set; }
    internal string ApiKey { get; }
    public Transmission(Uri address, Byte[] content, string contentType, string contentEncoding, TimeSpan timeout);
    public Transmission(Uri address, Byte[] content, string contentType, string contentEncoding, string apiKey, TimeSpan timeout);
    internal Transmission(TransmissionFile transmissionFile);
    private Transmission(TimeSpan timeout);
    private static Transmission();
    public Uri get_EndpointAddress();
    public Byte[] get_Content();
    public string get_ContentHash();
    public string get_ContentType();
    public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
private void set_Timeout(TimeSpan value);
    internal TransmissionFile get_TransmissionFile();
    public string get_EventTelemetryLevel();
    public void set_EventTelemetryLevel(string value);
    internal string get_ApiKey();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.Transmission/<SendAsync>d__37")]
public virtual Task SendAsync(CancellationToken token);
    private string GetNoResponseBodyFlag();
    public virtual string ToString();
    protected virtual WebRequest CreateRequest(Uri address);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.Transmission/<SendRequestAsync>d__41")]
private Task SendRequestAsync(WebRequest request);
    private static string HashContent(Byte[] content);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Channel.TransmissionFile : object {
    private static int ConvertChunkSize;
    private static int BufferSize;
    internal static string EndPointAPIKeyPropertyName;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventTelemetryLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <TransmissionEndpointUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentInBytes>k__BackingField;
    [JsonPropertyAttribute]
internal string ContentType { get; internal set; }
    [JsonPropertyAttribute]
internal string ContentEncoding { get; internal set; }
    [JsonPropertyAttribute]
internal string TransmissionEndpoint { get; internal set; }
    [JsonPropertyAttribute]
internal string Content { get; internal set; }
    [JsonPropertyAttribute]
internal string EndpointApiKey { get; internal set; }
    [JsonPropertyAttribute]
internal string EventTelemetryLevel { get; internal set; }
    [JsonIgnoreAttribute]
internal Uri TransmissionEndpointUri { get; internal set; }
    [JsonIgnoreAttribute]
internal Byte[] ContentInBytes { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_ContentType();
    [CompilerGeneratedAttribute]
internal void set_ContentType(string value);
    [CompilerGeneratedAttribute]
internal string get_ContentEncoding();
    [CompilerGeneratedAttribute]
internal void set_ContentEncoding(string value);
    internal string get_TransmissionEndpoint();
    internal void set_TransmissionEndpoint(string value);
    internal string get_Content();
    internal void set_Content(string value);
    [CompilerGeneratedAttribute]
internal string get_EndpointApiKey();
    [CompilerGeneratedAttribute]
internal void set_EndpointApiKey(string value);
    [CompilerGeneratedAttribute]
internal string get_EventTelemetryLevel();
    [CompilerGeneratedAttribute]
internal void set_EventTelemetryLevel(string value);
    [CompilerGeneratedAttribute]
internal Uri get_TransmissionEndpointUri();
    [CompilerGeneratedAttribute]
internal void set_TransmissionEndpointUri(Uri value);
    [CompilerGeneratedAttribute]
internal Byte[] get_ContentInBytes();
    [CompilerGeneratedAttribute]
internal void set_ContentInBytes(Byte[] value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.TransmissionFile/<SerializeToJsonAsync>d__34")]
internal static Task SerializeToJsonAsync(StreamWriter writer, TransmissionFile file);
    internal static TransmissionFile DeserializeFromJson(StreamReader reader);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.TransmissionFile/<SerializeToTrnAsync>d__36")]
internal static Task SerializeToTrnAsync(StreamWriter writer, TransmissionFile file);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.TransmissionFile/<DeserializeFromTrnAsync>d__37")]
internal static Task`1<TransmissionFile> DeserializeFromTrnAsync(StreamReader reader);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.TransmissionFile/<ReadHeaderAsync>d__38")]
private static Task`1<string> ReadHeaderAsync(TextReader reader, string headerName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.TransmissionFile/<ReadAddressAsync>d__39")]
private static Task`1<Uri> ReadAddressAsync(TextReader reader);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.TransmissionFile/<ReadContentAsync>d__40")]
private static Task`1<Byte[]> ReadContentAsync(TextReader reader);
    internal static String[] CreateChunkedBase64Strings(Byte[] content);
}
[ObsoleteAttribute("UniversalTelemetryChannel is no longer supported. Please use the CollectorSessionChannel or AsimovAppInsightsSessionChannel instead.")]
public class Microsoft.VisualStudio.ApplicationInsights.Channel.UniversalTelemetryChannel : object {
    private ConcurrentDictionary`2<string, EventSourceWriter> eventSourceWriters;
    private bool disposed;
    [CompilerGeneratedAttribute]
private bool <DeveloperMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointAddress>k__BackingField;
    public bool DeveloperMode { get; public set; }
    public string EndpointAddress { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DeveloperMode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DeveloperMode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EndpointAddress();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndpointAddress(string value);
    public static bool IsAvailable();
    public sealed virtual void Dispose();
    public sealed virtual void Send(ITelemetry item);
    public sealed virtual void Flush();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Channel.UniversalTelemetryChannel/<FlushAndTransmitAsync>d__15")]
public sealed virtual Task FlushAndTransmitAsync(CancellationToken token);
    internal EventSourceWriter GetEventSourceWriter(string instrumentationKey);
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private EventSourceWriter <GetEventSourceWriter>b__16_0(string key);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Constants : object {
    internal static string TelemetryServiceEndpoint;
    internal static string TelemetryNamePrefix;
    internal static string DevModeTelemetryNamePrefix;
    internal static string TelemetryGroup;
    internal static string DevModeTelemetryGroup;
    internal static string EventSourceGroupTraitKey;
    internal static int MaxExceptionCountToSave;
    internal static string WebRequestContentType;
    internal static string AiasimovChannelName;
    internal static string AiVortexChannelName;
    internal static string CollectorChannelName;
    internal static string CollectorClientVersion;
    internal static string CollectorEndpoint;
    internal static string NewCollectorEndpoint;
    internal static string VortexEndPoint;
    internal static string CollectorNoResponseBodyDiagnosticsEnvVar;
    internal static bool InitialDefaultUseCollector;
    internal static string CsDevKitSessionConfigurationKey;
    internal static string BucketParametersKeyName;
    internal static string CommonPropertiesKeyName;
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.EventTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal EventData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CommonSchemaVersion>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Name { get; public set; }
    public int CommonSchemaVersion { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public IDictionary`2<string, string> Properties { get; }
    public EventTelemetry(string name);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_CommonSchemaVersion();
    [CompilerGeneratedAttribute]
public void set_CommonSchemaVersion(int value);
    public IDictionary`2<string, double> get_Metrics();
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
public enum Microsoft.VisualStudio.ApplicationInsights.DataContracts.ExceptionHandledAt : Enum {
    public int value__;
    public static ExceptionHandledAt Unhandled;
    public static ExceptionHandledAt UserCode;
    public static ExceptionHandledAt Platform;
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.ExceptionTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal ExceptionData Data;
    private TelemetryContext context;
    private Exception exception;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public ExceptionHandledAt HandledAt { get; public set; }
    public Exception Exception { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public IDictionary`2<string, string> Properties { get; }
    public Nullable`1<SeverityLevel> SeverityLevel { get; public set; }
    internal IList`1<ExceptionDetails> Exceptions { get; }
    public ExceptionTelemetry(Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public ExceptionHandledAt get_HandledAt();
    public void set_HandledAt(ExceptionHandledAt value);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public IDictionary`2<string, double> get_Metrics();
    public sealed virtual IDictionary`2<string, string> get_Properties();
    public Nullable`1<SeverityLevel> get_SeverityLevel();
    public void set_SeverityLevel(Nullable`1<SeverityLevel> value);
    internal IList`1<ExceptionDetails> get_Exceptions();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
    private static void ConvertExceptionTree(Exception exception, ExceptionDetails parentExceptionDetails, List`1<ExceptionDetails> exceptions);
    private void UpdateExceptions(Exception exception);
    private ExceptionHandledAt ValidateExceptionHandledAt(string value);
}
public interface Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable {
    public abstract virtual void Serialize(IJsonWriter writer);
}
public interface Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonWriter {
    public abstract virtual void WriteStartArray();
    public abstract virtual void WriteStartObject();
    public abstract virtual void WriteEndArray();
    public abstract virtual void WriteEndObject();
    public abstract virtual void WriteComma();
    public abstract virtual void WriteProperty(string name, string value);
    public abstract virtual void WriteProperty(string name, Nullable`1<bool> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<int> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<double> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<TimeSpan> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<DateTimeOffset> value);
    public abstract virtual void WriteProperty(string name, IDictionary`2<string, double> values);
    public abstract virtual void WriteProperty(string name, IDictionary`2<string, string> values);
    public abstract virtual void WriteProperty(string name, IJsonSerializable value);
    public abstract virtual void WritePropertyName(string name);
    public abstract virtual void WriteRawValue(object value);
}
internal class Microsoft.VisualStudio.ApplicationInsights.DataContracts.InnerExceptionCountExceededException : Exception {
    public InnerExceptionCountExceededException(string message);
    public InnerExceptionCountExceededException(string message, Exception innerException);
    protected InnerExceptionCountExceededException(SerializationInfo info, StreamingContext context);
}
public interface Microsoft.VisualStudio.ApplicationInsights.DataContracts.ISupportProperties {
    public IDictionary`2<string, string> Properties { get; }
    public abstract virtual IDictionary`2<string, string> get_Properties();
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.MetricTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal MetricData Data;
    internal DataPoint Metric;
    private TelemetryContext context;
    private bool isAggregation;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Name { get; public set; }
    public double Value { get; public set; }
    public Nullable`1<int> Count { get; public set; }
    public Nullable`1<double> Min { get; public set; }
    public Nullable`1<double> Max { get; public set; }
    public Nullable`1<double> StandardDeviation { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public MetricTelemetry(string metricName, double metricValue);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Name();
    public void set_Name(string value);
    public double get_Value();
    public void set_Value(double value);
    public Nullable`1<int> get_Count();
    public void set_Count(Nullable`1<int> value);
    public Nullable`1<double> get_Min();
    public void set_Min(Nullable`1<double> value);
    public Nullable`1<double> get_Max();
    public void set_Max(Nullable`1<double> value);
    public Nullable`1<double> get_StandardDeviation();
    public void set_StandardDeviation(Nullable`1<double> value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
    private void UpdateKind();
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.PageViewTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal PageViewData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Name { get; public set; }
    public Uri Url { get; public set; }
    public TimeSpan Duration { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public IDictionary`2<string, string> Properties { get; }
    public PageViewTelemetry(string pageName);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Name();
    public void set_Name(string value);
    public Uri get_Url();
    public void set_Url(Uri value);
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    public IDictionary`2<string, double> get_Metrics();
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
[DebuggerDisplayAttribute("CategoryName={CategoryName}; CounterName={CounterName}; InstanceName={InstanceName}; Value={Value}; Timestamp={Timestamp}")]
internal class Microsoft.VisualStudio.ApplicationInsights.DataContracts.PerformanceCounterTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal PerformanceCounterData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public double Value { get; public set; }
    public string CategoryName { get; public set; }
    public string CounterName { get; public set; }
    public string InstanceName { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public PerformanceCounterTelemetry(string categoryName, string counterName, string instanceName, double value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public double get_Value();
    public void set_Value(double value);
    public string get_CategoryName();
    public void set_CategoryName(string value);
    public string get_CounterName();
    public void set_CounterName(string value);
    public string get_InstanceName();
    public void set_InstanceName(string value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
[DebuggerDisplayAttribute("Value={Value}; Name={Name}; Count={Count}; Success={Success}; Async={Async}; Timestamp={Timestamp}")]
internal class Microsoft.VisualStudio.ApplicationInsights.DataContracts.RemoteDependencyTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal RemoteDependencyData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Name { get; public set; }
    public string CommandName { get; public set; }
    public DependencyKind DependencyKind { get; public set; }
    public double Value { get; public set; }
    public Nullable`1<int> Count { get; public set; }
    public Nullable`1<bool> Success { get; public set; }
    public Nullable`1<bool> Async { get; public set; }
    public DependencySourceType DependencySource { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Name();
    public void set_Name(string value);
    public string get_CommandName();
    public void set_CommandName(string value);
    public DependencyKind get_DependencyKind();
    public void set_DependencyKind(DependencyKind value);
    public double get_Value();
    public void set_Value(double value);
    public Nullable`1<int> get_Count();
    public void set_Count(Nullable`1<int> value);
    public Nullable`1<bool> get_Success();
    public void set_Success(Nullable`1<bool> value);
    public Nullable`1<bool> get_Async();
    public void set_Async(Nullable`1<bool> value);
    public DependencySourceType get_DependencySource();
    public void set_DependencySource(DependencySourceType value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.RequestTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal RequestData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Id { get; public set; }
    public string Name { get; public set; }
    public string ResponseCode { get; public set; }
    public bool Success { get; public set; }
    public TimeSpan Duration { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public Uri Url { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public string HttpMethod { get; public set; }
    public RequestTelemetry(string name, DateTimeOffset timestamp, TimeSpan duration, string responseCode, bool success);
    public sealed virtual DateTimeOffset get_Timestamp();
    public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Id();
    public void set_Id(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_ResponseCode();
    public void set_ResponseCode(string value);
    public bool get_Success();
    public void set_Success(bool value);
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    public Uri get_Url();
    public void set_Url(Uri value);
    public IDictionary`2<string, double> get_Metrics();
    public string get_HttpMethod();
    public void set_HttpMethod(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
    private DateTimeOffset ValidateDateTimeOffset(string value);
}
public enum Microsoft.VisualStudio.ApplicationInsights.DataContracts.SessionState : Enum {
    public int value__;
    public static SessionState Start;
    public static SessionState End;
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.SessionStateTelemetry : object {
    internal static string TelemetryName;
    internal SessionStateData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionState <State>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public TelemetryContext Context { get; }
    public string Sequence { get; public set; }
    public SessionState State { get; public set; }
    public SessionStateTelemetry(SessionState state);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    public sealed virtual TelemetryContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    [CompilerGeneratedAttribute]
public SessionState get_State();
    [CompilerGeneratedAttribute]
public void set_State(SessionState value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
public enum Microsoft.VisualStudio.ApplicationInsights.DataContracts.SeverityLevel : Enum {
    public int value__;
    public static SeverityLevel Verbose;
    public static SeverityLevel Information;
    public static SeverityLevel Warning;
    public static SeverityLevel Error;
    public static SeverityLevel Critical;
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.TelemetryContext : object {
    private IDictionary`2<string, string> properties;
    private IDictionary`2<string, string> tags;
    private string instrumentationKey;
    private ComponentContext component;
    private DeviceContext device;
    private SessionContext session;
    private UserContext user;
    private OperationContext operation;
    private LocationContext location;
    private InternalContext internalContext;
    public string InstrumentationKey { get; public set; }
    public ComponentContext Component { get; }
    public DeviceContext Device { get; }
    public SessionContext Session { get; }
    public UserContext User { get; }
    public OperationContext Operation { get; }
    public LocationContext Location { get; }
    public IDictionary`2<string, string> Properties { get; }
    internal InternalContext Internal { get; }
    internal IDictionary`2<string, string> Tags { get; }
    internal TelemetryContext(IDictionary`2<string, string> properties, IDictionary`2<string, string> tags);
    public string get_InstrumentationKey();
    public void set_InstrumentationKey(string value);
    public ComponentContext get_Component();
    public DeviceContext get_Device();
    public SessionContext get_Session();
    public UserContext get_User();
    public OperationContext get_Operation();
    public LocationContext get_Location();
    public IDictionary`2<string, string> get_Properties();
    internal InternalContext get_Internal();
    internal IDictionary`2<string, string> get_Tags();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
    internal void Initialize(TelemetryContext source, string instrumentationKey);
    [CompilerGeneratedAttribute]
private ComponentContext <get_Component>b__16_0();
    [CompilerGeneratedAttribute]
private DeviceContext <get_Device>b__18_0();
    [CompilerGeneratedAttribute]
private SessionContext <get_Session>b__20_0();
    [CompilerGeneratedAttribute]
private UserContext <get_User>b__22_0();
    [CompilerGeneratedAttribute]
private OperationContext <get_Operation>b__24_0();
    [CompilerGeneratedAttribute]
private LocationContext <get_Location>b__26_0();
    [CompilerGeneratedAttribute]
private InternalContext <get_Internal>b__30_0();
}
public class Microsoft.VisualStudio.ApplicationInsights.DataContracts.TraceTelemetry : object {
    internal static string TelemetryName;
    internal string BaseType;
    internal MessageData Data;
    private TelemetryContext context;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public string Message { get; public set; }
    public Nullable`1<SeverityLevel> SeverityLevel { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public TraceTelemetry(string message);
    public TraceTelemetry(string message, SeverityLevel severityLevel);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public string get_Message();
    public void set_Message(string value);
    public Nullable`1<SeverityLevel> get_SeverityLevel();
    public void set_SeverityLevel(Nullable`1<SeverityLevel> value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.ApplicationLifecycle : object {
    private static object SyncRoot;
    private static ApplicationLifecycle service;
    private IApplicationLifecycle provider;
    [CompilerGeneratedAttribute]
private Action`2<object, object> Started;
    [CompilerGeneratedAttribute]
private EventHandler`1<ApplicationStoppingEventArgs> Stopping;
    public static IApplicationLifecycle Service { get; internal set; }
    unknown IApplicationLifecycle Provider {private set; }
    private static ApplicationLifecycle();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
    public static IApplicationLifecycle get_Service();
    internal static void set_Service(IApplicationLifecycle value);
    private void set_Provider(IApplicationLifecycle value);
    public static void SetProvider(IApplicationLifecycle provider);
    private void OnStarted(object sender, object eventArgs);
    private void OnStopping(object sender, ApplicationStoppingEventArgs eventArgs);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.ApplicationStoppingEventArgs : EventArgs {
    internal static ApplicationStoppingEventArgs Empty;
    private Func`2<Func`1<Task>, Task> asyncMethodRunner;
    public ApplicationStoppingEventArgs(Func`2<Func`1<Task>, Task> asyncMethodRunner);
    private static ApplicationStoppingEventArgs();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.Extensibility.ApplicationStoppingEventArgs/<Run>d__3")]
public void Run(Func`1<Task> asyncMethod);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.BuildInfoConfigComponentVersionContextInitializer : object {
    private string version;
    public sealed virtual void Initialize(TelemetryContext context);
    protected virtual XElement LoadBuildInfoConfig();
    private string GetVersion();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.ComponentContextInitializer : object {
    public sealed virtual void Initialize(TelemetryContext context);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.ComponentContextReader : object {
    internal static string UnknownComponentVersion;
    private static IComponentContextReader instance;
    public static IComponentContextReader Instance { get; internal set; }
    public static IComponentContextReader get_Instance();
    internal static void set_Instance(IComponentContextReader value);
    public sealed virtual void Initialize();
    public sealed virtual string GetVersion();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.DeviceContextInitializer : object {
    public sealed virtual void Initialize(TelemetryContext context);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.DeviceContextReader : object {
    private object syncRoot;
    private string deviceId;
    private string operatingSystem;
    private string deviceManufacturer;
    private string deviceName;
    private Nullable`1<int> networkType;
    private FallbackDeviceContext cachedContext;
    internal static string ContextPersistentStorageFileName;
    private static IDeviceContextReader instance;
    public FallbackDeviceContext FallbackContext { get; }
    public static IDeviceContextReader Instance { get; internal set; }
    public virtual FallbackDeviceContext get_FallbackContext();
    public virtual void Initialize();
    public virtual string GetDeviceType();
    public virtual string GetDeviceUniqueId();
    public virtual Task`1<string> GetOperatingSystemAsync();
    public virtual string GetOemName();
    public virtual string GetDeviceModel();
    public sealed virtual int GetNetworkType();
    public sealed virtual Task`1<string> GetScreenResolutionAsync();
    private FallbackDeviceContext ReadSerializedContext();
    private string RunWmiQuery(string table, string property, string defaultValue);
    public static IDeviceContextReader get_Instance();
    internal static void set_Instance(IDeviceContextReader value);
    public virtual string GetHostSystemLocale();
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.FallbackDeviceContext : object {
    [CompilerGeneratedAttribute]
private string <DeviceUniqueId>k__BackingField;
    public string DeviceUniqueId { get; private set; }
    [CompilerGeneratedAttribute]
public string get_DeviceUniqueId();
    [CompilerGeneratedAttribute]
private void set_DeviceUniqueId(string value);
    public sealed virtual void Initialize();
    public sealed virtual void Serialize(XElement rootElement);
    public sealed virtual bool Deserialize(XElement rootElement);
}
public interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.IApplicationLifecycle {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.IComponentContextReader {
    public abstract virtual void Initialize();
    public abstract virtual string GetVersion();
}
public interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.IContextInitializer {
    public abstract virtual void Initialize(TelemetryContext context);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.IDeviceContextReader {
    public FallbackDeviceContext FallbackContext { get; }
    public abstract virtual FallbackDeviceContext get_FallbackContext();
    public abstract virtual void Initialize();
    public abstract virtual string GetDeviceType();
    public abstract virtual string GetDeviceUniqueId();
    public abstract virtual Task`1<string> GetOperatingSystemAsync();
    public abstract virtual string GetOemName();
    public abstract virtual string GetDeviceModel();
    public abstract virtual int GetNetworkType();
    public abstract virtual Task`1<string> GetScreenResolutionAsync();
    public abstract virtual string GetHostSystemLocale();
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.IFallbackContext {
    public abstract virtual void Initialize();
    public abstract virtual void Serialize(XElement rootElement);
    public abstract virtual bool Deserialize(XElement rootElement);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Clock : object {
    private static DateTimeOffset InitialTimeStamp;
    private static Stopwatch OffsetStopwatch;
    private static IClock instance;
    public static IClock Instance { get; protected set; }
    public DateTimeOffset Time { get; }
    private static Clock();
    public static IClock get_Instance();
    protected static void set_Instance(IClock value);
    public sealed virtual DateTimeOffset get_Time();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.ComponentContext : object {
    private IDictionary`2<string, string> tags;
    public string Version { get; public set; }
    internal ComponentContext(IDictionary`2<string, string> tags);
    public string get_Version();
    public void set_Version(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.CurrentThreadTaskScheduler : TaskScheduler {
    public static TaskScheduler Instance;
    public int MaximumConcurrencyLevel { get; }
    private static CurrentThreadTaskScheduler();
    public virtual int get_MaximumConcurrencyLevel();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.DeviceContext : object {
    private IDictionary`2<string, string> tags;
    public string Type { get; public set; }
    public string Id { get; public set; }
    public string OperatingSystem { get; public set; }
    public string OemName { get; public set; }
    public string Model { get; public set; }
    public string NetworkType { get; public set; }
    public string ScreenResolution { get; public set; }
    public string Language { get; public set; }
    public string RoleName { get; public set; }
    public string RoleInstance { get; public set; }
    internal DeviceContext(IDictionary`2<string, string> tags);
    public string get_Type();
    public void set_Type(string value);
    public string get_Id();
    public void set_Id(string value);
    public string get_OperatingSystem();
    public void set_OperatingSystem(string value);
    public string get_OemName();
    public void set_OemName(string value);
    public string get_Model();
    public void set_Model(string value);
    public string get_NetworkType();
    public void set_NetworkType(string value);
    public string get_ScreenResolution();
    public void set_ScreenResolution(string value);
    public string get_Language();
    public void set_Language(string value);
    public string get_RoleName();
    public void set_RoleName(string value);
    public string get_RoleInstance();
    public void set_RoleInstance(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.EventTelemetryExtensions : object {
    [ExtensionAttribute]
public static bool TryGetBoolean(IDictionary`2<string, string> properties, string propertyName, Boolean& result);
    [ExtensionAttribute]
public static bool IsMicrosoftInternal(EventTelemetry telemetry);
}
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.ExceptionConverter : object {
    public static int MaxParsedStackLength;
    internal static ExceptionDetails ConvertToExceptionDetails(Exception exception, ExceptionDetails parentExceptionDetails);
    private static Tuple`2<List`1<TOutput>, bool> SanitizeStackFrame(IList`1<TInput> inputList, Func`3<TInput, int, TOutput> converter, Func`2<TOutput, int> lengthGetter);
    private static StackFrame GetStackFrame(StackFrame stackFrame, int frameId);
    private static int GetStackFrameLength(StackFrame stackFrame);
}
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.ExceptionHandler : object {
    public static void Start(Func`1<Task> asyncMethod);
}
[EventDataAttribute]
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.AjaxCallData : PageViewData {
    [CompilerGeneratedAttribute]
private string <ajaxUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private double <requestSize>k__BackingField;
    [CompilerGeneratedAttribute]
private double <responseSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <timeToFirstByte>k__BackingField;
    [CompilerGeneratedAttribute]
private string <timeToLastByte>k__BackingField;
    [CompilerGeneratedAttribute]
private string <callbackDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <responseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <success>k__BackingField;
    public string ajaxUrl { get; public set; }
    public double requestSize { get; public set; }
    public double responseSize { get; public set; }
    public string timeToFirstByte { get; public set; }
    public string timeToLastByte { get; public set; }
    public string callbackDuration { get; public set; }
    public string responseCode { get; public set; }
    public bool success { get; public set; }
    protected AjaxCallData(string fullName, string name);
    [CompilerGeneratedAttribute]
public string get_ajaxUrl();
    [CompilerGeneratedAttribute]
public void set_ajaxUrl(string value);
    [CompilerGeneratedAttribute]
public double get_requestSize();
    [CompilerGeneratedAttribute]
public void set_requestSize(double value);
    [CompilerGeneratedAttribute]
public double get_responseSize();
    [CompilerGeneratedAttribute]
public void set_responseSize(double value);
    [CompilerGeneratedAttribute]
public string get_timeToFirstByte();
    [CompilerGeneratedAttribute]
public void set_timeToFirstByte(string value);
    [CompilerGeneratedAttribute]
public string get_timeToLastByte();
    [CompilerGeneratedAttribute]
public void set_timeToLastByte(string value);
    [CompilerGeneratedAttribute]
public string get_callbackDuration();
    [CompilerGeneratedAttribute]
public void set_callbackDuration(string value);
    [CompilerGeneratedAttribute]
public string get_responseCode();
    [CompilerGeneratedAttribute]
public void set_responseCode(string value);
    [CompilerGeneratedAttribute]
public bool get_success();
    [CompilerGeneratedAttribute]
public void set_success(bool value);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.ComponentContextData : object {
    private IDictionary`2<string, string> tags;
    public string Version { get; public set; }
    public string Build { get; public set; }
    internal ComponentContextData(IDictionary`2<string, string> tags);
    public string get_Version();
    public void set_Version(string value);
    public string get_Build();
    public void set_Build(string value);
    internal void SetDefaults(ComponentContextData source);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.ContextTagKeys : object {
    private static ContextTagKeys keys;
    [CompilerGeneratedAttribute]
private string <ApplicationVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceIp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceLocale>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceModel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceNetwork>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceOEMName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceOS>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceOSVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceRoleInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceRoleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceScreenResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceMachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationIp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationRootId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationSyntheticSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationIsSynthetic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionIsFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionIsNew>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAccountAcquisitionDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserStoreRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SampleRate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InternalSdkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InternalAgentVersion>k__BackingField;
    internal static ContextTagKeys Keys { get; }
    public string ApplicationVersion { get; public set; }
    public string ApplicationBuild { get; public set; }
    public string DeviceId { get; public set; }
    public string DeviceIp { get; public set; }
    public string DeviceLanguage { get; public set; }
    public string DeviceLocale { get; public set; }
    public string DeviceModel { get; public set; }
    public string DeviceNetwork { get; public set; }
    public string DeviceOEMName { get; public set; }
    public string DeviceOS { get; public set; }
    public string DeviceOSVersion { get; public set; }
    public string DeviceRoleInstance { get; public set; }
    public string DeviceRoleName { get; public set; }
    public string DeviceScreenResolution { get; public set; }
    public string DeviceType { get; public set; }
    public string DeviceMachineName { get; public set; }
    public string LocationIp { get; public set; }
    public string OperationId { get; public set; }
    public string OperationName { get; public set; }
    public string OperationParentId { get; public set; }
    public string OperationRootId { get; public set; }
    public string OperationSyntheticSource { get; public set; }
    public string OperationIsSynthetic { get; public set; }
    public string SessionId { get; public set; }
    public string SessionIsFirst { get; public set; }
    public string SessionIsNew { get; public set; }
    public string UserAccountAcquisitionDate { get; public set; }
    public string UserAccountId { get; public set; }
    public string UserAgent { get; public set; }
    public string UserId { get; public set; }
    public string UserStoreRegion { get; public set; }
    public string SampleRate { get; public set; }
    public string InternalSdkVersion { get; public set; }
    public string InternalAgentVersion { get; public set; }
    protected ContextTagKeys(string fullName, string name);
    internal static ContextTagKeys get_Keys();
    [CompilerGeneratedAttribute]
public string get_ApplicationVersion();
    [CompilerGeneratedAttribute]
public void set_ApplicationVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationBuild();
    [CompilerGeneratedAttribute]
public void set_ApplicationBuild(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceId();
    [CompilerGeneratedAttribute]
public void set_DeviceId(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceIp();
    [CompilerGeneratedAttribute]
public void set_DeviceIp(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceLanguage();
    [CompilerGeneratedAttribute]
public void set_DeviceLanguage(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceLocale();
    [CompilerGeneratedAttribute]
public void set_DeviceLocale(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceModel();
    [CompilerGeneratedAttribute]
public void set_DeviceModel(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceNetwork();
    [CompilerGeneratedAttribute]
public void set_DeviceNetwork(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceOEMName();
    [CompilerGeneratedAttribute]
public void set_DeviceOEMName(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceOS();
    [CompilerGeneratedAttribute]
public void set_DeviceOS(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceOSVersion();
    [CompilerGeneratedAttribute]
public void set_DeviceOSVersion(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceRoleInstance();
    [CompilerGeneratedAttribute]
public void set_DeviceRoleInstance(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceRoleName();
    [CompilerGeneratedAttribute]
public void set_DeviceRoleName(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceScreenResolution();
    [CompilerGeneratedAttribute]
public void set_DeviceScreenResolution(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceType();
    [CompilerGeneratedAttribute]
public void set_DeviceType(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceMachineName();
    [CompilerGeneratedAttribute]
public void set_DeviceMachineName(string value);
    [CompilerGeneratedAttribute]
public string get_LocationIp();
    [CompilerGeneratedAttribute]
public void set_LocationIp(string value);
    [CompilerGeneratedAttribute]
public string get_OperationId();
    [CompilerGeneratedAttribute]
public void set_OperationId(string value);
    [CompilerGeneratedAttribute]
public string get_OperationName();
    [CompilerGeneratedAttribute]
public void set_OperationName(string value);
    [CompilerGeneratedAttribute]
public string get_OperationParentId();
    [CompilerGeneratedAttribute]
public void set_OperationParentId(string value);
    [CompilerGeneratedAttribute]
public string get_OperationRootId();
    [CompilerGeneratedAttribute]
public void set_OperationRootId(string value);
    [CompilerGeneratedAttribute]
public string get_OperationSyntheticSource();
    [CompilerGeneratedAttribute]
public void set_OperationSyntheticSource(string value);
    [CompilerGeneratedAttribute]
public string get_OperationIsSynthetic();
    [CompilerGeneratedAttribute]
public void set_OperationIsSynthetic(string value);
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(string value);
    [CompilerGeneratedAttribute]
public string get_SessionIsFirst();
    [CompilerGeneratedAttribute]
public void set_SessionIsFirst(string value);
    [CompilerGeneratedAttribute]
public string get_SessionIsNew();
    [CompilerGeneratedAttribute]
public void set_SessionIsNew(string value);
    [CompilerGeneratedAttribute]
public string get_UserAccountAcquisitionDate();
    [CompilerGeneratedAttribute]
public void set_UserAccountAcquisitionDate(string value);
    [CompilerGeneratedAttribute]
public string get_UserAccountId();
    [CompilerGeneratedAttribute]
public void set_UserAccountId(string value);
    [CompilerGeneratedAttribute]
public string get_UserAgent();
    [CompilerGeneratedAttribute]
public void set_UserAgent(string value);
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(string value);
    [CompilerGeneratedAttribute]
public string get_UserStoreRegion();
    [CompilerGeneratedAttribute]
public void set_UserStoreRegion(string value);
    [CompilerGeneratedAttribute]
public string get_SampleRate();
    [CompilerGeneratedAttribute]
public void set_SampleRate(string value);
    [CompilerGeneratedAttribute]
public string get_InternalSdkVersion();
    [CompilerGeneratedAttribute]
public void set_InternalSdkVersion(string value);
    [CompilerGeneratedAttribute]
public string get_InternalAgentVersion();
    [CompilerGeneratedAttribute]
public void set_InternalAgentVersion(string value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
[EventDataAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.DataPoint : object {
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private DataPointType <kind>k__BackingField;
    [CompilerGeneratedAttribute]
private double <value>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <count>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <max>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <stdDev>k__BackingField;
    public string name { get; public set; }
    public DataPointType kind { get; public set; }
    public double value { get; public set; }
    public Nullable`1<int> count { get; public set; }
    public Nullable`1<double> min { get; public set; }
    public Nullable`1<double> max { get; public set; }
    public Nullable`1<double> stdDev { get; public set; }
    protected DataPoint(string fullName, string name);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public DataPointType get_kind();
    [CompilerGeneratedAttribute]
public void set_kind(DataPointType value);
    [CompilerGeneratedAttribute]
public double get_value();
    [CompilerGeneratedAttribute]
public void set_value(double value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_count();
    [CompilerGeneratedAttribute]
public void set_count(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_min();
    [CompilerGeneratedAttribute]
public void set_min(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_max();
    [CompilerGeneratedAttribute]
public void set_max(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_stdDev();
    [CompilerGeneratedAttribute]
public void set_stdDev(Nullable`1<double> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal enum Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.DataPointType : Enum {
    public int value__;
    public static DataPointType Measurement;
    public static DataPointType Aggregation;
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal enum Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.DependencyKind : Enum {
    public int value__;
    public static DependencyKind SQL;
    public static DependencyKind Http;
    public static DependencyKind Other;
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal enum Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.DependencySourceType : Enum {
    public int value__;
    public static DependencySourceType Undefined;
    public static DependencySourceType Aic;
    public static DependencySourceType Apmc;
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.DeviceContextData : object {
    private IDictionary`2<string, string> tags;
    public string Type { get; public set; }
    public string Id { get; public set; }
    public string OperatingSystem { get; public set; }
    public string OemName { get; public set; }
    public string Model { get; public set; }
    public Nullable`1<int> NetworkType { get; public set; }
    public string ScreenResolution { get; public set; }
    public string Language { get; public set; }
    public string RoleName { get; public set; }
    public string RoleInstance { get; public set; }
    public string Ip { get; public set; }
    public string MachineName { get; public set; }
    internal DeviceContextData(IDictionary`2<string, string> tags);
    public string get_Type();
    public void set_Type(string value);
    public string get_Id();
    public void set_Id(string value);
    public string get_OperatingSystem();
    public void set_OperatingSystem(string value);
    public string get_OemName();
    public void set_OemName(string value);
    public string get_Model();
    public void set_Model(string value);
    public Nullable`1<int> get_NetworkType();
    public void set_NetworkType(Nullable`1<int> value);
    public string get_ScreenResolution();
    public void set_ScreenResolution(string value);
    public string get_Language();
    public void set_Language(string value);
    public string get_RoleName();
    public void set_RoleName(string value);
    public string get_RoleInstance();
    public void set_RoleInstance(string value);
    public string get_Ip();
    public void set_Ip(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    internal void SetDefaults(DeviceContextData source);
}
[GeneratedCodeAttribute("gbc", "3.02")]
[EventDataAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.EventData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, double> <measurements>k__BackingField;
    public int ver { get; public set; }
    public string name { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected EventData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, double> get_measurements();
    [CompilerGeneratedAttribute]
public void set_measurements(IDictionary`2<string, double> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
[EventDataAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.ExceptionData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <handledAt>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ExceptionDetails> <exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SeverityLevel> <severityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <problemId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <crashThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, double> <measurements>k__BackingField;
    public int ver { get; public set; }
    public string handledAt { get; public set; }
    public IList`1<ExceptionDetails> exceptions { get; public set; }
    public Nullable`1<SeverityLevel> severityLevel { get; public set; }
    public string problemId { get; public set; }
    public int crashThreadId { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected ExceptionData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_handledAt();
    [CompilerGeneratedAttribute]
public void set_handledAt(string value);
    [CompilerGeneratedAttribute]
public IList`1<ExceptionDetails> get_exceptions();
    [CompilerGeneratedAttribute]
public void set_exceptions(IList`1<ExceptionDetails> value);
    [CompilerGeneratedAttribute]
public Nullable`1<SeverityLevel> get_severityLevel();
    [CompilerGeneratedAttribute]
public void set_severityLevel(Nullable`1<SeverityLevel> value);
    [CompilerGeneratedAttribute]
public string get_problemId();
    [CompilerGeneratedAttribute]
public void set_problemId(string value);
    [CompilerGeneratedAttribute]
public int get_crashThreadId();
    [CompilerGeneratedAttribute]
public void set_crashThreadId(int value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, double> get_measurements();
    [CompilerGeneratedAttribute]
public void set_measurements(IDictionary`2<string, double> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
[EventDataAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.ExceptionDetails : object {
    [CompilerGeneratedAttribute]
private int <id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <outerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <typeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <hasFullStack>k__BackingField;
    [CompilerGeneratedAttribute]
private string <stack>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<StackFrame> <parsedStack>k__BackingField;
    public int id { get; public set; }
    public int outerId { get; public set; }
    public string typeName { get; public set; }
    public string message { get; public set; }
    public bool hasFullStack { get; public set; }
    public string stack { get; public set; }
    public IList`1<StackFrame> parsedStack { get; public set; }
    protected ExceptionDetails(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_id();
    [CompilerGeneratedAttribute]
public void set_id(int value);
    [CompilerGeneratedAttribute]
public int get_outerId();
    [CompilerGeneratedAttribute]
public void set_outerId(int value);
    [CompilerGeneratedAttribute]
public string get_typeName();
    [CompilerGeneratedAttribute]
public void set_typeName(string value);
    [CompilerGeneratedAttribute]
public string get_message();
    [CompilerGeneratedAttribute]
public void set_message(string value);
    [CompilerGeneratedAttribute]
public bool get_hasFullStack();
    [CompilerGeneratedAttribute]
public void set_hasFullStack(bool value);
    [CompilerGeneratedAttribute]
public string get_stack();
    [CompilerGeneratedAttribute]
public void set_stack(string value);
    [CompilerGeneratedAttribute]
public IList`1<StackFrame> get_parsedStack();
    [CompilerGeneratedAttribute]
public void set_parsedStack(IList`1<StackFrame> value);
    internal static ExceptionDetails CreateWithoutStackInfo(Exception exception, ExceptionDetails parentExceptionDetails);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.InternalContextData : object {
    private IDictionary`2<string, string> tags;
    public string SdkVersion { get; public set; }
    public string AgentVersion { get; public set; }
    internal InternalContextData(IDictionary`2<string, string> tags);
    public string get_SdkVersion();
    public void set_SdkVersion(string value);
    public string get_AgentVersion();
    public void set_AgentVersion(string value);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.LocationContextData : object {
    private IDictionary`2<string, string> tags;
    public string Ip { get; public set; }
    internal LocationContextData(IDictionary`2<string, string> tags);
    public string get_Ip();
    public void set_Ip(string value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
[EventDataAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.MessageData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <message>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SeverityLevel> <severityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    public int ver { get; public set; }
    public string message { get; public set; }
    public Nullable`1<SeverityLevel> severityLevel { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    protected MessageData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_message();
    [CompilerGeneratedAttribute]
public void set_message(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<SeverityLevel> get_severityLevel();
    [CompilerGeneratedAttribute]
public void set_severityLevel(Nullable`1<SeverityLevel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
[EventDataAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.MetricData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DataPoint> <metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    public int ver { get; public set; }
    public IList`1<DataPoint> metrics { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    protected MetricData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public IList`1<DataPoint> get_metrics();
    [CompilerGeneratedAttribute]
public void set_metrics(IList`1<DataPoint> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.OperationContextData : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public string Name { get; public set; }
    public string ParentId { get; public set; }
    public string RootId { get; public set; }
    public string SyntheticSource { get; public set; }
    public Nullable`1<bool> IsSynthetic { get; public set; }
    internal OperationContextData(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_ParentId();
    public void set_ParentId(string value);
    public string get_RootId();
    public void set_RootId(string value);
    public string get_SyntheticSource();
    public void set_SyntheticSource(string value);
    public Nullable`1<bool> get_IsSynthetic();
    public void set_IsSynthetic(Nullable`1<bool> value);
    internal void SetDefaults(OperationContextData source);
}
[GeneratedCodeAttribute("gbc", "3.02")]
[EventDataAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.PageViewData : EventData {
    [CompilerGeneratedAttribute]
private string <url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <duration>k__BackingField;
    public string url { get; public set; }
    public string duration { get; public set; }
    protected PageViewData(string fullName, string name);
    [CompilerGeneratedAttribute]
public string get_url();
    [CompilerGeneratedAttribute]
public void set_url(string value);
    [CompilerGeneratedAttribute]
public string get_duration();
    [CompilerGeneratedAttribute]
public void set_duration(string value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
[EventDataAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.PageViewPerfData : PageViewData {
    [CompilerGeneratedAttribute]
private string <perfTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <networkConnect>k__BackingField;
    [CompilerGeneratedAttribute]
private string <sentRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <receivedResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private string <domProcessing>k__BackingField;
    public string perfTotal { get; public set; }
    public string networkConnect { get; public set; }
    public string sentRequest { get; public set; }
    public string receivedResponse { get; public set; }
    public string domProcessing { get; public set; }
    protected PageViewPerfData(string fullName, string name);
    [CompilerGeneratedAttribute]
public string get_perfTotal();
    [CompilerGeneratedAttribute]
public void set_perfTotal(string value);
    [CompilerGeneratedAttribute]
public string get_networkConnect();
    [CompilerGeneratedAttribute]
public void set_networkConnect(string value);
    [CompilerGeneratedAttribute]
public string get_sentRequest();
    [CompilerGeneratedAttribute]
public void set_sentRequest(string value);
    [CompilerGeneratedAttribute]
public string get_receivedResponse();
    [CompilerGeneratedAttribute]
public void set_receivedResponse(string value);
    [CompilerGeneratedAttribute]
public string get_domProcessing();
    [CompilerGeneratedAttribute]
public void set_domProcessing(string value);
}
[EventDataAttribute]
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.PerformanceCounterData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <categoryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <counterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <instanceName>k__BackingField;
    [CompilerGeneratedAttribute]
private DataPointType <kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <count>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <max>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <stdDev>k__BackingField;
    [CompilerGeneratedAttribute]
private double <value>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    public int ver { get; public set; }
    public string categoryName { get; public set; }
    public string counterName { get; public set; }
    public string instanceName { get; public set; }
    public DataPointType kind { get; public set; }
    public Nullable`1<int> count { get; public set; }
    public Nullable`1<double> min { get; public set; }
    public Nullable`1<double> max { get; public set; }
    public Nullable`1<double> stdDev { get; public set; }
    public double value { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    protected PerformanceCounterData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_categoryName();
    [CompilerGeneratedAttribute]
public void set_categoryName(string value);
    [CompilerGeneratedAttribute]
public string get_counterName();
    [CompilerGeneratedAttribute]
public void set_counterName(string value);
    [CompilerGeneratedAttribute]
public string get_instanceName();
    [CompilerGeneratedAttribute]
public void set_instanceName(string value);
    [CompilerGeneratedAttribute]
public DataPointType get_kind();
    [CompilerGeneratedAttribute]
public void set_kind(DataPointType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_count();
    [CompilerGeneratedAttribute]
public void set_count(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_min();
    [CompilerGeneratedAttribute]
public void set_min(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_max();
    [CompilerGeneratedAttribute]
public void set_max(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_stdDev();
    [CompilerGeneratedAttribute]
public void set_stdDev(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public double get_value();
    [CompilerGeneratedAttribute]
public void set_value(double value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
[EventDataAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.RemoteDependencyData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private DataPointType <kind>k__BackingField;
    [CompilerGeneratedAttribute]
private double <value>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <count>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <max>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <stdDev>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyKind <dependencyKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <success>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <async>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencySourceType <dependencySource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <commandName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <dependencyTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    public int ver { get; public set; }
    public string name { get; public set; }
    public DataPointType kind { get; public set; }
    public double value { get; public set; }
    public Nullable`1<int> count { get; public set; }
    public Nullable`1<double> min { get; public set; }
    public Nullable`1<double> max { get; public set; }
    public Nullable`1<double> stdDev { get; public set; }
    public DependencyKind dependencyKind { get; public set; }
    public Nullable`1<bool> success { get; public set; }
    public Nullable`1<bool> async { get; public set; }
    public DependencySourceType dependencySource { get; public set; }
    public string commandName { get; public set; }
    public string dependencyTypeName { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    protected RemoteDependencyData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public DataPointType get_kind();
    [CompilerGeneratedAttribute]
public void set_kind(DataPointType value);
    [CompilerGeneratedAttribute]
public double get_value();
    [CompilerGeneratedAttribute]
public void set_value(double value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_count();
    [CompilerGeneratedAttribute]
public void set_count(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_min();
    [CompilerGeneratedAttribute]
public void set_min(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_max();
    [CompilerGeneratedAttribute]
public void set_max(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_stdDev();
    [CompilerGeneratedAttribute]
public void set_stdDev(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public DependencyKind get_dependencyKind();
    [CompilerGeneratedAttribute]
public void set_dependencyKind(DependencyKind value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_success();
    [CompilerGeneratedAttribute]
public void set_success(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_async();
    [CompilerGeneratedAttribute]
public void set_async(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public DependencySourceType get_dependencySource();
    [CompilerGeneratedAttribute]
public void set_dependencySource(DependencySourceType value);
    [CompilerGeneratedAttribute]
public string get_commandName();
    [CompilerGeneratedAttribute]
public void set_commandName(string value);
    [CompilerGeneratedAttribute]
public string get_dependencyTypeName();
    [CompilerGeneratedAttribute]
public void set_dependencyTypeName(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
[EventDataAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.RequestData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <startTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <responseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <success>k__BackingField;
    [CompilerGeneratedAttribute]
private string <httpMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <url>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, double> <measurements>k__BackingField;
    public int ver { get; public set; }
    public string id { get; public set; }
    public string name { get; public set; }
    public string startTime { get; public set; }
    public string duration { get; public set; }
    public string responseCode { get; public set; }
    public bool success { get; public set; }
    public string httpMethod { get; public set; }
    public string url { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected RequestData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_id();
    [CompilerGeneratedAttribute]
public void set_id(string value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public string get_startTime();
    [CompilerGeneratedAttribute]
public void set_startTime(string value);
    [CompilerGeneratedAttribute]
public string get_duration();
    [CompilerGeneratedAttribute]
public void set_duration(string value);
    [CompilerGeneratedAttribute]
public string get_responseCode();
    [CompilerGeneratedAttribute]
public void set_responseCode(string value);
    [CompilerGeneratedAttribute]
public bool get_success();
    [CompilerGeneratedAttribute]
public void set_success(bool value);
    [CompilerGeneratedAttribute]
public string get_httpMethod();
    [CompilerGeneratedAttribute]
public void set_httpMethod(string value);
    [CompilerGeneratedAttribute]
public string get_url();
    [CompilerGeneratedAttribute]
public void set_url(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, double> get_measurements();
    [CompilerGeneratedAttribute]
public void set_measurements(IDictionary`2<string, double> value);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.SessionContextData : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public Nullable`1<bool> IsFirst { get; public set; }
    public Nullable`1<bool> IsNewSession { get; public set; }
    internal SessionContextData(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public Nullable`1<bool> get_IsFirst();
    public void set_IsFirst(Nullable`1<bool> value);
    public Nullable`1<bool> get_IsNewSession();
    public void set_IsNewSession(Nullable`1<bool> value);
    internal void SetDefaults(SessionContextData source);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal enum Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.SessionState : Enum {
    public int value__;
    public static SessionState Start;
    public static SessionState End;
}
[EventDataAttribute]
[GeneratedCodeAttribute("gbc", "3.02")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.SessionStateData : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionState <state>k__BackingField;
    public int ver { get; public set; }
    public SessionState state { get; public set; }
    protected SessionStateData(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public SessionState get_state();
    [CompilerGeneratedAttribute]
public void set_state(SessionState value);
}
[GeneratedCodeAttribute("gbc", "3.02")]
internal enum Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.SeverityLevel : Enum {
    public int value__;
    public static SeverityLevel Verbose;
    public static SeverityLevel Information;
    public static SeverityLevel Warning;
    public static SeverityLevel Error;
    public static SeverityLevel Critical;
}
[GeneratedCodeAttribute("gbc", "3.02")]
[EventDataAttribute]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.StackFrame : object {
    [CompilerGeneratedAttribute]
private int <level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <fileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <line>k__BackingField;
    public int level { get; public set; }
    public string method { get; public set; }
    public string assembly { get; public set; }
    public string fileName { get; public set; }
    public int line { get; public set; }
    protected StackFrame(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_level();
    [CompilerGeneratedAttribute]
public void set_level(int value);
    [CompilerGeneratedAttribute]
public string get_method();
    [CompilerGeneratedAttribute]
public void set_method(string value);
    [CompilerGeneratedAttribute]
public string get_assembly();
    [CompilerGeneratedAttribute]
public void set_assembly(string value);
    [CompilerGeneratedAttribute]
public string get_fileName();
    [CompilerGeneratedAttribute]
public void set_fileName(string value);
    [CompilerGeneratedAttribute]
public int get_line();
    [CompilerGeneratedAttribute]
public void set_line(int value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.Tags : object {
    [ExtensionAttribute]
internal static Nullable`1<bool> GetTagBoolValueOrNull(IDictionary`2<string, string> tags, string tagKey);
    [ExtensionAttribute]
internal static Nullable`1<int> GetTagIntValueOrNull(IDictionary`2<string, string> tags, string tagKey);
    [ExtensionAttribute]
internal static Nullable`1<DateTimeOffset> GetTagDateTimeOffsetValueOrNull(IDictionary`2<string, string> tags, string tagKey);
    [ExtensionAttribute]
internal static void SetStringValueOrRemove(IDictionary`2<string, string> tags, string tagKey, string tagValue);
    [ExtensionAttribute]
internal static void SetDateTimeOffsetValueOrRemove(IDictionary`2<string, string> tags, string tagKey, Nullable`1<DateTimeOffset> tagValue);
    [ExtensionAttribute]
internal static void SetTagValueOrRemove(IDictionary`2<string, string> tags, string tagKey, T tagValue);
    [ExtensionAttribute]
internal static void InitializeTagValue(IDictionary`2<string, string> tags, string tagKey, T tagValue);
    [ExtensionAttribute]
internal static void InitializeTagDateTimeOffsetValue(IDictionary`2<string, string> tags, string tagKey, Nullable`1<DateTimeOffset> tagValue);
    [ExtensionAttribute]
internal static string GetTagValueOrNull(IDictionary`2<string, string> tags, string tagKey);
    [ExtensionAttribute]
private static void SetTagValueOrRemove(IDictionary`2<string, string> tags, string tagKey, string tagValue);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.External.UserContextData : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public string AccountId { get; public set; }
    public string UserAgent { get; public set; }
    public string StoreRegion { get; public set; }
    public Nullable`1<DateTimeOffset> AcquisitionDate { get; public set; }
    internal UserContextData(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public string get_AccountId();
    public void set_AccountId(string value);
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public string get_StoreRegion();
    public void set_StoreRegion(string value);
    public Nullable`1<DateTimeOffset> get_AcquisitionDate();
    public void set_AcquisitionDate(Nullable`1<DateTimeOffset> value);
    internal void SetDefaults(UserContextData source);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.FixedSizeQueue`1 : object {
    private int maxSize;
    private object queueLockObj;
    private Queue`1<T> queue;
    internal FixedSizeQueue`1(int maxSize);
    internal void Enqueue(T item);
    internal bool Contains(T item);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.IClock {
    public DateTimeOffset Time { get; }
    public abstract virtual DateTimeOffset get_Time();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.InternalContext : object {
    private IDictionary`2<string, string> tags;
    public string SdkVersion { get; public set; }
    public string AgentVersion { get; public set; }
    internal InternalContext(IDictionary`2<string, string> tags);
    public string get_SdkVersion();
    public void set_SdkVersion(string value);
    public string get_AgentVersion();
    public void set_AgentVersion(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.IPlatform {
    public abstract virtual IDictionary`2<string, object> GetApplicationSettings();
    public abstract virtual string ReadConfigurationXml();
    public abstract virtual ExceptionDetails GetExceptionDetails(Exception exception, ExceptionDetails parentExceptionDetails);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.IPlatformDispatcher {
    public abstract virtual Task RunAsync(Action action);
}
internal interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.IRandomNumberBatchGenerator {
    public abstract virtual void NextBatch(UInt64[] buffer, int index, int count);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.JsonWriter : object {
    private EmptyObjectDetector emptyObjectDetector;
    private TextWriter textWriter;
    private bool currentObjectHasProperties;
    internal JsonWriter(TextWriter textWriter);
    public sealed virtual void WriteStartArray();
    public sealed virtual void WriteStartObject();
    public sealed virtual void WriteEndArray();
    public sealed virtual void WriteEndObject();
    public sealed virtual void WriteComma();
    public sealed virtual void WriteRawValue(object value);
    public sealed virtual void WriteProperty(string name, string value);
    public sealed virtual void WriteProperty(string name, Nullable`1<bool> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<int> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<double> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<TimeSpan> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<DateTimeOffset> value);
    public sealed virtual void WriteProperty(string name, IJsonSerializable value);
    public sealed virtual void WriteProperty(string name, IDictionary`2<string, double> values);
    public sealed virtual void WriteProperty(string name, IDictionary`2<string, string> values);
    public sealed virtual void WritePropertyName(string name);
    protected bool IsNullOrEmpty(IJsonSerializable instance);
    protected void WriteString(string value);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.LocationContext : object {
    private IDictionary`2<string, string> tags;
    public string Ip { get; public set; }
    internal LocationContext(IDictionary`2<string, string> tags);
    public string get_Ip();
    public void set_Ip(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
    private bool IsIpV4(string ip);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.OperationContext : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public string Name { get; public set; }
    public string SyntheticSource { get; public set; }
    internal OperationContext(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_SyntheticSource();
    public void set_SyntheticSource(string value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Platform.PlatformApplicationLifecycle : object {
    private static IApplicationLifecycle provider;
    [CompilerGeneratedAttribute]
private Action`2<object, object> Started;
    [CompilerGeneratedAttribute]
private EventHandler`1<ApplicationStoppingEventArgs> Stopping;
    public static IApplicationLifecycle Provider { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
    public static IApplicationLifecycle get_Provider();
    public static void set_Provider(IApplicationLifecycle value);
    internal void Initialize();
    private static IApplicationLifecycle CreateDefaultProvider();
    private void OnStopping(ApplicationStoppingEventArgs eventArgs);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(object sender, EventArgs e);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Platform.PlatformImplementation : object {
    public sealed virtual IDictionary`2<string, object> GetApplicationSettings();
    public sealed virtual string ReadConfigurationXml();
    public sealed virtual ExceptionDetails GetExceptionDetails(Exception exception, ExceptionDetails parentExceptionDetails);
}
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Platform.PlatformSingleton : object {
    private static IPlatform current;
    public static IPlatform Current { get; public set; }
    public static IPlatform get_Current();
    public static void set_Current(IPlatform value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.Property : object {
    public static int MaxDictionaryNameLength;
    public static int MaxValueLength;
    public static int MaxNameLength;
    public static int MaxMessageLength;
    public static int MaxUrlLength;
    private static RegexOptions SanitizeOptions;
    private static Regex InvalidNameCharacters;
    private static Property();
    public static void Set(T& property, T value);
    public static void Initialize(Nullable`1& property, Nullable`1<T> value);
    public static void Initialize(String& property, string value);
    [ExtensionAttribute]
public static string SanitizeName(string name);
    [ExtensionAttribute]
public static string SanitizeValue(string value);
    [ExtensionAttribute]
public static string SanitizeMessage(string message);
    [ExtensionAttribute]
public static Uri SanitizeUri(Uri uri);
    [ExtensionAttribute]
public static void SanitizeProperties(IDictionary`2<string, string> dictionary);
    [ExtensionAttribute]
public static void SanitizeMeasurements(IDictionary`2<string, double> dictionary);
    private static string TrimAndTruncate(string value, int maxLength);
    private static string Truncate(string value, int maxLength);
    private static string SanitizeKey(string key, IDictionary`2<string, TValue> dictionary);
    private static string MakeKeyNonEmpty(string key);
    private static string MakeKeyUnique(string key, IDictionary`2<string, TValue> dictionary);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.SessionContext : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public Nullable`1<bool> IsFirst { get; public set; }
    internal SessionContext(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public Nullable`1<bool> get_IsFirst();
    public void set_IsFirst(Nullable`1<bool> value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.SeverityLevelExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<SeverityLevel> TranslateSeverityLevel(Nullable`1<SeverityLevel> sdkSeverityLevel);
    [ExtensionAttribute]
public static Nullable`1<SeverityLevel> TranslateSeverityLevel(Nullable`1<SeverityLevel> dataPlatformSeverityLevel);
}
internal abstract class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.SnapshottingCollection`2 : object {
    protected TCollection Collection;
    protected TCollection snapshot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    protected SnapshottingCollection`2(TCollection collection);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TItem item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TItem item);
    public sealed virtual void CopyTo(TItem[] array, int arrayIndex);
    public sealed virtual bool Remove(TItem item);
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected abstract virtual TCollection CreateSnapshot(TCollection collection);
    protected TCollection GetSnapshot();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.SnapshottingDictionary`2 : SnapshottingCollection`2<KeyValuePair`2<TKey, TValue>, IDictionary`2<TKey, TValue>> {
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    protected sealed virtual IDictionary`2<TKey, TValue> CreateSnapshot(IDictionary`2<TKey, TValue> collection);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.SnapshottingList`1 : SnapshottingCollection`2<T, IList`1<T>> {
    public T Item { get; public set; }
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    protected sealed virtual IList`1<T> CreateSnapshot(IList`1<T> collection);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TaskTimer : object {
    public static TimeSpan InfiniteTimeSpan;
    private TimeSpan delay;
    private CancellationTokenSource tokenSource;
    public TimeSpan Delay { get; public set; }
    public bool IsStarted { get; }
    private static TaskTimer();
    public TimeSpan get_Delay();
    public void set_Delay(TimeSpan value);
    public bool get_IsStarted();
    public void Start(Func`1<Task> elapsed);
    public void Cancel();
    public sealed virtual void Dispose();
    private static void CancelAndDispose(CancellationTokenSource tokenSource);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TelemetryConfigurationFactory : object {
    private static string AddElementName;
    private static string TypeAttributeName;
    private static MethodInfo LoadInstancesDefinition;
    private static XNamespace XmlNamespace;
    private static TelemetryConfigurationFactory instance;
    public static TelemetryConfigurationFactory Instance { get; public set; }
    private static TelemetryConfigurationFactory();
    public static TelemetryConfigurationFactory get_Instance();
    public static void set_Instance(TelemetryConfigurationFactory value);
    public virtual void Initialize(TelemetryConfiguration configuration);
    protected static object CreateInstance(Type interfaceType, string typeName);
    protected static void LoadFromXml(TelemetryConfiguration configuration, XDocument xml);
    protected static object LoadInstance(XElement definition, Type expectedType, object instance);
    protected static void LoadInstances(XElement definition, ICollection`1<T> instances);
    protected static void LoadProperties(XElement instanceDefinition, object instance);
    private static void InitializeComponents(TelemetryConfiguration configuration);
    private static void InitializeComponents(IEnumerable components, TelemetryConfiguration configuration);
    private static void InitializeComponent(object component, TelemetryConfiguration configuration);
    private static void LoadInstanceFromValue(XElement definition, Type expectedType, Object& instance);
    private static Type GetType(string typeName);
    private static Type GetManagedType(string typeName);
    private static bool GetCollectionElementType(Type type, Type& elementType);
    private static IEnumerable`1<XElement> GetPropertyDefinitions(XElement instanceDefinition);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TelemetryContextExtensions : object {
    [ExtensionAttribute]
public static InternalContext GetInternalContext(TelemetryContext context);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TelemetryHelper : object {
    [ExtensionAttribute]
public static void WriteEnvelopeProperties(ITelemetry telemetry, IJsonWriter json);
    private static void AddMsInternal(EventTelemetry telemetry, IJsonWriter json);
    [ExtensionAttribute]
public static void WriteTelemetryName(ITelemetry telemetry, IJsonWriter json, string telemetryName);
    private static string NormalizeInstrumentationKey(string instrumentationKey);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TelemetryItemExtensions : object {
    [ExtensionAttribute]
internal static string GetTelemetryFullName(ITelemetry item, string envelopeName);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.TypeExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetRuntimeMethods(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.UserContext : object {
    private IDictionary`2<string, string> tags;
    public string Id { get; public set; }
    public string AccountId { get; public set; }
    public string UserAgent { get; public set; }
    public Nullable`1<DateTimeOffset> AcquisitionDate { get; public set; }
    internal UserContext(IDictionary`2<string, string> tags);
    public string get_Id();
    public void set_Id(string value);
    public string get_AccountId();
    public void set_AccountId(string value);
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public Nullable`1<DateTimeOffset> get_AcquisitionDate();
    public void set_AcquisitionDate(Nullable`1<DateTimeOffset> value);
    private sealed virtual override void Microsoft.VisualStudio.ApplicationInsights.DataContracts.IJsonSerializable.Serialize(IJsonWriter writer);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.WeakConcurrentRandom : object {
    private static WeakConcurrentRandom random;
    private int index;
    private int segmentCount;
    private int segmentSize;
    private int bitsToStoreRandomIndexWithinSegment;
    private int segmentIndexMask;
    private int randomIndexWithinSegmentMask;
    private int randomArrayIndexMask;
    private IRandomNumberBatchGenerator[] randomGemerators;
    private UInt64[] randomNumbers;
    public static WeakConcurrentRandom Instance { get; }
    public static WeakConcurrentRandom get_Instance();
    public void Initialize();
    public void Initialize(Func`2<ulong, IRandomNumberBatchGenerator> randomGeneratorFactory, int segmentIndexBits, int segmentBits);
    public ulong Next();
    private void RegenerateSegment(int newIndex);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.Implementation.XorshiftRandomBatchGenerator : object {
    private static ulong Y;
    private static ulong Z;
    private static ulong W;
    private ulong lastX;
    private ulong lastY;
    private ulong lastZ;
    private ulong lastW;
    public XorshiftRandomBatchGenerator(ulong seed);
    public sealed virtual void NextBatch(UInt64[] buffer, int index, int count);
}
public interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.ISupportConfiguration {
    public abstract virtual void Initialize(TelemetryConfiguration configuration);
}
public interface Microsoft.VisualStudio.ApplicationInsights.Extensibility.ITelemetryInitializer {
    public abstract virtual void Initialize(ITelemetry telemetry);
}
internal class Microsoft.VisualStudio.ApplicationInsights.Extensibility.SdkVersionPropertyContextInitializer : object {
    private string sdkVersion;
    public sealed virtual void Initialize(TelemetryContext context);
    private string GetAssemblyVersion();
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.SequencePropertyInitializer : object {
    private string stablePrefix;
    private long currentNumber;
    public sealed virtual void Initialize(ITelemetry telemetry);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.TelemetryConfiguration : object {
    private static object syncRoot;
    private static TelemetryConfiguration active;
    private SnapshottingList`1<IContextInitializer> contextInitializers;
    private SnapshottingList`1<ITelemetryInitializer> telemetryInitializers;
    private SnapshottingList`1<object> telemetryModules;
    private string instrumentationKey;
    private bool disableTelemetry;
    [CompilerGeneratedAttribute]
private ITelemetryChannel <TelemetryChannel>k__BackingField;
    public static TelemetryConfiguration Active { get; internal set; }
    public string InstrumentationKey { get; public set; }
    public bool DisableTelemetry { get; public set; }
    public IList`1<IContextInitializer> ContextInitializers { get; }
    public IList`1<ITelemetryInitializer> TelemetryInitializers { get; }
    public IList`1<object> TelemetryModules { get; }
    public ITelemetryChannel TelemetryChannel { get; public set; }
    private static TelemetryConfiguration();
    public static TelemetryConfiguration get_Active();
    internal static void set_Active(TelemetryConfiguration value);
    public string get_InstrumentationKey();
    public void set_InstrumentationKey(string value);
    public bool get_DisableTelemetry();
    public void set_DisableTelemetry(bool value);
    public IList`1<IContextInitializer> get_ContextInitializers();
    public IList`1<ITelemetryInitializer> get_TelemetryInitializers();
    public IList`1<object> get_TelemetryModules();
    [CompilerGeneratedAttribute]
public ITelemetryChannel get_TelemetryChannel();
    [CompilerGeneratedAttribute]
public void set_TelemetryChannel(ITelemetryChannel value);
    public static TelemetryConfiguration CreateDefault();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class Microsoft.VisualStudio.ApplicationInsights.Extensibility.TimestampPropertyInitializer : object {
    public sealed virtual void Initialize(ITelemetry telemetry);
}
public class Microsoft.VisualStudio.ApplicationInsights.TelemetryClient : object {
    private TelemetryConfiguration configuration;
    private TelemetryContext context;
    private ITelemetryChannel channel;
    public TelemetryContext Context { get; internal set; }
    public string InstrumentationKey { get; public set; }
    internal ITelemetryChannel Channel { get; internal set; }
    public TelemetryClient(TelemetryConfiguration configuration);
    public TelemetryContext get_Context();
    internal void set_Context(TelemetryContext value);
    public string get_InstrumentationKey();
    public void set_InstrumentationKey(string value);
    internal ITelemetryChannel get_Channel();
    internal void set_Channel(ITelemetryChannel value);
    public bool IsEnabled();
    public void TrackEvent(string eventName, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics);
    public void TrackEvent(EventTelemetry telemetry);
    public void TrackTrace(string message);
    public void TrackTrace(string message, SeverityLevel severityLevel);
    public void TrackTrace(string message, IDictionary`2<string, string> properties);
    public void TrackTrace(string message, SeverityLevel severityLevel, IDictionary`2<string, string> properties);
    public void TrackTrace(TraceTelemetry telemetry);
    public void TrackMetric(string name, double value, IDictionary`2<string, string> properties);
    public void TrackMetric(MetricTelemetry telemetry);
    public void TrackException(Exception exception, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics);
    public void TrackException(ExceptionTelemetry telemetry);
    [EditorBrowsableAttribute("1")]
public void Track(ITelemetry telemetry);
    public void TrackPageView(string name);
    public void TrackPageView(PageViewTelemetry telemetry);
    public void TrackRequest(string name, DateTimeOffset timestamp, TimeSpan duration, string responseCode, bool success);
    public void TrackRequest(RequestTelemetry request);
    public void Flush();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ApplicationInsights.TelemetryClient/<FlushAndTransmitAsync>d__32")]
public Task FlushAndTransmitAsync(CancellationToken token);
    private TelemetryContext CreateInitializedContext();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ApplicationInsights.Utils : object {
    private static String[] RelativeFolderPath;
    private static Utils();
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
    public static void CopyDictionary(IDictionary`2<string, TValue> source, IDictionary`2<string, TValue> target);
    public static string PopulateRequiredStringValue(string value, string parameterName, string telemetryType);
    public static TimeSpan ValidateDuration(string value);
    public static TType ReadSerializedContext(string fileName);
}
internal class Microsoft.VisualStudio.Experimentation.ActiveFlightsData : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <Flights>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConfigData> <Configs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssignmentContext>k__BackingField;
    [JsonPropertyAttribute]
public IList`1<string> Flights { get; public set; }
    [JsonPropertyAttribute]
public IList`1<ConfigData> Configs { get; public set; }
    [JsonPropertyAttribute]
public string AssignmentContext { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_Flights();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Flights(IList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ConfigData> get_Configs();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configs(IList`1<ConfigData> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssignmentContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AssignmentContext(string value);
}
internal class Microsoft.VisualStudio.Experimentation.AFDFlightsProvider : CachedRemotePollerFlightsProviderBase`1<ActiveFlightsData> {
    private static int DefaultPollingIntervalInSecs;
    private static int DefaultRequestTimeout;
    private static string DefaultGetMethod;
    private static string DefaultContentType;
    private static string DefaultUrl;
    private static HttpRequestCachePolicy DefaultCachePolicy;
    internal static Regex RegExpression;
    private string flightsKey;
    private IExperimentationFilterProvider filterProvider;
    private IHttpWebRequestFactory httpWebRequestFactory;
    public AFDFlightsProvider(IKeyValueStorage keyValueStorage, string flightsKey, IFlightsStreamParser flightsStreamParser, IExperimentationFilterProvider filterProvider, IHttpWebRequestFactory httpWebRequestFactory);
    private static AFDFlightsProvider();
    protected virtual void InternalDispose();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.AFDFlightsProvider/<SendRemoteRequestInternalAsync>d__12")]
protected virtual Task`1<Stream> SendRemoteRequestInternalAsync();
    protected virtual string BuildFlightsKey();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Experimentation.AFDFlightsProvider/<GetAllFilters>d__14")]
private IEnumerable`1<KeyValuePair`2<string, string>> GetAllFilters();
    private static string ProcessFilterValue(string value);
    private void AddIfNotEmpty(List`1<string> parts, string v);
}
internal abstract class Microsoft.VisualStudio.Experimentation.CachedRemotePollerFlightsProviderBase`1 : TelemetryDisposableObject {
    private object lockObject;
    private Lazy`1<LocalFlightsProvider> cachedFlightsProvider;
    private IFlightsStreamParser flightsStreamParser;
    private Timer timer;
    private int timerInterval;
    private bool isStarted;
    private Task firstTaskRequest;
    private HashSet`1<FlightAllocation> flights;
    private IList`1<ConfigData> configs;
    [CompilerGeneratedAttribute]
private EventHandler`1<FlightsEventArgs> FlightsUpdated;
    public IEnumerable`1<FlightAllocation> Flights { get; private set; }
    public IEnumerable`1<ConfigData> Configs { get; private set; }
    public CachedRemotePollerFlightsProviderBase`1(IKeyValueStorage keyValueStorage, IFlightsStreamParser flightsStreamParser, int timerInterval);
    public sealed virtual IEnumerable`1<FlightAllocation> get_Flights();
    private void set_Flights(IEnumerable`1<FlightAllocation> value);
    public sealed virtual IEnumerable`1<ConfigData> get_Configs();
    private void set_Configs(IEnumerable`1<ConfigData> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    public sealed virtual void Start();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.CachedRemotePollerFlightsProviderBase`1/<WaitForReadyAsync>d__20")]
public sealed virtual Task WaitForReadyAsync(CancellationToken token);
    protected virtual void DisposeManagedResources();
    protected abstract virtual Task`1<Stream> SendRemoteRequestInternalAsync();
    protected abstract virtual string BuildFlightsKey();
    protected virtual void InternalDispose();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.CachedRemotePollerFlightsProviderBase`1/<SendRemoteRequestAsync>d__25")]
private Task SendRemoteRequestAsync();
    private void OnFlightsUpdated();
}
internal class Microsoft.VisualStudio.Experimentation.ConfigData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Parameters>k__BackingField;
    [JsonPropertyAttribute]
public string Id { get; public set; }
    [JsonPropertyAttribute]
public IDictionary`2<string, object> Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(IDictionary`2<string, object> value);
}
public class Microsoft.VisualStudio.Experimentation.DefaultExperimentationFilterProvider : object {
    internal static string Unknown;
    private TelemetrySession telemetrySession;
    private IProcessInformationProvider processInformation;
    public DefaultExperimentationFilterProvider(TelemetrySession telemetrySession);
    internal DefaultExperimentationFilterProvider(TelemetrySession telemetrySession, IProcessInformationProvider processInformation);
    public sealed virtual string GetFilterValue(Filters filter);
}
internal class Microsoft.VisualStudio.Experimentation.DefaultExperimentationOptinStatusReader : object {
    private TelemetrySession telemetrySession;
    private Lazy`1<bool> isOptedIn;
    public bool IsOptedIn { get; }
    public DefaultExperimentationOptinStatusReader(TelemetrySession telemetrySession);
    public sealed virtual bool get_IsOptedIn();
    private bool GetIsOptedIn();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__2_0();
}
internal class Microsoft.VisualStudio.Experimentation.DefaultExperimentationTelemetry : object {
    private TelemetrySession telemetrySession;
    public DefaultExperimentationTelemetry(TelemetrySession telemetrySession);
    public sealed virtual void PostEvent(string name, IDictionary`2<string, string> properties);
    public sealed virtual void SetSharedProperty(string name, string value);
    public sealed virtual void PostFault(string eventName, string description);
    public sealed virtual void PostEvent(string name, IDictionary`2<string, object> properties);
    public sealed virtual void SetSharedProperty(string name, object value);
}
internal class Microsoft.VisualStudio.Experimentation.DisabledFlightsData : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <Flights>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConfigData> <Configs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssignmentContext>k__BackingField;
    [JsonPropertyAttribute]
public IList`1<string> Flights { get; public set; }
    [JsonPropertyAttribute]
public IList`1<ConfigData> Configs { get; public set; }
    [JsonPropertyAttribute]
public string AssignmentContext { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_Flights();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Flights(IList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ConfigData> get_Configs();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configs(IList`1<ConfigData> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssignmentContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AssignmentContext(string value);
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Experimentation.DisabledFlightsRemoteFileReaderFactory : FlightsRemoteFileReaderFactoryBase {
    private static string DefaultPath;
}
public class Microsoft.VisualStudio.Experimentation.ExperimentationService : TelemetryDisposableObject {
    private static Lazy`1<ExperimentationService> defaultExperimentationService;
    private static ExperimentationServiceInitializer customInitializer;
    private IExperimentationTelemetry telemetry;
    private IExperimentationFilterProvider filterProvider;
    private ConcurrentDictionary`2<string, FlightStatus> flightStatus;
    private IFlightsProvider flightsProvider;
    private SetFlightsProvider setFlightsProvider;
    private object lockStartFlights;
    private bool isStarted;
    [ExcludeFromCodeCoverageAttribute]
public static IExperimentationService Default { get; }
    [ExcludeFromCodeCoverageAttribute]
public static IExperimentationSetterService DefaultSetter { get; }
    [ExcludeFromCodeCoverageAttribute]
public static IExperimentationStatusService DefaultStatus { get; }
    public IEnumerable`1<string> AllEnabledCachedFlights { get; }
    public ExperimentationService(ExperimentationServiceInitializer initializer);
    private static ExperimentationService();
    public static IExperimentationService get_Default();
    public static IExperimentationSetterService get_DefaultSetter();
    public static IExperimentationStatusService get_DefaultStatus();
    private static ExperimentationServiceInitializer GetDefaultInitializer();
    public static IExperimentationService CreateDefaultExperimentationService(ExperimentationServiceInitializer initializer);
    public sealed virtual bool QueryCachedFlightStatus(string flight);
    public sealed virtual bool IsCachedFlightEnabled(string flight);
    public sealed virtual Task`1<bool> QueryFlightStatusAsync(string flight, CancellationToken token);
    public sealed virtual Task`1<bool> IsFlightEnabledAsync(string flight, CancellationToken token);
    public sealed virtual IEnumerable`1<string> get_AllEnabledCachedFlights();
    public sealed virtual void Start();
    public sealed virtual void SetFlight(string flightName, int timeoutInMinutes);
    protected virtual void DisposeManagedResources();
    private void OnFlightsUpdated(object sender, FlightsEventArgs e);
    private void SetFlightsTelemetry();
    private void PostFlightRequestTelemetry(string flight, bool isEnabled);
    private bool IsCachedFlightEnabledInternal(string flight, bool sendTriggeredEvent);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.ExperimentationService/<IsFlightEnabledInternalAsync>d__31")]
private Task`1<bool> IsFlightEnabledInternalAsync(string flight, CancellationToken token, bool sendTriggeredEvent);
    public sealed virtual IDictionary`2<string, object> GetCachedTreatmentVariables(string configId);
    public sealed virtual Task`1<IDictionary`2<string, object>> GetTreatmentVariablesAsync(string configId, CancellationToken token);
    public sealed virtual Task`1<string> GetStringTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public sealed virtual Task`1<Nullable`1<int>> GetIntTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public sealed virtual Task`1<Nullable`1<bool>> GetBoolTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public sealed virtual Task`1<Nullable`1<double>> GetDoubleTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.ExperimentationService/<GetTreatmentVariableInternalAsync>d__38`1")]
private Task`1<T> GetTreatmentVariableInternalAsync(string configId, string varName, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.ExperimentationService/<GetConfigDataInternalAsync>d__39")]
private Task`1<IDictionary`2<string, object>> GetConfigDataInternalAsync(string configId, CancellationToken token);
}
[ExcludeFromCodeCoverageAttribute]
public class Microsoft.VisualStudio.Experimentation.ExperimentationServiceInitializer : object {
    private static string localTestFlightsPathSuffix;
    private static string enabledFlightsKey;
    private static string disabledFlightsKey;
    private static string shippedFlightsKey;
    private static string setFlightsKey;
    [CompilerGeneratedAttribute]
private IExperimentationTelemetry <ExperimentationTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private IExperimentationFilterProvider <ExperimentationFilterProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyValueStorage <KeyValueStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private IExperimentationOptinStatusReader <ExperimentationOptinStatusReader>k__BackingField;
    [CompilerGeneratedAttribute]
private IFlightsProvider <FlightsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private SetFlightsProvider <SetFlightsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteFileReaderFactory <ShippedRemoteFileReaderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteFileReaderFactory <DisabledSetRemoteFileReaderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IFlightsStreamParser <FlightsStreamParser>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpWebRequestFactory <HttpWebRequestFactory>k__BackingField;
    public IExperimentationTelemetry ExperimentationTelemetry { get; public set; }
    public IExperimentationFilterProvider ExperimentationFilterProvider { get; public set; }
    public IKeyValueStorage KeyValueStorage { get; public set; }
    public IExperimentationOptinStatusReader ExperimentationOptinStatusReader { get; public set; }
    internal IFlightsProvider FlightsProvider { get; internal set; }
    internal SetFlightsProvider SetFlightsProvider { get; internal set; }
    internal IRemoteFileReaderFactory ShippedRemoteFileReaderFactory { get; internal set; }
    internal IRemoteFileReaderFactory DisabledSetRemoteFileReaderFactory { get; internal set; }
    internal IFlightsStreamParser FlightsStreamParser { get; internal set; }
    internal IHttpWebRequestFactory HttpWebRequestFactory { get; internal set; }
    private static ExperimentationServiceInitializer();
    [CompilerGeneratedAttribute]
public IExperimentationTelemetry get_ExperimentationTelemetry();
    [CompilerGeneratedAttribute]
public void set_ExperimentationTelemetry(IExperimentationTelemetry value);
    [CompilerGeneratedAttribute]
public IExperimentationFilterProvider get_ExperimentationFilterProvider();
    [CompilerGeneratedAttribute]
public void set_ExperimentationFilterProvider(IExperimentationFilterProvider value);
    [CompilerGeneratedAttribute]
public IKeyValueStorage get_KeyValueStorage();
    [CompilerGeneratedAttribute]
public void set_KeyValueStorage(IKeyValueStorage value);
    [CompilerGeneratedAttribute]
public IExperimentationOptinStatusReader get_ExperimentationOptinStatusReader();
    [CompilerGeneratedAttribute]
public void set_ExperimentationOptinStatusReader(IExperimentationOptinStatusReader value);
    [CompilerGeneratedAttribute]
internal IFlightsProvider get_FlightsProvider();
    [CompilerGeneratedAttribute]
internal void set_FlightsProvider(IFlightsProvider value);
    [CompilerGeneratedAttribute]
internal SetFlightsProvider get_SetFlightsProvider();
    [CompilerGeneratedAttribute]
internal void set_SetFlightsProvider(SetFlightsProvider value);
    [CompilerGeneratedAttribute]
internal IRemoteFileReaderFactory get_ShippedRemoteFileReaderFactory();
    [CompilerGeneratedAttribute]
internal void set_ShippedRemoteFileReaderFactory(IRemoteFileReaderFactory value);
    [CompilerGeneratedAttribute]
internal IRemoteFileReaderFactory get_DisabledSetRemoteFileReaderFactory();
    [CompilerGeneratedAttribute]
internal void set_DisabledSetRemoteFileReaderFactory(IRemoteFileReaderFactory value);
    [CompilerGeneratedAttribute]
internal IFlightsStreamParser get_FlightsStreamParser();
    [CompilerGeneratedAttribute]
internal void set_FlightsStreamParser(IFlightsStreamParser value);
    [CompilerGeneratedAttribute]
internal IHttpWebRequestFactory get_HttpWebRequestFactory();
    [CompilerGeneratedAttribute]
internal void set_HttpWebRequestFactory(IHttpWebRequestFactory value);
    public static ExperimentationServiceInitializer BuildDefault();
    public ExperimentationServiceInitializer FillWithDefaults();
}
public enum Microsoft.VisualStudio.Experimentation.Filters : Enum {
    public int value__;
    public static Filters UserId;
    public static Filters ApplicationName;
    public static Filters ApplicationVersion;
    public static Filters ApplicationSku;
    public static Filters BranchBuildFrom;
    public static Filters IsInternal;
    public static Filters ChannelId;
}
internal class Microsoft.VisualStudio.Experimentation.FlightAllocation : object {
    private static char RegistrySplitCharacter;
    private static char NetworkSplitCharacter;
    [CompilerGeneratedAttribute]
private string <FlightName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllocationId>k__BackingField;
    private string registryFormat;
    public string FlightName { get; private set; }
    public string AllocationId { get; private set; }
    public FlightAllocation(string flight);
    public FlightAllocation(string flight, string allocation);
    private static FlightAllocation();
    [CompilerGeneratedAttribute]
public string get_FlightName();
    [CompilerGeneratedAttribute]
private void set_FlightName(string value);
    [CompilerGeneratedAttribute]
public string get_AllocationId();
    [CompilerGeneratedAttribute]
private void set_AllocationId(string value);
    public static FlightAllocation CreateFromNetworkString(string rawNetworkFlight);
    public static FlightAllocation CreateFromRegistryString(string rawRegistryFlight);
    public FlightAllocation ToLowerInvariant();
    public string ToRegistryString();
    public virtual string ToString();
    public sealed virtual bool Equals(FlightAllocation other);
    public virtual int GetHashCode();
    private static FlightAllocation CreationHelper(string flightString, char separator);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Experimentation.FlightAllocationExtensions : object {
    [ExtensionAttribute]
internal static HashSet`1<FlightAllocation> UnionWithFlights(IEnumerable`1<FlightAllocation> flights, IEnumerable`1<FlightAllocation> otherFlights, StringComparer comparer);
    [ExtensionAttribute]
internal static void ExceptWithFlights(HashSet`1<FlightAllocation> flights, IEnumerable`1<FlightAllocation> excludedFlights, StringComparer comparer);
}
internal class Microsoft.VisualStudio.Experimentation.FlightsEventArgs : EventArgs {
}
internal class Microsoft.VisualStudio.Experimentation.FlightsRemoteFileReader : TelemetryDisposableObject {
    private IRemoteControlClient remoteControlClient;
    public FlightsRemoteFileReader(IRemoteControlClient remoteControlClient);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.FlightsRemoteFileReader/<ReadFileAsync>d__2")]
public sealed virtual Task`1<Stream> ReadFileAsync();
    protected virtual void DisposeManagedResources();
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Experimentation.FlightsRemoteFileReaderFactoryBase : object {
    private static int DownloadIntervalInMin;
    private static string DefaultBaseUrl;
    private static string DefaultHostId;
    private string configPath;
    public FlightsRemoteFileReaderFactoryBase(string configPath);
    public sealed virtual IRemoteFileReader Instance();
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationFilterProvider {
    public abstract virtual string GetFilterValue(Filters filter);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationOptinStatusReader {
    public bool IsOptedIn { get; }
    public abstract virtual bool get_IsOptedIn();
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationService {
    public abstract virtual bool IsCachedFlightEnabled(string flight);
    public abstract virtual Task`1<bool> IsFlightEnabledAsync(string flight, CancellationToken token);
    public abstract virtual void Start();
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationService2 {
    public IEnumerable`1<string> AllEnabledCachedFlights { get; }
    public abstract virtual IEnumerable`1<string> get_AllEnabledCachedFlights();
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationService3 {
    public abstract virtual IDictionary`2<string, object> GetCachedTreatmentVariables(string configId);
    public abstract virtual Task`1<IDictionary`2<string, object>> GetTreatmentVariablesAsync(string configId, CancellationToken token);
    public abstract virtual Task`1<string> GetStringTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public abstract virtual Task`1<Nullable`1<int>> GetIntTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public abstract virtual Task`1<Nullable`1<bool>> GetBoolTreatmentVariableAsync(string configId, string varName, CancellationToken token);
    public abstract virtual Task`1<Nullable`1<double>> GetDoubleTreatmentVariableAsync(string configId, string varName, CancellationToken token);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationSetterService {
    public abstract virtual void SetFlight(string flightName, int timeoutInMinutes);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationStatusService {
    public abstract virtual bool QueryCachedFlightStatus(string flight);
    public abstract virtual Task`1<bool> QueryFlightStatusAsync(string flight, CancellationToken token);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationTelemetry {
    public abstract virtual void SetSharedProperty(string name, string value);
    public abstract virtual void PostEvent(string name, IDictionary`2<string, string> properties);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationTelemetry2 {
    public abstract virtual void PostFault(string eventName, string description);
}
public interface Microsoft.VisualStudio.Experimentation.IExperimentationTelemetry3 {
    public abstract virtual void SetSharedProperty(string name, object value);
    public abstract virtual void PostEvent(string name, IDictionary`2<string, object> properties);
}
internal interface Microsoft.VisualStudio.Experimentation.IFlightsData {
    public IList`1<string> Flights { get; public set; }
    public IList`1<ConfigData> Configs { get; public set; }
    public string AssignmentContext { get; public set; }
    public abstract virtual IList`1<string> get_Flights();
    public abstract virtual void set_Flights(IList`1<string> value);
    public abstract virtual IList`1<ConfigData> get_Configs();
    public abstract virtual void set_Configs(IList`1<ConfigData> value);
    public abstract virtual string get_AssignmentContext();
    public abstract virtual void set_AssignmentContext(string value);
}
internal interface Microsoft.VisualStudio.Experimentation.IFlightsProvider {
    public IEnumerable`1<FlightAllocation> Flights { get; }
    public IEnumerable`1<ConfigData> Configs { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    public abstract virtual IEnumerable`1<FlightAllocation> get_Flights();
    public abstract virtual IEnumerable`1<ConfigData> get_Configs();
    public abstract virtual Task WaitForReadyAsync(CancellationToken token);
    public abstract virtual void Start();
}
internal interface Microsoft.VisualStudio.Experimentation.IFlightsStreamParser {
    public abstract virtual Task`1<T> ParseStreamAsync(Stream stream);
}
public interface Microsoft.VisualStudio.Experimentation.IKeyValueStorage {
    public abstract virtual T GetValue(string key, T defaultValue);
    public abstract virtual void SetValue(string key, T value);
}
internal class Microsoft.VisualStudio.Experimentation.JsonFlightsStreamParser : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.JsonFlightsStreamParser/<ParseStreamAsync>d__0`1")]
public sealed virtual Task`1<T> ParseStreamAsync(Stream stream);
}
internal class Microsoft.VisualStudio.Experimentation.LocalFlightsProvider : TelemetryDisposableObject {
    public static string PathToSettingsPrefix;
    public static string PathToConfigSettingsPrefix;
    private object lockObject;
    private IKeyValueStorage keyValueStorage;
    private string pathToSettings;
    private string pathToConfigSettings;
    private string pathToConfigIds;
    private object lockFlights;
    private IEnumerable`1<FlightAllocation> flights;
    private IEnumerable`1<ConfigData> configs;
    public IEnumerable`1<FlightAllocation> Flights { get; public set; }
    public IEnumerable`1<ConfigData> Configs { get; public set; }
    public LocalFlightsProvider(IKeyValueStorage keyValueStorage, string flightsKey);
    private static LocalFlightsProvider();
    public sealed virtual IEnumerable`1<FlightAllocation> get_Flights();
    public void set_Flights(IEnumerable`1<FlightAllocation> value);
    public sealed virtual IEnumerable`1<ConfigData> get_Configs();
    public void set_Configs(IEnumerable`1<ConfigData> value);
    public sealed virtual void add_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    public sealed virtual void remove_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    private IEnumerable`1<FlightAllocation> ReadFlightsOnce();
    private IEnumerable`1<ConfigData> ReadConfigsOnce();
    public sealed virtual void Start();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.LocalFlightsProvider/<WaitForReadyAsync>d__23")]
public sealed virtual Task WaitForReadyAsync(CancellationToken token);
}
internal class Microsoft.VisualStudio.Experimentation.MasterFlightsProvider : TelemetryDisposableObject {
    private IEnumerable`1<IFlightsProvider> inclusiveFlightsProviders;
    private IEnumerable`1<IFlightsProvider> exclusiveFlightsProviders;
    private IFlightsProvider shippedFlightsProvider;
    private bool isUserOptedIn;
    private HashSet`1<FlightAllocation> activeFlights;
    private IList`1<ConfigData> configs;
    [CompilerGeneratedAttribute]
private EventHandler`1<FlightsEventArgs> FlightsUpdated;
    public IEnumerable`1<FlightAllocation> Flights { get; }
    public IEnumerable`1<ConfigData> Configs { get; }
    public MasterFlightsProvider(IEnumerable`1<IFlightsProvider> inclusiveFlightsProviders, IEnumerable`1<IFlightsProvider> exclusiveFlightsProviders, IFlightsProvider shippedFlightsProvider, IExperimentationOptinStatusReader optinStatusReader);
    public sealed virtual IEnumerable`1<FlightAllocation> get_Flights();
    public sealed virtual IEnumerable`1<ConfigData> get_Configs();
    [CompilerGeneratedAttribute]
public sealed virtual void add_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    public sealed virtual void Start();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.MasterFlightsProvider/<WaitForReadyAsync>d__15")]
public sealed virtual Task WaitForReadyAsync(CancellationToken token);
    protected virtual void DisposeManagedResources();
    private void ForAllProviders(Action`1<IFlightsProvider> action);
    private void ForAllProviders(Action`1<IFlightsProvider> action, IEnumerable`1<IFlightsProvider> flightsProviders);
    private void OnProviderFlightsUpdated(object sender, FlightsEventArgs e);
    private HashSet`1<FlightAllocation> BuildListOfFlights();
    private IList`1<ConfigData> BuildListOfConfigs();
    private void OnFlightsUpdated();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_0(IFlightsProvider provider);
}
internal class Microsoft.VisualStudio.Experimentation.RemoteFlightsProvider`1 : CachedRemotePollerFlightsProviderBase`1<T> {
    private static int DefaultPollingIntervalInSecs;
    private string flightsKey;
    private Lazy`1<IRemoteFileReader> remoteFileReader;
    public RemoteFlightsProvider`1(IKeyValueStorage keyValueStorage, string flightsKey, IRemoteFileReaderFactory remoteFileFactory, IFlightsStreamParser flightsStreamParser);
    protected virtual void InternalDispose();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.RemoteFlightsProvider`1/<SendRemoteRequestInternalAsync>d__5")]
protected virtual Task`1<Stream> SendRemoteRequestInternalAsync();
    protected virtual string BuildFlightsKey();
}
internal class Microsoft.VisualStudio.Experimentation.SetFlightsProvider : TelemetryDisposableObject {
    private Lazy`1<LocalFlightsProvider> cachedFlightsProvider;
    private object lockObject;
    private HashSet`1 modreq(System.Runtime.CompilerServices.IsVolatile) flights;
    private IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) configs;
    public IEnumerable`1<FlightAllocation> Flights { get; }
    public IEnumerable`1<ConfigData> Configs { get; }
    public SetFlightsProvider(IKeyValueStorage keyValueStorage, string flightsKey);
    public sealed virtual IEnumerable`1<FlightAllocation> get_Flights();
    public sealed virtual IEnumerable`1<ConfigData> get_Configs();
    public sealed virtual void add_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    public sealed virtual void remove_FlightsUpdated(EventHandler`1<FlightsEventArgs> value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Experimentation.SetFlightsProvider/<WaitForReadyAsync>d__12")]
public sealed virtual Task WaitForReadyAsync(CancellationToken token);
    public sealed virtual void Start();
    public void SetFlight(string flightName, int timeoutInMinutes);
    private IEnumerable`1<FlightAllocation> GetRawFlights();
    private IEnumerable`1<ConfigData> GetRawConfigs();
    private void SetRawFlights(IEnumerable`1<FlightAllocation> rawFlights);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Experimentation.SetFlightsProvider/<ConvertRawDataToPlainFlights>d__18")]
private IEnumerable`1<FlightAllocation> ConvertRawDataToPlainFlights(IEnumerable`1<FlightAllocation> rawFlights);
}
internal class Microsoft.VisualStudio.Experimentation.ShippedFlightsData : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <Flights>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConfigData> <Configs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssignmentContext>k__BackingField;
    [JsonPropertyAttribute]
public IList`1<string> Flights { get; public set; }
    [JsonPropertyAttribute]
public IList`1<ConfigData> Configs { get; public set; }
    [JsonPropertyAttribute]
public string AssignmentContext { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_Flights();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Flights(IList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ConfigData> get_Configs();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configs(IList`1<ConfigData> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssignmentContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AssignmentContext(string value);
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Experimentation.ShippedFlightsRemoteFileReaderFactory : FlightsRemoteFileReaderFactoryBase {
    private static string DefaultPath;
}
internal class Microsoft.VisualStudio.RemoteSettings.ActionCategory : object {
    [CompilerGeneratedAttribute]
private string <CategoryId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WaitTimeSpan>k__BackingField;
    [JsonPropertyAttribute]
public string CategoryId { get; public set; }
    [JsonPropertyAttribute]
public string WaitTimeSpan { get; public set; }
    [CompilerGeneratedAttribute]
public virtual string get_CategoryId();
    [CompilerGeneratedAttribute]
public virtual void set_CategoryId(string value);
    [CompilerGeneratedAttribute]
public virtual string get_WaitTimeSpan();
    [CompilerGeneratedAttribute]
public virtual void set_WaitTimeSpan(string value);
}
internal class Microsoft.VisualStudio.RemoteSettings.ActionRequestParameters : object {
    [CompilerGeneratedAttribute]
private string <MachineId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VsoId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VsSku>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NotificationsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppIdPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MacAddressHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChannelId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChannelManifestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManifestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OsType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExeName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IsInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <CachedRuleIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionRole>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClrVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientSourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GroupPolicyTelemetryLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentPolicyTelemetryLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LimitDumpCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MspFlags>k__BackingField;
    [JsonPropertyAttribute]
public string MachineId { get; public set; }
    [JsonPropertyAttribute]
public string UserId { get; public set; }
    [JsonPropertyAttribute]
public string VsoId { get; public set; }
    [JsonPropertyAttribute]
public string Culture { get; public set; }
    [JsonPropertyAttribute]
public string Version { get; public set; }
    [JsonPropertyAttribute]
public string VsSku { get; public set; }
    [JsonPropertyAttribute]
public int NotificationsCount { get; public set; }
    [JsonPropertyAttribute]
public string AppIdPackage { get; public set; }
    [JsonPropertyAttribute]
public string MacAddressHash { get; public set; }
    [JsonPropertyAttribute]
public string ChannelId { get; public set; }
    [JsonPropertyAttribute]
public string ChannelManifestId { get; public set; }
    [JsonPropertyAttribute]
public string ManifestId { get; public set; }
    [JsonPropertyAttribute]
public string OsType { get; public set; }
    [JsonPropertyAttribute]
public string OsVersion { get; public set; }
    [JsonPropertyAttribute]
public string ExeName { get; public set; }
    [JsonPropertyAttribute]
public int IsInternal { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<string> CachedRuleIds { get; public set; }
    [JsonPropertyAttribute]
public string SessionId { get; public set; }
    [JsonPropertyAttribute]
public string SessionRole { get; public set; }
    [JsonPropertyAttribute]
public string ClrVersion { get; public set; }
    [JsonPropertyAttribute]
public string ProcessArchitecture { get; public set; }
    [JsonPropertyAttribute]
public string ClientSourceType { get; public set; }
    [JsonPropertyAttribute]
public int GroupPolicyTelemetryLevel { get; public set; }
    [JsonPropertyAttribute]
public int CurrentPolicyTelemetryLevel { get; public set; }
    [JsonPropertyAttribute]
public int LimitDumpCollection { get; public set; }
    [JsonPropertyAttribute]
public long MspFlags { get; public set; }
    [CompilerGeneratedAttribute]
public string get_MachineId();
    [CompilerGeneratedAttribute]
public void set_MachineId(string value);
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(string value);
    [CompilerGeneratedAttribute]
public string get_VsoId();
    [CompilerGeneratedAttribute]
public void set_VsoId(string value);
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_VsSku();
    [CompilerGeneratedAttribute]
public void set_VsSku(string value);
    [CompilerGeneratedAttribute]
public int get_NotificationsCount();
    [CompilerGeneratedAttribute]
public void set_NotificationsCount(int value);
    [CompilerGeneratedAttribute]
public string get_AppIdPackage();
    [CompilerGeneratedAttribute]
public void set_AppIdPackage(string value);
    [CompilerGeneratedAttribute]
public string get_MacAddressHash();
    [CompilerGeneratedAttribute]
public void set_MacAddressHash(string value);
    [CompilerGeneratedAttribute]
public string get_ChannelId();
    [CompilerGeneratedAttribute]
public void set_ChannelId(string value);
    [CompilerGeneratedAttribute]
public string get_ChannelManifestId();
    [CompilerGeneratedAttribute]
public void set_ChannelManifestId(string value);
    [CompilerGeneratedAttribute]
public string get_ManifestId();
    [CompilerGeneratedAttribute]
public void set_ManifestId(string value);
    [CompilerGeneratedAttribute]
public string get_OsType();
    [CompilerGeneratedAttribute]
public void set_OsType(string value);
    [CompilerGeneratedAttribute]
public string get_OsVersion();
    [CompilerGeneratedAttribute]
public void set_OsVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ExeName();
    [CompilerGeneratedAttribute]
public void set_ExeName(string value);
    [CompilerGeneratedAttribute]
public int get_IsInternal();
    [CompilerGeneratedAttribute]
public void set_IsInternal(int value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_CachedRuleIds();
    [CompilerGeneratedAttribute]
public void set_CachedRuleIds(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(string value);
    [CompilerGeneratedAttribute]
public string get_SessionRole();
    [CompilerGeneratedAttribute]
public void set_SessionRole(string value);
    [CompilerGeneratedAttribute]
public string get_ClrVersion();
    [CompilerGeneratedAttribute]
public void set_ClrVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ProcessArchitecture();
    [CompilerGeneratedAttribute]
public void set_ProcessArchitecture(string value);
    [CompilerGeneratedAttribute]
public string get_ClientSourceType();
    [CompilerGeneratedAttribute]
public void set_ClientSourceType(string value);
    [CompilerGeneratedAttribute]
public int get_GroupPolicyTelemetryLevel();
    [CompilerGeneratedAttribute]
public void set_GroupPolicyTelemetryLevel(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentPolicyTelemetryLevel();
    [CompilerGeneratedAttribute]
public void set_CurrentPolicyTelemetryLevel(int value);
    [CompilerGeneratedAttribute]
public int get_LimitDumpCollection();
    [CompilerGeneratedAttribute]
public void set_LimitDumpCollection(int value);
    [CompilerGeneratedAttribute]
public long get_MspFlags();
    [CompilerGeneratedAttribute]
public void set_MspFlags(long value);
}
internal class Microsoft.VisualStudio.RemoteSettings.ActionResponse : object {
    [CompilerGeneratedAttribute]
private string <ActionPath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FlightName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionJson>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TriggerJson>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MaxWaitTimeSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendAlways>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Categories>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Origin>k__BackingField;
    [JsonPropertyAttribute]
public string ActionPath { get; public set; }
    [JsonPropertyAttribute]
public int Precedence { get; public set; }
    [JsonPropertyAttribute]
public string RuleId { get; public set; }
    [JsonPropertyAttribute]
public string ActionType { get; public set; }
    [JsonPropertyAttribute]
public string FlightName { get; public set; }
    [JsonPropertyAttribute]
public string ActionJson { get; public set; }
    [JsonPropertyAttribute]
public string TriggerJson { get; public set; }
    [JsonPropertyAttribute]
public string MaxWaitTimeSpan { get; public set; }
    [JsonPropertyAttribute]
public bool SendAlways { get; public set; }
    [JsonPropertyAttribute]
public IList`1<string> Categories { get; public set; }
    [JsonPropertyAttribute]
public string Origin { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ActionPath();
    [CompilerGeneratedAttribute]
public void set_ActionPath(string value);
    [CompilerGeneratedAttribute]
public virtual int get_Precedence();
    [CompilerGeneratedAttribute]
public virtual void set_Precedence(int value);
    [CompilerGeneratedAttribute]
public virtual string get_RuleId();
    [CompilerGeneratedAttribute]
public virtual void set_RuleId(string value);
    [CompilerGeneratedAttribute]
public virtual string get_ActionType();
    [CompilerGeneratedAttribute]
public virtual void set_ActionType(string value);
    [CompilerGeneratedAttribute]
public virtual string get_FlightName();
    [CompilerGeneratedAttribute]
public virtual void set_FlightName(string value);
    [CompilerGeneratedAttribute]
public virtual string get_ActionJson();
    [CompilerGeneratedAttribute]
public virtual void set_ActionJson(string value);
    [CompilerGeneratedAttribute]
public virtual string get_TriggerJson();
    [CompilerGeneratedAttribute]
public virtual void set_TriggerJson(string value);
    [CompilerGeneratedAttribute]
public virtual string get_MaxWaitTimeSpan();
    [CompilerGeneratedAttribute]
public virtual void set_MaxWaitTimeSpan(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_SendAlways();
    [CompilerGeneratedAttribute]
public virtual void set_SendAlways(bool value);
    [CompilerGeneratedAttribute]
public virtual IList`1<string> get_Categories();
    [CompilerGeneratedAttribute]
public virtual void set_Categories(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(string value);
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.RemoteSettings.ActionResponseBag : object {
    [CompilerGeneratedAttribute]
private string <ProductName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ActionResponse> <Actions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ActionCategory> <Categories>k__BackingField;
    [JsonPropertyAttribute]
public string ProductName { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<ActionResponse> Actions { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<ActionCategory> Categories { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProductName();
    [CompilerGeneratedAttribute]
public void set_ProductName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ActionResponse> get_Actions();
    [CompilerGeneratedAttribute]
public void set_Actions(IEnumerable`1<ActionResponse> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ActionCategory> get_Categories();
    [CompilerGeneratedAttribute]
public void set_Categories(IEnumerable`1<ActionCategory> value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.RemoteSettings.ActionResponseEx : object {
    private static Lazy`1<JsonConverter[]> matchConvertersLazy;
    private static ActionResponseEx();
    [ExtensionAttribute]
public static ActionWrapper`1<T> AsTypedAction(ActionResponse actionResponse);
    [ExtensionAttribute]
public static Dictionary`2<string, ITelemetryEventMatch> GetTriggers(ActionResponse actionResponse);
    [ExtensionAttribute]
public static Dictionary`2<string, ActionTriggerOptions> GetTriggerOptions(ActionResponse actionResponse);
}
public class Microsoft.VisualStudio.RemoteSettings.ActionSubscriptionDetails : object {
    public static string StartTrigger;
    public static string StopTrigger;
    [CompilerGeneratedAttribute]
private bool <TriggerAlways>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TriggerOnSubscribe>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryEvent <TelemetryEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <RegisteredTriggerNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TriggerName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, int> <TriggerSubscriptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryNotificationService <NotificationService>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TriggerLockObject>k__BackingField;
    public bool TriggerAlways { get; internal set; }
    public bool TriggerOnSubscribe { get; internal set; }
    public TelemetryEvent TelemetryEvent { get; internal set; }
    public IEnumerable`1<string> RegisteredTriggerNames { get; internal set; }
    public string TriggerName { get; internal set; }
    internal IDictionary`2<string, int> TriggerSubscriptions { get; internal set; }
    internal ITelemetryNotificationService NotificationService { get; internal set; }
    internal object TriggerLockObject { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_TriggerAlways();
    [CompilerGeneratedAttribute]
internal void set_TriggerAlways(bool value);
    [CompilerGeneratedAttribute]
public bool get_TriggerOnSubscribe();
    [CompilerGeneratedAttribute]
internal void set_TriggerOnSubscribe(bool value);
    [CompilerGeneratedAttribute]
public TelemetryEvent get_TelemetryEvent();
    [CompilerGeneratedAttribute]
internal void set_TelemetryEvent(TelemetryEvent value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_RegisteredTriggerNames();
    [CompilerGeneratedAttribute]
internal void set_RegisteredTriggerNames(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_TriggerName();
    [CompilerGeneratedAttribute]
internal void set_TriggerName(string value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, int> get_TriggerSubscriptions();
    [CompilerGeneratedAttribute]
internal void set_TriggerSubscriptions(IDictionary`2<string, int> value);
    [CompilerGeneratedAttribute]
internal ITelemetryNotificationService get_NotificationService();
    [CompilerGeneratedAttribute]
internal void set_NotificationService(ITelemetryNotificationService value);
    [CompilerGeneratedAttribute]
internal object get_TriggerLockObject();
    [CompilerGeneratedAttribute]
internal void set_TriggerLockObject(object value);
    public void Unsubscribe();
    public void UnsubscribeAll();
}
internal class Microsoft.VisualStudio.RemoteSettings.ActionTriggerOptions : object {
    [CompilerGeneratedAttribute]
private bool <TriggerOnSubscribe>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TriggerAlways>k__BackingField;
    [JsonPropertyAttribute]
public bool TriggerOnSubscribe { get; public set; }
    [JsonPropertyAttribute]
public bool TriggerAlways { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_TriggerOnSubscribe();
    [CompilerGeneratedAttribute]
public void set_TriggerOnSubscribe(bool value);
    [CompilerGeneratedAttribute]
public bool get_TriggerAlways();
    [CompilerGeneratedAttribute]
public void set_TriggerAlways(bool value);
}
public class Microsoft.VisualStudio.RemoteSettings.ActionWrapper`1 : object {
    [CompilerGeneratedAttribute]
private string <ActionPath>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FlightName>k__BackingField;
    [CompilerGeneratedAttribute]
private ActionSubscriptionDetails <Subscription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionJson>k__BackingField;
    public string ActionPath { get; internal set; }
    public T Action { get; internal set; }
    public int Precedence { get; internal set; }
    public string RuleId { get; internal set; }
    public string ActionType { get; internal set; }
    public string FlightName { get; internal set; }
    public ActionSubscriptionDetails Subscription { get; internal set; }
    internal string ActionJson { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_ActionPath();
    [CompilerGeneratedAttribute]
internal void set_ActionPath(string value);
    [CompilerGeneratedAttribute]
public T get_Action();
    [CompilerGeneratedAttribute]
internal void set_Action(T value);
    [CompilerGeneratedAttribute]
public int get_Precedence();
    [CompilerGeneratedAttribute]
internal void set_Precedence(int value);
    [CompilerGeneratedAttribute]
public string get_RuleId();
    [CompilerGeneratedAttribute]
internal void set_RuleId(string value);
    [CompilerGeneratedAttribute]
public string get_ActionType();
    [CompilerGeneratedAttribute]
internal void set_ActionType(string value);
    [CompilerGeneratedAttribute]
public string get_FlightName();
    [CompilerGeneratedAttribute]
internal void set_FlightName(string value);
    [CompilerGeneratedAttribute]
public ActionSubscriptionDetails get_Subscription();
    [CompilerGeneratedAttribute]
internal void set_Subscription(ActionSubscriptionDetails value);
    [CompilerGeneratedAttribute]
internal string get_ActionJson();
    [CompilerGeneratedAttribute]
internal void set_ActionJson(string value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.RemoteSettings.ActionWrapperEx : object {
    [ExtensionAttribute]
public static ActionWrapper`1<T> WithSubscriptionDetails(ActionWrapper`1<T> baseAction, ActionSubscriptionDetails details);
}
internal class Microsoft.VisualStudio.RemoteSettings.AsyncScopeParser : object {
    private string expression;
    private Stack`1<AsyncOperand> output;
    private Stack`1<Operator> operators;
    private IDictionary`2<string, IScopeFilterProvider> providedFilters;
    private Regex stringRegex;
    private int expressionIndex;
    internal AsyncScopeParser(string expression, IDictionary`2<string, IScopeFilterProvider> providedFilters);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.AsyncScopeParser/<RunAsync>d__14")]
public Task`1<bool> RunAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.AsyncScopeParser/<ParseOperatorAsync>d__15")]
private Task ParseOperatorAsync(Operator op);
    private void ParseOperand(AsyncOperand op);
    private Operator ScanOperator();
    private AsyncOperand ScanOperand();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.AsyncScopeParser/<EvaluateOutputAsync>d__19")]
private Task EvaluateOutputAsync();
    private string GetRestOfExpression();
    private static LazyOperand CastAppropiateSingle(IScopeFilterProvider provider);
    private static LazyOperand CastAppropiateMulti(IScopeFilterProvider provider, string subkey);
}
public class Microsoft.VisualStudio.RemoteSettings.BoolScopeValue : ScopeValue {
    private bool value;
    public BoolScopeValue(bool value);
    internal virtual AsyncOperand GetAsyncOperand();
    internal virtual Operand GetOperand();
}
internal class Microsoft.VisualStudio.RemoteSettings.CachedActionCategoryTime : object {
    [CompilerGeneratedAttribute]
private DateTime <LastSent>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <WaitTimeSpan>k__BackingField;
    public DateTime LastSent { get; public set; }
    public TimeSpan WaitTimeSpan { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_LastSent();
    [CompilerGeneratedAttribute]
public void set_LastSent(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_WaitTimeSpan();
    [CompilerGeneratedAttribute]
public void set_WaitTimeSpan(TimeSpan value);
}
internal class Microsoft.VisualStudio.RemoteSettings.CachedActionResponseTime : object {
    [CompilerGeneratedAttribute]
private DateTime <CachedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxWaitTimeSpan>k__BackingField;
    public DateTime CachedTime { get; public set; }
    public TimeSpan MaxWaitTimeSpan { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_CachedTime();
    [CompilerGeneratedAttribute]
public void set_CachedTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxWaitTimeSpan();
    [CompilerGeneratedAttribute]
public void set_MaxWaitTimeSpan(TimeSpan value);
}
internal class Microsoft.VisualStudio.RemoteSettings.CachedTargetedNotifications : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, CachedActionCategoryTime> <Categories>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, CachedActionResponseTime> <Actions>k__BackingField;
    public IDictionary`2<string, CachedActionCategoryTime> Categories { get; public set; }
    public IDictionary`2<string, CachedActionResponseTime> Actions { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, CachedActionCategoryTime> get_Categories();
    [CompilerGeneratedAttribute]
public void set_Categories(IDictionary`2<string, CachedActionCategoryTime> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, CachedActionResponseTime> get_Actions();
    [CompilerGeneratedAttribute]
public void set_Actions(IDictionary`2<string, CachedActionResponseTime> value);
}
internal class Microsoft.VisualStudio.RemoteSettings.CycleDetection : object {
    private static Regex scopeRegex;
    private static CycleDetection();
    public sealed virtual bool HasCycles(IEnumerable`1<Scope> scopes);
    internal static MatchCollection GetScopeMatches(string scopeString);
}
public class Microsoft.VisualStudio.RemoteSettings.DefaultRemoteSettingsFilterProvider : RemoteSettingsFilterProvider {
    private TelemetrySession session;
    private IProcessInformationProvider processInformationProvider;
    private IOSInformationProvider osInformationProvider;
    private Lazy`1<string> partnerId;
    private Lazy`1<TelemetryPolicyLevels> telemetryLevels;
    public DefaultRemoteSettingsFilterProvider(TelemetrySession telemetrySession);
    internal DefaultRemoteSettingsFilterProvider(TelemetrySession telemetrySession, IProcessInformationProvider processInformationProvider, IOSInformationProvider osInformationProvider);
    public virtual Guid GetMachineId();
    public virtual Guid GetUserId();
    public virtual string GetCulture();
    public virtual string GetApplicationName();
    public virtual string GetApplicationVersion();
    public virtual string GetMacAddressHash();
    public virtual string GetOsType();
    public virtual string GetOsVersion();
    public virtual bool GetIsUserInternal();
    public virtual string GetSessionRole();
    public virtual string GetClrVersion();
    public virtual string GetProcessArchitecture();
    public virtual string GetClientSourceType();
    private string InitializePartnerId();
    public virtual int GetGroupPolicy();
    public virtual int GetCurrentPolicy();
    public virtual int GetLimitDumpCollection();
    public virtual long GetMSPFlags();
    private static TelemetryPolicyLevels InitializeTelemetryPolicyLevels();
    [CompilerGeneratedAttribute]
private string <.ctor>b__6_0();
}
internal class Microsoft.VisualStudio.RemoteSettings.DefaultRemoteSettingsTelemetry : object {
    private TelemetrySession telemetrySession;
    public DefaultRemoteSettingsTelemetry(TelemetrySession telemetrySession);
    public sealed virtual IRemoteSettingsTelemetryActivity CreateActivity(string name);
    public sealed virtual void PostEvent(string name, IDictionary`2<string, object> properties);
}
internal class Microsoft.VisualStudio.RemoteSettings.DefaultTargetedNotificationsTelemetry : object {
    private TelemetrySession telemetrySession;
    public string SessionId { get; }
    public DefaultTargetedNotificationsTelemetry(TelemetrySession telemetrySession);
    public sealed virtual string get_SessionId();
    public sealed virtual void PostCriticalFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
    public sealed virtual void PostDiagnosticFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
    public sealed virtual void PostGeneralFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
    public sealed virtual void PostSuccessfulOperation(string eventName, Dictionary`2<string, object> additionalProperties);
    private void PostEventInternal(TelemetryEvent telemetryEvent, Dictionary`2<string, object> additionalProperties);
}
internal class Microsoft.VisualStudio.RemoteSettings.DeserializedRemoteSettings : object {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Scope> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<RemoteSetting> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public ReadOnlyCollection`1<Scope> Scopes { get; }
    public ReadOnlyCollection`1<RemoteSetting> Settings { get; }
    public string Error { get; }
    public bool Successful { get; }
    public DeserializedRemoteSettings(ReadOnlyCollection`1<Scope> scopes, ReadOnlyCollection`1<RemoteSetting> settings, string error);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Scope> get_Scopes();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<RemoteSetting> get_Settings();
    [CompilerGeneratedAttribute]
public string get_Error();
    public bool get_Successful();
}
internal class Microsoft.VisualStudio.RemoteSettings.DirectoryReader : object {
    private string path;
    private string directoryName;
    private bool markProcessed;
    private IRemoteSettingsLogger logger;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public int Priority { get; private set; }
    public DirectoryReader(string rootPath, string directoryName, bool markProcessed, int priority, IRemoteSettingsLogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
private void set_Priority(int value);
    public sealed virtual IEnumerable`1<DirectoryReaderContext> ReadAllFiles();
}
internal class Microsoft.VisualStudio.RemoteSettings.DirectoryReaderContext : object {
    [CompilerGeneratedAttribute]
private string <DirectoryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public string DirectoryName { get; public set; }
    public string FileName { get; public set; }
    public Stream Stream { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DirectoryName();
    [CompilerGeneratedAttribute]
public void set_DirectoryName(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(Stream value);
}
public class Microsoft.VisualStudio.RemoteSettings.DoubleScopeValue : ScopeValue {
    private double value;
    public DoubleScopeValue(double value);
    internal virtual AsyncOperand GetAsyncOperand();
    internal virtual Operand GetOperand();
}
internal class Microsoft.VisualStudio.RemoteSettings.ExeNameScopeFilterProvider : object {
    private Lazy`1<StringScopeValue> exeName;
    public string Name { get; }
    public ExeNameScopeFilterProvider(RemoteSettingsFilterProvider filterProvider);
    public sealed virtual string get_Name();
    public sealed virtual StringScopeValue Provide();
}
internal class Microsoft.VisualStudio.RemoteSettings.FileActionResponse : ActionResponse {
    [CompilerGeneratedAttribute]
private int <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FlightName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionJson>k__BackingField;
    [JsonPropertyAttribute]
public int Precedence { get; public set; }
    [JsonPropertyAttribute]
public string FlightName { get; public set; }
    [JsonPropertyAttribute]
public string RuleId { get; public set; }
    [JsonPropertyAttribute]
public string ActionType { get; public set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("Microsoft.VisualStudio.RemoteSettings.TestActionJsonConverter")]
public string ActionJson { get; public set; }
    [CompilerGeneratedAttribute]
public virtual int get_Precedence();
    [CompilerGeneratedAttribute]
public virtual void set_Precedence(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FlightName();
    [CompilerGeneratedAttribute]
public virtual void set_FlightName(string value);
    [CompilerGeneratedAttribute]
public virtual string get_RuleId();
    [CompilerGeneratedAttribute]
public virtual void set_RuleId(string value);
    [CompilerGeneratedAttribute]
public virtual string get_ActionType();
    [CompilerGeneratedAttribute]
public virtual void set_ActionType(string value);
    [CompilerGeneratedAttribute]
public virtual string get_ActionJson();
    [CompilerGeneratedAttribute]
public virtual void set_ActionJson(string value);
    [OnDeserializedAttribute]
internal void OnDeserializedMethod(StreamingContext context);
}
internal class Microsoft.VisualStudio.RemoteSettings.FlightScopeFilterProvider : object {
    private IExperimentationService experimentationService;
    public string Name { get; }
    public FlightScopeFilterProvider(IExperimentationService experimentationService);
    public sealed virtual string get_Name();
    public sealed virtual BoolScopeValue Provide(string key);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.FlightScopeFilterProvider/<ProvideAsync>d__5")]
public sealed virtual Task`1<BoolScopeValue> ProvideAsync(string key);
}
internal class Microsoft.VisualStudio.RemoteSettings.GroupedRemoteSettings : Dictionary`2<string, RemoteSettingPossibilities> {
    public GroupedRemoteSettings(DeserializedRemoteSettings deserializedRemoteSettings, string origin);
    public void Merge(GroupedRemoteSettings buckets, IRemoteSettingsLogger logger);
}
public interface Microsoft.VisualStudio.RemoteSettings.ICollectionKeyValueStorage {
    public abstract virtual T GetValue(string collectionPath, string key, T defaultValue);
    public abstract virtual bool TryGetValue(string collectionPath, string key, T& value);
    public abstract virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public abstract virtual void SetValue(string collectionPath, string key, T value);
    public abstract virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public abstract virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public abstract virtual bool CollectionExists(string collectionPath);
    public abstract virtual bool PropertyExists(string collectionPath, string propertyName);
    public abstract virtual bool DeleteCollection(string collectionPath);
    public abstract virtual bool DeleteProperty(string collectionPath, string propertyName);
}
internal interface Microsoft.VisualStudio.RemoteSettings.ICycleDetection {
    public abstract virtual bool HasCycles(IEnumerable`1<Scope> scopes);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IDirectoryReader {
    public int Priority { get; }
    public abstract virtual IEnumerable`1<DirectoryReaderContext> ReadAllFiles();
    public abstract virtual int get_Priority();
}
internal interface Microsoft.VisualStudio.RemoteSettings.ILocalTestParser {
    public abstract virtual Task`1<IEnumerable`1<ActionResponse>> ParseStreamAsync(DirectoryReaderContext streamContext);
}
public interface Microsoft.VisualStudio.RemoteSettings.IMultiValueScopeFilterAsyncProvider`1 {
    public abstract virtual Task`1<T> ProvideAsync(string key);
}
public interface Microsoft.VisualStudio.RemoteSettings.IMultiValueScopeFilterProvider`1 {
    public abstract virtual T Provide(string key);
}
internal class Microsoft.VisualStudio.RemoteSettings.InternalScopeFilterProvider : object {
    private TelemetrySession telemetrySession;
    public string Name { get; }
    public InternalScopeFilterProvider(TelemetrySession telemetrySession);
    public sealed virtual string get_Name();
    public sealed virtual BoolScopeValue Provide();
}
public interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettings {
    [CompilerGeneratedAttribute]
public abstract virtual void add_SettingsUpdated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SettingsUpdated(EventHandler value);
    public abstract virtual T GetValue(string collectionPath, string key, T defaultValue);
    public abstract virtual bool TryGetValue(string collectionPath, string key, T& value);
    public abstract virtual Task`1<T> GetValueAsync(string collectionPath, string key, T defaultValue);
    public abstract virtual ValueKind GetValueKind(string collectionPath, string key);
    public abstract virtual Task`1<IEnumerable`1<ActionWrapper`1<T>>> GetActionsAsync(string actionPath);
    public abstract virtual void Start();
    public abstract virtual IRemoteSettings RegisterFilterProvider(IScopeFilterProvider scopeFilterProvider);
    public abstract virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public abstract virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public abstract virtual bool CollectionExists(string collectionPath);
    public abstract virtual bool PropertyExists(string collectionPath, string key);
}
public interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettings2 {
    public abstract virtual void SubscribeActions(string actionPath, Action`1<ActionWrapper`1<T>> callback);
    public abstract virtual void UnsubscribeActions(string actionPath);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsLogger {
    public bool LoggingEnabled { get; }
    public abstract virtual bool get_LoggingEnabled();
    public abstract virtual Task StartAsync();
    public abstract virtual void LogVerbose(string message);
    public abstract virtual void LogVerbose(string message, object data);
    public abstract virtual void LogInfo(string message);
    public abstract virtual void LogError(string message);
    public abstract virtual void LogError(string message, Exception exception);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsParser {
    public abstract virtual VersionedDeserializedRemoteSettings TryParseVersionedStream(Stream stream);
    public abstract virtual DeserializedRemoteSettings TryParseFromJObject(JObject json, string globalScope);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsProvider {
    public string Name { get; }
    public abstract virtual bool TryGetValue(string collectionPath, string key, T& value);
    public abstract virtual string get_Name();
    public abstract virtual Task`1<GroupedRemoteSettings> StartAsync();
    public abstract virtual Task`1<IEnumerable`1<ActionWrapper`1<T>>> GetActionsAsync(string actionPath);
    public abstract virtual Task SubscribeActionsAsync(string actionPath, Action`1<ActionWrapper`1<T>> callback);
    public abstract virtual void UnsubscribeActions(string actionPath);
    public abstract virtual Task`1<RemoteSettingsProviderResult`1<T>> TryGetValueAsync(string collectionPath, string key);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsStorageHandler {
    public abstract virtual Task`1<RemoteSettingsProviderResult`1<T>> TryGetValueAsync(string collectionPath, string key);
    public abstract virtual bool TryGetValue(string collectionPath, string key, T& value);
    public abstract virtual void SaveSettings(GroupedRemoteSettings remoteSettings);
    public abstract virtual void SaveNonScopedSetting(RemoteSetting setting);
    public abstract virtual void SaveNonScopedSettings(GroupedRemoteSettings groupedSettings);
    public abstract virtual void DeleteAllSettings();
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsStorageHandlerFactory {
    public abstract virtual IVersionedRemoteSettingsStorageHandler BuildVersioned(ICollectionKeyValueStorage storage, bool usePrefix, string fileName, IScopeParserFactory scopeParserFactory);
    public abstract virtual IRemoteSettingsStorageHandler Build(ICollectionKeyValueStorage storage, bool usePrefix, RemoteSettingsFilterProvider filterProvider, IScopeParserFactory scopeParserFactory);
    public abstract virtual IRemoteSettingsStorageHandler Build(ICollectionKeyValueStorage storage, bool usePrefix, string collectionPath, IScopeParserFactory scopeParserFactory);
}
public interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsTelemetry {
    public abstract virtual void PostEvent(string name, IDictionary`2<string, object> properties);
    public abstract virtual IRemoteSettingsTelemetryActivity CreateActivity(string name);
}
public interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsTelemetryActivity {
    public abstract virtual void Start();
    public abstract virtual void End();
    public abstract virtual void Post(IDictionary`2<string, object> properties);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IRemoteSettingsValidator {
    public abstract virtual void ValidateDeserialized(DeserializedRemoteSettings remoteSettings);
    public abstract virtual void ValidateStored();
}
public interface Microsoft.VisualStudio.RemoteSettings.IScopeFilterProvider {
    public string Name { get; }
    public abstract virtual string get_Name();
}
internal interface Microsoft.VisualStudio.RemoteSettings.IScopeParserFactory {
    public IDictionary`2<string, IScopeFilterProvider> ProvidedFilters { get; }
    public abstract virtual IDictionary`2<string, IScopeFilterProvider> get_ProvidedFilters();
    public abstract virtual bool Evaluate(string scopeExpression);
    public abstract virtual Task`1<bool> EvaluateAsync(string scopeExpression);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IScopesStorageHandler {
    public abstract virtual IEnumerable`1<string> GetAllScopes();
    public abstract virtual string GetScope(string scopeName);
}
internal interface Microsoft.VisualStudio.RemoteSettings.ISettingsCollection {
    public abstract virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public abstract virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public abstract virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public abstract virtual bool CollectionExists(string collectionPath);
    public abstract virtual bool PropertyExists(string collectionPath, string propertyName);
}
public interface Microsoft.VisualStudio.RemoteSettings.ISingleValueScopeFilterAsyncProvider`1 {
    public abstract virtual Task`1<T> ProvideAsync();
}
public interface Microsoft.VisualStudio.RemoteSettings.ISingleValueScopeFilterProvider`1 {
    public abstract virtual T Provide();
}
internal interface Microsoft.VisualStudio.RemoteSettings.IStableRemoteSettingsProvider {
    public abstract virtual bool IsStable(string collectionPath);
    public abstract virtual void MakeStable(string collectionPath, string key, T value);
}
internal interface Microsoft.VisualStudio.RemoteSettings.ITargetedNotificationsCacheStorageProvider {
    public abstract virtual CachedTargetedNotifications GetLocalCacheCopy();
    public abstract virtual void SetLocalCache(CachedTargetedNotifications newCache);
    public abstract virtual bool Lock(Nullable`1<int> timeoutMs);
    public abstract virtual void Unlock();
    public abstract virtual void Reset();
}
internal interface Microsoft.VisualStudio.RemoteSettings.ITargetedNotificationsParser {
    public abstract virtual Task`1<ActionResponseBag> ParseStreamAsync(Stream stream, CancellationToken cancellationToken);
}
internal interface Microsoft.VisualStudio.RemoteSettings.ITargetedNotificationsTelemetry {
    public string SessionId { get; }
    public abstract virtual string get_SessionId();
    public abstract virtual void PostSuccessfulOperation(string eventName, Dictionary`2<string, object> additionalProperties);
    public abstract virtual void PostDiagnosticFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
    public abstract virtual void PostGeneralFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
    public abstract virtual void PostCriticalFault(string eventName, string description, Exception exception, Dictionary`2<string, object> additionalProperties);
}
internal interface Microsoft.VisualStudio.RemoteSettings.IVersionedRemoteSettingsStorageHandler {
    public string FileVersion { get; }
    public abstract virtual string get_FileVersion();
    public abstract virtual void DeleteSettingsForFileVersion(string fileVersion);
    public abstract virtual bool DoSettingsNeedToBeUpdated(string newFileVersion);
    public abstract virtual void SaveSettings(VersionedDeserializedRemoteSettings remoteSettings);
    public abstract virtual void InvalidateFileVersion();
    public abstract virtual void CleanUpOldFileVersions(string newFileVersion);
}
internal class Microsoft.VisualStudio.RemoteSettings.LocalTestParser : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.LocalTestParser/<ParseStreamAsync>d__0")]
public sealed virtual Task`1<IEnumerable`1<ActionResponse>> ParseStreamAsync(DirectoryReaderContext streamContext);
}
internal class Microsoft.VisualStudio.RemoteSettings.LocalTestProvider : TargetedNotificationsProviderBase {
    private IEnumerable`1<IDirectoryReader> directories;
    private ILocalTestParser localTestParser;
    public string Name { get; }
    public LocalTestProvider(RemoteSettingsInitializer initializer);
    public virtual string get_Name();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.LocalTestProvider/<GetTargetedNotificationActionsAsync>d__5")]
protected virtual Task`1<ActionResponseBag> GetTargetedNotificationActionsAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.LocalTestProvider/<<GetTargetedNotificationActionsAsync>b__5_1>d")]
[CompilerGeneratedAttribute]
private Task`1<IEnumerable`1<ActionResponse>> <GetTargetedNotificationActionsAsync>b__5_1(DirectoryReaderContext x);
}
internal class Microsoft.VisualStudio.RemoteSettings.LoggingContext`1 : object {
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public string Context { get; public set; }
    public T Value { get; public set; }
    public LoggingContext`1(string context, T value);
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(string value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
internal class Microsoft.VisualStudio.RemoteSettings.MemoryKeyValueStorage : object {
    private Dictionary`2<string, KeyValueCollection> collections;
    public sealed virtual bool CollectionExists(string collectionPath);
    public sealed virtual bool PropertyExists(string collectionPath, string key);
    public sealed virtual bool DeleteCollection(string collectionPath);
    public sealed virtual bool DeleteProperty(string collectionPath, string propertyName);
    public sealed virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public sealed virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public sealed virtual T GetValue(string collectionPath, string key, T defaultValue);
    public sealed virtual bool TryGetValue(string collectionPath, string key, T& value);
    public sealed virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public sealed virtual void SetValue(string collectionPath, string key, T value);
    private void AddToParentCollections(string collectionPath);
    private bool TryGetValueInternal(string collectionPath, string key, T defaultValue, T& value);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteControlRemoteSettingsProvider : RemoteSettingsProviderBase {
    private static int DisposingIsStarted;
    private static int DisposingNotStarted;
    private static string RemoteSettingsTelemetryEventPath;
    private static string RemoteSettingsTelemetryPropertyPath;
    private IVersionedRemoteSettingsStorageHandler remoteSettingsStorageHandler;
    private IRemoteSettingsTelemetry remoteSettingsTelemetry;
    private Lazy`1<IRemoteFileReader> remoteFileReader;
    private IRemoteSettingsParser remoteSettingsParser;
    private IScopeParserFactory scopeParserFactory;
    private IRemoteSettingsValidator remoteSettingsValidator;
    private string fileName;
    private int startedDisposing;
    private CancellationTokenSource cancellationTokenSource;
    public string Name { get; }
    public RemoteControlRemoteSettingsProvider(RemoteSettingsInitializer initializer);
    public virtual string get_Name();
    public virtual Task`1<GroupedRemoteSettings> StartAsync();
    protected virtual void DisposeManagedResources();
    private void ProcessRemoteSettingsFile(VersionedDeserializedRemoteSettings remoteSettings);
    private void ValidateStoredRemoteSettings();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteControlRemoteSettingsProvider/<<StartAsync>b__16_0>d")]
[CompilerGeneratedAttribute]
private Task`1<GroupedRemoteSettings> <StartAsync>b__16_0();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSetting : object {
    public static char Separator;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScopeString>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Origin>k__BackingField;
    public string Path { get; }
    public string Name { get; }
    public string ScopeString { get; public set; }
    public object Value { get; }
    public string Origin { get; public set; }
    public bool HasScope { get; }
    public RemoteSetting(string path, string name, object value, string scopeString);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_ScopeString();
    [CompilerGeneratedAttribute]
public void set_ScopeString(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public string get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(string value);
    public bool get_HasScope();
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingPossibilities : Dictionary`2<string, List`1<RemoteSetting>> {
}
public class Microsoft.VisualStudio.RemoteSettings.RemoteSettings : TelemetryDisposableObject {
    private static Lazy`1<RemoteSettings> defaultRemoteSettings;
    private IStableRemoteSettingsProvider stableRemoteSettingProvider;
    private List`1<IRemoteSettingsProvider> remoteSettingsProviders;
    private IScopeParserFactory scopeParserFactory;
    private IRemoteSettingsStorageHandler nonScopedStorageHandler;
    private Func`1<bool> isUpdateDisabled;
    private IRemoteSettingsLogger logger;
    private bool isStarted;
    internal Task StartTask;
    [CompilerGeneratedAttribute]
private EventHandler SettingsUpdated;
    internal IEnumerable`1<IRemoteSettingsProvider> AllRemoteSettingsProviders { get; }
    public static IRemoteSettings Default { get; }
    public RemoteSettings(RemoteSettingsInitializer initializer);
    private static RemoteSettings();
    [CompilerGeneratedAttribute]
public sealed virtual void add_SettingsUpdated(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SettingsUpdated(EventHandler value);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettings/<get_AllRemoteSettingsProviders>d__13")]
internal IEnumerable`1<IRemoteSettingsProvider> get_AllRemoteSettingsProviders();
    public static IRemoteSettings get_Default();
    public sealed virtual T GetValue(string collectionPath, string key, T defaultValue);
    public sealed virtual bool TryGetValue(string collectionPath, string key, T& value);
    public sealed virtual ValueKind GetValueKind(string collectionPath, string key);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettings/<GetValueAsync>d__20`1")]
public sealed virtual Task`1<T> GetValueAsync(string collectionPath, string key, T defaultValue);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettings/<GetActionsAsync>d__21`1")]
public sealed virtual Task`1<IEnumerable`1<ActionWrapper`1<T>>> GetActionsAsync(string actionPath);
    public sealed virtual void SubscribeActions(string actionPath, Action`1<ActionWrapper`1<T>> callback);
    public sealed virtual void UnsubscribeActions(string actionPath);
    public sealed virtual void Start();
    public sealed virtual IRemoteSettings RegisterFilterProvider(IScopeFilterProvider scopeFilterProvider);
    public sealed virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public sealed virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public sealed virtual bool CollectionExists(string collectionPath);
    public sealed virtual bool PropertyExists(string collectionPath, string key);
    protected virtual void DisposeManagedResources();
    private void RequiresStarted();
    private void OnRemoteSettingsApplied();
    [CompilerGeneratedAttribute]
private GroupedRemoteSettings <Start>b__24_2(GroupedRemoteSettings a, GroupedRemoteSettings b);
}
public abstract class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsFilterProvider : object {
    public virtual Guid GetMachineId();
    public virtual Guid GetUserId();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsFilterProvider/<GetVsIdAsync>d__2")]
public virtual Task`1<string> GetVsIdAsync();
    public virtual string GetCulture();
    public virtual string GetBranchBuildFrom();
    public virtual string GetApplicationName();
    public virtual string GetApplicationVersion();
    public virtual string GetVsSku();
    public virtual int GetNotificationsCount();
    public virtual Guid GetAppIdPackageGuid();
    public virtual string GetMacAddressHash();
    public virtual string GetChannelId();
    public virtual string GetChannelManifestId();
    public virtual string GetManifestId();
    public virtual string GetOsType();
    public virtual string GetOsVersion();
    public virtual bool GetIsUserInternal();
    public virtual string GetSessionRole();
    public virtual string GetClrVersion();
    public virtual string GetProcessArchitecture();
    public virtual string GetClientSourceType();
    public virtual int GetGroupPolicy();
    public virtual int GetCurrentPolicy();
    public virtual int GetLimitDumpCollection();
    public virtual long GetMSPFlags();
}
public class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsInitializer : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UsePathPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IScopeFilterProvider> <ScopeFilterProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteSettingsFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollectionKeyValueStorage <KeyValueStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private IExperimentationService <ExperimentationService>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryNotificationService <TelemetryNotificationService>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsTelemetry <Telemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private ITargetedNotificationsTelemetry <TargetedNotificationsTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private ITargetedNotificationsCacheStorageProvider <TargetedNotificationsCacheStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteSettingsFilterProvider <FilterProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollectionKeyValueStorage <NonScopedSettingsKeyValueStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <StableSettingRootSubCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private IScopeParserFactory <ScopeParserFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IVersionedRemoteSettingsStorageHandler <VersionedRemoteSettingsStorageHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsStorageHandler <CacheableRemoteSettingsStorageHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsStorageHandler <LocalTestRemoteSettingsStorageHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IDirectoryReader> <LocalTestDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IRemoteSettingsStorageHandler> <LiveRemoteSettingsStorageHandlerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsStorageHandler <NonScopedRemoteSettingsStorageHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteFileReaderFactory <RemoteFileReaderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsParser <RemoteSettingsParser>k__BackingField;
    [CompilerGeneratedAttribute]
private ITargetedNotificationsParser <TargetedNotificationsParser>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsValidator <RemoteSettingsValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Func`2<RemoteSettingsInitializer, IRemoteSettingsProvider>> <RemoteSettingsProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<RemoteSettingsInitializer, IStableRemoteSettingsProvider> <StableRemoteSettingsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpWebRequestFactory <HttpWebRequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<bool> <IsUpdatedDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private ILocalTestParser <LocalTestParser>k__BackingField;
    [CompilerGeneratedAttribute]
private IRemoteSettingsLogger <RemoteSettingsLogger>k__BackingField;
    public Nullable`1<bool> UsePathPrefix { get; public set; }
    public IEnumerable`1<IScopeFilterProvider> ScopeFilterProviders { get; public set; }
    public string RemoteSettingsFileName { get; public set; }
    public ICollectionKeyValueStorage KeyValueStorage { get; public set; }
    public IExperimentationService ExperimentationService { get; public set; }
    public ITelemetryNotificationService TelemetryNotificationService { get; public set; }
    public IRemoteSettingsTelemetry Telemetry { get; public set; }
    internal ITargetedNotificationsTelemetry TargetedNotificationsTelemetry { get; internal set; }
    internal ITargetedNotificationsCacheStorageProvider TargetedNotificationsCacheStorage { get; internal set; }
    public RemoteSettingsFilterProvider FilterProvider { get; public set; }
    public ICollectionKeyValueStorage NonScopedSettingsKeyValueStorage { get; public set; }
    public IEnumerable`1<string> StableSettingRootSubCollections { get; public set; }
    internal IScopeParserFactory ScopeParserFactory { get; internal set; }
    internal IVersionedRemoteSettingsStorageHandler VersionedRemoteSettingsStorageHandler { get; internal set; }
    internal IRemoteSettingsStorageHandler CacheableRemoteSettingsStorageHandler { get; internal set; }
    internal IRemoteSettingsStorageHandler LocalTestRemoteSettingsStorageHandler { get; internal set; }
    internal IEnumerable`1<IDirectoryReader> LocalTestDirectories { get; internal set; }
    internal Func`1<IRemoteSettingsStorageHandler> LiveRemoteSettingsStorageHandlerFactory { get; internal set; }
    internal IRemoteSettingsStorageHandler NonScopedRemoteSettingsStorageHandler { get; internal set; }
    internal IRemoteFileReaderFactory RemoteFileReaderFactory { get; internal set; }
    internal IRemoteSettingsParser RemoteSettingsParser { get; internal set; }
    internal ITargetedNotificationsParser TargetedNotificationsParser { get; internal set; }
    internal IRemoteSettingsValidator RemoteSettingsValidator { get; internal set; }
    internal IEnumerable`1<Func`2<RemoteSettingsInitializer, IRemoteSettingsProvider>> RemoteSettingsProviders { get; internal set; }
    internal Func`2<RemoteSettingsInitializer, IStableRemoteSettingsProvider> StableRemoteSettingsProvider { get; internal set; }
    internal IHttpWebRequestFactory HttpWebRequestFactory { get; internal set; }
    internal Func`1<bool> IsUpdatedDisabled { get; internal set; }
    internal ILocalTestParser LocalTestParser { get; internal set; }
    internal IRemoteSettingsLogger RemoteSettingsLogger { get; internal set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UsePathPrefix();
    [CompilerGeneratedAttribute]
public void set_UsePathPrefix(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IScopeFilterProvider> get_ScopeFilterProviders();
    [CompilerGeneratedAttribute]
public void set_ScopeFilterProviders(IEnumerable`1<IScopeFilterProvider> value);
    [CompilerGeneratedAttribute]
public string get_RemoteSettingsFileName();
    [CompilerGeneratedAttribute]
public void set_RemoteSettingsFileName(string value);
    [CompilerGeneratedAttribute]
public ICollectionKeyValueStorage get_KeyValueStorage();
    [CompilerGeneratedAttribute]
public void set_KeyValueStorage(ICollectionKeyValueStorage value);
    [CompilerGeneratedAttribute]
public IExperimentationService get_ExperimentationService();
    [CompilerGeneratedAttribute]
public void set_ExperimentationService(IExperimentationService value);
    [CompilerGeneratedAttribute]
public ITelemetryNotificationService get_TelemetryNotificationService();
    [CompilerGeneratedAttribute]
public void set_TelemetryNotificationService(ITelemetryNotificationService value);
    [CompilerGeneratedAttribute]
public IRemoteSettingsTelemetry get_Telemetry();
    [CompilerGeneratedAttribute]
public void set_Telemetry(IRemoteSettingsTelemetry value);
    [CompilerGeneratedAttribute]
internal ITargetedNotificationsTelemetry get_TargetedNotificationsTelemetry();
    [CompilerGeneratedAttribute]
internal void set_TargetedNotificationsTelemetry(ITargetedNotificationsTelemetry value);
    [CompilerGeneratedAttribute]
internal ITargetedNotificationsCacheStorageProvider get_TargetedNotificationsCacheStorage();
    [CompilerGeneratedAttribute]
internal void set_TargetedNotificationsCacheStorage(ITargetedNotificationsCacheStorageProvider value);
    [CompilerGeneratedAttribute]
public RemoteSettingsFilterProvider get_FilterProvider();
    [CompilerGeneratedAttribute]
public void set_FilterProvider(RemoteSettingsFilterProvider value);
    [CompilerGeneratedAttribute]
public ICollectionKeyValueStorage get_NonScopedSettingsKeyValueStorage();
    [CompilerGeneratedAttribute]
public void set_NonScopedSettingsKeyValueStorage(ICollectionKeyValueStorage value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_StableSettingRootSubCollections();
    [CompilerGeneratedAttribute]
public void set_StableSettingRootSubCollections(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
internal IScopeParserFactory get_ScopeParserFactory();
    [CompilerGeneratedAttribute]
internal void set_ScopeParserFactory(IScopeParserFactory value);
    internal static RemoteSettingsInitializer BuildDefault();
    internal RemoteSettingsInitializer FillWithDefaults();
    [CompilerGeneratedAttribute]
internal IVersionedRemoteSettingsStorageHandler get_VersionedRemoteSettingsStorageHandler();
    [CompilerGeneratedAttribute]
internal void set_VersionedRemoteSettingsStorageHandler(IVersionedRemoteSettingsStorageHandler value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsStorageHandler get_CacheableRemoteSettingsStorageHandler();
    [CompilerGeneratedAttribute]
internal void set_CacheableRemoteSettingsStorageHandler(IRemoteSettingsStorageHandler value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsStorageHandler get_LocalTestRemoteSettingsStorageHandler();
    [CompilerGeneratedAttribute]
internal void set_LocalTestRemoteSettingsStorageHandler(IRemoteSettingsStorageHandler value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<IDirectoryReader> get_LocalTestDirectories();
    [CompilerGeneratedAttribute]
internal void set_LocalTestDirectories(IEnumerable`1<IDirectoryReader> value);
    [CompilerGeneratedAttribute]
internal Func`1<IRemoteSettingsStorageHandler> get_LiveRemoteSettingsStorageHandlerFactory();
    [CompilerGeneratedAttribute]
internal void set_LiveRemoteSettingsStorageHandlerFactory(Func`1<IRemoteSettingsStorageHandler> value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsStorageHandler get_NonScopedRemoteSettingsStorageHandler();
    [CompilerGeneratedAttribute]
internal void set_NonScopedRemoteSettingsStorageHandler(IRemoteSettingsStorageHandler value);
    [CompilerGeneratedAttribute]
internal IRemoteFileReaderFactory get_RemoteFileReaderFactory();
    [CompilerGeneratedAttribute]
internal void set_RemoteFileReaderFactory(IRemoteFileReaderFactory value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsParser get_RemoteSettingsParser();
    [CompilerGeneratedAttribute]
internal void set_RemoteSettingsParser(IRemoteSettingsParser value);
    [CompilerGeneratedAttribute]
internal ITargetedNotificationsParser get_TargetedNotificationsParser();
    [CompilerGeneratedAttribute]
internal void set_TargetedNotificationsParser(ITargetedNotificationsParser value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsValidator get_RemoteSettingsValidator();
    [CompilerGeneratedAttribute]
internal void set_RemoteSettingsValidator(IRemoteSettingsValidator value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<Func`2<RemoteSettingsInitializer, IRemoteSettingsProvider>> get_RemoteSettingsProviders();
    [CompilerGeneratedAttribute]
internal void set_RemoteSettingsProviders(IEnumerable`1<Func`2<RemoteSettingsInitializer, IRemoteSettingsProvider>> value);
    [CompilerGeneratedAttribute]
internal Func`2<RemoteSettingsInitializer, IStableRemoteSettingsProvider> get_StableRemoteSettingsProvider();
    [CompilerGeneratedAttribute]
internal void set_StableRemoteSettingsProvider(Func`2<RemoteSettingsInitializer, IStableRemoteSettingsProvider> value);
    [CompilerGeneratedAttribute]
internal IHttpWebRequestFactory get_HttpWebRequestFactory();
    [CompilerGeneratedAttribute]
internal void set_HttpWebRequestFactory(IHttpWebRequestFactory value);
    [CompilerGeneratedAttribute]
internal Func`1<bool> get_IsUpdatedDisabled();
    [CompilerGeneratedAttribute]
internal void set_IsUpdatedDisabled(Func`1<bool> value);
    [CompilerGeneratedAttribute]
internal ILocalTestParser get_LocalTestParser();
    [CompilerGeneratedAttribute]
internal void set_LocalTestParser(ILocalTestParser value);
    [CompilerGeneratedAttribute]
internal IRemoteSettingsLogger get_RemoteSettingsLogger();
    [CompilerGeneratedAttribute]
internal void set_RemoteSettingsLogger(IRemoteSettingsLogger value);
    internal string GetLocalAppDataRoot();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsJsonLogFile : BaseJsonLogFile`1<RemoteSettingsLogMessage> {
    public RemoteSettingsJsonLogFile(ITelemetryWriter writer);
    protected virtual string ConvertEventToString(RemoteSettingsLogMessage eventData);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsLogger : TelemetryDisposableObject {
    private static string RemoteSettingsLogFolderName;
    private ITelemetryLogFile`1<RemoteSettingsLogMessage> logFile;
    private ITelemetryLogSettingsProvider settingsProvider;
    private RemoteSettingsFilterProvider filterProvider;
    private bool loggingEnabled;
    private Lazy`1<ConcurrentQueue`1<RemoteSettingsLogMessage>> buffer;
    private bool isStarted;
    private object flushLock;
    public bool LoggingEnabled { get; }
    private ConcurrentQueue`1<RemoteSettingsLogMessage> Buffer { get; }
    public RemoteSettingsLogger(RemoteSettingsFilterProvider remoteSettingsFilterProvider, bool loggingEnabled);
    public RemoteSettingsLogger(RemoteSettingsFilterProvider filterProvider, bool loggingEnabled, ITelemetryLogFile`1<RemoteSettingsLogMessage> logFile, ITelemetryLogSettingsProvider settingsProvider);
    public sealed virtual bool get_LoggingEnabled();
    private ConcurrentQueue`1<RemoteSettingsLogMessage> get_Buffer();
    public sealed virtual Task StartAsync();
    public sealed virtual void LogError(string message);
    public sealed virtual void LogError(string description, Exception exception);
    public sealed virtual void LogInfo(string message);
    public sealed virtual void LogVerbose(string message);
    public sealed virtual void LogVerbose(string message, object data);
    protected virtual void DisposeManagedResources();
    private void LogMessage(RemoteSettingsLogMessage message);
    private void LogMessageNoBuffer(RemoteSettingsLogMessage message);
    private void FlushBufferAndStart();
    [CompilerGeneratedAttribute]
private void <StartAsync>b__14_0();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsParser : object {
    internal static string FileVersionNotFirstPropertyErrorMessage;
    internal static string ChangesetIdNotSecondPropertyErrorMessage;
    internal static string TypeNotSupportedErrorMessageFormat;
    internal static string ScopesWasNotObjectErrorMessage;
    internal static string ScopeWasNotStringErrorMessage;
    internal static string InvalidJsonErrorMessage;
    internal static string UnhandledExceptionErrorMessageFormat;
    private IRemoteSettingsValidator remoteSettingsValidator;
    public RemoteSettingsParser(IRemoteSettingsValidator remoteSettingsValidator);
    private static RemoteSettingsParser();
    public sealed virtual VersionedDeserializedRemoteSettings TryParseVersionedStream(Stream stream);
    public sealed virtual DeserializedRemoteSettings TryParseFromJObject(JObject json, string globalScope);
    private DeserializedRemoteSettings ParseInternal(Queue`1<PropertyEntry> q, string globalScope);
    private static RemoteSetting ProcessRemoteSetting(string propertyPath, string propertyName, object value, string globalScope);
}
internal abstract class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsProviderBase : TelemetryDisposableObject {
    protected IRemoteSettingsStorageHandler currentStorageHandler;
    protected Task`1<GroupedRemoteSettings> startTask;
    protected IRemoteSettingsLogger logger;
    public string Name { get; }
    public RemoteSettingsProviderBase(IRemoteSettingsStorageHandler remoteSettingsStorageHandler, IRemoteSettingsLogger logger);
    public abstract virtual string get_Name();
    public sealed virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public sealed virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public sealed virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public sealed virtual bool CollectionExists(string collectionPath);
    public sealed virtual bool PropertyExists(string collectionPath, string propertyName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsProviderBase/<TryGetValueAsync>d__11`1")]
public sealed virtual Task`1<RemoteSettingsProviderResult`1<T>> TryGetValueAsync(string collectionPath, string key);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsProviderBase/<GetActionsAsync>d__12`1")]
public virtual Task`1<IEnumerable`1<ActionWrapper`1<T>>> GetActionsAsync(string actionPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsProviderBase/<SubscribeActionsAsync>d__13`1")]
public virtual Task SubscribeActionsAsync(string actionPath, Action`1<ActionWrapper`1<T>> callback);
    public virtual void UnsubscribeActions(string actionPath);
    public sealed virtual bool TryGetValue(string collectionPath, string key, T& value);
    public abstract virtual Task`1<GroupedRemoteSettings> StartAsync();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsProviderResult`1 : object {
    [CompilerGeneratedAttribute]
private bool <RetrievalSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public bool RetrievalSuccessful { get; public set; }
    public T Value { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_RetrievalSuccessful();
    [CompilerGeneratedAttribute]
public void set_RetrievalSuccessful(bool value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsRemoteFileReader : TelemetryDisposableObject {
    private IRemoteControlClient remoteControlClient;
    public RemoteSettingsRemoteFileReader(IRemoteControlClient remoteControlClient);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsRemoteFileReader/<ReadFileAsync>d__2")]
public sealed virtual Task`1<Stream> ReadFileAsync();
    protected virtual void DisposeManagedResources();
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsRemoteFileReaderFactory : object {
    private static TimeSpan DownloadInterval;
    private static string DefaultBaseUrl;
    private static string DefaultHostId;
    private static string DefaultPath;
    private string fileNameOverride;
    public RemoteSettingsRemoteFileReaderFactory(string fileNameOverride);
    private static RemoteSettingsRemoteFileReaderFactory();
    public sealed virtual IRemoteFileReader Instance();
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsStorageHandler : object {
    private static string PathSeparatorAsString;
    private ICollectionKeyValueStorage remoteSettingsStorage;
    private IScopeParserFactory scopeParserFactory;
    private IRemoteSettingsLogger logger;
    private bool isVersioned;
    private static string FileVersionKey;
    private static string SettingsVersionKey;
    private static string MultipleValueIndicator;
    internal static int SettingsVersion;
    internal string CollectionPathPrefix;
    private string currentCollectionPath;
    public string FileVersion { get; public set; }
    public int StoredSettingsVersion { get; public set; }
    private string CurrentCollectionPath { get; }
    public RemoteSettingsStorageHandler(ICollectionKeyValueStorage storage, string collectionPathPrefix, IScopeParserFactory scopeParserFactory, bool isVersioned, IRemoteSettingsLogger logger);
    private static RemoteSettingsStorageHandler();
    public sealed virtual string get_FileVersion();
    public void set_FileVersion(string value);
    public int get_StoredSettingsVersion();
    public void set_StoredSettingsVersion(int value);
    private string get_CurrentCollectionPath();
    public sealed virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public sealed virtual bool CollectionExists(string collectionPath);
    public sealed virtual bool PropertyExists(string collectionPath, string propertyName);
    public sealed virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsStorageHandler/<TryGetValueAsync>d__24`1")]
public sealed virtual Task`1<RemoteSettingsProviderResult`1<T>> TryGetValueAsync(string collectionPath, string key);
    public sealed virtual bool TryGetValue(string collectionPath, string key, T& value);
    public sealed virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public sealed virtual bool DoSettingsNeedToBeUpdated(string newFileVersion);
    public sealed virtual void DeleteSettingsForFileVersion(string fileVersion);
    public sealed virtual void SaveNonScopedSetting(RemoteSetting setting);
    public sealed virtual void SaveSettings(GroupedRemoteSettings remoteSettings);
    public sealed virtual void SaveNonScopedSettings(GroupedRemoteSettings groupedSettings);
    public sealed virtual void SaveSettings(VersionedDeserializedRemoteSettings remoteSettings);
    public sealed virtual void CleanUpOldFileVersions(string newFileVersion);
    public sealed virtual void DeleteAllSettings();
    public sealed virtual void InvalidateFileVersion();
    public sealed virtual IEnumerable`1<string> GetAllScopes();
    public sealed virtual string GetScope(string scopeName);
    private SingleSplitKeyOrCollection GetPossibleRemoteSettingKeys(string collectionPath, string key, string settingNameForLog);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.RemoteSettingsStorageHandler/<EvaluateScopedSettingAsync>d__39")]
private Task`1<bool> EvaluateScopedSettingAsync(LoggingContext`1<string> context);
    private bool EvaluateScopedSetting(LoggingContext`1<string> context);
    private void SaveSettingsInternal(string newCollectionPath, GroupedRemoteSettings groupedSettings);
    [CompilerGeneratedAttribute]
private string <get_CurrentCollectionPath>g__GenerateCurrentCollectionPath|19_0();
    [CompilerGeneratedAttribute]
internal static bool <TryGetValue>g__IsMatch|25_0(SplitKey possibleKey, string key, RemoteSettingsStorageHandler this, string settingNameForLog);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsStorageHandlerFactory : object {
    private static string PathPrefix;
    private static string PathFormatWithPrefix;
    private static string IsDisabledName;
    private static string IsLoggingEnabled;
    private static int RemoteSettingsExplicitlyDisabled;
    private static int RemoteSettingsLoggingEnabled;
    private IRemoteSettingsLogger logger;
    private Regex fileNameRegex;
    public RemoteSettingsStorageHandlerFactory(IRemoteSettingsLogger logger);
    public static Func`1<bool> BuildIsUpdateDisabled(ICollectionKeyValueStorage storage, bool usePrefix);
    public static Func`1<bool> BuildIsLoggingEnabled(ICollectionKeyValueStorage storage, bool usePrefix);
    public sealed virtual IVersionedRemoteSettingsStorageHandler BuildVersioned(ICollectionKeyValueStorage storage, bool usePrefix, string fileName, IScopeParserFactory scopeParserFactory);
    public sealed virtual IRemoteSettingsStorageHandler Build(ICollectionKeyValueStorage storage, bool usePrefix, RemoteSettingsFilterProvider filterProvider, IScopeParserFactory scopeParserFactory);
    public sealed virtual IRemoteSettingsStorageHandler Build(ICollectionKeyValueStorage storage, bool usePrefix, string collectionPath, IScopeParserFactory scopeParserFactory);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsValidationException : Exception {
    public RemoteSettingsValidationException(string description);
}
internal class Microsoft.VisualStudio.RemoteSettings.RemoteSettingsValidator : object {
    internal static string CyclesDetectedMessage;
    private ICycleDetection cycleDetection;
    private IScopesStorageHandler scopesStorageHandler;
    public RemoteSettingsValidator(ICycleDetection cycleDetection, IScopesStorageHandler scopesStorageHandler);
    private static RemoteSettingsValidator();
    public sealed virtual void ValidateDeserialized(DeserializedRemoteSettings remoteSettings);
    public sealed virtual void ValidateStored();
    private void ValidateScopes(IEnumerable`1<Scope> scopes);
}
internal class Microsoft.VisualStudio.RemoteSettings.Scope : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScopeString>k__BackingField;
    public string Name { get; public set; }
    public string ScopeString { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ScopeString();
    [CompilerGeneratedAttribute]
public void set_ScopeString(string value);
}
internal class Microsoft.VisualStudio.RemoteSettings.ScopeParser : object {
    private string expression;
    private Stack`1<Operand> output;
    private Stack`1<Operator> operators;
    private IDictionary`2<string, IScopeFilterProvider> providedFilters;
    private Regex stringRegex;
    private int expressionIndex;
    internal ScopeParser(string expression, IDictionary`2<string, IScopeFilterProvider> providedFilters);
    public bool Run();
    private void ParseOperator(Operator op);
    private void ParseOperand(Operand op);
    private Operator ScanOperator();
    private Operand ScanOperand();
    private void EvaluateOutput();
    private string GetRestOfExpression();
}
internal class Microsoft.VisualStudio.RemoteSettings.ScopeParserException : Exception {
    public ScopeParserException(string description);
}
internal class Microsoft.VisualStudio.RemoteSettings.ScopeParserFactory : object {
    private IDictionary`2<string, IScopeFilterProvider> providedFilters;
    private IRemoteSettingsLogger logger;
    public IDictionary`2<string, IScopeFilterProvider> ProvidedFilters { get; }
    public ScopeParserFactory(RemoteSettingsInitializer initializer);
    public sealed virtual IDictionary`2<string, IScopeFilterProvider> get_ProvidedFilters();
    public sealed virtual bool Evaluate(string scopeExpression);
    public sealed virtual Task`1<bool> EvaluateAsync(string scopeExpression);
}
internal class Microsoft.VisualStudio.RemoteSettings.ScopeScopeFilterProvider : object {
    private IScopesStorageHandler storage;
    private IScopeParserFactory scopeParserFactory;
    public string Name { get; }
    public ScopeScopeFilterProvider(IScopesStorageHandler storage, IScopeParserFactory factory);
    public sealed virtual string get_Name();
    public sealed virtual BoolScopeValue Provide(string key);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.ScopeScopeFilterProvider/<ProvideAsync>d__6")]
public sealed virtual Task`1<BoolScopeValue> ProvideAsync(string key);
}
public abstract class Microsoft.VisualStudio.RemoteSettings.ScopeValue : object {
    internal abstract virtual Operand GetOperand();
    internal abstract virtual AsyncOperand GetAsyncOperand();
}
public enum Microsoft.VisualStudio.RemoteSettings.SettingsType : Enum {
    public int value__;
    public static SettingsType Invalid;
    public static SettingsType Int32;
    public static SettingsType Int64;
    public static SettingsType String;
}
internal class Microsoft.VisualStudio.RemoteSettings.StableRemoteSettingsProvider : RemoteSettingsProviderBase {
    private HashSet`1<string> stableSettingRootSubCollections;
    public string Name { get; }
    public StableRemoteSettingsProvider(RemoteSettingsInitializer initializer);
    public virtual string get_Name();
    public sealed virtual bool IsStable(string collectionPath);
    public sealed virtual void MakeStable(string collectionPath, string key, T value);
    public virtual Task`1<GroupedRemoteSettings> StartAsync();
}
public class Microsoft.VisualStudio.RemoteSettings.StringScopeValue : ScopeValue {
    private string value;
    public StringScopeValue(string value);
    internal virtual AsyncOperand GetAsyncOperand();
    internal virtual Operand GetOperand();
}
internal class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsCacheProvider : object {
    [CompilerGeneratedAttribute]
private ITargetedNotificationsCacheStorageProvider <Storage>k__BackingField;
    private ITargetedNotificationsTelemetry telemetry;
    private TargetedNotificationsProviderBase tnProvider;
    private bool enforceCourtesy;
    private TimeSpan defaultMaxWaitTimeSpan;
    private bool responseUsesCachedRules;
    private ITargetedNotificationsCacheStorageProvider Storage { get; private set; }
    public TargetedNotificationsCacheProvider(bool enforceCourtesy, TargetedNotificationsProviderBase tnProvider, RemoteSettingsInitializer initializer);
    [CompilerGeneratedAttribute]
private ITargetedNotificationsCacheStorageProvider get_Storage();
    [CompilerGeneratedAttribute]
private void set_Storage(ITargetedNotificationsCacheStorageProvider value);
    public void MergeNewResponse(ActionResponseBag newResponse, IEnumerable`1<string> previouslyCachedRuleIds, Nullable`1<int> timeoutMs);
    public IEnumerable`1<string> GetAllCachedRuleIds(Nullable`1<int> timeoutMs);
    public ActionResponse GetSendableAction(ActionResponse action, Nullable`1<int> timeoutMs);
    public IEnumerable`1<ActionResponse> GetSendableActionsFromSet(IEnumerable`1<ActionResponse> actions, Nullable`1<int> timeoutMs);
}
internal class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsException : Exception {
    public TargetedNotificationsException(string message);
    public TargetedNotificationsException(string message, Exception innerException);
}
internal class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsJsonStorageProvider : object {
    private string cacheDirectory;
    private string cacheFileFullPath;
    private static string cacheLockName;
    private static string cacheFileName;
    private ITargetedNotificationsTelemetry telemetry;
    private Lazy`1<Mutex> cacheLock;
    public TargetedNotificationsJsonStorageProvider(RemoteSettingsInitializer initializer);
    public sealed virtual bool Lock(Nullable`1<int> timeoutMs);
    public sealed virtual void Unlock();
    public sealed virtual void Reset();
    public sealed virtual CachedTargetedNotifications GetLocalCacheCopy();
    public sealed virtual void SetLocalCache(CachedTargetedNotifications newCache);
    [CompilerGeneratedAttribute]
private Mutex <.ctor>b__6_0();
}
internal class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsParser : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsParser/<ParseStreamAsync>d__0")]
public sealed virtual Task`1<ActionResponseBag> ParseStreamAsync(Stream stream, CancellationToken cancellationToken);
}
internal class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProvider : TargetedNotificationsProviderBase {
    internal static string DefaultUrl;
    private static string DefaultContentType;
    private static int DefaultRequestTimeout;
    private IHttpWebRequestFactory webRequestFactory;
    private ITargetedNotificationsParser notificationsParser;
    private RemoteSettingsFilterProvider remoteSettingsFilterProvider;
    public string Name { get; }
    public TargetedNotificationsProvider(RemoteSettingsInitializer initializer);
    public virtual string get_Name();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProvider/<GetTargetedNotificationActionsAsync>d__9")]
protected virtual Task`1<ActionResponseBag> GetTargetedNotificationActionsAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProvider/<ResolveUrlRedirectAsync>d__10")]
private Task`1<string> ResolveUrlRedirectAsync(string url, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProvider/<SendTargetedNotificationsRequestAsync>d__11")]
private Task`1<Stream> SendTargetedNotificationsRequestAsync(IEnumerable`1<string> previouslyCachedRuleIds, CancellationToken cancelToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProvider/<BuildRequestParametersAsync>d__12")]
private Task`1<string> BuildRequestParametersAsync(IEnumerable`1<string> previouslyCachedRuleIds, CancellationToken cancellationToken);
    private static string HandleGuidParameter(Guid guid);
    private static int HandleBoolParameter(bool value);
}
internal abstract class Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase : RemoteSettingsProviderBase {
    internal static string TargetedNotificationsTelemetryEventPath;
    internal static string TargetedNotificationsTelemetryPropertyPath;
    internal IDictionary`2<string, ActionCategory> ActionCategories;
    protected static string RemoteSettingsActionPath;
    protected bool useCache;
    protected bool enforceCourtesy;
    protected int cacheTimeoutMs;
    protected TimeSpan serviceQueryLoopTimeSpan;
    protected CancellationTokenSource cancellationTokenSource;
    protected IRemoteSettingsTelemetry remoteSettingsTelemetry;
    protected ITargetedNotificationsTelemetry targetedNotificationsTelemetry;
    protected TargetedNotificationsCacheProvider notificationAndCourtesyCache;
    protected Stopwatch apiTimer;
    protected int queryIteration;
    private static string RemoteSettingsTelemetryEventPath;
    private static string RemoteSettingsTelemetryPropertyPath;
    private static string TargetedNotificationsCacheableStorageCollectionPath;
    private IDictionary`2<string, Dictionary`2<string, ActionResponse>> tnActions;
    private SemaphoreSlim actionsAndCategoriesLock;
    private IDictionary`2<string, List`1<int>> tnSubscriptionIds;
    private IDictionary`2<string, Dictionary`2<Type, IList>> tnSubscriptionCallbacks;
    private object subscriptionLockObject;
    private IRemoteSettingsStorageHandler cacheableStorageHandler;
    private IRemoteSettingsStorageHandler liveStorageHandler;
    private IRemoteSettingsParser remoteSettingsParser;
    private IExperimentationService experimentationService;
    private ITelemetryNotificationService telemetryNotificationService;
    public TargetedNotificationsProviderBase(IRemoteSettingsStorageHandler cacheableStorageHandler, RemoteSettingsInitializer initializer);
    public virtual Task`1<GroupedRemoteSettings> StartAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<StartAgainAfterAsync>d__29")]
internal Task StartAgainAfterAsync(TimeSpan delayTime);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<GetActionsAsync>d__30`1")]
public virtual Task`1<IEnumerable`1<ActionWrapper`1<T>>> GetActionsAsync(string actionPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<SubscribeActionsAsync>d__31`1")]
public virtual Task SubscribeActionsAsync(string actionPath, Action`1<ActionWrapper`1<T>> callback);
    public virtual void UnsubscribeActions(string actionPath);
    protected virtual void DisposeManagedResources();
    protected abstract virtual Task`1<ActionResponseBag> GetTargetedNotificationActionsAsync();
    private void ProcessActionResponseBag(ActionResponseBag response);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<ProcessRemoteSettingsFromTargetedNotificationsAsync>d__36")]
private Task`1<GroupedRemoteSettings> ProcessRemoteSettingsFromTargetedNotificationsAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<GetActionsInternalAsync>d__37`1")]
private Task`1<IEnumerable`1<LoggingContext`1<ActionWrapper`1<T>>>> GetActionsInternalAsync(string actionPath, bool shouldCheckFlight);
    private bool IsValidTriggerConfiguration(Dictionary`2<string, ITelemetryEventMatch> triggers, Dictionary`2<string, ActionTriggerOptions> options);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<SubscribeActionsInternalAsync>d__39`1")]
private Task SubscribeActionsInternalAsync(string actionPath, Action`1<ActionWrapper`1<T>> callback, IEnumerable`1<string> previouslySubscribedRuleIds);
    private T GetValueOrDefaultFromCacheableStorage(string collectionPath, string key, T defaultValue);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.RemoteSettings.TargetedNotificationsProviderBase/<<StartAsync>b__28_0>d")]
[CompilerGeneratedAttribute]
private Task`1<GroupedRemoteSettings> <StartAsync>b__28_0();
    [CompilerGeneratedAttribute]
private GroupedRemoteSettings <ProcessRemoteSettingsFromTargetedNotificationsAsync>b__36_3(GroupedRemoteSettings a, GroupedRemoteSettings b);
}
internal class Microsoft.VisualStudio.RemoteSettings.TestActionJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public enum Microsoft.VisualStudio.RemoteSettings.ValueKind : Enum {
    public int value__;
    public static ValueKind Unknown;
    public static ValueKind String;
    public static ValueKind MultiString;
    public static ValueKind DWord;
    public static ValueKind QWord;
}
internal class Microsoft.VisualStudio.RemoteSettings.VersionedDeserializedRemoteSettings : DeserializedRemoteSettings {
    [CompilerGeneratedAttribute]
private string <FileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangesetId>k__BackingField;
    public string FileVersion { get; }
    public string ChangesetId { get; }
    public VersionedDeserializedRemoteSettings(ReadOnlyCollection`1<Scope> scopes, ReadOnlyCollection`1<RemoteSetting> settings, string fileVersion, string changesetId, string error);
    public VersionedDeserializedRemoteSettings(DeserializedRemoteSettings remoteSettings, string fileVersion, string changesetId);
    [CompilerGeneratedAttribute]
public string get_FileVersion();
    [CompilerGeneratedAttribute]
public string get_ChangesetId();
}
internal class Microsoft.VisualStudio.RemoteSettings.VersionScopeFilterProvider : object {
    private DoubleScopeValue unknown;
    private Lazy`1<FileVersion> fileVersionInfo;
    public string Name { get; }
    public VersionScopeFilterProvider(RemoteSettingsFilterProvider filterProvider);
    public sealed virtual string get_Name();
    public sealed virtual DoubleScopeValue Provide(string key);
}
internal class Microsoft.VisualStudio.Telemetry.ActionPriorityConstants : object {
    public static int ManifestExcludePriority;
    public static int ManifestExcludePropertyPriority;
    public static int CustomOptOutPriority;
    public static int ManifestOptOutPriority;
    public static int ManifestThrottlingPriority;
    public static int ManifestHashedPriority;
    public static int ManifestPiiPriority;
    public static int ManifestCredScanPriority;
    public static int MetricPriority;
    public static int SettingPriority;
    public static int CredScanPriority;
    public static int PiiPriority;
    public static int EnforceAIRestrictionPriority;
    public static int ComplexPropertyPriority;
    public static int SuppressEmptyPostPropertyPriority;
    public static int ThrottlingPriority;
    public static int ManifestRoutePriority;
}
internal class Microsoft.VisualStudio.Telemetry.AssemblyPropertyProvider : object {
    internal static string TelemetryApiProductVersionPropertyName;
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
public class Microsoft.VisualStudio.Telemetry.AssetEvent : TelemetryEvent {
    private static string AssetEventPropertyPrefixName;
    private static string AssetIdPropertyName;
    private static string AssetEventVersionPropertyName;
    [CompilerGeneratedAttribute]
private string <AssetId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AssetEventVersion>k__BackingField;
    public string AssetId { get; }
    public int AssetEventVersion { get; }
    public AssetEvent(string eventName, string assetId, int assetEventVersion);
    public AssetEvent(string eventName, string assetId, int assetEventVersion, TelemetryEventCorrelation correlation);
    [CompilerGeneratedAttribute]
public string get_AssetId();
    [CompilerGeneratedAttribute]
public int get_AssetEventVersion();
}
public class Microsoft.VisualStudio.Telemetry.AssetService : object {
    private object locker;
    private ConcurrentDictionary`2<string, IAssetProvider> registeredProviders;
    private ConcurrentDictionary`2<CacheKey, TelemetryEventCorrelation> registeredCorrelations;
    private static Lazy`1<AssetService> lazyAssetService;
    [CompilerGeneratedAttribute]
private IAssetServiceThreadScheduler <ThreadScheduler>k__BackingField;
    private IAssetServiceThreadScheduler ThreadScheduler { get; }
    public static AssetService Instance { get; }
    internal AssetService(IAssetServiceThreadScheduler scheduler);
    private static AssetService();
    [CompilerGeneratedAttribute]
private IAssetServiceThreadScheduler get_ThreadScheduler();
    public static AssetService get_Instance();
    public void RegisterCorrelation(string assetTypeName, Guid assetId, TelemetryEventCorrelation correlation);
    public void RegisterCorrelation(string assetTypeName, string assetId, TelemetryEventCorrelation correlation);
    public void UnregisterCorrelation(string assetTypeName, Guid assetId);
    public void UnregisterCorrelation(string assetTypeName, string assetId);
    public void RegisterProvider(string assetTypeName, IAssetProvider assetProvider);
    public void UnregisterProvider(string assetTypeName);
    public TelemetryEventCorrelation GetCorrelation(string assetTypeName, Guid assetId);
    public TelemetryEventCorrelation GetCorrelation(string assetTypeName, string assetId);
}
internal abstract class Microsoft.VisualStudio.Telemetry.BaseHostRealtimePropertyProvider : object {
    private IHostInformationProvider hostInformationProvider;
    public BaseHostRealtimePropertyProvider(IHostInformationProvider hostInformationProvider);
    public sealed virtual void AddRealtimeSharedProperties(List`1<KeyValuePair`2<string, Func`1<object>>> sharedProperties, TelemetryContext telemetryContext);
    public abstract virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    [CompilerGeneratedAttribute]
private object <AddRealtimeSharedProperties>b__2_0();
}
internal abstract class Microsoft.VisualStudio.Telemetry.BaseJsonLogFile`1 : TelemetryDisposableObject {
    private object telemetryWriterLocker;
    private ITelemetryWriter telemetryWriter;
    private bool writeComma;
    private bool isInitialized;
    protected ITelemetryLogSettingsProvider settingsProvider;
    public BaseJsonLogFile`1(ITelemetryWriter writer);
    public sealed virtual void Initialize(ITelemetryLogSettingsProvider settingsProvider);
    public sealed virtual void WriteAsync(T eventData);
    protected abstract virtual string ConvertEventToString(T eventData);
    protected virtual void DisposeManagedResources();
    private void WriteHeader();
    private void WriteFooter();
}
internal enum Microsoft.VisualStudio.Telemetry.ChannelInternalSetting : Enum {
    public int value__;
    public static ChannelInternalSetting Undefined;
    public static ChannelInternalSetting ExplicitlyDisabled;
    public static ChannelInternalSetting ExplicitlyEnabled;
}
internal class Microsoft.VisualStudio.Telemetry.ClientSideThrottlingAction : object {
    private static long BaseThreshold;
    private static string UnknownValue;
    private HashSet`1<string> passthroughEvents;
    private HashSet`1<string> droppedEvents;
    private HashSet`1<string> noisyAllowedListEvents;
    private long counter;
    private long allowedListCounter;
    private double resetCounter;
    private long threshold;
    private DateTimeOffset bucketStartTime;
    public int Priority { get; }
    public ClientSideThrottlingAction(IEnumerable`1<string> passthroughEvents, double resetCounterOverride, long thresholdOverride);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void PostDiagnosticInformation(TelemetrySession mainSession, TelemetryManifest newManifest);
    public void AddPassthroughEventName(string eventName);
    private void Reset(TelemetrySession mainSession, TelemetryManifest newManifest, DateTimeOffset timeToReset);
}
internal class Microsoft.VisualStudio.Telemetry.Collector.Exceptions.FatalCollectorException : Exception {
    public FatalCollectorException(Exception innerException);
}
internal class Microsoft.VisualStudio.Telemetry.Collector.Exceptions.TelemetryStorageException : Exception {
    public TelemetryStorageException(Exception innerException);
}
internal interface Microsoft.VisualStudio.Telemetry.Collector.Exporters.IExporter {
    public abstract virtual bool ExportEvents(IEnumerable`1<IEmittedTelemetryEvent> events);
}
internal class Microsoft.VisualStudio.Telemetry.Collector.Exporters.TelemetryExporter : object {
    public sealed virtual bool ExportEvents(IEnumerable`1<IEmittedTelemetryEvent> events);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Collector.Exporters.TelemetryExporter/<SendAllAsync>d__1")]
private Task`1<bool> SendAllAsync(IEnumerable`1<IEmittedTelemetryEvent> transmissions, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Collector.Exporters.TelemetryExporter/<SendAsync>d__2")]
private Task`1<bool> SendAsync(IEmittedTelemetryEvent transmission, CancellationToken token);
    private static Nullable`1<int> GetStatusCode(WebException e);
    private static bool IsRetriable(Nullable`1<int> httpStatusCode, WebExceptionStatus webExceptionStatus);
}
internal interface Microsoft.VisualStudio.Telemetry.Collector.IEmittedTelemetryEvent {
    public string ApiKey { get; }
    public VisualStudioCodeTelemetryLevel TelemetryLevel { get; }
    public abstract virtual string get_ApiKey();
    public abstract virtual VisualStudioCodeTelemetryLevel get_TelemetryLevel();
    public abstract virtual void Delete();
    public abstract virtual Task SendAsync(CancellationToken token);
}
internal interface Microsoft.VisualStudio.Telemetry.Collector.ITelemetryPipeline {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void ProcessTelemetry();
    public abstract virtual void AddReceiver(IReceiver receiver);
    public abstract virtual void AddProcessor(IProcessor processor);
    public abstract virtual void AddExporter(IExporter exporter);
}
internal interface Microsoft.VisualStudio.Telemetry.Collector.IUpdateTelemetryLevel {
    public abstract virtual void UpdateTelemetryLevel(VisualStudioCodeTelemetryLevel newLevel);
}
internal class Microsoft.VisualStudio.Telemetry.Collector.Processors.EndpointApiKeyFilter : object {
    [CompilerGeneratedAttribute]
private string <ExpectedEndpointApiKey>k__BackingField;
    private string ExpectedEndpointApiKey { get; private set; }
    public EndpointApiKeyFilter(string endpointApiKey);
    [CompilerGeneratedAttribute]
private string get_ExpectedEndpointApiKey();
    [CompilerGeneratedAttribute]
private void set_ExpectedEndpointApiKey(string value);
    public sealed virtual IEnumerable`1<IEmittedTelemetryEvent> ProcessEvents(IEnumerable`1<IEmittedTelemetryEvent> events);
    [CompilerGeneratedAttribute]
private bool <ProcessEvents>b__5_0(IEmittedTelemetryEvent e);
}
internal interface Microsoft.VisualStudio.Telemetry.Collector.Processors.IProcessor {
    public abstract virtual IEnumerable`1<IEmittedTelemetryEvent> ProcessEvents(IEnumerable`1<IEmittedTelemetryEvent> events);
}
internal class Microsoft.VisualStudio.Telemetry.Collector.Processors.VsCodeTelemetryLevelFilter : object {
    [CompilerGeneratedAttribute]
private VisualStudioCodeTelemetryLevel <ConfiguredTelemetryLevel>k__BackingField;
    private VisualStudioCodeTelemetryLevel ConfiguredTelemetryLevel { get; private set; }
    public VsCodeTelemetryLevelFilter(VisualStudioCodeTelemetryLevel configuredTelemetryLevel);
    [CompilerGeneratedAttribute]
private VisualStudioCodeTelemetryLevel get_ConfiguredTelemetryLevel();
    [CompilerGeneratedAttribute]
private void set_ConfiguredTelemetryLevel(VisualStudioCodeTelemetryLevel value);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Collector.Processors.VsCodeTelemetryLevelFilter/<ProcessEvents>d__5")]
public sealed virtual IEnumerable`1<IEmittedTelemetryEvent> ProcessEvents(IEnumerable`1<IEmittedTelemetryEvent> events);
    public sealed virtual void UpdateTelemetryLevel(VisualStudioCodeTelemetryLevel newLevel);
}
internal interface Microsoft.VisualStudio.Telemetry.Collector.Receivers.IReceiver {
    public abstract virtual IEnumerable`1<IEmittedTelemetryEvent> GetEvents();
    public abstract virtual void PurgeTelemetryData();
}
internal class Microsoft.VisualStudio.Telemetry.Collector.Receivers.PersistentStorageReceiver : object {
    private StorageBase storage;
    public PersistentStorageReceiver(PersistenceVersion version, string iKey, string globalStorageUri);
    private StorageBase GetStorage(PersistenceVersion version, string iKey, string globalStorageUri);
    public sealed virtual IEnumerable`1<IEmittedTelemetryEvent> GetEvents();
    public sealed virtual void PurgeTelemetryData();
}
internal class Microsoft.VisualStudio.Telemetry.Collector.TelemetryCollector : object {
    [CompilerGeneratedAttribute]
private TimeSpan <SendingInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ITelemetryPipeline> <Pipelines>k__BackingField;
    private IProcessLock locker;
    private AutoResetEvent delayHandler;
    private AutoResetEvent stoppedHandler;
    private AutoResetEvent eventToKeepMutexThreadAlive;
    private CancellationTokenSource sendingCancellationTokenSource;
    private TimeSpan drainingTimeout;
    private int disposeCount;
    [CompilerGeneratedAttribute]
private CollectorStatus <Status>k__BackingField;
    internal TimeSpan SendingInterval { get; internal set; }
    private IList`1<ITelemetryPipeline> Pipelines { get; private set; }
    internal CollectorStatus Status { get; internal set; }
    public TelemetryCollector(TimeSpan processingInterval, string lockingFolder, Nullable`1<TimeSpan> drainingTimeout);
    [CompilerGeneratedAttribute]
internal TimeSpan get_SendingInterval();
    [CompilerGeneratedAttribute]
internal void set_SendingInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
private IList`1<ITelemetryPipeline> get_Pipelines();
    [CompilerGeneratedAttribute]
private void set_Pipelines(IList`1<ITelemetryPipeline> value);
    [CompilerGeneratedAttribute]
internal CollectorStatus get_Status();
    [CompilerGeneratedAttribute]
internal void set_Status(CollectorStatus value);
    public void AddPipeline(ITelemetryPipeline pipeline);
    public sealed virtual void UpdateTelemetryLevel(VisualStudioCodeTelemetryLevel newLevel);
    public void Start();
    internal Task StopAsync();
    internal void ProcessingLoop();
    private IProcessLockFactory GetProcessLock();
    private void AcquireMutex(Action action);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Start>b__23_0();
    [CompilerGeneratedAttribute]
private void <Start>b__23_2();
    [CompilerGeneratedAttribute]
private void <StopAsync>b__24_0();
}
internal class Microsoft.VisualStudio.Telemetry.Collector.TelemetryPipeline : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IReceiver> <Receivers>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IProcessor> <Processors>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IExporter> <Exporters>k__BackingField;
    private VisualStudioCodeTelemetryLevel currentTelemetryLevel;
    private VisualStudioCodeTelemetryLevel previousTelemetryLevel;
    private object processingLock;
    public string Name { get; public set; }
    private IList`1<IReceiver> Receivers { get; private set; }
    private IList`1<IProcessor> Processors { get; private set; }
    private IList`1<IExporter> Exporters { get; private set; }
    private VisualStudioCodeTelemetryLevel ConfiguredTelemetryLevel { get; private set; }
    public TelemetryPipeline(string name, VisualStudioCodeTelemetryLevel telemetryLevel);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
private IList`1<IReceiver> get_Receivers();
    [CompilerGeneratedAttribute]
private void set_Receivers(IList`1<IReceiver> value);
    [CompilerGeneratedAttribute]
private IList`1<IProcessor> get_Processors();
    [CompilerGeneratedAttribute]
private void set_Processors(IList`1<IProcessor> value);
    [CompilerGeneratedAttribute]
private IList`1<IExporter> get_Exporters();
    [CompilerGeneratedAttribute]
private void set_Exporters(IList`1<IExporter> value);
    private VisualStudioCodeTelemetryLevel get_ConfiguredTelemetryLevel();
    private void set_ConfiguredTelemetryLevel(VisualStudioCodeTelemetryLevel value);
    public sealed virtual void ProcessTelemetry();
    public sealed virtual void AddReceiver(IReceiver receiver);
    public sealed virtual void AddProcessor(IProcessor processor);
    public sealed virtual void AddExporter(IExporter exporter);
    public sealed virtual void UpdateTelemetryLevel(VisualStudioCodeTelemetryLevel newLevel);
    public void PurgeTelemetryData();
    private void UpdateAllComponentTelemetryLevels(VisualStudioCodeTelemetryLevel newLevel);
}
public class Microsoft.VisualStudio.Telemetry.Collector.VSCodeTelemetryCollector : object {
    [CompilerGeneratedAttribute]
private TelemetryCollector <Collector>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    private bool disposedValue;
    private TelemetryCollector Collector { get; private set; }
    private bool IsInitialized { get; private set; }
    [CompilerGeneratedAttribute]
private TelemetryCollector get_Collector();
    [CompilerGeneratedAttribute]
private void set_Collector(TelemetryCollector value);
    [CompilerGeneratedAttribute]
private bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public void Start(string rawTelemetryLevel, string globalStorageUri);
    public void UpdateTelemetryLevel(string newLevel);
    private void Initialize(VisualStudioCodeTelemetryLevel telemetryLevel, string globalStorageUri);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal static class Microsoft.VisualStudio.Telemetry.Common.Constants.InstrumentationConstants : object {
    internal static string VSCollectorApiKey;
    internal static string VSCodeCollectorApiKey;
    internal static string VSCollectorIKey;
    internal static string VSCodeCollectorIKey;
    internal static string VSAsimovIKey;
    internal static string VSAppInsightsIKey;
    private static InstrumentationConstants();
}
internal static class Microsoft.VisualStudio.Telemetry.Common.Constants.PropertyKeyConstants : object {
    internal static string DefaultContextPrefix;
    internal static string VSCorePrefix;
    internal static string ReservedPrefix;
    internal static string VSCoreInternalPrefix;
    private static string UserPrefix;
    internal static string MachineId;
    internal static string MacAddressHash;
    internal static string OsVersion;
    internal static string MachineArchitecture;
    internal static string IsDevBox;
    internal static string UserId;
    internal static string UserType;
    internal static string IsOptedIn;
    internal static string IsMicrosoftInternal;
    internal static string IsMicrosoftAADJoined;
    internal static string UserGeoId;
    internal static string UserName;
    internal static string UserDomainName;
    internal static string ComputerName;
    internal static string ExeName;
    internal static string ExeVersion;
    internal static string Is64BitProcess;
    internal static string ProcessArchitecture;
    internal static string ProductArchitecture;
    internal static string EntityType;
    internal static string EventId;
    internal static string Sessionid;
    internal static IEnumerable`1<string> RequiredProperties;
    private static PropertyKeyConstants();
}
internal static class Microsoft.VisualStudio.Telemetry.Common.Constants.RegistryConstants : object {
    internal static string WindowsCurrentVersionRegistryPath;
    internal static string BuildLabRegistryKey;
    internal static string OptedInRegistryKeyName;
    internal static int UserIsOptedInValue;
    internal static string VSGlobalPolicyRegKeyPath;
    internal static string VSCodeGlobalPolicyRegKeyPath;
    internal static string LocalOptedInRootRegistryPath;
    internal static string LocalOptedInRegistryPath;
}
internal static class Microsoft.VisualStudio.Telemetry.Common.Constants.StorageConstants : object {
    internal static string StorageCacheMutexPrefixV1;
    internal static string StorageCacheMutexPrefixV2;
    internal static string TrnTransmissionFileExtension;
    internal static string JsonTransmissionFileExtension;
    internal static string PersistentFolderNamePrefix;
}
internal class Microsoft.VisualStudio.Telemetry.Common.Exceptions.HashAlgorithmCreationException : InvalidOperationException {
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.BiosUuid.WindowsBiosUuidInformationProvider : object {
    private Lazy`1<BiosInformation> biosInformationLazy;
    internal Nullable`1<Guid> SMBiosUuid { get; }
    internal Nullable`1<Guid> get_SMBiosUuid();
    private BiosInformation InitializeBiosInformation();
    private static Memory`1<byte> GetSystemFirmwareTable(FIRMWARE_TABLE_PROVIDER provider, FIRMWARE_TABLE_ID table);
    private static Memory`1<FIRMWARE_TABLE_ID> EnumSystemFirmwareTables(FIRMWARE_TABLE_PROVIDER provider);
    [CompilerGeneratedAttribute]
private BiosInformation <.ctor>b__1_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.DefaultOSInformationProvider : object {
    [NullableAttribute("0")]
private IOSInformationProvider osInformationProvider;
    public string ProductName { get; }
    public IOSVersionInfo OSVersion { get; }
    public sealed virtual string get_ProductName();
    public sealed virtual IOSVersionInfo get_OSVersion();
}
internal abstract class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.DeveloperDevice.DeveloperDeviceInformationProviderBase : object {
    private bool isInitialized;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> errorList;
    [NullableAttribute("2")]
private string deviceId;
    private bool isDeviceIdFromCache;
    [NullableAttribute("2")]
private string legacyDeviceId;
    [CompilerGeneratedAttribute]
private IHardwareInformationProvider <HardwareInformationProvider>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> DeveloperDeviceIdentifierRetrievalComplete;
    protected IHardwareInformationProvider HardwareInformationProvider { get; }
    [NullableAttribute("2")]
public string DeviceId { get; }
    public bool IsDeviceIdFromCache { get; }
    public DeveloperDeviceInformationProviderBase(IHardwareInformationProvider hardwareInformationProvider, string idValueToUse);
    [CompilerGeneratedAttribute]
protected IHardwareInformationProvider get_HardwareInformationProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void add_DeveloperDeviceIdentifierRetrievalComplete(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DeveloperDeviceIdentifierRetrievalComplete(EventHandler`1<EventArgs> value);
    [NullableContextAttribute("2")]
public sealed virtual string get_DeviceId();
    public sealed virtual bool get_IsDeviceIdFromCache();
    public sealed virtual void InitializeIdentifiers();
    [NullableContextAttribute("2")]
internal string GetErrorList();
    [NullableContextAttribute("2")]
protected abstract virtual bool TryGetDeviceIdFromCache(String& deviceId);
    protected abstract virtual bool TryCacheDeviceId(string newDeviceId);
    protected abstract virtual bool TryCacheUuid();
    protected abstract virtual bool TryCacheMachineGuid();
    protected abstract virtual bool TryCacheHardDriveSerialNumber();
    protected string GenerateDeviceId();
    [NullableContextAttribute("2")]
protected void ReportError(string methodName, Exception ex, string optionalMessage);
    private void OnDeviceIdentifierRetrievalComplete(EventArgs e);
}
internal abstract class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.DeveloperDevice.FileBasedDeveloperDeviceInformationProviderBase : DeveloperDeviceInformationProviderBase {
    private static string deviceIdFileName;
    private static string uuidFileName;
    private static string machineGuidFileName;
    private static string hardDriveSerialNumberFileName;
    private Lazy`1<string> deviceCacheFolderLazy;
    private Lazy`1<string> hardwareCacheFolderLazy;
    protected string BaseStorageFolder { get; }
    public FileBasedDeveloperDeviceInformationProviderBase(IHardwareInformationProvider hardwareInformationProvider, string legacyDeviceId);
    protected abstract virtual string get_BaseStorageFolder();
    private string GetDeviceCacheFolder();
    private string GetHardwareCacheFolder();
    protected virtual bool TryCacheDeviceId(string newDeviceId);
    protected virtual bool TryCacheHardDriveSerialNumber();
    protected virtual bool TryCacheMachineGuid();
    protected virtual bool TryCacheUuid();
    [NullableContextAttribute("2")]
protected virtual bool TryGetDeviceIdFromCache(String& deviceId);
    protected bool TryCacheValueToDisk(string directoryPath, string fileName, string value);
    [CompilerGeneratedAttribute]
private string <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private string <.ctor>b__6_1();
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.DeveloperDevice.WindowsDeveloperDeviceInformationProvider : DeveloperDeviceInformationProviderBase {
    private static RegistryHive hive;
    private static string registryPathRoot;
    private static string hardwareRegistryPath;
    private static string developerDeviceIdName;
    private static string uuidName;
    private static string machineGuidName;
    private static string hardDriveSerialNumberName;
    public WindowsDeveloperDeviceInformationProvider(IHardwareInformationProvider hardwareInformationProvider, string legacyDeviceId);
    protected virtual bool TryCacheDeviceId(string newDeviceId);
    [NullableContextAttribute("2")]
protected virtual bool TryGetDeviceIdFromCache(String& deviceId);
    protected virtual bool TryCacheUuid();
    protected virtual bool TryCacheMachineGuid();
    protected virtual bool TryCacheHardDriveSerialNumber();
    private static bool GetRegistryValue(RegistryHive hive, string keyPath, string name, String& value, Action`3<string, Exception, string> errorReportingAction);
    private static bool SetRegistryValue(RegistryHive hive, string keyPath, string name, string value, Action`3<string, Exception, string> errorReportingAction);
}
internal interface Microsoft.VisualStudio.Telemetry.Common.InformationProviders.HostProcess.IHostProcessInformationProvider {
    public string ProcessName { get; }
    public UInt32 ProcessId { get; }
    public Nullable`1<int> ProcessBuildNumber { get; }
    public string ProcessExeVersion { get; }
    public bool IsDebuggerAttached { get; }
    public bool Is64BitProcess { get; }
    public string OSBitness { get; }
    public abstract virtual string get_ProcessName();
    public abstract virtual UInt32 get_ProcessId();
    public abstract virtual Nullable`1<int> get_ProcessBuildNumber();
    public abstract virtual string get_ProcessExeVersion();
    public abstract virtual bool get_IsDebuggerAttached();
    public abstract virtual bool get_Is64BitProcess();
    public abstract virtual string get_OSBitness();
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.HostProcess.Windows.WindowsHostProcessInformationProvider : object {
    private Lazy`1<string> name;
    private Lazy`1<UInt32> id;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<FileVersionInfo> hostVersionInfo;
    private static string UnknownName;
    public string ProcessName { get; }
    public UInt32 ProcessId { get; }
    public Nullable`1<int> ProcessBuildNumber { get; }
    public string ProcessExeVersion { get; }
    public bool IsDebuggerAttached { get; }
    public bool Is64BitProcess { get; }
    public string OSBitness { get; }
    public sealed virtual string get_ProcessName();
    public sealed virtual UInt32 get_ProcessId();
    public sealed virtual Nullable`1<int> get_ProcessBuildNumber();
    public sealed virtual string get_ProcessExeVersion();
    public sealed virtual bool get_IsDebuggerAttached();
    public sealed virtual bool get_Is64BitProcess();
    public sealed virtual string get_OSBitness();
    private static string InitializeName();
    private static UInt32 InitializeId();
    [NullableContextAttribute("2")]
private static FileVersionInfo InitializeHostVersionInfo();
}
[NullableContextAttribute("2")]
internal interface Microsoft.VisualStudio.Telemetry.Common.InformationProviders.IMachineInformationProvider {
    public Guid MachineId { get; }
    public bool IsDevBox { get; }
    public string MachineArchitecture { get; }
    public string Win365PartnerId { get; }
    public bool SqmIsTest { get; }
    public bool SqmIsMsftInternal { get; }
    public abstract virtual Guid get_MachineId();
    public abstract virtual bool get_IsDevBox();
    public abstract virtual string get_MachineArchitecture();
    public abstract virtual string get_Win365PartnerId();
    public abstract virtual bool get_SqmIsTest();
    public abstract virtual bool get_SqmIsMsftInternal();
}
internal interface Microsoft.VisualStudio.Telemetry.Common.InformationProviders.IMACInformationProvider {
    [CompilerGeneratedAttribute]
public abstract virtual void add_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    public abstract virtual void RunProcessIfNecessary(Action`1<string> onComplete);
    public abstract virtual string GetMACAddressHash();
}
[NullableContextAttribute("2")]
internal interface Microsoft.VisualStudio.Telemetry.Common.InformationProviders.IOSInformationProvider {
    public string ProductName { get; }
    public IOSVersionInfo OSVersion { get; }
    public abstract virtual string get_ProductName();
    public abstract virtual IOSVersionInfo get_OSVersion();
}
internal interface Microsoft.VisualStudio.Telemetry.Common.InformationProviders.IOSVersionInfo {
    public string Version { get; }
    public abstract virtual string get_Version();
}
internal interface Microsoft.VisualStudio.Telemetry.Common.InformationProviders.IUserInformationProvider {
    public bool CanCollectPrivateInformation { get; }
    public bool IsUserMicrosoftInternal { get; }
    public bool IsMicrosoftAADJoined { get; }
    public Guid UserId { get; }
    public UserType UserType { get; }
    public abstract virtual bool get_CanCollectPrivateInformation();
    public abstract virtual bool get_IsUserMicrosoftInternal();
    public abstract virtual bool get_IsMicrosoftAADJoined();
    public abstract virtual Guid get_UserId();
    public abstract virtual UserType get_UserType();
}
internal interface Microsoft.VisualStudio.Telemetry.Common.InformationProviders.IVsOptInStatusInformationProvider {
    public abstract virtual VsOptInStatus ReadIsOptedInStatus();
    public abstract virtual bool ReadIsOptedInStatus(string productVersion);
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.LinuxDeveloperDeviceInformationProvider : FileBasedDeveloperDeviceInformationProviderBase {
    protected string BaseStorageFolder { get; }
    public LinuxDeveloperDeviceInformationProvider(IHardwareInformationProvider hardwareInformationProvider, string legacyDeviceId);
    protected virtual string get_BaseStorageFolder();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.LinuxOSInformationProvider : object {
    [NullableAttribute("0")]
private static string LinuxProductName;
    public string ProductName { get; }
    public IOSVersionInfo OSVersion { get; }
    public sealed virtual string get_ProductName();
    public sealed virtual IOSVersionInfo get_OSVersion();
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.MacDeveloperDeviceInformationProvider : FileBasedDeveloperDeviceInformationProviderBase {
    protected string BaseStorageFolder { get; }
    public MacDeveloperDeviceInformationProvider(IHardwareInformationProvider hardwareInformationProvider, string legacyDeviceId);
    protected virtual string get_BaseStorageFolder();
}
internal static class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.MacHardwareIdentification : object {
    private static string CoreFoundationLibrary;
    private static IntPtr CoreFoundationLibraryHandle;
    private static IntPtr kCFTypeDictionaryKeyCallBacks;
    private static IntPtr kCFTypeDictionaryValueCallBacks;
    private static IntPtr kCFBooleanTrue;
    private static IntPtr kCFAllocatorDefault;
    private static int KERN_SUCCESS;
    private static string IOKitLibrary;
    private static IntPtr IOKitLibraryHandle;
    private static string kIOServicePlane;
    private static string kIOEthernetInterface;
    private static string kIOPrimaryInterface;
    private static string kIOPropertyMatchKey;
    private static string kIOMACAddress;
    private static IntPtr kIOMasterPortDefault;
    private static MacHardwareIdentification();
    [NullableContextAttribute("2")]
public static bool TryGetFirstPrimaryMacAddress(String& macAddress);
    [NullableContextAttribute("2")]
private static bool TryGetFirstPrimaryMacAddress(IntPtr interfaceIterator, String& macAddress);
    private static bool TryFindPrimaryEthernetInterfaces(IntPtr& interfaceIterator);
    private static IntPtr dlopen(string path, int mode);
    private static IntPtr dlsym(IntPtr handle, string symbol);
    private static void CFRelease(IntPtr obj);
    private static IntPtr CFStringCreateWithCString(IntPtr alloc, string str, CFStringEncoding encoding);
    private static IntPtr CFDictionaryCreateMutable(IntPtr allocator, IntPtr capacity, IntPtr keyCallBacks, IntPtr valueCallBacks);
    private static void CFDictionarySetValue(IntPtr theDict, IntPtr key, IntPtr value);
    private static void CFDataGetBytes(IntPtr theData, CFRange range, Byte[] buffer);
    private static IntPtr IOServiceMatching(string serviceName);
    private static int IOServiceGetMatchingServices(IntPtr masterPort, IntPtr matching, IntPtr& existing);
    private static void IOObjectRelease(IntPtr obj);
    private static IntPtr IOIteratorNext(IntPtr iter);
    private static int IORegistryEntryGetParentEntry(IntPtr entry, string plane, IntPtr& parent);
    private static IntPtr IORegistryEntryCreateCFProperty(IntPtr entry, IntPtr key, IntPtr allocator, UInt32 options);
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.MachineInformationProvider : object {
    private static object machineIdCalculationLock;
    private static string Win365RegistryPath;
    private static string Win365PartnerIdRegistryKey;
    private static string DevBoxPartnerId;
    private Lazy`1<Guid> machineId;
    private Lazy`1<bool> isDevBox;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<string> machineArchitecture;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<string> win365PartnerId;
    private Lazy`1<bool> sqmIsTest;
    private Lazy`1<bool> sqmIsMsftInternal;
    private ISQMApi sqmApi;
    private IUserInformationProvider userInformationProvider;
    private IMACInformationProvider macInformationProvider;
    public Guid MachineId { get; }
    public bool IsDevBox { get; }
    [NullableAttribute("2")]
public string MachineArchitecture { get; }
    [NullableAttribute("2")]
public string Win365PartnerId { get; }
    public bool SqmIsTest { get; }
    public bool SqmIsMsftInternal { get; }
    public MachineInformationProvider(ISQMApi sqmApi, IUserInformationProvider userInformationProvider, IMACInformationProvider macInformationProvider);
    private static MachineInformationProvider();
    public sealed virtual Guid get_MachineId();
    public sealed virtual bool get_IsDevBox();
    [NullableContextAttribute("2")]
public sealed virtual string get_MachineArchitecture();
    [NullableContextAttribute("2")]
public sealed virtual string get_Win365PartnerId();
    public sealed virtual bool get_SqmIsTest();
    public sealed virtual bool get_SqmIsMsftInternal();
    [NullableContextAttribute("2")]
internal static string GetWin365PartnerId();
    private Guid CalculateMachineId();
    private static Guid ConvertHexHashToGuid(string hex);
    private bool InitializeIsDevBox();
    [NullableContextAttribute("2")]
private string GetMachineArchitecture();
    private bool GetSqmIsTestValue();
    private bool GetSqmIsMsftInternalValue();
    [CompilerGeneratedAttribute]
private Guid <.ctor>b__13_0();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private string <.ctor>b__13_1();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__13_2();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__13_4();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__13_5();
}
internal abstract class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.MACInformationProvider : object {
    internal static string ZeroHash;
    private IProcessTools processTools;
    private IPersistentPropertyBag persistentStorage;
    private Lazy`1<string> persistedMAC;
    internal static string MacAddressKey;
    private static string MacRegex;
    private static string ZeroRegex;
    internal static string PersistRegex;
    private string command;
    [NullableAttribute("2")]
private string commandArgs;
    private bool needToRunProcess;
    private object needToRunProcessLock;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> MACAddressHashCalculationCompleted;
    protected MACInformationProvider(IProcessTools processTools, IPersistentPropertyBag persistentStorage, string command, string commandArgs);
    private static MACInformationProvider();
    public sealed virtual void RunProcessIfNecessary(Action`1<string> onComplete);
    public sealed virtual string GetMACAddressHash();
    [CompilerGeneratedAttribute]
public sealed virtual void add_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    private string CalculateMACAddressHash();
    private string ParseMACAddress(string data);
    internal static string HashMACAddress(string macAddress);
    private void OnMACAddressHashCalculationCompletedEvent(EventArgs e);
    [CompilerGeneratedAttribute]
private string <.ctor>b__12_0();
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.MacMACInformationProvider : object {
    private static string MacInformationProviderVersionKey;
    private static string MacInformationProviderVersion;
    private IPersistentPropertyBag persistentStorage;
    private ISQMApi sqmApi;
    private Lazy`1<string> persistedMAC;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> MACAddressHashCalculationCompleted;
    public MacMACInformationProvider(IPersistentPropertyBag persistentStorage, ISQMApi sqmApi);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MACAddressHashCalculationCompleted(EventHandler`1<EventArgs> value);
    public sealed virtual string GetMACAddressHash();
    public sealed virtual void RunProcessIfNecessary(Action`1<string> onComplete);
    private string CalculateMACAddressHash();
    [NullableContextAttribute("2")]
private string GetPersistedMacHash();
    private void OnMACAddressHashCalculationCompletedEvent(EventArgs e);
    [CompilerGeneratedAttribute]
private string <.ctor>b__5_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.MacOSInformationProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<MacOSVersionInfo> osVersion;
    public string ProductName { get; }
    public IOSVersionInfo OSVersion { get; }
    public sealed virtual string get_ProductName();
    public sealed virtual IOSVersionInfo get_OSVersion();
    private static MacOSVersionInfo GetOSVersion();
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.MacOSVersionInfo : object {
    [CompilerGeneratedAttribute]
private OSVersionInfo <VersionInfo>k__BackingField;
    public string Version { get; }
    public OSVersionInfo VersionInfo { get; public set; }
    public string KernelOSVersion { get; }
    public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public OSVersionInfo get_VersionInfo();
    [CompilerGeneratedAttribute]
public void set_VersionInfo(OSVersionInfo value);
    public string get_KernelOSVersion();
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.MacVsOptInStatusInformationProvider : object {
    public sealed virtual VsOptInStatus ReadIsOptedInStatus();
    public sealed virtual bool ReadIsOptedInStatus(string productVersion);
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.MonoMACInformationProvider : MACInformationProvider {
    private static string Command;
    private static string CommandArgs;
    public MonoMACInformationProvider(IProcessTools processTools, IPersistentPropertyBag persistentStorage);
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.OSVersionInfo : object {
    [CompilerGeneratedAttribute]
private ulong <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <BuildNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <RevisionNumber>k__BackingField;
    public string Version { get; }
    public ulong MajorVersion { get; public set; }
    public ulong MinorVersion { get; public set; }
    public ulong BuildNumber { get; public set; }
    public ulong RevisionNumber { get; public set; }
    public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public ulong get_MajorVersion();
    [CompilerGeneratedAttribute]
public void set_MajorVersion(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_MinorVersion();
    [CompilerGeneratedAttribute]
public void set_MinorVersion(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_BuildNumber();
    [CompilerGeneratedAttribute]
public void set_BuildNumber(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_RevisionNumber();
    [CompilerGeneratedAttribute]
public void set_RevisionNumber(ulong value);
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.Privacy.ConstantVsOptInStatusInformationProvider : object {
    private VsOptInStatus optInStatus;
    public ConstantVsOptInStatusInformationProvider(bool isOptedIn, VsOptInReason reason);
    public sealed virtual VsOptInStatus ReadIsOptedInStatus();
    public sealed virtual bool ReadIsOptedInStatus(string productVersion);
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.Privacy.DefaultVsOptInStatusInformationProvider : object {
    private IVsOptInStatusInformationProvider provider;
    public sealed virtual VsOptInStatus ReadIsOptedInStatus();
    public sealed virtual bool ReadIsOptedInStatus(string productVersion);
}
internal enum Microsoft.VisualStudio.Telemetry.Common.InformationProviders.Privacy.VsOptInReason : Enum {
    public int value__;
    public static VsOptInReason Undefined;
    public static VsOptInReason ReadFromGlobalPolicy;
    public static VsOptInReason OptedInForAll;
    public static VsOptInReason OptedOutForAll;
    public static VsOptInReason OptedInForSomeOptedOutForSome;
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.Privacy.VsOptInStatus : object {
    public bool IsOptedIn;
    public VsOptInReason OptInReason;
    internal VsOptInStatus(bool isOptedIn, VsOptInReason reason);
}
internal enum Microsoft.VisualStudio.Telemetry.Common.InformationProviders.UserType : Enum {
    public int value__;
    public static UserType External;
    public static UserType Internal;
    public static UserType DevDiv;
    public static UserType Lab;
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.WindowsMACInformationProvider : MACInformationProvider {
    private static string Command;
    public WindowsMACInformationProvider(IProcessTools processTools, IPersistentPropertyBag persistentStorage);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.WindowsOSInformationProvider : object {
    [NullableAttribute("0")]
private static string ProductNameRegistryKey;
    [NullableAttribute("0")]
private static string UBRRegistryKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<string> productName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<OSVersionInfo> osVersion;
    [NullableAttribute("0")]
private Lazy`1<IRegistryTools4> registry;
    public string ProductName { get; }
    public IOSVersionInfo OSVersion { get; }
    public WindowsOSInformationProvider(IRegistryTools4 registryTools);
    public sealed virtual string get_ProductName();
    public sealed virtual IOSVersionInfo get_OSVersion();
    private string GetProductName();
    private OSVersionInfo GetOSVersion();
    private OSVersionInfo GetOSVersionWindows();
}
internal class Microsoft.VisualStudio.Telemetry.Common.InformationProviders.WindowsVsOptInStatusInformationProvider : object {
    private IRegistryTools4 registry;
    [NullableContextAttribute("2")]
public WindowsVsOptInStatusInformationProvider(IRegistryTools4 registry);
    public sealed virtual VsOptInStatus ReadIsOptedInStatus();
    public sealed virtual bool ReadIsOptedInStatus(string productVersion);
    public bool ReadIsOptedInStatusForSpecificVersion(string productVersion);
    private bool TryGlobalPolicyOptedInStatus(Boolean& optedIn);
    private static bool KeyMatchesSqmFormat(string key);
    private static VsOptInReason GetOptInReasonForLocalPolicy(bool isOptedIn, bool anyVersionOptedIn);
}
internal interface Microsoft.VisualStudio.Telemetry.Common.Interfaces.IDeveloperDeviceInformationProvider {
    [NullableAttribute("2")]
public string DeviceId { get; }
    public bool IsDeviceIdFromCache { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_DeveloperDeviceIdentifierRetrievalComplete(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DeveloperDeviceIdentifierRetrievalComplete(EventHandler`1<EventArgs> value);
    [NullableContextAttribute("2")]
public abstract virtual string get_DeviceId();
    public abstract virtual bool get_IsDeviceIdFromCache();
    public abstract virtual void InitializeIdentifiers();
}
[NullableContextAttribute("2")]
internal interface Microsoft.VisualStudio.Telemetry.Common.Interfaces.IHardwareInformationProvider {
    public string Uuid { get; }
    public string MachineGuid { get; }
    public string HardDriveSerialNumber { get; }
    public abstract virtual string get_Uuid();
    public abstract virtual string get_MachineGuid();
    public abstract virtual string get_HardDriveSerialNumber();
}
internal interface Microsoft.VisualStudio.Telemetry.Common.IPersistentPropertyBag {
    public abstract virtual void Persist();
    public abstract virtual void SetProperty(string propertyName, int value);
    public abstract virtual void SetProperty(string propertyName, string value);
    public abstract virtual void SetProperty(string propertyName, double value);
    public abstract virtual object GetProperty(string propertyName);
    public abstract virtual void RemoveProperty(string propertyName);
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, object>> GetAllProperties();
    public abstract virtual void Clear();
}
internal interface Microsoft.VisualStudio.Telemetry.Common.IStorageBuilder {
    public string StorageDirectoryPath { get; }
    public string StorageFolderName { get; }
    public abstract virtual string get_StorageDirectoryPath();
    public abstract virtual string get_StorageFolderName();
    public abstract virtual bool CanDelete(string fullFilePath);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Logging.DefaultTextWriterFactory : object {
    public sealed virtual TextWriter CreateTextWriter(string fullPathName);
}
internal interface Microsoft.VisualStudio.Telemetry.Common.Logging.ILocalFileLogger {
    public bool Enabled { get; public set; }
    public string FullLogPath { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual string get_FullLogPath();
    public abstract virtual void Log(LocalLoggerSeverity severity, string componentId, string text);
}
internal interface Microsoft.VisualStudio.Telemetry.Common.Logging.ITextWriterFactory {
    public abstract virtual TextWriter CreateTextWriter(string fullPathName);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Logging.LocalFileLogger : object {
    private static string UnknownName;
    private static int sequenceNumber;
    private ITextWriterFactory textWriterFactory;
    private int disposeCount;
    [NullableAttribute("2")]
private TextWriter writer;
    private bool isEnabled;
    [CompilerGeneratedAttribute]
private string <FullLogPath>k__BackingField;
    public bool Enabled { get; public set; }
    public string FullLogPath { get; }
    public LocalFileLogger(string logFilePath);
    internal LocalFileLogger(ITextWriterFactory textWriterFactory, string logFilePath);
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullLogPath();
    public sealed virtual void Log(LocalLoggerSeverity severity, string componentId, string text);
    public sealed virtual void Dispose();
    internal static string GenerateLogFileName();
    private void Dispose(bool disposing);
    private void CreateOrOpenFile();
    private void CloseFile();
}
internal static class Microsoft.VisualStudio.Telemetry.Common.Logging.LocalFileLoggerService : object {
    private static object lockDefaultLoggerObject;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static ILocalFileLogger <DefaultLogger>k__BackingField;
    [NullableAttribute("2")]
private static ILocalFileLogger DefaultLogger { get; private set; }
    public static ILocalFileLogger Default { get; }
    private static LocalFileLoggerService();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private static ILocalFileLogger get_DefaultLogger();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private static void set_DefaultLogger(ILocalFileLogger value);
    public static ILocalFileLogger get_Default();
}
internal enum Microsoft.VisualStudio.Telemetry.Common.Logging.LocalLoggerSeverity : Enum {
    public int value__;
    public static LocalLoggerSeverity Info;
    public static LocalLoggerSeverity Warning;
    public static LocalLoggerSeverity Error;
    public static LocalLoggerSeverity Critical;
}
internal class Microsoft.VisualStudio.Telemetry.Common.Logging.NullLocalFileLogger : object {
    [CompilerGeneratedAttribute]
private string <FullLogPath>k__BackingField;
    public bool Enabled { get; public set; }
    public string FullLogPath { get; }
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullLogPath();
    public sealed virtual void Log(LocalLoggerSeverity severity, string componentId, string text);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal interface Microsoft.VisualStudio.Telemetry.Common.Policy.IPolicyId {
    public string PolicyId { get; }
    public abstract virtual string get_PolicyId();
}
internal class Microsoft.VisualStudio.Telemetry.Common.Policy.VSCodePrivacyPolicy : object {
    private Lazy`1<string> policyId;
    public string PolicyId { get; }
    public VSCodePrivacyPolicy(string globalStorageUri);
    public sealed virtual string get_PolicyId();
    private static string GeneratePolicyId(string iKey, string globalStorageUri);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Policy.VSPrivacyPolicy : object {
    private Lazy`1<string> policyId;
    public string PolicyId { get; }
    public VSPrivacyPolicy(string vsMajorVersion);
    public sealed virtual string get_PolicyId();
    private static string GeneratePolicyId(string vsMajorVersion);
}
internal interface Microsoft.VisualStudio.Telemetry.Common.SQM.ISQMApi {
    public abstract virtual Guid ReadSharedMachineId();
    public abstract virtual bool SetSharedMachineId(Guid machineId);
    public abstract virtual Guid ReadSharedUserId();
    public abstract virtual bool ReadSqmIsTest();
    public abstract virtual bool ReadSqmIsMSFTInternal();
}
internal class Microsoft.VisualStudio.Telemetry.Common.SQM.MonoSQMApi : SQMApi {
    protected virtual string ReadMachineIdFromRegistry(IRegistryTools registry, string regPath, string regKey);
    protected virtual bool SaveMachineIdToRegistry(IRegistryTools registry, string regPath, string regKey, string machineId);
}
internal class Microsoft.VisualStudio.Telemetry.Common.SQM.SQMApi : object {
    private static object userIdCalculation;
    private static string MachineIdRegPath;
    private static string MachineIdRegKey;
    private static string SqmIsTestRegKey;
    private static string SqmClientPolicyRegPath;
    private static string SqmMsftInternalRegKey;
    private static string UserIdRegPath;
    private static string UserIdRegKey;
    private static SQMApi();
    public sealed virtual Guid ReadSharedMachineId();
    public sealed virtual bool SetSharedMachineId(Guid machineId);
    public sealed virtual Guid ReadSharedUserId();
    public sealed virtual bool ReadSqmIsTest();
    public sealed virtual bool ReadSqmIsMSFTInternal();
    protected virtual string ReadMachineIdFromRegistry(IRegistryTools registry, string regPath, string regKey);
    protected virtual bool SaveMachineIdToRegistry(IRegistryTools registry, string regPath, string regKey, string machineId);
    private static string FormatGuid(Guid guid);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Storage.LinuxStorageBuilder : StorageBuilderBase {
    public LinuxStorageBuilder(string storageFolderName);
    protected virtual string GetTelemetryStorageFolder();
}
internal class Microsoft.VisualStudio.Telemetry.Common.Storage.MacOsStorageBuilder : StorageBuilderBase {
    public MacOsStorageBuilder(string storageFolderName);
    protected virtual string GetTelemetryStorageFolder();
}
internal enum Microsoft.VisualStudio.Telemetry.Common.Storage.PersistenceVersion : Enum {
    public int value__;
    public static PersistenceVersion Version1;
    public static PersistenceVersion Version2;
}
internal abstract class Microsoft.VisualStudio.Telemetry.Common.Storage.StorageBuilderBase : object {
    private Lazy`1<string> telemetryDirectoryPath;
    [CompilerGeneratedAttribute]
private string <StorageFolderName>k__BackingField;
    public string StorageDirectoryPath { get; }
    public string StorageFolderName { get; }
    public StorageBuilderBase(string storageFolderName);
    public sealed virtual string get_StorageDirectoryPath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_StorageFolderName();
    public virtual bool CanDelete(string fullFileName);
    protected abstract virtual string GetTelemetryStorageFolder();
    [CompilerGeneratedAttribute]
private string <.ctor>b__1_0();
}
internal static class Microsoft.VisualStudio.Telemetry.Common.Storage.StorageBuilderFactory : object {
    internal static IStorageBuilder GetStorageBuilder(string uniqueStorageIdentifier);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Storage.WindowsStorageBuilder : StorageBuilderBase {
    public WindowsStorageBuilder(string storageFolderName);
    public virtual bool CanDelete(string fullFilePath);
    protected virtual string GetTelemetryStorageFolder();
    private static void CheckAccessPermissions(DirectoryInfo telemetryDirectory);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Synchronization.FileBasedMutex : object {
    private string lockFile;
    [NullableAttribute("2")]
private FileSystemWatcher watcher;
    [NullableAttribute("2")]
private AutoResetEvent watcherEvent;
    [NullableAttribute("2")]
private FileStream stream;
    private bool disposed;
    private static SemaphoreSlim inMemoryLock;
    private bool releaseInMemoryLock;
    public FileBasedMutex(string lockFile);
    private static FileBasedMutex();
    public bool AcquireMutex(CancellationToken token);
    public void ReleaseLock();
    public sealed virtual void Dispose();
    private bool InternalAcquireMutex(CancellationToken token);
    private void WatcherDeleted(object sender, FileSystemEventArgs e);
    [CompilerGeneratedAttribute]
private void <AcquireMutex>b__8_0();
}
internal interface Microsoft.VisualStudio.Telemetry.Common.Synchronization.IProcessLock {
    public abstract virtual void Acquire(Action action, CancellationToken cancelToken);
}
internal interface Microsoft.VisualStudio.Telemetry.Common.Synchronization.IProcessLockFactory {
    public abstract virtual IProcessLock CreateLocker(string folderFullName, string prefix);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Synchronization.MonoProcessLock : object {
    private FileBasedMutex mutex;
    public MonoProcessLock(string name);
    public sealed virtual void Acquire(Action action, CancellationToken cancelToken);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.Telemetry.Common.Synchronization.MonoProcessLockFactory : object {
    public sealed virtual IProcessLock CreateLocker(string folderFullName, string prefix);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Synchronization.ProcessLockException : Exception {
    [CompilerGeneratedAttribute]
private bool <IsRetriable>k__BackingField;
    public bool IsRetriable { get; }
    public ProcessLockException(string description, Exception innerException, bool isRetriable);
    [CompilerGeneratedAttribute]
public bool get_IsRetriable();
}
internal class Microsoft.VisualStudio.Telemetry.Common.Synchronization.WindowsProcessLock : object {
    private Mutex mutex;
    private string mutexPath;
    public WindowsProcessLock(string name);
    public sealed virtual void Acquire(Action action, CancellationToken cancelToken);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.Telemetry.Common.Synchronization.WindowsProcessLockFactory : object {
    public sealed virtual IProcessLock CreateLocker(string folderFullName, string prefix);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Tracing.ApplicationNameProvider : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    private string GetApplicationName();
}
internal class Microsoft.VisualStudio.Telemetry.Common.Tracing.CoreEventSource : object {
    public static ICoreEventSource Log;
    private static CoreEventSource();
    private static ICoreEventSource CreateWindowsEventSource();
    private static ICoreEventSource CreateMonoEventSource();
}
internal static class Microsoft.VisualStudio.Telemetry.Common.Tracing.EventSourceKeywords : object {
    public static long UserActionable;
    public static long Diagnostics;
    public static long VerboseFailure;
    public static long ErrorFailure;
    public static long ReservedUserKeywordBegin;
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Common.Tracing.Extensions : object {
    [ExtensionAttribute]
public static string ToInvariantString(Exception exception);
}
internal interface Microsoft.VisualStudio.Telemetry.Common.Tracing.ICoreEventSource {
    public abstract virtual void LogVerbose(string message, string appDomainName);
    public abstract virtual void BuildInfoConfigBrokenXmlError(string msg, string appDomainName);
    public abstract virtual void PopulateRequiredStringWithValue(string parameterName, string telemetryType, string appDomainName);
    public abstract virtual void RequestTelemetryIncorrectDuration(string appDomainName);
    public abstract virtual void LogError(string msg, string appDomainName);
    public abstract virtual void DiagnosticsEventThrottlingHasBeenStartedForTheEvent(int eventId, string appDomainName);
    public abstract virtual void DiagnosticsEventThrottlingHasBeenResetForTheEvent(int eventId, int executionCount, string appDomainName);
    public abstract virtual void DiagnosticsEventThrottlingSchedulerTimerWasCreated(int intervalInMilliseconds, string appDomainName);
    public abstract virtual void DiagnosticsEventThrottlingSchedulerTimerWasRemoved(string appDomainName);
    public abstract virtual void DiagnosticsEventThrottlingSchedulerDisposeTimerFailure(string exception, string appDomainName);
    public abstract virtual void TrackingWasDisabled(string appDomainName);
    public abstract virtual void TrackingWasEnabled(string appDomainName);
    public abstract virtual void TelemetryClientConstructorWithNoTelemetryConfiguration(string appDomainName);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Tracing.MonoEventSource : object {
    public sealed virtual void BuildInfoConfigBrokenXmlError(string msg, string appDomainName);
    public sealed virtual void DiagnosticsEventThrottlingSchedulerDisposeTimerFailure(string exception, string appDomainName);
    public sealed virtual void DiagnosticsEventThrottlingSchedulerTimerWasCreated(int intervalInMilliseconds, string appDomainName);
    public sealed virtual void DiagnosticsEventThrottlingSchedulerTimerWasRemoved(string appDomainName);
    public sealed virtual void DiagnosticsEventThrottlingHasBeenResetForTheEvent(int eventId, int executionCount, string appDomainName);
    public sealed virtual void DiagnosticsEventThrottlingHasBeenStartedForTheEvent(int eventId, string appDomainName);
    public sealed virtual void LogError(string msg, string appDomainName);
    public sealed virtual void LogVerbose(string message, string appDomainName);
    public sealed virtual void PopulateRequiredStringWithValue(string parameterName, string telemetryType, string appDomainName);
    public sealed virtual void RequestTelemetryIncorrectDuration(string appDomainName);
    public sealed virtual void TelemetryClientConstructorWithNoTelemetryConfiguration(string appDomainName);
    public sealed virtual void TrackingWasDisabled(string appDomainName);
    public sealed virtual void TrackingWasEnabled(string appDomainName);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Common.Tracing.SpinWait : object {
    [ExtensionAttribute]
internal static void ExecuteSpinWaitLock(object syncRoot, Action action);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Tracing.ThreadResourceLock : object {
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static object syncObject;
    public static bool IsResourceLocked { get; }
    public static bool get_IsResourceLocked();
    public sealed virtual void Dispose();
}
[EventSourceAttribute]
internal class Microsoft.VisualStudio.Telemetry.Common.Tracing.WindowsCoreEventSource : EventSource {
    private ApplicationNameProvider nameProvider;
    public static WindowsCoreEventSource Log;
    private static WindowsCoreEventSource();
    [EventAttribute("10")]
public sealed virtual void LogVerbose(string msg, string appDomainName);
    [EventAttribute("20")]
public sealed virtual void DiagnosticsEventThrottlingHasBeenStartedForTheEvent(int eventId, string appDomainName);
    [EventAttribute("30")]
public sealed virtual void DiagnosticsEventThrottlingHasBeenResetForTheEvent(int eventId, int executionCount, string appDomainName);
    [EventAttribute("40")]
public sealed virtual void DiagnosticsEventThrottlingSchedulerDisposeTimerFailure(string exception, string appDomainName);
    [EventAttribute("50")]
public sealed virtual void DiagnosticsEventThrottlingSchedulerTimerWasCreated(int intervalInMilliseconds, string appDomainName);
    [EventAttribute("60")]
public sealed virtual void DiagnosticsEventThrottlingSchedulerTimerWasRemoved(string appDomainName);
    [EventAttribute("70")]
public sealed virtual void TelemetryClientConstructorWithNoTelemetryConfiguration(string appDomainName);
    [EventAttribute("71")]
public sealed virtual void PopulateRequiredStringWithValue(string parameterName, string telemetryType, string appDomainName);
    [EventAttribute("72")]
public sealed virtual void RequestTelemetryIncorrectDuration(string appDomainName);
    [EventAttribute("80")]
public sealed virtual void TrackingWasDisabled(string appDomainName);
    [EventAttribute("81")]
public sealed virtual void TrackingWasEnabled(string appDomainName);
    [EventAttribute("90")]
public sealed virtual void LogError(string msg, string appDomainName);
    [EventAttribute("91")]
public sealed virtual void BuildInfoConfigBrokenXmlError(string msg, string appDomainName);
}
internal static class Microsoft.VisualStudio.Telemetry.Common.Utilities.ArchitectureTools : object {
    private static Dictionary`2<ProcessorArchitectureType, string> processorArchitectureName;
    private static ushort PROCESS_INFORMATION_CLASS_22000_ProcessMachineTypeInfo;
    private static ArchitectureTools();
    internal static void GetImageFileMachineArchitectures(String& processArch, String& nativeMachineArch);
    private static void GetImageFileMachineArchitectures(ProcessorArchitectureType& processArch, ProcessorArchitectureType& nativeMachineArch);
    private static void GetImageFileMachineArchitecturesWindows(ProcessorArchitectureType& processArch, ProcessorArchitectureType& nativeMachineArch);
    private static ProcessorArchitectureType ImageFileMachineToProcessArchitectureType(IMAGE_FILE_MACHINE imageFileMachine);
    private static ProcessorArchitectureType GetOSArchitecture();
    private static ProcessorArchitectureType GetProcessArchitecture();
    private static ProcessorArchitectureType ConvertRuntimeArchToProcessorArchType(Architecture architecture);
}
internal static class Microsoft.VisualStudio.Telemetry.Common.Utilities.BiosFirmwareTableParser : object {
    private static string BiosSerialNumberNotAvailable;
    internal static int MinimumTableLength;
    [CompilerGeneratedAttribute]
private static Version <MinimumSupportedBiosVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static Dictionary`2<int, Func`3<BinaryReader, BiosInformation, BiosInformation>> <SectionProcessorLookup>k__BackingField;
    private static Version MinimumSupportedBiosVersion { get; }
    private static Dictionary`2<int, Func`3<BinaryReader, BiosInformation, BiosInformation>> SectionProcessorLookup { get; }
    private static BiosFirmwareTableParser();
    [CompilerGeneratedAttribute]
private static Version get_MinimumSupportedBiosVersion();
    [CompilerGeneratedAttribute]
private static Dictionary`2<int, Func`3<BinaryReader, BiosInformation, BiosInformation>> get_SectionProcessorLookup();
    internal static BiosInformation ParseBiosFirmwareTable(Memory`1<byte> biosFirmwareTable);
    private static int GoToNextSectionToParse(BinaryReader br);
    private static IList`1<string> GetStringsFromStringsSection(BinaryReader br);
    private static BiosInformation ProcessBiosSystemInformation(BinaryReader br, BiosInformation biosInformation);
    internal static BiosInformation ParseBiosFirmwareTable(Stream biosFirmwareTable);
}
internal enum Microsoft.VisualStudio.Telemetry.Common.Utilities.BiosFirmwareTableParserError : Enum {
    public int value__;
    public static BiosFirmwareTableParserError Success;
    public static BiosFirmwareTableParserError SpecVersionUnsupported;
    public static BiosFirmwareTableParserError TableTooSmall;
    public static BiosFirmwareTableParserError RequiredSectionNotFound;
    public static BiosFirmwareTableParserError SerialNumberOrdinalIndexOutOfBound;
}
internal class Microsoft.VisualStudio.Telemetry.Common.Utilities.BiosInformation : ValueType {
    public Version SpecVersion;
    public long TableSize;
    public string SerialNumber;
    public Guid UUID;
    public BiosFirmwareTableParserError Error;
}
internal class Microsoft.VisualStudio.Telemetry.Common.Utilities.EnvironmentTools : object {
    public string Version { get; }
    public sealed virtual string get_Version();
    public sealed virtual string GetEnvironmentVariable(string key);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Utilities.FipsCompliantSha : object {
    private static ThreadLocal`1<HashAlgorithm> LocalSHA256Instance;
    private static FipsCompliantSha();
    private static HashAlgorithm CreateEncryptor();
    public static string SHA256Hash(string input, Encoding encoding);
    public static Byte[] SHA256HashToBytes(string input, Encoding encoding);
}
internal interface Microsoft.VisualStudio.Telemetry.Common.Utilities.IEnvironmentTools {
    public string Version { get; }
    public abstract virtual string get_Version();
    public abstract virtual string GetEnvironmentVariable(string key);
}
internal interface Microsoft.VisualStudio.Telemetry.Common.Utilities.IProcessTools {
    public abstract virtual void RunCommand(string commandName, Action`1<string> onProcessComplete);
    public abstract virtual void RunCommand(string commandName, Action`1<string> onProcessComplete, string commandArgs);
}
internal interface Microsoft.VisualStudio.Telemetry.Common.Utilities.IRegistryToolsHelper {
    public IRegistryTools4 RegistryTools { get; }
    public ProductTarget ProductTarget { get; }
    public string TelemetryRegistryPathBase { get; }
    public string GlobalPolicyRegistryPathBase { get; }
    public abstract virtual IRegistryTools4 get_RegistryTools();
    public abstract virtual ProductTarget get_ProductTarget();
    public abstract virtual string get_TelemetryRegistryPathBase();
    public abstract virtual string get_GlobalPolicyRegistryPathBase();
    public abstract virtual bool SetRegistryFromCurrentUserRoot(string regKeyName, object value);
    public abstract virtual object GetRegistryValueFromCurrentUserRoot(string regKeyName, object defaultOnError);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Common.Utilities.NativeFlagsEx : object {
    [ExtensionAttribute]
internal static FILE_ACCESS_FLAGS ToFILE_ACCESS_FLAGS(FileAccess fileAccess);
    [ExtensionAttribute]
internal static FILE_SHARE_MODE ToFILE_SHARE_MODE(FileShare fileShare);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Telemetry.Common.Utilities.NativeMethods : object {
    internal static string GetFullProcessExeName();
    internal static Nullable`1<long> GetProcessCreationTime();
    internal static Nullable`1<ulong> GetProcessCreationFileTime();
    internal static Nullable`1<UInt32> GetCurrentThreadId();
    internal static Nullable`1<UInt32> GetCurrentProcessId();
    private static string GetFullProcessExeNameWindows();
    private static Nullable`1<ulong> GetProcessCreationFileTimeWindows();
    private static Nullable`1<long> GetProcessCreationTimeWindows();
    private static DateTime FiletimeToDateTime(FILETIME fileTime);
    private static ulong FiletimeToULong(FILETIME fileTime);
}
internal static class Microsoft.VisualStudio.Telemetry.Common.Utilities.PlatformHelper : object {
    public static bool IsWindows { get; }
    public static bool IsLinux { get; }
    public static bool IsMacOs { get; }
    public static bool get_IsWindows();
    public static bool get_IsLinux();
    public static bool get_IsMacOs();
}
internal class Microsoft.VisualStudio.Telemetry.Common.Utilities.ProductDetectionTools : object {
    internal static ProductTarget GetProduct(string collectorApiKey);
    internal static ProductTarget GetProduct(string asimovIKey, string collectorApiKey);
}
internal enum Microsoft.VisualStudio.Telemetry.Common.Utilities.ProductTarget : Enum {
    public int value__;
    public static ProductTarget VSCode;
    public static ProductTarget Other;
}
internal class Microsoft.VisualStudio.Telemetry.Common.Utilities.RegistryToolsHelper : object {
    [NullableAttribute("2")]
protected static IRegistryToolsHelper instance;
    private static string VSTelemetryRegKeyPath;
    private static string VSCodeTelemetryRegKeyPath;
    private ProductTarget productTarget;
    [CompilerGeneratedAttribute]
private IRegistryTools4 <RegistryTools>k__BackingField;
    public static IRegistryToolsHelper Instance { get; }
    public IRegistryTools4 RegistryTools { get; protected set; }
    public ProductTarget ProductTarget { get; }
    public string TelemetryRegistryPathBase { get; }
    public string GlobalPolicyRegistryPathBase { get; }
    protected RegistryToolsHelper(ProductTarget productTarget);
    public static IRegistryToolsHelper get_Instance();
    public static void Initialize(ProductTarget productTarget);
    [CompilerGeneratedAttribute]
public sealed virtual IRegistryTools4 get_RegistryTools();
    [CompilerGeneratedAttribute]
protected void set_RegistryTools(IRegistryTools4 value);
    public sealed virtual ProductTarget get_ProductTarget();
    public sealed virtual string get_TelemetryRegistryPathBase();
    public sealed virtual string get_GlobalPolicyRegistryPathBase();
    public sealed virtual bool SetRegistryFromCurrentUserRoot(string regKeyName, object value);
    public sealed virtual object GetRegistryValueFromCurrentUserRoot(string regKeyName, object defaultOnError);
}
internal class Microsoft.VisualStudio.Telemetry.Common.Utilities.ShellCommandRunner : object {
    internal static string RunCommand(string command, string args);
}
internal class Microsoft.VisualStudio.Telemetry.CommonProperty.CommonPropertyParser1 : object {
    private IDictionary`2<string, object> loadedData;
    private static string GlobalStorageUriV1PropertyName;
    public CommonPropertyParser1(IDictionary`2& data);
    public sealed virtual void SetSettingsAndLoadCommonProps(TelemetrySessionInternalBase session);
}
internal class Microsoft.VisualStudio.Telemetry.CommonProperty.CommonPropertyParser2 : object {
    internal static string CommonPropertyParserEventName;
    internal static string BucketFilterErrorMessage;
    private IDictionary`2<string, object> loadedData;
    public CommonPropertyParser2(IDictionary`2& data);
    public sealed virtual void SetSettingsAndLoadCommonProps(TelemetrySessionInternalBase session);
}
internal static class Microsoft.VisualStudio.Telemetry.CommonProperty.CommonPropertyParserFactory : object {
    private static string CommonPropertyBagPathEnvironmentVariableName;
    private static string CommonPropertyBagWithConfigPathEnvironmentVariableName;
    internal static ICommonPropertyParser GetCommonPropertyParser(TelemetrySessionInternalBase session);
}
internal class Microsoft.VisualStudio.Telemetry.CommonProperty.FileBasedKeyValuesLoader : object {
    internal static string LoadCommonPropsEventName;
    internal static string LoadCommonPropsFaultDescription;
    internal static string LoadCommonPropsFaultEventName;
    private static FileBasedKeyValuesLoader();
    public sealed virtual IDictionary`2<string, object> GetData(TelemetrySession session, string filePath);
}
internal interface Microsoft.VisualStudio.Telemetry.CommonProperty.ICommonPropertyParser {
    public abstract virtual void SetSettingsAndLoadCommonProps(TelemetrySessionInternalBase session);
}
internal interface Microsoft.VisualStudio.Telemetry.CommonProperty.IExternalKeyValuesLoader {
    public abstract virtual IDictionary`2<string, object> GetData(TelemetrySession session, string source);
}
internal class Microsoft.VisualStudio.Telemetry.ComplexObjectSerializerException : Exception {
    public ComplexObjectSerializerException(string message, Exception innerException);
}
internal class Microsoft.VisualStudio.Telemetry.ComplexPropertyAction : object {
    internal static int MaxSerializedLength;
    internal static string FailedToSerializePropertyName;
    internal static string TruncatedPropertyName;
    private IComplexObjectSerializerFactory serializerFactory;
    private IPiiPropertyProcessor piiProcessor;
    private Func`2<object, string> converterToHashValue;
    private Func`2<object, string> converterToRawValue;
    private IComplexObjectSerializer serializer;
    public int Priority { get; }
    public ComplexPropertyAction(IComplexObjectSerializerFactory serializerFactory, IPiiPropertyProcessor piiProcessor);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    private void EnsureSerializerIsInitialized();
    private void SerializeProperty(string propertyName, TelemetryComplexProperty propertyValue, IEventProcessorContext eventProcessorContext, List`1<KeyValuePair`2<string, string>> propertiesToModify);
    [CompilerGeneratedAttribute]
private string <.ctor>b__10_0(object value);
    [CompilerGeneratedAttribute]
private string <.ctor>b__10_1(object value);
}
internal class Microsoft.VisualStudio.Telemetry.CredScanAction : object {
    internal static string ElapsedTimePropertyName;
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
}
public static class Microsoft.VisualStudio.Telemetry.DataModelEventNameHelper : object {
    private static char Separator;
    public static void SetProductFeatureEntityName(OperationEvent operationEvent);
    public static void SetProductFeatureEntityName(FaultEvent faultEvent);
    public static void SetProductFeatureEntityName(AssetEvent assetEvent);
    private static void SetProductFeatureEntityName(string eventName, PrefixedNotConcurrent`1<object> reservedProperties);
    private static void ValidateEventName(string eventName);
}
public enum Microsoft.VisualStudio.Telemetry.DataModelEventType : Enum {
    public int value__;
    public static DataModelEventType UserTask;
    public static DataModelEventType Trace;
    public static DataModelEventType Operation;
    public static DataModelEventType Fault;
    public static DataModelEventType Asset;
}
internal static class Microsoft.VisualStudio.Telemetry.DataModelEventTypeNames : object {
    internal static string GetName(DataModelEventType eventType);
}
internal abstract class Microsoft.VisualStudio.Telemetry.DataModelPropertyAction`1 : object {
    private HashSet`1<string> properties;
    private static string UnknownValue;
    private int totalPropertyCount;
    private string flagPropertyName;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuffixName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DiagnosticName>k__BackingField;
    public int Priority { get; }
    public string SuffixName { get; }
    public string DiagnosticName { get; }
    public DataModelPropertyAction`1(int priority, string suffixName, string flagName, string diagnosticName);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public string get_SuffixName();
    [CompilerGeneratedAttribute]
public string get_DiagnosticName();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void PostDiagnosticInformation(TelemetrySession mainSession, TelemetryManifest newManifest);
}
internal class Microsoft.VisualStudio.Telemetry.DataModelPropertyNames : object {
    internal static string DataModelPrefix;
    internal static string DataModelSource;
    internal static string EventType;
    internal static string EventSchemaVersion;
    internal static string ProductName;
    internal static string FeatureName;
    internal static string EntityName;
    internal static string Severity;
    internal static string Correlation;
    internal static string CorrelationPrefix;
}
internal class Microsoft.VisualStudio.Telemetry.DefaultContextPropertyManager : TelemetryDisposableObject {
    private List`1<IPropertyProvider> propertyProviders;
    private CancellationTokenSource cancellationTokenSource;
    public DefaultContextPropertyManager(IEnumerable`1<IPropertyProvider> propertyProviders);
    public sealed virtual void AddPropertyProvider(IPropertyProvider propertyProvider);
    public sealed virtual void AddDefaultContextProperties(TelemetryContext telemetryContext);
    public sealed virtual void PostDefaultContextProperties(TelemetryContext telemetryContext);
    protected virtual void DisposeManagedResources();
    public sealed virtual void AddRealtimeDefaultContextProperties(TelemetryContext telemetryContext);
}
internal class Microsoft.VisualStudio.Telemetry.DiagnosticTelemetry : object {
    private ConcurrentDictionary`2<string, string> registrySettings;
    private static string RegistrySettingsPrefix;
    public sealed virtual void LogRegistrySettings(string settingsName, string value);
    public sealed virtual void PostDiagnosticTelemetryWhenSessionInitialized(TelemetrySession telemetrySession, IEnumerable`1<KeyValuePair`2<string, object>> propertyBag);
    private static bool ShouldHashTelemetryAssemblyPath(String& assemblyPath);
}
internal class Microsoft.VisualStudio.Telemetry.DisabledTelemetryChannelValidator : object {
    private IInternalSettings internalSettings;
    public DisabledTelemetryChannelValidator(IInternalSettings internalSettings);
    public sealed virtual bool IsValid(ISessionChannel channelToValidate);
}
internal class Microsoft.VisualStudio.Telemetry.EnforceAIRestrictionAction : object {
    private static int MaxPropertyNameLength;
    private static int MaxPropertyValueLength;
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    private static bool IsPropertyValueValid(string value);
    private static bool IsPropertyNameValid(string propertyName);
}
internal class Microsoft.VisualStudio.Telemetry.EventProcessor : TelemetryDisposableObject {
    private IEventProcessorContext eventProcessorContext;
    private TelemetrySession mainSession;
    private List`1<IEventProcessorAction> customActionList;
    private object updateManifestLock;
    private Lazy`1<ISensitiveDataScrubber> sensitiveDataScrubber;
    private static string RedactionString;
    private TelemetryManifest currentManifest;
    private bool diagnosticNeedsToBePosted;
    internal TelemetryManifest CurrentManifest { get; internal set; }
    internal IEventProcessorContext EventProcessorContext { get; }
    public EventProcessor(TelemetrySession session, IEventProcessorContext eventProcessorContext);
    internal TelemetryManifest get_CurrentManifest();
    internal void set_CurrentManifest(TelemetryManifest value);
    internal IEventProcessorContext get_EventProcessorContext();
    public sealed virtual void ProcessEvent(TelemetryEvent telemetryEvent);
    private static void ScrubPropertiesAndReservedProperties(TelemetryEvent telemetryEvent, ISensitiveDataScrubber scrubber);
    private static void ScrubProperties(IDictionary`2<string, object> properties, ISensitiveDataScrubber scrubber, bool scrubAllPersonalData);
    public void AddChannel(ISessionChannel channel);
    public sealed virtual void AddCustomAction(IEventProcessorAction eventProcessorAction);
    public void PostDiagnosticInformationIfNeeded();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.EventProcessor/<DisposeAndTransmitAsync>d__20")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    protected virtual void DisposeManagedResources();
    private void UpdateManifest(TelemetryManifest manifestToBeUpdated);
    private void PostDiagnosticInformation(TelemetryManifest newManifest);
    private IEnumerable`1<IEventProcessorAction> GetMergedCustomAndManifestActionsInOrder(IEnumerable`1<ITelemetryManifestAction> manifestActions);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0();
}
internal class Microsoft.VisualStudio.Telemetry.EventProcessorChannelBuilder : object {
    private IPersistentPropertyBag persistentPropertyBag;
    private ITelemetryScheduler telemetryScheduler;
    [CompilerGeneratedAttribute]
private EventProcessor <EventProcessor>k__BackingField;
    [CompilerGeneratedAttribute]
private EventProcessorChannel <EventProcessorChannel>k__BackingField;
    [CompilerGeneratedAttribute]
private EventProcessorContext <EventProcessorContext>k__BackingField;
    [CompilerGeneratedAttribute]
private EventProcessorRouter <EventProcessorRouter>k__BackingField;
    public EventProcessor EventProcessor { get; private set; }
    public EventProcessorChannel EventProcessorChannel { get; private set; }
    public EventProcessorContext EventProcessorContext { get; private set; }
    public EventProcessorRouter EventProcessorRouter { get; private set; }
    public EventProcessorChannelBuilder(IPersistentPropertyBag persistentPropertyBag, ITelemetryScheduler telemetryScheduler);
    [CompilerGeneratedAttribute]
public EventProcessor get_EventProcessor();
    [CompilerGeneratedAttribute]
private void set_EventProcessor(EventProcessor value);
    [CompilerGeneratedAttribute]
public EventProcessorChannel get_EventProcessorChannel();
    [CompilerGeneratedAttribute]
private void set_EventProcessorChannel(EventProcessorChannel value);
    [CompilerGeneratedAttribute]
public EventProcessorContext get_EventProcessorContext();
    [CompilerGeneratedAttribute]
private void set_EventProcessorContext(EventProcessorContext value);
    [CompilerGeneratedAttribute]
public EventProcessorRouter get_EventProcessorRouter();
    [CompilerGeneratedAttribute]
private void set_EventProcessorRouter(EventProcessorRouter value);
    public void Build(TelemetrySession hostSession);
    private EventProcessorChannel BuildChannel(IEventProcessor eventProcessor, TelemetrySession telemetrySession);
    private EventProcessor BuildProcessor(TelemetrySession hostSession, IEventProcessorContext context);
    private EventProcessorContext BuildContext(TelemetrySession hostSession, IEventProcessorRouter eventProcessorRouter);
    private EventProcessorRouter BuildRouter();
}
internal class Microsoft.VisualStudio.Telemetry.EventProcessorContext : TelemetryDisposableObject {
    private TelemetrySession hostTelemetrySession;
    private IEventProcessorRouter eventProcessorRouter;
    private TelemetryEvent workerTelemetryEvent;
    private Dictionary`2<string, object> excludedProperties;
    [CompilerGeneratedAttribute]
private bool <IsEventDropped>k__BackingField;
    [CompilerGeneratedAttribute]
private ThrottlingAction <ThrottlingAction>k__BackingField;
    public bool IsEventDropped { get; public set; }
    public ThrottlingAction ThrottlingAction { get; public set; }
    public TelemetrySession HostTelemetrySession { get; }
    public IEventProcessorRouter Router { get; }
    public TelemetryEvent TelemetryEvent { get; }
    public EventProcessorContext(TelemetrySession hostTelemetrySession, IEventProcessorRouter eventProcessorRouter);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEventDropped();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsEventDropped(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ThrottlingAction get_ThrottlingAction();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ThrottlingAction(ThrottlingAction value);
    public sealed virtual TelemetrySession get_HostTelemetrySession();
    public sealed virtual IEventProcessorRouter get_Router();
    public sealed virtual TelemetryEvent get_TelemetryEvent();
    public sealed virtual void InitForNewEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void ExcludePropertyFromEvent(string propertyName);
    public sealed virtual void IncludePropertyToEvent(string propertyName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.EventProcessorContext/<DisposeAndTransmitAsync>d__22")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    protected virtual void DisposeManagedResources();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0();
}
internal class Microsoft.VisualStudio.Telemetry.EventProcessorRouter : TelemetryDisposableObject {
    private static string ChannelUsedProperty;
    private IPersistentPropertyBag persistentPropertyBag;
    private Stopwatch disposeLatencyTimer;
    private RouteInformation[] routeInformation;
    private Dictionary`2<string, int> channelMapping;
    private ConcurrentBag`1<ISessionChannel> channelList;
    public EventProcessorRouter(IPersistentPropertyBag persistentPropertyBag);
    public sealed virtual void Reset();
    public sealed virtual bool TryGetRouteArgument(string channelId, IEnumerable`1& routeArguments);
    public sealed virtual bool TryAddRouteArgument(string channelId, ITelemetryManifestRouteArgs routeArguments);
    public sealed virtual void DisableChannel(string channelId);
    public sealed virtual bool IsChannelDisabled(string channelId);
    public sealed virtual void AddChannel(ISessionChannel channel);
    public sealed virtual void RouteEvent(TelemetryEvent telemetryEvent, string sessionId, bool isDropped);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.EventProcessorRouter/<DisposeAndTransmitAsync>d__14")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    protected virtual void DisposeManagedResources();
    private void DisposeStart();
    private void DisposeEnd();
    private void RemoveAllChannels();
    private void OnUpdateChannelList();
    public sealed virtual void UpdateDefaultChannel(bool useCollector);
}
public class Microsoft.VisualStudio.Telemetry.FaultEvent : TelemetryEvent {
    internal static string InternalFaultEventName;
    internal static int WatsonMaxParamLength;
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <WatsonSamplePercent>k__BackingField;
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <MaximumWatsonReportsPerSession>k__BackingField;
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <MinimumSecondsBetweenWatsonReports>k__BackingField;
    [ObsoleteAttribute("This property is obsolete. Use TelemetrySession.BucketFiltersToEnableWatsonForFaults to enable Watson reports for fault events. They are disabled by default.", "False")]
public static List`1<BucketFilter> BucketFiltersToDisableWatsonReport;
    [ObsoleteAttribute("This property is obsolete. Use TelemetrySession.BucketFiltersToAddDumpsToFaults to add process dumps to fault events. They are disabled by default.", "False")]
public static List`1<BucketFilter> BucketFiltersToAddProcessDump;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsIncludedInWatsonSample>k__BackingField;
    [CompilerGeneratedAttribute]
private WER_DUMP_TYPE <DumpCollectionType>k__BackingField;
    internal static string watsonEventTypeVisualStudioNonFatalErrors2;
    [CompilerGeneratedAttribute]
private string <WatsonEventType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SynchronousDumpCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ExceptionObject>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IFaultUtility, int> <GatherEventDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultSeverity <FaultSeverity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PostThisEventToTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BucketParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<int> <ListProcessIdsToDump>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ListFilesToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <SBuilderAdditionalUserErrorInfo>k__BackingField;
    internal FaultEventWatsonOptIn UserOptInToWatson;
    [CompilerGeneratedAttribute]
private bool <AddedErrorInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddedProcessDump>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddedFile>k__BackingField;
    public static Nullable`1<int> WatsonSamplePercent { get; public set; }
    public static Nullable`1<int> MaximumWatsonReportsPerSession { get; public set; }
    public static Nullable`1<int> MinimumSecondsBetweenWatsonReports { get; public set; }
    public Nullable`1<bool> IsIncludedInWatsonSample { get; public set; }
    public WER_DUMP_TYPE DumpCollectionType { get; public set; }
    public string WatsonEventType { get; public set; }
    public bool SynchronousDumpCollection { get; public set; }
    internal string Description { get; }
    internal Exception ExceptionObject { get; }
    internal Func`2<IFaultUtility, int> GatherEventDetails { get; }
    internal FaultSeverity FaultSeverity { get; internal set; }
    internal bool PostThisEventToTelemetry { get; internal set; }
    internal String[] BucketParameters { get; internal set; }
    internal List`1<int> ListProcessIdsToDump { get; }
    internal List`1<string> ListFilesToAdd { get; }
    internal StringBuilder SBuilderAdditionalUserErrorInfo { get; }
    internal bool AddedErrorInformation { get; internal set; }
    internal bool AddedProcessDump { get; internal set; }
    internal bool AddedFile { get; internal set; }
    public FaultEvent(string eventName, string description, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails);
    public FaultEvent(string eventName, string description, FaultSeverity faultSeverity, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails);
    private static FaultEvent();
    [CompilerGeneratedAttribute]
public static Nullable`1<int> get_WatsonSamplePercent();
    [CompilerGeneratedAttribute]
public static void set_WatsonSamplePercent(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public static Nullable`1<int> get_MaximumWatsonReportsPerSession();
    [CompilerGeneratedAttribute]
public static void set_MaximumWatsonReportsPerSession(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public static Nullable`1<int> get_MinimumSecondsBetweenWatsonReports();
    [CompilerGeneratedAttribute]
public static void set_MinimumSecondsBetweenWatsonReports(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsIncludedInWatsonSample();
    [CompilerGeneratedAttribute]
public void set_IsIncludedInWatsonSample(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public WER_DUMP_TYPE get_DumpCollectionType();
    [CompilerGeneratedAttribute]
public void set_DumpCollectionType(WER_DUMP_TYPE value);
    [CompilerGeneratedAttribute]
public string get_WatsonEventType();
    [CompilerGeneratedAttribute]
public void set_WatsonEventType(string value);
    [CompilerGeneratedAttribute]
public bool get_SynchronousDumpCollection();
    [CompilerGeneratedAttribute]
public void set_SynchronousDumpCollection(bool value);
    [CompilerGeneratedAttribute]
internal string get_Description();
    [CompilerGeneratedAttribute]
internal Exception get_ExceptionObject();
    [CompilerGeneratedAttribute]
internal Func`2<IFaultUtility, int> get_GatherEventDetails();
    [CompilerGeneratedAttribute]
internal FaultSeverity get_FaultSeverity();
    [CompilerGeneratedAttribute]
internal void set_FaultSeverity(FaultSeverity value);
    [CompilerGeneratedAttribute]
internal bool get_PostThisEventToTelemetry();
    [CompilerGeneratedAttribute]
internal void set_PostThisEventToTelemetry(bool value);
    [CompilerGeneratedAttribute]
internal String[] get_BucketParameters();
    [CompilerGeneratedAttribute]
internal void set_BucketParameters(String[] value);
    [CompilerGeneratedAttribute]
internal List`1<int> get_ListProcessIdsToDump();
    [CompilerGeneratedAttribute]
internal List`1<string> get_ListFilesToAdd();
    [CompilerGeneratedAttribute]
internal StringBuilder get_SBuilderAdditionalUserErrorInfo();
    [CompilerGeneratedAttribute]
internal bool get_AddedErrorInformation();
    [CompilerGeneratedAttribute]
internal void set_AddedErrorInformation(bool value);
    [CompilerGeneratedAttribute]
internal bool get_AddedProcessDump();
    [CompilerGeneratedAttribute]
internal void set_AddedProcessDump(bool value);
    [CompilerGeneratedAttribute]
internal bool get_AddedFile();
    [CompilerGeneratedAttribute]
internal void set_AddedFile(bool value);
    public sealed virtual void AddErrorInformation(string information);
    public sealed virtual void AddProcessDump(int pid);
    public sealed virtual void SetBucketParameter(int bucketNumber, string newBucketValue);
    public void SetAppName(string appName);
    public void SetAppVersion(string appVersion);
    public void SetFailureParameters(string failureParameter0, string failureParameter1, string failureParameter2, string failureParameter3, string failureParameter4);
    public void SetNonFailureParameters(string nonFailureParameter0, string nonFailureParameter1);
    internal static string TrucateToMaxWatsonParamLength(string input);
    public sealed virtual string GetBucketParameter(int bucketNumber);
    public sealed virtual void AddFile(string fullPathFileName);
    public virtual string ToString();
    internal static WER_DUMP_TYPE GetDumpTypeFromString(string dumpType);
    [CompilerGeneratedAttribute]
private void <AddErrorInformation>b__79_0(string line);
}
public enum Microsoft.VisualStudio.Telemetry.FaultSeverity : Enum {
    public int value__;
    public static FaultSeverity Uncategorized;
    public static FaultSeverity Diagnostic;
    public static FaultSeverity General;
    public static FaultSeverity Critical;
    public static FaultSeverity Crash;
}
internal enum Microsoft.VisualStudio.Telemetry.HashInput : Enum {
    public int value__;
    public static HashInput MachineId;
    public static HashInput UserId;
    public static HashInput RuleId;
    public static HashInput SamplingId;
    public static HashInput SessionId;
}
public interface Microsoft.VisualStudio.Telemetry.IAssetProvider {
    public abstract virtual bool PostAsset(string assetId, TelemetryEventCorrelation correlation);
}
internal interface Microsoft.VisualStudio.Telemetry.IAssetServiceThreadScheduler {
    public abstract virtual void Schedule(Action action);
}
internal interface Microsoft.VisualStudio.Telemetry.IChannelValidator {
    public abstract virtual bool IsValid(ISessionChannel channelToValidate);
}
internal interface Microsoft.VisualStudio.Telemetry.IComplexObjectSerializer {
    public abstract virtual string Serialize(object obj);
    public abstract virtual void SetTypeConverter(Type type, Func`2<object, string> converter);
    public abstract virtual bool WasConverterUsedForType(Type type);
}
internal interface Microsoft.VisualStudio.Telemetry.IComplexObjectSerializerFactory {
    public abstract virtual IComplexObjectSerializer Instance();
}
internal interface Microsoft.VisualStudio.Telemetry.IContextPropertyManager {
    public abstract virtual void AddPropertyProvider(IPropertyProvider propertyProvider);
    public abstract virtual void AddDefaultContextProperties(TelemetryContext telemetryContext);
    public abstract virtual void AddRealtimeDefaultContextProperties(TelemetryContext telemetryContext);
    public abstract virtual void PostDefaultContextProperties(TelemetryContext telemetryContext);
}
internal interface Microsoft.VisualStudio.Telemetry.IDiagnosticTelemetry {
    public abstract virtual void LogRegistrySettings(string settingsName, string value);
    public abstract virtual void PostDiagnosticTelemetryWhenSessionInitialized(TelemetrySession telemetrySession, IEnumerable`1<KeyValuePair`2<string, object>> propertyBag);
}
internal interface Microsoft.VisualStudio.Telemetry.IEventProcessor {
    public abstract virtual void ProcessEvent(TelemetryEvent telemetryEvent);
    public abstract virtual void AddCustomAction(IEventProcessorAction eventProcessorAction);
    public abstract virtual Task DisposeAndTransmitAsync(CancellationToken token);
}
internal interface Microsoft.VisualStudio.Telemetry.IEventProcessorAction {
    public int Priority { get; }
    public abstract virtual int get_Priority();
    public abstract virtual bool Execute(IEventProcessorContext eventProcessorContext);
}
internal interface Microsoft.VisualStudio.Telemetry.IEventProcessorActionDiagnostics {
    public abstract virtual void PostDiagnosticInformation(TelemetrySession mainSession, TelemetryManifest newManifest);
}
internal interface Microsoft.VisualStudio.Telemetry.IEventProcessorContext {
    public bool IsEventDropped { get; public set; }
    public ThrottlingAction ThrottlingAction { get; public set; }
    public TelemetrySession HostTelemetrySession { get; }
    public IEventProcessorRouter Router { get; }
    public TelemetryEvent TelemetryEvent { get; }
    public abstract virtual bool get_IsEventDropped();
    public abstract virtual void set_IsEventDropped(bool value);
    public abstract virtual ThrottlingAction get_ThrottlingAction();
    public abstract virtual void set_ThrottlingAction(ThrottlingAction value);
    public abstract virtual TelemetrySession get_HostTelemetrySession();
    public abstract virtual IEventProcessorRouter get_Router();
    public abstract virtual TelemetryEvent get_TelemetryEvent();
    public abstract virtual void InitForNewEvent(TelemetryEvent telemetryEvent);
    public abstract virtual void ExcludePropertyFromEvent(string propertyName);
    public abstract virtual void IncludePropertyToEvent(string propertyName);
    public abstract virtual Task DisposeAndTransmitAsync(CancellationToken token);
}
internal interface Microsoft.VisualStudio.Telemetry.IEventProcessorRouter {
    public abstract virtual void Reset();
    public abstract virtual bool TryGetRouteArgument(string channelId, IEnumerable`1& routeArguments);
    public abstract virtual bool TryAddRouteArgument(string channelId, ITelemetryManifestRouteArgs routeArgument);
    public abstract virtual void DisableChannel(string channelId);
    public abstract virtual bool IsChannelDisabled(string channelId);
    public abstract virtual void AddChannel(ISessionChannel channel);
    public abstract virtual void RouteEvent(TelemetryEvent telemetryEvent, string sessionId, bool isDropped);
    public abstract virtual Task DisposeAndTransmitAsync(CancellationToken token);
    public abstract virtual void UpdateDefaultChannel(bool useCollector);
}
public interface Microsoft.VisualStudio.Telemetry.IFaultUtility {
    public abstract virtual void AddErrorInformation(string information);
    public abstract virtual void AddProcessDump(int pid);
    public abstract virtual void AddFile(string fullpathname);
    public abstract virtual void SetBucketParameter(int bucketNumber, string value);
    public abstract virtual string GetBucketParameter(int bucketNumber);
}
internal interface Microsoft.VisualStudio.Telemetry.IHostInformationProvider {
    public string ProcessName { get; }
    public UInt32 ProcessId { get; }
    public string ProcessExeVersion { get; }
    public Nullable`1<int> ProcessBuildNumber { get; }
    public bool IsDebuggerAttached { get; }
    public bool Is64BitProcess { get; }
    public string OSBitness { get; }
    public abstract virtual string get_ProcessName();
    public abstract virtual UInt32 get_ProcessId();
    public abstract virtual string get_ProcessExeVersion();
    public abstract virtual Nullable`1<int> get_ProcessBuildNumber();
    public abstract virtual bool get_IsDebuggerAttached();
    public abstract virtual bool get_Is64BitProcess();
    public abstract virtual string get_OSBitness();
}
internal interface Microsoft.VisualStudio.Telemetry.IInternalSettings {
    public abstract virtual bool IsForcedUserExternal();
    public abstract virtual bool TryGetTestHostName(String& testHostName);
    public abstract virtual bool TryGetTestAppId(UInt32& testAppId);
    public abstract virtual ChannelInternalSetting GetChannelSettings(string channelId);
    public abstract virtual string GetIPGlobalConfigDomainName();
    public abstract virtual bool IsTelemetryDisabledCompletely();
    public abstract virtual bool IsLocalLoggerEnabled();
    public abstract virtual int FaultEventWatsonSamplePercent();
    public abstract virtual int FaultEventMaximumWatsonReportsPerSession();
    public abstract virtual int FaultEventMinimumSecondsBetweenWatsonReports();
}
[NullableContextAttribute("2")]
internal interface Microsoft.VisualStudio.Telemetry.InformationProviders.IUniqueIdentifierInformationProvider {
    [NullableAttribute("0")]
public string DevMachineId { get; }
    public bool DevMachineIdCacheExists { get; }
    [NullableAttribute("0")]
public string InstallationId { get; }
    public string InstallationIdCached { get; }
    public bool InstallationIdChanged { get; }
    public bool InstallationIdCacheExists { get; }
    public bool InstallationIdCreatedInitial { get; }
    public string MachineGuidCurrent { get; }
    public bool MachineGuidChanged { get; }
    public bool MachineGuidCacheExists { get; }
    public string MachineGuidCached { get; }
    public string DriveSerialNumberCurrent { get; }
    public bool DriveSerialNumberChanged { get; }
    public bool DriveSerialNumberCacheExists { get; }
    public string DriveSerialNumberCached { get; }
    public string UuidCurrent { get; }
    public bool UuidChanged { get; }
    public bool UuidCacheExists { get; }
    public string UuidCached { get; }
    [NullableContextAttribute("0")]
public abstract virtual string get_DevMachineId();
    public abstract virtual bool get_DevMachineIdCacheExists();
    [NullableContextAttribute("0")]
public abstract virtual string get_InstallationId();
    public abstract virtual string get_InstallationIdCached();
    public abstract virtual bool get_InstallationIdChanged();
    public abstract virtual bool get_InstallationIdCacheExists();
    public abstract virtual bool get_InstallationIdCreatedInitial();
    public abstract virtual string get_MachineGuidCurrent();
    public abstract virtual bool get_MachineGuidChanged();
    public abstract virtual bool get_MachineGuidCacheExists();
    public abstract virtual string get_MachineGuidCached();
    public abstract virtual string get_DriveSerialNumberCurrent();
    public abstract virtual bool get_DriveSerialNumberChanged();
    public abstract virtual bool get_DriveSerialNumberCacheExists();
    public abstract virtual string get_DriveSerialNumberCached();
    public abstract virtual string get_UuidCurrent();
    public abstract virtual bool get_UuidChanged();
    public abstract virtual bool get_UuidCacheExists();
    public abstract virtual string get_UuidCached();
    [NullableContextAttribute("0")]
public abstract virtual void ReportError(string method, Exception e, string message);
    [NullableContextAttribute("0")]
public abstract virtual void ReportError(string method, string message);
    public abstract virtual string GetErrors();
}
internal class Microsoft.VisualStudio.Telemetry.InformationProviders.LinuxUniqueIdentifierInformationProvider : MonoUniqueIdentifierInformationProviderBase {
    protected string StorageDirectoryBase { get; }
    [NullableContextAttribute("2")]
protected virtual string InitializeUUID();
    [NullableContextAttribute("2")]
protected virtual string InitializeDriveSerialNumber();
    [NullableContextAttribute("2")]
protected virtual string InitializeMachineGuid();
    protected virtual string get_StorageDirectoryBase();
    protected static BlockDeviceInfo FindRootDevice(BlockDeviceInfo[] blockDevices);
}
internal class Microsoft.VisualStudio.Telemetry.InformationProviders.MacUniqueIdentifierInformationProvider : MonoUniqueIdentifierInformationProviderBase {
    protected string StorageDirectoryBase { get; }
    [NullableContextAttribute("2")]
protected virtual string InitializeUUID();
    [NullableContextAttribute("2")]
protected virtual string InitializeDriveSerialNumber();
    [NullableContextAttribute("2")]
protected virtual string InitializeMachineGuid();
    protected virtual string get_StorageDirectoryBase();
}
internal abstract class Microsoft.VisualStudio.Telemetry.InformationProviders.Mono.MonoUniqueIdentifierInformationProviderBase : UniqueIdentifierInformationProviderBase {
    private static string UuidCacheFileName;
    private static string DriveSerialNumberCacheFileName;
    private static string MachineGuidCacheFileName;
    protected Lazy`1<string> shellPathLazy;
    protected virtual void PersistUuid();
    protected virtual void PersistDriveSerialNumber();
    protected virtual void PersistMachineGuid();
    [NullableContextAttribute("2")]
protected virtual string GetCachedBiosUuid(Boolean& cacheExists);
    [NullableContextAttribute("2")]
protected virtual string GetCachedDriveSerialNumber(Boolean& cacheExists);
    [NullableContextAttribute("2")]
protected virtual string GetCachedMachineGuid(Boolean& cacheExists);
    protected virtual void DeleteHardwareCache();
    private string GetHardwareValueFromFile(string fileName, Boolean& cacheExists);
    private bool PersistHardwareValueToFile(string fileName, string value);
    private string GenerateHardwareCacheFilePath(string hardwareCacheFileName);
    private static string RemoveWhiteSpace(string input);
    private string GetShell();
    [CompilerGeneratedAttribute]
private string <.ctor>b__4_0();
}
internal abstract class Microsoft.VisualStudio.Telemetry.InformationProviders.UniqueIdentifierInformationProviderBase : object {
    private static string InstallationIdFileName;
    private static string DevMachineIdFileName;
    private Lazy`1<string> currentUUIDLazy;
    private Lazy`1<string> currentDriveSerialNumberLazy;
    private Lazy`1<string> currentMachineGuidLazy;
    private Lazy`1<string> installationIdLazy;
    private Lazy`1<string> devMachineIdLazy;
    private Lazy`1<string> installationIdFilePathLazy;
    [CompilerGeneratedAttribute]
private bool <UuidChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UuidCacheExists>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <UuidCached>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MachineGuidChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MachineGuidCacheExists>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <MachineGuidCached>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DriveSerialNumberChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DriveSerialNumberCacheExists>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <DriveSerialNumberCached>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallationIdCached>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstallationIdCacheExists>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstallationIdCreatedInitial>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevMachineIdCacheExists>k__BackingField;
    private bool installationIdChanged;
    [CompilerGeneratedAttribute]
private bool <IsWindowsSystemAccount>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ErrorList>k__BackingField;
    private string Microsoft.VisualStudio.Telemetry.Common.Interfaces.IHardwareInformationProvider.Uuid { get; }
    private string Microsoft.VisualStudio.Telemetry.Common.Interfaces.IHardwareInformationProvider.MachineGuid { get; }
    private string Microsoft.VisualStudio.Telemetry.Common.Interfaces.IHardwareInformationProvider.HardDriveSerialNumber { get; }
    [NullableAttribute("2")]
public string UuidCurrent { get; }
    public bool UuidChanged { get; private set; }
    public bool UuidCacheExists { get; private set; }
    [NullableAttribute("2")]
public string UuidCached { get; private set; }
    [NullableAttribute("2")]
public string MachineGuidCurrent { get; }
    public bool MachineGuidChanged { get; private set; }
    public bool MachineGuidCacheExists { get; private set; }
    [NullableAttribute("2")]
public string MachineGuidCached { get; private set; }
    [NullableAttribute("2")]
public string DriveSerialNumberCurrent { get; }
    public bool DriveSerialNumberChanged { get; private set; }
    public bool DriveSerialNumberCacheExists { get; private set; }
    [NullableAttribute("2")]
public string DriveSerialNumberCached { get; private set; }
    public string InstallationId { get; }
    public string InstallationIdCached { get; private set; }
    public bool InstallationIdCacheExists { get; private set; }
    public bool InstallationIdCreatedInitial { get; private set; }
    public string DevMachineId { get; }
    public bool DevMachineIdCacheExists { get; private set; }
    public bool InstallationIdChanged { get; }
    public bool IsWindowsSystemAccount { get; private set; }
    private List`1<string> ErrorList { get; }
    protected string StorageDirectoryBase { get; }
    private sealed virtual override string Microsoft.VisualStudio.Telemetry.Common.Interfaces.IHardwareInformationProvider.get_Uuid();
    private sealed virtual override string Microsoft.VisualStudio.Telemetry.Common.Interfaces.IHardwareInformationProvider.get_MachineGuid();
    private sealed virtual override string Microsoft.VisualStudio.Telemetry.Common.Interfaces.IHardwareInformationProvider.get_HardDriveSerialNumber();
    [NullableContextAttribute("2")]
public sealed virtual string get_UuidCurrent();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UuidChanged();
    [CompilerGeneratedAttribute]
private void set_UuidChanged(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UuidCacheExists();
    [CompilerGeneratedAttribute]
private void set_UuidCacheExists(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_UuidCached();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_UuidCached(string value);
    [NullableContextAttribute("2")]
public sealed virtual string get_MachineGuidCurrent();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_MachineGuidChanged();
    [CompilerGeneratedAttribute]
private void set_MachineGuidChanged(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_MachineGuidCacheExists();
    [CompilerGeneratedAttribute]
private void set_MachineGuidCacheExists(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_MachineGuidCached();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_MachineGuidCached(string value);
    [NullableContextAttribute("2")]
public sealed virtual string get_DriveSerialNumberCurrent();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DriveSerialNumberChanged();
    [CompilerGeneratedAttribute]
private void set_DriveSerialNumberChanged(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DriveSerialNumberCacheExists();
    [CompilerGeneratedAttribute]
private void set_DriveSerialNumberCacheExists(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_DriveSerialNumberCached();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_DriveSerialNumberCached(string value);
    public sealed virtual string get_InstallationId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_InstallationIdCached();
    [CompilerGeneratedAttribute]
private void set_InstallationIdCached(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_InstallationIdCacheExists();
    [CompilerGeneratedAttribute]
private void set_InstallationIdCacheExists(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_InstallationIdCreatedInitial();
    [CompilerGeneratedAttribute]
private void set_InstallationIdCreatedInitial(bool value);
    public sealed virtual string get_DevMachineId();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevMachineIdCacheExists();
    [CompilerGeneratedAttribute]
private void set_DevMachineIdCacheExists(bool value);
    public sealed virtual bool get_InstallationIdChanged();
    [CompilerGeneratedAttribute]
public bool get_IsWindowsSystemAccount();
    [CompilerGeneratedAttribute]
private void set_IsWindowsSystemAccount(bool value);
    [CompilerGeneratedAttribute]
private List`1<string> get_ErrorList();
    public sealed virtual void ReportError(string method, Exception e, string message);
    public sealed virtual void ReportError(string method, string message);
    [NullableContextAttribute("2")]
public sealed virtual string GetErrors();
    protected abstract virtual string get_StorageDirectoryBase();
    [NullableContextAttribute("2")]
protected abstract virtual string InitializeUUID();
    [NullableContextAttribute("2")]
protected abstract virtual string InitializeMachineGuid();
    [NullableContextAttribute("2")]
protected abstract virtual string InitializeDriveSerialNumber();
    protected abstract virtual void PersistUuid();
    protected abstract virtual void PersistMachineGuid();
    protected abstract virtual void PersistDriveSerialNumber();
    protected abstract virtual string GetCachedBiosUuid(Boolean& cacheExists);
    protected abstract virtual string GetCachedMachineGuid(Boolean& cacheExists);
    protected abstract virtual string GetCachedDriveSerialNumber(Boolean& cacheExists);
    protected abstract virtual void DeleteHardwareCache();
    protected string GetDevMachineId();
    protected string GetInstallationId();
    private string PersistCurrentIdentifiers();
    protected string GenerateCacheFilePath(string fileName);
    protected bool CheckCachedHardwareIdsAreCurrent();
    protected virtual string GetCachedDevMachineId(Boolean& cacheExists);
    [NullableContextAttribute("2")]
protected virtual string GetCachedInstallationId(Boolean& cacheExists);
    protected virtual bool DeleteInstallationIdFile();
    protected virtual bool PersistDevMachineId(string devMachineId);
    protected virtual bool PersistInstallationId(string installationId);
    protected void InitializeCachedHardwareIds();
    protected bool PersistIdToFile(string path, string id);
    protected string GetIdFromFile(string path, Boolean& fileExists);
    [CompilerGeneratedAttribute]
private string <.ctor>b__86_0();
    [CompilerGeneratedAttribute]
private string <.ctor>b__86_1();
    [CompilerGeneratedAttribute]
private string <.ctor>b__86_2();
    [CompilerGeneratedAttribute]
private string <.ctor>b__86_3();
    [CompilerGeneratedAttribute]
private string <.ctor>b__86_4();
    [CompilerGeneratedAttribute]
private string <.ctor>b__86_5();
}
internal class Microsoft.VisualStudio.Telemetry.InformationProviders.WindowsUniqueIdentifierInformationProvider : UniqueIdentifierInformationProviderBase {
    private static string InstallationIdRegistryName;
    private static string DevMachineIdRegistryName;
    private static string DevMachineRegistryPath;
    private static string IdentifierRegistryPath;
    private static RegistryHive UniqueIdRegistryHive;
    private static string MachineGuidCachedKeyName;
    private static string DriveSerialNumberCachedKeyName;
    private static string UuidCachedKeyName;
    private WindowsBiosUuidInformationProvider windowsBiosUuidInformationProvider;
    public Lazy`1<bool> IsSystemAccountLazy;
    private string diskBasedInstallationId;
    private string diskBasedInstallationIdCached;
    private Nullable`1<bool> diskBasedInstallationIdCacheExists;
    [CompilerGeneratedAttribute]
private bool <DiskBasedInstallationIdCreatedInitial>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DiskBasedInstallationIdHasChanged>k__BackingField;
    [NullableAttribute("2")]
private string storageDirectoryBase;
    public string DiskBasedInstallationId { get; private set; }
    [NullableAttribute("2")]
public string DiskBasedInstallationIdCached { get; }
    public bool DiskBasedInstallationIdCacheExists { get; }
    public bool DiskBasedInstallationIdCreatedInitial { get; private set; }
    public bool DiskBasedInstallationIdHasChanged { get; private set; }
    protected string StorageDirectoryBase { get; }
    public string get_DiskBasedInstallationId();
    private void set_DiskBasedInstallationId(string value);
    [NullableContextAttribute("2")]
public string get_DiskBasedInstallationIdCached();
    public bool get_DiskBasedInstallationIdCacheExists();
    [CompilerGeneratedAttribute]
public bool get_DiskBasedInstallationIdCreatedInitial();
    [CompilerGeneratedAttribute]
private void set_DiskBasedInstallationIdCreatedInitial(bool value);
    [CompilerGeneratedAttribute]
public bool get_DiskBasedInstallationIdHasChanged();
    [CompilerGeneratedAttribute]
private void set_DiskBasedInstallationIdHasChanged(bool value);
    [NullableContextAttribute("2")]
protected virtual string InitializeUUID();
    [NullableContextAttribute("2")]
protected virtual string InitializeDriveSerialNumber();
    [NullableContextAttribute("2")]
protected virtual string InitializeMachineGuid();
    protected virtual string GetCachedInstallationId(Boolean& cacheExists);
    protected virtual bool DeleteInstallationIdFile();
    protected virtual void DeleteHardwareCache();
    protected virtual string GetCachedDevMachineId(Boolean& cacheExists);
    protected virtual bool PersistDevMachineId(string devMachineId);
    private void InitializeDiskBasedInstallationId();
    private void DeleteDiskBasedInstallationId();
    private static string GetFinalProgramDataPath();
    protected virtual string get_StorageDirectoryBase();
    protected virtual bool PersistInstallationId(string installationId);
    private void PersistDiskBasedInstallationId(string installationId);
    protected virtual void PersistUuid();
    protected virtual void PersistMachineGuid();
    protected virtual void PersistDriveSerialNumber();
    [NullableContextAttribute("2")]
protected virtual string GetCachedMachineGuid(Boolean& cacheExists);
    [NullableContextAttribute("2")]
protected virtual string GetCachedDriveSerialNumber(Boolean& cacheExists);
    [NullableContextAttribute("2")]
protected virtual string GetCachedBiosUuid(Boolean& cacheExists);
    private static bool IsSystemAccount();
    private void SetRegistryValueInDevMachinePath(string name, string regValue);
    private string GetRegistryValueInDevMachinePath(string name, Boolean& exists);
    private void SetRegistryValueInIdentifierPath(string name, string regValue);
    private string GetRegistryValueInIdentifierPath(string name, Boolean& exists);
    protected void DeleteIdentifierRegistryKey();
    private static bool DeviceIoControl(SafeHandle hDevice, UInt32 dwIoControlCode, Void* lpInBuffer, int nInBufferSize, Void* lpOutBuffer, int nOutBufferSize, UInt32& lpBytesReturned, IntPtr lpOverlapped);
    private static bool GetVolumeNameForVolumeMountPoint(string mountPoint, StringBuilder name, UInt32 bufferLength);
}
internal interface Microsoft.VisualStudio.Telemetry.INsBundleInformationProvider {
    public abstract virtual string GetName();
    public abstract virtual string GetVersion();
}
internal class Microsoft.VisualStudio.Telemetry.InternalChannelValidator : object {
    private IUserInformationProvider userInformationProvider;
    public InternalChannelValidator(IUserInformationProvider theUserInformationProvider);
    public sealed virtual bool IsValid(ISessionChannel channelToValidate);
}
internal class Microsoft.VisualStudio.Telemetry.InternalSettingsBase : object {
    internal static string TelemetryUserRegKeyPath;
    internal static string CompletelyDisabledTelemetryRegKeyName;
    internal static string LocalLoggerEnabledRegKeyName;
    internal static int LocalLoggerEnabled;
    internal static int CompletelyDisabledTelemetry;
    private static string RegKeyChannelSettings;
    private static int ChannelExplicitlyEnabled;
    private static int ChannelExplicitlyDisabled;
    private static string ForceExternalUserRegKeyName;
    private static int ForcedUserExternal;
    private static string TestHostNameRegKeyName;
    private static string TestAppIdRegKeyName;
    protected IDiagnosticTelemetry diagnosticTelemetry;
    public InternalSettingsBase(IDiagnosticTelemetry diagnosticTelemetry);
    public virtual ChannelInternalSetting GetChannelSettings(string channelId);
    public sealed virtual bool IsForcedUserExternal();
    public sealed virtual bool TryGetTestAppId(UInt32& testAppId);
    public sealed virtual bool TryGetTestHostName(String& testHostName);
    public sealed virtual string GetIPGlobalConfigDomainName();
    public sealed virtual bool IsTelemetryDisabledCompletely();
    public sealed virtual bool IsLocalLoggerEnabled();
    public virtual int FaultEventWatsonSamplePercent();
    public virtual int FaultEventMaximumWatsonReportsPerSession();
    public virtual int FaultEventMinimumSecondsBetweenWatsonReports();
}
internal interface Microsoft.VisualStudio.Telemetry.IPiiPropertyProcessor {
    public abstract virtual Type TypeOfPiiProperty();
    public abstract virtual Type TypeOfHashedProperty();
    public abstract virtual object ConvertToRawValue(object value);
    public abstract virtual string ConvertToHashedValue(object value);
    public abstract virtual bool CanAddRawValue(IEventProcessorContext eventProcessorContext);
    public abstract virtual string BuildRawPropertyName(string propertyName);
}
internal interface Microsoft.VisualStudio.Telemetry.IProcessCreationTime {
    public abstract virtual long GetProcessCreationTime();
}
internal interface Microsoft.VisualStudio.Telemetry.IPropertyProvider {
    public abstract virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public abstract virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
internal interface Microsoft.VisualStudio.Telemetry.IRealtimePropertyProvider {
    public abstract virtual void AddRealtimeSharedProperties(List`1<KeyValuePair`2<string, Func`1<object>>> sharedProperties, TelemetryContext telemetryContext);
}
public interface Microsoft.VisualStudio.Telemetry.ISetTelemetrySession {
    public abstract virtual void SetSession(TelemetrySession session);
}
internal interface Microsoft.VisualStudio.Telemetry.IStreamParser {
    public abstract virtual Task`1<object> ParseAsync(TextReader stream);
}
internal interface Microsoft.VisualStudio.Telemetry.IStreamSerializer {
    public abstract virtual Task SerializeAsync(object objectToSerialize, TextWriter stream);
}
public interface Microsoft.VisualStudio.Telemetry.ITelemetryEtwProvider {
    public abstract virtual void WriteActivityStartEvent(TelemetryActivity activity);
    public abstract virtual void WriteActivityStopEvent(TelemetryActivity activity);
    public abstract virtual void WriteActivityEndWithDurationEvent(TelemetryActivity activity);
    public abstract virtual void WriteActivityPostEvent(TelemetryActivity activity, TelemetrySession session);
    public abstract virtual void WriteTelemetryPostEvent(TelemetryEvent telemetryEvent, TelemetrySession session);
}
public interface Microsoft.VisualStudio.Telemetry.ITelemetryEventMatch {
    public abstract virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryLogFile`1 {
    public abstract virtual void Initialize(ITelemetryLogSettingsProvider settingsProvider);
    public abstract virtual void WriteAsync(T telemetryEvent);
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryLogSettingsProvider {
    public IEnumerable`1<KeyValuePair`2<string, string>> MainIdentifiers { get; public set; }
    public string Path { get; public set; }
    public string Folder { get; public set; }
    public string FilePath { get; }
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_MainIdentifiers();
    public abstract virtual void set_MainIdentifiers(IEnumerable`1<KeyValuePair`2<string, string>> value);
    public abstract virtual string get_Path();
    public abstract virtual void set_Path(string value);
    public abstract virtual string get_Folder();
    public abstract virtual void set_Folder(string value);
    public abstract virtual string get_FilePath();
    public abstract virtual string GetCreateFolderPath();
    public abstract virtual int GetNextUniqueId();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestAction {
    public abstract virtual void Validate();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestManager {
    public bool ForcedReadManifest { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_UpdateTelemetryManifestStatusEvent(EventHandler`1<TelemetryManifestEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UpdateTelemetryManifestStatusEvent(EventHandler`1<TelemetryManifestEventArgs> value);
    public abstract virtual bool get_ForcedReadManifest();
    public abstract virtual void Start(string hostName, bool isDisposing);
    public abstract virtual bool ForceReadManifest();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestManagerBuilder {
    public abstract virtual ITelemetryManifestManager Build(TelemetrySession telemetrySession);
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestManagerSettings {
    public string BaseUrl { get; }
    public string HostId { get; }
    public string RelativePath { get; }
    public abstract virtual string get_BaseUrl();
    public abstract virtual string get_HostId();
    public abstract virtual string get_RelativePath();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch {
    public abstract virtual void ValidateItself();
    public abstract virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatchValue {
    public abstract virtual bool IsMatch(object valueToCompare);
    public abstract virtual void Validate();
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestParser {
    public abstract virtual TelemetryManifest Parse(string jsonString);
}
public interface Microsoft.VisualStudio.Telemetry.ITelemetryManifestRouteArgs {
    public abstract virtual void Validate();
}
public interface Microsoft.VisualStudio.Telemetry.ITelemetryPropertyBag`1 {
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryScheduler {
    public abstract virtual void Schedule(Action action, Nullable`1<CancellationToken> token);
    public abstract virtual void Schedule(Func`1<Task> actionTask, Nullable`1<CancellationToken> token);
    public abstract virtual void InitializeTimed(TimeSpan delay);
    public abstract virtual void ScheduleTimed(Action action, bool recurring);
    public abstract virtual void ScheduleTimed(Func`1<Task> actionTask, bool recurring);
    public abstract virtual bool CanEnterTimedDelegate();
    public abstract virtual void ExitTimedDelegate();
    public abstract virtual void CancelTimed(bool wait);
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal {
    public string SessionId { get; }
    public VisualStudioCodeTelemetryLevel TelemetryLevel { get; }
    public ProductTarget HostProduct { get; }
    public bool IsOptedIn { get; public set; }
    public bool UseCollector { get; public set; }
    public List`1<BucketFilter> BucketFiltersToEnableWatsonForFaults { get; public set; }
    public List`1<BucketFilter> BucketFiltersToAddDumpsToFaults { get; public set; }
    public string HostName { get; public set; }
    public CancellationToken CancellationToken { get; }
    public UInt32 AppId { get; public set; }
    public bool CanCollectPrivateInformation { get; }
    public bool IsUserMicrosoftInternal { get; }
    public string CalculatedSamplings { get; }
    public Guid MachineId { get; }
    public Guid UserId { get; }
    public string MacAddressHash { get; }
    unknown Action InitializedAction {public set; }
    public EventHandler`1<TelemetryTestChannelEventArgs> RawTelemetryEventReceived { get; public set; }
    public EventProcessor EventProcessor { get; }
    public TelemetryContext DefaultContext { get; }
    public ITelemetryManifestManager ManifestManager { get; }
    public TelemetrySessionSettings SessionSettings { get; }
    public long ProcessStartTime { get; }
    public int ProcessPid { get; }
    public bool IsSessionCloned { get; }
    public string GlobalStorageUri { get; public set; }
    public long TimeSinceSessionStart { get; }
    public abstract virtual TelemetrySession GetHostTelemetrySession();
    public abstract virtual string get_SessionId();
    public abstract virtual VisualStudioCodeTelemetryLevel get_TelemetryLevel();
    public abstract virtual ProductTarget get_HostProduct();
    public abstract virtual bool get_IsOptedIn();
    public abstract virtual void set_IsOptedIn(bool value);
    public abstract virtual bool get_UseCollector();
    public abstract virtual void set_UseCollector(bool value);
    public abstract virtual List`1<BucketFilter> get_BucketFiltersToEnableWatsonForFaults();
    public abstract virtual void set_BucketFiltersToEnableWatsonForFaults(List`1<BucketFilter> value);
    public abstract virtual List`1<BucketFilter> get_BucketFiltersToAddDumpsToFaults();
    public abstract virtual void set_BucketFiltersToAddDumpsToFaults(List`1<BucketFilter> value);
    public abstract virtual string get_HostName();
    public abstract virtual void set_HostName(string value);
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual UInt32 get_AppId();
    public abstract virtual void set_AppId(UInt32 value);
    public abstract virtual bool get_CanCollectPrivateInformation();
    public abstract virtual bool get_IsUserMicrosoftInternal();
    public abstract virtual string get_CalculatedSamplings();
    public abstract virtual Guid get_MachineId();
    public abstract virtual Guid get_UserId();
    public abstract virtual string get_MacAddressHash();
    public abstract virtual void set_InitializedAction(Action value);
    public abstract virtual EventHandler`1<TelemetryTestChannelEventArgs> get_RawTelemetryEventReceived();
    public abstract virtual void set_RawTelemetryEventReceived(EventHandler`1<TelemetryTestChannelEventArgs> value);
    public abstract virtual EventProcessor get_EventProcessor();
    public abstract virtual TelemetryContext get_DefaultContext();
    public abstract virtual ITelemetryManifestManager get_ManifestManager();
    public abstract virtual TelemetrySessionSettings get_SessionSettings();
    public abstract virtual void Start(bool checkPendingAsimovEvents);
    public abstract virtual void UseVsIsOptedIn();
    public abstract virtual void UseVsIsOptedIn(string productVersion);
    public abstract virtual TelemetryContext CreateContext(string contextName);
    public abstract virtual TelemetryContext GetContext(string contextName);
    public abstract virtual void PostEvent(string eventName);
    public abstract virtual void PostEvent(TelemetryEvent telemetryEvent);
    public abstract virtual void PostMetricEvent(TelemetryMetricEvent metricEvent);
    public abstract virtual void PostProperty(string propertyName, object propertyValue);
    public abstract virtual void PostRecurringProperty(string propertyName, object propertyValue);
    public abstract virtual void AddSessionChannel(ISessionChannel sessionChannel);
    public abstract virtual string SerializeSettings();
    public abstract virtual void SetSharedProperty(string propertyName, object propertyValue);
    public abstract virtual void RemoveSharedProperty(string propertyName);
    public abstract virtual object GetSharedProperty(string propertyName);
    public abstract virtual object GetSharedPropertyAsObject(string propertyName);
    public abstract virtual void SetPersistedSharedProperty(string propertyName, string propertyValue);
    public abstract virtual void SetPersistedSharedProperty(string propertyName, double propertyValue);
    public abstract virtual void SetPersistedSharedProperty(string propertyName, object propertyValue, Action addToBagAction);
    public abstract virtual void RemovePersistedSharedProperty(string propertyName);
    public abstract virtual object GetPersistedSharedProperty(string propertyName);
    public abstract virtual void RegisterPropertyBag(string name, TelemetryPropertyBag propertyBag);
    public abstract virtual void UnregisterPropertyBag(string name);
    public abstract virtual TelemetryPropertyBag GetPropertyBag(string name);
    public abstract virtual Task DisposeToNetworkAsync(CancellationToken token);
    public abstract virtual void RegisterForReliabilityEvent();
    public abstract virtual long get_ProcessStartTime();
    public abstract virtual int get_ProcessPid();
    public abstract virtual void PostValidatedEvent(TelemetryEvent telemetryEvents);
    public abstract virtual bool get_IsSessionCloned();
    public abstract virtual bool GetCachedUseCollectorFromRegistry();
    public abstract virtual void AddContext(TelemetryContext telemetryContext);
    public abstract virtual void RemoveContext(TelemetryContext telemetryContext);
    public abstract virtual void AddSessionChannels(IEnumerable`1<ISessionChannel> channels);
    public abstract virtual bool SetUseCollectorToRegistry(Nullable`1<bool> value);
    public abstract virtual void AddContextProperties(TelemetryEvent telemetryEvent);
    public abstract virtual void ProcessManifestUseCollectorProperty(TelemetryManifest manifest);
    public abstract virtual string get_GlobalStorageUri();
    public abstract virtual void set_GlobalStorageUri(string value);
    public abstract virtual long get_TimeSinceSessionStart();
    public abstract virtual void AddCommonProperties(IDictionary`2<string, object> properties);
    public abstract virtual bool TryAddCommonProperty(string propertyName, object propertyValue);
    public abstract virtual bool Equals(TelemetrySession other);
    public abstract virtual void LoadCommonProperties();
    public abstract virtual bool TryGetCommonPropertyValue(string propertyName, Object& value);
    public abstract virtual IDictionary`2<string, object> GetCommonPropertyDictionary();
}
public interface Microsoft.VisualStudio.Telemetry.ITelemetryTestChannel {
    public abstract virtual void OnPostEvent(object sender, TelemetryTestChannelEventArgs e);
}
internal interface Microsoft.VisualStudio.Telemetry.ITelemetryWriter {
    public abstract virtual Task WriteLineAsync(string text);
}
internal class Microsoft.VisualStudio.Telemetry.JsonComplexObjectSerializer : object {
    private Lazy`1<CustomJsonConverter> jsonConverter;
    public sealed virtual void SetTypeConverter(Type type, Func`2<object, string> converter);
    public sealed virtual string Serialize(object obj);
    public sealed virtual bool WasConverterUsedForType(Type type);
}
internal class Microsoft.VisualStudio.Telemetry.JsonComplexObjectSerializerFactory : object {
    public sealed virtual IComplexObjectSerializer Instance();
}
public abstract class Microsoft.VisualStudio.Telemetry.JsonCreationConverter`1 : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    internal abstract virtual T Create(Type objectType, JObject jsonObject);
    protected bool FieldExists(string fieldName, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonHelpers.CustomJsonConverter : JsonConverter {
    private Dictionary`2<Type, Func`2<object, string>> typeConverters;
    private HashSet`1<Type> usedConverter;
    public bool CanRead { get; }
    public void AddConverter(Type type, Func`2<object, string> converter);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
    public void ResetUsageInformation();
    public bool WasConverterUsed(Type typeOfConverter);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.JsonHelpers.JsonHelperExtensions : object {
    [ExtensionAttribute]
public static bool FieldExists(JObject jObject, string fieldName);
    [ExtensionAttribute]
public static ITelemetryManifestMatch CreateTelemetryManifestMatch(JObject jObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryEventMatchConverter : JsonCreationConverter`1<ITelemetryEventMatch> {
    internal virtual ITelemetryEventMatch Create(Type objectType, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestActionConverter : JsonCreationConverter`1<ITelemetryManifestAction> {
    internal virtual ITelemetryManifestAction Create(Type objectType, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestMatchConverter : JsonCreationConverter`1<ITelemetryManifestMatch> {
    internal virtual ITelemetryManifestMatch Create(Type objectType, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestMatchValueConverter : JsonCreationConverter`1<ITelemetryManifestMatchValue> {
    internal virtual ITelemetryManifestMatchValue Create(Type objectType, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestParser : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestParser/<ParseAsync>d__0")]
public sealed virtual Task`1<object> ParseAsync(TextReader stream);
    public sealed virtual TelemetryManifest Parse(string jsonString);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestRouteArgsConverter : JsonCreationConverter`1<ITelemetryManifestRouteArgs> {
    internal virtual ITelemetryManifestRouteArgs Create(Type objectType, JObject jsonObject);
}
internal class Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestSerializer : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.JsonTelemetryManifestSerializer/<SerializeAsync>d__0")]
public sealed virtual Task SerializeAsync(object objectToSerialize, TextWriter stream);
}
internal enum Microsoft.VisualStudio.Telemetry.LegacyDatapointType : Enum {
    public int value__;
    public static LegacyDatapointType Bool;
    public static LegacyDatapointType Dword;
    public static LegacyDatapointType Dword64;
    public static LegacyDatapointType String;
}
internal enum Microsoft.VisualStudio.Telemetry.LegacyStringTruncationRule : Enum {
    public int value__;
    public static LegacyStringTruncationRule Right;
    public static LegacyStringTruncationRule Left;
}
internal class Microsoft.VisualStudio.Telemetry.LinuxHostPropertyProvider : object {
    private IHostInformationProvider hostInfoProvider;
    public LinuxHostPropertyProvider(IHostInformationProvider theHostInfoProvider);
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
internal class Microsoft.VisualStudio.Telemetry.LinuxLocalePropertyProvider : MacLocalePropertyProvider {
}
internal class Microsoft.VisualStudio.Telemetry.LinuxMachinePropertyProvider : object {
    private IMachineInformationProvider machineInformationProvider;
    private IMACInformationProvider macInformationProvider;
    public LinuxMachinePropertyProvider(IMachineInformationProvider machineInformationProvider, IMACInformationProvider macInformationProvider);
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
internal class Microsoft.VisualStudio.Telemetry.LinuxUserPropertyProvider : UserPropertyProviderBase {
    public LinuxUserPropertyProvider(IUserInformationProvider userInformationProvider);
    protected virtual bool InitializeUserIsAdminInformation();
    private static UInt32 GetEuid();
}
internal class Microsoft.VisualStudio.Telemetry.MacHostPropertyProvider : BaseHostRealtimePropertyProvider {
    private IHostInformationProvider hostInfoProvider;
    private INsBundleInformationProvider nsBundleInformationProvider;
    private Lazy`1<string> hostExeName;
    private Lazy`1<Version> hostVersionInfo;
    public MacHostPropertyProvider(IHostInformationProvider theHostInfoProvider, INsBundleInformationProvider theNsBundleInformationProvider);
    public virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    private string InitializeHostExeName();
    private Version InitializeHostVersionInfo();
    [CompilerGeneratedAttribute]
private string <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private Version <.ctor>b__4_1();
}
internal class Microsoft.VisualStudio.Telemetry.MacLocalePropertyProvider : object {
    private Lazy`1<CultureInfo> systemInfo;
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private CultureInfo InitializeSystemInformation();
    [CompilerGeneratedAttribute]
private CultureInfo <.ctor>b__1_0();
}
internal class Microsoft.VisualStudio.Telemetry.MacMachinePropertyProvider : object {
    private static long MbInBytes;
    private Lazy`1<SystemInfo> systemInformation;
    private IMachineInformationProvider machineInformationProvider;
    private IMACInformationProvider macInformationProvider;
    public MacMachinePropertyProvider(IMachineInformationProvider machineInformationProvider, IMACInformationProvider macInformationProvider);
    private static MacMachinePropertyProvider();
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private SystemInfo InitializeSystemInformation();
    [CompilerGeneratedAttribute]
private SystemInfo <.ctor>b__4_0();
}
internal class Microsoft.VisualStudio.Telemetry.MacOSPropertyProvider : object {
    private static long MbInBytes;
    private IEnvironmentTools environmentTools;
    private IOSInformationProvider osInformationProvider;
    private Lazy`1<DisplayInformation> displayInfo;
    private Lazy`1<RootDriveInfo> rootDriveInfo;
    private Lazy`1<Nullable`1<long>> totalVolumesSize;
    public MacOSPropertyProvider(IEnvironmentTools envTools, IOSInformationProvider osInformationProvider);
    private static MacOSPropertyProvider();
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private DisplayInformation InitializeDisplayInfo();
    private RootDriveInfo InitializeRootDriveInfo();
    private Nullable`1<long> InitializeTotalVolumeSize();
    [CompilerGeneratedAttribute]
private DisplayInformation <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private RootDriveInfo <.ctor>b__6_1();
    [CompilerGeneratedAttribute]
private Nullable`1<long> <.ctor>b__6_2();
}
internal class Microsoft.VisualStudio.Telemetry.MacUserPropertyProvider : UserPropertyProviderBase {
    public MacUserPropertyProvider(IUserInformationProvider userInformationProvider);
    protected virtual bool InitializeUserIsAdminInformation();
    private static UInt32 GetEuid();
}
internal class Microsoft.VisualStudio.Telemetry.MetricAction : DataModelPropertyAction`1<TelemetryMetricProperty> {
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Counter`1 : CounterBase`1<T> {
    private MonotonicDirection direction;
    internal Counter`1(IMeter meter, string name, string unit, string description);
    protected virtual void RecordMeasurement(T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
}
internal abstract class Microsoft.VisualStudio.Telemetry.Metrics.CounterBase`1 : Instrument`1<T> {
    [CompilerGeneratedAttribute]
private T <Sum>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    private static Lazy`1<CounterPropertyGenerator`1<T>> PropertyGenerator;
    public T Sum { get; private set; }
    public long Count { get; private set; }
    internal CounterBase`1(IMeter meter, string name, string unit, string description);
    private static CounterBase`1();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Sum();
    [CompilerGeneratedAttribute]
private void set_Sum(T value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(long value);
    public sealed virtual void Add(T delta);
    public sealed virtual void Add(T delta, KeyValuePair`2<string, object> tag);
    public sealed virtual void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    public sealed virtual void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    public sealed virtual void Add(T delta, KeyValuePair`2[] tags);
    public sealed virtual void Add(T delta, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    protected virtual void RecordMeasurement(T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.Metrics.Events.IMetricPropertyGenerator.SetProperties(TelemetryMetricEvent metricEvent, IInstrument metric);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.DataPointEqualityComparer`1 : object {
    public sealed virtual int Compare(T x, T y);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Events.BaseMetricPropertyGenerator : object {
    public virtual void SetProperties(TelemetryMetricEvent metricEvent, IInstrument metric);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Events.CounterPropertyGenerator`1 : BaseMetricPropertyGenerator {
    private static string CounterPrefix;
    public virtual void SetProperties(TelemetryMetricEvent metricEvent, IInstrument metric);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Events.HistogramPropertyGenerator`1 : BaseMetricPropertyGenerator {
    private static string HistogramPrefix;
    public virtual void SetProperties(TelemetryMetricEvent metricEvent, IInstrument metric);
}
internal interface Microsoft.VisualStudio.Telemetry.Metrics.Events.IMetricPropertyGenerator {
    public abstract virtual void SetProperties(TelemetryMetricEvent metricEvent, IInstrument metric);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Events.TelemetryCounterEvent`1 : TelemetryMetricEvent {
    public TelemetryCounterEvent`1(TelemetryEvent telemetryEvent, ICounter`1<T> counter);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Events.TelemetryHistogramEvent`1 : TelemetryMetricEvent {
    public TelemetryHistogramEvent`1(TelemetryEvent telemetryEvent, IHistogram`1<T> histogram);
}
public abstract class Microsoft.VisualStudio.Telemetry.Metrics.Events.TelemetryMetricEvent : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IInstrument> <Metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryEvent <MetricEvent>k__BackingField;
    internal static string MetricPrefix;
    internal static string MeterPrefix;
    private IEnumerable`1<IInstrument> Metrics { get; private set; }
    internal TelemetryEvent MetricEvent { get; private set; }
    public TelemetryMetricEvent(TelemetryEvent telemetryEvent, IInstrument metric);
    protected TelemetryMetricEvent(TelemetryEvent telemetryEvent, IEnumerable`1<IInstrument> metrics);
    [CompilerGeneratedAttribute]
private IEnumerable`1<IInstrument> get_Metrics();
    [CompilerGeneratedAttribute]
private void set_Metrics(IEnumerable`1<IInstrument> value);
    [CompilerGeneratedAttribute]
internal TelemetryEvent get_MetricEvent();
    [CompilerGeneratedAttribute]
private void set_MetricEvent(TelemetryEvent value);
    internal void SetProperties();
    internal void SetMetricProperty(string propertyKey, object content, IInstrument metric);
    internal void SetMeterProperty(string propertyKey, object content, IInstrument metric);
    private void SetPropertyInternal(string prefix, string propertyKey, object content, IInstrument metric);
    public virtual string ToString();
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Exceptions.InvalidBucketConfigurationException : ArgumentException {
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Exceptions.InvalidMeterNameException : FormatException {
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Exceptions.NonMonotonicOperationException : InvalidOperationException {
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Exceptions.RegisteredMetricLimitExceededException : InvalidOperationException {
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Exceptions.UnsupportedNumericStructException : FormatException {
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Histogram`1 : Instrument`1<T> {
    [CompilerGeneratedAttribute]
private HistogramStatistics`1<T> <Statistics>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramBuckets`1<T> <Buckets>k__BackingField;
    private HistogramConfiguration configuration;
    private static Lazy`1<HistogramPropertyGenerator`1<T>> PropertyGenerator;
    public HistogramStatistics`1<T> Statistics { get; private set; }
    public HistogramBuckets`1<T> Buckets { get; private set; }
    internal Histogram`1(IMeter meter, string name, string unit, string description);
    internal Histogram`1(IMeter meter, string name, HistogramConfiguration configuration, string unit, string description);
    private static Histogram`1();
    [CompilerGeneratedAttribute]
public sealed virtual HistogramStatistics`1<T> get_Statistics();
    [CompilerGeneratedAttribute]
private void set_Statistics(HistogramStatistics`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual HistogramBuckets`1<T> get_Buckets();
    [CompilerGeneratedAttribute]
private void set_Buckets(HistogramBuckets`1<T> value);
    public sealed virtual void Record(T value);
    public sealed virtual void Record(T value, KeyValuePair`2<string, object> tag);
    public sealed virtual void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    public sealed virtual void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    public sealed virtual void Record(T value, KeyValuePair`2[] tags);
    public sealed virtual void Record(T value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    protected virtual void RecordMeasurement(T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.Metrics.Events.IMetricPropertyGenerator.SetProperties(TelemetryMetricEvent metricEvent, IInstrument metric);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.HistogramBucket`1 : object {
    [CompilerGeneratedAttribute]
private HistogramStatistics`1<T> <Statistics>k__BackingField;
    private double minBoundary;
    private double maxBoundary;
    internal double MinBoundary { get; }
    internal double MaxBoundary { get; }
    internal HistogramStatistics`1<T> Statistics { get; private set; }
    public HistogramBucket`1(double minBoundary, double maxBoundary, IMeter meter, HistogramConfiguration configuration);
    internal double get_MinBoundary();
    internal double get_MaxBoundary();
    [CompilerGeneratedAttribute]
internal HistogramStatistics`1<T> get_Statistics();
    [CompilerGeneratedAttribute]
private void set_Statistics(HistogramStatistics`1<T> value);
    internal bool IsCorrectBucket(double measurement);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.HistogramBuckets`1 : object {
    [CompilerGeneratedAttribute]
private HistogramBucket`1[] <OrderedBuckets>k__BackingField;
    internal HistogramBucket`1[] OrderedBuckets { get; private set; }
    public HistogramBuckets`1(IMeter meter, HistogramConfiguration configuration);
    [CompilerGeneratedAttribute]
internal HistogramBucket`1[] get_OrderedBuckets();
    [CompilerGeneratedAttribute]
private void set_OrderedBuckets(HistogramBucket`1[] value);
    internal void Record(T measurement);
    private void CreateBuckets(IMeter meter, HistogramConfiguration configuration);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.HistogramConfiguration : object {
    private Double[] explicitBuckets;
    private bool recordMinMax;
    private bool recordMedian;
    internal static Double[] DefaultHistogramBuckets;
    internal Double[] ExplicitBuckets { get; }
    internal bool RecordMinMax { get; }
    internal bool RecordMedian { get; }
    public HistogramConfiguration(Double[] explicitBucketBoundaries, bool recordMinMax, bool recordMedian);
    private static HistogramConfiguration();
    internal Double[] get_ExplicitBuckets();
    internal bool get_RecordMinMax();
    internal bool get_RecordMedian();
    private void ValidateBucketOrdering();
}
public class Microsoft.VisualStudio.Telemetry.Metrics.HistogramStatistics`1 : object {
    [CompilerGeneratedAttribute]
private IVSCounter`1<T> <Counter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<T> <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<T> <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FirstRecorded>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastRecorded>k__BackingField;
    private HistogramConfiguration configuration;
    private SortedList`2<T, T> dataPoints;
    public IVSCounter`1<T> Counter { get; private set; }
    public Nullable`1<T> Min { get; private set; }
    public Nullable`1<T> Max { get; private set; }
    public Nullable`1<double> Average { get; }
    public Nullable`1<double> Median { get; }
    public Nullable`1<DateTime> FirstRecorded { get; private set; }
    public Nullable`1<DateTime> LastRecorded { get; private set; }
    public HistogramStatistics`1(IMeter meter, HistogramConfiguration configuration);
    [CompilerGeneratedAttribute]
public IVSCounter`1<T> get_Counter();
    [CompilerGeneratedAttribute]
private void set_Counter(IVSCounter`1<T> value);
    [CompilerGeneratedAttribute]
public Nullable`1<T> get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(Nullable`1<T> value);
    [CompilerGeneratedAttribute]
public Nullable`1<T> get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(Nullable`1<T> value);
    public Nullable`1<double> get_Average();
    public Nullable`1<double> get_Median();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_FirstRecorded();
    [CompilerGeneratedAttribute]
private void set_FirstRecorded(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastRecorded();
    [CompilerGeneratedAttribute]
private void set_LastRecorded(Nullable`1<DateTime> value);
    internal void Record(T measurement);
    internal Nullable`1<double> CalculateMedian();
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.ICounter`1 {
    public abstract virtual void Add(T delta);
    public abstract virtual void Add(T delta, KeyValuePair`2<string, object> tag);
    public abstract virtual void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    public abstract virtual void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    public abstract virtual void Add(T delta, KeyValuePair`2[] tags);
    public abstract virtual void Add(T delta, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IHistogram`1 {
    public abstract virtual void Record(T value);
    public abstract virtual void Record(T value, KeyValuePair`2<string, object> tag);
    public abstract virtual void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    public abstract virtual void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    public abstract virtual void Record(T value, KeyValuePair`2[] tags);
    public abstract virtual void Record(T value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IInstrument {
    public string Name { get; }
    public string Description { get; }
    public IMeter Meter { get; }
    public string Unit { get; }
    public bool Enabled { get; }
    public bool IsObservable { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Description();
    public abstract virtual IMeter get_Meter();
    public abstract virtual string get_Unit();
    public abstract virtual bool get_Enabled();
    public abstract virtual bool get_IsObservable();
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IMeter {
    public string Name { get; }
    public string Version { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Version();
    public abstract virtual ICounter`1<T> CreateCounter(string name, string unit, string description);
    public abstract virtual ICounter`1<T> CreateUpDownCounter(string name, string unit, string description);
    public abstract virtual IVSCounter`1<T> CreateVSCounter(string name, string unit, string description);
    public abstract virtual IVSCounter`1<T> CreateVSUpDownCounter(string name, string unit, string description);
    public abstract virtual IHistogram`1<T> CreateHistogram(string name, string unit, string description);
    public abstract virtual IHistogram`1<T> CreateHistogram(string name, HistogramConfiguration configuration, string unit, string description);
    public abstract virtual IVSHistogram`1<T> CreateVSHistogram(string name, string unit, string description);
    public abstract virtual IVSHistogram`1<T> CreateVSHistogram(string name, HistogramConfiguration configuration, string unit, string description);
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IMeterProvider {
    public abstract virtual IMeter CreateMeter(string name);
    public abstract virtual IMeter CreateMeter(string name, string version);
}
public abstract class Microsoft.VisualStudio.Telemetry.Metrics.Instrument`1 : object {
    private string name;
    private string description;
    private IMeter meter;
    private string unit;
    protected static KeyValuePair`2[] EmptyTags;
    private KeyValuePair`2[] internalTags;
    private static int MAX_TAGS;
    public string Name { get; }
    public string Description { get; }
    public IMeter Meter { get; }
    public string Unit { get; }
    public bool Enabled { get; }
    public bool IsObservable { get; }
    protected KeyValuePair`2[] Tags { get; protected set; }
    internal Instrument`1(IMeter meter, string name, string unit, string description);
    private static Instrument`1();
    public sealed virtual string get_Name();
    public sealed virtual string get_Description();
    public sealed virtual IMeter get_Meter();
    public sealed virtual string get_Unit();
    public sealed virtual bool get_Enabled();
    public sealed virtual bool get_IsObservable();
    protected KeyValuePair`2[] get_Tags();
    protected void set_Tags(KeyValuePair`2[] value);
    protected void Publish();
    protected virtual void RecordMeasurement(T measurement);
    protected virtual void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag);
    protected virtual void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2);
    protected virtual void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3);
    protected abstract virtual void RecordMeasurement(T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IVSCounter`1 {
    public T Sum { get; }
    public long Count { get; }
    public abstract virtual T get_Sum();
    public abstract virtual long get_Count();
}
public interface Microsoft.VisualStudio.Telemetry.Metrics.IVSHistogram`1 {
    public HistogramStatistics`1<T> Statistics { get; }
    public HistogramBuckets`1<T> Buckets { get; }
    public abstract virtual HistogramStatistics`1<T> get_Statistics();
    public abstract virtual HistogramBuckets`1<T> get_Buckets();
}
internal enum Microsoft.VisualStudio.Telemetry.Metrics.Management.MetricDataType : Enum {
    public int value__;
    public static MetricDataType Integer;
    public static MetricDataType FloatingPoint;
}
internal enum Microsoft.VisualStudio.Telemetry.Metrics.Management.MetricInstrumentType : Enum {
    public int value__;
    public static MetricInstrumentType Undefined;
    public static MetricInstrumentType Counter;
    public static MetricInstrumentType Histogram;
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Management.RegisteredCompositeMetricsSet : object {
    private static string RegisteredMetricMeterName;
    private static string RegisteredMetricMeterVersion;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, RegisteredMetric> <Metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, HashSet`1<string>> <CompositeProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryEvent <MetricEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Expiry>k__BackingField;
    [CompilerGeneratedAttribute]
private VSTelemetryMeterProvider <MeterProvider>k__BackingField;
    internal ConcurrentDictionary`2<string, RegisteredMetric> Metrics { get; private set; }
    internal ConcurrentDictionary`2<string, HashSet`1<string>> CompositeProperties { get; private set; }
    internal TelemetryEvent MetricEvent { get; private set; }
    internal DateTime Expiry { get; private set; }
    internal int ConcurrentMetricsCount { get; }
    private VSTelemetryMeterProvider MeterProvider { get; }
    internal RegisteredCompositeMetricsSet(TelemetryEvent metricEvent);
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<string, RegisteredMetric> get_Metrics();
    [CompilerGeneratedAttribute]
private void set_Metrics(ConcurrentDictionary`2<string, RegisteredMetric> value);
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<string, HashSet`1<string>> get_CompositeProperties();
    [CompilerGeneratedAttribute]
private void set_CompositeProperties(ConcurrentDictionary`2<string, HashSet`1<string>> value);
    [CompilerGeneratedAttribute]
internal TelemetryEvent get_MetricEvent();
    [CompilerGeneratedAttribute]
private void set_MetricEvent(TelemetryEvent value);
    [CompilerGeneratedAttribute]
internal DateTime get_Expiry();
    [CompilerGeneratedAttribute]
private void set_Expiry(DateTime value);
    internal int get_ConcurrentMetricsCount();
    [CompilerGeneratedAttribute]
private VSTelemetryMeterProvider get_MeterProvider();
    internal void Record(string metricName, MetricInstrumentType instrumentType, T data, TimeSpan timeout, Double[] buckets, IEnumerable`1<KeyValuePair`2<string, string>> commonProperties);
    internal RegisteredMetric GetMetric(string metricName);
    internal void Close(TelemetrySession session, string separator);
    private RegisteredMetric CreateNewMetric(string metricName, MetricDataType dataType, MetricInstrumentType instrumentType, Double[] buckets);
    private void MergeCompositeProperties(IEnumerable`1<KeyValuePair`2<string, string>> properties);
    private RegisteredMetric CreateRegisteredMetric(string name, MetricDataType dataType, MetricInstrumentType instrumentType, string units, string description, Double[] buckets);
    private void RecordData(RegisteredMetric metric, T data);
    private void RecordFloatingPointData(RegisteredMetric metric, T data);
    private void RecordIntegerData(RegisteredMetric metric, T data);
    private void UpdateExpirationTime(TimeSpan timeout);
    private MetricDataType DetermineMetricDataType(Type specifiedType);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.Management.RegisteredMetric : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstrument <Instrument>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricDataType <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricInstrumentType <InstrumentType>k__BackingField;
    internal string Name { get; private set; }
    internal IInstrument Instrument { get; private set; }
    internal MetricDataType DataType { get; private set; }
    internal MetricInstrumentType InstrumentType { get; private set; }
    public RegisteredMetric(IInstrument instrument, MetricDataType dataType, MetricInstrumentType instrumentType);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
internal IInstrument get_Instrument();
    [CompilerGeneratedAttribute]
private void set_Instrument(IInstrument value);
    [CompilerGeneratedAttribute]
internal MetricDataType get_DataType();
    [CompilerGeneratedAttribute]
private void set_DataType(MetricDataType value);
    [CompilerGeneratedAttribute]
internal MetricInstrumentType get_InstrumentType();
    [CompilerGeneratedAttribute]
private void set_InstrumentType(MetricInstrumentType value);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Management.RegisteredMetricManager : object {
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, RegisteredCompositeMetricsSet> <CompositeMetricSets>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetrySession <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private Timer <ExpirationTimer>k__BackingField;
    public static int DEFAULT_MAX_CONCURRENT_METRICS;
    public static int DEFAULT_TIMEOUT_IN_SECONDS;
    public static string DEFAULT_COMPOSITE_PROPERTY_SEPARATOR;
    public int MaxConcurrentMetrics;
    private int timeoutInSeconds;
    private string compositePropertySeparator;
    private TimeSpan timeout;
    private object metricSetSync;
    private bool disposedValue;
    internal ConcurrentDictionary`2<string, RegisteredCompositeMetricsSet> CompositeMetricSets { get; }
    internal bool IsExpirationTimerRunning { get; }
    private TelemetrySession Session { get; private set; }
    private Timer ExpirationTimer { get; private set; }
    public int ConcurrentMetricsCount { get; }
    public RegisteredMetricManager(TelemetrySession session, int maxConcurrentMetrics, int timeoutInSeconds, string compositePropertySeparator);
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<string, RegisteredCompositeMetricsSet> get_CompositeMetricSets();
    internal bool get_IsExpirationTimerRunning();
    [CompilerGeneratedAttribute]
private TelemetrySession get_Session();
    [CompilerGeneratedAttribute]
private void set_Session(TelemetrySession value);
    [CompilerGeneratedAttribute]
private Timer get_ExpirationTimer();
    [CompilerGeneratedAttribute]
private void set_ExpirationTimer(Timer value);
    public int get_ConcurrentMetricsCount();
    private RegisteredCompositeMetricsSet EnsureRegisteredCompositeMetric(string key, TelemetryEvent baseMetricEvent);
    public void RecordCounterData(string key, T data, string metricName, TelemetryEvent metricEvent, IEnumerable`1<KeyValuePair`2<string, string>> compositeProperties);
    public void RecordHistogramData(string key, T data, string metricName, TelemetryEvent metricEvent, Double[] buckets, IEnumerable`1<KeyValuePair`2<string, string>> compositeProperties);
    public void CloseAll(TelemetrySession session);
    public void Close(TelemetrySession session, string key);
    private void CloseInternal(TelemetrySession session, string key);
    private void RecordInternal(string key, TelemetryEvent metricEvent, MetricInstrumentType instrumentType, T data, string metricName, Double[] buckets, IEnumerable`1<KeyValuePair`2<string, string>> compositeProperties);
    private void StartExpiryTimer();
    private void StopExpiryTimer();
    private void CloseExpired(object sender, ElapsedEventArgs e);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Microsoft.VisualStudio.Telemetry.Metrics.Meter : object {
    private string name;
    private string version;
    public string Name { get; }
    public string Version { get; }
    public Meter(string name);
    public Meter(string name, string version);
    public sealed virtual string get_Name();
    public sealed virtual string get_Version();
    public sealed virtual ICounter`1<T> CreateCounter(string name, string unit, string description);
    public sealed virtual ICounter`1<T> CreateUpDownCounter(string name, string unit, string description);
    public sealed virtual IVSCounter`1<T> CreateVSCounter(string name, string unit, string description);
    public sealed virtual IVSCounter`1<T> CreateVSUpDownCounter(string name, string unit, string description);
    public sealed virtual IHistogram`1<T> CreateHistogram(string name, string unit, string description);
    public sealed virtual IHistogram`1<T> CreateHistogram(string name, HistogramConfiguration configuration, string unit, string description);
    public sealed virtual IVSHistogram`1<T> CreateVSHistogram(string name, string unit, string description);
    public sealed virtual IVSHistogram`1<T> CreateVSHistogram(string name, HistogramConfiguration configuration, string unit, string description);
    public sealed virtual void Dispose();
    private static void ValidateNumericType(Type type);
}
internal enum Microsoft.VisualStudio.Telemetry.Metrics.MonotonicDirection : Enum {
    public int value__;
    public static MonotonicDirection Unknown;
    public static MonotonicDirection Negative;
    public static MonotonicDirection Positive;
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.NumericUtilities.ArithmeticCache : object {
    private ByteArithmetic byteImplementation;
    private Int16Arithmetic int16Implementation;
    private Int32Arithmetic int32Implementation;
    private Int64Arithmetic int64Implementation;
    private FloatArithmetic floatImplementation;
    private DoubleArithmetic doubleImplementation;
    private DecimalArithmetic decimalImplementation;
    public IArithmetic`1<T> GetArithmetic();
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.NumericUtilities.ByteArithmetic : object {
    public sealed virtual byte Add(byte a, byte b);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.NumericUtilities.DecimalArithmetic : object {
    public sealed virtual decimal Add(decimal a, decimal b);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.NumericUtilities.DoubleArithmetic : object {
    public sealed virtual double Add(double a, double b);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.NumericUtilities.FloatArithmetic : object {
    public sealed virtual float Add(float a, float b);
}
internal static class Microsoft.VisualStudio.Telemetry.Metrics.NumericUtilities.GenericNumericUtility : object {
    private static ArithmeticCache arithmeticOperators;
    private static GenericNumericUtility();
    public static T Add(T a, T b);
    public static Nullable`1<double> Average(T sum, long count);
    public static int Compare(T a, T b);
    private static bool IsSupportedNumericType(Type type);
}
internal interface Microsoft.VisualStudio.Telemetry.Metrics.NumericUtilities.IArithmetic`1 {
    public abstract virtual T Add(T a, T b);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.NumericUtilities.Int16Arithmetic : object {
    public sealed virtual short Add(short a, short b);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.NumericUtilities.Int32Arithmetic : object {
    public sealed virtual int Add(int a, int b);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.NumericUtilities.Int64Arithmetic : object {
    public sealed virtual long Add(long a, long b);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.TelemetryCompositeMetricEvent : TelemetryMetricEvent {
    public TelemetryCompositeMetricEvent(TelemetryEvent baseEvent, IEnumerable`1<IInstrument> metrics);
    internal void AssignCompositedPropertyValues(RegisteredCompositeMetricsSet compositeSet, string separator);
}
internal class Microsoft.VisualStudio.Telemetry.Metrics.UpDownCounter`1 : CounterBase`1<T> {
    internal UpDownCounter`1(IMeter meter, string name, string unit, string description);
}
public class Microsoft.VisualStudio.Telemetry.Metrics.VSTelemetryMeterProvider : object {
    private static Regex InstrumentNameRegex;
    private static VSTelemetryMeterProvider();
    public sealed virtual IMeter CreateMeter(string name);
    public sealed virtual IMeter CreateMeter(string name, string version);
    public static bool IsValidInstrumentName(string instrumentName);
}
internal class Microsoft.VisualStudio.Telemetry.MonoFileTimeProcessCreationTime : object {
    public sealed virtual long GetProcessCreationTime();
}
internal class Microsoft.VisualStudio.Telemetry.MonoHostInformationProvider : object {
    private string name;
    private UInt32 id;
    private Nullable`1<int> buildNumber;
    private string exeVersion;
    private bool isProcessInitialized;
    private static object isInitializedLock;
    public string ProcessName { get; }
    public UInt32 ProcessId { get; }
    public string ProcessExeVersion { get; }
    public Nullable`1<int> ProcessBuildNumber { get; }
    public bool IsDebuggerAttached { get; }
    public bool Is64BitProcess { get; }
    public string OSBitness { get; }
    private static MonoHostInformationProvider();
    public sealed virtual string GetName();
    public sealed virtual string GetVersion();
    public sealed virtual string get_ProcessName();
    public sealed virtual UInt32 get_ProcessId();
    public sealed virtual string get_ProcessExeVersion();
    public sealed virtual Nullable`1<int> get_ProcessBuildNumber();
    public sealed virtual bool get_IsDebuggerAttached();
    public sealed virtual bool get_Is64BitProcess();
    public sealed virtual string get_OSBitness();
    private void InitializeFromCurrentProcess();
    private string InitializeName(FileVersionInfo hostVersionInfo);
    private FileVersionInfo GetFileVersionInfo(Process process);
    private string InitializeExeVersion(FileVersionInfo hostVersionInfo);
}
internal class Microsoft.VisualStudio.Telemetry.MonoInternalSettings : InternalSettingsBase {
    internal static string TelemetryUserDirKeyPath;
    private static int ChannelExplicitlyEnabled;
    private static int ChannelExplicitlyDisabled;
    private JObject channelSettingsJson;
    public MonoInternalSettings(IDiagnosticTelemetry diagnosticTelemetry);
    public virtual ChannelInternalSetting GetChannelSettings(string channelId);
    private void LoadChannelSettings();
}
internal class Microsoft.VisualStudio.Telemetry.MonoProcessCreationTime : object {
    public sealed virtual long GetProcessCreationTime();
}
internal class Microsoft.VisualStudio.Telemetry.MonoRegistryPropertyBag : RegistryPropertyBag {
    public MonoRegistryPropertyBag(string processName);
    protected virtual IEnumerable`1<KeyValuePair`2<string, object>> ReadRegistryValues(string registryKeyName);
    protected virtual object GetProperty(string fullRegistryKeyName, string registryKeyName, string propertyName, object defaultValue);
    private object GetValue(string registryKeyName, string propertyName);
    protected virtual void SetProperty(string registryKeyName, string propertyName, object value);
    protected virtual void RemoveProperty(string registryKeyName, string propertyName);
    protected virtual void Clear(string registryKeyName);
    protected virtual void SetAccessControl(RegistryKey key);
}
internal class Microsoft.VisualStudio.Telemetry.MonoUserInformationProvider : UserInformationProviderBase {
    public UserType UserType { get; }
    public MonoUserInformationProvider(IInternalSettings internalSettings, IEnvironmentTools envTools, ISQMApi sqmApi, Nullable`1<Guid> userId);
    public virtual UserType get_UserType();
    protected virtual bool CalculateIsMicrosoftAADJoined();
}
internal static class Microsoft.VisualStudio.Telemetry.Native.Mac.MacFoundation : object {
}
internal static class Microsoft.VisualStudio.Telemetry.Native.Mac.MacRuntime : object {
    public static string LIBOBJC_DYLIB;
}
internal class Microsoft.VisualStudio.Telemetry.Notification.AsyncManualResetEvent : object {
    private TaskCompletionSource`1 modreq(System.Runtime.CompilerServices.IsVolatile) tcs;
    public Task WaitAsync();
    public void Set();
    public void Reset();
    [CompilerGeneratedAttribute]
private bool <Set>b__2_0();
}
internal interface Microsoft.VisualStudio.Telemetry.Notification.ITelemetryNotificationProvider {
    public abstract virtual void AttachChannel(ITelemetryTestChannel channel);
    public abstract virtual void DetachChannel(ITelemetryTestChannel channel);
    public abstract virtual void PostFaultEvent(string eventName, string description, Exception exception);
}
public interface Microsoft.VisualStudio.Telemetry.Notification.ITelemetryNotificationService {
    public abstract virtual int Subscribe(ITelemetryEventMatch eventMatch, Action`1<TelemetryEvent> handler, bool singleNotification);
    public abstract virtual void Unsubscribe(int subscriptionId);
}
internal class Microsoft.VisualStudio.Telemetry.Notification.NotificationTelemetryChannel : object {
    private Action`1<TelemetryEvent> handler;
    public NotificationTelemetryChannel(Action`1<TelemetryEvent> handler);
    public sealed virtual void OnPostEvent(object sender, TelemetryTestChannelEventArgs e);
}
internal class Microsoft.VisualStudio.Telemetry.Notification.TelemetryNotificationProvider : object {
    private ITelemetryTestChannel channel;
    private TelemetrySession telemetrySession;
    public TelemetryNotificationProvider(TelemetrySession session);
    public sealed virtual void AttachChannel(ITelemetryTestChannel channel);
    public sealed virtual void DetachChannel(ITelemetryTestChannel channel);
    public sealed virtual void PostFaultEvent(string eventName, string description, Exception exception);
}
public class Microsoft.VisualStudio.Telemetry.Notification.TelemetryNotificationService : object {
    private static Lazy`1<ITelemetryNotificationService> defaultLazy;
    private static string TelemetryNotificationBaseEventName;
    internal static string TelemetryNotificationFilterFaultEventName;
    internal static string TelemetryNotificationHandlerFaultEventName;
    private object lockObject;
    private Lazy`1<IDictionary`2<int, Subscription>> subscriptionsLazy;
    private ITelemetryNotificationProvider provider;
    private ITelemetryTestChannel channel;
    private int lastSubscriptionId;
    private ConcurrentQueue`1<TelemetryEvent> queueTelemetryEvents;
    internal AsyncManualResetEvent EventNewItemAvailableForNotification;
    private CancellationTokenSource cancellationTokenSource;
    public static ITelemetryNotificationService Default { get; }
    private IDictionary`2<int, Subscription> Subscriptions { get; }
    private static TelemetryNotificationService();
    internal TelemetryNotificationService(ITelemetryNotificationProvider provider);
    public static ITelemetryNotificationService get_Default();
    internal static void Initialize();
    public sealed virtual int Subscribe(ITelemetryEventMatch eventMatch, Action`1<TelemetryEvent> handler, bool singleNotification);
    public sealed virtual void Unsubscribe(int subscriptionId);
    private IDictionary`2<int, Subscription> get_Subscriptions();
    private void AttachChannel();
    private void DetachChannel();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Notification.TelemetryNotificationService/<ListenForEventsInQueueAsync>d__23")]
private Task ListenForEventsInQueueAsync();
    private void OnPostEvent(TelemetryEvent telemetryEvent);
    private void ProcessPostedEvents(TelemetryEvent telemetryEvent);
    private void PostFaultEvent(string eventName, ITelemetryEventMatch eventMatch, Exception exception);
    public sealed virtual void SetSession(TelemetrySession session);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Notification.TelemetryNotificationService/<<AttachChannel>b__21_0>d")]
[CompilerGeneratedAttribute]
private Task <AttachChannel>b__21_0();
}
internal class Microsoft.VisualStudio.Telemetry.NsBundleInformationProvider : object {
    public sealed virtual string GetVersion();
    public sealed virtual string GetName();
}
public class Microsoft.VisualStudio.Telemetry.OperationEvent : TelemetryEvent {
    private static string OperationPropertyPrefixName;
    private static string ResultPropertyName;
    private static string ResultSummaryPropertyName;
    private static string StageTypePropertyName;
    private static string StartTimePropertyName;
    private static string EndTimePropertyName;
    private static string DurationPropertyName;
    private static string PostStartEventPropertyName;
    private TelemetryResult result;
    private string resultSummary;
    private OperationStageType stageType;
    private Nullable`1<double> duration;
    private Nullable`1<long> startTime;
    private Nullable`1<long> endTime;
    public TelemetryResult Result { get; private set; }
    public string ResultSummary { get; private set; }
    public OperationStageType StageType { get; internal set; }
    public Nullable`1<Guid> StartEndPairId { get; }
    public Nullable`1<double> Duration { get; private set; }
    public Nullable`1<long> StartTime { get; private set; }
    public Nullable`1<long> EndTime { get; private set; }
    public string ProductName { get; }
    public string FeatureName { get; }
    public string EntityName { get; }
    public OperationEvent(string eventName, TelemetryResult result, string resultSummary);
    internal OperationEvent(string eventName, OperationStageType stageType, TelemetryResult result, string resultSummary);
    internal OperationEvent(string eventName, DataModelEventType eventType, OperationStageType stageType, TelemetryResult result, string resultSummary);
    public TelemetryResult get_Result();
    private void set_Result(TelemetryResult value);
    public string get_ResultSummary();
    private void set_ResultSummary(string value);
    public OperationStageType get_StageType();
    internal void set_StageType(OperationStageType value);
    public Nullable`1<Guid> get_StartEndPairId();
    public Nullable`1<double> get_Duration();
    private void set_Duration(Nullable`1<double> value);
    public Nullable`1<long> get_StartTime();
    private void set_StartTime(Nullable`1<long> value);
    public Nullable`1<long> get_EndTime();
    private void set_EndTime(Nullable`1<long> value);
    public string get_ProductName();
    public string get_FeatureName();
    public string get_EntityName();
    public void Correlate(TelemetryEventCorrelation correlation, string description);
    internal void SetResultProperties(TelemetryResult result, string resultSummary);
    internal void SetTimeProperties(DateTime startTime, DateTime endTime, double durationInMilliseconds);
    internal void SetPostStartEventProperty(bool postStartEvent);
    private string GetOperationStageTypeName(OperationStageType operationType);
}
public enum Microsoft.VisualStudio.Telemetry.OperationStageType : Enum {
    public int value__;
    public static OperationStageType Atomic;
    public static OperationStageType Start;
    public static OperationStageType End;
}
internal class Microsoft.VisualStudio.Telemetry.OptOutAction : object {
    private HashSet`1<string> optoutFriendlyEvents;
    private HashSet`1<string> optoutFriendlyProperties;
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public void AddOptOutFriendlyEventName(string eventName);
    public void AddOptOutFriendlyPropertiesList(IEnumerable`1<string> propertyNameList);
}
internal class Microsoft.VisualStudio.Telemetry.PersistentSharedPropertyProvider : object {
    private IPersistentPropertyBag persistedSessionProperties;
    public PersistentSharedPropertyProvider(IPersistentPropertyBag persistentPropertyBag);
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
internal class Microsoft.VisualStudio.Telemetry.PiiAction : object {
    private static string UnknownValue;
    private HashSet`1<string> piiedProperties;
    private IPiiPropertyProcessor piiPropertyProcessor;
    private int totalPiiProperties;
    public int Priority { get; }
    public PiiAction(IPiiPropertyProcessor piiPropertyProcessor);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void PostDiagnosticInformation(TelemetrySession mainSession, TelemetryManifest newManifest);
}
internal class Microsoft.VisualStudio.Telemetry.PIIPropertyProcessor : object {
    private static string NotHashedPropertySuffix;
    private static string Key;
    private static ThreadLocal`1<HashAlgorithm> Encrypter;
    private static PIIPropertyProcessor();
    public sealed virtual string BuildRawPropertyName(string propertyName);
    public sealed virtual bool CanAddRawValue(IEventProcessorContext eventProcessorContext);
    public sealed virtual object ConvertToRawValue(object value);
    public sealed virtual string ConvertToHashedValue(object value);
    public sealed virtual Type TypeOfPiiProperty();
    public sealed virtual Type TypeOfHashedProperty();
    private static HashAlgorithm CreateEncryptor();
    private string HashPropertyValue(string value);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.Telemetry.PrefixedPropertyBag`1 : object {
    private string prefix;
    private IDictionary`2<string, TValue> withPrefix;
    public TValue Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal IEnumerable`1<KeyValuePair`2<string, TValue>> PrefixedEnumerable { get; }
    public PrefixedPropertyBag`1(IDictionary`2<string, TValue> backingDictionary, string prefix);
    public sealed virtual TValue get_Item(string key);
    public sealed virtual void set_Item(string key, TValue value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<string, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, TValue> item);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.PrefixedPropertyBag`1/<GetEnumerator>d__20")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, TValue>> GetEnumerator();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, TValue> item);
    public sealed virtual bool TryGetValue(string key, TValue& value);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.PrefixedPropertyBag`1/<System-Collections-IEnumerable-GetEnumerator>d__24")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void AddPrefixed(string key, TValue value);
    internal void RemovePrefixed(string key);
    internal TValue GetPrefixed(string key);
    internal IEnumerable`1<KeyValuePair`2<string, TValue>> get_PrefixedEnumerable();
    internal void AddRangePrefixed(IEnumerable`1<KeyValuePair`2<string, TValue>> source, bool forceUpdate);
    private void AssertIsPrefixed(string key);
    private string GetFullPropertyName(string shortName);
    private KeyValuePair`2<string, TValue> GetFullPropertyName(KeyValuePair`2<string, TValue> pair);
    private string GetShortPropertyName(string fullName);
    private KeyValuePair`2<string, TValue> GetShortPropertyName(KeyValuePair`2<string, TValue> pair);
    [CompilerGeneratedAttribute]
private string <get_Keys>b__7_0(KeyValuePair`2<string, TValue> kv);
}
internal class Microsoft.VisualStudio.Telemetry.ProcessTools : object {
    public sealed virtual void RunCommand(string commandName, Action`1<string> onProcessComplete);
    public sealed virtual void RunCommand(string commandName, Action`1<string> onProcessComplete, string commandArgs);
}
internal class Microsoft.VisualStudio.Telemetry.PropertyProviders.Linux.LinuxOSPropertyProvider : object {
    private IOSInformationProvider osInformationProvider;
    public LinuxOSPropertyProvider(IOSInformationProvider osInformationProvider);
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
internal class Microsoft.VisualStudio.Telemetry.RegistryChannelValidator : object {
    private IInternalSettings internalSettings;
    public RegistryChannelValidator(IInternalSettings internalSettings);
    public sealed virtual bool IsValid(ISessionChannel channelToValidate);
}
internal class Microsoft.VisualStudio.Telemetry.RegistryPropertyBag : object {
    private static string StringPrefix;
    private static string DoublePrefix;
    private string keyName;
    private string fullKeyName;
    public RegistryPropertyBag(string processName);
    public virtual IEnumerable`1<KeyValuePair`2<string, object>> GetAllProperties();
    public sealed virtual object GetProperty(string propertyName);
    public sealed virtual void SetProperty(string propertyName, int value);
    public sealed virtual void SetProperty(string propertyName, string value);
    public sealed virtual void SetProperty(string propertyName, double value);
    public sealed virtual void RemoveProperty(string propertyName);
    public sealed virtual void Clear();
    protected virtual IEnumerable`1<KeyValuePair`2<string, object>> ReadRegistryValues(string registryKeyName);
    protected virtual object GetProperty(string fullRegistryKeyName, string registryKeyName, string propertyName, object defaultValue);
    protected virtual void SetProperty(string registryKeyName, string propertyName, object value);
    protected virtual void RemoveProperty(string registryKeyName, string propertyName);
    protected virtual void Clear(string registryKeyName);
    protected virtual void SetAccessControl(RegistryKey key);
    private void SetProperty(string propertyName, object value);
    private static object InterpretRegistryValue(object value);
    private static string StringPrefixScrubber(string valueAsString);
    private bool SafeRegistryCall(Action action);
    public sealed virtual void Persist();
    [CompilerGeneratedAttribute]
private void <Clear>b__11_0();
}
internal class Microsoft.VisualStudio.Telemetry.SensitiveDataScrubber.CredScanDataScrubber : object {
    internal static string CREDSCAN_PREFILTER_EXTENDED;
    private static Regex CredScanPrefilterExtendedRegex;
    private static CredScanDataScrubber();
    public sealed virtual bool ContainsSensitiveData(string propertyValue, bool scrubAllTypesOfPersonalData);
}
internal interface Microsoft.VisualStudio.Telemetry.SensitiveDataScrubber.ISensitiveDataScrubber {
    public abstract virtual bool ContainsSensitiveData(string propertyValue, bool scrubAllTypesOfPersonalData);
}
internal class Microsoft.VisualStudio.Telemetry.SensitiveDataScrubber.SensitiveDataScrubber : object {
    private static RegexOptions Options;
    private Regex allPatternsRegexes;
    private static SubstringMatch[] substringMatches;
    private static List`1<string> additionalPatterns;
    private static SensitiveDataScrubber();
    public sealed virtual bool ContainsSensitiveData(string propertyValue, bool scrubAllTypesOfPersonalData);
    private static bool IsMatch(string value, SubstringMatch& substringMatch);
    private static string RemoveSubstring(string value, string substring);
}
internal class Microsoft.VisualStudio.Telemetry.Services.DefaultRegistryKeyValueStorage : object {
    public sealed virtual bool CollectionExists(string collectionPath);
    public sealed virtual bool PropertyExists(string collectionPath, string key);
    public sealed virtual IEnumerable`1<string> GetPropertyNames(string collectionPath);
    public sealed virtual T GetValue(string key, T defaultValue);
    public sealed virtual T GetValue(string collectionPath, string key, T defaultValue);
    public sealed virtual bool TryGetValue(string collectionPath, string key, T& value);
    public sealed virtual bool TryGetValueKind(string collectionPath, string key, ValueKind& kind);
    public sealed virtual void SetValue(string key, T value);
    public sealed virtual void SetValue(string collectionPath, string key, T value);
    private Tuple`2<string, string> GetPathComponents(string key);
    private bool GetValueInternal(string collectionPath, string key, T defaultValue, T& value);
    private void SetValueInternal(string collectionPath, string key, T value);
    public sealed virtual IEnumerable`1<string> GetSubCollectionNames(string collectionPath);
    public sealed virtual bool DeleteCollection(string collectionPath);
    public sealed virtual bool DeleteProperty(string collectionPath, string propertyName);
}
internal enum Microsoft.VisualStudio.Telemetry.Services.ErrorCode : Enum {
    public int value__;
    public static ErrorCode NoError;
    public static ErrorCode NullResponse;
    public static ErrorCode RequestTimedOut;
    public static ErrorCode WebExceptionThrown;
}
internal class Microsoft.VisualStudio.Telemetry.Services.FileVersion : object {
    [CompilerGeneratedAttribute]
private int <FileMajorPart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileMinorPart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileBuildPart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileRevisionPart>k__BackingField;
    public int FileMajorPart { get; private set; }
    public int FileMinorPart { get; private set; }
    public int FileBuildPart { get; private set; }
    public int FileRevisionPart { get; private set; }
    public FileVersion(FileVersionInfo fileVersionInfo);
    public FileVersion(int major, int minor, int build, int revision);
    public static bool TryParse(string fileVersion, FileVersion& value);
    [CompilerGeneratedAttribute]
public int get_FileMajorPart();
    [CompilerGeneratedAttribute]
private void set_FileMajorPart(int value);
    [CompilerGeneratedAttribute]
public int get_FileMinorPart();
    [CompilerGeneratedAttribute]
private void set_FileMinorPart(int value);
    [CompilerGeneratedAttribute]
public int get_FileBuildPart();
    [CompilerGeneratedAttribute]
private void set_FileBuildPart(int value);
    [CompilerGeneratedAttribute]
public int get_FileRevisionPart();
    [CompilerGeneratedAttribute]
private void set_FileRevisionPart(int value);
    public virtual string ToString();
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Telemetry.Services.HttpWebRequest : object {
    private HttpWebRequest request;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Url { get; }
    public string Method { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ContentType { get; public set; }
    public long ContentLength { get; public set; }
    public bool AllowAutoRedirect { get; public set; }
    public HttpWebRequest(string url);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Url();
    public sealed virtual string get_Method();
    public sealed virtual void set_Method(string value);
    public sealed virtual RequestCachePolicy get_CachePolicy();
    public sealed virtual void set_CachePolicy(RequestCachePolicy value);
    public sealed virtual string get_ContentType();
    public sealed virtual void set_ContentType(string value);
    public sealed virtual long get_ContentLength();
    public sealed virtual void set_ContentLength(long value);
    public sealed virtual bool get_AllowAutoRedirect();
    public sealed virtual void set_AllowAutoRedirect(bool value);
    public sealed virtual void AddHeaders(IEnumerable`1<KeyValuePair`2<string, string>> headers);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Services.HttpWebRequest/<GetResponseAsync>d__21")]
public sealed virtual Task`1<IHttpWebResponse> GetResponseAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Services.HttpWebRequest/<GetRequestStreamAsync>d__22")]
public sealed virtual Task`1<Stream> GetRequestStreamAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <GetResponseAsync>b__21_0();
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Telemetry.Services.HttpWebRequestFactory : object {
    public sealed virtual IHttpWebRequest Create(string url);
    public sealed virtual IHttpWebRequest Create(string url, IEnumerable`1<KeyValuePair`2<string, string>> queryParameters);
}
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.VisualStudio.Telemetry.Services.HttpWebResponse : object {
    [CompilerGeneratedAttribute]
private ErrorCode <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private WebExceptionStatus <ExceptionCode>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpWebResponse <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private WebHeaderCollection <Headers>k__BackingField;
    public ErrorCode ErrorCode { get; public set; }
    public WebExceptionStatus ExceptionCode { get; public set; }
    public HttpWebResponse Response { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ErrorCode get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(ErrorCode value);
    [CompilerGeneratedAttribute]
public sealed virtual WebExceptionStatus get_ExceptionCode();
    [CompilerGeneratedAttribute]
public void set_ExceptionCode(WebExceptionStatus value);
    [CompilerGeneratedAttribute]
public HttpWebResponse get_Response();
    [CompilerGeneratedAttribute]
public void set_Response(HttpWebResponse value);
    [CompilerGeneratedAttribute]
public sealed virtual HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public sealed virtual WebHeaderCollection get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Headers(WebHeaderCollection value);
    public sealed virtual Stream GetResponseStream();
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IHttpWebRequest {
    public string Url { get; }
    public string Method { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ContentType { get; public set; }
    public long ContentLength { get; public set; }
    public bool AllowAutoRedirect { get; public set; }
    public abstract virtual string get_Url();
    public abstract virtual string get_Method();
    public abstract virtual void set_Method(string value);
    public abstract virtual RequestCachePolicy get_CachePolicy();
    public abstract virtual void set_CachePolicy(RequestCachePolicy value);
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual long get_ContentLength();
    public abstract virtual void set_ContentLength(long value);
    public abstract virtual bool get_AllowAutoRedirect();
    public abstract virtual void set_AllowAutoRedirect(bool value);
    public abstract virtual void AddHeaders(IEnumerable`1<KeyValuePair`2<string, string>> headers);
    public abstract virtual Task`1<IHttpWebResponse> GetResponseAsync(CancellationToken token);
    public abstract virtual Task`1<Stream> GetRequestStreamAsync(CancellationToken token);
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IHttpWebRequestFactory {
    public abstract virtual IHttpWebRequest Create(string url);
    public abstract virtual IHttpWebRequest Create(string url, IEnumerable`1<KeyValuePair`2<string, string>> queryParameters);
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IHttpWebResponse {
    public ErrorCode ErrorCode { get; }
    public WebExceptionStatus ExceptionCode { get; }
    public HttpStatusCode StatusCode { get; }
    public WebHeaderCollection Headers { get; public set; }
    public abstract virtual ErrorCode get_ErrorCode();
    public abstract virtual WebExceptionStatus get_ExceptionCode();
    public abstract virtual HttpStatusCode get_StatusCode();
    public abstract virtual WebHeaderCollection get_Headers();
    public abstract virtual void set_Headers(WebHeaderCollection value);
    public abstract virtual Stream GetResponseStream();
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IProcessInformationProvider {
    public abstract virtual string GetExeName();
    public abstract virtual FileVersion GetProcessVersionInfo();
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IRemoteFileReader {
    public abstract virtual Task`1<Stream> ReadFileAsync();
}
internal interface Microsoft.VisualStudio.Telemetry.Services.IRemoteFileReaderFactory {
    public abstract virtual IRemoteFileReader Instance();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Services.ListEx : object {
    [ExtensionAttribute]
public static void AddIfNotEmpty(List`1<string> parts, string v);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Services.ObjectEx : object {
    [ExtensionAttribute]
public static bool TryConvertToType(object originalValue, T defaultValue, T& returnValue);
}
internal class Microsoft.VisualStudio.Telemetry.Services.ProcessInformationProvider : object {
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual string GetExeName();
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual FileVersion GetProcessVersionInfo();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Services.StringEx : object {
    private static int MaxPath;
    private static Char[] buffer;
    private static StringEx();
    [ExtensionAttribute]
public static string NormalizePath(string path);
    [ExtensionAttribute]
public static string GetRootSubCollectionOfPath(string path);
    private static bool IsSkippable(char c);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.Services.TaskEx : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.Services.TaskEx/<WithCancellation>d__0`1")]
[ExtensionAttribute]
public static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken cancellationToken);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.AsimovAppInsightsClientWrapper : BaseAppInsightsClientWrapper {
    private TelemetrySession hostTelemetrySession;
    private StorageBase storage;
    private IProcessLockFactory processLockFactory;
    public AsimovAppInsightsClientWrapper(string instrumentationKey, TelemetrySession hostTelemetrySession, StorageBase storage, IProcessLockFactory processLockFactory);
    public virtual bool TryGetTransport(String& transportUsed);
    protected virtual ITelemetryChannel CreateAppInsightsChannel(TelemetryConfiguration config);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.AsimovAppInsightsSessionChannel : BaseAppInsightsSessionChannel {
    private static string DefaultAsimovIKey;
    private static string DefaultAppInsightsIKey;
    private static string AppInsightsPersistencePath;
    private string channelId;
    private TelemetrySession hostTelemetrySession;
    private IProcessLockFactory processLockFactory;
    protected string FolderNameSuffix { get; }
    internal string IKey { get; }
    public string ChannelId { get; }
    public AsimovAppInsightsSessionChannel(string channelId, string instrumentationKey, string userId, ChannelProperties channelProperties, TelemetrySession hostTelemetrySession, IProcessLockFactory processLockFactory);
    protected virtual string get_FolderNameSuffix();
    internal virtual string get_IKey();
    public virtual string get_ChannelId();
    internal void CheckPendingEventsAndStartChannel(string sessionId);
    protected virtual IAppInsightsClientWrapper CreateAppInsightsClientWrapper();
    private bool TryUploadPendingFiles(string environmentFolderName, string sessionId);
    internal virtual void AppendCommonSchemaVersion(EventTelemetry eventTelemetry);
}
internal abstract class Microsoft.VisualStudio.Telemetry.SessionChannel.BaseAppInsightsClientWrapper : TelemetryDisposableObject {
    private string instrumentationKey;
    private TelemetryClient appInsightsClient;
    private ITelemetryChannel appInsightsChannel;
    public string InstrumentationKey { get; }
    public BaseAppInsightsClientWrapper(string instrumentationKey);
    public sealed virtual string get_InstrumentationKey();
    public abstract virtual bool TryGetTransport(String& transportUsed);
    public sealed virtual void Initialize(string sessionId, string userId);
    public sealed virtual void TrackEvent(EventTelemetry ev);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.SessionChannel.BaseAppInsightsClientWrapper/<DisposeAndTransmitAsync>d__10")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    protected abstract virtual ITelemetryChannel CreateAppInsightsChannel(TelemetryConfiguration config);
    protected virtual void DisposeManagedResources();
    private void DisposeChannel();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0();
}
internal abstract class Microsoft.VisualStudio.Telemetry.SessionChannel.BaseAppInsightsSessionChannel : TelemetryDisposableObject {
    protected string InstrumentationKey;
    protected string UserId;
    private Lazy`1<string> transportUsed;
    private static string SequenceNumberPropertyName;
    private bool isChannelStarted;
    private IAppInsightsClientWrapper appInsightsClient;
    private int eventCounter;
    private ChannelProperties channelProperties;
    public string ChannelId { get; }
    public string TransportUsed { get; }
    public ChannelProperties Properties { get; public set; }
    public bool IsStarted { get; }
    internal string IKey { get; }
    protected string PersistenceFolderName { get; }
    protected string FolderNameSuffix { get; }
    public BaseAppInsightsSessionChannel(string instrumentationKey, string userId, IAppInsightsClientWrapper overridedClientWrapper, ChannelProperties defaultChannelProperties);
    public abstract virtual string get_ChannelId();
    public sealed virtual string get_TransportUsed();
    public sealed virtual ChannelProperties get_Properties();
    public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual void Start(string sessionId);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.SessionChannel.BaseAppInsightsSessionChannel/<DisposeAndTransmitAsync>d__17")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    public sealed virtual bool get_IsStarted();
    internal abstract virtual string get_IKey();
    protected string get_PersistenceFolderName();
    protected abstract virtual string get_FolderNameSuffix();
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    internal abstract virtual void AppendCommonSchemaVersion(EventTelemetry eventTelemetry);
    protected abstract virtual IAppInsightsClientWrapper CreateAppInsightsClientWrapper();
    protected virtual void DisposeManagedResources();
    private void EnsureChannelIsStarted();
    [CompilerGeneratedAttribute]
private string <.ctor>b__15_0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0();
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Telemetry.SessionChannel.ChannelProperties : Enum {
    public int value__;
    public static ChannelProperties None;
    public static ChannelProperties Default;
    public static ChannelProperties InternalOnly;
    public static ChannelProperties Test;
    public static ChannelProperties NotForUnitTest;
    public static ChannelProperties DevChannel;
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.CollectorClientWrapper : BaseAppInsightsClientWrapper {
    private TelemetrySession hostTelemetrySession;
    private StorageBase storage;
    private IProcessLockFactory processLockFactory;
    public CollectorClientWrapper(string instrumentationKey, TelemetrySession hostTelemetrySession, StorageBase storage, IProcessLockFactory processLockFactory);
    public virtual bool TryGetTransport(String& transportUsed);
    protected virtual ITelemetryChannel CreateAppInsightsChannel(TelemetryConfiguration config);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.CollectorSessionChannel : BaseAppInsightsSessionChannel {
    private static string AppInsightsPersistencePath;
    private string channelId;
    private TelemetrySession hostTelemetrySession;
    private IProcessLockFactory processLockFactory;
    private string iKey;
    private PersistenceVersion PersistenceVersion { get; }
    public string ChannelId { get; }
    protected string FolderNameSuffix { get; }
    internal string IKey { get; }
    public CollectorSessionChannel(string channelId, string instrumentationKey, string userId, ChannelProperties channelProperties, TelemetrySession hostTelemetrySession, IProcessLockFactory processLockFactory);
    private PersistenceVersion get_PersistenceVersion();
    public virtual string get_ChannelId();
    protected virtual string get_FolderNameSuffix();
    internal virtual string get_IKey();
    internal void CheckPendingEventsAndStartChannel(string sessionId);
    protected virtual IAppInsightsClientWrapper CreateAppInsightsClientWrapper();
    private bool TryUploadPendingFiles(string environmentFolderName, string sessionId);
    internal virtual void AppendCommonSchemaVersion(EventTelemetry eventTelemetry);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.DefaultAppInsightsClientWrapper : BaseAppInsightsClientWrapper {
    private TelemetrySession hostTelemetrySession;
    private StorageBase storage;
    private IProcessLockFactory processLockFactory;
    public DefaultAppInsightsClientWrapper(string instrumentationKey, StorageBase storage, TelemetrySession session, IProcessLockFactory processLockFactory);
    public virtual bool TryGetTransport(String& transportUsed);
    protected virtual ITelemetryChannel CreateAppInsightsChannel(TelemetryConfiguration config);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.DefaultAppInsightsSessionChannel : BaseAppInsightsSessionChannel {
    private TelemetrySession hostTelemetrySession;
    private IProcessLockFactory processLockFactory;
    public string ChannelId { get; }
    internal string IKey { get; }
    protected string FolderNameSuffix { get; }
    public DefaultAppInsightsSessionChannel(TelemetrySession session, string instrumentationKey, string userId);
    public DefaultAppInsightsSessionChannel(string instrumentationKey, string userId, TelemetrySession session, IProcessLockFactory processLockFactory);
    public virtual string get_ChannelId();
    internal virtual string get_IKey();
    protected virtual string get_FolderNameSuffix();
    protected virtual IAppInsightsClientWrapper CreateAppInsightsClientWrapper();
    internal virtual void AppendCommonSchemaVersion(EventTelemetry eventTelemetry);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.EventProcessorChannel : TelemetryDisposableObject {
    private static int SchedulerDelay;
    private ConcurrentQueue`1<TelemetryEvent> queue;
    private IEventProcessor eventProcessor;
    private ITelemetryScheduler scheduler;
    private TelemetrySession telemetrySession;
    private bool hasProcessedEvents;
    private Action initializedAction;
    public string ChannelId { get; }
    public ChannelProperties Properties { get; public set; }
    public bool IsStarted { get; }
    public string TransportUsed { get; }
    unknown Action InitializedAction {internal set; }
    internal EventProcessorChannel(IEventProcessor theEventProcessor, ITelemetryScheduler theScheduler, TelemetrySession telemetrySession);
    public sealed virtual string get_ChannelId();
    public sealed virtual ChannelProperties get_Properties();
    public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public sealed virtual void Start(string sessionId);
    public sealed virtual bool get_IsStarted();
    public sealed virtual string get_TransportUsed();
    public void ProcessEvents();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.SessionChannel.EventProcessorChannel/<DisposeAndTransmitAsync>d__21")]
public sealed virtual Task DisposeAndTransmitAsync(CancellationToken token);
    internal void set_InitializedAction(Action value);
    protected virtual void DisposeManagedResources();
    private void DisposeInit();
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.GlobalTelemetryTestChannel : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<TelemetryTestChannelEventArgs> EventPosted;
    private static GlobalTelemetryTestChannel PrivateInstance;
    public string ChannelId { get; }
    public bool IsStarted { get; }
    public ChannelProperties Properties { get; public set; }
    public string TransportUsed { get; }
    public static GlobalTelemetryTestChannel Instance { get; }
    private static GlobalTelemetryTestChannel();
    [CompilerGeneratedAttribute]
public void add_EventPosted(EventHandler`1<TelemetryTestChannelEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventPosted(EventHandler`1<TelemetryTestChannelEventArgs> value);
    public sealed virtual string get_ChannelId();
    public sealed virtual bool get_IsStarted();
    public sealed virtual ChannelProperties get_Properties();
    public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual string get_TransportUsed();
    public static GlobalTelemetryTestChannel get_Instance();
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public void ClearEventSubscribers();
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public sealed virtual void Start(string sessionId);
    public virtual string ToString();
}
internal interface Microsoft.VisualStudio.Telemetry.SessionChannel.IAppInsightsClientWrapper {
    public string InstrumentationKey { get; }
    public abstract virtual string get_InstrumentationKey();
    public abstract virtual void Initialize(string sessionId, string userId);
    public abstract virtual void TrackEvent(EventTelemetry ev);
    public abstract virtual bool TryGetTransport(String& transportUsed);
}
internal interface Microsoft.VisualStudio.Telemetry.SessionChannel.IAppInsightsLifecycleManager {
    public abstract virtual void ApplicationStart();
    public abstract virtual void ApplicationStop();
}
public interface Microsoft.VisualStudio.Telemetry.SessionChannel.IDisposeAndTransmit {
    public abstract virtual Task DisposeAndTransmitAsync(CancellationToken token);
}
public interface Microsoft.VisualStudio.Telemetry.SessionChannel.ISessionChannel {
    public string ChannelId { get; }
    public string TransportUsed { get; }
    public ChannelProperties Properties { get; public set; }
    public bool IsStarted { get; }
    public abstract virtual string get_ChannelId();
    public abstract virtual string get_TransportUsed();
    public abstract virtual ChannelProperties get_Properties();
    public abstract virtual void set_Properties(ChannelProperties value);
    public abstract virtual bool get_IsStarted();
    public abstract virtual void PostEvent(TelemetryEvent telemetryEvent);
    public abstract virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public abstract virtual void Start(string sessionId);
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.TelemetryBufferChannel : object {
    private ConcurrentQueue`1<TelemetryEvent> eventBuffer;
    public string ChannelId { get; }
    public string TransportUsed { get; }
    public ChannelProperties Properties { get; public set; }
    public bool IsStarted { get; }
    public sealed virtual string get_ChannelId();
    public sealed virtual string get_TransportUsed();
    public sealed virtual ChannelProperties get_Properties();
    public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public sealed virtual void Start(string sessionID);
    public sealed virtual bool get_IsStarted();
    public bool TryDequeue(TelemetryEvent& telemetryEvent);
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.TelemetryLogToFileChannel : TelemetryDisposableObject {
    private static string TelemetryLogFolderName;
    private ITelemetryLogFile`1<TelemetryEvent> logFile;
    private ITelemetryLogSettingsProvider settingsProvider;
    private ChannelProperties channelProperties;
    private bool isChannelStarted;
    private ProductTarget hostProduct;
    public string ChannelId { get; }
    public string TransportUsed { get; }
    public ChannelProperties Properties { get; public set; }
    public bool IsStarted { get; }
    public TelemetryLogToFileChannel(ProductTarget productTarget);
    internal TelemetryLogToFileChannel(ITelemetryLogSettingsProvider settingsProvider, ITelemetryLogFile`1<TelemetryEvent> logFile);
    public sealed virtual string get_ChannelId();
    public sealed virtual string get_TransportUsed();
    public sealed virtual ChannelProperties get_Properties();
    public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public sealed virtual void Start(string sessionID);
    public sealed virtual bool get_IsStarted();
    protected virtual void DisposeManagedResources();
}
internal class Microsoft.VisualStudio.Telemetry.SessionChannel.WatsonSessionChannel : object {
    [CompilerGeneratedAttribute]
private TelemetrySession <TelemetrySession>k__BackingField;
    [CompilerGeneratedAttribute]
private static Random <Random>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <NumberOfWatsonReportsThisSession>k__BackingField;
    [CompilerGeneratedAttribute]
private static DateTime <DateTimeOfLastWatsonReport>k__BackingField;
    public static string MaxWatsonReportsReached;
    [CompilerGeneratedAttribute]
private int <FaultEventWatsonSamplePercent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FaultEventMaximumWatsonReportsPerSession>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FaultEventMinimumSecondsBetweenWatsonReports>k__BackingField;
    [CompilerGeneratedAttribute]
private ChannelProperties <Properties>k__BackingField;
    private TelemetrySession TelemetrySession { get; }
    internal static Random Random { get; }
    internal static int NumberOfWatsonReportsThisSession { get; internal set; }
    internal static DateTime DateTimeOfLastWatsonReport { get; internal set; }
    public int FaultEventWatsonSamplePercent { get; }
    public int FaultEventMaximumWatsonReportsPerSession { get; }
    public int FaultEventMinimumSecondsBetweenWatsonReports { get; }
    public string ChannelId { get; }
    public bool IsStarted { get; }
    public ChannelProperties Properties { get; public set; }
    public string TransportUsed { get; }
    public WatsonSessionChannel(TelemetrySession telemetrySession, int faultEventWatsonSamplePercent, int faultEventMaximumWatsonReportsPerSession, int faultEventMinimumSecondsBetweenWatsonReports);
    private static WatsonSessionChannel();
    [CompilerGeneratedAttribute]
private TelemetrySession get_TelemetrySession();
    [CompilerGeneratedAttribute]
internal static Random get_Random();
    [CompilerGeneratedAttribute]
internal static int get_NumberOfWatsonReportsThisSession();
    [CompilerGeneratedAttribute]
internal static void set_NumberOfWatsonReportsThisSession(int value);
    [CompilerGeneratedAttribute]
internal static DateTime get_DateTimeOfLastWatsonReport();
    [CompilerGeneratedAttribute]
internal static void set_DateTimeOfLastWatsonReport(DateTime value);
    [CompilerGeneratedAttribute]
public int get_FaultEventWatsonSamplePercent();
    [CompilerGeneratedAttribute]
public int get_FaultEventMaximumWatsonReportsPerSession();
    [CompilerGeneratedAttribute]
public int get_FaultEventMinimumSecondsBetweenWatsonReports();
    public sealed virtual string get_ChannelId();
    public sealed virtual bool get_IsStarted();
    [CompilerGeneratedAttribute]
public sealed virtual ChannelProperties get_Properties();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Properties(ChannelProperties value);
    public sealed virtual string get_TransportUsed();
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent, IEnumerable`1<ITelemetryManifestRouteArgs> args);
    public sealed virtual void Start(string sessionId);
}
internal class Microsoft.VisualStudio.Telemetry.SettingAction : DataModelPropertyAction`1<TelemetrySettingProperty> {
}
internal class Microsoft.VisualStudio.Telemetry.SuppressEmptyPostPropertyEventAction : object {
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryActivity : TelemetryEvent {
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    private Guid correlationId;
    private Guid parentCorrelationId;
    public Guid CorrelationId { get; }
    internal Guid ParentCorrelationId { get; }
    internal DateTime StartTime { get; private set; }
    internal DateTime EndTime { get; private set; }
    public TelemetryActivity(string eventName);
    public TelemetryActivity(string eventName, Guid parentCorrelationId);
    public Guid get_CorrelationId();
    internal Guid get_ParentCorrelationId();
    [CompilerGeneratedAttribute]
internal DateTime get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
internal DateTime get_EndTime();
    [CompilerGeneratedAttribute]
private void set_EndTime(DateTime value);
    public void Start();
    public void End();
    public void End(TimeSpan duration);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryActivity/<GetDefaultEventProperties>d__19")]
protected virtual IEnumerable`1<KeyValuePair`2<string, object>> GetDefaultEventProperties(long eventTime, long processStartTime, string sessionId);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<KeyValuePair`2<string, object>> <>n__0(long eventTime, long processStartTime, string sessionId);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryComplexProperty : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public TelemetryComplexProperty(object val);
    [CompilerGeneratedAttribute]
public object get_Value();
    [ExcludeFromCodeCoverageAttribute]
public virtual string ToString();
}
public class Microsoft.VisualStudio.Telemetry.TelemetryContext : TelemetryDisposableObject {
    private static int SchedulerDelay;
    private static string ContextPropertyPrefix;
    private static string ContextEventPrefix;
    private static string ContextEventCreate;
    private static string ContextEventClose;
    private static string ContextEventPostProperty;
    private PrefixedConcurrent`1<object> sharedProperties;
    private PrefixedConcurrent`1<Func`1<object>> realtimeSharedProperties;
    private ITelemetrySessionInternal telemetrySessionInternal;
    private bool overrideInit;
    private object disposeLocker;
    private ITelemetryScheduler scheduler;
    private ConcurrentQueue`1<PostPropertyEntry> postedProperties;
    private DateTime contextStart;
    private bool disposedContextPart;
    [CompilerGeneratedAttribute]
private string <ContextName>k__BackingField;
    public IDictionary`2<string, object> SharedProperties { get; }
    public IDictionary`2<string, Func`1<object>> RealtimeSharedProperties { get; }
    public bool HasSharedProperties { get; }
    public string ContextName { get; private set; }
    internal TelemetryContext(string contextName, ITelemetrySessionInternal telemetrySessionInternal, ITelemetryScheduler theScheduler, bool theOverrideInit, Action`1<TelemetryContext> initializationAction);
    public IDictionary`2<string, object> get_SharedProperties();
    public IDictionary`2<string, Func`1<object>> get_RealtimeSharedProperties();
    public bool get_HasSharedProperties();
    [CompilerGeneratedAttribute]
public string get_ContextName();
    [CompilerGeneratedAttribute]
private void set_ContextName(string value);
    public void PostProperty(string propertyName, object propertyValue);
    internal void PostProperty(string propertyName, object propertyValue, bool isReserved);
    internal void FlushPostedProperties();
    internal static bool IsContextNameValid(string contextName);
    internal void ProcessEvent(TelemetryEvent telemetryEvent, bool overwriteExisting);
    internal void ProcessEventRealtime(TelemetryEvent telemetryEvent);
    internal static void ValidateEvent(TelemetryEvent telemetryEvent);
    internal static void ValidatePropertyName(string propertyName);
    internal static bool IsPropertyNameReserved(string propertyName);
    internal static bool IsEventNameContextPostProperty(string eventName);
    protected virtual void DisposeManagedResources();
    private static void ValidateEventName(TelemetryEvent telemetryEvent);
    private static void ValidateEventProperties(TelemetryEvent telemetryEvent);
    private static string BuildEventName(string eventName);
    private TelemetryEvent BuildStartEvent();
    private TelemetryEvent BuildCloseEvent();
    private void AddReservedPropertiesToTheEvent(TelemetryEvent telemetryEvent);
    private TelemetryEvent CreateTelemetryEvent(string eventName);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryCredScanProperty : object {
    [CompilerGeneratedAttribute]
private string <StringValue>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ElapsedTimeInMs>k__BackingField;
    internal static string ReplacementText;
    private CredScanDataScrubber scrubber;
    public string StringValue { get; }
    public long ElapsedTimeInMs { get; }
    public TelemetryCredScanProperty(object val);
    private static TelemetryCredScanProperty();
    [CompilerGeneratedAttribute]
public string get_StringValue();
    [CompilerGeneratedAttribute]
public long get_ElapsedTimeInMs();
}
public abstract class Microsoft.VisualStudio.Telemetry.TelemetryDataModelProperty : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public TelemetryDataModelProperty(object val);
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual string ToString();
}
public abstract class Microsoft.VisualStudio.Telemetry.TelemetryDisposableObject : object {
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    protected void RequiresNotDisposed();
    protected virtual void DisposeManagedResources();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryEtwProvider : object {
    internal static string TelemetryProviderName;
    private EventSource telemetryEventSource;
    public sealed virtual void WriteActivityStartEvent(TelemetryActivity activity);
    public sealed virtual void WriteActivityStopEvent(TelemetryActivity activity);
    public sealed virtual void WriteActivityEndWithDurationEvent(TelemetryActivity activity);
    public sealed virtual void WriteActivityPostEvent(TelemetryActivity activity, TelemetrySession session);
    public sealed virtual void WriteTelemetryPostEvent(TelemetryEvent telemetryEvent, TelemetrySession session);
    private void WriteTelemetryEventSimple(TelemetryEvent telemetryEvent, EventSourceOptions options, TelemetrySession session);
    private void WriteTelemetryEventExtended(TelemetryEvent telemetryEvent, TelemetrySession session);
    private void WriteEventWithActivityId(TelemetryEvent telemetryEvent, string eventName, EventSourceOptions options, T userData);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryEvent : object {
    private static int SchemaVersion;
    private static string DataModelApiSource;
    private static TelemetrySeverity DefaultSeverity;
    internal static string ReservedPropertyPrefix;
    private string eventName;
    private NotConcurrent`1<object> eventProperties;
    private PrefixedNotConcurrent`1<object> reservedEventProperties;
    private HashSet`1<TelemetryPropertyBag> sharedPropertyBags;
    private Guid eventId;
    private TelemetrySeverity severity;
    [CompilerGeneratedAttribute]
private Dictionary`2<TelemetryEventCorrelation, string> <CorrelatedWith>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptOutFriendly>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventSchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryEventCorrelation <Correlation>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <PostTimestamp>k__BackingField;
    internal Dictionary`2<TelemetryEventCorrelation, string> CorrelatedWith { get; private set; }
    public bool IsOptOutFriendly { get; public set; }
    public TelemetrySeverity Severity { get; public set; }
    public DataModelEventType EventType { get; }
    public int EventSchemaVersion { get; }
    public string DataSource { get; }
    public TelemetryEventCorrelation Correlation { get; private set; }
    public string Name { get; }
    public IDictionary`2<string, object> Properties { get; }
    public bool HasProperties { get; }
    internal DateTimeOffset PostTimestamp { get; internal set; }
    public HashSet`1<TelemetryPropertyBag> SharedPropertyBags { get; }
    internal PrefixedNotConcurrent`1<object> ReservedProperties { get; }
    internal bool HasReservedProperties { get; }
    public TelemetryEvent(string eventName);
    public TelemetryEvent(string eventName, TelemetrySeverity severity);
    internal TelemetryEvent(string eventName, TelemetrySeverity severity, DataModelEventType eventType);
    internal TelemetryEvent(string eventName, TelemetrySeverity severity, TelemetryEventCorrelation correlation);
    [CompilerGeneratedAttribute]
internal Dictionary`2<TelemetryEventCorrelation, string> get_CorrelatedWith();
    [CompilerGeneratedAttribute]
private void set_CorrelatedWith(Dictionary`2<TelemetryEventCorrelation, string> value);
    [CompilerGeneratedAttribute]
public bool get_IsOptOutFriendly();
    [CompilerGeneratedAttribute]
public void set_IsOptOutFriendly(bool value);
    public TelemetrySeverity get_Severity();
    public void set_Severity(TelemetrySeverity value);
    public DataModelEventType get_EventType();
    [CompilerGeneratedAttribute]
public int get_EventSchemaVersion();
    public string get_DataSource();
    [CompilerGeneratedAttribute]
public TelemetryEventCorrelation get_Correlation();
    [CompilerGeneratedAttribute]
private void set_Correlation(TelemetryEventCorrelation value);
    public void Correlate(TelemetryEventCorrelation[] correlations);
    internal TelemetryEvent BuildChannelEvent(long processStartTime, string sessionId);
    internal TelemetryEvent CloneTelemetryEvent();
    protected void CorrelateWithDescription(TelemetryEventCorrelation correlation, string description);
    public string get_Name();
    public IDictionary`2<string, object> get_Properties();
    public bool get_HasProperties();
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_PostTimestamp();
    [CompilerGeneratedAttribute]
internal void set_PostTimestamp(DateTimeOffset value);
    public HashSet`1<TelemetryPropertyBag> get_SharedPropertyBags();
    internal PrefixedNotConcurrent`1<object> get_ReservedProperties();
    internal bool get_HasReservedProperties();
    internal static bool IsPropertyNameReserved(string propertyName);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryEvent/<GetDefaultEventProperties>d__57")]
protected virtual IEnumerable`1<KeyValuePair`2<string, object>> GetDefaultEventProperties(long eventTime, long processStartTime, string sessionId);
    private static KeyValuePair`2<string, object> AsReservedProperty(KeyValuePair`2<string, object> property);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryEvent/<GetCorrelatedWithProperties>d__59")]
private IEnumerable`1<KeyValuePair`2<string, object>> GetCorrelatedWithProperties();
    private IEnumerable`1<KeyValuePair`2<string, object>> GetAllProperties(long eventTime, long processStartTime, string sessionId);
    private void InitDataModelBasicProperties();
    public virtual string ToString();
}
public class Microsoft.VisualStudio.Telemetry.TelemetryEventCorrelation : ValueType {
    public static TelemetryEventCorrelation Empty;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DataModelEventType <EventType>k__BackingField;
    [JsonPropertyAttribute]
internal Guid Id { get; private set; }
    internal bool IsEmpty { get; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
internal DataModelEventType EventType { get; private set; }
    internal TelemetryEventCorrelation(Guid id, DataModelEventType eventType);
    private static TelemetryEventCorrelation();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    internal bool get_IsEmpty();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal DataModelEventType get_EventType();
    [CompilerGeneratedAttribute]
private void set_EventType(DataModelEventType value);
    public string Serialize();
    public static TelemetryEventCorrelation Deserialize(string jsonString);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.TelemetryEventCorrelationCodeContract : object {
    [ExtensionAttribute]
internal static void RequireNotEmpty(TelemetryEventCorrelation correlation, string argumentName);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryEventMatchByName : object {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFullNameCheck>k__BackingField;
    public string EventName { get; private set; }
    public bool IsFullNameCheck { get; private set; }
    public TelemetryEventMatchByName(string eventName, bool isFullNameCheck);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
private void set_EventName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsFullNameCheck();
    [CompilerGeneratedAttribute]
private void set_IsFullNameCheck(bool value);
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryHashedProperty : object {
    [CompilerGeneratedAttribute]
private string <StringValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RawValue>k__BackingField;
    public string StringValue { get; }
    public object RawValue { get; }
    public TelemetryHashedProperty(object val);
    [CompilerGeneratedAttribute]
public string get_StringValue();
    [CompilerGeneratedAttribute]
public object get_RawValue();
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryJsonLogFile : BaseJsonLogFile`1<TelemetryEvent> {
    public TelemetryJsonLogFile(ITelemetryWriter writer);
    protected virtual string ConvertEventToString(TelemetryEvent eventData);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryLogSettingsProvider : object {
    private static int fileVersion;
    private static int processId;
    private static int appDomainId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, string>> <MainIdentifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Folder>k__BackingField;
    public string FileNameFormatString { get; }
    public IEnumerable`1<KeyValuePair`2<string, string>> MainIdentifiers { get; public set; }
    public int ProcessId { get; }
    public int AppDomainId { get; }
    public string Path { get; public set; }
    public string Folder { get; public set; }
    public string FilePath { get; }
    private static TelemetryLogSettingsProvider();
    public string get_FileNameFormatString();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_MainIdentifiers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MainIdentifiers(IEnumerable`1<KeyValuePair`2<string, string>> value);
    public int get_ProcessId();
    public int get_AppDomainId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Path(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Folder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Folder(string value);
    public sealed virtual string get_FilePath();
    public sealed virtual string GetCreateFolderPath();
    public sealed virtual int GetNextUniqueId();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifest : object {
    public static UInt32 FormatVersion;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCollector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ThrottlingThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ThrottlingTimerReset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldSendAliasForAllInternalUsers>k__BackingField;
    [JsonIgnoreAttribute]
private HashSet`1<string> invalidRules;
    [CompilerGeneratedAttribute]
private int <InvalidActionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TelemetryManifestRule> <Rules>k__BackingField;
    [JsonPropertyAttribute]
public string Version { get; public set; }
    [DefaultValueAttribute("False")]
[JsonPropertyAttribute]
public bool UseCollector { get; public set; }
    [JsonPropertyAttribute]
public string Etag { get; public set; }
    [JsonPropertyAttribute]
public long ThrottlingThreshold { get; public set; }
    [JsonPropertyAttribute]
public double ThrottlingTimerReset { get; public set; }
    [DefaultValueAttribute("True")]
[JsonPropertyAttribute]
public bool ShouldSendAliasForAllInternalUsers { get; public set; }
    [JsonIgnoreAttribute]
public IEnumerable`1<string> InvalidRules { get; }
    [JsonIgnoreAttribute]
public int InvalidActionCount { get; private set; }
    [JsonPropertyAttribute]
public IEnumerable`1<TelemetryManifestRule> Rules { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_UseCollector();
    [CompilerGeneratedAttribute]
public void set_UseCollector(bool value);
    [CompilerGeneratedAttribute]
public string get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(string value);
    [CompilerGeneratedAttribute]
public long get_ThrottlingThreshold();
    [CompilerGeneratedAttribute]
public void set_ThrottlingThreshold(long value);
    [CompilerGeneratedAttribute]
public double get_ThrottlingTimerReset();
    [CompilerGeneratedAttribute]
public void set_ThrottlingTimerReset(double value);
    [CompilerGeneratedAttribute]
public bool get_ShouldSendAliasForAllInternalUsers();
    [CompilerGeneratedAttribute]
public void set_ShouldSendAliasForAllInternalUsers(bool value);
    public IEnumerable`1<string> get_InvalidRules();
    [CompilerGeneratedAttribute]
public int get_InvalidActionCount();
    [CompilerGeneratedAttribute]
private void set_InvalidActionCount(int value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TelemetryManifestRule> get_Rules();
    [CompilerGeneratedAttribute]
public void set_Rules(IEnumerable`1<TelemetryManifestRule> value);
    public static TelemetryManifest BuildDefaultManifest();
    public IEnumerable`1<ITelemetryManifestAction> GetActionsForEvent(TelemetryEvent telemetryEvent);
    public void Validate();
    internal string CalculateAllSamplings(TelemetrySession session);
    internal IEnumerable`1<Path> GetAllSamplings();
    [OnDeserializedAttribute]
internal void ValidateAfterDeserialization(StreamingContext context);
    [CompilerGeneratedAttribute]
private bool <Validate>b__38_0(TelemetryManifestRule rule);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionCredScan : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Properties>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<string> Properties { get; public set; }
    public int Priority { get; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IEnumerable`1<string> value);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionDoNotThrottle : TelemetryManifestActionThrottleBase {
    protected virtual void ExecuteThrottlingAction(IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionExclude : object {
    [JsonIgnoreAttribute]
private bool excludeAll;
    [JsonIgnoreAttribute]
private IEnumerable`1<string> channelsToExclude;
    [JsonPropertyAttribute]
public IEnumerable`1<string> ExcludeForChannels { get; public set; }
    [JsonIgnoreAttribute]
public int Priority { get; }
    public IEnumerable`1<string> get_ExcludeForChannels();
    public void set_ExcludeForChannels(IEnumerable`1<string> value);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionExcludeProperty : object {
    [CompilerGeneratedAttribute]
private string <ExcludeProperty>k__BackingField;
    [JsonPropertyAttribute]
public string ExcludeProperty { get; public set; }
    [JsonIgnoreAttribute]
public int Priority { get; }
    [CompilerGeneratedAttribute]
public string get_ExcludeProperty();
    [CompilerGeneratedAttribute]
public void set_ExcludeProperty(string value);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionHashed : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Properties>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<string> Properties { get; public set; }
    [JsonIgnoreAttribute]
public int Priority { get; }
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<string> get_Properties();
    [CompilerGeneratedAttribute]
public virtual void set_Properties(IEnumerable`1<string> value);
    public virtual int get_Priority();
    public virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public virtual void Validate();
}
internal abstract class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutBase : object {
    [JsonIgnoreAttribute]
public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public virtual void Validate();
    protected abstract virtual void ExecuteOptOutAction(IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutExcludeEvents : TelemetryManifestActionOptOutBase {
    protected virtual void ExecuteOptOutAction(IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutExcludeProperties : TelemetryManifestActionOptOutPropertiesBase {
    [JsonPropertyAttribute]
public IEnumerable`1<string> Properties { get; public set; }
    public IEnumerable`1<string> get_Properties();
    public void set_Properties(IEnumerable`1<string> value);
    protected virtual void ProcessPropertyName(string propertyName, IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutIncludeEvents : TelemetryManifestActionOptOutBase {
    protected virtual void ExecuteOptOutAction(IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutIncludeProperties : TelemetryManifestActionOptOutPropertiesBase {
    [JsonPropertyAttribute]
public IEnumerable`1<string> Properties { get; public set; }
    public IEnumerable`1<string> get_Properties();
    public void set_Properties(IEnumerable`1<string> value);
    protected virtual void ProcessPropertyName(string propertyName, IEventProcessorContext eventProcessorContext);
}
internal abstract class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionOptOutPropertiesBase : TelemetryManifestActionOptOutBase {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <PropertiesImpl>k__BackingField;
    [JsonIgnoreAttribute]
protected IEnumerable`1<string> PropertiesImpl { get; protected set; }
    [CompilerGeneratedAttribute]
protected IEnumerable`1<string> get_PropertiesImpl();
    [CompilerGeneratedAttribute]
protected void set_PropertiesImpl(IEnumerable`1<string> value);
    public virtual void Validate();
    protected virtual void ExecuteOptOutAction(IEventProcessorContext eventProcessorContext);
    protected abstract virtual void ProcessPropertyName(string propertyName, IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionPii : TelemetryManifestActionHashed {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Properties>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<string> Properties { get; public set; }
    [JsonIgnoreAttribute]
public int Priority { get; }
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<string> get_Properties();
    [CompilerGeneratedAttribute]
public virtual void set_Properties(IEnumerable`1<string> value);
    public virtual int get_Priority();
    public virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionRoute : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TelemetryManifestRouter> <Route>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<TelemetryManifestRouter> Route { get; public set; }
    [JsonIgnoreAttribute]
public int Priority { get; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<TelemetryManifestRouter> get_Route();
    [CompilerGeneratedAttribute]
public void set_Route(IEnumerable`1<TelemetryManifestRouter> value);
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionThrottle : TelemetryManifestActionThrottleBase {
    protected virtual void ExecuteThrottlingAction(IEventProcessorContext eventProcessorContext);
}
internal abstract class Microsoft.VisualStudio.Telemetry.TelemetryManifestActionThrottleBase : object {
    [JsonIgnoreAttribute]
public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public virtual void Validate();
    protected abstract virtual void ExecuteThrottlingAction(IEventProcessorContext eventProcessorContext);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private TelemetryManifest <TelemetryManifest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    public TelemetryManifest TelemetryManifest { get; }
    public bool IsSuccess { get; }
    public TelemetryManifestEventArgs(TelemetryManifest telemetryManifest);
    [CompilerGeneratedAttribute]
public TelemetryManifest get_TelemetryManifest();
    [CompilerGeneratedAttribute]
public bool get_IsSuccess();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestInvalidAction : object {
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool Execute(IEventProcessorContext eventProcessorContext);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestInvalidMatchItem : object {
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestInvalidMatchValueItem : object {
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestInvalidRouteArgs : object {
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestLegacyDatapointRouteArgs : object {
    [CompilerGeneratedAttribute]
private UInt32 <DatapointId>k__BackingField;
    [CompilerGeneratedAttribute]
private LegacyDatapointType <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private LegacyStringTruncationRule <TruncationRule>k__BackingField;
    [JsonPropertyAttribute]
public UInt32 DatapointId { get; public set; }
    [JsonPropertyAttribute]
public LegacyDatapointType DataType { get; public set; }
    [JsonPropertyAttribute]
public string ParameterName { get; public set; }
    [JsonPropertyAttribute]
public LegacyStringTruncationRule TruncationRule { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_DatapointId();
    [CompilerGeneratedAttribute]
public void set_DatapointId(UInt32 value);
    [CompilerGeneratedAttribute]
public LegacyDatapointType get_DataType();
    [CompilerGeneratedAttribute]
public void set_DataType(LegacyDatapointType value);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public void set_ParameterName(string value);
    [CompilerGeneratedAttribute]
public LegacyStringTruncationRule get_TruncationRule();
    [CompilerGeneratedAttribute]
public void set_TruncationRule(LegacyStringTruncationRule value);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestLegacyStreamPropertyRouteArgs : object {
    [CompilerGeneratedAttribute]
private LegacyDatapointType <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private LegacyStringTruncationRule <TruncationRule>k__BackingField;
    [JsonPropertyAttribute]
public LegacyDatapointType DataType { get; public set; }
    [JsonPropertyAttribute]
public string PropertyName { get; public set; }
    [JsonPropertyAttribute]
public LegacyStringTruncationRule TruncationRule { get; public set; }
    [CompilerGeneratedAttribute]
public LegacyDatapointType get_DataType();
    [CompilerGeneratedAttribute]
public void set_DataType(LegacyDatapointType value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public LegacyStringTruncationRule get_TruncationRule();
    [CompilerGeneratedAttribute]
public void set_TruncationRule(LegacyStringTruncationRule value);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestLegacyStreamRouteArgs : object {
    [CompilerGeneratedAttribute]
private UInt32 <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITelemetryManifestRouteArgs> <Properties>k__BackingField;
    [JsonPropertyAttribute]
public UInt32 StreamId { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<ITelemetryManifestRouteArgs> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(UInt32 value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ITelemetryManifestRouteArgs> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IEnumerable`1<ITelemetryManifestRouteArgs> value);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestManager : TelemetryDisposableObject {
    private static int RemoteControlReadFileTelemetryFrequency;
    private static TimeSpan DownloadInterval;
    private static TimeSpan ReadInterval;
    private static TimeSpan ForceReadDelay;
    private ITelemetryManifestParser manifestParser;
    private ITelemetryScheduler scheduler;
    private TelemetrySession mainSession;
    private IRemoteControlClient remoteControlClient;
    private ITelemetryManifestManagerSettings settings;
    private CancellationTokenSource tokenSource;
    private bool isStarted;
    [CompilerGeneratedAttribute]
private EventHandler`1<TelemetryManifestEventArgs> UpdateTelemetryManifestStatusEvent;
    [CompilerGeneratedAttribute]
private bool <ForcedReadManifest>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryManifest <CurrentManifest>k__BackingField;
    public bool ForcedReadManifest { get; private set; }
    internal TelemetryManifest CurrentManifest { get; private set; }
    public TelemetryManifestManager(IRemoteControlClient theRemoteControlClient, ITelemetryManifestManagerSettings theSettings, ITelemetryManifestParser theManifestParser, ITelemetryScheduler theScheduler, TelemetrySession theMainSession);
    private static TelemetryManifestManager();
    [CompilerGeneratedAttribute]
public sealed virtual void add_UpdateTelemetryManifestStatusEvent(EventHandler`1<TelemetryManifestEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_UpdateTelemetryManifestStatusEvent(EventHandler`1<TelemetryManifestEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ForcedReadManifest();
    [CompilerGeneratedAttribute]
private void set_ForcedReadManifest(bool value);
    [CompilerGeneratedAttribute]
internal TelemetryManifest get_CurrentManifest();
    [CompilerGeneratedAttribute]
private void set_CurrentManifest(TelemetryManifest value);
    public sealed virtual void Start(string hostName, bool isDisposing);
    public sealed virtual bool ForceReadManifest();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryManifestManager/<CheckAsync>d__25")]
internal Task CheckAsync();
    protected virtual void DisposeManagedResources();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryManifestManager/<CheckAsync>d__27")]
private Task CheckAsync(BehaviorOnStale staleBehavior, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryManifestManager/<LoadManifestAsync>d__28")]
private Task LoadManifestAsync(BehaviorOnStale staleBehavior, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryManifestManager/<ReadAndParseManifestAsync>d__29")]
private Task`1<Tuple`2<TelemetryManifest, long>> ReadAndParseManifestAsync(BehaviorOnStale staleBehavior);
    private void OnUpdateTelemetryManifestStatusEvent(TelemetryManifestEventArgs e);
    private void InstrumentLoad(TelemetryManifest telemetryManifest, long streamSize, string message, string errorDetails, double duration);
    [CompilerGeneratedAttribute]
private void <.ctor>b__22_0(string eventName, IDictionary`2<string, object> properties, IDictionary`2<string, object> piiProperties);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestManagerBuilder : object {
    private object remoteControlClient;
    private ITelemetryManifestManagerSettings settings;
    private ITelemetryManifestParser manifestParser;
    private ITelemetryScheduler scheduler;
    public TelemetryManifestManagerBuilder(object theRemoteControlClient, ITelemetryManifestManagerSettings theSettings, ITelemetryManifestParser theManifestParser, ITelemetryScheduler theScheduler);
    public sealed virtual ITelemetryManifestManager Build(TelemetrySession telemetrySession);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestManagerSettings : object {
    private string urlFilePath;
    private string urlFilePattern;
    [CompilerGeneratedAttribute]
private string <HostId>k__BackingField;
    public string BaseUrl { get; }
    public string HostId { get; }
    public string RelativePath { get; }
    public TelemetryManifestManagerSettings(string hostName, string theUrlFilePattern);
    public sealed virtual string get_BaseUrl();
    [CompilerGeneratedAttribute]
public sealed virtual string get_HostId();
    public sealed virtual string get_RelativePath();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchAnd : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITelemetryManifestMatch> <And>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<ITelemetryManifestMatch> And { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<ITelemetryManifestMatch> get_And();
    [CompilerGeneratedAttribute]
public void set_And(IEnumerable`1<ITelemetryManifestMatch> value);
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchEventName : object {
    [JsonIgnoreAttribute]
private TelemetryEventMatchByName eventMatchFilter;
    [JsonPropertyAttribute]
public string EventName { get; public set; }
    public string get_EventName();
    public void set_EventName(string value);
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchExtension : object {
    [ExtensionAttribute]
public static IEnumerable`1<ITelemetryManifestMatch> GetDescendants(ITelemetryManifestMatch match);
    [ExtensionAttribute]
public static IEnumerable`1<ITelemetryManifestMatch> GetDescendantsAndItself(ITelemetryManifestMatch match);
    [ExtensionAttribute]
public static void Validate(ITelemetryManifestMatch match);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchNot : object {
    [CompilerGeneratedAttribute]
private ITelemetryManifestMatch <Not>k__BackingField;
    [JsonPropertyAttribute]
public ITelemetryManifestMatch Not { get; public set; }
    [CompilerGeneratedAttribute]
public ITelemetryManifestMatch get_Not();
    [CompilerGeneratedAttribute]
public void set_Not(ITelemetryManifestMatch value);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchNot/<GetChildren>d__4")]
public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchOr : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITelemetryManifestMatch> <Or>k__BackingField;
    [JsonPropertyAttribute]
public IEnumerable`1<ITelemetryManifestMatch> Or { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<ITelemetryManifestMatch> get_Or();
    [CompilerGeneratedAttribute]
public void set_Or(IEnumerable`1<ITelemetryManifestMatch> value);
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchPropertyValue : object {
    [JsonIgnoreAttribute]
private string propertyName;
    [CompilerGeneratedAttribute]
private ITelemetryManifestMatchValue <Value>k__BackingField;
    [JsonPropertyAttribute]
public string Property { get; public set; }
    [JsonPropertyAttribute]
public ITelemetryManifestMatchValue Value { get; public set; }
    public string get_Property();
    public void set_Property(string value);
    [CompilerGeneratedAttribute]
public ITelemetryManifestMatchValue get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(ITelemetryManifestMatchValue value);
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchSampling : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Rate>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<HashInput> <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSampleActive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCalculateCalled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRateTooLow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRateTooHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInputStringEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InputString>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Hash>k__BackingField;
    [JsonPropertyAttribute]
public string Name { get; public set; }
    [JsonPropertyAttribute]
public double Rate { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<HashInput> Inputs { get; public set; }
    [JsonIgnoreAttribute]
public bool IsSampleActive { get; public set; }
    [JsonIgnoreAttribute]
public bool IsCalculateCalled { get; private set; }
    [JsonIgnoreAttribute]
public bool IsRateTooLow { get; private set; }
    [JsonIgnoreAttribute]
public bool IsRateTooHigh { get; private set; }
    [JsonIgnoreAttribute]
public bool IsInputStringEmpty { get; private set; }
    [JsonIgnoreAttribute]
public string InputString { get; private set; }
    [JsonIgnoreAttribute]
public ulong Hash { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public double get_Rate();
    [CompilerGeneratedAttribute]
public void set_Rate(double value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<HashInput> get_Inputs();
    [CompilerGeneratedAttribute]
public void set_Inputs(IEnumerable`1<HashInput> value);
    [CompilerGeneratedAttribute]
public bool get_IsSampleActive();
    [CompilerGeneratedAttribute]
public void set_IsSampleActive(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCalculateCalled();
    [CompilerGeneratedAttribute]
private void set_IsCalculateCalled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRateTooLow();
    [CompilerGeneratedAttribute]
private void set_IsRateTooLow(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRateTooHigh();
    [CompilerGeneratedAttribute]
private void set_IsRateTooHigh(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInputStringEmpty();
    [CompilerGeneratedAttribute]
private void set_IsInputStringEmpty(bool value);
    [CompilerGeneratedAttribute]
public string get_InputString();
    [CompilerGeneratedAttribute]
private void set_InputString(string value);
    [CompilerGeneratedAttribute]
public ulong get_Hash();
    [CompilerGeneratedAttribute]
private void set_Hash(ulong value);
    public sealed virtual bool IsEventMatch(TelemetryEvent telemetryEvent);
    public sealed virtual IEnumerable`1<ITelemetryManifestMatch> GetChildren();
    public string GetFullName(TelemetryManifestRule rule);
    public void CalculateIsSampleActive(TelemetryManifestRule rule, TelemetrySession session);
    private sealed virtual override void Microsoft.VisualStudio.Telemetry.ITelemetryManifestMatch.ValidateItself();
    [CompilerGeneratedAttribute]
private bool <CalculateIsSampleActive>b__43_0(Tuple`2<HashInput, string> t);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueContains : object {
    [CompilerGeneratedAttribute]
private string <Contains>k__BackingField;
    [JsonPropertyAttribute]
public string Contains { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Contains();
    [CompilerGeneratedAttribute]
public void set_Contains(string value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueEndsWith : object {
    [CompilerGeneratedAttribute]
private string <EndsWith>k__BackingField;
    [JsonPropertyAttribute]
public string EndsWith { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EndsWith();
    [CompilerGeneratedAttribute]
public void set_EndsWith(string value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueEq : object {
    [CompilerGeneratedAttribute]
private string <Eq>k__BackingField;
    [JsonPropertyAttribute]
public string Eq { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Eq();
    [CompilerGeneratedAttribute]
public void set_Eq(string value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueExists : object {
    [CompilerGeneratedAttribute]
private bool <Exists>k__BackingField;
    [JsonPropertyAttribute]
public bool Exists { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Exists();
    [CompilerGeneratedAttribute]
public void set_Exists(bool value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueGt : object {
    [CompilerGeneratedAttribute]
private double <Gt>k__BackingField;
    [JsonPropertyAttribute]
public double Gt { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Gt();
    [CompilerGeneratedAttribute]
public void set_Gt(double value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueLt : object {
    [CompilerGeneratedAttribute]
private double <Lt>k__BackingField;
    [JsonPropertyAttribute]
public double Lt { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Lt();
    [CompilerGeneratedAttribute]
public void set_Lt(double value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestMatchValueStartsWith : object {
    [CompilerGeneratedAttribute]
private string <StartsWith>k__BackingField;
    [JsonPropertyAttribute]
public string StartsWith { get; public set; }
    [CompilerGeneratedAttribute]
public string get_StartsWith();
    [CompilerGeneratedAttribute]
public void set_StartsWith(string value);
    public sealed virtual bool IsMatch(object valueToCompare);
    public sealed virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestParserException : Exception {
    public TelemetryManifestParserException(string description, Exception innerException);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestRouter : object {
    [CompilerGeneratedAttribute]
private string <ChannelId>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryManifestRouteArgs <Args>k__BackingField;
    [JsonPropertyAttribute]
public string ChannelId { get; public set; }
    [JsonPropertyAttribute]
public ITelemetryManifestRouteArgs Args { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ChannelId();
    [CompilerGeneratedAttribute]
public void set_ChannelId(string value);
    [CompilerGeneratedAttribute]
public ITelemetryManifestRouteArgs get_Args();
    [CompilerGeneratedAttribute]
public void set_Args(ITelemetryManifestRouteArgs value);
    public virtual void Validate();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestRule : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InvalidActionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryManifestMatch <When>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITelemetryManifestAction> <Actions>k__BackingField;
    [JsonPropertyAttribute]
public string Name { get; public set; }
    [JsonIgnoreAttribute]
public int InvalidActionCount { get; private set; }
    [JsonPropertyAttribute]
public ITelemetryManifestMatch When { get; public set; }
    [JsonPropertyAttribute]
public IEnumerable`1<ITelemetryManifestAction> Actions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_InvalidActionCount();
    [CompilerGeneratedAttribute]
private void set_InvalidActionCount(int value);
    [CompilerGeneratedAttribute]
public ITelemetryManifestMatch get_When();
    [CompilerGeneratedAttribute]
public void set_When(ITelemetryManifestMatch value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ITelemetryManifestAction> get_Actions();
    [CompilerGeneratedAttribute]
public void set_Actions(IEnumerable`1<ITelemetryManifestAction> value);
    public IEnumerable`1<TelemetryManifestMatchSampling> GetAllSamplings();
    public string CalculateAllSamplings(TelemetrySession session);
    public virtual void Validate();
    [CompilerGeneratedAttribute]
private bool <Validate>b__18_0(ITelemetryManifestAction action);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryManifestValidationException : Exception {
    public TelemetryManifestValidationException(string description);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryMetricProperty : TelemetryDataModelProperty {
    public TelemetryMetricProperty(double val);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryNullEtwProvider : object {
    public sealed virtual void WriteActivityEndWithDurationEvent(TelemetryActivity activity);
    public sealed virtual void WriteActivityPostEvent(TelemetryActivity activity, TelemetrySession session);
    public sealed virtual void WriteActivityStartEvent(TelemetryActivity activity);
    public sealed virtual void WriteActivityStopEvent(TelemetryActivity activity);
    public sealed virtual void WriteTelemetryPostEvent(TelemetryEvent telemetryEvent, TelemetrySession session);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryPiiProperty : TelemetryHashedProperty {
    public TelemetryPiiProperty(object val);
    public virtual string ToString();
}
public class Microsoft.VisualStudio.Telemetry.TelemetryPropertyBag : Concurrent`1<object> {
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Telemetry.TelemetryPropertyBags : object {
    internal static StringComparer KeyComparer;
    private static TelemetryPropertyBags();
    [ExtensionAttribute]
public static bool HasProperties(ITelemetryPropertyBag`1<TValue> bag);
}
public enum Microsoft.VisualStudio.Telemetry.TelemetryResult : Enum {
    public int value__;
    public static TelemetryResult None;
    public static TelemetryResult Success;
    public static TelemetryResult Failure;
    public static TelemetryResult UserFault;
    public static TelemetryResult UserCancel;
}
public static class Microsoft.VisualStudio.Telemetry.TelemetryResultStrings : object {
    internal static string GetString(TelemetryResult result);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryScheduler : object {
    internal static int IsInProgressOfProcessingEvent;
    internal static int NotInProgressOfProcessingEvent;
    private int isInProcess;
    private TelemetryTaskTimer taskTimer;
    internal int IsInProgress { get; }
    internal int get_IsInProgress();
    public sealed virtual void Schedule(Func`1<Task> actionTask, Nullable`1<CancellationToken> token);
    public sealed virtual void Schedule(Action action, Nullable`1<CancellationToken> token);
    public sealed virtual void InitializeTimed(TimeSpan delay);
    public sealed virtual void ScheduleTimed(Func`1<Task> actionTask, bool recurring);
    public sealed virtual void ScheduleTimed(Action action, bool recurring);
    public sealed virtual bool CanEnterTimedDelegate();
    public sealed virtual void ExitTimedDelegate();
    public sealed virtual void CancelTimed(bool wait);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryScope`1 : object {
    [CompilerGeneratedAttribute]
private TelemetrySession <TelemetrySession>k__BackingField;
    private static int ScopeIsEnded;
    private static int ScopeIsNotEnded;
    private int isEnded;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private T <EndEvent>k__BackingField;
    private TelemetrySession TelemetrySession { get; private set; }
    private DateTime StartTime { get; private set; }
    public bool IsEnd { get; }
    public T EndEvent { get; }
    public TelemetryEventCorrelation Correlation { get; }
    internal TelemetryScope`1(TelemetrySession telemetrySession, string eventName, CreateNewEvent<T> createNewEvent, TelemetryScopeSettings settings);
    [CompilerGeneratedAttribute]
private TelemetrySession get_TelemetrySession();
    [CompilerGeneratedAttribute]
private void set_TelemetrySession(TelemetrySession value);
    [CompilerGeneratedAttribute]
private DateTime get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTime value);
    public bool get_IsEnd();
    [CompilerGeneratedAttribute]
public T get_EndEvent();
    public TelemetryEventCorrelation get_Correlation();
    public void End(TelemetryResult result, string resultSummary);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryScopeSettings : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <StartEventProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetrySeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptOutFriendly>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryEventCorrelation[] <Correlations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PostStartEvent>k__BackingField;
    public IDictionary`2<string, object> StartEventProperties { get; public set; }
    public TelemetrySeverity Severity { get; public set; }
    public bool IsOptOutFriendly { get; public set; }
    public TelemetryEventCorrelation[] Correlations { get; public set; }
    public bool PostStartEvent { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_StartEventProperties();
    [CompilerGeneratedAttribute]
public void set_StartEventProperties(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public TelemetrySeverity get_Severity();
    [CompilerGeneratedAttribute]
public void set_Severity(TelemetrySeverity value);
    [CompilerGeneratedAttribute]
public bool get_IsOptOutFriendly();
    [CompilerGeneratedAttribute]
public void set_IsOptOutFriendly(bool value);
    [CompilerGeneratedAttribute]
public TelemetryEventCorrelation[] get_Correlations();
    [CompilerGeneratedAttribute]
public void set_Correlations(TelemetryEventCorrelation[] value);
    [CompilerGeneratedAttribute]
public bool get_PostStartEvent();
    [CompilerGeneratedAttribute]
public void set_PostStartEvent(bool value);
}
[CLSCompliantAttribute("False")]
public static class Microsoft.VisualStudio.Telemetry.TelemetryService : object {
    private static object lockDefaultSessionCreation;
    [CompilerGeneratedAttribute]
private static TelemetrySession <InternalDefaultSession>k__BackingField;
    [CompilerGeneratedAttribute]
private static ITelemetryEtwProvider <TelemetryEventSource>k__BackingField;
    internal static TelemetrySession InternalDefaultSession { get; internal set; }
    public static TelemetrySession DefaultSession { get; }
    public static AssetService AssetService { get; }
    internal static ITelemetryEtwProvider TelemetryEventSource { get; internal set; }
    private static TelemetryService();
    [CompilerGeneratedAttribute]
internal static TelemetrySession get_InternalDefaultSession();
    [CompilerGeneratedAttribute]
internal static void set_InternalDefaultSession(TelemetrySession value);
    public static TelemetrySession get_DefaultSession();
    public static AssetService get_AssetService();
    [CompilerGeneratedAttribute]
internal static ITelemetryEtwProvider get_TelemetryEventSource();
    [CompilerGeneratedAttribute]
internal static void set_TelemetryEventSource(ITelemetryEtwProvider value);
    public static void SetDefaultSession(TelemetrySession telemetrySession);
    public static bool TrySetDefaultSession(TelemetrySession telemetrySession);
    public static TelemetrySession CreateAndGetDefaultSession(string appInsightsIKey, string asimovIKey);
    public static TelemetrySession CreateAndGetDefaultSession(string collectorApiKey);
    public static TelemetrySession CreateAndGetDefaultSession(string appInsightsIKey, string asimovIKey, string collectorApiKey);
    public static void AttachTestChannel(ITelemetryTestChannel channel);
    public static void DetachTestChannel(ITelemetryTestChannel channel);
    public static void InitializeEtwProvider(ITelemetryEtwProvider provider);
    internal static void EnsureEtwProviderInitialized();
}
public class Microsoft.VisualStudio.Telemetry.TelemetrySession : TelemetryDisposableObject {
    public static string ValueNotAvailable;
    public static string DefaultContextName;
    private ITelemetrySessionInternal internalTelemetrySessionObject;
    internal bool UseCollector { get; internal set; }
    public string SessionId { get; }
    internal VisualStudioCodeTelemetryLevel TelemetryLevel { get; }
    internal ProductTarget HostProduct { get; }
    public bool IsOptedIn { get; public set; }
    public List`1<BucketFilter> BucketFiltersToEnableWatsonForFaults { get; public set; }
    public List`1<BucketFilter> BucketFiltersToAddDumpsToFaults { get; public set; }
    public string HostName { get; public set; }
    public CancellationToken CancellationToken { get; }
    [CLSCompliantAttribute("False")]
public UInt32 AppId { get; public set; }
    public bool CanCollectPrivateInformation { get; }
    public bool IsUserMicrosoftInternal { get; }
    public string CalculatedSamplings { get; }
    public Guid MachineId { get; }
    public Guid UserId { get; }
    public string MacAddressHash { get; }
    public long TimeSinceSessionStart { get; }
    unknown Action InitializedAction {internal set; }
    internal EventHandler`1<TelemetryTestChannelEventArgs> RawTelemetryEventReceived { get; internal set; }
    internal EventProcessor EventProcessor { get; }
    internal TelemetryContext DefaultContext { get; }
    internal bool IsSessionCloned { get; }
    internal TelemetrySessionSettings SessionSettings { get; }
    internal ITelemetryManifestManager ManifestManager { get; }
    internal long ProcessStartTime { get; }
    internal int ProcessPid { get; }
    public string GlobalStorageUri { get; internal set; }
    public TelemetrySession(string serializedSession);
    internal TelemetrySession(TelemetrySessionSettings telemetrySessionSettings);
    internal TelemetrySession(string serializedSession, TelemetrySessionInitializer initializerObject);
    internal TelemetrySession(TelemetrySessionSettings settings, bool isCloned, TelemetrySessionInitializer initializerObject);
    internal ITelemetrySessionInternal GetTelemetrySessionInternal();
    internal void SetTelemetrySessionInternal(ITelemetrySessionInternal internalSession);
    internal bool get_UseCollector();
    internal void set_UseCollector(bool value);
    public string get_SessionId();
    internal VisualStudioCodeTelemetryLevel get_TelemetryLevel();
    internal ProductTarget get_HostProduct();
    public bool get_IsOptedIn();
    public void set_IsOptedIn(bool value);
    public List`1<BucketFilter> get_BucketFiltersToEnableWatsonForFaults();
    public void set_BucketFiltersToEnableWatsonForFaults(List`1<BucketFilter> value);
    public List`1<BucketFilter> get_BucketFiltersToAddDumpsToFaults();
    public void set_BucketFiltersToAddDumpsToFaults(List`1<BucketFilter> value);
    public string get_HostName();
    public void set_HostName(string value);
    public CancellationToken get_CancellationToken();
    public UInt32 get_AppId();
    public void set_AppId(UInt32 value);
    public bool get_CanCollectPrivateInformation();
    public bool get_IsUserMicrosoftInternal();
    public string get_CalculatedSamplings();
    public Guid get_MachineId();
    public Guid get_UserId();
    public string get_MacAddressHash();
    public long get_TimeSinceSessionStart();
    internal void set_InitializedAction(Action value);
    internal EventHandler`1<TelemetryTestChannelEventArgs> get_RawTelemetryEventReceived();
    internal void set_RawTelemetryEventReceived(EventHandler`1<TelemetryTestChannelEventArgs> value);
    internal EventProcessor get_EventProcessor();
    internal TelemetryContext get_DefaultContext();
    internal bool get_IsSessionCloned();
    internal TelemetrySessionSettings get_SessionSettings();
    internal ITelemetryManifestManager get_ManifestManager();
    public void Start();
    public void UseVsIsOptedIn(string productVersion);
    public void UseVsIsOptedIn();
    public TelemetryContext CreateContext(string contextName);
    public TelemetryContext GetContext(string contextName);
    public void PostEvent(string eventName);
    public void PostEvent(TelemetryEvent telemetryEvent);
    public void PostMetricEvent(TelemetryMetricEvent metricEvent);
    public void PostProperty(string propertyName, object propertyValue);
    public void PostRecurringProperty(string propertyName, object propertyValue);
    public void AddSessionChannel(ISessionChannel sessionChannel);
    public string SerializeSettings();
    public void SetSharedProperty(string propertyName, object propertyValue);
    public void RemoveSharedProperty(string propertyName);
    public object GetSharedProperty(string propertyName);
    public object GetSharedPropertyAsObject(string propertyName);
    public void SetPersistedSharedProperty(string propertyName, string propertyValue);
    public void SetPersistedSharedProperty(string propertyName, double propertyValue);
    public void RemovePersistedSharedProperty(string propertyName);
    public object GetPersistedSharedProperty(string propertyName);
    public void RegisterPropertyBag(string name, TelemetryPropertyBag propertyBag);
    public void UnregisterPropertyBag(string name);
    public TelemetryPropertyBag GetPropertyBag(string name);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetrySession/<DisposeToNetworkAsync>d__86")]
public Task DisposeToNetworkAsync(CancellationToken token);
    public void RegisterForReliabilityEvent();
    internal long get_ProcessStartTime();
    internal int get_ProcessPid();
    internal void Start(bool checkPendingAsimovEvents);
    internal static TelemetrySession Create();
    internal static TelemetrySession Create(TelemetrySessionInitializer initializerObject);
    internal bool Equals(TelemetrySession other);
    internal void PostValidatedEvent(TelemetryEvent telemetryEvent);
    internal void AddContext(TelemetryContext telemetryContext);
    internal void RemoveContext(TelemetryContext telemetryContext);
    internal void AddSessionChannels(IEnumerable`1<ISessionChannel> channels);
    internal bool GetCachedUseCollectorFromRegistry();
    internal bool SetUseCollectorToRegistry(Nullable`1<bool> value);
    internal void AddContextProperties(TelemetryEvent telemetryEvent);
    internal static string Guard(Func`1<string> provider, string defaultValue);
    internal static void ValidateEvent(TelemetryEvent telemetryEvent);
    internal void ProcessManifestUseCollectorProperty(TelemetryManifest manifest);
    public virtual string ToString();
    protected virtual void DisposeManagedResources();
    public void AddCommonPropertyRange(IDictionary`2<string, object> properties);
    public bool TryAddCommonProperty(string propertyName, object propertyValue);
    public bool TryGetCommonPropertyValue(string propertyName, Object& value);
    public IDictionary`2<string, object> GetCommonPropertyDictionary();
    public string get_GlobalStorageUri();
    internal void set_GlobalStorageUri(string value);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Telemetry.TelemetrySessionCommandLineExtensions : object {
    internal static string CommandLineFlagsEventName;
    internal static string CommandLineFlagsPropertiesPrefix;
    internal static string CommandLineFlagsArgumentsCountProperty;
    internal static string CommandLineFlagsFlagsCountProperty;
    internal static string CommandLineFlagsFirstFlagProperty;
    internal static string CommandLineFlagsFlagsProperty;
    [CompilerGeneratedAttribute]
private static Func`1<String[]> <GetCommandLineArgsFunc>k__BackingField;
    internal static Func`1<String[]> GetCommandLineArgsFunc { get; internal set; }
    private static TelemetrySessionCommandLineExtensions();
    [ExtensionAttribute]
public static void PostCommandLineFlags(TelemetrySession session, String[] flagPrefixes);
    [ExtensionAttribute]
public static void PostCommandLineFlags(TelemetrySession session, IEnumerable`1<string> flagPrefixes, IDictionary`2<string, object> additionalProperties);
    [CompilerGeneratedAttribute]
internal static Func`1<String[]> get_GetCommandLineArgsFunc();
    [CompilerGeneratedAttribute]
internal static void set_GetCommandLineArgsFunc(Func`1<String[]> value);
    private static CommandLineFlagsInfo ComputeCommandLineFlags(IEnumerable`1<string> flagPrefixes);
    private static String[] GetCommandLineArgs();
    [ExtensionAttribute]
private static Tuple`2<bool, string> TryGetValidFlag(string argument, String[] flagPrefixes);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Telemetry.TelemetrySessionExtensions : object {
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostUserTask(TelemetrySession session, string eventName, TelemetryResult result, string resultSummary, TelemetryEventCorrelation[] correlatedWith);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostOperation(TelemetrySession session, string eventName, TelemetryResult result, string resultSummary, TelemetryEventCorrelation[] correlatedWith);
    [ExtensionAttribute]
public static TelemetryScope`1<UserTaskEvent> StartUserTask(TelemetrySession session, string eventName);
    [ExtensionAttribute]
public static TelemetryScope`1<UserTaskEvent> StartUserTask(TelemetrySession session, string eventName, TelemetrySeverity severity);
    [ExtensionAttribute]
public static TelemetryScope`1<UserTaskEvent> StartUserTask(TelemetrySession session, string eventName, TelemetrySeverity severity, IDictionary`2<string, object> startEventProperties);
    [ExtensionAttribute]
public static TelemetryScope`1<UserTaskEvent> StartUserTask(TelemetrySession session, string eventName, TelemetrySeverity severity, IDictionary`2<string, object> startEventProperties, TelemetryEventCorrelation[] correlations);
    [ExtensionAttribute]
public static TelemetryScope`1<UserTaskEvent> StartUserTask(TelemetrySession session, string eventName, TelemetryScopeSettings settings);
    [ExtensionAttribute]
public static TelemetryScope`1<OperationEvent> StartOperation(TelemetrySession session, string eventName);
    [ExtensionAttribute]
public static TelemetryScope`1<OperationEvent> StartOperation(TelemetrySession session, string eventName, TelemetrySeverity severity);
    [ExtensionAttribute]
public static TelemetryScope`1<OperationEvent> StartOperation(TelemetrySession session, string eventName, TelemetrySeverity severity, IDictionary`2<string, object> startEventProperties);
    [ExtensionAttribute]
public static TelemetryScope`1<OperationEvent> StartOperation(TelemetrySession session, string eventName, TelemetrySeverity severity, IDictionary`2<string, object> startEventProperties, TelemetryEventCorrelation[] correlations);
    [ExtensionAttribute]
public static TelemetryScope`1<OperationEvent> StartOperation(TelemetrySession session, string eventName, TelemetryScopeSettings settings);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, FaultSeverity faultSeverity);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, Exception exceptionObject);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, FaultSeverity faultSeverity, Exception exceptionObject);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, FaultSeverity faultSeverity, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails, TelemetryEventCorrelation[] correlatedWith);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostFault(TelemetrySession telemetrySession, string eventName, string description, FaultSeverity faultSeverity, Exception exceptionObject, Func`2<IFaultUtility, int> gatherEventDetails, TelemetryEventCorrelation[] correlatedWith);
    [ExtensionAttribute]
public static TelemetryEventCorrelation PostAsset(TelemetrySession telemetrySession, string eventName, string assetId, int assetEventVersion, IDictionary`2<string, object> properties, TelemetryEventCorrelation[] correlatedWith);
    [ExtensionAttribute]
private static TelemetryEventCorrelation PostOperationHelper(TelemetrySession session, Func`1<T> createEvent, TelemetryEventCorrelation[] correlatedWith);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetrySessionInitializer : object {
    [CompilerGeneratedAttribute]
private CancellationTokenSource <CancellationTokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppInsightsInstrumentationKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AsimovInstrumentationKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectorApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IDiagnosticTelemetry <DiagnosticTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnvironmentTools <EnvironmentTools>k__BackingField;
    [CompilerGeneratedAttribute]
private IVsOptInStatusInformationProvider <OptinStatusReader>k__BackingField;
    [CompilerGeneratedAttribute]
private IProcessTools <ProcessTools>k__BackingField;
    [CompilerGeneratedAttribute]
private ISQMApi <SQMApi>k__BackingField;
    [CompilerGeneratedAttribute]
private IInternalSettings <InternalSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IHostInformationProvider <HostInformationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IMachineInformationProvider <MachineInformationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IMACInformationProvider <MACInformationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IUserInformationProvider <UserInformationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeveloperDeviceInformationProvider <DeveloperDeviceInformationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IUniqueIdentifierInformationProvider <UniqueIdentifierInformationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryScheduler <EventProcessorScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryScheduler <ContextScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryScheduler <RecurringPropertyUpdateScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryScheduler <RecurringPropertyScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryManifestManagerBuilder <TelemetryManifestManagerBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IContextPropertyManager <DefaultContextPropertyManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IPersistentPropertyBag <PersistentStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private IPersistentPropertyBag <PersistentSharedProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IPersistentPropertyBag <PersistentPropertyBag>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IChannelValidator> <ChannelValidators>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ISessionChannel> <ChannelsToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IEventProcessorAction> <CustomActionToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPropertyProvider> <PropertyProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private EventProcessorChannelBuilder <EventProcessorChannelBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private WatsonSessionChannelBuilder <WatsonSessionChannelBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IProcessCreationTime <ProcessCreationTime>k__BackingField;
    public CancellationTokenSource CancellationTokenSource { get; public set; }
    public string SessionId { get; public set; }
    public string AppInsightsInstrumentationKey { get; public set; }
    public string AsimovInstrumentationKey { get; public set; }
    public string CollectorApiKey { get; public set; }
    public IDiagnosticTelemetry DiagnosticTelemetry { get; public set; }
    public IEnvironmentTools EnvironmentTools { get; public set; }
    public IVsOptInStatusInformationProvider OptinStatusReader { get; public set; }
    public IProcessTools ProcessTools { get; public set; }
    public ISQMApi SQMApi { get; public set; }
    public IInternalSettings InternalSettings { get; public set; }
    public IHostInformationProvider HostInformationProvider { get; public set; }
    public IMachineInformationProvider MachineInformationProvider { get; public set; }
    public IMACInformationProvider MACInformationProvider { get; public set; }
    public IUserInformationProvider UserInformationProvider { get; public set; }
    public IDeveloperDeviceInformationProvider DeveloperDeviceInformationProvider { get; public set; }
    public IUniqueIdentifierInformationProvider UniqueIdentifierInformationProvider { get; public set; }
    public ITelemetryScheduler EventProcessorScheduler { get; public set; }
    public ITelemetryScheduler ContextScheduler { get; public set; }
    public ITelemetryScheduler RecurringPropertyUpdateScheduler { get; public set; }
    public ITelemetryScheduler RecurringPropertyScheduler { get; public set; }
    public ITelemetryManifestManagerBuilder TelemetryManifestManagerBuilder { get; public set; }
    public IContextPropertyManager DefaultContextPropertyManager { get; public set; }
    public IPersistentPropertyBag PersistentStorage { get; public set; }
    public IPersistentPropertyBag PersistentSharedProperties { get; public set; }
    public IPersistentPropertyBag PersistentPropertyBag { get; public set; }
    public IEnumerable`1<IChannelValidator> ChannelValidators { get; public set; }
    public IEnumerable`1<ISessionChannel> ChannelsToAdd { get; public set; }
    public IEnumerable`1<IEventProcessorAction> CustomActionToAdd { get; public set; }
    public IEnumerable`1<IPropertyProvider> PropertyProviders { get; public set; }
    public EventProcessorChannelBuilder EventProcessorChannelBuilder { get; public set; }
    public WatsonSessionChannelBuilder WatsonSessionChannelBuilder { get; public set; }
    public IProcessCreationTime ProcessCreationTime { get; public set; }
    public static TelemetrySessionInitializer Default { get; }
    [CompilerGeneratedAttribute]
public CancellationTokenSource get_CancellationTokenSource();
    [CompilerGeneratedAttribute]
public void set_CancellationTokenSource(CancellationTokenSource value);
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(string value);
    [CompilerGeneratedAttribute]
public string get_AppInsightsInstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_AppInsightsInstrumentationKey(string value);
    [CompilerGeneratedAttribute]
public string get_AsimovInstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_AsimovInstrumentationKey(string value);
    [CompilerGeneratedAttribute]
public string get_CollectorApiKey();
    [CompilerGeneratedAttribute]
public void set_CollectorApiKey(string value);
    [CompilerGeneratedAttribute]
public IDiagnosticTelemetry get_DiagnosticTelemetry();
    [CompilerGeneratedAttribute]
public void set_DiagnosticTelemetry(IDiagnosticTelemetry value);
    [CompilerGeneratedAttribute]
public IEnvironmentTools get_EnvironmentTools();
    [CompilerGeneratedAttribute]
public void set_EnvironmentTools(IEnvironmentTools value);
    [CompilerGeneratedAttribute]
public IVsOptInStatusInformationProvider get_OptinStatusReader();
    [CompilerGeneratedAttribute]
public void set_OptinStatusReader(IVsOptInStatusInformationProvider value);
    [CompilerGeneratedAttribute]
public IProcessTools get_ProcessTools();
    [CompilerGeneratedAttribute]
public void set_ProcessTools(IProcessTools value);
    [CompilerGeneratedAttribute]
public ISQMApi get_SQMApi();
    [CompilerGeneratedAttribute]
public void set_SQMApi(ISQMApi value);
    [CompilerGeneratedAttribute]
public IInternalSettings get_InternalSettings();
    [CompilerGeneratedAttribute]
public void set_InternalSettings(IInternalSettings value);
    [CompilerGeneratedAttribute]
public IHostInformationProvider get_HostInformationProvider();
    [CompilerGeneratedAttribute]
public void set_HostInformationProvider(IHostInformationProvider value);
    [CompilerGeneratedAttribute]
public IMachineInformationProvider get_MachineInformationProvider();
    [CompilerGeneratedAttribute]
public void set_MachineInformationProvider(IMachineInformationProvider value);
    [CompilerGeneratedAttribute]
public IMACInformationProvider get_MACInformationProvider();
    [CompilerGeneratedAttribute]
public void set_MACInformationProvider(IMACInformationProvider value);
    [CompilerGeneratedAttribute]
public IUserInformationProvider get_UserInformationProvider();
    [CompilerGeneratedAttribute]
public void set_UserInformationProvider(IUserInformationProvider value);
    [CompilerGeneratedAttribute]
public IDeveloperDeviceInformationProvider get_DeveloperDeviceInformationProvider();
    [CompilerGeneratedAttribute]
public void set_DeveloperDeviceInformationProvider(IDeveloperDeviceInformationProvider value);
    [CompilerGeneratedAttribute]
public IUniqueIdentifierInformationProvider get_UniqueIdentifierInformationProvider();
    [CompilerGeneratedAttribute]
public void set_UniqueIdentifierInformationProvider(IUniqueIdentifierInformationProvider value);
    [CompilerGeneratedAttribute]
public ITelemetryScheduler get_EventProcessorScheduler();
    [CompilerGeneratedAttribute]
public void set_EventProcessorScheduler(ITelemetryScheduler value);
    [CompilerGeneratedAttribute]
public ITelemetryScheduler get_ContextScheduler();
    [CompilerGeneratedAttribute]
public void set_ContextScheduler(ITelemetryScheduler value);
    [CompilerGeneratedAttribute]
public ITelemetryScheduler get_RecurringPropertyUpdateScheduler();
    [CompilerGeneratedAttribute]
public void set_RecurringPropertyUpdateScheduler(ITelemetryScheduler value);
    [CompilerGeneratedAttribute]
public ITelemetryScheduler get_RecurringPropertyScheduler();
    [CompilerGeneratedAttribute]
public void set_RecurringPropertyScheduler(ITelemetryScheduler value);
    [CompilerGeneratedAttribute]
public ITelemetryManifestManagerBuilder get_TelemetryManifestManagerBuilder();
    [CompilerGeneratedAttribute]
public void set_TelemetryManifestManagerBuilder(ITelemetryManifestManagerBuilder value);
    [CompilerGeneratedAttribute]
public IContextPropertyManager get_DefaultContextPropertyManager();
    [CompilerGeneratedAttribute]
public void set_DefaultContextPropertyManager(IContextPropertyManager value);
    [CompilerGeneratedAttribute]
public IPersistentPropertyBag get_PersistentStorage();
    [CompilerGeneratedAttribute]
public void set_PersistentStorage(IPersistentPropertyBag value);
    [CompilerGeneratedAttribute]
public IPersistentPropertyBag get_PersistentSharedProperties();
    [CompilerGeneratedAttribute]
public void set_PersistentSharedProperties(IPersistentPropertyBag value);
    [CompilerGeneratedAttribute]
public IPersistentPropertyBag get_PersistentPropertyBag();
    [CompilerGeneratedAttribute]
public void set_PersistentPropertyBag(IPersistentPropertyBag value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IChannelValidator> get_ChannelValidators();
    [CompilerGeneratedAttribute]
public void set_ChannelValidators(IEnumerable`1<IChannelValidator> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ISessionChannel> get_ChannelsToAdd();
    [CompilerGeneratedAttribute]
public void set_ChannelsToAdd(IEnumerable`1<ISessionChannel> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IEventProcessorAction> get_CustomActionToAdd();
    [CompilerGeneratedAttribute]
public void set_CustomActionToAdd(IEnumerable`1<IEventProcessorAction> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IPropertyProvider> get_PropertyProviders();
    [CompilerGeneratedAttribute]
public void set_PropertyProviders(IEnumerable`1<IPropertyProvider> value);
    [CompilerGeneratedAttribute]
public EventProcessorChannelBuilder get_EventProcessorChannelBuilder();
    [CompilerGeneratedAttribute]
public void set_EventProcessorChannelBuilder(EventProcessorChannelBuilder value);
    [CompilerGeneratedAttribute]
public WatsonSessionChannelBuilder get_WatsonSessionChannelBuilder();
    [CompilerGeneratedAttribute]
public void set_WatsonSessionChannelBuilder(WatsonSessionChannelBuilder value);
    [CompilerGeneratedAttribute]
public IProcessCreationTime get_ProcessCreationTime();
    [CompilerGeneratedAttribute]
public void set_ProcessCreationTime(IProcessCreationTime value);
    public static TelemetrySessionInitializer get_Default();
    public static TelemetrySessionInitializer FromSessionSettings(TelemetrySessionSettings telemetrySessionSettings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetrySessionInitializer/<CreateSessionChannels>d__135")]
public IEnumerable`1<ISessionChannel> CreateSessionChannels(TelemetrySession telemetrySession, bool checkPendingAsimovEvents);
    public void Validate();
    private static TelemetrySessionInitializer BuildInitializer(TelemetrySessionSettings telemetrySessionSettings);
    private static ISQMApi GetSQMApi();
    private static IDeveloperDeviceInformationProvider GetDeveloperDeviceInformationProvider(UniqueIdentifierInformationProviderBase uniqueInformationProvider);
    private static IUniqueIdentifierInformationProvider GetUniqueIdentifierInformationProvider();
    private static IMACInformationProvider GetMACInformationProvider(IProcessTools processTools, IPersistentPropertyBag persistentStorage, ISQMApi sqmApi);
    private static IHostInformationProvider GetHostInformationProvider();
    private static IUserInformationProvider GetUserInformationProvider(IInternalSettings internalSettings, IEnvironmentTools environmentTools, ISQMApi sqmApi, TelemetrySessionSettings telemetrySessionSettings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetrySessionInitializer/<GetPropertyProviders>d__144")]
private static IEnumerable`1<IPropertyProvider> GetPropertyProviders(IEnvironmentTools environmentTools, IHostInformationProvider host, IMachineInformationProvider machine, IMACInformationProvider macAddress, IUserInformationProvider user, IPersistentPropertyBag sharedProperties, ProductTarget productTarget);
    internal static IProcessCreationTime GetProcessCreationTime(ProductTarget productTarget);
    private static IInternalSettings GetInternalSettings(IDiagnosticTelemetry diagnosticTelemetry);
    private static IPersistentPropertyBag CreatePersistentPropertyBag(string processName);
    private static IProcessLockFactory GetProcessLock();
}
internal abstract class Microsoft.VisualStudio.Telemetry.TelemetrySessionInternalBase : TelemetryDisposableObject {
    protected static string UseCollectorRegKeyName;
    protected string useCollectorRegKeyPath;
    public static string ValueNotAvailable;
    public static string DefaultContextName;
    private static int WaitForPendingPostingTimeout;
    private static int DisposingIsStarted;
    private static int DisposingNotStarted;
    private static int RecurringPropertyUpdateDelaySeconds;
    private static int RecurringPropertyDelayMinutes;
    protected TelemetrySessionInitializer sessionInitializer;
    private Concurrent`1<TelemetryContext> sessionContexts;
    private LinkedList`1<TelemetryContext> sessionContextStack;
    private object startedLock;
    private object initializedLock;
    private Concurrent`1<TelemetryPropertyBag> propertyBagDictionary;
    private Concurrent`1<object> recurringProperties;
    protected Concurrent`1<object> commonProperties;
    private IDeveloperDeviceInformationProvider developerDeviceInformationProvider;
    private IMachineInformationProvider machineInformationProvider;
    private IMACInformationProvider macInformationProvider;
    private TelemetryContext defaultContext;
    private IContextPropertyManager defaultContextPropertyManager;
    private EventProcessorChannel eventProcessorChannel;
    private IEnumerable`1<IChannelValidator> channelValidators;
    private Lazy`1<ITelemetryManifestManager> telemetryManifestManager;
    private IPersistentPropertyBag persistentPropertyBag;
    private IPersistentPropertyBag persistentSharedProperties;
    private ITelemetryScheduler contextScheduler;
    private ITelemetryScheduler recurringPropertyUpdateScheduler;
    private ITelemetryScheduler recurringPropertyScheduler;
    private CancellationTokenSource cancellationTokenSource;
    private IDiagnosticTelemetry diagnosticTelemetry;
    private HashSet`1<string> defaultSessionChannelsId;
    private bool isSessionCloned;
    private Lazy`1<string> previousSessionShutdownRegistryPath;
    protected IUserInformationProvider userInformationProvider;
    protected TelemetrySessionSettings sessionSettings;
    [CompilerGeneratedAttribute]
private bool <UseCollector>k__BackingField;
    private ReaderWriterLockSlim customEventPostProtection;
    private TelemetryBufferChannel telemetryBufferChannel;
    private WatsonSessionChannel watsonSessionChannel;
    private Stopwatch disposeLatencyTimer;
    private int numberOfDroppedEventsInDisposing;
    private bool isSessionStarted;
    private bool isInitialized;
    private bool isManifestCompleted;
    private bool isMACAddressCompleted;
    private bool isDevDeviceIdCompleted;
    private int startedDisposing;
    [CompilerGeneratedAttribute]
private ProductTarget <ProductScenario>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CalculatedSamplings>k__BackingField;
    private EventHandler`1<TelemetryTestChannelEventArgs> rawTelemetryEventReceived;
    [CompilerGeneratedAttribute]
private EventProcessor <EventProcessor>k__BackingField;
    private TelemetrySession hostTelemetrySession;
    [CompilerGeneratedAttribute]
private string <GlobalStorageUri>k__BackingField;
    public bool UseCollector { get; public set; }
    public string SessionId { get; }
    public string DevDeviceId { get; }
    public ProductTarget ProductScenario { get; internal set; }
    public VisualStudioCodeTelemetryLevel TelemetryLevel { get; }
    public ProductTarget HostProduct { get; }
    public bool IsOptedIn { get; public set; }
    public List`1<BucketFilter> BucketFiltersToEnableWatsonForFaults { get; public set; }
    public List`1<BucketFilter> BucketFiltersToAddDumpsToFaults { get; public set; }
    public string HostName { get; public set; }
    public CancellationToken CancellationToken { get; }
    public UInt32 AppId { get; public set; }
    public bool CanCollectPrivateInformation { get; }
    public bool IsUserMicrosoftInternal { get; }
    protected bool IsUserMicrosoftInternalInternal { get; }
    public string CalculatedSamplings { get; private set; }
    public Guid MachineId { get; }
    public Guid UserId { get; }
    public string MacAddressHash { get; }
    unknown Action InitializedAction {public set; }
    public EventHandler`1<TelemetryTestChannelEventArgs> RawTelemetryEventReceived { get; public set; }
    private EventProcessor Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.EventProcessor { get; }
    private TelemetryContext Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.DefaultContext { get; }
    private ITelemetryManifestManager Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.ManifestManager { get; }
    private TelemetrySessionSettings Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.SessionSettings { get; }
    private bool Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.IsSessionCloned { get; }
    internal EventProcessor EventProcessor { get; }
    internal TelemetryContext DefaultContext { get; }
    internal bool IsSessionCloned { get; }
    internal ITelemetryManifestManager ManifestManager { get; }
    internal TelemetrySessionSettings SessionSettings { get; }
    public long ProcessStartTime { get; }
    public int ProcessPid { get; }
    public string GlobalStorageUri { get; public set; }
    public long TimeSinceSessionStart { get; }
    internal TelemetrySessionInternalBase(TelemetrySessionSettings settings, bool isCloned, TelemetrySessionInitializer initializerObject, TelemetrySession session);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseCollector();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseCollector(bool value);
    public sealed virtual string get_SessionId();
    public string get_DevDeviceId();
    [CompilerGeneratedAttribute]
public ProductTarget get_ProductScenario();
    [CompilerGeneratedAttribute]
internal void set_ProductScenario(ProductTarget value);
    public sealed virtual VisualStudioCodeTelemetryLevel get_TelemetryLevel();
    public sealed virtual ProductTarget get_HostProduct();
    public sealed virtual bool get_IsOptedIn();
    public sealed virtual void set_IsOptedIn(bool value);
    public sealed virtual List`1<BucketFilter> get_BucketFiltersToEnableWatsonForFaults();
    public sealed virtual void set_BucketFiltersToEnableWatsonForFaults(List`1<BucketFilter> value);
    public sealed virtual List`1<BucketFilter> get_BucketFiltersToAddDumpsToFaults();
    public sealed virtual void set_BucketFiltersToAddDumpsToFaults(List`1<BucketFilter> value);
    public sealed virtual string get_HostName();
    public sealed virtual void set_HostName(string value);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual UInt32 get_AppId();
    public sealed virtual void set_AppId(UInt32 value);
    public sealed virtual bool get_CanCollectPrivateInformation();
    public sealed virtual bool get_IsUserMicrosoftInternal();
    protected virtual bool get_IsUserMicrosoftInternalInternal();
    [CompilerGeneratedAttribute]
public sealed virtual string get_CalculatedSamplings();
    [CompilerGeneratedAttribute]
private void set_CalculatedSamplings(string value);
    public sealed virtual Guid get_MachineId();
    public sealed virtual Guid get_UserId();
    public sealed virtual string get_MacAddressHash();
    public sealed virtual void set_InitializedAction(Action value);
    public sealed virtual EventHandler`1<TelemetryTestChannelEventArgs> get_RawTelemetryEventReceived();
    public sealed virtual void set_RawTelemetryEventReceived(EventHandler`1<TelemetryTestChannelEventArgs> value);
    private sealed virtual override EventProcessor Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.get_EventProcessor();
    private sealed virtual override TelemetryContext Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.get_DefaultContext();
    private sealed virtual override ITelemetryManifestManager Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.get_ManifestManager();
    private sealed virtual override TelemetrySessionSettings Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.get_SessionSettings();
    private sealed virtual override bool Microsoft.VisualStudio.Telemetry.ITelemetrySessionInternal.get_IsSessionCloned();
    [CompilerGeneratedAttribute]
internal EventProcessor get_EventProcessor();
    internal TelemetryContext get_DefaultContext();
    internal bool get_IsSessionCloned();
    internal ITelemetryManifestManager get_ManifestManager();
    internal TelemetrySessionSettings get_SessionSettings();
    public abstract virtual void UseVsIsOptedIn(string productVersion);
    public abstract virtual void UseVsIsOptedIn();
    public sealed virtual TelemetryContext CreateContext(string contextName);
    public sealed virtual TelemetryContext GetContext(string contextName);
    public sealed virtual void PostEvent(string eventName);
    public sealed virtual void PostEvent(TelemetryEvent telemetryEvent);
    public sealed virtual void PostMetricEvent(TelemetryMetricEvent metricEvent);
    public sealed virtual void PostProperty(string propertyName, object propertyValue);
    public sealed virtual void PostRecurringProperty(string propertyName, object propertyValue);
    public sealed virtual void AddSessionChannel(ISessionChannel sessionChannel);
    public sealed virtual string SerializeSettings();
    public sealed virtual void SetSharedProperty(string propertyName, object propertyValue);
    public sealed virtual void RemoveSharedProperty(string propertyName);
    public sealed virtual object GetSharedProperty(string propertyName);
    public sealed virtual object GetSharedPropertyAsObject(string propertyName);
    public sealed virtual void RemovePersistedSharedProperty(string propertyName);
    public sealed virtual object GetPersistedSharedProperty(string propertyName);
    public sealed virtual void RegisterPropertyBag(string name, TelemetryPropertyBag propertyBag);
    public sealed virtual void UnregisterPropertyBag(string name);
    public sealed virtual TelemetryPropertyBag GetPropertyBag(string name);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetrySessionInternalBase/<DisposeToNetworkAsync>d__146")]
public sealed virtual Task DisposeToNetworkAsync(CancellationToken token);
    protected abstract virtual string InitializeReliabilityRegistryPath();
    protected abstract virtual string GetUseCollectorRegKeyPath();
    public sealed virtual void RegisterForReliabilityEvent();
    protected virtual void SetReliabilityValuesInRegistry(string regPath);
    private string GetExeName();
    public sealed virtual long get_ProcessStartTime();
    public sealed virtual int get_ProcessPid();
    public sealed virtual void Start(bool checkPendingAsimovEvents);
    private void SetSharedPropertiesFromSessionSettings();
    public sealed virtual bool Equals(TelemetrySession other);
    public sealed virtual void PostValidatedEvent(TelemetryEvent telemetryEvent);
    private void AddAdditionalProperties(TelemetryEvent channelTelemetryEvent);
    public sealed virtual void AddContext(TelemetryContext telemetryContext);
    public sealed virtual void RemoveContext(TelemetryContext telemetryContext);
    public sealed virtual void AddSessionChannels(IEnumerable`1<ISessionChannel> channels);
    protected virtual void DisposeManagedResources();
    private bool DisposeStart();
    private void DisposeEnd();
    private bool IsValidChannel(ISessionChannel sessionChannel);
    private static void RequiresNotDefaultContextName(string contextName);
    private void PostProcessedEvent(TelemetryEvent telemetryEvent);
    public abstract virtual bool GetCachedUseCollectorFromRegistry();
    public sealed virtual bool SetUseCollectorToRegistry(Nullable`1<bool> value);
    private TelemetryContext CreateDefaultContext();
    private void InitializeWithDefaultChannels(bool checkPendingAsimovEvents);
    private void SetOptedInProperty();
    private void SetInternalInformationProperties(TelemetryManifest telemetryManifest);
    private void SetInternalUserNameIfApplicable(TelemetryManifest telemetryManifest);
    private void SetInternalComputerNameIfApplicable();
    private void SetInternalDomainNameIfApplicable();
    public sealed virtual void AddContextProperties(TelemetryEvent telemetryEvent);
    public sealed virtual void SetPersistedSharedProperty(string propertyName, string propertyValue);
    public sealed virtual void SetPersistedSharedProperty(string propertyName, double propertyValue);
    public sealed virtual void SetPersistedSharedProperty(string propertyName, object propertyValue, Action addToBagAction);
    private void FlushRecurringProperties();
    private void TelemetryManifestUpdateStatus(object sender, TelemetryManifestEventArgs e);
    public sealed virtual void ProcessManifestUseCollectorProperty(TelemetryManifest manifest);
    private void MACAddressHashCalculationCompleted(object sender, EventArgs e);
    private void DeveloperDeviceIdentifierRetrievalCompleted(object sender, EventArgs e);
    private void InitializeSession();
    private void InitializeAndSendIdentifiers();
    private bool ValidateHostName(string hostName);
    private void IndicateNormalShutdown();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetrySessionInternalBase/<StartReliabilityHeartbeatAsync>d__192")]
private Task StartReliabilityHeartbeatAsync();
    public sealed virtual void AddCommonProperties(IDictionary`2<string, object> properties);
    public sealed virtual bool TryAddCommonProperty(string propertyName, object propertyValue);
    public sealed virtual bool TryGetCommonPropertyValue(string propertyName, Object& value);
    private void AddCommonPropertiesToEvent(TelemetryEvent channelTelemetryEvent);
    public sealed virtual IDictionary`2<string, object> GetCommonPropertyDictionary();
    [CompilerGeneratedAttribute]
public sealed virtual string get_GlobalStorageUri();
    [CompilerGeneratedAttribute]
public sealed virtual void set_GlobalStorageUri(string value);
    public abstract virtual long get_TimeSinceSessionStart();
    public virtual string ToString();
    public sealed virtual TelemetrySession GetHostTelemetrySession();
    public sealed virtual void LoadCommonProperties();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetrySessionInternalVS : TelemetrySessionInternalBase {
    private IVsOptInStatusInformationProvider optinStatusReader;
    public long TimeSinceSessionStart { get; }
    internal TelemetrySessionInternalVS(TelemetrySessionSettings settings, bool isCloned, TelemetrySessionInitializer initializerObject, TelemetrySession session);
    public virtual long get_TimeSinceSessionStart();
    protected virtual string InitializeReliabilityRegistryPath();
    protected virtual string GetUseCollectorRegKeyPath();
    public virtual bool GetCachedUseCollectorFromRegistry();
    public virtual void UseVsIsOptedIn();
    public virtual void UseVsIsOptedIn(string productVersion);
}
internal class Microsoft.VisualStudio.Telemetry.TelemetrySessionInternalVSCode : TelemetrySessionInternalBase {
    internal static string CsDevKitInternalPropertyName;
    public long TimeSinceSessionStart { get; }
    protected bool IsUserMicrosoftInternalInternal { get; }
    internal TelemetrySessionInternalVSCode(TelemetrySessionSettings settings, bool isCloned, TelemetrySessionInitializer initializerObject, TelemetrySession session);
    public virtual long get_TimeSinceSessionStart();
    protected virtual string InitializeReliabilityRegistryPath();
    protected virtual string GetUseCollectorRegKeyPath();
    protected virtual bool get_IsUserMicrosoftInternalInternal();
    protected virtual void SetReliabilityValuesInRegistry(string regPath);
    public virtual bool GetCachedUseCollectorFromRegistry();
    private static void WerRegisterCustomMetaData(string property, string value);
    public virtual void UseVsIsOptedIn();
    public virtual void UseVsIsOptedIn(string productVersion);
}
[DataContractAttribute]
internal class Microsoft.VisualStudio.Telemetry.TelemetrySessionSettings : object {
    private static string DefaultHostName;
    private static UInt32 DefaultAppId;
    [CompilerGeneratedAttribute]
private string <TelemetryLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptedIn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitialSession>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppInsightsInstrumentationKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AsimovInstrumentationKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectorApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <AppId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ProcessStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VSExeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SkuName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BucketFilter> <BucketFiltersToEnableWatsonForFaults>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BucketFilter> <BucketFiltersToAddDumpsToFaults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanOverrideHostName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanOverrideAppId>k__BackingField;
    [DataMemberAttribute]
public string TelemetryLevel { get; public set; }
    [DataMemberAttribute]
public bool IsOptedIn { get; public set; }
    [DataMemberAttribute]
public bool IsInitialSession { get; public set; }
    [DataMemberAttribute]
public string HostName { get; public set; }
    [DataMemberAttribute]
public string AppInsightsInstrumentationKey { get; public set; }
    [DataMemberAttribute]
public string AsimovInstrumentationKey { get; public set; }
    [DataMemberAttribute]
public string CollectorApiKey { get; public set; }
    [DataMemberAttribute]
public UInt32 AppId { get; public set; }
    [DataMemberAttribute]
public Nullable`1<Guid> UserId { get; public set; }
    [DataMemberAttribute]
public string Id { get; public set; }
    [DataMemberAttribute]
public long ProcessStartTime { get; public set; }
    [DataMemberAttribute]
public string VSExeVersion { get; public set; }
    [DataMemberAttribute]
public string SkuName { get; public set; }
    [DataMemberAttribute]
public List`1<BucketFilter> BucketFiltersToEnableWatsonForFaults { get; public set; }
    [DataMemberAttribute]
public List`1<BucketFilter> BucketFiltersToAddDumpsToFaults { get; public set; }
    [IgnoreDataMemberAttribute]
public bool CanOverrideHostName { get; private set; }
    [IgnoreDataMemberAttribute]
public bool CanOverrideAppId { get; private set; }
    public TelemetrySessionSettings(string id, IInternalSettings internalSettings, string appInsightsIKey, string asimovIKey, string collectorApiKey, IProcessCreationTime processCreation);
    [CompilerGeneratedAttribute]
public string get_TelemetryLevel();
    [CompilerGeneratedAttribute]
public void set_TelemetryLevel(string value);
    [CompilerGeneratedAttribute]
public bool get_IsOptedIn();
    [CompilerGeneratedAttribute]
public void set_IsOptedIn(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInitialSession();
    [CompilerGeneratedAttribute]
public void set_IsInitialSession(bool value);
    [CompilerGeneratedAttribute]
public string get_HostName();
    [CompilerGeneratedAttribute]
public void set_HostName(string value);
    [CompilerGeneratedAttribute]
public string get_AppInsightsInstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_AppInsightsInstrumentationKey(string value);
    [CompilerGeneratedAttribute]
public string get_AsimovInstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_AsimovInstrumentationKey(string value);
    [CompilerGeneratedAttribute]
public string get_CollectorApiKey();
    [CompilerGeneratedAttribute]
public void set_CollectorApiKey(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_AppId();
    [CompilerGeneratedAttribute]
public void set_AppId(UInt32 value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public long get_ProcessStartTime();
    [CompilerGeneratedAttribute]
public void set_ProcessStartTime(long value);
    [CompilerGeneratedAttribute]
public string get_VSExeVersion();
    [CompilerGeneratedAttribute]
public void set_VSExeVersion(string value);
    [CompilerGeneratedAttribute]
public string get_SkuName();
    [CompilerGeneratedAttribute]
public void set_SkuName(string value);
    [CompilerGeneratedAttribute]
public List`1<BucketFilter> get_BucketFiltersToEnableWatsonForFaults();
    [CompilerGeneratedAttribute]
public void set_BucketFiltersToEnableWatsonForFaults(List`1<BucketFilter> value);
    [CompilerGeneratedAttribute]
public List`1<BucketFilter> get_BucketFiltersToAddDumpsToFaults();
    [CompilerGeneratedAttribute]
public void set_BucketFiltersToAddDumpsToFaults(List`1<BucketFilter> value);
    [CompilerGeneratedAttribute]
public bool get_CanOverrideHostName();
    [CompilerGeneratedAttribute]
private void set_CanOverrideHostName(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanOverrideAppId();
    [CompilerGeneratedAttribute]
private void set_CanOverrideAppId(bool value);
    internal static bool IsSessionIdValid(string sessionID);
    internal static TelemetrySessionSettings Parse(string serializedSession);
    public virtual bool Equals(object other);
    public virtual string ToString();
    internal static string GetFaultEventBucketFilterJson(List`1<BucketFilter> bucketFilters);
    internal static ProductTarget GetProduct(TelemetrySessionSettings settings);
    public virtual int GetHashCode();
    private static string StringToJsonValue(string value);
    private static TelemetrySessionSettings Deserialize(string settings);
    private static bool IsSerializedSessionValid(string serializedSession);
}
public class Microsoft.VisualStudio.Telemetry.TelemetrySettingProperty : TelemetryDataModelProperty {
    public TelemetrySettingProperty(object val);
}
public enum Microsoft.VisualStudio.Telemetry.TelemetrySeverity : Enum {
    public int value__;
    public static TelemetrySeverity High;
    public static TelemetrySeverity Normal;
    public static TelemetrySeverity Low;
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryTaskTimer : TelemetryDisposableObject {
    public static TimeSpan InfiniteTimeSpan;
    private TimeSpan delay;
    private CancellationTokenSource tokenSource;
    private Task delayTask;
    private Task currentTask;
    public TimeSpan Delay { get; public set; }
    public bool IsStarted { get; }
    public TelemetryTaskTimer(TimeSpan taskDelay);
    private static TelemetryTaskTimer();
    public TimeSpan get_Delay();
    public void set_Delay(TimeSpan value);
    public bool get_IsStarted();
    public void Start(Action elapsed, bool infinite);
    public void Start(Func`1<Task> elapsed, bool infinite);
    public void Cancel();
    public void WaitThenCancel();
    protected virtual void DisposeManagedResources();
    private static void CancelAndDispose(CancellationTokenSource tokenSource);
}
public class Microsoft.VisualStudio.Telemetry.TelemetryTestChannelEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private TelemetryEvent <Event>k__BackingField;
    public TelemetryEvent Event { get; public set; }
    [CompilerGeneratedAttribute]
public TelemetryEvent get_Event();
    [CompilerGeneratedAttribute]
public void set_Event(TelemetryEvent value);
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.Telemetry.TelemetryTextWriter : object {
    private TextWriter writer;
    public TelemetryTextWriter(string filePath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.TelemetryTextWriter/<WriteLineAsync>d__2")]
public sealed virtual Task WriteLineAsync(string text);
    public sealed virtual void Dispose();
}
internal enum Microsoft.VisualStudio.Telemetry.ThrottlingAction : Enum {
    public int value__;
    public static ThrottlingAction Default;
    public static ThrottlingAction Throttle;
    public static ThrottlingAction DoNotThrottle;
}
internal static class Microsoft.VisualStudio.Telemetry.TypeTools : object {
    public static bool IsNumericType(Type t);
    public static bool TryConvertToUInt(object o, UInt32& result);
    public static bool TryConvertToInt(object o, Int32& result);
    public static string ConvertToString(object o);
    private static bool GuardConvert(Func`2<object, T> convertFunc, object from, T& res);
}
internal abstract class Microsoft.VisualStudio.Telemetry.UserInformationProviderBase : object {
    private static string FullUserDomainEnvironmentKey;
    protected static string MicrosoftTenantId;
    private Lazy`1<bool> canCollectPrivateInformation;
    private Lazy`1<bool> isUserMicrosoftInternal;
    private Lazy`1<bool> isMicrosoftAADJoined;
    private Lazy`1<Guid> userId;
    private IEnvironmentTools environmentTools;
    private IInternalSettings internalSettings;
    private ISQMApi sqmApi;
    private static HashSet`1<string> CanCollectPrivateInformationDomainList;
    private static HashSet`1<string> MicrosoftInternalDomainList;
    public bool CanCollectPrivateInformation { get; }
    public bool IsUserMicrosoftInternal { get; }
    public bool IsMicrosoftAADJoined { get; }
    public Guid UserId { get; }
    public UserType UserType { get; }
    public UserInformationProviderBase(IInternalSettings internalSettings, IEnvironmentTools envTools, ISQMApi sqmApi, Nullable`1<Guid> userId);
    private static UserInformationProviderBase();
    public sealed virtual bool get_CanCollectPrivateInformation();
    public sealed virtual bool get_IsUserMicrosoftInternal();
    public sealed virtual bool get_IsMicrosoftAADJoined();
    public sealed virtual Guid get_UserId();
    public abstract virtual UserType get_UserType();
    protected abstract virtual bool CalculateIsMicrosoftAADJoined();
    private bool CalculateIsInternal();
    private bool CalculateCanCollectPrivateInformation();
    private bool ValidateDomainInformation(HashSet`1<string> domainList);
}
internal abstract class Microsoft.VisualStudio.Telemetry.UserPropertyProviderBase : object {
    protected static string AdminValue;
    protected static string NormalUserValue;
    private Lazy`1<bool> getIsDomainMember;
    private Lazy`1<bool> getIsUserAdmin;
    [CompilerGeneratedAttribute]
private IUserInformationProvider <UserInformationProvider>k__BackingField;
    protected IUserInformationProvider UserInformationProvider { get; }
    public UserPropertyProviderBase(IUserInformationProvider userInformationProvider);
    [CompilerGeneratedAttribute]
protected IUserInformationProvider get_UserInformationProvider();
    protected abstract virtual bool InitializeUserIsAdminInformation();
    protected virtual bool InitializeIsDomainMember();
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
}
public class Microsoft.VisualStudio.Telemetry.UserTaskEvent : OperationEvent {
    public UserTaskEvent(string eventName, TelemetryResult result, string resultSummary);
    internal UserTaskEvent(string eventName, OperationStageType stageType, TelemetryResult result, string resultSummary);
}
public class Microsoft.VisualStudio.Telemetry.VsCodeExt.VisualStudioCodeTelemetryLevel : object {
    internal TelemetryLevel ConfiguredLevel;
    internal VisualStudioCodeTelemetryLevel(string telemetryLevelRaw);
    public static bool IsTelemetryDataPermitted(string configuredTelemetryLevel, string eventTelemetryLevel);
    internal bool IsTelemetryDataPermitted(TelemetryLevel minimumRequiredTelemetryLevel);
    private static TelemetryLevel MapRawValueToLevel(string telemetryLevelRaw);
}
internal class Microsoft.VisualStudio.Telemetry.WatsonSessionChannelBuilder : object {
    private int faultEventSamplePercent;
    private int faultEventMaximumWatsonReportsPerSession;
    private int faultEventMinimumSecondsBetweenWatsonReports;
    private ChannelProperties properties;
    [CompilerGeneratedAttribute]
private WatsonSessionChannel <WatsonSessionChannel>k__BackingField;
    public WatsonSessionChannel WatsonSessionChannel { get; private set; }
    public WatsonSessionChannelBuilder(int faultEventSamplePercent, int faultEventMaximumWatsonReportsPerSession, int faultEventMinimumSecondsBetweenWatsonReports, ChannelProperties properties);
    [CompilerGeneratedAttribute]
public WatsonSessionChannel get_WatsonSessionChannel();
    [CompilerGeneratedAttribute]
private void set_WatsonSessionChannel(WatsonSessionChannel value);
    public void Build(TelemetrySession hostSession);
}
public enum Microsoft.VisualStudio.Telemetry.WER_DUMP_TYPE : Enum {
    public int value__;
    public static WER_DUMP_TYPE WerDumpTypeMicroDump;
    public static WER_DUMP_TYPE WerDumpTypeMiniDump;
    public static WER_DUMP_TYPE WerDumpTypeHeapDump;
    public static WER_DUMP_TYPE WerDumpTypeTriageDump;
    public static WER_DUMP_TYPE WerDumpTypeMax;
}
[DataContractAttribute]
public class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.BucketFilter : object {
    private static String[] bucketParameterNames;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WatsonEventType>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BucketParameterFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AdditionalProperties>k__BackingField;
    [DataMemberAttribute]
public Guid Id { get; public set; }
    [DataMemberAttribute]
public string WatsonEventType { get; public set; }
    [DataMemberAttribute]
public String[] BucketParameterFilters { get; public set; }
    [DataMemberAttribute]
public Dictionary`2<string, string> AdditionalProperties { get; public set; }
    public BucketFilter(Guid id, string watsonEventType);
    private static BucketFilter();
    public static int IndexOfBucketParameter(string bucketParameterName);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public string get_WatsonEventType();
    [CompilerGeneratedAttribute]
public void set_WatsonEventType(string value);
    [CompilerGeneratedAttribute]
public String[] get_BucketParameterFilters();
    [CompilerGeneratedAttribute]
public void set_BucketParameterFilters(String[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(Dictionary`2<string, string> value);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.DefaultWerReportImplementation : object {
    public sealed virtual WerReportCloseHandleSafeHandle WerReportCreateEx(string pwzEventType, WER_REPORT_TYPE repType, Nullable`1<WER_REPORT_INFORMATION> pReportInformation);
    public sealed virtual int WerReportSetParameter(WerReportCloseHandleSafeHandle hReportHandle, UInt32 dwparamID, string pwzName, string pwzValue);
    public sealed virtual int WerReportAddDump(WerReportCloseHandleSafeHandle hReportHandle, IntPtr hProcess, IntPtr hThread, WER_DUMP_TYPE dumpType, IntPtr pExceptionParam, IntPtr pDumpCustomOptions, int dwFlags);
    public sealed virtual int WerReportSubmitEx(WerReportCloseHandleSafeHandle hReportHandle, WER_CONSENT consent, WER_SUBMIT_FLAGS dwFlags);
    public sealed virtual int WerReportAddFile(WerReportCloseHandleSafeHandle hReportHandle, string pwxPath, WER_FILE_TYPE repFileType, WER_FILE dwFileFlags);
}
internal interface Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.IWerReport {
    public abstract virtual WerReportCloseHandleSafeHandle WerReportCreateEx(string pwzEventType, WER_REPORT_TYPE repType, Nullable`1<WER_REPORT_INFORMATION> pReportInformation);
    public abstract virtual int WerReportSetParameter(WerReportCloseHandleSafeHandle hReportHandle, UInt32 dwparamID, string pwzName, string pwzValue);
    public abstract virtual int WerReportAddDump(WerReportCloseHandleSafeHandle hReportHandle, IntPtr hProcess, IntPtr hThread, WER_DUMP_TYPE dumpType, IntPtr pExceptionParam, IntPtr pDumpCustomOptions, int dwFlags);
    public abstract virtual int WerReportAddFile(WerReportCloseHandleSafeHandle hReportHandle, string pwxPath, WER_FILE_TYPE repFileType, WER_FILE dwFileFlags);
    public abstract virtual int WerReportSubmitEx(WerReportCloseHandleSafeHandle hReportHandle, WER_CONSENT consent, WER_SUBMIT_FLAGS dwFlags);
}
internal static class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.NativeMethods : object {
    public static int WerReportAddDump(WerReportCloseHandleSafeHandle hReportHandle, IntPtr hProcess, IntPtr hThread, WER_DUMP_TYPE dumpType, IntPtr pExceptionParam, IntPtr pDumpCustomOptions, int dwFlags);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.NoPumpSyncContext : SynchronizationContext {
    private static SynchronizationContext DefaultInstance;
    public static SynchronizationContext Default { get; }
    private static NoPumpSyncContext();
    public static SynchronizationContext get_Default();
    public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.SafeWerDumpCustomOptionsHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private WER_DUMP_CUSTOM_OPTIONS_V3 options;
    public SafeWerDumpCustomOptionsHandle(WER_DUMP_CUSTOM_OPTIONS_V3& options);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport : object {
    public static int DefaultWatsonSamplePercent;
    public static int DefaultMaximumWatsonReportsPerSession;
    public static int DefaultMinimumSecondsBetweenWatsonReports;
    [CompilerGeneratedAttribute]
private FaultEvent <FaultEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetrySession <TelemetrySession>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <SBuilderErrorInfo>k__BackingField;
    internal static string UnknownBucketValue;
    internal static int NumberOfBucketParameters;
    internal static string ExceptionDataModelPrefix;
    private static String[] bucketNames;
    public static int P0AppNameIndex;
    public static int P1AppVersionIndex;
    public static int P2TelemetryNameIndex;
    public static int P3failureParam0Index;
    public static int P3ExceptionTypeDefaultIndex;
    public static int P4failureParam1Index;
    public static int P4ModuleNameDefaultIndex;
    public static int P5failureParam2Index;
    public static int P5MethodNameDefaultIndex;
    public static int P6failureParam3Index;
    public static int P7failureParam4Index;
    public static int P8nonFailureParam0Index;
    public static int P9nonFailureParam1Index;
    private FaultEvent FaultEvent { get; }
    private TelemetrySession TelemetrySession { get; }
    internal StringBuilder SBuilderErrorInfo { get; }
    public WatsonReport(FaultEvent faultEvent, TelemetrySession telemetrySession);
    private static WatsonReport();
    [CompilerGeneratedAttribute]
private FaultEvent get_FaultEvent();
    [CompilerGeneratedAttribute]
private TelemetrySession get_TelemetrySession();
    [CompilerGeneratedAttribute]
internal StringBuilder get_SBuilderErrorInfo();
    public void PostWatsonReport(int maxReportsPerSession, int minSecondsBetweenReports);
    private void FillReportUploadInfo(WER_SUBMIT_RESULT submitResult, DateTime startTime, DateTime endTime);
    private void LogTelemetryAboutExtraDataAddedToFaultEvent();
    internal static void LogExceptionToTelemetry(Exception ex);
    private bool GetReportInfo(bool queue, DateTime startTime, DateTime endTime);
    private static bool ShouldSendSubmitArchiveParamsOnly(bool fullCab, bool sendParams);
    private WER_SUBMIT_RESULT SendWatsonReport(bool fullCab, bool sendParams, DateTime& startTime, DateTime& endTime);
    private void BeginSendWatsonReport(bool fullCab, bool sendParams);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport/<SubmitReportAsync>d__38")]
private Task SubmitReportAsync(WerReportBuilder reportBuilder, Guid correlationId, bool fullCab, bool sendParams);
    private void AddFilesToReport(WerReportBuilder reportBuilder);
    private WER_SUBMIT_RESULT SubmitReport(WerReportBuilder reportBuilder, WER_SUBMIT_FLAGS watsonFlags, DateTime& startTime, DateTime& endTime);
    private void SetWerSubmitResultProperty(string value);
    private void SetReportParameters(WerReportBuilder reportBuilder);
    private void AddDumpsToReport(WerReportBuilder reportBuilder, bool useSnapshot);
    private void AddErrorInfoFile(WerReportBuilder reportBuilder);
    private void SetDumpTypeFaultEventProperties();
    private void AddBucketParametersToEventProperties();
    internal BucketFilter GetMatchingBucketFilter(List`1<BucketFilter> bucketFilters, string bucketFilterTelemetryPropertyNamePrefix);
    private void SendSupplementalInfoEvent(Guid correlationId);
    private static bool IsAsyncDumpCollectionEnabled();
    private static int GetFaultEventDumpModeRemoteSettingValue();
    private void TrySetBucketParameter(int bucketNum, string value);
    private bool GetBlameFromFrame(StackFrame frame, String& methodName, String& fileName, String& offset);
    private void SetInitialBucketParameters();
    internal static IEnumerable`1<StackFrame> RemoveFrames(StackFrame[] frames);
    internal static string FormatException(Exception ex);
    internal static string FormatExceptionStack(Exception ex, bool shorten);
    internal static string FormatStackTrace(IEnumerable`1<StackFrame> stackFrames, int maxLength, bool shorten);
    internal static string FormatMethodName(MethodBase method, bool shortened);
    private void SetBucketParametersForModule(string filename, string methodName, string offset);
    internal void AddExceptionInfoToIncludedFile(Exception exceptionObject);
    private void AddStackToFile(string desc, string stack, int indentLevel);
    private void AddPropertiesForExceptionObject(Exception exceptionObject);
    private void AddStackToTelemetryReport(string stackTrace, string message, bool exceptionStack);
    private Exception GetInnerMostException(Exception exceptionObject, Func`2<Exception, bool> exceptionChainRestraint);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WerReportBuilder : object {
    private WerReportCloseHandleSafeHandle reportHandle;
    private List`1<SafeHandle> safeHandlesToCleanup;
    private List`1<HPSS> snapshotsToCleanup;
    private WerReportBuilder(string watsonEventType, WER_REPORT_TYPE reportType);
    internal static WerReportBuilder Create(string watsonEventType, WER_REPORT_TYPE reportType);
    internal bool AddDump(Process proc, WER_DUMP_TYPE dumpType);
    internal bool AddFile(string filePath, WER_FILE fileFlags);
    internal bool SetParameter(UInt32 paramId, string paramName, string paramValue);
    internal bool AddDumpFromSnapshot(Process proc, WER_DUMP_TYPE dumpType);
    internal WER_SUBMIT_RESULT SubmitReport(WER_CONSENT werConsent, WER_SUBMIT_FLAGS dwFlags);
    public sealed virtual void Dispose();
    private static HPSS GetProcessSnapshot(IntPtr processHandle, bool fIncludeFullHeap);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WerReportShim : object {
    private static IWerReport implementation;
    private static WerReportShim();
    internal static void SetImplementation(IWerReport implementation);
    public static WerReportCloseHandleSafeHandle WerReportCreate(string pwzEventType, WER_REPORT_TYPE repType, Nullable`1<WER_REPORT_INFORMATION> pReportInformation);
    public static int WerReportSetParameter(WerReportCloseHandleSafeHandle hReportHandle, UInt32 dwparamID, string pwzName, string pwzValue);
    public static int WerReportAddDump(WerReportCloseHandleSafeHandle hReportHandle, IntPtr hProcess, IntPtr hThread, WER_DUMP_TYPE dumpType, IntPtr pExceptionParam, IntPtr pDumpCustomOptions, int flags);
    public static int WerReportAddFile(WerReportCloseHandleSafeHandle hReportHandle, string pwxPath, WER_FILE_TYPE repFileType, WER_FILE fileFlags);
    public static int WerReportSubmit(WerReportCloseHandleSafeHandle hReportHandle, WER_CONSENT consent, WER_SUBMIT_FLAGS dwFlags);
}
public class Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WerStoreApi : object {
    private static Nullable`1<bool> doesInterfaceExist;
    private static string WerDllName;
    public static bool IsStoreInterfacePresent { get; }
    private static UInt32 GetSystemDirectory(StringBuilder lpBuffer, UInt32 uSize);
    private static IntPtr LoadLibrary(string fileName);
    private static IntPtr FreeLibrary(IntPtr hLib);
    private static IntPtr GetProcAddress(IntPtr hModule, string lpProcName);
    private static int WerStoreOpen(REPORT_STORE_TYPES storeType, IntPtr& hResportStore);
    private static void WerStoreClose(IntPtr hResportStore);
    private static UInt32 WerStoreGetNextReportKey(IntPtr hResportStore, IntPtr& reportKeyPtr);
    private static UInt32 WerStoreQueryReportMetadataV2(IntPtr hResportStore, string reportKey, ReportMetaData& report);
    public static bool get_IsStoreInterfacePresent();
    public static IWerStore GetStore(REPORT_STORE_TYPES type);
    private static Guid ToManagedGuid(GUID nativeGuid);
    private static DateTime FiletimeToDateTime(FILETIME fileTime);
}
internal class Microsoft.VisualStudio.Telemetry.WindowsHostInformationProvider : object {
    private Lazy`1<string> name;
    private Lazy`1<UInt32> id;
    private Lazy`1<FileVersionInfo> hostVersionInfo;
    private Lazy`1<Nullable`1<int>> buildNumber;
    private Lazy`1<string> exeVersion;
    private static string UnknownName;
    public string ProcessName { get; }
    public UInt32 ProcessId { get; }
    public Nullable`1<int> ProcessBuildNumber { get; }
    public string ProcessExeVersion { get; }
    public bool IsDebuggerAttached { get; }
    public bool Is64BitProcess { get; }
    public string OSBitness { get; }
    public sealed virtual string get_ProcessName();
    public sealed virtual UInt32 get_ProcessId();
    public sealed virtual Nullable`1<int> get_ProcessBuildNumber();
    public sealed virtual string get_ProcessExeVersion();
    public sealed virtual bool get_IsDebuggerAttached();
    public sealed virtual bool get_Is64BitProcess();
    public sealed virtual string get_OSBitness();
    private static string InitializeName();
    private static UInt32 InitializeId();
    private static FileVersionInfo InitializeHostVersionInfo();
    private Nullable`1<int> InitializeBuildNumber();
    private string InitializeExeVersion();
    [CompilerGeneratedAttribute]
private Nullable`1<int> <.ctor>b__20_0();
    [CompilerGeneratedAttribute]
private string <.ctor>b__20_1();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsHostPropertyProvider : BaseHostRealtimePropertyProvider {
    private IHostInformationProvider hostInfoProvider;
    private Lazy`1<bool> isRDPSession;
    private static string TerminalServerRegistryPath;
    private static string GlassSessionIdRegistryKey;
    public WindowsHostPropertyProvider(IHostInformationProvider theHostInfoProvider);
    public virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private bool InitializeIsRDPSession();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__4_0();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsInternalSettings : InternalSettingsBase {
    private static string FaultEventWatsonSampleRateRegKeyName;
    private static string FaultEventMaximumWatsonReportsPerSessionRegKeyName;
    private static string FaultEventMinimumSecondsBetweenWatsonReportsRegKeyName;
    private static string EventTagTelemetryRegKeyName;
    public WindowsInternalSettings(IDiagnosticTelemetry diagnosticTelemetry);
    public virtual int FaultEventWatsonSamplePercent();
    public virtual int FaultEventMaximumWatsonReportsPerSession();
    public virtual int FaultEventMinimumSecondsBetweenWatsonReports();
    public string GetUserEventTag();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsLocalePropertyProvider : object {
    private static string SystemLocaleRegistryPath;
    private static string SystemLocaleRegistryKey;
    private Lazy`1<CultureInfo> systemInfo;
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private CultureInfo InitializeSystemInformation();
    [CompilerGeneratedAttribute]
private CultureInfo <.ctor>b__3_0();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsMachinePropertyProvider : object {
    internal static string ProcessArchPropertyName;
    private static ulong MbInBytes;
    private static string AzureVMImageNameKey;
    private static string HardwareDescriptionRegistryPath;
    private static string HardwareProcessNameRegistryKey;
    private static string HardwareCPUSpeedRegistryKey;
    private static string NoneValue;
    private static string TelemetryLocalMachineRegistryPath;
    private static string UnknownValue;
    private static string IsVirtualMachinePropertyName;
    private static string VirtualMachineTypePropertyName;
    private static UInt32 VMType_Unknown;
    private static string SystemInformationRegistryPath;
    private static string SkuNameRegistryKey;
    private static string Win365PartnerIdPropertyName;
    private static string Win365SkuNamePropertyName;
    private Lazy`1<MEMORYSTATUSEX> memoryInformation;
    private Lazy`1<SYSTEM_INFO> systemInformation;
    private Lazy`1<string> processorDescription;
    private Lazy`1<Nullable`1<int>> processorFrequency;
    private Lazy`1<string> azureVMImageName;
    private Lazy`1<bool> isVirtualMachine;
    private Lazy`1<string> virtualMachineType;
    private Lazy`1<UInt32> virtualMachineTypeValue;
    private Lazy`1<string> win365SkuName;
    private IMachineInformationProvider machineInformationProvider;
    private IMACInformationProvider macInformationProvider;
    private IPersistentPropertyBag persistentPropertyBag;
    private WindowsBiosUuidInformationProvider windowsBiosUuidInformationProvider;
    [CompilerGeneratedAttribute]
private string <ProcessArchitecture>k__BackingField;
    private string ProcessArchitecture { get; }
    public WindowsMachinePropertyProvider(IMachineInformationProvider machineInformationProvider, IMACInformationProvider macInformationProvider, IPersistentPropertyBag persistentPropertyBag);
    private static WindowsMachinePropertyProvider();
    [CompilerGeneratedAttribute]
private string get_ProcessArchitecture();
    public sealed virtual void AddSharedProperties(List`1<KeyValuePair`2<string, object>> sharedProperties, TelemetryContext telemetryContext);
    public sealed virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    private void PostVirtualMachineTypeTelemetry(TelemetryContext telemetryContext);
    private MEMORYSTATUSEX InitializeOSMemoryInformation();
    private SYSTEM_INFO InitializeSystemInformation();
    private string InitializeProcessorDescription();
    private string InitializeAzureVMImageName();
    internal bool IsVirtualMachine();
    private string InitializeVirtualMachineType();
    private string InitializeWin365SkuName();
    private UInt32 InitializeVirtualMachineTypeValue();
    private UInt32 GetVirtualMachineTypeValue();
    private static string GetValue(ManagementBaseObject collection, string value);
    [CompilerGeneratedAttribute]
private MEMORYSTATUSEX <.ctor>b__32_0();
    [CompilerGeneratedAttribute]
private SYSTEM_INFO <.ctor>b__32_1();
    [CompilerGeneratedAttribute]
private string <.ctor>b__32_2();
    [CompilerGeneratedAttribute]
private string <.ctor>b__32_4();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__32_5();
    [CompilerGeneratedAttribute]
private string <.ctor>b__32_6();
    [CompilerGeneratedAttribute]
private UInt32 <.ctor>b__32_7();
    [CompilerGeneratedAttribute]
private string <.ctor>b__32_8();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsProcessCreationTime : object {
    public sealed virtual long GetProcessCreationTime();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsUserInformationProvider : UserInformationProviderBase {
    private static string SqmUserTypeRegistryKey;
    private Lazy`1<UserType> userType;
    internal Lazy`1<string> AADTenantId;
    public UserType UserType { get; }
    public WindowsUserInformationProvider(IInternalSettings internalSettings, IEnvironmentTools envTools, ISQMApi sqmApi, Nullable`1<Guid> userId);
    public virtual UserType get_UserType();
    protected virtual bool CalculateIsMicrosoftAADJoined();
    private UserType CalculateUserType();
    private string GetAADTenantId();
    [CompilerGeneratedAttribute]
private UserType <.ctor>b__3_0();
    [CompilerGeneratedAttribute]
private string <.ctor>b__3_1();
}
internal class Microsoft.VisualStudio.Telemetry.WindowsUserPropertyProvider : UserPropertyProviderBase {
    private Lazy`1<bool> processAdminInformation;
    public WindowsUserPropertyProvider(IUserInformationProvider userInformationProvider);
    public virtual void PostProperties(TelemetryContext telemetryContext, CancellationToken token);
    protected virtual bool InitializeIsDomainMember();
    private bool InitializeProcessAdminInformation();
    protected virtual bool InitializeUserIsAdminInformation();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__1_0();
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[ExtensionAttribute]
internal static class System.TimeSpanEx : object {
    public static TimeSpan Parse(string value, CultureInfo info);
    public static bool TryParse(string value, CultureInfo info, TimeSpan& output);
    [ExtensionAttribute]
public static string ToString(TimeSpan timeSpan, CultureInfo info, string format);
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.133.12845")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
[IsReadOnlyAttribute]
internal class Windows.Win32.Foundation.BOOL : ValueType {
    private int value;
    internal int Value { get; }
    internal BOOL(bool value);
    internal BOOL(int value);
    internal int get_Value();
    public static bool op_Implicit(BOOL value);
    public static BOOL op_Implicit(bool value);
    public static BOOL op_Explicit(int value);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.BOOLEAN : ValueType {
    internal byte Value;
    internal BOOLEAN(byte value);
    public static byte op_Implicit(BOOLEAN value);
    public static BOOLEAN op_Explicit(byte value);
    public static bool op_Equality(BOOLEAN left, BOOLEAN right);
    public static bool op_Inequality(BOOLEAN left, BOOLEAN right);
    public sealed virtual bool Equals(BOOLEAN other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.HANDLE : ValueType {
    internal IntPtr Value;
    internal bool IsNull { get; }
    internal HANDLE(IntPtr value);
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HANDLE value);
    public static HANDLE op_Explicit(IntPtr value);
    public static bool op_Equality(HANDLE left, HANDLE right);
    public static bool op_Inequality(HANDLE left, HANDLE right);
    public sealed virtual bool Equals(HANDLE other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.HINSTANCE : ValueType {
    internal IntPtr Value;
    internal bool IsNull { get; }
    internal HINSTANCE(IntPtr value);
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HINSTANCE value);
    public static HINSTANCE op_Explicit(IntPtr value);
    public static bool op_Equality(HINSTANCE left, HINSTANCE right);
    public static bool op_Inequality(HINSTANCE left, HINSTANCE right);
    public sealed virtual bool Equals(HINSTANCE other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.HRESULT : ValueType {
    internal int Value;
    [DebuggerBrowsableAttribute("0")]
internal bool Succeeded { get; }
    [DebuggerBrowsableAttribute("0")]
internal bool Failed { get; }
    internal HRESULT(int value);
    public static int op_Implicit(HRESULT value);
    public static HRESULT op_Explicit(int value);
    public static bool op_Equality(HRESULT left, HRESULT right);
    public static bool op_Inequality(HRESULT left, HRESULT right);
    public sealed virtual bool Equals(HRESULT other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static UInt32 op_Implicit(HRESULT value);
    public static HRESULT op_Explicit(UInt32 value);
    internal bool get_Succeeded();
    internal bool get_Failed();
    internal HRESULT ThrowOnFailure(IntPtr errorInfo);
    public virtual string ToString();
    internal string ToString(string format, IFormatProvider formatProvider);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.HWND : ValueType {
    [NativeIntegerAttribute]
internal IntPtr Value;
    internal HWND(IntPtr value);
    public static IntPtr op_Implicit(HWND value);
    public static HWND op_Explicit(IntPtr value);
    public static bool op_Equality(HWND left, HWND right);
    public static bool op_Inequality(HWND left, HWND right);
    public sealed virtual bool Equals(HWND other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class Windows.Win32.Foundation.PCWSTR : ValueType {
    internal Char* Value;
    internal int Length { get; }
    private string DebuggerDisplay { get; }
    internal PCWSTR(Char* value);
    public static Char* op_Explicit(PCWSTR value);
    public static PCWSTR op_Implicit(Char* value);
    public static PCWSTR op_Implicit(PWSTR value);
    public sealed virtual bool Equals(PCWSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Length();
    public virtual string ToString();
    private string get_DebuggerDisplay();
    internal ReadOnlySpan`1<char> AsSpan();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.PSTR : ValueType {
    internal Byte* Value;
    internal PSTR(Byte* value);
    public static Byte* op_Implicit(PSTR value);
    public static PSTR op_Implicit(Byte* value);
    public static bool op_Equality(PSTR left, PSTR right);
    public static bool op_Inequality(PSTR left, PSTR right);
    public sealed virtual bool Equals(PSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.PWSTR : ValueType {
    internal Char* Value;
    internal int Length { get; }
    internal PWSTR(Char* value);
    public static Char* op_Implicit(PWSTR value);
    public static PWSTR op_Implicit(Char* value);
    public static bool op_Equality(PWSTR left, PWSTR right);
    public static bool op_Inequality(PWSTR left, PWSTR right);
    public sealed virtual bool Equals(PWSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Length();
    public virtual string ToString();
    internal Span`1<char> AsSpan();
}
internal enum Windows.Win32.Graphics.Gdi.GET_DEVICE_CAPS_INDEX : Enum {
    public UInt32 value__;
    public static GET_DEVICE_CAPS_INDEX DRIVERVERSION;
    public static GET_DEVICE_CAPS_INDEX TECHNOLOGY;
    public static GET_DEVICE_CAPS_INDEX HORZSIZE;
    public static GET_DEVICE_CAPS_INDEX VERTSIZE;
    public static GET_DEVICE_CAPS_INDEX HORZRES;
    public static GET_DEVICE_CAPS_INDEX VERTRES;
    public static GET_DEVICE_CAPS_INDEX BITSPIXEL;
    public static GET_DEVICE_CAPS_INDEX PLANES;
    public static GET_DEVICE_CAPS_INDEX NUMBRUSHES;
    public static GET_DEVICE_CAPS_INDEX NUMPENS;
    public static GET_DEVICE_CAPS_INDEX NUMMARKERS;
    public static GET_DEVICE_CAPS_INDEX NUMFONTS;
    public static GET_DEVICE_CAPS_INDEX NUMCOLORS;
    public static GET_DEVICE_CAPS_INDEX PDEVICESIZE;
    public static GET_DEVICE_CAPS_INDEX CURVECAPS;
    public static GET_DEVICE_CAPS_INDEX LINECAPS;
    public static GET_DEVICE_CAPS_INDEX POLYGONALCAPS;
    public static GET_DEVICE_CAPS_INDEX TEXTCAPS;
    public static GET_DEVICE_CAPS_INDEX CLIPCAPS;
    public static GET_DEVICE_CAPS_INDEX RASTERCAPS;
    public static GET_DEVICE_CAPS_INDEX ASPECTX;
    public static GET_DEVICE_CAPS_INDEX ASPECTY;
    public static GET_DEVICE_CAPS_INDEX ASPECTXY;
    public static GET_DEVICE_CAPS_INDEX LOGPIXELSX;
    public static GET_DEVICE_CAPS_INDEX LOGPIXELSY;
    public static GET_DEVICE_CAPS_INDEX SIZEPALETTE;
    public static GET_DEVICE_CAPS_INDEX NUMRESERVED;
    public static GET_DEVICE_CAPS_INDEX COLORRES;
    public static GET_DEVICE_CAPS_INDEX PHYSICALWIDTH;
    public static GET_DEVICE_CAPS_INDEX PHYSICALHEIGHT;
    public static GET_DEVICE_CAPS_INDEX PHYSICALOFFSETX;
    public static GET_DEVICE_CAPS_INDEX PHYSICALOFFSETY;
    public static GET_DEVICE_CAPS_INDEX SCALINGFACTORX;
    public static GET_DEVICE_CAPS_INDEX SCALINGFACTORY;
    public static GET_DEVICE_CAPS_INDEX VREFRESH;
    public static GET_DEVICE_CAPS_INDEX DESKTOPVERTRES;
    public static GET_DEVICE_CAPS_INDEX DESKTOPHORZRES;
    public static GET_DEVICE_CAPS_INDEX BLTALIGNMENT;
    public static GET_DEVICE_CAPS_INDEX SHADEBLENDCAPS;
    public static GET_DEVICE_CAPS_INDEX COLORMGMTCAPS;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Graphics.Gdi.HDC : ValueType {
    internal IntPtr Value;
    internal bool IsNull { get; }
    internal HDC(IntPtr value);
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HDC value);
    public static HDC op_Explicit(IntPtr value);
    public static bool op_Equality(HDC left, HDC right);
    public static bool op_Inequality(HDC left, HDC right);
    public sealed virtual bool Equals(HDC other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Windows.Win32.InlineArrayIndexerExtensions : object {
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_1& this, int index);
    [ExtensionAttribute]
internal static Char& ItemRef(__char_1& this, int index);
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_128& this, int index);
    [ExtensionAttribute]
internal static Char& ItemRef(__char_128& this, int index);
    [ExtensionAttribute]
internal static Byte& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__byte_1& this, int index);
    [ExtensionAttribute]
internal static Byte& ItemRef(__byte_1& this, int index);
    [ExtensionAttribute]
internal static Byte& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__byte_1& this, int index);
    [ExtensionAttribute]
internal static Byte& ItemRef(__byte_1& this, int index);
    [ExtensionAttribute]
internal static DISK_EXTENT& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__winmdroot_System_Ioctl_DISK_EXTENT_1& this, int index);
    [ExtensionAttribute]
internal static DISK_EXTENT& ItemRef(__winmdroot_System_Ioctl_DISK_EXTENT_1& this, int index);
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_256& this, int index);
    [ExtensionAttribute]
internal static Char& ItemRef(__char_256& this, int index);
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_64& this, int index);
    [ExtensionAttribute]
internal static Char& ItemRef(__char_64& this, int index);
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_128& this, int index);
    [ExtensionAttribute]
internal static Char& ItemRef(__char_128& this, int index);
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_260& this, int index);
    [ExtensionAttribute]
internal static Char& ItemRef(__char_260& this, int index);
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_512& this, int index);
    [ExtensionAttribute]
internal static Char& ItemRef(__char_512& this, int index);
}
internal class Windows.Win32.NetworkManagement.NetManagement.DSREG_JOIN_INFO : ValueType {
    internal DSREG_JOIN_TYPE joinType;
    internal CERT_CONTEXT* pJoinCertificate;
    internal PWSTR pszDeviceId;
    internal PWSTR pszIdpDomain;
    internal PWSTR pszTenantId;
    internal PWSTR pszJoinUserEmail;
    internal PWSTR pszTenantDisplayName;
    internal PWSTR pszMdmEnrollmentUrl;
    internal PWSTR pszMdmTermsOfUseUrl;
    internal PWSTR pszMdmComplianceUrl;
    internal PWSTR pszUserSettingSyncUrl;
    internal DSREG_USER_INFO* pUserInfo;
}
internal enum Windows.Win32.NetworkManagement.NetManagement.DSREG_JOIN_TYPE : Enum {
    public int value__;
    public static DSREG_JOIN_TYPE DSREG_UNKNOWN_JOIN;
    public static DSREG_JOIN_TYPE DSREG_DEVICE_JOIN;
    public static DSREG_JOIN_TYPE DSREG_WORKPLACE_JOIN;
}
internal class Windows.Win32.NetworkManagement.NetManagement.DSREG_USER_INFO : ValueType {
    internal PWSTR pszUserEmail;
    internal PWSTR pszUserKeyId;
    internal PWSTR pszUserKeyName;
}
internal class Windows.Win32.Security.Cryptography.CERT_CONTEXT : ValueType {
    internal UInt32 dwCertEncodingType;
    internal Byte* pbCertEncoded;
    internal UInt32 cbCertEncoded;
    internal CERT_INFO* pCertInfo;
    internal Void* hCertStore;
}
internal class Windows.Win32.Security.Cryptography.CERT_EXTENSION : ValueType {
    internal PSTR pszObjId;
    internal BOOL fCritical;
    internal CRYPTOAPI_BLOB Value;
}
internal class Windows.Win32.Security.Cryptography.CERT_INFO : ValueType {
    internal UInt32 dwVersion;
    internal CRYPTOAPI_BLOB SerialNumber;
    internal CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
    internal CRYPTOAPI_BLOB Issuer;
    internal FILETIME NotBefore;
    internal FILETIME NotAfter;
    internal CRYPTOAPI_BLOB Subject;
    internal CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
    internal CRYPT_BIT_BLOB IssuerUniqueId;
    internal CRYPT_BIT_BLOB SubjectUniqueId;
    internal UInt32 cExtension;
    internal CERT_EXTENSION* rgExtension;
}
internal class Windows.Win32.Security.Cryptography.CERT_PUBLIC_KEY_INFO : ValueType {
    internal CRYPT_ALGORITHM_IDENTIFIER Algorithm;
    internal CRYPT_BIT_BLOB PublicKey;
}
internal class Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER : ValueType {
    internal PSTR pszObjId;
    internal CRYPTOAPI_BLOB Parameters;
}
internal class Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB : ValueType {
    internal UInt32 cbData;
    internal Byte* pbData;
    internal UInt32 cUnusedBits;
}
internal class Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB : ValueType {
    internal UInt32 cbData;
    internal Byte* pbData;
}
internal class Windows.Win32.Security.SECURITY_ATTRIBUTES : ValueType {
    internal UInt32 nLength;
    internal Void* lpSecurityDescriptor;
    internal BOOL bInheritHandle;
}
internal enum Windows.Win32.Security.TOKEN_ELEVATION_TYPE : Enum {
    public int value__;
    public static TOKEN_ELEVATION_TYPE TokenElevationTypeDefault;
    public static TOKEN_ELEVATION_TYPE TokenElevationTypeFull;
    public static TOKEN_ELEVATION_TYPE TokenElevationTypeLimited;
}
internal enum Windows.Win32.Security.TOKEN_INFORMATION_CLASS : Enum {
    public int value__;
    public static TOKEN_INFORMATION_CLASS TokenUser;
    public static TOKEN_INFORMATION_CLASS TokenGroups;
    public static TOKEN_INFORMATION_CLASS TokenPrivileges;
    public static TOKEN_INFORMATION_CLASS TokenOwner;
    public static TOKEN_INFORMATION_CLASS TokenPrimaryGroup;
    public static TOKEN_INFORMATION_CLASS TokenDefaultDacl;
    public static TOKEN_INFORMATION_CLASS TokenSource;
    public static TOKEN_INFORMATION_CLASS TokenType;
    public static TOKEN_INFORMATION_CLASS TokenImpersonationLevel;
    public static TOKEN_INFORMATION_CLASS TokenStatistics;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedSids;
    public static TOKEN_INFORMATION_CLASS TokenSessionId;
    public static TOKEN_INFORMATION_CLASS TokenGroupsAndPrivileges;
    public static TOKEN_INFORMATION_CLASS TokenSessionReference;
    public static TOKEN_INFORMATION_CLASS TokenSandBoxInert;
    public static TOKEN_INFORMATION_CLASS TokenAuditPolicy;
    public static TOKEN_INFORMATION_CLASS TokenOrigin;
    public static TOKEN_INFORMATION_CLASS TokenElevationType;
    public static TOKEN_INFORMATION_CLASS TokenLinkedToken;
    public static TOKEN_INFORMATION_CLASS TokenElevation;
    public static TOKEN_INFORMATION_CLASS TokenHasRestrictions;
    public static TOKEN_INFORMATION_CLASS TokenAccessInformation;
    public static TOKEN_INFORMATION_CLASS TokenVirtualizationAllowed;
    public static TOKEN_INFORMATION_CLASS TokenVirtualizationEnabled;
    public static TOKEN_INFORMATION_CLASS TokenIntegrityLevel;
    public static TOKEN_INFORMATION_CLASS TokenUIAccess;
    public static TOKEN_INFORMATION_CLASS TokenMandatoryPolicy;
    public static TOKEN_INFORMATION_CLASS TokenLogonSid;
    public static TOKEN_INFORMATION_CLASS TokenIsAppContainer;
    public static TOKEN_INFORMATION_CLASS TokenCapabilities;
    public static TOKEN_INFORMATION_CLASS TokenAppContainerSid;
    public static TOKEN_INFORMATION_CLASS TokenAppContainerNumber;
    public static TOKEN_INFORMATION_CLASS TokenUserClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenDeviceClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedUserClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedDeviceClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenDeviceGroups;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedDeviceGroups;
    public static TOKEN_INFORMATION_CLASS TokenSecurityAttributes;
    public static TOKEN_INFORMATION_CLASS TokenIsRestricted;
    public static TOKEN_INFORMATION_CLASS TokenProcessTrustLevel;
    public static TOKEN_INFORMATION_CLASS TokenPrivateNameSpace;
    public static TOKEN_INFORMATION_CLASS TokenSingletonAttributes;
    public static TOKEN_INFORMATION_CLASS TokenBnoIsolation;
    public static TOKEN_INFORMATION_CLASS TokenChildProcessFlags;
    public static TOKEN_INFORMATION_CLASS TokenIsLessPrivilegedAppContainer;
    public static TOKEN_INFORMATION_CLASS TokenIsSandboxed;
    public static TOKEN_INFORMATION_CLASS MaxTokenInfoClass;
}
internal class Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION : ValueType {
    internal UInt32 dwFileAttributes;
    internal FILETIME ftCreationTime;
    internal FILETIME ftLastAccessTime;
    internal FILETIME ftLastWriteTime;
    internal UInt32 dwVolumeSerialNumber;
    internal UInt32 nFileSizeHigh;
    internal UInt32 nFileSizeLow;
    internal UInt32 nNumberOfLinks;
    internal UInt32 nFileIndexHigh;
    internal UInt32 nFileIndexLow;
}
[FlagsAttribute]
internal enum Windows.Win32.Storage.FileSystem.FILE_ACCESS_FLAGS : Enum {
    public UInt32 value__;
    public static FILE_ACCESS_FLAGS FILE_READ_DATA;
    public static FILE_ACCESS_FLAGS FILE_LIST_DIRECTORY;
    public static FILE_ACCESS_FLAGS FILE_WRITE_DATA;
    public static FILE_ACCESS_FLAGS FILE_ADD_FILE;
    public static FILE_ACCESS_FLAGS FILE_APPEND_DATA;
    public static FILE_ACCESS_FLAGS FILE_ADD_SUBDIRECTORY;
    public static FILE_ACCESS_FLAGS FILE_CREATE_PIPE_INSTANCE;
    public static FILE_ACCESS_FLAGS FILE_READ_EA;
    public static FILE_ACCESS_FLAGS FILE_WRITE_EA;
    public static FILE_ACCESS_FLAGS FILE_EXECUTE;
    public static FILE_ACCESS_FLAGS FILE_TRAVERSE;
    public static FILE_ACCESS_FLAGS FILE_DELETE_CHILD;
    public static FILE_ACCESS_FLAGS FILE_READ_ATTRIBUTES;
    public static FILE_ACCESS_FLAGS FILE_WRITE_ATTRIBUTES;
    public static FILE_ACCESS_FLAGS READ_CONTROL;
    public static FILE_ACCESS_FLAGS SYNCHRONIZE;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_REQUIRED;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_READ;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_WRITE;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_EXECUTE;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_ALL;
    public static FILE_ACCESS_FLAGS SPECIFIC_RIGHTS_ALL;
    public static FILE_ACCESS_FLAGS FILE_ALL_ACCESS;
    public static FILE_ACCESS_FLAGS FILE_GENERIC_READ;
    public static FILE_ACCESS_FLAGS FILE_GENERIC_WRITE;
    public static FILE_ACCESS_FLAGS FILE_GENERIC_EXECUTE;
}
internal class Windows.Win32.Storage.FileSystem.FILE_BASIC_INFO : ValueType {
    internal long CreationTime;
    internal long LastAccessTime;
    internal long LastWriteTime;
    internal long ChangeTime;
    internal UInt32 FileAttributes;
}
internal enum Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION : Enum {
    public UInt32 value__;
    public static FILE_CREATION_DISPOSITION CREATE_NEW;
    public static FILE_CREATION_DISPOSITION CREATE_ALWAYS;
    public static FILE_CREATION_DISPOSITION OPEN_EXISTING;
    public static FILE_CREATION_DISPOSITION OPEN_ALWAYS;
    public static FILE_CREATION_DISPOSITION TRUNCATE_EXISTING;
}
internal class Windows.Win32.Storage.FileSystem.FILE_DISPOSITION_INFO : ValueType {
    internal BOOLEAN DeleteFileA;
}
[FlagsAttribute]
internal enum Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES : Enum {
    public UInt32 value__;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_READONLY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_HIDDEN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_SYSTEM;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_DIRECTORY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_ARCHIVE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_DEVICE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NORMAL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_TEMPORARY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_SPARSE_FILE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_REPARSE_POINT;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_COMPRESSED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_OFFLINE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_ENCRYPTED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_INTEGRITY_STREAM;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_VIRTUAL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NO_SCRUB_DATA;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_EA;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_PINNED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_UNPINNED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_RECALL_ON_OPEN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_WRITE_THROUGH;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OVERLAPPED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_NO_BUFFERING;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_RANDOM_ACCESS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_SEQUENTIAL_SCAN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_DELETE_ON_CLOSE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_BACKUP_SEMANTICS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_POSIX_SEMANTICS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_SESSION_AWARE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OPEN_REPARSE_POINT;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OPEN_NO_RECALL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_FIRST_PIPE_INSTANCE;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_DUPLEX;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_INBOUND;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_OUTBOUND;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_ANONYMOUS;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_IDENTIFICATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_IMPERSONATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_DELEGATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_CONTEXT_TRACKING;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_EFFECTIVE_ONLY;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_SQOS_PRESENT;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_VALID_SQOS_FLAGS;
}
internal enum Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS : Enum {
    public int value__;
    public static FILE_INFO_BY_HANDLE_CLASS FileBasicInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStandardInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileNameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileRenameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileDispositionInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAllocationInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileEndOfFileInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStreamInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileCompressionInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAttributeTagInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdBothDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdBothDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIoPriorityHintInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileRemoteProtocolInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileFullDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileFullDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStorageInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAlignmentInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdExtdDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdExtdDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileDispositionInfoEx;
    public static FILE_INFO_BY_HANDLE_CLASS FileRenameInfoEx;
    public static FILE_INFO_BY_HANDLE_CLASS FileCaseSensitiveInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileNormalizedNameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS MaximumFileInfoByHandleClass;
}
internal enum Windows.Win32.Storage.FileSystem.FILE_NAME : Enum {
    public UInt32 value__;
    public static FILE_NAME FILE_NAME_NORMALIZED;
    public static FILE_NAME FILE_NAME_OPENED;
}
internal class Windows.Win32.Storage.FileSystem.FILE_RENAME_INFO : ValueType {
    internal _Anonymous_e__Union Anonymous;
    internal HANDLE RootDirectory;
    internal UInt32 FileNameLength;
    internal __char_1 FileName;
}
[FlagsAttribute]
internal enum Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE : Enum {
    public UInt32 value__;
    public static FILE_SHARE_MODE FILE_SHARE_NONE;
    public static FILE_SHARE_MODE FILE_SHARE_DELETE;
    public static FILE_SHARE_MODE FILE_SHARE_READ;
    public static FILE_SHARE_MODE FILE_SHARE_WRITE;
}
internal enum Windows.Win32.Storage.FileSystem.STORAGE_BUS_TYPE : Enum {
    public int value__;
    public static STORAGE_BUS_TYPE BusTypeUnknown;
    public static STORAGE_BUS_TYPE BusTypeScsi;
    public static STORAGE_BUS_TYPE BusTypeAtapi;
    public static STORAGE_BUS_TYPE BusTypeAta;
    public static STORAGE_BUS_TYPE BusType1394;
    public static STORAGE_BUS_TYPE BusTypeSsa;
    public static STORAGE_BUS_TYPE BusTypeFibre;
    public static STORAGE_BUS_TYPE BusTypeUsb;
    public static STORAGE_BUS_TYPE BusTypeRAID;
    public static STORAGE_BUS_TYPE BusTypeiScsi;
    public static STORAGE_BUS_TYPE BusTypeSas;
    public static STORAGE_BUS_TYPE BusTypeSata;
    public static STORAGE_BUS_TYPE BusTypeSd;
    public static STORAGE_BUS_TYPE BusTypeMmc;
    public static STORAGE_BUS_TYPE BusTypeVirtual;
    public static STORAGE_BUS_TYPE BusTypeFileBackedVirtual;
    public static STORAGE_BUS_TYPE BusTypeSpaces;
    public static STORAGE_BUS_TYPE BusTypeNvme;
    public static STORAGE_BUS_TYPE BusTypeSCM;
    public static STORAGE_BUS_TYPE BusTypeUfs;
    public static STORAGE_BUS_TYPE BusTypeMax;
    public static STORAGE_BUS_TYPE BusTypeMaxReserved;
}
internal enum Windows.Win32.System.Diagnostics.Debug.IMAGE_FILE_MACHINE : Enum {
    public ushort value__;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_AXP64;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_I386;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_IA64;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_AMD64;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_UNKNOWN;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_TARGET_HOST;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_R3000;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_R4000;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_R10000;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_WCEMIPSV2;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_ALPHA;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_SH3;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_SH3DSP;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_SH3E;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_SH4;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_SH5;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_ARM;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_THUMB;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_ARMNT;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_AM33;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_POWERPC;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_POWERPCFP;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_MIPS16;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_ALPHA64;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_MIPSFPU;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_MIPSFPU16;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_TRICORE;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_CEF;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_EBC;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_M32R;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_ARM64;
    public static IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_CEE;
}
internal enum Windows.Win32.System.Diagnostics.Debug.PROCESSOR_ARCHITECTURE : Enum {
    public ushort value__;
    public static PROCESSOR_ARCHITECTURE PROCESSOR_ARCHITECTURE_AMD64;
    public static PROCESSOR_ARCHITECTURE PROCESSOR_ARCHITECTURE_IA64;
    public static PROCESSOR_ARCHITECTURE PROCESSOR_ARCHITECTURE_INTEL;
    public static PROCESSOR_ARCHITECTURE PROCESSOR_ARCHITECTURE_ARM;
    public static PROCESSOR_ARCHITECTURE PROCESSOR_ARCHITECTURE_UNKNOWN;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.System.Diagnostics.ProcessSnapshotting.HPSS : ValueType {
    [NativeIntegerAttribute]
internal IntPtr Value;
    internal HPSS(IntPtr value);
    public static IntPtr op_Implicit(HPSS value);
    public static HPSS op_Explicit(IntPtr value);
    public static bool op_Equality(HPSS left, HPSS right);
    public static bool op_Inequality(HPSS left, HPSS right);
    public sealed virtual bool Equals(HPSS other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[FlagsAttribute]
internal enum Windows.Win32.System.Diagnostics.ProcessSnapshotting.PSS_CAPTURE_FLAGS : Enum {
    public UInt32 value__;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_NONE;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_VA_CLONE;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_RESERVED_00000002;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_HANDLES;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_HANDLE_NAME_INFORMATION;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_HANDLE_BASIC_INFORMATION;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_HANDLE_TYPE_SPECIFIC_INFORMATION;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_HANDLE_TRACE;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_THREADS;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_THREAD_CONTEXT;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_THREAD_CONTEXT_EXTENDED;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_RESERVED_00000400;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_VA_SPACE;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_VA_SPACE_SECTION_INFORMATION;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_IPT_TRACE;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_RESERVED_00004000;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_BREAKAWAY_OPTIONAL;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_BREAKAWAY;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_FORCE_BREAKAWAY;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_USE_VM_ALLOCATIONS;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_MEASURE_PERFORMANCE;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_RELEASE_SECTION;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.System.ErrorReporting.HREPORT : ValueType {
    internal IntPtr Value;
    internal bool IsNull { get; }
    internal HREPORT(IntPtr value);
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HREPORT value);
    public static HREPORT op_Explicit(IntPtr value);
    public static bool op_Equality(HREPORT left, HREPORT right);
    public static bool op_Inequality(HREPORT left, HREPORT right);
    public sealed virtual bool Equals(HREPORT other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum Windows.Win32.System.ErrorReporting.WER_CONSENT : Enum {
    public int value__;
    public static WER_CONSENT WerConsentNotAsked;
    public static WER_CONSENT WerConsentApproved;
    public static WER_CONSENT WerConsentDenied;
    public static WER_CONSENT WerConsentAlwaysPrompt;
    public static WER_CONSENT WerConsentMax;
}
internal class Windows.Win32.System.ErrorReporting.WER_DUMP_CUSTOM_OPTIONS_V3 : ValueType {
    internal UInt32 dwSize;
    internal UInt32 dwMask;
    internal UInt32 dwDumpFlags;
    internal BOOL bOnlyThisThread;
    internal UInt32 dwExceptionThreadFlags;
    internal UInt32 dwOtherThreadFlags;
    internal UInt32 dwExceptionThreadExFlags;
    internal UInt32 dwOtherThreadExFlags;
    internal UInt32 dwPreferredModuleFlags;
    internal UInt32 dwOtherModuleFlags;
    internal __char_256 wzPreferredModuleList;
    internal UInt32 dwPreferredModuleResetFlags;
    internal UInt32 dwOtherModuleResetFlags;
    internal Void* pvDumpKey;
    internal HANDLE hSnapshot;
    internal UInt32 dwThreadID;
}
[FlagsAttribute]
internal enum Windows.Win32.System.ErrorReporting.WER_FILE : Enum {
    public UInt32 value__;
    public static WER_FILE WER_FILE_ANONYMOUS_DATA;
    public static WER_FILE WER_FILE_DELETE_WHEN_DONE;
}
internal enum Windows.Win32.System.ErrorReporting.WER_FILE_TYPE : Enum {
    public int value__;
    public static WER_FILE_TYPE WerFileTypeMicrodump;
    public static WER_FILE_TYPE WerFileTypeMinidump;
    public static WER_FILE_TYPE WerFileTypeHeapdump;
    public static WER_FILE_TYPE WerFileTypeUserDocument;
    public static WER_FILE_TYPE WerFileTypeOther;
    public static WER_FILE_TYPE WerFileTypeTriagedump;
    public static WER_FILE_TYPE WerFileTypeCustomDump;
    public static WER_FILE_TYPE WerFileTypeAuxiliaryDump;
    public static WER_FILE_TYPE WerFileTypeEtlTrace;
    public static WER_FILE_TYPE WerFileTypeMax;
}
internal class Windows.Win32.System.ErrorReporting.WER_REPORT_INFORMATION : ValueType {
    internal UInt32 dwSize;
    internal HANDLE hProcess;
    internal __char_64 wzConsentKey;
    internal __char_128 wzFriendlyEventName;
    internal __char_128 wzApplicationName;
    internal __char_260 wzApplicationPath;
    internal __char_512 wzDescription;
    internal HWND hwndParent;
}
internal enum Windows.Win32.System.ErrorReporting.WER_REPORT_TYPE : Enum {
    public int value__;
    public static WER_REPORT_TYPE WerReportNonCritical;
    public static WER_REPORT_TYPE WerReportCritical;
    public static WER_REPORT_TYPE WerReportApplicationCrash;
    public static WER_REPORT_TYPE WerReportApplicationHang;
    public static WER_REPORT_TYPE WerReportKernel;
    public static WER_REPORT_TYPE WerReportInvalid;
}
[FlagsAttribute]
internal enum Windows.Win32.System.ErrorReporting.WER_SUBMIT_FLAGS : Enum {
    public UInt32 value__;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_ADD_REGISTERED_DATA;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_HONOR_RECOVERY;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_HONOR_RESTART;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_NO_ARCHIVE;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_NO_CLOSE_UI;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_NO_QUEUE;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_OUTOFPROCESS;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_OUTOFPROCESS_ASYNC;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_QUEUE;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_SHOW_DEBUG;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_START_MINIMIZED;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_BYPASS_DATA_THROTTLING;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_ARCHIVE_PARAMETERS_ONLY;
    public static WER_SUBMIT_FLAGS WER_SUBMIT_REPORT_MACHINE_ID;
}
internal enum Windows.Win32.System.ErrorReporting.WER_SUBMIT_RESULT : Enum {
    public int value__;
    public static WER_SUBMIT_RESULT WerReportQueued;
    public static WER_SUBMIT_RESULT WerReportUploaded;
    public static WER_SUBMIT_RESULT WerReportDebug;
    public static WER_SUBMIT_RESULT WerReportFailed;
    public static WER_SUBMIT_RESULT WerDisabled;
    public static WER_SUBMIT_RESULT WerReportCancelled;
    public static WER_SUBMIT_RESULT WerDisabledQueue;
    public static WER_SUBMIT_RESULT WerReportAsync;
    public static WER_SUBMIT_RESULT WerCustomAction;
    public static WER_SUBMIT_RESULT WerThrottled;
    public static WER_SUBMIT_RESULT WerReportUploadedCab;
    public static WER_SUBMIT_RESULT WerStorageLocationNotFound;
    public static WER_SUBMIT_RESULT WerSubmitResultMax;
}
internal class Windows.Win32.System.IO.OVERLAPPED : ValueType {
    [NativeIntegerAttribute]
internal UIntPtr Internal;
    [NativeIntegerAttribute]
internal UIntPtr InternalHigh;
    internal _Anonymous_e__Union Anonymous;
    internal HANDLE hEvent;
}
internal class Windows.Win32.System.Ioctl.DISK_EXTENT : ValueType {
    internal UInt32 DiskNumber;
    internal long StartingOffset;
    internal long ExtentLength;
}
internal class Windows.Win32.System.Ioctl.STORAGE_DESCRIPTOR_HEADER : ValueType {
    internal UInt32 Version;
    internal UInt32 Size;
}
internal class Windows.Win32.System.Ioctl.STORAGE_DEVICE_DESCRIPTOR : ValueType {
    internal UInt32 Version;
    internal UInt32 Size;
    internal byte DeviceType;
    internal byte DeviceTypeModifier;
    internal BOOLEAN RemovableMedia;
    internal BOOLEAN CommandQueueing;
    internal UInt32 VendorIdOffset;
    internal UInt32 ProductIdOffset;
    internal UInt32 ProductRevisionOffset;
    internal UInt32 SerialNumberOffset;
    internal STORAGE_BUS_TYPE BusType;
    internal UInt32 RawPropertiesLength;
    internal __byte_1 RawDeviceProperties;
}
internal enum Windows.Win32.System.Ioctl.STORAGE_PROPERTY_ID : Enum {
    public int value__;
    public static STORAGE_PROPERTY_ID StorageDeviceProperty;
    public static STORAGE_PROPERTY_ID StorageAdapterProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceIdProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceUniqueIdProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceWriteCacheProperty;
    public static STORAGE_PROPERTY_ID StorageMiniportProperty;
    public static STORAGE_PROPERTY_ID StorageAccessAlignmentProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceSeekPenaltyProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceTrimProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceWriteAggregationProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceDeviceTelemetryProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceLBProvisioningProperty;
    public static STORAGE_PROPERTY_ID StorageDevicePowerProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceCopyOffloadProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceResiliencyProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceMediumProductType;
    public static STORAGE_PROPERTY_ID StorageAdapterRpmbProperty;
    public static STORAGE_PROPERTY_ID StorageAdapterCryptoProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceIoCapabilityProperty;
    public static STORAGE_PROPERTY_ID StorageAdapterProtocolSpecificProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceProtocolSpecificProperty;
    public static STORAGE_PROPERTY_ID StorageAdapterTemperatureProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceTemperatureProperty;
    public static STORAGE_PROPERTY_ID StorageAdapterPhysicalTopologyProperty;
    public static STORAGE_PROPERTY_ID StorageDevicePhysicalTopologyProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceAttributesProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceManagementStatus;
    public static STORAGE_PROPERTY_ID StorageAdapterSerialNumberProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceLocationProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceNumaProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceZonedDeviceProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceUnsafeShutdownCount;
    public static STORAGE_PROPERTY_ID StorageDeviceEnduranceProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceLedStateProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceSelfEncryptionProperty;
    public static STORAGE_PROPERTY_ID StorageFruIdProperty;
}
internal class Windows.Win32.System.Ioctl.STORAGE_PROPERTY_QUERY : ValueType {
    internal STORAGE_PROPERTY_ID PropertyId;
    internal STORAGE_QUERY_TYPE QueryType;
    internal __byte_1 AdditionalParameters;
}
internal enum Windows.Win32.System.Ioctl.STORAGE_QUERY_TYPE : Enum {
    public int value__;
    public static STORAGE_QUERY_TYPE PropertyStandardQuery;
    public static STORAGE_QUERY_TYPE PropertyExistsQuery;
    public static STORAGE_QUERY_TYPE PropertyMaskQuery;
    public static STORAGE_QUERY_TYPE PropertyQueryMaxDefined;
}
internal class Windows.Win32.System.Ioctl.VOLUME_DISK_EXTENTS : ValueType {
    internal UInt32 NumberOfDiskExtents;
    internal __winmdroot_System_Ioctl_DISK_EXTENT_1 Extents;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.System.SystemInformation.FIRMWARE_TABLE_ID : ValueType {
    internal UInt32 Value;
    internal FIRMWARE_TABLE_ID(UInt32 value);
    public static UInt32 op_Implicit(FIRMWARE_TABLE_ID value);
    public static FIRMWARE_TABLE_ID op_Explicit(UInt32 value);
    public static bool op_Equality(FIRMWARE_TABLE_ID left, FIRMWARE_TABLE_ID right);
    public static bool op_Inequality(FIRMWARE_TABLE_ID left, FIRMWARE_TABLE_ID right);
    public sealed virtual bool Equals(FIRMWARE_TABLE_ID other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum Windows.Win32.System.SystemInformation.FIRMWARE_TABLE_PROVIDER : Enum {
    public UInt32 value__;
    public static FIRMWARE_TABLE_PROVIDER ACPI;
    public static FIRMWARE_TABLE_PROVIDER FIRM;
    public static FIRMWARE_TABLE_PROVIDER RSMB;
}
internal class Windows.Win32.System.SystemInformation.MEMORYSTATUSEX : ValueType {
    internal UInt32 dwLength;
    internal UInt32 dwMemoryLoad;
    internal ulong ullTotalPhys;
    internal ulong ullAvailPhys;
    internal ulong ullTotalPageFile;
    internal ulong ullAvailPageFile;
    internal ulong ullTotalVirtual;
    internal ulong ullAvailVirtual;
    internal ulong ullAvailExtendedVirtual;
}
internal class Windows.Win32.System.SystemInformation.OSVERSIONINFOW : ValueType {
    internal UInt32 dwOSVersionInfoSize;
    internal UInt32 dwMajorVersion;
    internal UInt32 dwMinorVersion;
    internal UInt32 dwBuildNumber;
    internal UInt32 dwPlatformId;
    internal __char_128 szCSDVersion;
}
internal class Windows.Win32.System.SystemInformation.SYSTEM_INFO : ValueType {
    internal _Anonymous_e__Union Anonymous;
    internal UInt32 dwPageSize;
    internal Void* lpMinimumApplicationAddress;
    internal Void* lpMaximumApplicationAddress;
    [NativeIntegerAttribute]
internal UIntPtr dwActiveProcessorMask;
    internal UInt32 dwNumberOfProcessors;
    internal UInt32 dwProcessorType;
    internal UInt32 dwAllocationGranularity;
    internal ushort wProcessorLevel;
    internal ushort wProcessorRevision;
}
[FlagsAttribute]
internal enum Windows.Win32.System.Threading.MACHINE_ATTRIBUTES : Enum {
    public UInt32 value__;
    public static MACHINE_ATTRIBUTES UserEnabled;
    public static MACHINE_ATTRIBUTES KernelEnabled;
    public static MACHINE_ATTRIBUTES Wow64Container;
}
internal enum Windows.Win32.System.Threading.PROCESS_INFORMATION_CLASS : Enum {
    public int value__;
    public static PROCESS_INFORMATION_CLASS ProcessMemoryPriority;
    public static PROCESS_INFORMATION_CLASS ProcessMemoryExhaustionInfo;
    public static PROCESS_INFORMATION_CLASS ProcessAppMemoryInfo;
    public static PROCESS_INFORMATION_CLASS ProcessInPrivateInfo;
    public static PROCESS_INFORMATION_CLASS ProcessPowerThrottling;
    public static PROCESS_INFORMATION_CLASS ProcessReservedValue1;
    public static PROCESS_INFORMATION_CLASS ProcessTelemetryCoverageInfo;
    public static PROCESS_INFORMATION_CLASS ProcessProtectionLevelInfo;
    public static PROCESS_INFORMATION_CLASS ProcessLeapSecondInfo;
    public static PROCESS_INFORMATION_CLASS ProcessMachineTypeInfo;
    public static PROCESS_INFORMATION_CLASS ProcessInformationClassMax;
}
internal class Windows.Win32.System.Threading.PROCESS_MACHINE_INFORMATION : ValueType {
    internal ushort ProcessMachine;
    internal ushort Res0;
    internal MACHINE_ATTRIBUTES MachineAttributes;
}
internal static class Windows.Win32.TelemetryPInvoke : object {
    internal static UInt32 DELETE;
    internal static UInt32 FILE_RENAME_FLAG_POSIX_SEMANTICS;
    internal static UInt32 FILE_RENAME_FLAG_REPLACE_IF_EXISTS;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 GENERIC_WRITE;
    internal static UInt32 IOCTL_STORAGE_QUERY_PROPERTY;
    internal static UInt32 IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS;
    internal static HRESULT S_OK;
    private static TelemetryPInvoke();
    internal static UInt32 PssCaptureSnapshot(IntPtr processHandle, PSS_CAPTURE_FLAGS captureFlags, UInt32 threadContextFlags, HPSS& snapshotHandle);
    internal static UInt32 PssFreeSnapshot(IntPtr processHandle, HPSS snapshotHandle);
    internal static BOOL GetTokenInformation(SafeHandle TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, Void* TokenInformation, UInt32 TokenInformationLength, UInt32& ReturnLength);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, Void* TokenInformation, UInt32 TokenInformationLength, UInt32* ReturnLength);
    internal static int GetDeviceCaps(SafeHandle hdc, GET_DEVICE_CAPS_INDEX index);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static int GetDeviceCaps(HDC hdc, GET_DEVICE_CAPS_INDEX index);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL CloseHandle(HANDLE hObject);
    internal static SafeFileHandle CreateFile(string lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, SafeHandle hTemplateFile);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE CreateFile(PCWSTR lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, HANDLE hTemplateFile);
    internal static BOOL DeviceIoControl(SafeHandle hDevice, UInt32 dwIoControlCode, Void* lpInBuffer, UInt32 nInBufferSize, Void* lpOutBuffer, UInt32 nOutBufferSize, UInt32* lpBytesReturned, OVERLAPPED* lpOverlapped);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL DeviceIoControl(HANDLE hDevice, UInt32 dwIoControlCode, Void* lpInBuffer, UInt32 nInBufferSize, Void* lpOutBuffer, UInt32 nOutBufferSize, UInt32* lpBytesReturned, OVERLAPPED* lpOverlapped);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 EnumSystemFirmwareTables(FIRMWARE_TABLE_PROVIDER FirmwareTableProviderSignature, FIRMWARE_TABLE_ID* pFirmwareTableEnumBuffer, UInt32 BufferSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static PWSTR GetCommandLine();
    internal static SafeFileHandle GetCurrentProcess_SafeHandle();
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE GetCurrentProcess();
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetCurrentProcessId();
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetCurrentThreadId();
    internal static BOOL GetFileInformationByHandle(SafeHandle hFile, BY_HANDLE_FILE_INFORMATION& lpFileInformation);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetFileInformationByHandle(HANDLE hFile, BY_HANDLE_FILE_INFORMATION* lpFileInformation);
    internal static UInt32 GetFinalPathNameByHandle(SafeHandle hFile, PWSTR lpszFilePath, UInt32 cchFilePath, FILE_NAME dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetFinalPathNameByHandle(HANDLE hFile, PWSTR lpszFilePath, UInt32 cchFilePath, FILE_NAME dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL FreeLibrary(HINSTANCE hLibModule);
    internal static UInt32 GetModuleFileName(SafeHandle hModule, PWSTR lpFilename, UInt32 nSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetModuleFileName(HINSTANCE hModule, PWSTR lpFilename, UInt32 nSize);
    internal static void GetNativeSystemInfo(SYSTEM_INFO& lpSystemInfo);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static void GetNativeSystemInfo(SYSTEM_INFO* lpSystemInfo);
    internal static BOOL GetProcessInformation(SafeHandle hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, Void* ProcessInformation, UInt32 ProcessInformationSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, Void* ProcessInformation, UInt32 ProcessInformationSize);
    internal static BOOL GetProcessTimes(SafeHandle hProcess, FILETIME& lpCreationTime, FILETIME& lpExitTime, FILETIME& lpKernelTime, FILETIME& lpUserTime);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetProcessTimes(HANDLE hProcess, FILETIME* lpCreationTime, FILETIME* lpExitTime, FILETIME* lpKernelTime, FILETIME* lpUserTime);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetSystemFirmwareTable(FIRMWARE_TABLE_PROVIDER FirmwareTableProviderSignature, FIRMWARE_TABLE_ID FirmwareTableID, Void* pFirmwareTableBuffer, UInt32 BufferSize);
    internal static BOOL GetVersionEx(OSVERSIONINFOW& lpVersionInformation);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetVersionEx(OSVERSIONINFOW* lpVersionInformation);
    internal static BOOL GlobalMemoryStatusEx(MEMORYSTATUSEX& lpBuffer);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GlobalMemoryStatusEx(MEMORYSTATUSEX* lpBuffer);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL IsDebuggerPresent();
    internal static BOOL IsWow64Process2(SafeHandle hProcess, UInt16& pProcessMachine, UInt16* pNativeMachine);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL IsWow64Process2(HANDLE hProcess, UInt16* pProcessMachine, UInt16* pNativeMachine);
    internal static BOOL ProcessIdToSessionId(UInt32 dwProcessId, UInt32& pSessionId);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL ProcessIdToSessionId(UInt32 dwProcessId, UInt32* pSessionId);
    internal static UInt32 PssCaptureSnapshot(SafeHandle ProcessHandle, PSS_CAPTURE_FLAGS CaptureFlags, UInt32 ThreadContextFlags, HPSS& SnapshotHandle);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 PssCaptureSnapshot(HANDLE ProcessHandle, PSS_CAPTURE_FLAGS CaptureFlags, UInt32 ThreadContextFlags, HPSS* SnapshotHandle);
    internal static UInt32 PssFreeSnapshot(SafeHandle ProcessHandle, HPSS SnapshotHandle);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 PssFreeSnapshot(HANDLE ProcessHandle, HPSS SnapshotHandle);
    internal static SafeFileHandle ReOpenFile(SafeHandle hOriginalFile, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE ReOpenFile(HANDLE hOriginalFile, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
    internal static BOOL SetFileInformationByHandle(SafeHandle hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
    internal static UInt32 WaitForMultipleObjects(ReadOnlySpan`1<HANDLE> lpHandles, BOOL bWaitAll, UInt32 dwMilliseconds);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 WaitForMultipleObjects(UInt32 nCount, HANDLE* lpHandles, BOOL bWaitAll, UInt32 dwMilliseconds);
    internal static HRESULT WerRegisterCustomMetadata(string key, string value);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HRESULT WerRegisterCustomMetadata(PCWSTR key, PCWSTR value);
    internal static void NetFreeAadJoinInformation(Nullable`1<DSREG_JOIN_INFO> pJoinInfo);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static void NetFreeAadJoinInformation(DSREG_JOIN_INFO* pJoinInfo);
    internal static HRESULT NetGetAadJoinInformation(string pcszTenantId, DSREG_JOIN_INFO** ppJoinInfo);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HRESULT NetGetAadJoinInformation(PCWSTR pcszTenantId, DSREG_JOIN_INFO** ppJoinInfo);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL IsOS(OS dwOS);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static int ReleaseDC(HWND hWnd, HDC hDC);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static int GetSystemMetrics(SYSTEM_METRICS_INDEX nIndex);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HRESULT WerReportCloseHandle(HREPORT hReportHandle);
    internal static HRESULT WerReportAddFile(SafeHandle hReportHandle, string pwzPath, WER_FILE_TYPE repFileType, WER_FILE dwFileFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HRESULT WerReportAddFile(HREPORT hReportHandle, PCWSTR pwzPath, WER_FILE_TYPE repFileType, WER_FILE dwFileFlags);
    internal static HRESULT WerReportCreate(string pwzEventType, WER_REPORT_TYPE repType, Nullable`1<WER_REPORT_INFORMATION> pReportInformation, WerReportCloseHandleSafeHandle& phReportHandle);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HRESULT WerReportCreate(PCWSTR pwzEventType, WER_REPORT_TYPE repType, WER_REPORT_INFORMATION* pReportInformation, HREPORT* phReportHandle);
    internal static HRESULT WerReportSetParameter(SafeHandle hReportHandle, UInt32 dwparamID, string pwzName, string pwzValue);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HRESULT WerReportSetParameter(HREPORT hReportHandle, UInt32 dwparamID, PCWSTR pwzName, PCWSTR pwzValue);
    internal static HRESULT WerReportSubmit(SafeHandle hReportHandle, WER_CONSENT consent, WER_SUBMIT_FLAGS dwFlags, WER_SUBMIT_RESULT* pSubmitResult);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HRESULT WerReportSubmit(HREPORT hReportHandle, WER_CONSENT consent, WER_SUBMIT_FLAGS dwFlags, WER_SUBMIT_RESULT* pSubmitResult);
}
internal enum Windows.Win32.UI.Shell.OS : Enum {
    public UInt32 value__;
    public static OS OS_WINDOWS;
    public static OS OS_NT;
    public static OS OS_WIN95ORGREATER;
    public static OS OS_NT4ORGREATER;
    public static OS OS_WIN98ORGREATER;
    public static OS OS_WIN98_GOLD;
    public static OS OS_WIN2000ORGREATER;
    public static OS OS_WIN2000PRO;
    public static OS OS_WIN2000SERVER;
    public static OS OS_WIN2000ADVSERVER;
    public static OS OS_WIN2000DATACENTER;
    public static OS OS_WIN2000TERMINAL;
    public static OS OS_EMBEDDED;
    public static OS OS_TERMINALCLIENT;
    public static OS OS_TERMINALREMOTEADMIN;
    public static OS OS_WIN95_GOLD;
    public static OS OS_MEORGREATER;
    public static OS OS_XPORGREATER;
    public static OS OS_HOME;
    public static OS OS_PROFESSIONAL;
    public static OS OS_DATACENTER;
    public static OS OS_ADVSERVER;
    public static OS OS_SERVER;
    public static OS OS_TERMINALSERVER;
    public static OS OS_PERSONALTERMINALSERVER;
    public static OS OS_FASTUSERSWITCHING;
    public static OS OS_WELCOMELOGONUI;
    public static OS OS_DOMAINMEMBER;
    public static OS OS_ANYSERVER;
    public static OS OS_WOW6432;
    public static OS OS_WEBSERVER;
    public static OS OS_SMALLBUSINESSSERVER;
    public static OS OS_TABLETPC;
    public static OS OS_SERVERADMINUI;
    public static OS OS_MEDIACENTER;
    public static OS OS_APPLIANCE;
}
internal enum Windows.Win32.UI.WindowsAndMessaging.SYSTEM_METRICS_INDEX : Enum {
    public UInt32 value__;
    public static SYSTEM_METRICS_INDEX SM_ARRANGE;
    public static SYSTEM_METRICS_INDEX SM_CLEANBOOT;
    public static SYSTEM_METRICS_INDEX SM_CMONITORS;
    public static SYSTEM_METRICS_INDEX SM_CMOUSEBUTTONS;
    public static SYSTEM_METRICS_INDEX SM_CONVERTIBLESLATEMODE;
    public static SYSTEM_METRICS_INDEX SM_CXBORDER;
    public static SYSTEM_METRICS_INDEX SM_CXCURSOR;
    public static SYSTEM_METRICS_INDEX SM_CXDLGFRAME;
    public static SYSTEM_METRICS_INDEX SM_CXDOUBLECLK;
    public static SYSTEM_METRICS_INDEX SM_CXDRAG;
    public static SYSTEM_METRICS_INDEX SM_CXEDGE;
    public static SYSTEM_METRICS_INDEX SM_CXFIXEDFRAME;
    public static SYSTEM_METRICS_INDEX SM_CXFOCUSBORDER;
    public static SYSTEM_METRICS_INDEX SM_CXFRAME;
    public static SYSTEM_METRICS_INDEX SM_CXFULLSCREEN;
    public static SYSTEM_METRICS_INDEX SM_CXHSCROLL;
    public static SYSTEM_METRICS_INDEX SM_CXHTHUMB;
    public static SYSTEM_METRICS_INDEX SM_CXICON;
    public static SYSTEM_METRICS_INDEX SM_CXICONSPACING;
    public static SYSTEM_METRICS_INDEX SM_CXMAXIMIZED;
    public static SYSTEM_METRICS_INDEX SM_CXMAXTRACK;
    public static SYSTEM_METRICS_INDEX SM_CXMENUCHECK;
    public static SYSTEM_METRICS_INDEX SM_CXMENUSIZE;
    public static SYSTEM_METRICS_INDEX SM_CXMIN;
    public static SYSTEM_METRICS_INDEX SM_CXMINIMIZED;
    public static SYSTEM_METRICS_INDEX SM_CXMINSPACING;
    public static SYSTEM_METRICS_INDEX SM_CXMINTRACK;
    public static SYSTEM_METRICS_INDEX SM_CXPADDEDBORDER;
    public static SYSTEM_METRICS_INDEX SM_CXSCREEN;
    public static SYSTEM_METRICS_INDEX SM_CXSIZE;
    public static SYSTEM_METRICS_INDEX SM_CXSIZEFRAME;
    public static SYSTEM_METRICS_INDEX SM_CXSMICON;
    public static SYSTEM_METRICS_INDEX SM_CXSMSIZE;
    public static SYSTEM_METRICS_INDEX SM_CXVIRTUALSCREEN;
    public static SYSTEM_METRICS_INDEX SM_CXVSCROLL;
    public static SYSTEM_METRICS_INDEX SM_CYBORDER;
    public static SYSTEM_METRICS_INDEX SM_CYCAPTION;
    public static SYSTEM_METRICS_INDEX SM_CYCURSOR;
    public static SYSTEM_METRICS_INDEX SM_CYDLGFRAME;
    public static SYSTEM_METRICS_INDEX SM_CYDOUBLECLK;
    public static SYSTEM_METRICS_INDEX SM_CYDRAG;
    public static SYSTEM_METRICS_INDEX SM_CYEDGE;
    public static SYSTEM_METRICS_INDEX SM_CYFIXEDFRAME;
    public static SYSTEM_METRICS_INDEX SM_CYFOCUSBORDER;
    public static SYSTEM_METRICS_INDEX SM_CYFRAME;
    public static SYSTEM_METRICS_INDEX SM_CYFULLSCREEN;
    public static SYSTEM_METRICS_INDEX SM_CYHSCROLL;
    public static SYSTEM_METRICS_INDEX SM_CYICON;
    public static SYSTEM_METRICS_INDEX SM_CYICONSPACING;
    public static SYSTEM_METRICS_INDEX SM_CYKANJIWINDOW;
    public static SYSTEM_METRICS_INDEX SM_CYMAXIMIZED;
    public static SYSTEM_METRICS_INDEX SM_CYMAXTRACK;
    public static SYSTEM_METRICS_INDEX SM_CYMENU;
    public static SYSTEM_METRICS_INDEX SM_CYMENUCHECK;
    public static SYSTEM_METRICS_INDEX SM_CYMENUSIZE;
    public static SYSTEM_METRICS_INDEX SM_CYMIN;
    public static SYSTEM_METRICS_INDEX SM_CYMINIMIZED;
    public static SYSTEM_METRICS_INDEX SM_CYMINSPACING;
    public static SYSTEM_METRICS_INDEX SM_CYMINTRACK;
    public static SYSTEM_METRICS_INDEX SM_CYSCREEN;
    public static SYSTEM_METRICS_INDEX SM_CYSIZE;
    public static SYSTEM_METRICS_INDEX SM_CYSIZEFRAME;
    public static SYSTEM_METRICS_INDEX SM_CYSMCAPTION;
    public static SYSTEM_METRICS_INDEX SM_CYSMICON;
    public static SYSTEM_METRICS_INDEX SM_CYSMSIZE;
    public static SYSTEM_METRICS_INDEX SM_CYVIRTUALSCREEN;
    public static SYSTEM_METRICS_INDEX SM_CYVSCROLL;
    public static SYSTEM_METRICS_INDEX SM_CYVTHUMB;
    public static SYSTEM_METRICS_INDEX SM_DBCSENABLED;
    public static SYSTEM_METRICS_INDEX SM_DEBUG;
    public static SYSTEM_METRICS_INDEX SM_DIGITIZER;
    public static SYSTEM_METRICS_INDEX SM_IMMENABLED;
    public static SYSTEM_METRICS_INDEX SM_MAXIMUMTOUCHES;
    public static SYSTEM_METRICS_INDEX SM_MEDIACENTER;
    public static SYSTEM_METRICS_INDEX SM_MENUDROPALIGNMENT;
    public static SYSTEM_METRICS_INDEX SM_MIDEASTENABLED;
    public static SYSTEM_METRICS_INDEX SM_MOUSEPRESENT;
    public static SYSTEM_METRICS_INDEX SM_MOUSEHORIZONTALWHEELPRESENT;
    public static SYSTEM_METRICS_INDEX SM_MOUSEWHEELPRESENT;
    public static SYSTEM_METRICS_INDEX SM_NETWORK;
    public static SYSTEM_METRICS_INDEX SM_PENWINDOWS;
    public static SYSTEM_METRICS_INDEX SM_REMOTECONTROL;
    public static SYSTEM_METRICS_INDEX SM_REMOTESESSION;
    public static SYSTEM_METRICS_INDEX SM_SAMEDISPLAYFORMAT;
    public static SYSTEM_METRICS_INDEX SM_SECURE;
    public static SYSTEM_METRICS_INDEX SM_SERVERR2;
    public static SYSTEM_METRICS_INDEX SM_SHOWSOUNDS;
    public static SYSTEM_METRICS_INDEX SM_SHUTTINGDOWN;
    public static SYSTEM_METRICS_INDEX SM_SLOWMACHINE;
    public static SYSTEM_METRICS_INDEX SM_STARTER;
    public static SYSTEM_METRICS_INDEX SM_SWAPBUTTON;
    public static SYSTEM_METRICS_INDEX SM_SYSTEMDOCKED_;
    public static SYSTEM_METRICS_INDEX SM_TABLETPC;
    public static SYSTEM_METRICS_INDEX SM_XVIRTUALSCREEN;
    public static SYSTEM_METRICS_INDEX SM_YVIRTUALSCREEN;
}
internal class Windows.Win32.WerReportCloseHandleSafeHandle : SafeHandle {
    private static IntPtr INVALID_HANDLE_VALUE;
    public bool IsInvalid { get; }
    internal WerReportCloseHandleSafeHandle(IntPtr preexistingHandle, bool ownsHandle);
    private static WerReportCloseHandleSafeHandle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
