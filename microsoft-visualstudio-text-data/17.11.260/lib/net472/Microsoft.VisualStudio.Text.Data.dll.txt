[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Microsoft.VisualStudio.Text.ContentTypeChangedEventArgs : TextSnapshotChangedEventArgs {
    [CompilerGeneratedAttribute]
private IContentType <BeforeContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private IContentType <AfterContentType>k__BackingField;
    public IContentType BeforeContentType { get; }
    public IContentType AfterContentType { get; }
    public ContentTypeChangedEventArgs(ITextSnapshot beforeSnapshot, ITextSnapshot afterSnapshot, IContentType beforeContentType, IContentType afterContentType, object editTag);
    [CompilerGeneratedAttribute]
public IContentType get_BeforeContentType();
    [CompilerGeneratedAttribute]
public IContentType get_AfterContentType();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Text.CreateAndLoadTextDocumentResult : object {
    [CompilerGeneratedAttribute]
private ITextDocument <TextDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CharacterSubstitutionsOccurred>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <LoadingException>k__BackingField;
    internal ITextDocument TextDocument { get; }
    internal bool CharacterSubstitutionsOccurred { get; }
    internal Exception LoadingException { get; }
    internal CreateAndLoadTextDocumentResult(ITextDocument textDocument, bool characterSubstitutionsOccurred, Exception loadingException);
    [CompilerGeneratedAttribute]
internal ITextDocument get_TextDocument();
    [CompilerGeneratedAttribute]
internal bool get_CharacterSubstitutionsOccurred();
    [CompilerGeneratedAttribute]
internal Exception get_LoadingException();
}
public class Microsoft.VisualStudio.Text.CustomTrackToVersion : MulticastDelegate {
    public CustomTrackToVersion(object object, IntPtr method);
    public virtual Span Invoke(ITrackingSpan customSpan, ITextVersion currentVersion, ITextVersion targetVersion, Span currentSpan, object customState);
    public virtual IAsyncResult BeginInvoke(ITrackingSpan customSpan, ITextVersion currentVersion, ITextVersion targetVersion, Span currentSpan, object customState, AsyncCallback callback, object object);
    public virtual Span EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.Text.Differencing.ContinueProcessingPredicate`1 : MulticastDelegate {
    public ContinueProcessingPredicate`1(object object, IntPtr method);
    public virtual bool Invoke(int leftIndex, IList`1<T> leftSequence, int longestMatchSoFar);
    public virtual IAsyncResult BeginInvoke(int leftIndex, IList`1<T> leftSequence, int longestMatchSoFar, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[ObsoleteAttribute("Methods that use this callback are now deprecated, and instances of this callback will not be used.")]
public class Microsoft.VisualStudio.Text.Differencing.DetermineLocalityCallback : MulticastDelegate {
    public DetermineLocalityCallback(object object, IntPtr method);
    public virtual Nullable`1<int> Invoke(StringDifferenceTypes differenceType, IList`1<string> leftStrings, IList`1<string> rightStrings);
    public virtual IAsyncResult BeginInvoke(StringDifferenceTypes differenceType, IList`1<string> leftStrings, IList`1<string> rightStrings, AsyncCallback callback, object object);
    public virtual Nullable`1<int> EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.Text.Differencing.Difference : object {
    private Span left;
    private Span right;
    private Match before;
    private Match after;
    private DifferenceType type;
    public Span Left { get; }
    public Span Right { get; }
    public Match Before { get; }
    public Match After { get; }
    public DifferenceType DifferenceType { get; }
    public Difference(Span left, Span right, Match before, Match after);
    public Span get_Left();
    public Span get_Right();
    public Match get_Before();
    public Match get_After();
    public DifferenceType get_DifferenceType();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Microsoft.VisualStudio.Text.Differencing.DifferenceType : Enum {
    public int value__;
    public static DifferenceType Add;
    public static DifferenceType Remove;
    public static DifferenceType Change;
}
public interface Microsoft.VisualStudio.Text.Differencing.IDifferenceCollection`1 {
    public IEnumerable`1<Tuple`2<int, int>> MatchSequence { get; }
    public IList`1<T> LeftSequence { get; }
    public IList`1<T> RightSequence { get; }
    public IList`1<Difference> Differences { get; }
    public abstract virtual IEnumerable`1<Tuple`2<int, int>> get_MatchSequence();
    public abstract virtual IList`1<T> get_LeftSequence();
    public abstract virtual IList`1<T> get_RightSequence();
    public abstract virtual IList`1<Difference> get_Differences();
}
public interface Microsoft.VisualStudio.Text.Differencing.IDifferenceService {
    public abstract virtual IDifferenceCollection`1<T> DifferenceSequences(IList`1<T> left, IList`1<T> right);
    public abstract virtual IDifferenceCollection`1<T> DifferenceSequences(IList`1<T> left, IList`1<T> right, ContinueProcessingPredicate`1<T> continueProcessingPredicate);
}
public interface Microsoft.VisualStudio.Text.Differencing.IHierarchicalDifferenceCollection {
    public ITokenizedStringList LeftDecomposition { get; }
    public ITokenizedStringList RightDecomposition { get; }
    public abstract virtual ITokenizedStringList get_LeftDecomposition();
    public abstract virtual ITokenizedStringList get_RightDecomposition();
    public abstract virtual IHierarchicalDifferenceCollection GetContainedDifferences(int index);
    public abstract virtual bool HasContainedDifferences(int index);
}
[ObsoleteAttribute("This interface has been deprecated in favor of the ITextDifferencingSelectorService MEF service.")]
public interface Microsoft.VisualStudio.Text.Differencing.IHierarchicalStringDifferenceService {
    public abstract virtual IHierarchicalDifferenceCollection DiffStrings(string left, string right, StringDifferenceOptions differenceOptions);
    public abstract virtual IHierarchicalDifferenceCollection DiffSnapshotSpans(SnapshotSpan left, SnapshotSpan right, StringDifferenceOptions differenceOptions);
}
public interface Microsoft.VisualStudio.Text.Differencing.ITextDifferencingSelectorService {
    public ITextDifferencingService DefaultTextDifferencingService { get; }
    public abstract virtual ITextDifferencingService GetTextDifferencingService(IContentType contentType);
    public abstract virtual ITextDifferencingService get_DefaultTextDifferencingService();
}
public interface Microsoft.VisualStudio.Text.Differencing.ITextDifferencingService {
    public abstract virtual IHierarchicalDifferenceCollection DiffStrings(string left, string right, StringDifferenceOptions differenceOptions);
    public abstract virtual IHierarchicalDifferenceCollection DiffSnapshotSpans(SnapshotSpan left, SnapshotSpan right, StringDifferenceOptions differenceOptions);
    public abstract virtual IHierarchicalDifferenceCollection DiffSnapshotSpans(SnapshotSpan left, SnapshotSpan right, StringDifferenceOptions differenceOptions, Func`2<ITextSnapshotLine, string> getLineTextCallback);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Text.Differencing.ITextDifferencingService2 {
    public abstract virtual IHierarchicalDifferenceCollection DiffStrings(string left, string right, StringDifferenceOptions differenceOptions, IEqualityComparer`1<string> comparer);
    public abstract virtual IHierarchicalDifferenceCollection DiffSnapshotSpans(SnapshotSpan left, SnapshotSpan right, StringDifferenceOptions differenceOptions, IEqualityComparer`1<string> comparer);
    public abstract virtual IHierarchicalDifferenceCollection DiffSnapshotSpans(SnapshotSpan left, SnapshotSpan right, StringDifferenceOptions differenceOptions, Func`2<ITextSnapshotLine, string> getLineTextCallback, IEqualityComparer`1<string> comparer);
}
public interface Microsoft.VisualStudio.Text.Differencing.ITokenizedStringList {
    public string Original { get; }
    public abstract virtual string get_Original();
    public abstract virtual Span GetElementInOriginal(int index);
    public abstract virtual Span GetSpanInOriginal(Span span);
}
public class Microsoft.VisualStudio.Text.Differencing.Match : object {
    private Span left;
    private Span right;
    public Span Left { get; }
    public Span Right { get; }
    public int Length { get; }
    public Match(Span left, Span right);
    public Span get_Left();
    public Span get_Right();
    public int get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Text.Differencing.Match/<GetEnumerator>d__11")]
public sealed virtual IEnumerator`1<Tuple`2<int, int>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Microsoft.VisualStudio.Text.Differencing.StringDifferenceOptions : ValueType {
    [CompilerGeneratedAttribute]
private StringDifferenceTypes <DifferenceType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Locality>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreTrimWhiteSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private WordSplitBehavior <WordSplitBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private DetermineLocalityCallback <DetermineLocalityCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private ContinueProcessingPredicate`1<string> <ContinueProcessingPredicate>k__BackingField;
    public StringDifferenceTypes DifferenceType { get; public set; }
    [ObsoleteAttribute("This value is no longer used and will be ignored.")]
public int Locality { get; public set; }
    public bool IgnoreTrimWhiteSpace { get; public set; }
    public WordSplitBehavior WordSplitBehavior { get; public set; }
    [ObsoleteAttribute("This callback is no longer used and will be ignored.")]
public DetermineLocalityCallback DetermineLocalityCallback { get; public set; }
    public ContinueProcessingPredicate`1<string> ContinueProcessingPredicate { get; public set; }
    public StringDifferenceOptions(StringDifferenceTypes differenceType, int locality, bool ignoreTrimWhiteSpace);
    public StringDifferenceOptions(StringDifferenceOptions other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public StringDifferenceTypes get_DifferenceType();
    [CompilerGeneratedAttribute]
public void set_DifferenceType(StringDifferenceTypes value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Locality();
    [CompilerGeneratedAttribute]
public void set_Locality(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IgnoreTrimWhiteSpace();
    [CompilerGeneratedAttribute]
public void set_IgnoreTrimWhiteSpace(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public WordSplitBehavior get_WordSplitBehavior();
    [CompilerGeneratedAttribute]
public void set_WordSplitBehavior(WordSplitBehavior value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public DetermineLocalityCallback get_DetermineLocalityCallback();
    [CompilerGeneratedAttribute]
public void set_DetermineLocalityCallback(DetermineLocalityCallback value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ContinueProcessingPredicate`1<string> get_ContinueProcessingPredicate();
    [CompilerGeneratedAttribute]
public void set_ContinueProcessingPredicate(ContinueProcessingPredicate`1<string> value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(StringDifferenceOptions left, StringDifferenceOptions right);
    public static bool op_Inequality(StringDifferenceOptions left, StringDifferenceOptions right);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Text.Differencing.StringDifferenceTypes : Enum {
    public int value__;
    public static StringDifferenceTypes Line;
    public static StringDifferenceTypes Word;
    public static StringDifferenceTypes Character;
}
public enum Microsoft.VisualStudio.Text.Differencing.WordSplitBehavior : Enum {
    public int value__;
    public static WordSplitBehavior Default;
    public static WordSplitBehavior CharacterClass;
    public static WordSplitBehavior WhiteSpace;
    public static WordSplitBehavior WhiteSpaceAndPunctuation;
    public static WordSplitBehavior LanguageAppropriate;
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Text.Document.IWhitespaceManager {
    public NewlineState NewlineState { get; }
    public LeadingWhitespaceState LeadingWhitespaceState { get; }
    public abstract virtual NewlineState get_NewlineState();
    public abstract virtual LeadingWhitespaceState get_LeadingWhitespaceState();
    public abstract virtual string NormalizeNewlines(string input);
}
internal interface Microsoft.VisualStudio.Text.Document.IWhitespaceManagerFactory {
    public abstract virtual IWhitespaceManager CreateWhitespaceManager(ITextBuffer buffer);
    public abstract virtual bool TryGetExistingWhitespaceManager(ITextBuffer buffer, IWhitespaceManager& manager);
}
public class Microsoft.VisualStudio.Text.DynamicReadOnlyRegionQuery : MulticastDelegate {
    public DynamicReadOnlyRegionQuery(object object, IntPtr method);
    public virtual bool Invoke(bool isEdit);
    public virtual IAsyncResult BeginInvoke(bool isEdit, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public enum Microsoft.VisualStudio.Text.EdgeInsertionMode : Enum {
    public int value__;
    public static EdgeInsertionMode Allow;
    public static EdgeInsertionMode Deny;
}
public class Microsoft.VisualStudio.Text.EditOptions : ValueType {
    public static EditOptions None;
    public static EditOptions DefaultMinimalChange;
    [CompilerGeneratedAttribute]
private bool <ComputeMinimalChange>k__BackingField;
    [CompilerGeneratedAttribute]
private StringDifferenceOptions <DifferenceOptions>k__BackingField;
    public bool ComputeMinimalChange { get; }
    public StringDifferenceOptions DifferenceOptions { get; }
    public EditOptions(StringDifferenceOptions differenceOptions);
    public EditOptions(bool computeMinimalChange, StringDifferenceOptions differenceOptions);
    private static EditOptions();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ComputeMinimalChange();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public StringDifferenceOptions get_DifferenceOptions();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(EditOptions left, EditOptions right);
    public static bool op_Inequality(EditOptions left, EditOptions right);
}
public class Microsoft.VisualStudio.Text.EncodingChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Encoding <OldEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <NewEncoding>k__BackingField;
    public Encoding OldEncoding { get; private set; }
    public Encoding NewEncoding { get; private set; }
    public EncodingChangedEventArgs(Encoding oldEncoding, Encoding newEncoding);
    [CompilerGeneratedAttribute]
public Encoding get_OldEncoding();
    [CompilerGeneratedAttribute]
private void set_OldEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public Encoding get_NewEncoding();
    [CompilerGeneratedAttribute]
private void set_NewEncoding(Encoding value);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Text.FileActionTypes : Enum {
    public int value__;
    public static FileActionTypes ContentSavedToDisk;
    public static FileActionTypes ContentLoadedFromDisk;
    public static FileActionTypes DocumentRenamed;
}
[NullableContextAttribute("2")]
internal interface Microsoft.VisualStudio.Text.IAsynchronouslyLoadedTextDocumentData {
    public bool CharacterSubstitutionsOccurred { get; }
    public Exception LoadingException { get; }
    public abstract virtual bool TryGetOrCreateTextDocument(IContentType contentType, ITextDocument& textDocument);
    public abstract virtual bool get_CharacterSubstitutionsOccurred();
    public abstract virtual bool TryGetTextBuffer(ITextBuffer& textBuffer);
    public abstract virtual Exception get_LoadingException();
}
public interface Microsoft.VisualStudio.Text.IDeleteEditTag {
}
public interface Microsoft.VisualStudio.Text.IEditTag {
}
public interface Microsoft.VisualStudio.Text.IEncodingDetector {
    public abstract virtual Encoding GetStreamEncoding(Stream stream);
}
public interface Microsoft.VisualStudio.Text.IExtensionErrorHandler {
    public abstract virtual void HandleError(object sender, Exception exception);
}
public interface Microsoft.VisualStudio.Text.IExtensionErrorHandler2 {
    public abstract virtual void LogError(object sender, Exception exception);
}
public interface Microsoft.VisualStudio.Text.IExtensionPerformanceTracker {
    public abstract virtual void BeforeCallingEventHandler(Delegate eventHandler);
    public abstract virtual void AfterCallingEventHandler(Delegate eventHandler);
    public abstract virtual void BeforeCallingExtension(object extension);
    public abstract virtual void AfterCallingExtension(object extension);
}
public interface Microsoft.VisualStudio.Text.IFormattingEditTag {
}
public interface Microsoft.VisualStudio.Text.IFormattingNeededEditTag {
}
public interface Microsoft.VisualStudio.Text.IInviolableEditTag {
}
public interface Microsoft.VisualStudio.Text.IInvisibleEditTag {
}
public interface Microsoft.VisualStudio.Text.IMappingPoint {
    public ITextBuffer AnchorBuffer { get; }
    public IBufferGraph BufferGraph { get; }
    public abstract virtual Nullable`1<SnapshotPoint> GetPoint(ITextBuffer targetBuffer, PositionAffinity affinity);
    public abstract virtual Nullable`1<SnapshotPoint> GetPoint(ITextSnapshot targetSnapshot, PositionAffinity affinity);
    public abstract virtual Nullable`1<SnapshotPoint> GetPoint(Predicate`1<ITextBuffer> match, PositionAffinity affinity);
    public abstract virtual Nullable`1<SnapshotPoint> GetInsertionPoint(Predicate`1<ITextBuffer> match);
    public abstract virtual ITextBuffer get_AnchorBuffer();
    public abstract virtual IBufferGraph get_BufferGraph();
}
public interface Microsoft.VisualStudio.Text.IMappingSpan {
    public IMappingPoint Start { get; }
    public IMappingPoint End { get; }
    public ITextBuffer AnchorBuffer { get; }
    public IBufferGraph BufferGraph { get; }
    public abstract virtual NormalizedSnapshotSpanCollection GetSpans(ITextBuffer targetBuffer);
    public abstract virtual NormalizedSnapshotSpanCollection GetSpans(ITextSnapshot targetSnapshot);
    public abstract virtual NormalizedSnapshotSpanCollection GetSpans(Predicate`1<ITextBuffer> match);
    public abstract virtual IMappingPoint get_Start();
    public abstract virtual IMappingPoint get_End();
    public abstract virtual ITextBuffer get_AnchorBuffer();
    public abstract virtual IBufferGraph get_BufferGraph();
}
public interface Microsoft.VisualStudio.Text.INormalizedTextChangeCollection {
    public bool IncludesLineChanges { get; }
    public abstract virtual bool get_IncludesLineChanges();
}
public interface Microsoft.VisualStudio.Text.IPersistentSpan {
    public bool IsDocumentOpen { get; }
    public ITextDocument Document { get; }
    public ITrackingSpan Span { get; }
    public string FilePath { get; }
    public abstract virtual bool get_IsDocumentOpen();
    public abstract virtual ITextDocument get_Document();
    public abstract virtual ITrackingSpan get_Span();
    public abstract virtual string get_FilePath();
    public abstract virtual bool TryGetStartLineIndex(Int32& startLine, Int32& startIndex);
    public abstract virtual bool TryGetEndLineIndex(Int32& endLine, Int32& endIndex);
    public abstract virtual bool TryGetSpan(Span& span);
    internal abstract virtual void Disconnect();
}
public interface Microsoft.VisualStudio.Text.IPersistentSpanFactory {
    public abstract virtual bool CanCreate(ITextBuffer buffer);
    public abstract virtual IPersistentSpan Create(SnapshotSpan span, SpanTrackingMode trackingMode);
    public abstract virtual IPersistentSpan Create(ITextSnapshot snapshot, int startLine, int startIndex, int endLine, int endIndex, SpanTrackingMode trackingMode);
    internal abstract virtual IPersistentSpan Create(ITextSnapshot snapshot, int startLine, int startIndex, int endLine, int endIndex, SpanTrackingMode trackingMode, TrackingFidelityMode trackingFidelityMode);
    public abstract virtual IPersistentSpan Create(string filePath, int startLine, int startIndex, int endLine, int endIndex, SpanTrackingMode trackingMode);
    internal abstract virtual IPersistentSpan Create(string filePath, int startLine, int startIndex, int endLine, int endIndex, SpanTrackingMode trackingMode, TrackingFidelityMode trackingFidelityMode);
    public abstract virtual IPersistentSpan Create(string filePath, Span span, SpanTrackingMode trackingMode);
}
public interface Microsoft.VisualStudio.Text.IProxyEditTag {
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Text.IReadOnlyRegion {
    public EdgeInsertionMode EdgeInsertionMode { get; }
    public ITrackingSpan Span { get; }
    [NullableAttribute("2")]
public DynamicReadOnlyRegionQuery QueryCallback { get; }
    public abstract virtual EdgeInsertionMode get_EdgeInsertionMode();
    public abstract virtual ITrackingSpan get_Span();
    [NullableContextAttribute("2")]
public abstract virtual DynamicReadOnlyRegionQuery get_QueryCallback();
}
public interface Microsoft.VisualStudio.Text.IReadOnlyRegionEdit {
    public abstract virtual IReadOnlyRegion CreateReadOnlyRegion(Span span);
    public abstract virtual IReadOnlyRegion CreateReadOnlyRegion(Span span, SpanTrackingMode trackingMode, EdgeInsertionMode edgeInsertionMode);
    public abstract virtual IReadOnlyRegion CreateDynamicReadOnlyRegion(Span span, SpanTrackingMode trackingMode, EdgeInsertionMode edgeInsertionMode, DynamicReadOnlyRegionQuery callback);
    public abstract virtual void RemoveReadOnlyRegion(IReadOnlyRegion readOnlyRegion);
}
public interface Microsoft.VisualStudio.Text.IRemoteEditTag {
}
public interface Microsoft.VisualStudio.Text.ITextBuffer {
    public IContentType ContentType { get; }
    public ITextSnapshot CurrentSnapshot { get; }
    public bool EditInProgress { get; }
    public abstract virtual IContentType get_ContentType();
    public abstract virtual ITextSnapshot get_CurrentSnapshot();
    public abstract virtual ITextEdit CreateEdit(EditOptions options, Nullable`1<int> reiteratedVersionNumber, object editTag);
    public abstract virtual ITextEdit CreateEdit();
    public abstract virtual IReadOnlyRegionEdit CreateReadOnlyRegionEdit();
    public abstract virtual bool get_EditInProgress();
    public abstract virtual void TakeThreadOwnership();
    public abstract virtual bool CheckEditAccess();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ReadOnlyRegionsChanged(EventHandler`1<SnapshotSpanEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ReadOnlyRegionsChanged(EventHandler`1<SnapshotSpanEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler`1<TextContentChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler`1<TextContentChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChangedLowPriority(EventHandler`1<TextContentChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChangedLowPriority(EventHandler`1<TextContentChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChangedHighPriority(EventHandler`1<TextContentChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChangedHighPriority(EventHandler`1<TextContentChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changing(EventHandler`1<TextContentChangingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changing(EventHandler`1<TextContentChangingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PostChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PostChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ContentTypeChanged(EventHandler`1<ContentTypeChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ContentTypeChanged(EventHandler`1<ContentTypeChangedEventArgs> value);
    public abstract virtual void ChangeContentType(IContentType newContentType, object editTag);
    public abstract virtual ITextSnapshot Insert(int position, string text);
    public abstract virtual ITextSnapshot Delete(Span deleteSpan);
    public abstract virtual ITextSnapshot Replace(Span replaceSpan, string replaceWith);
    public abstract virtual bool IsReadOnly(int position);
    public abstract virtual bool IsReadOnly(int position, bool isEdit);
    public abstract virtual bool IsReadOnly(Span span);
    public abstract virtual bool IsReadOnly(Span span, bool isEdit);
    public abstract virtual NormalizedSpanCollection GetReadOnlyExtents(Span span);
}
public interface Microsoft.VisualStudio.Text.ITextBuffer2 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChangedOnBackground(EventHandler`1<TextContentChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChangedOnBackground(EventHandler`1<TextContentChangedEventArgs> value);
}
public interface Microsoft.VisualStudio.Text.ITextBufferContentTypeListener {
    public abstract virtual void ContentTypeChanged(ITextBuffer buffer, IContentType oldContentType, IContentType newContentType);
}
internal interface Microsoft.VisualStudio.Text.ITextBufferContentTypeManager {
    public abstract virtual void BufferContentTypeChanged(ITextBuffer buffer, IContentType beforeContentType, IContentType afterContentType);
}
public interface Microsoft.VisualStudio.Text.ITextBufferEdit {
    public ITextSnapshot Snapshot { get; }
    public bool Canceled { get; }
    public abstract virtual ITextSnapshot get_Snapshot();
    public abstract virtual ITextSnapshot Apply();
    public abstract virtual void Cancel();
    public abstract virtual bool get_Canceled();
}
public interface Microsoft.VisualStudio.Text.ITextBufferFactoryService {
    public IContentType TextContentType { get; }
    public IContentType PlaintextContentType { get; }
    public IContentType InertContentType { get; }
    public abstract virtual IContentType get_TextContentType();
    public abstract virtual IContentType get_PlaintextContentType();
    public abstract virtual IContentType get_InertContentType();
    public abstract virtual ITextBuffer CreateTextBuffer();
    public abstract virtual ITextBuffer CreateTextBuffer(IContentType contentType);
    public abstract virtual ITextBuffer CreateTextBuffer(string text, IContentType contentType);
    public abstract virtual ITextBuffer CreateTextBuffer(TextReader reader, IContentType contentType);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextBufferCreated(EventHandler`1<TextBufferCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextBufferCreated(EventHandler`1<TextBufferCreatedEventArgs> value);
}
public interface Microsoft.VisualStudio.Text.ITextBufferFactoryService2 {
    public abstract virtual ITextBuffer CreateTextBuffer(SnapshotSpan span, IContentType contentType);
    public abstract virtual ITextBuffer CreateTextBuffer(TextReader reader, IContentType contentType, long length, string traceId, bool throwOnInvalidCharacters);
}
public interface Microsoft.VisualStudio.Text.ITextBufferFactoryService3 {
    public abstract virtual ITextBuffer CreateTextBuffer(SnapshotSpan span, IContentType contentType);
    public abstract virtual ITextBuffer CreateTextBuffer(TextReader reader, IContentType contentType, long length, string traceId);
    public abstract virtual ITextBuffer CreateTextBuffer(ITextImage image, IContentType contentType);
}
public interface Microsoft.VisualStudio.Text.ITextChange {
    public Span OldSpan { get; }
    public Span NewSpan { get; }
    public int OldPosition { get; }
    public int NewPosition { get; }
    public int Delta { get; }
    public int OldEnd { get; }
    public int NewEnd { get; }
    public string OldText { get; }
    public string NewText { get; }
    public int OldLength { get; }
    public int NewLength { get; }
    public int LineCountDelta { get; }
    public abstract virtual Span get_OldSpan();
    public abstract virtual Span get_NewSpan();
    public abstract virtual int get_OldPosition();
    public abstract virtual int get_NewPosition();
    public abstract virtual int get_Delta();
    public abstract virtual int get_OldEnd();
    public abstract virtual int get_NewEnd();
    public abstract virtual string get_OldText();
    public abstract virtual string get_NewText();
    public abstract virtual int get_OldLength();
    public abstract virtual int get_NewLength();
    public abstract virtual int get_LineCountDelta();
}
public interface Microsoft.VisualStudio.Text.ITextChange2 {
    public bool IsOpaque { get; }
    public abstract virtual bool get_IsOpaque();
}
public interface Microsoft.VisualStudio.Text.ITextChange3 {
    public abstract virtual string GetOldText(Span span);
    public abstract virtual string GetNewText(Span span);
    public abstract virtual char GetOldTextAt(int position);
    public abstract virtual char GetNewTextAt(int position);
}
public interface Microsoft.VisualStudio.Text.ITextDocument {
    public string FilePath { get; }
    public ITextBuffer TextBuffer { get; }
    public bool IsDirty { get; }
    public DateTime LastSavedTime { get; }
    public DateTime LastContentModifiedTime { get; }
    public Encoding Encoding { get; public set; }
    public bool IsReloading { get; }
    public abstract virtual string get_FilePath();
    public abstract virtual ITextBuffer get_TextBuffer();
    public abstract virtual bool get_IsDirty();
    public abstract virtual DateTime get_LastSavedTime();
    public abstract virtual DateTime get_LastContentModifiedTime();
    public abstract virtual Encoding get_Encoding();
    public abstract virtual void set_Encoding(Encoding value);
    public abstract virtual void SetEncoderFallback(EncoderFallback fallback);
    [CompilerGeneratedAttribute]
public abstract virtual void add_EncodingChanged(EventHandler`1<EncodingChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EncodingChanged(EventHandler`1<EncodingChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_FileActionOccurred(EventHandler`1<TextDocumentFileActionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FileActionOccurred(EventHandler`1<TextDocumentFileActionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DirtyStateChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DirtyStateChanged(EventHandler value);
    public abstract virtual void Rename(string newFilePath);
    public abstract virtual ReloadResult Reload();
    public abstract virtual ReloadResult Reload(EditOptions options);
    public abstract virtual bool get_IsReloading();
    public abstract virtual void Save();
    public abstract virtual void SaveAs(string filePath, bool overwrite);
    public abstract virtual void SaveAs(string filePath, bool overwrite, bool createFolder);
    public abstract virtual void SaveAs(string filePath, bool overwrite, IContentType newContentType);
    public abstract virtual void SaveAs(string filePath, bool overwrite, bool createFolder, IContentType newContentType);
    public abstract virtual void SaveCopy(string filePath, bool overwrite);
    public abstract virtual void SaveCopy(string filePath, bool overwrite, bool createFolder);
    public abstract virtual void UpdateDirtyState(bool isDirty, DateTime lastContentModifiedTime);
}
internal interface Microsoft.VisualStudio.Text.ITextDocument2 {
    public abstract virtual Task SaveAsync(CancellationToken token);
    public abstract virtual Task SaveAsync(ITextSnapshot3 snapshotToBeSaved, CancellationToken token);
    public abstract virtual Task SaveAsAsync(string filePath, bool overwrite, bool createFolder, CancellationToken token);
    public abstract virtual Task SaveAsAsync(string filePath, ITextSnapshot3 snapshotToBeSaved, bool overwrite, bool createFolder, CancellationToken token);
    public abstract virtual Task SaveCopyAsync(string filePath, bool overwrite, bool createFolder, CancellationToken token);
    public abstract virtual Task SaveCopyAsync(string filePath, ITextSnapshot3 snapshotToBeSaved, bool overwrite, bool createFolder, CancellationToken token);
}
internal interface Microsoft.VisualStudio.Text.ITextDocument3 {
    [NullableContextAttribute("1")]
public abstract virtual void SetConventionEncoding(Encoding encoding);
    public abstract virtual void ResetConventionEncoding();
}
public interface Microsoft.VisualStudio.Text.ITextDocumentFactoryService {
    public abstract virtual ITextDocument CreateAndLoadTextDocument(string filePath, IContentType contentType);
    public abstract virtual ITextDocument CreateAndLoadTextDocument(string filePath, IContentType contentType, Encoding encoding, Boolean& characterSubstitutionsOccurred);
    public abstract virtual ITextDocument CreateAndLoadTextDocument(string filePath, IContentType contentType, bool attemptUtf8Detection, Boolean& characterSubstitutionsOccurred);
    public abstract virtual ITextDocument CreateTextDocument(ITextBuffer textBuffer, string filePath);
    public abstract virtual bool TryGetTextDocument(ITextBuffer textBuffer, ITextDocument& textDocument);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextDocumentCreated(EventHandler`1<TextDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextDocumentCreated(EventHandler`1<TextDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextDocumentDisposed(EventHandler`1<TextDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextDocumentDisposed(EventHandler`1<TextDocumentEventArgs> value);
}
public interface Microsoft.VisualStudio.Text.ITextDocumentFactoryService2 {
    public abstract virtual ITextDocument CreateAndLoadTextDocument(string filePath, IContentType contentType, bool attemptUtf8Detection, bool allowCompressedStorage, bool throwOnInvalidCharactersIfUnknownEncoding, Boolean& characterSubstitutionsOccurred);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Text.ITextDocumentFactoryService3 {
    public abstract virtual Task`1<IAsynchronouslyLoadedTextDocumentData> CreateTextDocumentAsync(string filePath, IContentType contentType, CancellationToken cancellationToken);
    public abstract virtual Task`1<IAsynchronouslyLoadedTextDocumentData> CreateTextDocumentAsync(string filePath, IContentType contentType, bool attemptUtf8Detection, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<CreateAndLoadTextDocumentResult> CreateAndLoadTextDocumentAsync(string filePath, IContentType contentType, bool attemptUtf8Detection, bool throwOnInvalidCharactersIfUnknownEncoding, bool stayOnCallingThread, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<CreateAndLoadTextDocumentResult> CreateAndLoadTextDocumentAsync(string filePath, IContentType contentType, Encoding encoding, bool stayOnCallingThread, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Text.ITextEdit {
    public bool HasEffectiveChanges { get; }
    public bool HasFailedChanges { get; }
    public abstract virtual bool Insert(int position, string text);
    public abstract virtual bool Insert(int position, Char[] characterBuffer, int startIndex, int length);
    public abstract virtual bool Delete(Span deleteSpan);
    public abstract virtual bool Delete(int startPosition, int charsToDelete);
    public abstract virtual bool Replace(Span replaceSpan, string replaceWith);
    public abstract virtual bool Replace(int startPosition, int charsToReplace, string replaceWith);
    public abstract virtual bool get_HasEffectiveChanges();
    public abstract virtual bool get_HasFailedChanges();
}
[DefaultMemberAttribute("Item")]
public interface Microsoft.VisualStudio.Text.ITextImage {
    public ITextImageVersion Version { get; }
    public int Length { get; }
    public int LineCount { get; }
    public char Item { get; }
    public abstract virtual ITextImageVersion get_Version();
    public abstract virtual ITextImage GetSubText(Span span);
    public abstract virtual int get_Length();
    public abstract virtual int get_LineCount();
    public abstract virtual string GetText(Span span);
    public abstract virtual Char[] ToCharArray(int startIndex, int length);
    public abstract virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public abstract virtual char get_Item(int position);
    public abstract virtual TextImageLine GetLineFromLineNumber(int lineNumber);
    public abstract virtual TextImageLine GetLineFromPosition(int position);
    public abstract virtual int GetLineNumberFromPosition(int position);
    public abstract virtual void Write(TextWriter writer, Span span);
}
internal interface Microsoft.VisualStudio.Text.ITextImage2 {
    public abstract virtual Task WriteAsync(TextWriter writer, Span span, CancellationToken token);
    public abstract virtual void CopyTo(int sourceIndex, Span`1<char> destination, int count);
}
public interface Microsoft.VisualStudio.Text.ITextImageFactoryService {
    public abstract virtual ITextImage CreateTextImage(string text);
    public abstract virtual ITextImage CreateTextImage(TextReader reader, long length);
}
internal interface Microsoft.VisualStudio.Text.ITextImageFactoryService2 {
    public abstract virtual ITextImage CreateTextImage(MemoryMappedFile source);
}
public interface Microsoft.VisualStudio.Text.ITextImageVersion {
    public ITextImageVersion Next { get; }
    public int Length { get; }
    public INormalizedTextChangeCollection Changes { get; }
    public int VersionNumber { get; }
    public int ReiteratedVersionNumber { get; }
    public object Identifier { get; }
    public abstract virtual ITextImageVersion get_Next();
    public abstract virtual int get_Length();
    public abstract virtual INormalizedTextChangeCollection get_Changes();
    public abstract virtual int get_VersionNumber();
    public abstract virtual int get_ReiteratedVersionNumber();
    public abstract virtual object get_Identifier();
    public abstract virtual int TrackTo(VersionedPosition other, PointTrackingMode mode);
    public abstract virtual Span TrackTo(VersionedSpan span, SpanTrackingMode mode);
}
[DefaultMemberAttribute("Item")]
public interface Microsoft.VisualStudio.Text.ITextSnapshot {
    public ITextBuffer TextBuffer { get; }
    public IContentType ContentType { get; }
    public ITextVersion Version { get; }
    public int Length { get; }
    public int LineCount { get; }
    public char Item { get; }
    public IEnumerable`1<ITextSnapshotLine> Lines { get; }
    public abstract virtual ITextBuffer get_TextBuffer();
    public abstract virtual IContentType get_ContentType();
    public abstract virtual ITextVersion get_Version();
    public abstract virtual int get_Length();
    public abstract virtual int get_LineCount();
    public abstract virtual string GetText(Span span);
    public abstract virtual string GetText(int startIndex, int length);
    public abstract virtual string GetText();
    public abstract virtual Char[] ToCharArray(int startIndex, int length);
    public abstract virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public abstract virtual char get_Item(int position);
    public abstract virtual ITrackingPoint CreateTrackingPoint(int position, PointTrackingMode trackingMode);
    public abstract virtual ITrackingPoint CreateTrackingPoint(int position, PointTrackingMode trackingMode, TrackingFidelityMode trackingFidelity);
    public abstract virtual ITrackingSpan CreateTrackingSpan(Span span, SpanTrackingMode trackingMode);
    public abstract virtual ITrackingSpan CreateTrackingSpan(Span span, SpanTrackingMode trackingMode, TrackingFidelityMode trackingFidelity);
    public abstract virtual ITrackingSpan CreateTrackingSpan(int start, int length, SpanTrackingMode trackingMode);
    public abstract virtual ITrackingSpan CreateTrackingSpan(int start, int length, SpanTrackingMode trackingMode, TrackingFidelityMode trackingFidelity);
    public abstract virtual ITextSnapshotLine GetLineFromLineNumber(int lineNumber);
    public abstract virtual ITextSnapshotLine GetLineFromPosition(int position);
    public abstract virtual int GetLineNumberFromPosition(int position);
    public abstract virtual IEnumerable`1<ITextSnapshotLine> get_Lines();
    public abstract virtual void Write(TextWriter writer, Span span);
    public abstract virtual void Write(TextWriter writer);
}
public interface Microsoft.VisualStudio.Text.ITextSnapshot2 {
    public ITextImage TextImage { get; }
    public abstract virtual ITextImage get_TextImage();
    public abstract virtual void SaveToFile(string filePath, bool replaceFile, Encoding encoding);
}
internal interface Microsoft.VisualStudio.Text.ITextSnapshot3 {
    public Guid Identity { get; }
    public abstract virtual Task WriteAsync(TextWriter writer, Span span, CancellationToken token);
    public abstract virtual Task WriteAsync(TextWriter writer, CancellationToken token);
    public abstract virtual Task SaveToFileAsync(string filePath, bool replaceFile, Encoding encoding, CancellationToken token);
    public abstract virtual void CopyTo(int sourceIndex, Span`1<char> destination, int count);
    public abstract virtual Guid get_Identity();
}
public interface Microsoft.VisualStudio.Text.ITextSnapshotLine {
    public ITextSnapshot Snapshot { get; }
    public SnapshotSpan Extent { get; }
    public SnapshotSpan ExtentIncludingLineBreak { get; }
    public int LineNumber { get; }
    public SnapshotPoint Start { get; }
    public int Length { get; }
    public int LengthIncludingLineBreak { get; }
    public SnapshotPoint End { get; }
    public SnapshotPoint EndIncludingLineBreak { get; }
    public int LineBreakLength { get; }
    public abstract virtual ITextSnapshot get_Snapshot();
    public abstract virtual SnapshotSpan get_Extent();
    public abstract virtual SnapshotSpan get_ExtentIncludingLineBreak();
    public abstract virtual int get_LineNumber();
    public abstract virtual SnapshotPoint get_Start();
    public abstract virtual int get_Length();
    public abstract virtual int get_LengthIncludingLineBreak();
    public abstract virtual SnapshotPoint get_End();
    public abstract virtual SnapshotPoint get_EndIncludingLineBreak();
    public abstract virtual int get_LineBreakLength();
    public abstract virtual string GetText();
    public abstract virtual string GetTextIncludingLineBreak();
    public abstract virtual string GetLineBreakText();
}
public interface Microsoft.VisualStudio.Text.ITextVersion {
    public ITextVersion Next { get; }
    public int Length { get; }
    public INormalizedTextChangeCollection Changes { get; }
    public ITextBuffer TextBuffer { get; }
    public int VersionNumber { get; }
    public int ReiteratedVersionNumber { get; }
    public abstract virtual ITextVersion get_Next();
    public abstract virtual int get_Length();
    public abstract virtual INormalizedTextChangeCollection get_Changes();
    public abstract virtual ITrackingPoint CreateTrackingPoint(int position, PointTrackingMode trackingMode);
    public abstract virtual ITrackingPoint CreateTrackingPoint(int position, PointTrackingMode trackingMode, TrackingFidelityMode trackingFidelity);
    public abstract virtual ITrackingSpan CreateTrackingSpan(Span span, SpanTrackingMode trackingMode);
    public abstract virtual ITrackingSpan CreateTrackingSpan(Span span, SpanTrackingMode trackingMode, TrackingFidelityMode trackingFidelity);
    public abstract virtual ITrackingSpan CreateTrackingSpan(int start, int length, SpanTrackingMode trackingMode);
    public abstract virtual ITrackingSpan CreateTrackingSpan(int start, int length, SpanTrackingMode trackingMode, TrackingFidelityMode trackingFidelity);
    public abstract virtual ITrackingSpan CreateCustomTrackingSpan(Span span, TrackingFidelityMode trackingFidelity, object customState, CustomTrackToVersion behavior);
    public abstract virtual ITextBuffer get_TextBuffer();
    public abstract virtual int get_VersionNumber();
    public abstract virtual int get_ReiteratedVersionNumber();
}
public interface Microsoft.VisualStudio.Text.ITextVersion2 {
    public ITextImageVersion ImageVersion { get; }
    public abstract virtual ITextImageVersion get_ImageVersion();
}
public interface Microsoft.VisualStudio.Text.ITrackingPoint {
    public ITextBuffer TextBuffer { get; }
    public PointTrackingMode TrackingMode { get; }
    public TrackingFidelityMode TrackingFidelity { get; }
    public abstract virtual ITextBuffer get_TextBuffer();
    public abstract virtual PointTrackingMode get_TrackingMode();
    public abstract virtual TrackingFidelityMode get_TrackingFidelity();
    public abstract virtual SnapshotPoint GetPoint(ITextSnapshot snapshot);
    public abstract virtual int GetPosition(ITextSnapshot snapshot);
    public abstract virtual int GetPosition(ITextVersion version);
    public abstract virtual char GetCharacter(ITextSnapshot snapshot);
}
public interface Microsoft.VisualStudio.Text.ITrackingSpan {
    public ITextBuffer TextBuffer { get; }
    public SpanTrackingMode TrackingMode { get; }
    public TrackingFidelityMode TrackingFidelity { get; }
    public abstract virtual ITextBuffer get_TextBuffer();
    public abstract virtual SpanTrackingMode get_TrackingMode();
    public abstract virtual TrackingFidelityMode get_TrackingFidelity();
    public abstract virtual SnapshotSpan GetSpan(ITextSnapshot snapshot);
    public abstract virtual Span GetSpan(ITextVersion version);
    public abstract virtual string GetText(ITextSnapshot snapshot);
    public abstract virtual SnapshotPoint GetStartPoint(ITextSnapshot snapshot);
    public abstract virtual SnapshotPoint GetEndPoint(ITextSnapshot snapshot);
}
public interface Microsoft.VisualStudio.Text.ITypingEditTag {
}
public interface Microsoft.VisualStudio.Text.IUndoEditTag {
}
public interface Microsoft.VisualStudio.Text.IUserEditTag {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Text.LeadingWhitespaceState : object {
    internal int _tab;
    internal static int _maxSpaces;
    internal Int32[] _spaces;
    internal int _totalSpaceLines;
    internal int LinesBeginningWithTabs { get; }
    internal int LinesBeginningWithSpaces(int tabSize);
    internal int get_LinesBeginningWithTabs();
    public State GetDominantLineLeadingCharacter(int tabSize);
    public State GetLineLeadingCharacter(int tabSize);
    private int GetEffectiveSpaces(int tabSize);
    [ConditionalAttribute("DEBUG")]
internal void AssertEquals(LeadingWhitespaceState other);
    internal void IncrementTabs();
    internal void IncrementSpaces(int spaceCount, int delta);
    internal void Increment(ITextSnapshotLine line, int delta);
}
internal class Microsoft.VisualStudio.Text.NewlineState : object {
    internal int _cr;
    internal int _lf;
    internal int _crlf;
    internal int _nel;
    internal int _ls;
    internal int _ps;
    public bool HasConsistentLineEndings { get; }
    public Nullable`1<LineEnding> InferredLineEnding { get; }
    public bool get_HasConsistentLineEndings();
    public Nullable`1<LineEnding> get_InferredLineEnding();
    internal void Increment(LineEnding lineEnding, int count);
    internal void Increment(char linebreak, int count);
    internal void Increment(ITextSnapshotLine line, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Microsoft.VisualStudio.Text.NormalizedSnapshotSpanCollection : object {
    [NullableAttribute("2")]
private ITextSnapshot snapshot;
    [NullableAttribute("2")]
private NormalizedSpanCollection spans;
    private Span span;
    public static NormalizedSnapshotSpanCollection Empty;
    public SnapshotSpan Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<Microsoft.VisualStudio.Text.SnapshotSpan>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public NormalizedSnapshotSpanCollection(SnapshotSpan span);
    public NormalizedSnapshotSpanCollection(ITextSnapshot snapshot, NormalizedSpanCollection spans);
    public NormalizedSnapshotSpanCollection(ITextSnapshot snapshot, IEnumerable`1<Span> spans);
    public NormalizedSnapshotSpanCollection(ITextSnapshot snapshot, IList`1<Span> spans);
    private NormalizedSnapshotSpanCollection(ITextSnapshot snapshot, IList`1<Span> spans, bool skipCopy);
    public NormalizedSnapshotSpanCollection(IEnumerable`1<SnapshotSpan> snapshotSpans);
    public NormalizedSnapshotSpanCollection(IList`1<SnapshotSpan> snapshotSpans);
    public NormalizedSnapshotSpanCollection(ITextSnapshot snapshot, Span span);
    private static NormalizedSnapshotSpanCollection();
    [NullableContextAttribute("2")]
private static void InitializeHelper(NormalizedSpanCollection& spans, Span& span, NormalizedSpanCollection normalized, ITextSnapshot snapshot);
    internal static NormalizedSnapshotSpanCollection Create(IList`1<SnapshotSpan> spans);
    public NormalizedSnapshotSpanCollection CloneAndTrackTo(ITextSnapshot targetSnapshot, SpanTrackingMode mode);
    public static NormalizedSpanCollection op_Implicit(NormalizedSnapshotSpanCollection spans);
    public static NormalizedSnapshotSpanCollection Union(NormalizedSnapshotSpanCollection left, NormalizedSnapshotSpanCollection right);
    public static NormalizedSnapshotSpanCollection Overlap(NormalizedSnapshotSpanCollection left, NormalizedSnapshotSpanCollection right);
    public static NormalizedSnapshotSpanCollection Intersection(NormalizedSnapshotSpanCollection left, NormalizedSnapshotSpanCollection right);
    public static NormalizedSnapshotSpanCollection Difference(NormalizedSnapshotSpanCollection left, NormalizedSnapshotSpanCollection right);
    public bool OverlapsWith(NormalizedSnapshotSpanCollection set);
    public bool OverlapsWith(SnapshotSpan span);
    public bool IntersectsWith(NormalizedSnapshotSpanCollection set);
    public bool IntersectsWith(SnapshotSpan span);
    public sealed virtual int IndexOf(SnapshotSpan item);
    private sealed virtual override void System.Collections.Generic.IList<Microsoft.VisualStudio.Text.SnapshotSpan>.Insert(int index, SnapshotSpan item);
    private sealed virtual override void System.Collections.Generic.IList<Microsoft.VisualStudio.Text.SnapshotSpan>.RemoveAt(int index);
    public sealed virtual SnapshotSpan get_Item(int index);
    public sealed virtual void set_Item(int index, SnapshotSpan value);
    private sealed virtual override void System.Collections.Generic.ICollection<Microsoft.VisualStudio.Text.SnapshotSpan>.Add(SnapshotSpan item);
    private sealed virtual override void System.Collections.Generic.ICollection<Microsoft.VisualStudio.Text.SnapshotSpan>.Clear();
    public sealed virtual bool Contains(SnapshotSpan item);
    public sealed virtual void CopyTo(SnapshotSpan[] array, int arrayIndex);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.VisualStudio.Text.SnapshotSpan>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.VisualStudio.Text.SnapshotSpan>.Remove(SnapshotSpan item);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Text.NormalizedSnapshotSpanCollection/<GetEnumerator>d__40")]
public sealed virtual IEnumerator`1<SnapshotSpan> GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Text.NormalizedSnapshotSpanCollection/<System-Collections-IEnumerable-GetEnumerator>d__41")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [NullableContextAttribute("2")]
public static bool op_Equality(NormalizedSnapshotSpanCollection left, NormalizedSnapshotSpanCollection right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(NormalizedSnapshotSpanCollection left, NormalizedSnapshotSpanCollection right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Text.NormalizedSpanCollection : ReadOnlyCollection`1<Span> {
    public static NormalizedSpanCollection Empty;
    public NormalizedSpanCollection(Span span);
    public NormalizedSpanCollection(IEnumerable`1<Span> spans);
    public NormalizedSpanCollection(IList`1<Span> spans);
    private NormalizedSpanCollection(IList`1<Span> normalizedSpans, bool ignored);
    private static NormalizedSpanCollection();
    internal static NormalizedSpanCollection CreateFromNormalizedSpans(IList`1<Span> alreadyNormalizedSpans);
    public static NormalizedSpanCollection Union(NormalizedSpanCollection left, NormalizedSpanCollection right);
    public static NormalizedSpanCollection Overlap(NormalizedSpanCollection left, NormalizedSpanCollection right);
    public static NormalizedSpanCollection Intersection(NormalizedSpanCollection left, NormalizedSpanCollection right);
    public static NormalizedSpanCollection Difference(NormalizedSpanCollection left, NormalizedSpanCollection right);
    [NullableContextAttribute("2")]
public static bool op_Equality(NormalizedSpanCollection left, NormalizedSpanCollection right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(NormalizedSpanCollection left, NormalizedSpanCollection right);
    public bool OverlapsWith(NormalizedSpanCollection set);
    public bool OverlapsWith(Span span);
    public bool IntersectsWith(NormalizedSpanCollection set);
    public bool IntersectsWith(Span span);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
    public Enumerator GetEnumerator();
    private static IList`1<Span> ListFromSpan(Span span);
    private static void UpdateSpanUnion(Span span, IList`1<Span> spans, Int32& start, Int32& end);
    private static IList`1<Span> NormalizeSpans(IList`1<Span> spans);
    private static IList`1<Span> NormalizeSpans(IEnumerable`1<Span> spans);
    internal static IList`1<Span> NormalizeSpansImpl(IEnumerable`1<Span> spans, bool skipCopy);
}
public enum Microsoft.VisualStudio.Text.PointTrackingMode : Enum {
    public int value__;
    public static PointTrackingMode Positive;
    public static PointTrackingMode Negative;
}
public enum Microsoft.VisualStudio.Text.PositionAffinity : Enum {
    public int value__;
    public static PositionAffinity Predecessor;
    public static PositionAffinity Successor;
}
public class Microsoft.VisualStudio.Text.PreContentChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ITextSnapshot <BeforeSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private INormalizedTextChangeCollection <Changes>k__BackingField;
    public ITextSnapshot BeforeSnapshot { get; private set; }
    public INormalizedTextChangeCollection Changes { get; private set; }
    public PreContentChangedEventArgs(ITextSnapshot beforeSnapshot, INormalizedTextChangeCollection changes);
    [CompilerGeneratedAttribute]
public ITextSnapshot get_BeforeSnapshot();
    [CompilerGeneratedAttribute]
private void set_BeforeSnapshot(ITextSnapshot value);
    [CompilerGeneratedAttribute]
public INormalizedTextChangeCollection get_Changes();
    [CompilerGeneratedAttribute]
private void set_Changes(INormalizedTextChangeCollection value);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Text.Projection.ElisionBufferOptions : Enum {
    public int value__;
    public static ElisionBufferOptions None;
    public static ElisionBufferOptions FillInMappingMode;
}
public class Microsoft.VisualStudio.Text.Projection.ElisionSourceSpansChangedEventArgs : TextContentChangedEventArgs {
    private NormalizedSpanCollection elidedSpans;
    private NormalizedSpanCollection expandedSpans;
    public NormalizedSpanCollection ElidedSpans { get; }
    public NormalizedSpanCollection ExpandedSpans { get; }
    public IProjectionSnapshot Before { get; }
    public IProjectionSnapshot After { get; }
    public ElisionSourceSpansChangedEventArgs(IProjectionSnapshot beforeSnapshot, IProjectionSnapshot afterSnapshot, NormalizedSpanCollection elidedSpans, NormalizedSpanCollection expandedSpans, object sourceToken);
    public NormalizedSpanCollection get_ElidedSpans();
    public NormalizedSpanCollection get_ExpandedSpans();
    public IProjectionSnapshot get_Before();
    public IProjectionSnapshot get_After();
}
public class Microsoft.VisualStudio.Text.Projection.GraphBufferContentTypeChangedEventArgs : EventArgs {
    private ITextBuffer textBuffer;
    private IContentType beforeContentType;
    private IContentType afterContentType;
    public ITextBuffer TextBuffer { get; }
    public IContentType BeforeContentType { get; }
    public IContentType AfterContentType { get; }
    public GraphBufferContentTypeChangedEventArgs(ITextBuffer textBuffer, IContentType beforeContentType, IContentType afterContentType);
    public ITextBuffer get_TextBuffer();
    public IContentType get_BeforeContentType();
    public IContentType get_AfterContentType();
}
public class Microsoft.VisualStudio.Text.Projection.GraphBuffersChangedEventArgs : EventArgs {
    private ReadOnlyCollection`1<ITextBuffer> addedBuffers;
    private ReadOnlyCollection`1<ITextBuffer> removedBuffers;
    public ReadOnlyCollection`1<ITextBuffer> AddedBuffers { get; }
    public ReadOnlyCollection`1<ITextBuffer> RemovedBuffers { get; }
    public GraphBuffersChangedEventArgs(IList`1<ITextBuffer> addedBuffers, IList`1<ITextBuffer> removedBuffers);
    public ReadOnlyCollection`1<ITextBuffer> get_AddedBuffers();
    public ReadOnlyCollection`1<ITextBuffer> get_RemovedBuffers();
}
public interface Microsoft.VisualStudio.Text.Projection.IBufferGraph {
    public ITextBuffer TopBuffer { get; }
    public abstract virtual ITextBuffer get_TopBuffer();
    public abstract virtual Collection`1<ITextBuffer> GetTextBuffers(Predicate`1<ITextBuffer> match);
    public abstract virtual IMappingPoint CreateMappingPoint(SnapshotPoint point, PointTrackingMode trackingMode);
    public abstract virtual IMappingSpan CreateMappingSpan(SnapshotSpan span, SpanTrackingMode trackingMode);
    public abstract virtual Nullable`1<SnapshotPoint> MapDownToBuffer(SnapshotPoint position, PointTrackingMode trackingMode, ITextBuffer targetBuffer, PositionAffinity affinity);
    public abstract virtual Nullable`1<SnapshotPoint> MapDownToSnapshot(SnapshotPoint position, PointTrackingMode trackingMode, ITextSnapshot targetSnapshot, PositionAffinity affinity);
    public abstract virtual Nullable`1<SnapshotPoint> MapDownToFirstMatch(SnapshotPoint position, PointTrackingMode trackingMode, Predicate`1<ITextSnapshot> match, PositionAffinity affinity);
    public abstract virtual Nullable`1<SnapshotPoint> MapDownToInsertionPoint(SnapshotPoint position, PointTrackingMode trackingMode, Predicate`1<ITextSnapshot> match);
    public abstract virtual NormalizedSnapshotSpanCollection MapDownToBuffer(SnapshotSpan span, SpanTrackingMode trackingMode, ITextBuffer targetBuffer);
    public abstract virtual NormalizedSnapshotSpanCollection MapDownToSnapshot(SnapshotSpan span, SpanTrackingMode trackingMode, ITextSnapshot targetSnapshot);
    public abstract virtual NormalizedSnapshotSpanCollection MapDownToFirstMatch(SnapshotSpan span, SpanTrackingMode trackingMode, Predicate`1<ITextSnapshot> match);
    public abstract virtual Nullable`1<SnapshotPoint> MapUpToBuffer(SnapshotPoint point, PointTrackingMode trackingMode, PositionAffinity affinity, ITextBuffer targetBuffer);
    public abstract virtual Nullable`1<SnapshotPoint> MapUpToSnapshot(SnapshotPoint point, PointTrackingMode trackingMode, PositionAffinity affinity, ITextSnapshot targetSnapshot);
    public abstract virtual Nullable`1<SnapshotPoint> MapUpToFirstMatch(SnapshotPoint point, PointTrackingMode trackingMode, Predicate`1<ITextSnapshot> match, PositionAffinity affinity);
    public abstract virtual NormalizedSnapshotSpanCollection MapUpToBuffer(SnapshotSpan span, SpanTrackingMode trackingMode, ITextBuffer targetBuffer);
    public abstract virtual NormalizedSnapshotSpanCollection MapUpToSnapshot(SnapshotSpan span, SpanTrackingMode trackingMode, ITextSnapshot targetSnapshot);
    public abstract virtual NormalizedSnapshotSpanCollection MapUpToFirstMatch(SnapshotSpan span, SpanTrackingMode trackingMode, Predicate`1<ITextSnapshot> match);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GraphBuffersChanged(EventHandler`1<GraphBuffersChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GraphBuffersChanged(EventHandler`1<GraphBuffersChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GraphBufferContentTypeChanged(EventHandler`1<GraphBufferContentTypeChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GraphBufferContentTypeChanged(EventHandler`1<GraphBufferContentTypeChangedEventArgs> value);
}
public interface Microsoft.VisualStudio.Text.Projection.IBufferGraphFactoryService {
    public abstract virtual IBufferGraph CreateBufferGraph(ITextBuffer textBuffer);
}
public interface Microsoft.VisualStudio.Text.Projection.IElisionBuffer {
    public ITextBuffer SourceBuffer { get; }
    public IElisionSnapshot CurrentSnapshot { get; }
    public ElisionBufferOptions Options { get; }
    public abstract virtual ITextBuffer get_SourceBuffer();
    public abstract virtual IElisionSnapshot get_CurrentSnapshot();
    public abstract virtual IProjectionSnapshot ElideSpans(NormalizedSpanCollection spansToElide);
    public abstract virtual IProjectionSnapshot ExpandSpans(NormalizedSpanCollection spansToExpand);
    public abstract virtual IProjectionSnapshot ModifySpans(NormalizedSpanCollection spansToElide, NormalizedSpanCollection spansToExpand);
    public abstract virtual ElisionBufferOptions get_Options();
    [CompilerGeneratedAttribute]
public abstract virtual void add_SourceSpansChanged(EventHandler`1<ElisionSourceSpansChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SourceSpansChanged(EventHandler`1<ElisionSourceSpansChangedEventArgs> value);
}
public interface Microsoft.VisualStudio.Text.Projection.IElisionSnapshot {
    public IElisionBuffer TextBuffer { get; }
    public ITextSnapshot SourceSnapshot { get; }
    public abstract virtual IElisionBuffer get_TextBuffer();
    public abstract virtual ITextSnapshot get_SourceSnapshot();
    public abstract virtual SnapshotPoint MapFromSourceSnapshotToNearest(SnapshotPoint point);
}
public interface Microsoft.VisualStudio.Text.Projection.IProjectionBuffer {
    public abstract virtual IProjectionSnapshot InsertSpan(int position, ITrackingSpan spanToInsert);
    public abstract virtual IProjectionSnapshot InsertSpan(int position, string literalSpanToInsert);
    public abstract virtual IProjectionSnapshot InsertSpans(int position, IList`1<object> spansToInsert);
    public abstract virtual IProjectionSnapshot DeleteSpans(int position, int spansToDelete);
    public abstract virtual IProjectionSnapshot ReplaceSpans(int position, int spansToReplace, IList`1<object> spansToInsert, EditOptions options, object editTag);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SourceSpansChanged(EventHandler`1<ProjectionSourceSpansChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SourceSpansChanged(EventHandler`1<ProjectionSourceSpansChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SourceBuffersChanged(EventHandler`1<ProjectionSourceBuffersChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SourceBuffersChanged(EventHandler`1<ProjectionSourceBuffersChangedEventArgs> value);
}
public interface Microsoft.VisualStudio.Text.Projection.IProjectionBufferBase {
    public IProjectionSnapshot CurrentSnapshot { get; }
    public IList`1<ITextBuffer> SourceBuffers { get; }
    public abstract virtual IProjectionSnapshot get_CurrentSnapshot();
    public abstract virtual IList`1<ITextBuffer> get_SourceBuffers();
    public abstract virtual IProjectionSnapshot Insert(int position, string text);
    public abstract virtual IProjectionSnapshot Delete(Span deleteSpan);
    public abstract virtual IProjectionSnapshot Replace(Span replaceSpan, string replaceWith);
}
public interface Microsoft.VisualStudio.Text.Projection.IProjectionBufferFactoryService {
    public IContentType ProjectionContentType { get; }
    public abstract virtual IContentType get_ProjectionContentType();
    public abstract virtual IProjectionBuffer CreateProjectionBuffer(IProjectionEditResolver projectionEditResolver, IList`1<object> sourceSpans, ProjectionBufferOptions options, IContentType contentType);
    public abstract virtual IProjectionBuffer CreateProjectionBuffer(IProjectionEditResolver projectionEditResolver, IList`1<object> sourceSpans, ProjectionBufferOptions options);
    public abstract virtual IElisionBuffer CreateElisionBuffer(IProjectionEditResolver projectionEditResolver, NormalizedSnapshotSpanCollection exposedSpans, ElisionBufferOptions options, IContentType contentType);
    public abstract virtual IElisionBuffer CreateElisionBuffer(IProjectionEditResolver projectionEditResolver, NormalizedSnapshotSpanCollection exposedSpans, ElisionBufferOptions options);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectionBufferCreated(EventHandler`1<TextBufferCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectionBufferCreated(EventHandler`1<TextBufferCreatedEventArgs> value);
}
public interface Microsoft.VisualStudio.Text.Projection.IProjectionEditResolver {
    public abstract virtual void FillInInsertionSizes(SnapshotPoint projectionInsertionPoint, ReadOnlyCollection`1<SnapshotPoint> sourceInsertionPoints, string insertionText, IList`1<int> insertionSizes);
    public abstract virtual void FillInReplacementSizes(SnapshotSpan projectionReplacementSpan, ReadOnlyCollection`1<SnapshotSpan> sourceReplacementSpans, string insertionText, IList`1<int> insertionSizes);
    public abstract virtual int GetTypicalInsertionPosition(SnapshotPoint projectionInsertionPoint, ReadOnlyCollection`1<SnapshotPoint> sourceInsertionPoints);
}
public interface Microsoft.VisualStudio.Text.Projection.IProjectionSnapshot {
    public IProjectionBufferBase TextBuffer { get; }
    public int SpanCount { get; }
    public ReadOnlyCollection`1<ITextSnapshot> SourceSnapshots { get; }
    public abstract virtual IProjectionBufferBase get_TextBuffer();
    public abstract virtual int get_SpanCount();
    public abstract virtual ReadOnlyCollection`1<ITextSnapshot> get_SourceSnapshots();
    public abstract virtual ITextSnapshot GetMatchingSnapshot(ITextBuffer textBuffer);
    public abstract virtual ReadOnlyCollection`1<SnapshotSpan> GetSourceSpans(int startSpanIndex, int count);
    public abstract virtual ReadOnlyCollection`1<SnapshotSpan> GetSourceSpans();
    public abstract virtual SnapshotPoint MapToSourceSnapshot(int position, PositionAffinity affinity);
    public abstract virtual ReadOnlyCollection`1<SnapshotPoint> MapToSourceSnapshots(int position);
    public abstract virtual SnapshotPoint MapToSourceSnapshot(int position);
    public abstract virtual Nullable`1<SnapshotPoint> MapFromSourceSnapshot(SnapshotPoint point, PositionAffinity affinity);
    public abstract virtual ReadOnlyCollection`1<SnapshotSpan> MapToSourceSnapshots(Span span);
    public abstract virtual ReadOnlyCollection`1<Span> MapFromSourceSnapshot(SnapshotSpan span);
}
public interface Microsoft.VisualStudio.Text.Projection.IProjectionSnapshot2 {
    public abstract virtual ITextSnapshot GetMatchingSnapshotInClosure(ITextBuffer targetBuffer);
    public abstract virtual ITextSnapshot GetMatchingSnapshotInClosure(Predicate`1<ITextBuffer> match);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Text.Projection.ProjectionBufferOptions : Enum {
    public int value__;
    public static ProjectionBufferOptions None;
    public static ProjectionBufferOptions PermissiveEdgeInclusiveSourceSpans;
    public static ProjectionBufferOptions WritableLiteralSpans;
}
public class Microsoft.VisualStudio.Text.Projection.ProjectionSourceBuffersChangedEventArgs : ProjectionSourceSpansChangedEventArgs {
    private IList`1<ITextBuffer> addedBuffers;
    private IList`1<ITextBuffer> removedBuffers;
    public ReadOnlyCollection`1<ITextBuffer> AddedBuffers { get; }
    public ReadOnlyCollection`1<ITextBuffer> RemovedBuffers { get; }
    public ProjectionSourceBuffersChangedEventArgs(IProjectionSnapshot beforeSnapshot, IProjectionSnapshot afterSnapshot, IList`1<ITrackingSpan> insertedSpans, IList`1<ITrackingSpan> deletedSpans, int spanPosition, IList`1<ITextBuffer> addedBuffers, IList`1<ITextBuffer> removedBuffers, EditOptions options, object editTag);
    public ReadOnlyCollection`1<ITextBuffer> get_AddedBuffers();
    public ReadOnlyCollection`1<ITextBuffer> get_RemovedBuffers();
}
public class Microsoft.VisualStudio.Text.Projection.ProjectionSourceSpansChangedEventArgs : TextContentChangedEventArgs {
    private ReadOnlyCollection`1<ITrackingSpan> insertedSpans;
    private ReadOnlyCollection`1<ITrackingSpan> deletedSpans;
    private int spanPosition;
    public int SpanPosition { get; }
    public ReadOnlyCollection`1<ITrackingSpan> InsertedSpans { get; }
    public ReadOnlyCollection`1<ITrackingSpan> DeletedSpans { get; }
    public IProjectionSnapshot Before { get; }
    public IProjectionSnapshot After { get; }
    public ProjectionSourceSpansChangedEventArgs(IProjectionSnapshot beforeSnapshot, IProjectionSnapshot afterSnapshot, IList`1<ITrackingSpan> insertedSpans, IList`1<ITrackingSpan> deletedSpans, int spanPosition, EditOptions options, object editTag);
    public int get_SpanPosition();
    public ReadOnlyCollection`1<ITrackingSpan> get_InsertedSpans();
    public ReadOnlyCollection`1<ITrackingSpan> get_DeletedSpans();
    public IProjectionSnapshot get_Before();
    public IProjectionSnapshot get_After();
}
public enum Microsoft.VisualStudio.Text.ReloadResult : Enum {
    public int value__;
    public static ReloadResult Aborted;
    public static ReloadResult Succeeded;
    public static ReloadResult SucceededWithCharacterSubstitutions;
}
public class Microsoft.VisualStudio.Text.SnapshotPoint : ValueType {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private ITextSnapshot <Snapshot>k__BackingField;
    public int Position { get; }
    public ITextSnapshot Snapshot { get; }
    public SnapshotPoint(ITextSnapshot snapshot, int position);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Position();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ITextSnapshot get_Snapshot();
    public static int op_Implicit(SnapshotPoint snapshotPoint);
    public ITextSnapshotLine GetContainingLine();
    internal TextSnapshotLineData GetContainingLineData();
    public int GetContainingLineNumber();
    public char GetChar();
    public SnapshotPoint TranslateTo(ITextSnapshot targetSnapshot, PointTrackingMode trackingMode);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public SnapshotPoint Add(int offset);
    public SnapshotPoint Subtract(int offset);
    public int Difference(SnapshotPoint other);
    public static SnapshotPoint op_Subtraction(SnapshotPoint point, int offset);
    public static int op_Subtraction(SnapshotPoint start, SnapshotPoint other);
    public static bool op_Equality(SnapshotPoint left, SnapshotPoint right);
    public static bool op_Inequality(SnapshotPoint left, SnapshotPoint right);
    public static SnapshotPoint op_Addition(SnapshotPoint point, int offset);
    public static bool op_GreaterThan(SnapshotPoint left, SnapshotPoint right);
    public static bool op_LessThan(SnapshotPoint left, SnapshotPoint right);
    public sealed virtual int CompareTo(SnapshotPoint other);
}
public class Microsoft.VisualStudio.Text.SnapshotPointEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SnapshotPoint <Point>k__BackingField;
    public SnapshotPoint Point { get; }
    public SnapshotPointEventArgs(SnapshotPoint point);
    [CompilerGeneratedAttribute]
public SnapshotPoint get_Point();
}
public class Microsoft.VisualStudio.Text.SnapshotSpan : ValueType {
    private SnapshotPoint start;
    private int length;
    public ITextSnapshot Snapshot { get; }
    public Span Span { get; }
    public SnapshotPoint Start { get; }
    public SnapshotPoint End { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public SnapshotSpan(ITextSnapshot snapshot, Span span);
    public SnapshotSpan(ITextSnapshot snapshot, int start, int length);
    public SnapshotSpan(SnapshotPoint start, SnapshotPoint end);
    public SnapshotSpan(SnapshotPoint start, int length);
    public static Span op_Implicit(SnapshotSpan snapshotSpan);
    public ITextSnapshot get_Snapshot();
    public string GetText();
    public SnapshotSpan TranslateTo(ITextSnapshot targetSnapshot, SpanTrackingMode spanTrackingMode);
    public Span get_Span();
    public SnapshotPoint get_Start();
    public SnapshotPoint get_End();
    public int get_Length();
    public bool get_IsEmpty();
    public bool Contains(int position);
    public bool Contains(SnapshotPoint point);
    public bool Contains(Span simpleSpan);
    public bool Contains(SnapshotSpan snapshotSpan);
    public bool OverlapsWith(Span simpleSpan);
    public bool OverlapsWith(SnapshotSpan snapshotSpan);
    public Nullable`1<SnapshotSpan> Overlap(Span simpleSpan);
    public Nullable`1<SnapshotSpan> Overlap(SnapshotSpan snapshotSpan);
    public bool IntersectsWith(Span simpleSpan);
    public bool IntersectsWith(SnapshotSpan snapshotSpan);
    public Nullable`1<SnapshotSpan> Intersection(Span simpleSpan);
    public Nullable`1<SnapshotSpan> Intersection(SnapshotSpan snapshotSpan);
    internal SnapshotSpan Slice(int start, int length);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool op_Equality(SnapshotSpan left, SnapshotSpan right);
    public static bool op_Inequality(SnapshotSpan left, SnapshotSpan right);
    private void EnsureSnapshot(ITextSnapshot requestedSnapshot);
}
public class Microsoft.VisualStudio.Text.SnapshotSpanEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SnapshotSpan <Span>k__BackingField;
    public SnapshotSpan Span { get; private set; }
    public SnapshotSpanEventArgs(SnapshotSpan span);
    [CompilerGeneratedAttribute]
public SnapshotSpan get_Span();
    [CompilerGeneratedAttribute]
private void set_Span(SnapshotSpan value);
}
public class Microsoft.VisualStudio.Text.Span : ValueType {
    private int start;
    private int length;
    public int Start { get; }
    public int End { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public Span(int start, int length);
    public static Span FromBounds(int start, int end);
    public int get_Start();
    public int get_End();
    public int get_Length();
    public bool get_IsEmpty();
    public bool Contains(int position);
    public bool Contains(Span span);
    public bool OverlapsWith(Span span);
    public Nullable`1<Span> Overlap(Span span);
    public bool IntersectsWith(Span span);
    public Nullable`1<Span> Intersection(Span span);
    internal Span Slice(int start, int length);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(Span left, Span right);
    public static bool op_Inequality(Span left, Span right);
}
public enum Microsoft.VisualStudio.Text.SpanTrackingMode : Enum {
    public int value__;
    public static SpanTrackingMode EdgeExclusive;
    public static SpanTrackingMode EdgeInclusive;
    public static SpanTrackingMode EdgePositive;
    public static SpanTrackingMode EdgeNegative;
    public static SpanTrackingMode Custom;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.Text.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArrayRankNotOne { get; }
    internal static string CircularityInBufferVersion { get; }
    internal static string InvalidSnapshot { get; }
    internal static string InvalidSnapshotPoint { get; }
    internal static string InvalidSnapshotSpan { get; }
    internal static string MismatchedSnapshotPoints { get; }
    internal static string MismatchedSnapshots { get; }
    internal static string MismatchedVersions { get; }
    internal static string SpansBeyondEnd { get; }
    internal static string UninitializedSnapshotPoint { get; }
    internal static string UninitializedSnapshotSpan { get; }
    internal static string VersionDoesNotBelongToBuffer { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArrayRankNotOne();
    internal static string get_CircularityInBufferVersion();
    internal static string get_InvalidSnapshot();
    internal static string get_InvalidSnapshotPoint();
    internal static string get_InvalidSnapshotSpan();
    internal static string get_MismatchedSnapshotPoints();
    internal static string get_MismatchedSnapshots();
    internal static string get_MismatchedVersions();
    internal static string get_SpansBeyondEnd();
    internal static string get_UninitializedSnapshotPoint();
    internal static string get_UninitializedSnapshotSpan();
    internal static string get_VersionDoesNotBelongToBuffer();
}
public class Microsoft.VisualStudio.Text.TextBufferCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ITextBuffer <TextBuffer>k__BackingField;
    public ITextBuffer TextBuffer { get; private set; }
    public TextBufferCreatedEventArgs(ITextBuffer textBuffer);
    [CompilerGeneratedAttribute]
public ITextBuffer get_TextBuffer();
    [CompilerGeneratedAttribute]
private void set_TextBuffer(ITextBuffer value);
}
public class Microsoft.VisualStudio.Text.TextContentChangedEventArgs : TextSnapshotChangedEventArgs {
    private EditOptions options;
    public INormalizedTextChangeCollection Changes { get; }
    public EditOptions Options { get; }
    public TextContentChangedEventArgs(ITextSnapshot beforeSnapshot, ITextSnapshot afterSnapshot, EditOptions options, object editTag);
    public INormalizedTextChangeCollection get_Changes();
    public EditOptions get_Options();
}
public class Microsoft.VisualStudio.Text.TextContentChangingEventArgs : EventArgs {
    private Action`1<TextContentChangingEventArgs> cancelAction;
    [CompilerGeneratedAttribute]
private bool <Canceled>k__BackingField;
    [CompilerGeneratedAttribute]
private ITextSnapshot <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private object <EditTag>k__BackingField;
    public bool Canceled { get; private set; }
    public ITextSnapshot Before { get; private set; }
    public object EditTag { get; private set; }
    public ITextVersion BeforeVersion { get; }
    public TextContentChangingEventArgs(ITextSnapshot beforeSnapshot, object editTag, Action`1<TextContentChangingEventArgs> cancelAction);
    [CompilerGeneratedAttribute]
public bool get_Canceled();
    [CompilerGeneratedAttribute]
private void set_Canceled(bool value);
    [CompilerGeneratedAttribute]
public ITextSnapshot get_Before();
    [CompilerGeneratedAttribute]
private void set_Before(ITextSnapshot value);
    [CompilerGeneratedAttribute]
public object get_EditTag();
    [CompilerGeneratedAttribute]
private void set_EditTag(object value);
    public void Cancel();
    public ITextVersion get_BeforeVersion();
}
public class Microsoft.VisualStudio.Text.TextDocumentEventArgs : EventArgs {
    private ITextDocument _textDocument;
    public ITextDocument TextDocument { get; }
    public TextDocumentEventArgs(ITextDocument textDocument);
    public ITextDocument get_TextDocument();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Text.TextDocumentFileActionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <OldFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private FileActionTypes <FileActionType>k__BackingField;
    public string OldFilePath { get; }
    public string FilePath { get; }
    public DateTime Time { get; }
    public FileActionTypes FileActionType { get; }
    public TextDocumentFileActionEventArgs(string filePath, DateTime time, FileActionTypes fileActionType);
    public TextDocumentFileActionEventArgs(string oldFilePath, string newFilePath, DateTime time, FileActionTypes fileActionType);
    [CompilerGeneratedAttribute]
public string get_OldFilePath();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public DateTime get_Time();
    [CompilerGeneratedAttribute]
public FileActionTypes get_FileActionType();
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Text.TextImageExtensions : object {
    [ExtensionAttribute]
public static string GetText(ITextImage image, int startIndex, int length);
    [ExtensionAttribute]
public static string GetText(ITextImage image);
    [ExtensionAttribute]
public static ITextImage GetSubText(ITextImage image, int startIndex, int length);
    [ExtensionAttribute]
public static void Write(ITextImage image, TextWriter writer);
    [ExtensionAttribute]
internal static Task WriteAsync(ITextImage2 image, TextWriter writer, CancellationToken token);
}
public class Microsoft.VisualStudio.Text.TextImageLine : ValueType {
    public static TextImageLine Invalid;
    public ITextImage Image;
    public Span Extent;
    public int LineNumber;
    public int LineBreakLength;
    public Span ExtentIncludingLineBreak { get; }
    public int Start { get; }
    public int Length { get; }
    public int LengthIncludingLineBreak { get; }
    public int End { get; }
    public int EndIncludingLineBreak { get; }
    public TextImageLine(ITextImage image, int lineNumber, Span extent, int lineBreakLength);
    public Span get_ExtentIncludingLineBreak();
    public int get_Start();
    public int get_Length();
    public int get_LengthIncludingLineBreak();
    public int get_End();
    public int get_EndIncludingLineBreak();
    public string GetText();
    public string GetTextIncludingLineBreak();
    public string GetLineBreakText();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TextImageLine other);
    public static bool op_Equality(TextImageLine left, TextImageLine right);
    public static bool op_Inequality(TextImageLine left, TextImageLine right);
    public virtual string ToString();
}
public abstract class Microsoft.VisualStudio.Text.TextSnapshotChangedEventArgs : EventArgs {
    private ITextSnapshot before;
    private ITextSnapshot after;
    private object editTag;
    public ITextSnapshot Before { get; }
    public ITextSnapshot After { get; }
    public ITextVersion BeforeVersion { get; }
    public ITextVersion AfterVersion { get; }
    public object EditTag { get; }
    protected TextSnapshotChangedEventArgs(ITextSnapshot beforeSnapshot, ITextSnapshot afterSnapshot, object editTag);
    public ITextSnapshot get_Before();
    public ITextSnapshot get_After();
    public ITextVersion get_BeforeVersion();
    public ITextVersion get_AfterVersion();
    public object get_EditTag();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Text.TextSnapshotExtensions : object {
    [ExtensionAttribute]
public static SnapshotSpan GetEntireSpan(ITextSnapshot textSnapshot);
    [ExtensionAttribute]
public static Nullable`1<SnapshotPoint> TryGetSnapshotPoint(ITextSnapshot snapshot, int lineNumber, int columnIndex);
    [ExtensionAttribute]
public static bool TryGetSnapshotPoint(ITextSnapshot snapshot, int lineNumber, int columnIndex, SnapshotPoint& position);
    [ExtensionAttribute]
public static TextSnapshotLineData GetLineDataFromLineNumber(ITextSnapshot snapshot, int lineNumber);
    [ExtensionAttribute]
public static void GetLineAndColumn(SnapshotPoint point, Int32& lineNumber, Int32& columnIndex);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<int, int> GetLineAndColumn(SnapshotPoint point);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<int, int> GetLineAndColumn1Based(SnapshotPoint point);
    [ExtensionAttribute]
public static bool AnyChanges(ITextVersion oldVersion, ITextVersion newVersion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.VisualStudio.Text.TextSnapshotLineData : ValueType {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private SnapshotSpan <Extent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineBreakLength>k__BackingField;
    public int LineNumber { get; }
    public SnapshotSpan Extent { get; }
    public int LineBreakLength { get; }
    public ITextSnapshot Snapshot { get; }
    public SnapshotPoint Start { get; }
    public SnapshotPoint End { get; }
    public SnapshotPoint EndIncludingLineBreak { get; }
    public int Length { get; }
    public int LengthIncludingLineBreak { get; }
    public SnapshotSpan ExtentIncludingLineBreak { get; }
    public TextSnapshotLineData NextLine { get; }
    public TextSnapshotLineData PreviousLine { get; }
    public TextSnapshotLineData(ITextSnapshot snapshot, int lineNumber, Span extent, int lineBreakLength);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public SnapshotSpan get_Extent();
    [CompilerGeneratedAttribute]
public int get_LineBreakLength();
    public ITextSnapshot get_Snapshot();
    public SnapshotPoint get_Start();
    public SnapshotPoint get_End();
    public SnapshotPoint get_EndIncludingLineBreak();
    public int get_Length();
    public int get_LengthIncludingLineBreak();
    public SnapshotSpan get_ExtentIncludingLineBreak();
    public TextSnapshotLineData get_NextLine();
    public TextSnapshotLineData get_PreviousLine();
}
public class Microsoft.VisualStudio.Text.TextSnapshotToTextReader : TextReader {
    private ITextSnapshot _snapshot;
    private int _currentPosition;
    public TextSnapshotToTextReader(ITextSnapshot textSnapshot);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual string ReadLine();
    public virtual string ReadToEnd();
}
public static class Microsoft.VisualStudio.Text.Tracking : object {
    public static int TrackPositionForwardInTime(PointTrackingMode trackingMode, int currentPosition, ITextVersion currentVersion, ITextVersion targetVersion);
    public static int TrackPositionForwardInTime(PointTrackingMode trackingMode, int currentPosition, ITextImageVersion currentVersion, ITextImageVersion targetVersion);
    public static int TrackPositionForwardInTime(PointTrackingMode trackingMode, int currentPosition, INormalizedTextChangeCollection textChanges);
    private static bool ShouldOffsetEndpointOfChange(ITextChange textChange, int offset, bool isForwardTracking);
    public static int TrackPositionBackwardInTime(PointTrackingMode trackingMode, int currentPosition, ITextVersion currentVersion, ITextVersion targetVersion);
    public static int TrackPositionBackwardInTime(PointTrackingMode trackingMode, int currentPosition, ITextImageVersion currentVersion, ITextImageVersion targetVersion);
    public static int TrackPositionBackwardInTime(PointTrackingMode trackingMode, int currentPosition, INormalizedTextChangeCollection textChanges);
    public static Span TrackSpanForwardInTime(SpanTrackingMode trackingMode, Span span, ITextVersion currentVersion, ITextVersion targetVersion);
    public static Span TrackSpanForwardInTime(SpanTrackingMode trackingMode, Span span, ITextImageVersion currentVersion, ITextImageVersion targetVersion);
    public static Span TrackSpanBackwardInTime(SpanTrackingMode trackingMode, Span span, ITextVersion currentVersion, ITextVersion targetVersion);
    public static Span TrackSpanBackwardInTime(SpanTrackingMode trackingMode, Span span, ITextImageVersion currentVersion, ITextImageVersion targetVersion);
    private static bool IsOpaque(ITextChange textChange);
}
public enum Microsoft.VisualStudio.Text.TrackingFidelityMode : Enum {
    public int value__;
    public static TrackingFidelityMode Forward;
    public static TrackingFidelityMode Backward;
    public static TrackingFidelityMode UndoRedo;
}
internal enum Microsoft.VisualStudio.Text.TrackingFidelityModeInternal : Enum {
    public int value__;
    public static TrackingFidelityModeInternal Forward;
    public static TrackingFidelityModeInternal Backward;
    public static TrackingFidelityModeInternal UndoRedo;
    public static TrackingFidelityModeInternal ForwardOptimizedForReiteratedSnapshots;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.Text.Utilities.LineBuffer : ValueType {
    private ITextSnapshotLine line;
    public char Item { get; }
    public LineBuffer(ITextSnapshotLine line);
    public char get_Item(int index);
}
internal class Microsoft.VisualStudio.Text.Utilities.TrackingSpanNode`1 : object {
    [CompilerGeneratedAttribute]
private T <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private ITrackingSpan <TrackingSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TrackingSpanNode`1<T>> <Children>k__BackingField;
    public T Item { get; private set; }
    public ITrackingSpan TrackingSpan { get; private set; }
    public List`1<TrackingSpanNode`1<T>> Children { get; private set; }
    public TrackingSpanNode`1(T item, ITrackingSpan trackingSpan);
    public TrackingSpanNode`1(T item, ITrackingSpan trackingSpan, List`1<TrackingSpanNode`1<T>> children);
    [CompilerGeneratedAttribute]
public T get_Item();
    [CompilerGeneratedAttribute]
private void set_Item(T value);
    [CompilerGeneratedAttribute]
public ITrackingSpan get_TrackingSpan();
    [CompilerGeneratedAttribute]
private void set_TrackingSpan(ITrackingSpan value);
    [CompilerGeneratedAttribute]
public List`1<TrackingSpanNode`1<T>> get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(List`1<TrackingSpanNode`1<T>> value);
    internal void Advance(ITextVersion toVersion);
}
internal class Microsoft.VisualStudio.Text.Utilities.TrackingSpanTree`1 : object {
    [CompilerGeneratedAttribute]
private TrackingSpanNode`1<T> <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private ITextBuffer <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    private int advanceVersion;
    public TrackingSpanNode`1<T> Root { get; private set; }
    public ITextBuffer Buffer { get; private set; }
    public int Count { get; private set; }
    public TrackingSpanTree`1(ITextBuffer buffer, bool keepTrackingCurrent);
    [CompilerGeneratedAttribute]
public TrackingSpanNode`1<T> get_Root();
    [CompilerGeneratedAttribute]
private void set_Root(TrackingSpanNode`1<T> value);
    [CompilerGeneratedAttribute]
public ITextBuffer get_Buffer();
    [CompilerGeneratedAttribute]
private void set_Buffer(ITextBuffer value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public TrackingSpanNode`1<T> TryAddItem(T item, ITrackingSpan trackingSpan);
    public bool RemoveItem(T item, ITrackingSpan trackingSpan);
    public void Clear();
    public IEnumerable`1<TrackingSpanNode`1<T>> FindNodesIntersecting(SnapshotSpan span);
    public IEnumerable`1<TrackingSpanNode`1<T>> FindNodesIntersecting(NormalizedSnapshotSpanCollection spans);
    public IEnumerable`1<TrackingSpanNode`1<T>> FindTopLevelNodesIntersecting(SnapshotSpan span);
    public IEnumerable`1<TrackingSpanNode`1<T>> FindTopLevelNodesIntersecting(NormalizedSnapshotSpanCollection spans);
    public IEnumerable`1<TrackingSpanNode`1<T>> FindNodesContainedBy(SnapshotSpan span);
    public IEnumerable`1<TrackingSpanNode`1<T>> FindNodesContainedBy(NormalizedSnapshotSpanCollection spans);
    public IEnumerable`1<TrackingSpanNode`1<T>> FindTopLevelNodesContainedBy(SnapshotSpan span);
    public IEnumerable`1<TrackingSpanNode`1<T>> FindTopLevelNodesContainedBy(NormalizedSnapshotSpanCollection spans);
    public bool IsPointContainedInANode(SnapshotPoint point);
    public bool IsNodeTopLevel(TrackingSpanNode`1<T> node);
    public void Advance(ITextVersion toVersion);
    private void OnBufferChanged(object sender, TextContentChangedEventArgs args);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Text.Utilities.TrackingSpanTree`1/<FindNodes>d__29")]
private static IEnumerable`1<TrackingSpanNode`1<T>> FindNodes(NormalizedSnapshotSpanCollection spans, TrackingSpanNode`1<T> root, bool recurse, bool contained);
    private static int FindNextChild(TrackingSpanNode`1<T> root, SnapshotPoint point, int currentChildIndex);
    private static bool RemoveItemFromRoot(T item, SnapshotSpan span, TrackingSpanNode`1<T> root);
    private static TrackingSpanNode`1<T> TryAddNodeToRoot(TrackingSpanNode`1<T> newNode, SnapshotSpan span, TrackingSpanNode`1<T> root);
    private static FindResult<T> FindChild(SnapshotPoint point, List`1<TrackingSpanNode`1<T>> nodes, bool left, int lo, int hi);
    private static FindResult<T> FindIndexForAdd(SnapshotPoint point, List`1<TrackingSpanNode`1<T>> nodes, bool left, int lo, int hi);
}
internal static class Microsoft.VisualStudio.Text.Utilities.UnicodeWordExtent : object {
    public static char UCH_LF;
    public static char UCH_CR;
    public static char UCH_LS;
    public static char UCH_PS;
    public static char UCH_NEL;
    public static char UCH_HANGUL_JAMO_FIRST;
    public static char UCH_HANGUL_JAMO_LEAD_FIRST;
    public static char UCH_HANGUL_JAMO_LEAD_LAST;
    public static char UCH_HANGUL_JAMO_VOWEL_FIRST;
    public static char UCH_HANGUL_JAMO_VOWEL_LAST;
    public static char UCH_HANGUL_JAMO_TRAIL_FIRST;
    public static char UCH_HANGUL_JAMO_TRAIL_LAST;
    public static char UCH_HANGUL_JAMO_LAST;
    public static bool FindCurrentToken(SnapshotPoint currentPosition, SnapshotSpan& span);
    public static bool FindCurrentWordCoords(SnapshotPoint currentPosition, SnapshotSpan& span);
    public static bool IsWordBreak(LineBuffer line, int iChar, bool fHanWordBreak);
    public static int PrevChar(LineBuffer line, int iChar);
    public static bool IsGraphemeBreak(LineBuffer line, int iChar);
    public static bool IsPropBreak(char cL, char cR, bool fHanWordBreak);
    public static bool IsWordChar(char ch);
    public static bool IsWholeWord(SnapshotSpan candidate, bool acceptHanWordBreak);
    public static bool IsNonBreaking(char ch);
    public static bool IsLineBreak(char ch);
    public static UnicodeScript UScript(char ch);
    public static bool IsKatakana(char ch);
    public static bool IsHiragana(char ch);
    public static bool IsIdeograph(char ch);
    public static bool IsMathSymbol(char ch);
    public static bool IsCombining(char ch);
    public static bool IsPropCombining(UnicodeCategory cat);
    public static bool IsPropAlpha(UnicodeCategory cat);
    public static bool IsPropDigit(UnicodeCategory cat);
    public static HangulJamoType GetHangulJamoType(char ch);
}
public class Microsoft.VisualStudio.Text.VersionedPosition : ValueType {
    public ITextImageVersion Version;
    public int Position;
    public static VersionedPosition Invalid;
    public VersionedPosition(ITextImageVersion version, int position);
    public static int op_Implicit(VersionedPosition position);
    public VersionedPosition TranslateTo(ITextImageVersion other, PointTrackingMode mode);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(VersionedPosition other);
    public static bool op_Equality(VersionedPosition left, VersionedPosition right);
    public static bool op_Inequality(VersionedPosition left, VersionedPosition right);
    public virtual string ToString();
}
public class Microsoft.VisualStudio.Text.VersionedSpan : ValueType {
    public ITextImageVersion Version;
    public Span Span;
    public static VersionedSpan Invalid;
    public VersionedSpan(ITextImageVersion version, Span span);
    public static Span op_Implicit(VersionedSpan span);
    public VersionedSpan TranslateTo(ITextImageVersion other, SpanTrackingMode mode);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(VersionedSpan other);
    public static bool op_Equality(VersionedSpan left, VersionedSpan right);
    public static bool op_Inequality(VersionedSpan left, VersionedSpan right);
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.5.107.25444")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
