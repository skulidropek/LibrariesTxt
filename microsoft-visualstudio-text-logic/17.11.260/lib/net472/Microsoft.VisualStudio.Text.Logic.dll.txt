[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public static class Microsoft.VisualStudio.Editor.CommonEditorConstants : object {
    public static string AssetName;
    public static string BraceHighlightingTagger;
    public static string ContentTypeName;
    public static string TextMateRepositoryKey;
    public static string TextMateLanguageConfigurationGrammarMappingKey;
    public static string TextMateLanguageConfigurationContentTypeMappingKey;
    public static string TextMateCommentUncommentCommandsContentTypeName;
    public static string TextMateIndentationContentTypeName;
    public static string TextMateBraceContentTypeName;
}
public interface Microsoft.VisualStudio.Editor.ICommonEditorAssetMetadata {
    [DefaultValueAttribute("")]
public IEnumerable`1<Type> TagTypes { get; }
    public abstract virtual IEnumerable`1<Type> get_TagTypes();
}
public interface Microsoft.VisualStudio.Editor.ICommonEditorAssetService {
    public abstract virtual T FindAsset(Predicate`1<ICommonEditorAssetMetadata> isMatch);
}
public interface Microsoft.VisualStudio.Editor.ICommonEditorAssetServiceFactory {
    public abstract virtual ICommonEditorAssetService GetOrCreate(ITextBuffer textBuffer);
}
public class Microsoft.VisualStudio.Text.Classification.ClassificationChangedEventArgs : EventArgs {
    private SnapshotSpan changeSpan;
    public SnapshotSpan ChangeSpan { get; }
    public ClassificationChangedEventArgs(SnapshotSpan changeSpan);
    public SnapshotSpan get_ChangeSpan();
}
public enum Microsoft.VisualStudio.Text.Classification.ClassificationLayer : Enum {
    public int value__;
    public static ClassificationLayer Default;
    public static ClassificationLayer Lexical;
    public static ClassificationLayer Syntactic;
    public static ClassificationLayer Semantic;
}
public class Microsoft.VisualStudio.Text.Classification.ClassificationSpan : object {
    private SnapshotSpan span;
    private IClassificationType classification;
    public IClassificationType ClassificationType { get; }
    public SnapshotSpan Span { get; }
    public ClassificationSpan(SnapshotSpan span, IClassificationType classification);
    public IClassificationType get_ClassificationType();
    public SnapshotSpan get_Span();
}
public class Microsoft.VisualStudio.Text.Classification.ClassificationTypeAttribute : MultipleBaseMetadataAttribute {
    private string _name;
    public string ClassificationTypeNames { get; public set; }
    public string get_ClassificationTypeNames();
    public void set_ClassificationTypeNames(string value);
}
public class Microsoft.VisualStudio.Text.Classification.ClassificationTypeDefinition : object {
}
public interface Microsoft.VisualStudio.Text.Classification.IAccurateClassifier {
    public abstract virtual IList`1<ClassificationSpan> GetAllClassificationSpans(SnapshotSpan span, CancellationToken cancel);
}
public interface Microsoft.VisualStudio.Text.Classification.IClassificationType {
    public string Classification { get; }
    public IEnumerable`1<IClassificationType> BaseTypes { get; }
    public abstract virtual string get_Classification();
    public abstract virtual bool IsOfType(string type);
    public abstract virtual IEnumerable`1<IClassificationType> get_BaseTypes();
}
public interface Microsoft.VisualStudio.Text.Classification.IClassificationTypeRegistryService {
    public abstract virtual IClassificationType GetClassificationType(string type);
    public abstract virtual IClassificationType CreateClassificationType(string type, IEnumerable`1<IClassificationType> baseTypes);
    public abstract virtual IClassificationType CreateTransientClassificationType(IEnumerable`1<IClassificationType> baseTypes);
    public abstract virtual IClassificationType CreateTransientClassificationType(IClassificationType[] baseTypes);
    public abstract virtual ILayeredClassificationType GetClassificationType(ClassificationLayer layer, string type);
    public abstract virtual ILayeredClassificationType CreateClassificationType(ClassificationLayer layer, string type, IEnumerable`1<IClassificationType> baseTypes);
}
public interface Microsoft.VisualStudio.Text.Classification.IClassifier {
    public abstract virtual IList`1<ClassificationSpan> GetClassificationSpans(SnapshotSpan span);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ClassificationChanged(EventHandler`1<ClassificationChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ClassificationChanged(EventHandler`1<ClassificationChangedEventArgs> value);
}
public interface Microsoft.VisualStudio.Text.Classification.IClassifierAggregatorService {
    public abstract virtual IClassifier GetClassifier(ITextBuffer textBuffer);
}
public interface Microsoft.VisualStudio.Text.Classification.IClassifierProvider {
    public abstract virtual IClassifier GetClassifier(ITextBuffer textBuffer);
}
public interface Microsoft.VisualStudio.Text.Classification.ILayeredClassificationType {
    public ClassificationLayer Layer { get; }
    public abstract virtual ClassificationLayer get_Layer();
}
internal enum Microsoft.VisualStudio.Text.CodingConventions.ChangeType : Enum {
    public int value__;
    public static ChangeType FileCreated;
    public static ChangeType FileModified;
    public static ChangeType FileDeleted;
    public static ChangeType FolderDeleted;
}
[ObsoleteAttribute("Class has not been finalized and may change without warning.")]
public class Microsoft.VisualStudio.Text.CodingConventions.CodingConventionsChangedAsyncEventHandler : MulticastDelegate {
    public CodingConventionsChangedAsyncEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(object sender, CodingConventionsChangedEventArgs arg);
    public virtual IAsyncResult BeginInvoke(object sender, CodingConventionsChangedEventArgs arg, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[ObsoleteAttribute("Class has not been finalized and may change without warning.")]
public class Microsoft.VisualStudio.Text.CodingConventions.CodingConventionsChangedEventArgs : EventArgs {
}
internal class Microsoft.VisualStudio.Text.CodingConventions.ContextFileMovedAsyncEventHandler : MulticastDelegate {
    public ContextFileMovedAsyncEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(object sender, ContextFileMovedEventArgs arg);
    public virtual IAsyncResult BeginInvoke(object sender, ContextFileMovedEventArgs arg, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Text.CodingConventions.ContextFileMovedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <OldFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewFilePath>k__BackingField;
    public string OldFilePath { get; }
    public string NewFilePath { get; }
    public ContextFileMovedEventArgs(string oldFilePath, string newFilePath);
    [CompilerGeneratedAttribute]
public string get_OldFilePath();
    [CompilerGeneratedAttribute]
public string get_NewFilePath();
}
internal class Microsoft.VisualStudio.Text.CodingConventions.ConventionsFileChangedAsyncEventHandler : MulticastDelegate {
    public ConventionsFileChangedAsyncEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(object sender, ConventionsFileChangeEventArgs arg);
    public virtual IAsyncResult BeginInvoke(object sender, ConventionsFileChangeEventArgs arg, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Text.CodingConventions.ConventionsFileChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeType <ChangeType>k__BackingField;
    public string FileName { get; }
    public string DirectoryPath { get; }
    public ChangeType ChangeType { get; }
    public ConventionsFileChangeEventArgs(string fileName, string directoryPath, ChangeType changeType);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_DirectoryPath();
    [CompilerGeneratedAttribute]
public ChangeType get_ChangeType();
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("Class has not been finalized and may change without warning.")]
public interface Microsoft.VisualStudio.Text.CodingConventions.ICodingConventionContext {
    [NullableAttribute("2")]
public ICodingConventionsSnapshot CurrentConventions { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_CodingConventionsChangedAsync(CodingConventionsChangedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CodingConventionsChangedAsync(CodingConventionsChangedAsyncEventHandler value);
    [NullableContextAttribute("2")]
public abstract virtual ICodingConventionsSnapshot get_CurrentConventions();
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("Class has not been finalized and may change without warning.")]
public interface Microsoft.VisualStudio.Text.CodingConventions.ICodingConventionsManager {
    public abstract virtual Task`1<ICodingConventionContext> GetConventionContextAsync(string filePathContext, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Text.CodingConventions.ICodingConventionsProvider {
    public abstract virtual Task`1<ICodingConventionContext> GetCodingConventionsAsync(string filePathContext, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Microsoft.VisualStudio.Text.CodingConventions.ICodingConventionsProviderDependencies {
    public IFileWatcher FileWatcher { get; }
    public abstract virtual IFileWatcher get_FileWatcher();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Text.CodingConventions.ICodingConventionsProviderFactory {
    public abstract virtual ICodingConventionsProvider CreateCodingConventionsProvider(ICodingConventionsProviderDependencies dependencies);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("Class has not been finalized and may change without warning.")]
public interface Microsoft.VisualStudio.Text.CodingConventions.ICodingConventionsSnapshot {
    public IUniversalCodingConventions UniversalConventions { get; }
    public IReadOnlyDictionary`2<string, object> AllRawConventions { get; }
    public abstract virtual IUniversalCodingConventions get_UniversalConventions();
    [NullableContextAttribute("2")]
public abstract virtual bool TryGetConventionValue(string conventionName, T& conventionValue);
    public abstract virtual bool TryGetConventionPath(string conventionName, String& conventionPath);
    public abstract virtual IReadOnlyDictionary`2<string, object> get_AllRawConventions();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Text.CodingConventions.IFileWatcher {
    public abstract virtual void StartWatching(string fileName, string directoryPath);
    public abstract virtual void StopWatching(string fileName, string directoryPath);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConventionFileChanged(ConventionsFileChangedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConventionFileChanged(ConventionsFileChangedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ContextFileMoved(ContextFileMovedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ContextFileMoved(ContextFileMovedAsyncEventHandler value);
}
[ObsoleteAttribute("Class has not been finalized and may change without warning.")]
public enum Microsoft.VisualStudio.Text.CodingConventions.IndentStyle : Enum {
    public int value__;
    public static IndentStyle Tabs;
    public static IndentStyle Spaces;
}
[NullableContextAttribute("2")]
[ObsoleteAttribute("Class has not been finalized and may change without warning.")]
public interface Microsoft.VisualStudio.Text.CodingConventions.IUniversalCodingConventions {
    public abstract virtual bool TryGetIndentStyle(Nullable`1& indentStyle);
    public abstract virtual bool TryGetIndentSize(Nullable`1& indentSize);
    public abstract virtual bool TryGetTabWidth(Nullable`1& tabWidth);
    public abstract virtual bool TryGetLineEnding(String& lineEnding);
    public abstract virtual bool TryGetEncoding(Encoding& encoding);
    public abstract virtual bool TryGetAllowTrailingWhitespace(Nullable`1& allowTrailingWhitespace);
    public abstract virtual bool TryGetRequireFinalNewline(Nullable`1& requireFinalNewline);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Text.Configuration.IWordPatternBroker {
    public abstract virtual Task`1<string> GetWordPatternExpressionAsync(SnapshotPoint snapshotPoint, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Text.Configuration.IWordPatternProvider {
    public abstract virtual Task`1<string> GetWordPatternRegexAsync(SnapshotPoint snapshotPoint, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Text.Configuration.IWordPatternProviderFactory {
    public abstract virtual IWordPatternProvider Create(ITextBuffer textBuffer);
}
public class Microsoft.VisualStudio.Text.Differencing.BaseLeftBufferChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ITextBuffer <OldBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private ITextBuffer <NewBuffer>k__BackingField;
    public ITextBuffer OldBuffer { get; }
    public ITextBuffer NewBuffer { get; }
    public BaseLeftBufferChangedEventArgs(ITextBuffer oldBuffer, ITextBuffer newBuffer);
    [CompilerGeneratedAttribute]
public ITextBuffer get_OldBuffer();
    [CompilerGeneratedAttribute]
public ITextBuffer get_NewBuffer();
}
public abstract class Microsoft.VisualStudio.Text.Differencing.DifferenceBufferOption`1 : EditorOptionDefinition`1<T> {
    public virtual bool IsApplicableToScope(IPropertyOwner scope);
}
public static class Microsoft.VisualStudio.Text.Differencing.DifferenceBufferOptions : object {
    public static EditorOptionKey`1<IgnoreWhiteSpaceBehavior> IgnoreWhiteSpaceBehaviorId;
    public static string IgnoreWhiteSpaceBehaviorName;
    public static EditorOptionKey`1<bool> IgnoreCaseId;
    public static string IgnoreCaseName;
    private static DifferenceBufferOptions();
}
public static class Microsoft.VisualStudio.Text.Differencing.DifferenceBufferProperties : object {
    public static string PlaceholderBuffer;
}
public enum Microsoft.VisualStudio.Text.Differencing.DifferenceMappingMode : Enum {
    public int value__;
    public static DifferenceMappingMode Start;
    public static DifferenceMappingMode LineColumn;
    public static DifferenceMappingMode End;
}
public interface Microsoft.VisualStudio.Text.Differencing.IDifferenceBuffer {
    public ITextBuffer BaseLeftBuffer { get; }
    public ITextBuffer LeftBuffer { get; }
    public ITextBuffer BaseRightBuffer { get; }
    public ITextBuffer RightBuffer { get; }
    public IProjectionBuffer InlineBuffer { get; }
    public ISnapshotDifference CurrentSnapshotDifference { get; }
    public IProjectionSnapshot CurrentInlineBufferSnapshot { get; }
    public IEditorOptions Options { get; }
    public StringDifferenceOptions DifferenceOptions { get; public set; }
    public bool IsEditingDisabled { get; }
    public abstract virtual ITextBuffer get_BaseLeftBuffer();
    public abstract virtual ITextBuffer get_LeftBuffer();
    public abstract virtual ITextBuffer get_BaseRightBuffer();
    public abstract virtual ITextBuffer get_RightBuffer();
    public abstract virtual IProjectionBuffer get_InlineBuffer();
    public abstract virtual ISnapshotDifference get_CurrentSnapshotDifference();
    public abstract virtual IProjectionSnapshot get_CurrentInlineBufferSnapshot();
    [CompilerGeneratedAttribute]
public abstract virtual void add_SnapshotDifferenceChanging(EventHandler`1<SnapshotDifferenceChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SnapshotDifferenceChanging(EventHandler`1<SnapshotDifferenceChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SnapshotDifferenceChanged(EventHandler`1<SnapshotDifferenceChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SnapshotDifferenceChanged(EventHandler`1<SnapshotDifferenceChangeEventArgs> value);
    public abstract virtual IEditorOptions get_Options();
    public abstract virtual StringDifferenceOptions get_DifferenceOptions();
    public abstract virtual void set_DifferenceOptions(StringDifferenceOptions value);
    public abstract virtual bool get_IsEditingDisabled();
    public abstract virtual void AddIgnoreDifferencePredicate(IgnoreDifferencePredicate predicate);
    public abstract virtual bool RemoveIgnoreDifferencePredicate(IgnoreDifferencePredicate predicate);
    public abstract virtual void AddSnapshotLineTransform(SnapshotLineTransform transform);
    public abstract virtual bool RemoveSnapshotLineTransform(SnapshotLineTransform transform);
}
public interface Microsoft.VisualStudio.Text.Differencing.IDifferenceBuffer2 {
    public bool HasFixedBaseLeftBuffer { get; }
    public ITextDataModel LeftDataModel { get; }
    public ITextDataModel InnerLeftDataModel { get; public set; }
    public ITextDataModel RightDataModel { get; }
    public ITextDataModel InlineDataModel { get; }
    public abstract virtual bool get_HasFixedBaseLeftBuffer();
    [CompilerGeneratedAttribute]
public abstract virtual void add_BaseLeftBufferChanged(EventHandler`1<BaseLeftBufferChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BaseLeftBufferChanged(EventHandler`1<BaseLeftBufferChangedEventArgs> value);
    public abstract virtual ITextDataModel get_LeftDataModel();
    public abstract virtual ITextDataModel get_InnerLeftDataModel();
    public abstract virtual void set_InnerLeftDataModel(ITextDataModel value);
    public abstract virtual ITextDataModel get_RightDataModel();
    public abstract virtual ITextDataModel get_InlineDataModel();
}
public interface Microsoft.VisualStudio.Text.Differencing.IDifferenceBuffer3 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_BaseLeftBufferChanging(EventHandler`1<BaseLeftBufferChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BaseLeftBufferChanging(EventHandler`1<BaseLeftBufferChangedEventArgs> value);
}
internal interface Microsoft.VisualStudio.Text.Differencing.IDifferenceBuffer4 {
    public abstract virtual void AddLineDifferenceMutator(LineDifferenceMutator mutator);
    public abstract virtual bool RemoveLineDifferenceMutator(LineDifferenceMutator mutator);
    public abstract virtual void ForceUpdate();
}
public interface Microsoft.VisualStudio.Text.Differencing.IDifferenceBufferFactoryService {
    public abstract virtual IDifferenceBuffer CreateDifferenceBuffer(ITextBuffer leftBaseBuffer, ITextBuffer rightBaseBuffer);
    public abstract virtual IDifferenceBuffer CreateDifferenceBuffer(ITextBuffer leftBaseBuffer, ITextBuffer rightBaseBuffer, StringDifferenceOptions options, bool disableEditing, bool wrapLeftBuffer, bool wrapRightBuffer);
    public abstract virtual IDifferenceBuffer TryGetDifferenceBuffer(IProjectionBufferBase projectionBuffer);
}
public interface Microsoft.VisualStudio.Text.Differencing.IDifferenceBufferFactoryService2 {
    public abstract virtual IDifferenceBuffer2 CreateDifferenceBuffer(ITextBuffer leftBaseBuffer, ITextBuffer rightBaseBuffer, StringDifferenceOptions options, bool disableEditing, bool wrapLeftBuffer, bool wrapRightBuffer, bool fixedBaseLeftBuffer);
    public abstract virtual IDifferenceBuffer2 CreateDifferenceBuffer(ITextDataModel innerLeftDataModel, ITextDataModel rightDataModel, StringDifferenceOptions options, bool disableEditing, bool wrapLeftBuffer, bool wrapRightBuffer, bool fixedBaseLeftBuffer);
}
public interface Microsoft.VisualStudio.Text.Differencing.IDifferenceBufferFactoryService3 {
    public abstract virtual IDifferenceBuffer2 CreateDifferenceBuffer(ITextDataModel innerLeftDataModel, ITextDataModel rightDataModel, StringDifferenceOptions options, bool disableEditing, IProjectionBuffer leftEditBuffer, Action`3<IProjectionBuffer, IDifferenceBuffer2, ITextDataModel> updateLeftProjection, IProjectionBuffer rightEditBuffer, bool fixedBaseLeftBuffer);
}
public interface Microsoft.VisualStudio.Text.Differencing.IDifferenceTrackingSpanCollection {
    public IEnumerable`1<ITrackingSpan> RemovedLineSpans { get; }
    public IEnumerable`1<ITrackingSpan> RemovedWordSpans { get; }
    public IEnumerable`1<ITrackingSpan> AddedLineSpans { get; }
    public IEnumerable`1<ITrackingSpan> AddedWordSpans { get; }
    public abstract virtual IEnumerable`1<ITrackingSpan> get_RemovedLineSpans();
    public abstract virtual IEnumerable`1<ITrackingSpan> get_RemovedWordSpans();
    public abstract virtual IEnumerable`1<ITrackingSpan> get_AddedLineSpans();
    public abstract virtual IEnumerable`1<ITrackingSpan> get_AddedWordSpans();
}
public class Microsoft.VisualStudio.Text.Differencing.IgnoreDifferencePredicate : MulticastDelegate {
    public IgnoreDifferencePredicate(object object, IntPtr method);
    public virtual bool Invoke(Difference lineDifference, ITextSnapshot leftSnapshot, ITextSnapshot rightSnapshot);
    public virtual IAsyncResult BeginInvoke(Difference lineDifference, ITextSnapshot leftSnapshot, ITextSnapshot rightSnapshot, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public enum Microsoft.VisualStudio.Text.Differencing.IgnoreWhiteSpaceBehavior : Enum {
    public int value__;
    public static IgnoreWhiteSpaceBehavior None;
    public static IgnoreWhiteSpaceBehavior IgnoreTrimWhiteSpace;
    public static IgnoreWhiteSpaceBehavior IgnoreAllWhiteSpace;
}
public interface Microsoft.VisualStudio.Text.Differencing.ISnapshotDifference {
    public IDifferenceBuffer DifferenceBuffer { get; }
    public ITextSnapshot LeftBufferSnapshot { get; }
    public ITextSnapshot RightBufferSnapshot { get; }
    public IProjectionSnapshot InlineBufferSnapshot { get; }
    public StringDifferenceOptions DifferenceOptions { get; }
    public IEnumerable`1<SnapshotLineTransform> SnapshotLineTransforms { get; }
    public IEnumerable`1<IgnoreDifferencePredicate> IgnoreDifferencePredicates { get; }
    public IHierarchicalDifferenceCollection LineDifferences { get; }
    public IDifferenceTrackingSpanCollection DifferenceSpans { get; }
    public abstract virtual IDifferenceBuffer get_DifferenceBuffer();
    public abstract virtual ITextSnapshot get_LeftBufferSnapshot();
    public abstract virtual ITextSnapshot get_RightBufferSnapshot();
    public abstract virtual IProjectionSnapshot get_InlineBufferSnapshot();
    public abstract virtual StringDifferenceOptions get_DifferenceOptions();
    public abstract virtual IEnumerable`1<SnapshotLineTransform> get_SnapshotLineTransforms();
    public abstract virtual IEnumerable`1<IgnoreDifferencePredicate> get_IgnoreDifferencePredicates();
    public abstract virtual IHierarchicalDifferenceCollection get_LineDifferences();
    public abstract virtual IDifferenceTrackingSpanCollection get_DifferenceSpans();
    public abstract virtual SnapshotPoint MapToInlineSnapshot(SnapshotPoint point);
    public abstract virtual SnapshotPoint MapToInlineSnapshot(SnapshotPoint point, PositionAffinity positionAffinity);
    public abstract virtual int FindMatchOrDifference(SnapshotPoint point, Match& match, Difference& difference);
    public abstract virtual SnapshotPoint TranslateToSnapshot(SnapshotPoint point);
    public abstract virtual SnapshotPoint MapToSourceSnapshot(SnapshotPoint inlinePoint);
    public abstract virtual SnapshotPoint MapToSnapshot(SnapshotPoint point, ITextSnapshot target, DifferenceMappingMode mode);
    public abstract virtual SnapshotSpan MapToSnapshot(Difference difference, ITextSnapshot target);
}
internal class Microsoft.VisualStudio.Text.Differencing.LineDifferenceMutator : MulticastDelegate {
    public LineDifferenceMutator(object object, IntPtr method);
    public virtual IReadOnlyList`1<SpanPair> Invoke(IReadOnlyList`1<SpanPair> lineDifferences, ITextSnapshot leftSnapshot, ITextSnapshot rightSnapshot);
    public virtual IAsyncResult BeginInvoke(IReadOnlyList`1<SpanPair> lineDifferences, ITextSnapshot leftSnapshot, ITextSnapshot rightSnapshot, AsyncCallback callback, object object);
    public virtual IReadOnlyList`1<SpanPair> EndInvoke(IAsyncResult result);
}
public enum Microsoft.VisualStudio.Text.Differencing.LineType : Enum {
    public int value__;
    public static LineType Added;
    public static LineType Removed;
    public static LineType Matched;
}
public class Microsoft.VisualStudio.Text.Differencing.SnapshotDifferenceChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ISnapshotDifference <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private ISnapshotDifference <After>k__BackingField;
    public ISnapshotDifference Before { get; private set; }
    public ISnapshotDifference After { get; private set; }
    public SnapshotDifferenceChangeEventArgs(ISnapshotDifference before, ISnapshotDifference after);
    [CompilerGeneratedAttribute]
public ISnapshotDifference get_Before();
    [CompilerGeneratedAttribute]
private void set_Before(ISnapshotDifference value);
    [CompilerGeneratedAttribute]
public ISnapshotDifference get_After();
    [CompilerGeneratedAttribute]
private void set_After(ISnapshotDifference value);
}
public class Microsoft.VisualStudio.Text.Differencing.SnapshotLineTransform : MulticastDelegate {
    public SnapshotLineTransform(object object, IntPtr method);
    public virtual string Invoke(ITextSnapshotLine line, string currentText);
    public virtual IAsyncResult BeginInvoke(ITextSnapshotLine line, string currentText, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.Text.Differencing.SpanPair : object {
    internal Span Left;
    internal Span Right;
    internal SpanPair(Span left, Span right);
}
[IsReadOnlyAttribute]
public class Microsoft.VisualStudio.Text.Document.ChangedSnapshotSpan : ValueType {
    [CompilerGeneratedAttribute]
private SnapshotSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeTypes <ChangeType>k__BackingField;
    public SnapshotSpan Span { get; }
    public ChangeTypes ChangeType { get; }
    public ChangedSnapshotSpan(SnapshotSpan span, ChangeTypes changeType);
    [CompilerGeneratedAttribute]
public SnapshotSpan get_Span();
    [CompilerGeneratedAttribute]
public ChangeTypes get_ChangeType();
}
public class Microsoft.VisualStudio.Text.Document.ChangeTag : object {
    [CompilerGeneratedAttribute]
private ChangeTypes <ChangeTypes>k__BackingField;
    public ChangeTypes ChangeTypes { get; }
    public ChangeTag(ChangeTypes type);
    [CompilerGeneratedAttribute]
public ChangeTypes get_ChangeTypes();
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Text.Document.ChangeTypes : Enum {
    public int value__;
    public static ChangeTypes None;
    public static ChangeTypes ChangedSinceOpened;
    public static ChangeTypes ChangedSinceSaved;
    public static ChangeTypes SourceControlAdded;
    public static ChangeTypes SourceControlDeleted;
    public static ChangeTypes SourceControlModified;
    public static ChangeTypes SourceControlChangeSaved;
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Text.Document.IChangeSource {
    public bool IsActive { get; }
    public abstract virtual bool get_IsActive();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChangedSpansChanged(EventHandler`1<SnapshotSpanEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChangedSpansChanged(EventHandler`1<SnapshotSpanEventArgs> value);
    public abstract virtual IEnumerable`1<ChangedSnapshotSpan> GetChangedSpans(NormalizedSnapshotSpanCollection spans);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Text.Document.IChangeSourceProvider {
    public abstract virtual IChangeSource Create(ITextBuffer textBuffer);
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("AdaptiveFormatting")]
internal class Microsoft.VisualStudio.Text.Editor.AdaptiveFormattingOption : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("AutoDetectUtf8")]
public class Microsoft.VisualStudio.Text.Editor.AutoDetectUtf8Option : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("AutomaticDelimiterHighlighting")]
public class Microsoft.VisualStudio.Text.Editor.AutomaticDelimiterHighlightingOption : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
internal enum Microsoft.VisualStudio.Text.Editor.ChangeTrackingMode : Enum {
    public int value__;
    public static ChangeTrackingMode ChangesComparedToSourceControlBase;
    public static ChangeTrackingMode ChangesSinceFileOpen;
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("ChangeTrackingMode")]
internal class Microsoft.VisualStudio.Text.Editor.ChangeTrackingModeOption : EditorOptionDefinition`1<ChangeTrackingMode> {
    public ChangeTrackingMode Default { get; }
    public EditorOptionKey`1<ChangeTrackingMode> Key { get; }
    public virtual ChangeTrackingMode get_Default();
    public virtual EditorOptionKey`1<ChangeTrackingMode> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("CodeCleanupOnSaveProfileOption")]
internal class Microsoft.VisualStudio.Text.Editor.CodeCleanupOnSaveProfileOption : EditorOptionDefinition`1<string> {
    public string Default { get; }
    public EditorOptionKey`1<string> Key { get; }
    public virtual string get_Default();
    public virtual EditorOptionKey`1<string> get_Key();
}
internal enum Microsoft.VisualStudio.Text.Editor.CompletionModePreference : Enum {
    public int value__;
    public static CompletionModePreference AutoCompletionMode;
    public static CompletionModePreference SuggestionMode;
    public static CompletionModePreference LastUsed;
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("Tabs/ConvertTabsToSpaces")]
public class Microsoft.VisualStudio.Text.Editor.ConvertTabsToSpaces : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
internal class Microsoft.VisualStudio.Text.Editor.ConvertTabsToSpacesContext : object {
    public static ConvertTabsToSpacesContext FromCodingConventions;
    public static ConvertTabsToSpacesContext FromToolsOptions;
    [CompilerGeneratedAttribute]
private bool <SettingFromCodingConventions>k__BackingField;
    public bool SettingFromCodingConventions { get; }
    private ConvertTabsToSpacesContext(bool settingFromCodingConventions);
    private static ConvertTabsToSpacesContext();
    [CompilerGeneratedAttribute]
public bool get_SettingFromCodingConventions();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("DefaultCompletionMode")]
internal class Microsoft.VisualStudio.Text.Editor.DefaultCompletionModeOption : EditorOptionDefinition`1<CompletionModePreference> {
    public CompletionModePreference Default { get; }
    public EditorOptionKey`1<CompletionModePreference> Key { get; }
    public virtual CompletionModePreference get_Default();
    public virtual EditorOptionKey`1<CompletionModePreference> get_Key();
}
public static class Microsoft.VisualStudio.Text.Editor.DefaultOptions : object {
    public static EditorOptionKey`1<bool> ConvertTabsToSpacesOptionId;
    public static string ConvertTabsToSpacesOptionName;
    public static EditorOptionKey`1<int> TabSizeOptionId;
    public static string TabSizeOptionName;
    public static EditorOptionKey`1<int> IndentSizeOptionId;
    public static string IndentSizeOptionName;
    public static EditorOptionKey`1<IndentingStyle> IndentStyleId;
    public static string IndentStyleName;
    public static EditorOptionKey`1<bool> ReplicateNewLineCharacterOptionId;
    public static string ReplicateNewLineCharacterOptionName;
    public static EditorOptionKey`1<string> NewLineCharacterOptionId;
    public static string NewLineCharacterOptionName;
    public static EditorOptionKey`1<int> LongBufferLineThresholdId;
    public static string LongBufferLineThresholdOptionName;
    public static EditorOptionKey`1<int> LongBufferLineChunkLengthId;
    public static string LongBufferLineChunkLengthOptionName;
    public static EditorOptionKey`1<bool> TrimTrailingWhiteSpaceOptionId;
    public static string TrimTrailingWhiteSpaceOptionName;
    public static EditorOptionKey`1<bool> InsertFinalNewLineOptionId;
    public static string InsertFinalNewLineOptionName;
    public static EditorOptionKey`1<string> TooltipAppearanceCategoryOptionId;
    public static string TooltipAppearanceCategoryOptionName;
    public static EditorOptionKey`1<bool> AutoDetectUtf8Id;
    public static string AutoDetectUtf8Name;
    public static EditorOptionKey`1<bool> AutomaticDelimiterHighlightingId;
    public static string AutomaticDelimiterHighlightingName;
    public static EditorOptionKey`1<bool> FollowCodingConventionsId;
    public static string FollowCodingConventionsName;
    public static EditorOptionKey`1<IReadOnlyDictionary`2<string, object>> RawCodingConventionsSnapshotOptionId;
    public static string RawCodingConventionsSnapshotOptionName;
    public static EditorOptionKey`1<int> EditorEmulationModeId;
    public static string EditorEmulationModeName;
    internal static EditorOptionKey`1<int> MaximumTypingLatencyOptionId;
    internal static string MaximumTypingLatencyOptionName;
    internal static EditorOptionKey`1<int> UserCustomMaximumTypingLatencyOptionId;
    internal static string UserCustomMaximumTypingLatencyOptionName;
    internal static EditorOptionKey`1<bool> EnableTypingLatencyGuardOptionId;
    internal static string EnableTypingLatencyGuardOptionName;
    public static EditorOptionKey`1<string> FallbackFontId;
    public static string FallbackFontName;
    public static EditorOptionKey`1<bool> NonBlockingCompletionOptionId;
    public static string NonBlockingCompletionOptionName;
    public static EditorOptionKey`1<bool> ResponsiveCompletionOptionId;
    public static string ResponsiveCompletionOptionName;
    public static EditorOptionKey`1<int> ResponsiveCompletionThresholdOptionId;
    public static string ResponsiveCompletionThresholdOptionName;
    public static EditorOptionKey`1<bool> WordBasedSuggestionsOptionId;
    public static string WordBasedSuggestionsOptionName;
    internal static EditorOptionKey`1<CompletionModePreference> DefaultCompletionModeOptionId;
    internal static string DefaultCompletionModeOptionName;
    internal static EditorOptionKey`1<bool> DiagnosticModeOptionId;
    internal static string DiagnosticModeOptionName;
    public static EditorOptionKey`1<bool> AdaptiveFormattingOptionId;
    public static string AdaptiveFormattingOptionName;
    public static EditorOptionKey`1<bool> UseBoxSelectionOptionId;
    public static string UseBoxSelectionOptionName;
    public static EditorOptionKey`1<bool> SelectSubwordOnDoubleClickId;
    public static string SelectSubwordOnDoubleClickName;
    public static EditorOptionKey`1<bool> EnableCodeCleanupOnSaveOptionId;
    public static string EnableCodeCleanupOnSaveOptionName;
    public static EditorOptionKey`1<string> CodeCleanupOnSaveProfileOptionId;
    public static string CodeCleanupOnSaveProfileOptionName;
    public static EditorOptionKey`1<bool> HideAdvancedCompletionItemsOptionId;
    public static string HideAdvancedCompletionItemsOptionName;
    public static EditorOptionKey`1<bool> ShowSignatureHelpOptionId;
    public static string ShowSignatureHelpOptionName;
    internal static EditorOptionKey`1<ChangeTrackingMode> ChangeTrackingModeOptionId;
    internal static string ChangeTrackingModeOptionName;
    internal static EditorOptionKey`1<string> PreloadDisallowListOptionId;
    internal static string PreloadDisallowListOptionName;
    private static DefaultOptions();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("452")]
public class Microsoft.VisualStudio.Text.Editor.DeferCreationAttribute : SingletonBaseMetadataAttribute {
    private string optionName;
    public string OptionName { get; public set; }
    public string get_OptionName();
    public void set_OptionName(string value);
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("DiagnosticMode")]
internal class Microsoft.VisualStudio.Text.Editor.DiagnosticModeOption : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("EditorEmulationMode")]
public class Microsoft.VisualStudio.Text.Editor.EditorEmulationModeOption : EditorOptionDefinition`1<int> {
    public int Default { get; }
    public EditorOptionKey`1<int> Key { get; }
    public virtual int get_Default();
    public virtual EditorOptionKey`1<int> get_Key();
}
public class Microsoft.VisualStudio.Text.Editor.EditorOptionChangedEventArgs : EventArgs {
    private string _optionId;
    public string OptionId { get; }
    public EditorOptionChangedEventArgs(string optionId);
    public string get_OptionId();
}
public abstract class Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition : object {
    public object DefaultValue { get; }
    public Type ValueType { get; }
    public string Name { get; }
    public abstract virtual object get_DefaultValue();
    public abstract virtual Type get_ValueType();
    public abstract virtual string get_Name();
    public virtual bool IsApplicableToScope(IPropertyOwner scope);
    public virtual bool IsValid(Object& proposedValue);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition`1 : EditorOptionDefinition {
    public Type ValueType { get; }
    public string Name { get; }
    public object DefaultValue { get; }
    public EditorOptionKey`1<T> Key { get; }
    public T Default { get; }
    public sealed virtual Type get_ValueType();
    public sealed virtual string get_Name();
    public sealed virtual object get_DefaultValue();
    public sealed virtual bool IsValid(Object& proposedValue);
    public abstract virtual EditorOptionKey`1<T> get_Key();
    public virtual T get_Default();
    public virtual bool IsValid(T& proposedValue);
}
public class Microsoft.VisualStudio.Text.Editor.EditorOptionKey`1 : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public EditorOptionKey`1(string name);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(EditorOptionKey`1<T> left, EditorOptionKey`1<T> right);
    public static bool op_Inequality(EditorOptionKey`1<T> left, EditorOptionKey`1<T> right);
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("EnableCodeCleanupOnSaveOption")]
internal class Microsoft.VisualStudio.Text.Editor.EnableCodeCleanupOnSaveOption : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("EnableTypingLatencyGuard")]
internal class Microsoft.VisualStudio.Text.Editor.EnableTypingLatencyGuard : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("FollowCodingConventions")]
public class Microsoft.VisualStudio.Text.Editor.FollowCodingConventionsOption : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("TextView/HideAdvancedCompletionItems")]
internal class Microsoft.VisualStudio.Text.Editor.HideAdvancedCompletionItemsOption : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
public interface Microsoft.VisualStudio.Text.Editor.IEditorOptions {
    public IEnumerable`1<EditorOptionDefinition> SupportedOptions { get; }
    public IEditorOptions GlobalOptions { get; }
    public IEditorOptions Parent { get; public set; }
    public abstract virtual T GetOptionValue(string optionId);
    public abstract virtual T GetOptionValue(EditorOptionKey`1<T> key);
    public abstract virtual object GetOptionValue(string optionId);
    public abstract virtual void SetOptionValue(string optionId, object value);
    public abstract virtual void SetOptionValue(EditorOptionKey`1<T> key, T value);
    public abstract virtual bool IsOptionDefined(string optionId, bool localScopeOnly);
    public abstract virtual bool IsOptionDefined(EditorOptionKey`1<T> key, bool localScopeOnly);
    public abstract virtual bool ClearOptionValue(string optionId);
    public abstract virtual bool ClearOptionValue(EditorOptionKey`1<T> key);
    public abstract virtual IEnumerable`1<EditorOptionDefinition> get_SupportedOptions();
    public abstract virtual IEditorOptions get_GlobalOptions();
    public abstract virtual IEditorOptions get_Parent();
    public abstract virtual void set_Parent(IEditorOptions value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OptionChanged(EventHandler`1<EditorOptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OptionChanged(EventHandler`1<EditorOptionChangedEventArgs> value);
}
public interface Microsoft.VisualStudio.Text.Editor.IEditorOptionsFactoryService {
    public IEditorOptions GlobalOptions { get; }
    public abstract virtual IEditorOptions GetOptions(IPropertyOwner scope);
    public abstract virtual IEditorOptions CreateOptions();
    public abstract virtual IEditorOptions get_GlobalOptions();
}
internal interface Microsoft.VisualStudio.Text.Editor.IEditorOptionsFactoryService2 {
    public abstract virtual IEditorOptions CreateOptions(bool allowLateBinding);
    public abstract virtual bool TryBindToScope(IEditorOptions option, IPropertyOwner scope);
    public abstract virtual EditorOptionDefinition GetOptionDefinition(string optionId);
}
public interface Microsoft.VisualStudio.Text.Editor.IIndentationManagerService {
    public abstract virtual void GetIndentation(ITextBuffer buffer, bool explicitFormat, Boolean& convertTabsToSpaces, Int32& tabSize, Int32& indentSize);
    public abstract virtual bool UseSpacesForWhitespace(ITextBuffer buffer, bool explicitFormat);
    public abstract virtual int GetTabSize(ITextBuffer buffer, bool explicitFormat);
    public abstract virtual int GetIndentSize(ITextBuffer buffer, bool explicitFormat);
}
public enum Microsoft.VisualStudio.Text.Editor.IndentingStyle : Enum {
    public int value__;
    public static IndentingStyle None;
    public static IndentingStyle Block;
    public static IndentingStyle Smart;
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("Tabs/IndentStyle")]
public class Microsoft.VisualStudio.Text.Editor.IndentingStyleOption : EditorOptionDefinition`1<IndentingStyle> {
    public IndentingStyle Default { get; }
    public EditorOptionKey`1<IndentingStyle> Key { get; }
    public virtual IndentingStyle get_Default();
    public virtual EditorOptionKey`1<IndentingStyle> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("Tabs/IndentSize")]
public class Microsoft.VisualStudio.Text.Editor.IndentSize : EditorOptionDefinition`1<int> {
    public int Default { get; }
    public EditorOptionKey`1<int> Key { get; }
    public virtual int get_Default();
    public virtual EditorOptionKey`1<int> get_Key();
    public virtual bool IsValid(Int32& proposedValue);
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("InsertFinalNewLine")]
public class Microsoft.VisualStudio.Text.Editor.InsertFinalNewLine : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
internal interface Microsoft.VisualStudio.Text.Editor.ITextModelOptionsSetter {
    public abstract virtual void SetTextModelOptions(IEditorOptions options);
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("LongBufferLineChunkLength")]
public class Microsoft.VisualStudio.Text.Editor.LongBufferLineChunk : EditorOptionDefinition`1<int> {
    public int Default { get; }
    public EditorOptionKey`1<int> Key { get; }
    public virtual int get_Default();
    public virtual EditorOptionKey`1<int> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("LongBufferLineThreshold")]
public class Microsoft.VisualStudio.Text.Editor.LongBufferLineThreshold : EditorOptionDefinition`1<int> {
    public int Default { get; }
    public EditorOptionKey`1<int> Key { get; }
    public virtual int get_Default();
    public virtual EditorOptionKey`1<int> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("MaximumTypingLatency")]
internal class Microsoft.VisualStudio.Text.Editor.MaximumTypingLatency : EditorOptionDefinition`1<int> {
    public int Default { get; }
    public EditorOptionKey`1<int> Key { get; }
    public virtual int get_Default();
    public virtual EditorOptionKey`1<int> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("NewLineCharacter")]
public class Microsoft.VisualStudio.Text.Editor.NewLineCharacter : EditorOptionDefinition`1<string> {
    public string Default { get; }
    public EditorOptionKey`1<string> Key { get; }
    public virtual string get_Default();
    public virtual EditorOptionKey`1<string> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("NonBlockingCompletion")]
public class Microsoft.VisualStudio.Text.Editor.NonBlockingCompletionOption : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Text.Editor.OptionsExtensionMethods.DefaultOptionExtensions : object {
    [ExtensionAttribute]
public static bool IsConvertTabsToSpacesEnabled(IEditorOptions options);
    [ExtensionAttribute]
public static int GetTabSize(IEditorOptions options);
    [ExtensionAttribute]
public static int GetIndentSize(IEditorOptions options);
    [ExtensionAttribute]
public static IndentingStyle GetIndentStyle(IEditorOptions options);
    [ExtensionAttribute]
public static bool GetReplicateNewLineCharacter(IEditorOptions options);
    [ExtensionAttribute]
public static string GetNewLineCharacter(IEditorOptions options);
    [ExtensionAttribute]
public static bool GetTrimTrailingWhieSpace(IEditorOptions options);
    [ExtensionAttribute]
public static bool GetInsertFinalNewLine(IEditorOptions options);
    [ExtensionAttribute]
public static string GetTooltipAppearanceCategory(IEditorOptions options);
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("PreloadDisallowList")]
internal class Microsoft.VisualStudio.Text.Editor.PreloadDisallowListOption : EditorOptionDefinition`1<string> {
    public string Default { get; }
    public EditorOptionKey`1<string> Key { get; }
    public virtual string get_Default();
    public virtual EditorOptionKey`1<string> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("CodingConventionsSnapshot")]
internal class Microsoft.VisualStudio.Text.Editor.RawCodingConventionsSnapshotOption : EditorOptionDefinition`1<IReadOnlyDictionary`2<string, object>> {
    private static ReadOnlyDictionary`2<string, object> EmptyDictionary;
    public IReadOnlyDictionary`2<string, object> Default { get; }
    public EditorOptionKey`1<IReadOnlyDictionary`2<string, object>> Key { get; }
    private static RawCodingConventionsSnapshotOption();
    public virtual IReadOnlyDictionary`2<string, object> get_Default();
    public virtual EditorOptionKey`1<IReadOnlyDictionary`2<string, object>> get_Key();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Text.Editor.ReplacesAttribute : MultipleBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private string <Replaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplacesOnlyIfCreated>k__BackingField;
    public string Replaces { get; private set; }
    public bool ReplacesOnlyIfCreated { get; private set; }
    public ReplacesAttribute(string replaces);
    public ReplacesAttribute(string replaces, bool replacesOnlyIfCreated);
    [CompilerGeneratedAttribute]
public string get_Replaces();
    [CompilerGeneratedAttribute]
private void set_Replaces(string value);
    [CompilerGeneratedAttribute]
public bool get_ReplacesOnlyIfCreated();
    [CompilerGeneratedAttribute]
private void set_ReplacesOnlyIfCreated(bool value);
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("ReplicateNewLineCharacter")]
public class Microsoft.VisualStudio.Text.Editor.ReplicateNewLineCharacter : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("ResponsiveCompletion")]
public class Microsoft.VisualStudio.Text.Editor.ResponsiveCompletionOption : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("ResponsiveCompletionThreshold")]
public class Microsoft.VisualStudio.Text.Editor.ResponsiveCompletionThresholdOption : EditorOptionDefinition`1<int> {
    public int Default { get; }
    public EditorOptionKey`1<int> Key { get; }
    public virtual int get_Default();
    public virtual EditorOptionKey`1<int> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("TextView/ShowSignatureHelp")]
internal class Microsoft.VisualStudio.Text.Editor.ShowSignatureHelpOption : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("TextView/SelectSubwordOnDoubleClick")]
internal class Microsoft.VisualStudio.Text.Editor.SubWordNavigationOption : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("Tabs/TabSize")]
public class Microsoft.VisualStudio.Text.Editor.TabSize : EditorOptionDefinition`1<int> {
    public int Default { get; }
    public EditorOptionKey`1<int> Key { get; }
    public virtual int get_Default();
    public virtual EditorOptionKey`1<int> get_Key();
    public virtual bool IsValid(Int32& proposedValue);
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("TooltipAppearanceCategory")]
public class Microsoft.VisualStudio.Text.Editor.TooltipAppearanceCategory : EditorOptionDefinition`1<string> {
    public string Default { get; }
    public EditorOptionKey`1<string> Key { get; }
    public virtual string get_Default();
    public virtual EditorOptionKey`1<string> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("TrimTrailingWhiteSpace")]
public class Microsoft.VisualStudio.Text.Editor.TrimTrailingWhiteSpace : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("UseBoxSelectionOption")]
internal class Microsoft.VisualStudio.Text.Editor.UseBoxSelectionOption : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("UserCustomMaximumTypingLatency")]
internal class Microsoft.VisualStudio.Text.Editor.UserCustomMaximumTypingLatencyOption : EditorOptionDefinition`1<int> {
    public int Default { get; }
    public EditorOptionKey`1<int> Key { get; }
    public virtual int get_Default();
    public virtual EditorOptionKey`1<int> get_Key();
}
[ExportAttribute("Microsoft.VisualStudio.Text.Editor.EditorOptionDefinition")]
[NameAttribute("WordBasedSuggestions")]
internal class Microsoft.VisualStudio.Text.Editor.WordBasedSuggestions : EditorOptionDefinition`1<bool> {
    public bool Default { get; }
    public EditorOptionKey`1<bool> Key { get; }
    public virtual bool get_Default();
    public virtual EditorOptionKey`1<bool> get_Key();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Text.GlobMatching.GlobMatcher : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]
private ImmutableArray`1<ValueTuple`2<int, int>> _numberRangePairs;
    [CompilerGeneratedAttribute]
private Regex <Regex>k__BackingField;
    private Regex Regex { get; }
    [NullableContextAttribute("0")]
private GlobMatcher(Regex regex, ImmutableArray`1<ValueTuple`2<int, int>> numberRangePairs);
    [CompilerGeneratedAttribute]
private Regex get_Regex();
    public bool IsPathMatch(string filePath);
    public static bool TryParseGlobPattern(string globPattern, GlobMatcher& matcher);
    public static bool TryParseGlobPattern(string globPattern, RegexOptions regexOptions, GlobMatcher& matcher);
    private static bool TryCompilePathList(Lexer& lexer, StringBuilder sb, bool parsingChoice, ArrayBuilder`1<ValueTuple`2<int, int>> numberRangePairs);
    private static Nullable`1<ValueTuple`2<string, string>> TryParseNumberRange(Lexer& lexer);
    private static bool TryCompileCharacterClass(Lexer& lexer, StringBuilder sb);
    private static bool TryCompileChoice(Lexer& lexer, StringBuilder sb, ArrayBuilder`1<ValueTuple`2<int, int>> numberRangePairs);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Text.IEditDistanceService {
    public abstract virtual int GetEditDistance(string source, string target);
}
public interface Microsoft.VisualStudio.Text.ITextDataModel {
    public IContentType ContentType { get; }
    public ITextBuffer DocumentBuffer { get; }
    public ITextBuffer DataBuffer { get; }
    public abstract virtual IContentType get_ContentType();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ContentTypeChanged(EventHandler`1<TextDataModelContentTypeChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ContentTypeChanged(EventHandler`1<TextDataModelContentTypeChangedEventArgs> value);
    public abstract virtual ITextBuffer get_DocumentBuffer();
    public abstract virtual ITextBuffer get_DataBuffer();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Text.Logic.IOpenDocumentTextSnapshotCachingService {
    public abstract virtual ITextSnapshot TryGetTextSnapshotForVersionNumber(ITextBuffer2 textBuffer, int textSnapshotVersion);
    public abstract virtual ITextSnapshot TryGetTextSnapshotForVersionNumber(string filePath, int textSnapshotVersion);
    public abstract virtual ITextSnapshot TryGetOldestSnapshotAvailable(ITextBuffer2 textBuffer);
    public abstract virtual ITextSnapshot TryGetOldestSnapshotAvailable(string filePath);
    public abstract virtual ITextSnapshot TryGetLatestSnapshot(string filePath);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CachedItemStateChanged(EventHandler`1<OpenDocumentCachedItemActionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CachedItemStateChanged(EventHandler`1<OpenDocumentCachedItemActionEventArgs> value);
    public abstract virtual Nullable`1<bool> IsDocumentDirty(string filePath);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Text.Logic.IRemoteFileManager {
    public bool IsRemoteClient { get; }
    public abstract virtual bool get_IsRemoteClient();
    public abstract virtual Task`1<string> GetLocalDocumentNameAsync(Uri remoteUri, CancellationToken cancellationToken);
    public abstract virtual Task`1<Uri> GetLocalUriAsync(Uri remoteUri, CancellationToken cancellationToken);
    public abstract virtual Task`1<Uri> GetRemoteUriAsync(Uri localUri, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetDisplayNameFromRemoteMonikerAsync(Uri remoteUri, CancellationToken cancellationToken);
}
internal enum Microsoft.VisualStudio.Text.Logic.OpenDocumentCachedItemAction : Enum {
    public int value__;
    public static OpenDocumentCachedItemAction ItemRemoved;
    public static OpenDocumentCachedItemAction ItemAdded;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Text.Logic.OpenDocumentCachedItemActionEventArgs : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenDocumentCachedItemAction <ItemState>k__BackingField;
    public string FilePath { get; }
    public OpenDocumentCachedItemAction ItemState { get; }
    public OpenDocumentCachedItemActionEventArgs(string filePath, OpenDocumentCachedItemAction itemState);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public OpenDocumentCachedItemAction get_ItemState();
}
public class Microsoft.VisualStudio.Text.Logic.TextModel.ChangeTypeAttribute : MultipleBaseMetadataAttribute {
    [CompilerGeneratedAttribute]
private ChangeTypes <ChangeType>k__BackingField;
    public ChangeTypes ChangeType { get; }
    public ChangeTypeAttribute(ChangeTypes changeType);
    [CompilerGeneratedAttribute]
public ChangeTypes get_ChangeType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Text.Operations.FileCandidate : ValueType {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public string FilePath { get; }
    public FileCandidate(string filePath);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FilePath();
}
public class Microsoft.VisualStudio.Text.Operations.FindData : ValueType {
    private string _searchString;
    private ITextSnapshot _textSnapshotToSearch;
    [CompilerGeneratedAttribute]
private FindOptions <FindOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ITextStructureNavigator <TextStructureNavigator>k__BackingField;
    public string SearchString { get; public set; }
    public FindOptions FindOptions { get; public set; }
    public ITextSnapshot TextSnapshotToSearch { get; public set; }
    public ITextStructureNavigator TextStructureNavigator { get; public set; }
    public FindData(string searchPattern, ITextSnapshot textSnapshot, FindOptions findOptions, ITextStructureNavigator textStructureNavigator);
    public FindData(string searchPattern, ITextSnapshot textSnapshot);
    internal FindData(ITextSnapshot textSnapshot);
    public string get_SearchString();
    public void set_SearchString(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(FindData data1, FindData data2);
    public static bool op_Inequality(FindData data1, FindData data2);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public FindOptions get_FindOptions();
    [CompilerGeneratedAttribute]
public void set_FindOptions(FindOptions value);
    public ITextSnapshot get_TextSnapshotToSearch();
    public void set_TextSnapshotToSearch(ITextSnapshot value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ITextStructureNavigator get_TextStructureNavigator();
    [CompilerGeneratedAttribute]
public void set_TextStructureNavigator(ITextStructureNavigator value);
}
[IsReadOnlyAttribute]
public class Microsoft.VisualStudio.Text.Operations.FinderReplacement : ValueType {
    public Span Match;
    public string Replace;
    public FinderReplacement(Span match, string replace);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Text.Operations.FindOptions : Enum {
    public int value__;
    public static FindOptions None;
    public static FindOptions MatchCase;
    public static FindOptions UseRegularExpressions;
    public static FindOptions WholeWord;
    public static FindOptions SearchReverse;
    public static FindOptions Wrap;
    public static FindOptions Multiline;
    public static FindOptions OrdinalComparison;
    public static FindOptions SingleLine;
    public static FindOptions DoNotUpdateUI;
    public static FindOptions PreserveCase;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Text.Operations.FindScopeOptions : Enum {
    public int value__;
    public static FindScopeOptions None;
    public static FindScopeOptions IncludeMiscellaneousItems;
    public static FindScopeOptions IncludeExternalItems;
    public static FindScopeOptions IncludeSubdirectories;
    public static FindScopeOptions BlockScope;
    public static FindScopeOptions SelectionScope;
    public static FindScopeOptions OpenFolderScope;
}
internal interface Microsoft.VisualStudio.Text.Operations.IEditOnlyTextUndoPrimitive {
    public INormalizedTextChangeCollection Changes { get; }
    public Nullable`1<int> BeforeReiteratedVersionNumber { get; }
    public Nullable`1<int> AfterReiteratedVersionNumber { get; }
    public abstract virtual INormalizedTextChangeCollection get_Changes();
    public abstract virtual Nullable`1<int> get_BeforeReiteratedVersionNumber();
    public abstract virtual Nullable`1<int> get_AfterReiteratedVersionNumber();
}
public interface Microsoft.VisualStudio.Text.Operations.IFinder {
    public string FindWhat { get; }
    public string ReplaceWith { get; }
    public FindOptions Options { get; }
    public ITextSnapshot Snapshot { get; }
    public abstract virtual string get_FindWhat();
    public abstract virtual string get_ReplaceWith();
    public abstract virtual FindOptions get_Options();
    public abstract virtual ITextSnapshot get_Snapshot();
    public abstract virtual bool TryFind(Span& result);
    public abstract virtual bool TryFind(Span searchRange, Span& result);
    public abstract virtual bool TryFind(int startingPosition, Span& result);
    public abstract virtual bool TryFind(int startingPosition, Span searchRange, Span& result);
    public abstract virtual IEnumerable`1<Span> FindAll();
    public abstract virtual IEnumerable`1<Span> FindAll(Span searchRange);
    public abstract virtual bool TryFindForReplace(Span& result, String& expandedReplacePattern);
    public abstract virtual bool TryFindForReplace(Span searchRange, Span& result, String& expandedReplacePattern);
    public abstract virtual bool TryFindForReplace(int startingPosition, Span& result, String& expandedReplacePattern);
    public abstract virtual bool TryFindForReplace(int startingPosition, Span searchRange, Span& result, String& expandedReplacePattern);
    public abstract virtual IEnumerable`1<FinderReplacement> FindForReplaceAll();
    public abstract virtual IEnumerable`1<FinderReplacement> FindForReplaceAll(Span searchRange);
}
public interface Microsoft.VisualStudio.Text.Operations.IFinderFactory {
    public string FindWhat { get; }
    public string ReplaceWith { get; }
    public FindOptions Options { get; }
    public abstract virtual IFinder Create(ITextSnapshot snapshot);
    public abstract virtual string get_FindWhat();
    public abstract virtual string get_ReplaceWith();
    public abstract virtual FindOptions get_Options();
}
internal interface Microsoft.VisualStudio.Text.Operations.IFinderFactory2 {
    public string FindKind { get; }
    public string ScopeName { get; }
    public string Filters { get; }
    public FindScopeOptions ScopeOptions { get; }
    public abstract virtual string get_FindKind();
    public abstract virtual string get_ScopeName();
    public abstract virtual string get_Filters();
    public abstract virtual FindScopeOptions get_ScopeOptions();
}
public interface Microsoft.VisualStudio.Text.Operations.IFindService {
    public abstract virtual IFinderFactory CreateFinderFactory(string findWhat, FindOptions options);
    public abstract virtual IFinderFactory CreateFinderFactory(string findWhat, string replaceWith, FindOptions options);
}
internal interface Microsoft.VisualStudio.Text.Operations.IFindService2 {
    public abstract virtual IFinderFactory2 CreateFinderFactory(string findWhat, string replaceWith, FindOptions options, string findKind, string scopeName, string filters, FindScopeOptions scopeOptions);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Text.Operations.IIndexedTextSearchService {
    public IndexSearchServiceState State { get; }
    internal int TotalFilesIndexed { get; }
    public abstract virtual IndexSearchServiceState get_State();
    public abstract virtual IAsyncEnumerable`1<FileCandidate> GetPotentiallyMatchingFilesAsync(string searchTerm, SearchFileOptions options, CancellationToken cancellationToken);
    internal abstract virtual int get_TotalFilesIndexed();
    internal abstract virtual IAsyncEnumerable`1<SearchMatch> GetAllExactMatchesAsync(string searchTerm, SearchOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal abstract virtual void add_ServiceReadyStateChangedAsync(AsyncEventHandler`1<ServiceStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_ServiceReadyStateChangedAsync(AsyncEventHandler`1<ServiceStateChangedEventArgs> value);
}
public interface Microsoft.VisualStudio.Text.Operations.IMergeTextUndoTransactionPolicy {
    public abstract virtual bool TestCompatiblePolicy(IMergeTextUndoTransactionPolicy other);
    public abstract virtual bool CanMerge(ITextUndoTransaction newerTransaction, ITextUndoTransaction olderTransaction);
    public abstract virtual void PerformTransactionMerge(ITextUndoTransaction existingTransaction, ITextUndoTransaction newTransaction);
}
public enum Microsoft.VisualStudio.Text.Operations.IndexSearchServiceState : Enum {
    public int value__;
    public static IndexSearchServiceState NotAvailable;
    public static IndexSearchServiceState InProgressAccurate;
    public static IndexSearchServiceState InProgressStale;
    public static IndexSearchServiceState Faulted;
    public static IndexSearchServiceState Ready;
}
public interface Microsoft.VisualStudio.Text.Operations.ITextBufferUndoManager {
    public ITextBuffer TextBuffer { get; }
    public ITextUndoHistory TextBufferUndoHistory { get; }
    public abstract virtual ITextBuffer get_TextBuffer();
    public abstract virtual ITextUndoHistory get_TextBufferUndoHistory();
    public abstract virtual void UnregisterUndoHistory();
}
public interface Microsoft.VisualStudio.Text.Operations.ITextBufferUndoManagerProvider {
    public abstract virtual ITextBufferUndoManager GetTextBufferUndoManager(ITextBuffer textBuffer);
    public abstract virtual void RemoveTextBufferUndoManager(ITextBuffer textBuffer);
}
[NullableContextAttribute("2")]
public interface Microsoft.VisualStudio.Text.Operations.ITextSearchNavigator3 {
    public string SearchTerm { get; public set; }
    public string ReplaceTerm { get; public set; }
    public FindOptions SearchOptions { get; public set; }
    public Nullable`1<SnapshotPoint> StartPoint { get; public set; }
    public ITrackingSpan SearchSpan { get; public set; }
    public Nullable`1<SnapshotSpan> CurrentResult { get; }
    public NormalizedSnapshotSpanCollection SearchSpans { get; public set; }
    public abstract virtual string get_SearchTerm();
    public abstract virtual void set_SearchTerm(string value);
    public abstract virtual string get_ReplaceTerm();
    public abstract virtual void set_ReplaceTerm(string value);
    public abstract virtual FindOptions get_SearchOptions();
    public abstract virtual void set_SearchOptions(FindOptions value);
    public abstract virtual Nullable`1<SnapshotPoint> get_StartPoint();
    public abstract virtual void set_StartPoint(Nullable`1<SnapshotPoint> value);
    public abstract virtual ITrackingSpan get_SearchSpan();
    public abstract virtual void set_SearchSpan(ITrackingSpan value);
    public abstract virtual Nullable`1<SnapshotSpan> get_CurrentResult();
    public abstract virtual bool Find();
    public abstract virtual bool Replace();
    public abstract virtual void ClearCurrentResult();
    public abstract virtual NormalizedSnapshotSpanCollection get_SearchSpans();
    public abstract virtual void set_SearchSpans(NormalizedSnapshotSpanCollection value);
}
public interface Microsoft.VisualStudio.Text.Operations.ITextSearchNavigatorFactoryService {
    public abstract virtual ITextSearchNavigator3 CreateSearchNavigator(ITextBuffer buffer);
}
public interface Microsoft.VisualStudio.Text.Operations.ITextSearchService {
    public abstract virtual Nullable`1<SnapshotSpan> FindNext(int startIndex, bool wraparound, FindData findData);
    public abstract virtual Collection`1<SnapshotSpan> FindAll(FindData findData);
}
public interface Microsoft.VisualStudio.Text.Operations.ITextSearchService2 {
    public abstract virtual Nullable`1<SnapshotSpan> Find(SnapshotPoint startingPosition, string searchPattern, FindOptions options);
    public abstract virtual Nullable`1<SnapshotSpan> Find(SnapshotSpan searchRange, SnapshotPoint startingPosition, string searchPattern, FindOptions options);
    public abstract virtual Nullable`1<SnapshotSpan> FindForReplace(SnapshotPoint startingPosition, string searchPattern, string replacePattern, FindOptions options, String& expandedReplacePattern);
    public abstract virtual Nullable`1<SnapshotSpan> FindForReplace(SnapshotSpan searchRange, string searchPattern, string replacePattern, FindOptions options, String& expandedReplacePattern);
    public abstract virtual IEnumerable`1<SnapshotSpan> FindAll(SnapshotSpan searchRange, string searchPattern, FindOptions options);
    public abstract virtual IEnumerable`1<SnapshotSpan> FindAll(SnapshotSpan searchRange, SnapshotPoint startingPosition, string searchPattern, FindOptions options);
    public abstract virtual IEnumerable`1<Tuple`2<SnapshotSpan, string>> FindAllForReplace(SnapshotSpan searchRange, string searchPattern, string replacePattern, FindOptions options);
}
internal interface Microsoft.VisualStudio.Text.Operations.ITextSearchTagger`1 {
    public NormalizedSnapshotSpanCollection SearchSpans { get; public set; }
    public abstract virtual NormalizedSnapshotSpanCollection get_SearchSpans();
    public abstract virtual void set_SearchSpans(NormalizedSnapshotSpanCollection value);
    public abstract virtual void TagTerm(string searchTerm, FindOptions searchOptions, Func`2<SnapshotSpan, T> tagFactory);
    public abstract virtual void ClearTags();
}
internal interface Microsoft.VisualStudio.Text.Operations.ITextSearchTaggerFactoryService {
    public abstract virtual ITextSearchTagger`1<T> CreateTextSearchTagger(ITextBuffer buffer);
}
public interface Microsoft.VisualStudio.Text.Operations.ITextStructureNavigator {
    public IContentType ContentType { get; }
    public abstract virtual TextExtent GetExtentOfWord(SnapshotPoint currentPosition);
    public abstract virtual SnapshotSpan GetSpanOfEnclosing(SnapshotSpan activeSpan);
    public abstract virtual SnapshotSpan GetSpanOfFirstChild(SnapshotSpan activeSpan);
    public abstract virtual SnapshotSpan GetSpanOfNextSibling(SnapshotSpan activeSpan);
    public abstract virtual SnapshotSpan GetSpanOfPreviousSibling(SnapshotSpan activeSpan);
    public abstract virtual IContentType get_ContentType();
}
public interface Microsoft.VisualStudio.Text.Operations.ITextStructureNavigatorProvider {
    public abstract virtual ITextStructureNavigator CreateTextStructureNavigator(ITextBuffer textBuffer);
}
public interface Microsoft.VisualStudio.Text.Operations.ITextStructureNavigatorSelectorService {
    public abstract virtual ITextStructureNavigator GetTextStructureNavigator(ITextBuffer textBuffer);
    public abstract virtual ITextStructureNavigator CreateTextStructureNavigator(ITextBuffer textBuffer, IContentType contentType);
}
public interface Microsoft.VisualStudio.Text.Operations.ITextUndoHistory {
    public IEnumerable`1<ITextUndoTransaction> UndoStack { get; }
    public IEnumerable`1<ITextUndoTransaction> RedoStack { get; }
    public ITextUndoTransaction LastUndoTransaction { get; }
    public ITextUndoTransaction LastRedoTransaction { get; }
    public bool CanUndo { get; }
    public bool CanRedo { get; }
    public string UndoDescription { get; }
    public string RedoDescription { get; }
    public ITextUndoTransaction CurrentTransaction { get; }
    public TextUndoHistoryState State { get; }
    public abstract virtual IEnumerable`1<ITextUndoTransaction> get_UndoStack();
    public abstract virtual IEnumerable`1<ITextUndoTransaction> get_RedoStack();
    public abstract virtual ITextUndoTransaction get_LastUndoTransaction();
    public abstract virtual ITextUndoTransaction get_LastRedoTransaction();
    public abstract virtual bool get_CanUndo();
    public abstract virtual bool get_CanRedo();
    public abstract virtual string get_UndoDescription();
    public abstract virtual string get_RedoDescription();
    public abstract virtual ITextUndoTransaction get_CurrentTransaction();
    public abstract virtual TextUndoHistoryState get_State();
    public abstract virtual ITextUndoTransaction CreateTransaction(string description);
    public abstract virtual void Undo(int count);
    public abstract virtual void Redo(int count);
    [CompilerGeneratedAttribute]
public abstract virtual void add_UndoRedoHappened(EventHandler`1<TextUndoRedoEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UndoRedoHappened(EventHandler`1<TextUndoRedoEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_UndoTransactionCompleted(EventHandler`1<TextUndoTransactionCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UndoTransactionCompleted(EventHandler`1<TextUndoTransactionCompletedEventArgs> value);
}
internal interface Microsoft.VisualStudio.Text.Operations.ITextUndoHistory2 {
    [NullableContextAttribute("1")]
public abstract virtual ITextUndoTransaction CreateInvisibleTransaction(string description);
    public abstract virtual bool IsUndoEnabled();
}
public interface Microsoft.VisualStudio.Text.Operations.ITextUndoHistoryRegistry {
    public abstract virtual ITextUndoHistory RegisterHistory(object context);
    public abstract virtual ITextUndoHistory GetHistory(object context);
    public abstract virtual bool TryGetHistory(object context, ITextUndoHistory& history);
    public abstract virtual void AttachHistory(object context, ITextUndoHistory history);
    public abstract virtual void RemoveHistory(ITextUndoHistory history);
}
public interface Microsoft.VisualStudio.Text.Operations.ITextUndoPrimitive {
    public ITextUndoTransaction Parent { get; public set; }
    public bool CanRedo { get; }
    public bool CanUndo { get; }
    public abstract virtual ITextUndoTransaction get_Parent();
    public abstract virtual void set_Parent(ITextUndoTransaction value);
    public abstract virtual bool get_CanRedo();
    public abstract virtual bool get_CanUndo();
    public abstract virtual void Do();
    public abstract virtual void Undo();
    public abstract virtual bool CanMerge(ITextUndoPrimitive older);
    public abstract virtual ITextUndoPrimitive Merge(ITextUndoPrimitive older);
}
public interface Microsoft.VisualStudio.Text.Operations.ITextUndoTransaction {
    public string Description { get; public set; }
    public UndoTransactionState State { get; }
    public ITextUndoHistory History { get; }
    public IList`1<ITextUndoPrimitive> UndoPrimitives { get; }
    public ITextUndoTransaction Parent { get; }
    public bool CanRedo { get; }
    public bool CanUndo { get; }
    public IMergeTextUndoTransactionPolicy MergePolicy { get; public set; }
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual UndoTransactionState get_State();
    public abstract virtual ITextUndoHistory get_History();
    public abstract virtual IList`1<ITextUndoPrimitive> get_UndoPrimitives();
    public abstract virtual void Complete();
    public abstract virtual void Cancel();
    public abstract virtual void AddUndo(ITextUndoPrimitive undo);
    public abstract virtual ITextUndoTransaction get_Parent();
    public abstract virtual bool get_CanRedo();
    public abstract virtual bool get_CanUndo();
    public abstract virtual void Do();
    public abstract virtual void Undo();
    public abstract virtual IMergeTextUndoTransactionPolicy get_MergePolicy();
    public abstract virtual void set_MergePolicy(IMergeTextUndoTransactionPolicy value);
}
public class Microsoft.VisualStudio.Text.Operations.SearchFileOptions : object {
    [CompilerGeneratedAttribute]
private bool <IncludeMiscellaneousItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeHiddenItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeExternalItems>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Filters>k__BackingField;
    public bool IncludeMiscellaneousItems { get; }
    public bool IncludeHiddenItems { get; }
    public bool IncludeExternalItems { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Filters { get; }
    public SearchFileOptions(bool includeMiscellaneousItems, bool includeHiddenItems, bool includeExternalItems, Nullable`1<ImmutableArray`1<string>> filters);
    [CompilerGeneratedAttribute]
public bool get_IncludeMiscellaneousItems();
    [CompilerGeneratedAttribute]
public bool get_IncludeHiddenItems();
    [CompilerGeneratedAttribute]
public bool get_IncludeExternalItems();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Filters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.VisualStudio.Text.Operations.SearchMatch : ValueType {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MatchPreview>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMatchPreviewTrimmedAtBeginning>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMatchPreviewTrimmedAtEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private Span <MatchSpan>k__BackingField;
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public string FilePath { get; }
    public string MatchPreview { get; }
    public bool IsMatchPreviewTrimmedAtBeginning { get; }
    public bool IsMatchPreviewTrimmedAtEnd { get; }
    public Span MatchSpan { get; }
    public SearchMatch(int lineNumber, int columnNumber, string filePath, string matchPreview, bool isMatchPreviewTrimmedAtBeginning, bool isMatchPreviewTrimmedAtEnd, Span matchSpan);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public string get_MatchPreview();
    [CompilerGeneratedAttribute]
public bool get_IsMatchPreviewTrimmedAtBeginning();
    [CompilerGeneratedAttribute]
public bool get_IsMatchPreviewTrimmedAtEnd();
    [CompilerGeneratedAttribute]
public Span get_MatchSpan();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Text.Operations.SearchOptions : object {
    [CompilerGeneratedAttribute]
private SearchFileOptions <FileOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private FindOptions <FindOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfResultsToRetrieve>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnOnlyIndexedMatches>k__BackingField;
    internal SearchFileOptions FileOptions { get; }
    internal FindOptions FindOptions { get; }
    internal int MaxNumberOfResultsToRetrieve { get; }
    internal bool ReturnOnlyIndexedMatches { get; }
    public SearchOptions(int maxNumberOfResultsToRetrieve, SearchFileOptions fileOptions);
    [CompilerGeneratedAttribute]
internal SearchFileOptions get_FileOptions();
    [CompilerGeneratedAttribute]
internal FindOptions get_FindOptions();
    [CompilerGeneratedAttribute]
internal int get_MaxNumberOfResultsToRetrieve();
    [CompilerGeneratedAttribute]
internal bool get_ReturnOnlyIndexedMatches();
}
internal class Microsoft.VisualStudio.Text.Operations.ServiceStateChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IndexSearchServiceState <OldState>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexSearchServiceState <NewState>k__BackingField;
    public IndexSearchServiceState OldState { get; }
    public IndexSearchServiceState NewState { get; }
    public ServiceStateChangedEventArgs(IndexSearchServiceState oldState, IndexSearchServiceState newState);
    [CompilerGeneratedAttribute]
public IndexSearchServiceState get_OldState();
    [CompilerGeneratedAttribute]
public IndexSearchServiceState get_NewState();
}
public class Microsoft.VisualStudio.Text.Operations.TextExtent : ValueType {
    private SnapshotSpan _span;
    private bool _isSignificant;
    public SnapshotSpan Span { get; }
    public bool IsSignificant { get; }
    public TextExtent(SnapshotSpan span, bool isSignificant);
    public TextExtent(TextExtent textExtent);
    public SnapshotSpan get_Span();
    public bool get_IsSignificant();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TextExtent extent1, TextExtent extent2);
    public static bool op_Inequality(TextExtent extent1, TextExtent extent2);
}
public enum Microsoft.VisualStudio.Text.Operations.TextUndoHistoryState : Enum {
    public int value__;
    public static TextUndoHistoryState Idle;
    public static TextUndoHistoryState Undoing;
    public static TextUndoHistoryState Redoing;
}
public class Microsoft.VisualStudio.Text.Operations.TextUndoRedoEventArgs : EventArgs {
    private TextUndoHistoryState state;
    private ITextUndoTransaction transaction;
    public ITextUndoTransaction Transaction { get; }
    public TextUndoHistoryState State { get; }
    public TextUndoRedoEventArgs(TextUndoHistoryState state, ITextUndoTransaction transaction);
    public ITextUndoTransaction get_Transaction();
    public TextUndoHistoryState get_State();
}
public class Microsoft.VisualStudio.Text.Operations.TextUndoTransactionCompletedEventArgs : EventArgs {
    private ITextUndoTransaction transaction;
    private TextUndoTransactionCompletionResult result;
    public ITextUndoTransaction Transaction { get; }
    public TextUndoTransactionCompletionResult Result { get; }
    public TextUndoTransactionCompletedEventArgs(ITextUndoTransaction transaction, TextUndoTransactionCompletionResult result);
    public ITextUndoTransaction get_Transaction();
    public TextUndoTransactionCompletionResult get_Result();
}
public enum Microsoft.VisualStudio.Text.Operations.TextUndoTransactionCompletionResult : Enum {
    public int value__;
    public static TextUndoTransactionCompletionResult TransactionAdded;
    public static TextUndoTransactionCompletionResult TransactionMerged;
}
public enum Microsoft.VisualStudio.Text.Operations.UndoTransactionState : Enum {
    public int value__;
    public static UndoTransactionState Open;
    public static UndoTransactionState Completed;
    public static UndoTransactionState Canceled;
    public static UndoTransactionState Redoing;
    public static UndoTransactionState Undoing;
    public static UndoTransactionState Undone;
    public static UndoTransactionState Invalid;
}
public interface Microsoft.VisualStudio.Text.PatternMatching.IPatternMatcher {
    public bool HasInvalidPattern { get; }
    public abstract virtual Nullable`1<PatternMatch> TryMatch(string candidate);
    public abstract virtual bool get_HasInvalidPattern();
}
public interface Microsoft.VisualStudio.Text.PatternMatching.IPatternMatcherFactory {
    public abstract virtual IPatternMatcher CreatePatternMatcher(string pattern, PatternMatcherCreationOptions creationOptions);
}
public interface Microsoft.VisualStudio.Text.PatternMatching.IPatternMatcherFactory2 {
    public abstract virtual IPatternMatcher CreatePatternMatcher(string pattern, PatternMatcherCreationOptions creationOptions, IPatternMatcher linkedMatcher);
}
public class Microsoft.VisualStudio.Text.PatternMatching.PatternMatch : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsCaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternMatchKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Span> <MatchedSpans>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPunctuationStripped>k__BackingField;
    public bool IsCaseSensitive { get; }
    public PatternMatchKind Kind { get; }
    public ImmutableArray`1<Span> MatchedSpans { get; }
    public bool IsPunctuationStripped { get; }
    public PatternMatch(PatternMatchKind resultType, bool punctuationStripped, bool isCaseSensitive);
    public PatternMatch(PatternMatchKind resultType, bool punctuationStripped, bool isCaseSensitive, ImmutableArray`1<Span> matchedSpans);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsCaseSensitive();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PatternMatchKind get_Kind();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ImmutableArray`1<Span> get_MatchedSpans();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsPunctuationStripped();
    public PatternMatch WithMatchedSpans(ImmutableArray`1<Span> matchedSpans);
    public sealed virtual int CompareTo(PatternMatch other);
    public int CompareTo(PatternMatch other, bool ignoreCase);
    private static int ComparePunctuation(PatternMatch result1, PatternMatch result2);
    private static int CompareCase(PatternMatch result1, PatternMatch result2, bool ignoreCase);
    private static int CompareType(PatternMatch result1, PatternMatch result2);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Text.PatternMatching.PatternMatcherCreationFlags : Enum {
    public int value__;
    public static PatternMatcherCreationFlags None;
    public static PatternMatcherCreationFlags AllowFuzzyMatching;
    public static PatternMatcherCreationFlags IncludeMatchedSpans;
    public static PatternMatcherCreationFlags AllowSimpleSubstringMatching;
}
public class Microsoft.VisualStudio.Text.PatternMatching.PatternMatcherCreationOptions : object {
    public CultureInfo CultureInfo;
    public PatternMatcherCreationFlags Flags;
    public IReadOnlyCollection`1<char> ContainerSplitCharacters;
    public PatternMatcherCreationOptions(CultureInfo cultureInfo, PatternMatcherCreationFlags flags, IReadOnlyCollection`1<char> containerSplitCharacters);
}
public enum Microsoft.VisualStudio.Text.PatternMatching.PatternMatchKind : Enum {
    public int value__;
    public static PatternMatchKind Exact;
    public static PatternMatchKind Prefix;
    public static PatternMatchKind Substring;
    public static PatternMatchKind CamelCaseExact;
    public static PatternMatchKind CamelCasePrefix;
    public static PatternMatchKind CamelCaseNonContiguousPrefix;
    public static PatternMatchKind CamelCaseSubstring;
    public static PatternMatchKind CamelCaseNonContiguousSubstring;
    public static PatternMatchKind Fuzzy;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Text.PatternMatching.PatternMatchKindExtensions : object {
    [ExtensionAttribute]
public static int CompareTo(PatternMatchKind kind1, PatternMatchKind kind2);
}
public class Microsoft.VisualStudio.Text.Tagging.BatchedTagsChangedEventArgs : EventArgs {
    private ReadOnlyCollection`1<IMappingSpan> _spans;
    public ReadOnlyCollection`1<IMappingSpan> Spans { get; }
    public BatchedTagsChangedEventArgs(IList`1<IMappingSpan> spans);
    public ReadOnlyCollection`1<IMappingSpan> get_Spans();
}
[ObsoleteAttribute("Class has not been finalized and may change without warning.")]
public class Microsoft.VisualStudio.Text.Tagging.BracePairTag : object {
    [CompilerGeneratedAttribute]
private Nullable`1<SnapshotSpan> <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SnapshotSpan> <End>k__BackingField;
    public Nullable`1<SnapshotSpan> Start { get; }
    public Nullable`1<SnapshotSpan> End { get; }
    public BracePairTag(Nullable`1<SnapshotSpan> start, Nullable`1<SnapshotSpan> end);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<SnapshotSpan> get_Start();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<SnapshotSpan> get_End();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Text.Tagging.BraceTag : object {
    [CompilerGeneratedAttribute]
private SnapshotSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CloseMatch>k__BackingField;
    public SnapshotSpan Span { get; }
    public string CloseMatch { get; }
    public bool IsOpenBrace { get; }
    public BraceTag(SnapshotSpan span, string closeMatch);
    [CompilerGeneratedAttribute]
public SnapshotSpan get_Span();
    [CompilerGeneratedAttribute]
public string get_CloseMatch();
    public bool get_IsOpenBrace();
}
public class Microsoft.VisualStudio.Text.Tagging.ClassificationTag : object {
    [CompilerGeneratedAttribute]
private IClassificationType <ClassificationType>k__BackingField;
    public IClassificationType ClassificationType { get; private set; }
    public ClassificationTag(IClassificationType type);
    [CompilerGeneratedAttribute]
public sealed virtual IClassificationType get_ClassificationType();
    [CompilerGeneratedAttribute]
private void set_ClassificationType(IClassificationType value);
}
public interface Microsoft.VisualStudio.Text.Tagging.IAccurateTagAggregator`1 {
    public abstract virtual IEnumerable`1<IMappingTagSpan`1<T>> GetAllTags(SnapshotSpan span, CancellationToken cancel);
    public abstract virtual IEnumerable`1<IMappingTagSpan`1<T>> GetAllTags(IMappingSpan span, CancellationToken cancel);
    public abstract virtual IEnumerable`1<IMappingTagSpan`1<T>> GetAllTags(NormalizedSnapshotSpanCollection snapshotSpans, CancellationToken cancel);
}
public interface Microsoft.VisualStudio.Text.Tagging.IAccurateTagger`1 {
    public abstract virtual IEnumerable`1<ITagSpan`1<T>> GetAllTags(NormalizedSnapshotSpanCollection spans, CancellationToken cancel);
}
[ObsoleteAttribute("Class has not been finalized and may change without warning.")]
public interface Microsoft.VisualStudio.Text.Tagging.IBracePairTag {
    public Nullable`1<SnapshotSpan> Start { get; }
    public Nullable`1<SnapshotSpan> End { get; }
    public abstract virtual Nullable`1<SnapshotSpan> get_Start();
    public abstract virtual Nullable`1<SnapshotSpan> get_End();
}
public interface Microsoft.VisualStudio.Text.Tagging.IBufferTagAggregatorFactoryService {
    public abstract virtual ITagAggregator`1<T> CreateTagAggregator(ITextBuffer textBuffer);
    public abstract virtual ITagAggregator`1<T> CreateTagAggregator(ITextBuffer textBuffer, TagAggregatorOptions options);
}
public interface Microsoft.VisualStudio.Text.Tagging.IClassificationTag {
    public IClassificationType ClassificationType { get; }
    public abstract virtual IClassificationType get_ClassificationType();
}
public interface Microsoft.VisualStudio.Text.Tagging.IMappingTagSpan`1 {
    public T Tag { get; }
    public IMappingSpan Span { get; }
    public abstract virtual T get_Tag();
    public abstract virtual IMappingSpan get_Span();
}
public interface Microsoft.VisualStudio.Text.Tagging.ITag {
}
public interface Microsoft.VisualStudio.Text.Tagging.ITagAggregator`1 {
    public IBufferGraph BufferGraph { get; }
    public abstract virtual IEnumerable`1<IMappingTagSpan`1<T>> GetTags(SnapshotSpan span);
    public abstract virtual IEnumerable`1<IMappingTagSpan`1<T>> GetTags(IMappingSpan span);
    public abstract virtual IEnumerable`1<IMappingTagSpan`1<T>> GetTags(NormalizedSnapshotSpanCollection snapshotSpans);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TagsChanged(EventHandler`1<TagsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TagsChanged(EventHandler`1<TagsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BatchedTagsChanged(EventHandler`1<BatchedTagsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BatchedTagsChanged(EventHandler`1<BatchedTagsChangedEventArgs> value);
    public abstract virtual IBufferGraph get_BufferGraph();
}
public interface Microsoft.VisualStudio.Text.Tagging.ITagger`1 {
    public abstract virtual IEnumerable`1<ITagSpan`1<T>> GetTags(NormalizedSnapshotSpanCollection spans);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TagsChanged(EventHandler`1<SnapshotSpanEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TagsChanged(EventHandler`1<SnapshotSpanEventArgs> value);
}
public interface Microsoft.VisualStudio.Text.Tagging.ITaggerProvider {
    public abstract virtual ITagger`1<T> CreateTagger(ITextBuffer buffer);
}
public interface Microsoft.VisualStudio.Text.Tagging.ITagSpan`1 {
    public T Tag { get; }
    public SnapshotSpan Span { get; }
    public abstract virtual T get_Tag();
    public abstract virtual SnapshotSpan get_Span();
}
public interface Microsoft.VisualStudio.Text.Tagging.IUrlTag {
    public Uri Url { get; }
    public abstract virtual Uri get_Url();
}
public class Microsoft.VisualStudio.Text.Tagging.MappingTagSpan`1 : object {
    [CompilerGeneratedAttribute]
private T <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private IMappingSpan <Span>k__BackingField;
    public T Tag { get; private set; }
    public IMappingSpan Span { get; private set; }
    public MappingTagSpan`1(IMappingSpan span, T tag);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Tag();
    [CompilerGeneratedAttribute]
private void set_Tag(T value);
    [CompilerGeneratedAttribute]
public sealed virtual IMappingSpan get_Span();
    [CompilerGeneratedAttribute]
private void set_Span(IMappingSpan value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.VisualStudio.Text.Tagging.RefCountedSimpleTagger`1 : SimpleTagger`1<T> {
    internal int refCount;
    private ITextBuffer buffer;
    public RefCountedSimpleTagger`1(ITextBuffer buffer);
    public void AddRef();
    public void ReleaseRef();
    protected virtual void InitializeRefCountedObject();
    protected virtual void ReleaseRefCountedObject();
    public sealed virtual void Dispose();
    public static ITagger`1<T> GetOrCreate(ITextBuffer buffer);
    internal static RefCountedSimpleTagger`1<T> GetTagger(ITextBuffer buffer);
}
public class Microsoft.VisualStudio.Text.Tagging.SimpleTagger`1 : object {
    private List`1<TrackingTagSpan`1<T>> _trackingTagSpans;
    private ITextBuffer buffer;
    private object mutex;
    private int _batchNesting;
    private ITrackingSpan _batchSpan;
    [CompilerGeneratedAttribute]
private EventHandler`1<SnapshotSpanEventArgs> TagsChanged;
    public SimpleTagger`1(ITextBuffer buffer);
    private void StartBatch();
    private void EndBatch();
    private void UpdateBatchSpan(ITrackingSpan snapshotSpan);
    public TrackingTagSpan`1<T> CreateTagSpan(ITrackingSpan span, T tag);
    public bool RemoveTagSpan(TrackingTagSpan`1<T> tagSpan);
    public int RemoveTagSpans(Predicate`1<TrackingTagSpan`1<T>> match);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Text.Tagging.SimpleTagger`1/<GetTaggedSpans>d__12")]
public IEnumerable`1<TrackingTagSpan`1<T>> GetTaggedSpans(SnapshotSpan span);
    public IDisposable Update();
    public sealed virtual IEnumerable`1<ITagSpan`1<T>> GetTags(NormalizedSnapshotSpanCollection spans);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TagsChanged(EventHandler`1<SnapshotSpanEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TagsChanged(EventHandler`1<SnapshotSpanEventArgs> value);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Text.Tagging.SimpleTagger`1/<<GetTags>g__GetTagsImpl|14_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<ITagSpan`1<T>> <GetTags>g__GetTagsImpl|14_0(TrackingTagSpan`1[] tagSpans, NormalizedSnapshotSpanCollection querySpans);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Text.Tagging.TagAggregatorOptions : Enum {
    public int value__;
    public static TagAggregatorOptions None;
    public static TagAggregatorOptions MapByContentType;
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Text.Tagging.TagAggregatorOptions2 : Enum {
    public int value__;
    public static TagAggregatorOptions2 None;
    public static TagAggregatorOptions2 MapByContentType;
    public static TagAggregatorOptions2 DeferTaggerCreation;
    public static TagAggregatorOptions2 NoProjection;
}
public class Microsoft.VisualStudio.Text.Tagging.TagsChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IMappingSpan <Span>k__BackingField;
    public IMappingSpan Span { get; private set; }
    public TagsChangedEventArgs(IMappingSpan span);
    [CompilerGeneratedAttribute]
public IMappingSpan get_Span();
    [CompilerGeneratedAttribute]
private void set_Span(IMappingSpan value);
}
public class Microsoft.VisualStudio.Text.Tagging.TagSpan`1 : object {
    [CompilerGeneratedAttribute]
private T <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private SnapshotSpan <Span>k__BackingField;
    public T Tag { get; private set; }
    public SnapshotSpan Span { get; private set; }
    public TagSpan`1(SnapshotSpan span, T tag);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Tag();
    [CompilerGeneratedAttribute]
private void set_Tag(T value);
    [CompilerGeneratedAttribute]
public sealed virtual SnapshotSpan get_Span();
    [CompilerGeneratedAttribute]
private void set_Span(SnapshotSpan value);
}
public class Microsoft.VisualStudio.Text.Tagging.TagTypeAttribute : MultipleBaseMetadataAttribute {
    private Type type;
    public Type TagTypes { get; }
    public TagTypeAttribute(Type tagType);
    public Type get_TagTypes();
}
public class Microsoft.VisualStudio.Text.Tagging.TrackingTagSpan`1 : object {
    [CompilerGeneratedAttribute]
private T <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private ITrackingSpan <Span>k__BackingField;
    public T Tag { get; private set; }
    public ITrackingSpan Span { get; private set; }
    public TrackingTagSpan`1(ITrackingSpan span, T tag);
    [CompilerGeneratedAttribute]
public T get_Tag();
    [CompilerGeneratedAttribute]
private void set_Tag(T value);
    [CompilerGeneratedAttribute]
public ITrackingSpan get_Span();
    [CompilerGeneratedAttribute]
private void set_Span(ITrackingSpan value);
}
public class Microsoft.VisualStudio.Text.Tagging.UrlTag : object {
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    public Uri Url { get; private set; }
    public UrlTag(Uri url);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Url();
    [CompilerGeneratedAttribute]
private void set_Url(Uri value);
}
public class Microsoft.VisualStudio.Text.TextDataModelContentTypeChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IContentType <BeforeContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private IContentType <AfterContentType>k__BackingField;
    public IContentType BeforeContentType { get; private set; }
    public IContentType AfterContentType { get; private set; }
    public TextDataModelContentTypeChangedEventArgs(IContentType beforeContentType, IContentType afterContentType);
    [CompilerGeneratedAttribute]
public IContentType get_BeforeContentType();
    [CompilerGeneratedAttribute]
private void set_BeforeContentType(IContentType value);
    [CompilerGeneratedAttribute]
public IContentType get_AfterContentType();
    [CompilerGeneratedAttribute]
private void set_AfterContentType(IContentType value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Text.TextSnapshotExtensions : object {
    private static char Space;
    private static char Tab;
    private static int LineBrowsingLimit;
    [ExtensionAttribute]
internal static bool StartsWith(ITextSnapshot snapshot, string value);
    [ExtensionAttribute]
internal static bool StartsWith(ITextSnapshot snapshot, string value, int startIndex);
    [ExtensionAttribute]
internal static bool StartsWith(SnapshotSpan span, string value);
    [ExtensionAttribute]
internal static bool StartsWith(ITextSnapshot snapshot, char value);
    [ExtensionAttribute]
internal static bool StartsWith(ITextSnapshot snapshot, char value, int startIndex);
    [ExtensionAttribute]
internal static bool StartsWith(SnapshotSpan span, char value);
    [ExtensionAttribute]
internal static ITrackingSpan CreateTrackingSpan(SnapshotSpan span, SpanTrackingMode mode, TrackingFidelityMode fidelity);
    [ExtensionAttribute]
internal static bool StartsWith(SnapshotPoint startPoint, string value);
    [ExtensionAttribute]
internal static bool StartsWith(SnapshotPoint startPoint, char value);
    [ExtensionAttribute]
internal static bool EndsWith(ITextSnapshot snapshot, string value);
    [ExtensionAttribute]
internal static bool EndsWith(ITextSnapshot snapshot, string value, int startIndex);
    [ExtensionAttribute]
internal static bool EndsWith(SnapshotSpan span, string value);
    [ExtensionAttribute]
internal static bool EndsWith(SnapshotPoint startPoint, string value);
    [ExtensionAttribute]
internal static int IndexOf(SnapshotPoint startPoint, string value);
    [ExtensionAttribute]
internal static int IndexOf(SnapshotSpan span, string value);
    [ExtensionAttribute]
internal static int IndexOf(SnapshotSpan span, string value, int startIndex);
    [ExtensionAttribute]
internal static int IndexOf(ITextSnapshot snapshot, string value);
    [ExtensionAttribute]
internal static int IndexOf(ITextSnapshot snapshot, string value, int startIndex);
    [ExtensionAttribute]
internal static int IndexOf(SnapshotPoint startPoint, char value);
    [ExtensionAttribute]
internal static int IndexOf(SnapshotSpan span, char value);
    [ExtensionAttribute]
internal static int IndexOf(SnapshotSpan span, char value, int startIndex);
    [ExtensionAttribute]
internal static IReadOnlyList`1<SnapshotSpan> Split(SnapshotSpan span, char value);
    [ExtensionAttribute]
internal static int IndexOf(ITextSnapshot snapshot, char value);
    [ExtensionAttribute]
internal static int IndexOf(ITextSnapshot snapshot, char value, int startIndex);
    [ExtensionAttribute]
internal static int IndexOf(ITextSnapshot snapshot, string value, int startIndex, int endIndex);
    [ExtensionAttribute]
internal static int IndexOf(ITextSnapshot snapshot, char value, int startIndex, int endIndex);
    [ExtensionAttribute]
internal static int LastIndexOf(SnapshotPoint startPoint, string value);
    [ExtensionAttribute]
internal static int LastIndexOf(SnapshotSpan span, string value);
    [ExtensionAttribute]
internal static int LastIndexOf(ITextSnapshot snapshot, string value);
    [ExtensionAttribute]
internal static int LastIndexOf(ITextSnapshot snapshot, string value, int startIndex);
    [ExtensionAttribute]
private static int LastIndexOf(ITextSnapshot snapshot, string value, int startIndex, int endIndex);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetPreviousNonWhitespace(ITextSnapshotLine line, SnapshotPoint startPoint);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetPreviousNonWhitespace(SnapshotPoint startPoint);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetPreviousNonWhitespace(SnapshotPoint startPoint, bool includeLineBreak);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetPreviousNonWhitespace(SnapshotSpan snapshotSpan);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetPreviousNonWhitespace(SnapshotSpan snapshotSpan, bool includeLineBreak);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetPreviousNonWhitespace(SnapshotSpan snapshotSpan, SnapshotPoint startPoint);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetPreviousNonWhitespace(SnapshotSpan snapshotSpan, SnapshotPoint startPoint, bool includeLineBreak);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetFirstNonWhitespace(ITextSnapshotLine line);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetFirstNonWhitespace(SnapshotPoint startPoint);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetFirstNonWhitespace(SnapshotPoint startPoint, bool includeLineBreak);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetFirstNonWhitespace(SnapshotSpan snapshotSpan);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetFirstNonWhitespace(SnapshotSpan snapshotSpan, bool includeLineBreak);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetFirstNonWhitespace(SnapshotSpan snapshotSpan, SnapshotPoint startPoint);
    [ExtensionAttribute]
internal static Nullable`1<SnapshotPoint> GetFirstNonWhitespace(SnapshotSpan snapshotSpan, SnapshotPoint startPoint, bool includeLineBreak);
    [ExtensionAttribute]
internal static ITextSnapshotLine GetNextLine(ITextSnapshotLine line);
    [ExtensionAttribute]
internal static ITextSnapshotLine GetPreviousLine(ITextSnapshotLine line);
    [ExtensionAttribute]
internal static ITextSnapshotLine GetPreviousNonEmptyLine(ITextSnapshotLine line);
    [ExtensionAttribute]
internal static bool IsEmptyOrWhitespace(ITextSnapshotLine line);
    [ExtensionAttribute]
internal static bool IsEmptyOrWhitespace(SnapshotSpan span);
    [ExtensionAttribute]
internal static bool IsEmptyOrWhitespace(SnapshotSpan span, bool includeLineBreak);
    [ExtensionAttribute]
internal static int GetLineNumber(SnapshotPoint snapshotPoint);
    [ExtensionAttribute]
internal static int GetCurrentIndentation(ITextSnapshotLine line, int tabSize);
}
internal class Microsoft.VisualStudio.Text.Utilities.DeferCreationAttributeHelper`1 : object {
    private Lazy`1<Dictionary`2<string, List`1<T>>> _deferredAssets;
    private bool _isSubscribedToFirstOptionChangeEventOnly;
    private IDeferCreationHandler _deferCreationHandler;
    private IEditorOptions _editorOptions;
    [CompilerGeneratedAttribute]
private DeferredAssetRequestedEventHandler<T> DeferredAssetRequested;
    public DeferCreationAttributeHelper`1(IDeferCreationHandler deferCreationHandler, bool subscribeToFirstOptionChangeEventOnly);
    [CompilerGeneratedAttribute]
public void add_DeferredAssetRequested(DeferredAssetRequestedEventHandler<T> value);
    [CompilerGeneratedAttribute]
public void remove_DeferredAssetRequested(DeferredAssetRequestedEventHandler<T> value);
    public bool TryDeferCreation(string optionName, T asset, bool subscribeEvenIfNotDeferred);
    public void Unsubscribe();
    public IReadOnlyList`1<T> GetDeferredEditorAssetsForOption(string optionName);
    public bool IsOptionRegistered(string optionName);
    public bool AreAnyAssetsDeferred();
    public sealed virtual void Dispose();
    public bool IsAssetDeferred(string optionName, Boolean& isBoolOptionDefined);
    private bool IsOptionDefined(string optionName);
    private void SubscribeToOptionChangedEvent(string optionName, T asset);
    private void EditorOptions_OptionChanged(object sender, EditorOptionChangedEventArgs e);
}
internal class Microsoft.VisualStudio.Text.Utilities.DeferCreationRequestedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private List`1<T> <Assets>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OptionName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OptionValue>k__BackingField;
    public List`1<T> Assets { get; }
    public string OptionName { get; }
    public bool OptionValue { get; }
    public DeferCreationRequestedEventArgs`1(string optionName, bool optionValue, List`1<T> assets);
    [CompilerGeneratedAttribute]
public List`1<T> get_Assets();
    [CompilerGeneratedAttribute]
public string get_OptionName();
    [CompilerGeneratedAttribute]
public bool get_OptionValue();
}
internal interface Microsoft.VisualStudio.Text.Utilities.IDeferCreationHandler {
    public IEditorOptions EditorOptions { get; }
    public abstract virtual IEditorOptions get_EditorOptions();
}
public class Microsoft.VisualStudio.Text.VirtualSnapshotPoint : ValueType {
    private SnapshotPoint _position;
    private int _virtualSpaces;
    public SnapshotPoint Position { get; }
    public int VirtualSpaces { get; }
    public bool IsInVirtualSpace { get; }
    public VirtualSnapshotPoint(SnapshotPoint position);
    public VirtualSnapshotPoint(ITextSnapshot snapshot, int position);
    public VirtualSnapshotPoint(SnapshotPoint position, int virtualSpaces);
    public VirtualSnapshotPoint(ITextSnapshotLine line, int offset);
    public SnapshotPoint get_Position();
    public int get_VirtualSpaces();
    public bool get_IsInVirtualSpace();
    public virtual int GetHashCode();
    public VirtualSnapshotPoint TranslateTo(ITextSnapshot snapshot);
    public VirtualSnapshotPoint TranslateTo(ITextSnapshot snapshot, PointTrackingMode trackingMode);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool op_Equality(VirtualSnapshotPoint left, VirtualSnapshotPoint right);
    public static bool op_Inequality(VirtualSnapshotPoint left, VirtualSnapshotPoint right);
    public static bool op_GreaterThan(VirtualSnapshotPoint left, VirtualSnapshotPoint right);
    public static bool op_GreaterThanOrEqual(VirtualSnapshotPoint left, VirtualSnapshotPoint right);
    public static bool op_LessThan(VirtualSnapshotPoint left, VirtualSnapshotPoint right);
    public static bool op_LessThanOrEqual(VirtualSnapshotPoint left, VirtualSnapshotPoint right);
    public sealed virtual int CompareTo(VirtualSnapshotPoint other);
    private static bool CharacterDeleted(SnapshotPoint position, ITextSnapshot snapshot);
}
public class Microsoft.VisualStudio.Text.VirtualSnapshotSpan : ValueType {
    private VirtualSnapshotPoint _start;
    private VirtualSnapshotPoint _end;
    public VirtualSnapshotPoint Start { get; }
    public VirtualSnapshotPoint End { get; }
    public ITextSnapshot Snapshot { get; }
    public int Length { get; }
    public SnapshotSpan SnapshotSpan { get; }
    public bool IsInVirtualSpace { get; }
    public bool IsEmpty { get; }
    public VirtualSnapshotSpan(SnapshotSpan snapshotSpan);
    public VirtualSnapshotSpan(VirtualSnapshotPoint start, VirtualSnapshotPoint end);
    public VirtualSnapshotPoint get_Start();
    public VirtualSnapshotPoint get_End();
    public ITextSnapshot get_Snapshot();
    public int get_Length();
    public string GetText();
    public SnapshotSpan get_SnapshotSpan();
    public bool get_IsInVirtualSpace();
    public bool get_IsEmpty();
    public bool Contains(VirtualSnapshotPoint virtualPoint);
    public bool Contains(VirtualSnapshotSpan virtualSpan);
    public bool OverlapsWith(VirtualSnapshotSpan virtualSpan);
    public Nullable`1<VirtualSnapshotSpan> Overlap(VirtualSnapshotSpan virtualSpan);
    public bool IntersectsWith(VirtualSnapshotSpan virtualSpan);
    public Nullable`1<VirtualSnapshotSpan> Intersection(VirtualSnapshotSpan virtualSpan);
    public virtual int GetHashCode();
    public VirtualSnapshotSpan TranslateTo(ITextSnapshot snapshot);
    public VirtualSnapshotSpan TranslateTo(ITextSnapshot snapshot, SpanTrackingMode trackingMode);
    private static PointTrackingMode GetStartPointMode(SpanTrackingMode trackingMode);
    private static PointTrackingMode GetEndPointMode(SpanTrackingMode trackingMode);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool op_Equality(VirtualSnapshotSpan left, VirtualSnapshotSpan right);
    public static bool op_Inequality(VirtualSnapshotSpan left, VirtualSnapshotSpan right);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.5.107.25444")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
