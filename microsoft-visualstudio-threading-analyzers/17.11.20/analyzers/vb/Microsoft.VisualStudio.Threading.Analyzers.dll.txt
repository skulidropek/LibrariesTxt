[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Threading.Analyzers.AbstractVSTHRD001UseSwitchToMainThreadAsyncAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected LanguageUtils LanguageUtils { get; }
    private static AbstractVSTHRD001UseSwitchToMainThreadAsyncAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected abstract virtual LanguageUtils get_LanguageUtils();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext compilationStartContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Threading.Analyzers.AbstractVSTHRD004AwaitSwitchToMainThreadAsyncAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected LanguageUtils LanguageUtils { get; }
    private static AbstractVSTHRD004AwaitSwitchToMainThreadAsyncAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected abstract virtual LanguageUtils get_LanguageUtils();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Threading.Analyzers.AbstractVSTHRD011UseAsyncLazyAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor LazyOfTaskDescriptor;
    internal static DiagnosticDescriptor SyncBlockInValueFactoryDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected LanguageUtils LanguageUtils { get; }
    private static AbstractVSTHRD011UseAsyncLazyAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected abstract virtual LanguageUtils get_LanguageUtils();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeNode(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Threading.Analyzers.AbstractVSTHRD012SpecifyJtfWhereAllowed : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected LanguageUtils LanguageUtils { get; }
    private static AbstractVSTHRD012SpecifyJtfWhereAllowed();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected abstract virtual LanguageUtils get_LanguageUtils();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsImportantJtfParameter(IParameterSymbol ps);
    private static IArgumentOperation GetArgumentForParameter(ImmutableArray`1<IArgumentOperation> arguments, IParameterSymbol parameter);
    private static void AnalyzeCall(OperationAnalysisContext context, Location location, ImmutableArray`1<IArgumentOperation> argList, IMethodSymbol methodSymbol, IEnumerable`1<IMethodSymbol> otherOverloads);
    private void AnalyzeInvocation(OperationAnalysisContext context);
    private void AnalyzeObjectCreation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Threading.Analyzers.AbstractVSTHRD105AvoidImplicitTaskSchedulerCurrentAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected LanguageUtils LanguageUtils { get; }
    private static AbstractVSTHRD105AvoidImplicitTaskSchedulerCurrentAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected abstract virtual LanguageUtils get_LanguageUtils();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Threading.Analyzers.AbstractVSTHRD108AssertThreadRequirementUnconditionally : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected LanguageUtils LanguageUtils { get; }
    private static AbstractVSTHRD108AssertThreadRequirementUnconditionally();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected abstract virtual LanguageUtils get_LanguageUtils();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsInConditional(IOperation operation);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Threading.Analyzers.AbstractVSTHRD108AssertThreadRequirementUnconditionally/<GetAncestorsWithinMethod>d__8")]
private static IEnumerable`1<IOperation> GetAncestorsWithinMethod(IOperation operation);
    private static bool IsArgInInvocationToConditionalMethod(OperationAnalysisContext context);
    [NullableContextAttribute("0")]
private void AnalyzeInvocation(OperationAnalysisContext context, ImmutableArray`1<QualifiedMember> mainThreadAssertingMethods);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext ctxt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Threading.Analyzers.AbstractVSTHRD109AvoidAssertInAsyncMethodsAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected LanguageUtils LanguageUtils { get; }
    private static AbstractVSTHRD109AvoidAssertInAsyncMethodsAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected abstract virtual LanguageUtils get_LanguageUtils();
    public virtual void Initialize(AnalysisContext context);
    [NullableContextAttribute("0")]
private void AnalyzeInvocation(OperationAnalysisContext context, ImmutableArray`1<QualifiedMember> mainThreadAssertingMethods);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext ctxt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Threading.Analyzers.AbstractVSTHRD110ObserveResultOfAsyncCallsAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected LanguageUtils LanguageUtils { get; }
    private static AbstractVSTHRD110ObserveResultOfAsyncCallsAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected abstract virtual LanguageUtils get_LanguageUtils();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context, AwaitableTypeTester awaitableTypes);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Threading.Analyzers.AbstractVSTHRD112ImplementSystemIAsyncDisposableAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected LanguageUtils LanguageUtils { get; }
    private static AbstractVSTHRD112ImplementSystemIAsyncDisposableAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected abstract virtual LanguageUtils get_LanguageUtils();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeType(SymbolAnalysisContext context, INamedTypeSymbol vsThreadingAsyncDisposableType, INamedTypeSymbol bclAsyncDisposableType);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext startCompilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Threading.Analyzers.AbstractVSTHRD114AvoidReturningNullTaskAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected LanguageUtils LanguageUtils { get; }
    private static AbstractVSTHRD114AvoidReturningNullTaskAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected abstract virtual LanguageUtils get_LanguageUtils();
    public virtual void Initialize(AnalysisContext context);
    private static IMethodSymbol FindOwningSymbol(IBlockOperation block, ISymbol containingSymbol);
    private void AnalyzerReturnOperation(OperationAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Threading.Analyzers.CommonInterest : object {
    internal static Regex FileNamePatternForLegacyThreadSwitchingMembers;
    internal static Regex FileNamePatternForMembersRequiringMainThread;
    internal static Regex FileNamePatternForMethodsThatAssertMainThread;
    internal static Regex FileNamePatternForMethodsThatSwitchToMainThread;
    internal static IEnumerable`1<SyncBlockingMethod> JTFSyncBlockers;
    internal static IEnumerable`1<SyncBlockingMethod> ProblematicSyncBlockingMethods;
    internal static IEnumerable`1<SyncBlockingMethod> SyncBlockingMethods;
    internal static IReadOnlyList`1<SyncBlockingMethod> SyncBlockingProperties;
    internal static IEnumerable`1<QualifiedMember> ThreadAffinityTestingMethods;
    [NullableAttribute("0")]
internal static ImmutableArray`1<QualifiedMember> TaskConfigureAwait;
    private static RegexOptions FileNamePatternRegexOptions;
    private static string GetAwaiterMethodName;
    private static TimeSpan RegexMatchTimeout;
    private static Regex NegatableTypeOrMemberReferenceRegex;
    private static Regex MemberReferenceRegex;
    private static Char[] QualifiedIdentifierSeparators;
    private static CommonInterest();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Threading.Analyzers.CommonInterest/<ReadMethods>d__16")]
internal static IEnumerable`1<QualifiedMember> ReadMethods(AnalyzerOptions analyzerOptions, Regex fileNamePattern, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Threading.Analyzers.CommonInterest/<ReadTypesAndMembers>d__17")]
internal static IEnumerable`1<TypeMatchSpec> ReadTypesAndMembers(AnalyzerOptions analyzerOptions, Regex fileNamePattern, CancellationToken cancellationToken);
    internal static IEnumerable`1<string> ReadAdditionalFiles(AnalyzerOptions analyzerOptions, Regex fileNamePattern, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static bool Contains(ImmutableArray`1<QualifiedMember> methods, ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool Contains(ImmutableArray`1<TypeMatchSpec> types, ITypeSymbol typeSymbol, ISymbol memberSymbol);
    internal static AwaitableTypeTester CollectAwaitableTypes(Compilation compilation, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsAwaitable(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
internal static bool IsAwaitable(ITypeSymbol typeSymbol, SemanticModel semanticModel, int position);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static IOperation GetContainingFunction(IOperation operation);
    internal static bool ConformsToAwaiterPattern(ITypeSymbol typeSymbol);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Threading.Analyzers.CommonInterest/<ReadLinesFromAdditionalFile>d__26")]
internal static IEnumerable`1<string> ReadLinesFromAdditionalFile(SourceText text);
    internal static QualifiedMember ParseAdditionalFileMethodLine(string line);
    private static bool TestGetAwaiterMethod(IMethodSymbol getAwaiterMethod);
    [CompilerGeneratedAttribute]
internal static void <CollectAwaitableTypes>g__AddAwaitableType|21_0(ITypeSymbol type, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
internal static void <CollectAwaitableTypes>g__CollectNamespace|21_2(INamespaceOrTypeSymbol nsOrType, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
internal static bool <CollectAwaitableTypes>g__TryGetAwaitableType|21_1(ISymbol getAwaiterMember, ITypeSymbol& awaitableType, <>c__DisplayClass21_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Threading.Analyzers.LanguageUtils : object {
    internal abstract virtual Location GetLocationOfBaseTypeName(INamedTypeSymbol symbol, INamedTypeSymbol baseType, Compilation compilation, CancellationToken cancellationToken);
    internal abstract virtual SyntaxNode IsolateMethodName(IInvocationOperation invocation);
    internal abstract virtual SyntaxNode IsolateMethodName(IObjectCreationOperation objectCreation);
    internal abstract virtual bool MethodReturnsNullableReferenceType(IMethodSymbol method);
    internal abstract virtual bool IsAsyncMethod(SyntaxNode syntaxNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Threading.Analyzers.Namespaces : object {
    internal static IReadOnlyList`1<string> System;
    internal static IReadOnlyList`1<string> SystemCollectionsGeneric;
    internal static IReadOnlyList`1<string> SystemThreading;
    internal static IReadOnlyList`1<string> SystemDiagnostics;
    internal static IReadOnlyList`1<string> SystemThreadingTasks;
    internal static IReadOnlyList`1<string> SystemRuntimeCompilerServices;
    internal static IReadOnlyList`1<string> SystemRuntimeInteropServices;
    internal static IReadOnlyList`1<string> SystemWindowsThreading;
    internal static IReadOnlyList`1<string> MicrosoftVisualStudioThreading;
    internal static IReadOnlyList`1<string> MicrosoftVisualStudioShell;
    internal static IReadOnlyList`1<string> MicrosoftVisualStudioShellInterop;
    private static Namespaces();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.Threading.Analyzers.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AwaitXInstead { get; }
    internal static string SystemIAsyncDisposablePackageNote { get; }
    internal static string UseAwaitInstead { get; }
    internal static string VSTHRD001_MessageFormat { get; }
    internal static string VSTHRD001_Title { get; }
    internal static string VSTHRD002_CodeFix_Await_Title { get; }
    internal static string VSTHRD002_MessageFormat { get; }
    internal static string VSTHRD002_Title { get; }
    internal static string VSTHRD003_MessageFormat { get; }
    internal static string VSTHRD003_Title { get; }
    internal static string VSTHRD004_MessageFormat { get; }
    internal static string VSTHRD004_Title { get; }
    internal static string VSTHRD010_MessageFormat_Async { get; }
    internal static string VSTHRD010_MessageFormat_Sync { get; }
    internal static string VSTHRD010_Title { get; }
    internal static string VSTHRD011_MessageFormat { get; }
    internal static string VSTHRD011_Title { get; }
    internal static string VSTHRD011b_MessageFormat { get; }
    internal static string VSTHRD012_MessageFormat { get; }
    internal static string VSTHRD012_Title { get; }
    internal static string VSTHRD100_CodeFix_Title { get; }
    internal static string VSTHRD100_MessageFormat { get; }
    internal static string VSTHRD100_Title { get; }
    internal static string VSTHRD101_MessageFormat { get; }
    internal static string VSTHRD101_Title { get; }
    internal static string VSTHRD102_MessageFormat { get; }
    internal static string VSTHRD102_Title { get; }
    internal static string VSTHRD103_MessageFormat { get; }
    internal static string VSTHRD103_MessageFormat_UseAwaitInstead { get; }
    internal static string VSTHRD103_Title { get; }
    internal static string VSTHRD104_MessageFormat { get; }
    internal static string VSTHRD104_Title { get; }
    internal static string VSTHRD105_MessageFormat { get; }
    internal static string VSTHRD105_Title { get; }
    internal static string VSTHRD106_MessageFormat { get; }
    internal static string VSTHRD106_Title { get; }
    internal static string VSTHRD107_CodeFix_Title { get; }
    internal static string VSTHRD107_MessageFormat { get; }
    internal static string VSTHRD107_Title { get; }
    internal static string VSTHRD108_MessageFormat { get; }
    internal static string VSTHRD108_Title { get; }
    internal static string VSTHRD109_MessageFormat { get; }
    internal static string VSTHRD109_Title { get; }
    internal static string VSTHRD110_MessageFormat { get; }
    internal static string VSTHRD110_Title { get; }
    internal static string VSTHRD111_CodeFix_False_Title { get; }
    internal static string VSTHRD111_CodeFix_True_Title { get; }
    internal static string VSTHRD111_MessageFormat { get; }
    internal static string VSTHRD111_Title { get; }
    internal static string VSTHRD112_CodeFix_Title { get; }
    internal static string VSTHRD112_MessageFormat { get; }
    internal static string VSTHRD112_Title { get; }
    internal static string VSTHRD113_MessageFormat { get; }
    internal static string VSTHRD113_Title { get; }
    internal static string VSTHRD114_CodeFix_CompletedTask { get; }
    internal static string VSTHRD114_CodeFix_FromResult { get; }
    internal static string VSTHRD114_MessageFormat { get; }
    internal static string VSTHRD114_Title { get; }
    internal static string VSTHRD200_AddAsync_MessageFormat { get; }
    internal static string VSTHRD200_CodeFix_Title { get; }
    internal static string VSTHRD200_RemoveAsync_MessageFormat { get; }
    internal static string VSTHRD200_Title { get; }
    internal static string VSTHRD201_CodeFix_Title { get; }
    internal static string VSTHRD201_MessageFormat { get; }
    internal static string VSTHRD201_Title { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AwaitXInstead();
    internal static string get_SystemIAsyncDisposablePackageNote();
    internal static string get_UseAwaitInstead();
    internal static string get_VSTHRD001_MessageFormat();
    internal static string get_VSTHRD001_Title();
    internal static string get_VSTHRD002_CodeFix_Await_Title();
    internal static string get_VSTHRD002_MessageFormat();
    internal static string get_VSTHRD002_Title();
    internal static string get_VSTHRD003_MessageFormat();
    internal static string get_VSTHRD003_Title();
    internal static string get_VSTHRD004_MessageFormat();
    internal static string get_VSTHRD004_Title();
    internal static string get_VSTHRD010_MessageFormat_Async();
    internal static string get_VSTHRD010_MessageFormat_Sync();
    internal static string get_VSTHRD010_Title();
    internal static string get_VSTHRD011_MessageFormat();
    internal static string get_VSTHRD011_Title();
    internal static string get_VSTHRD011b_MessageFormat();
    internal static string get_VSTHRD012_MessageFormat();
    internal static string get_VSTHRD012_Title();
    internal static string get_VSTHRD100_CodeFix_Title();
    internal static string get_VSTHRD100_MessageFormat();
    internal static string get_VSTHRD100_Title();
    internal static string get_VSTHRD101_MessageFormat();
    internal static string get_VSTHRD101_Title();
    internal static string get_VSTHRD102_MessageFormat();
    internal static string get_VSTHRD102_Title();
    internal static string get_VSTHRD103_MessageFormat();
    internal static string get_VSTHRD103_MessageFormat_UseAwaitInstead();
    internal static string get_VSTHRD103_Title();
    internal static string get_VSTHRD104_MessageFormat();
    internal static string get_VSTHRD104_Title();
    internal static string get_VSTHRD105_MessageFormat();
    internal static string get_VSTHRD105_Title();
    internal static string get_VSTHRD106_MessageFormat();
    internal static string get_VSTHRD106_Title();
    internal static string get_VSTHRD107_CodeFix_Title();
    internal static string get_VSTHRD107_MessageFormat();
    internal static string get_VSTHRD107_Title();
    internal static string get_VSTHRD108_MessageFormat();
    internal static string get_VSTHRD108_Title();
    internal static string get_VSTHRD109_MessageFormat();
    internal static string get_VSTHRD109_Title();
    internal static string get_VSTHRD110_MessageFormat();
    internal static string get_VSTHRD110_Title();
    internal static string get_VSTHRD111_CodeFix_False_Title();
    internal static string get_VSTHRD111_CodeFix_True_Title();
    internal static string get_VSTHRD111_MessageFormat();
    internal static string get_VSTHRD111_Title();
    internal static string get_VSTHRD112_CodeFix_Title();
    internal static string get_VSTHRD112_MessageFormat();
    internal static string get_VSTHRD112_Title();
    internal static string get_VSTHRD113_MessageFormat();
    internal static string get_VSTHRD113_Title();
    internal static string get_VSTHRD114_CodeFix_CompletedTask();
    internal static string get_VSTHRD114_CodeFix_FromResult();
    internal static string get_VSTHRD114_MessageFormat();
    internal static string get_VSTHRD114_Title();
    internal static string get_VSTHRD200_AddAsync_MessageFormat();
    internal static string get_VSTHRD200_CodeFix_Title();
    internal static string get_VSTHRD200_RemoveAsync_MessageFormat();
    internal static string get_VSTHRD200_Title();
    internal static string get_VSTHRD201_CodeFix_Title();
    internal static string get_VSTHRD201_MessageFormat();
    internal static string get_VSTHRD201_Title();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Threading.Analyzers.Types : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Threading.Analyzers.Utils : object {
    internal static Action`1<SyntaxNodeAnalysisContext> DebuggableWrapper(Action`1<SyntaxNodeAnalysisContext> handler);
    internal static Action`1<SymbolAnalysisContext> DebuggableWrapper(Action`1<SymbolAnalysisContext> handler);
    internal static Action`1<CodeBlockAnalysisContext> DebuggableWrapper(Action`1<CodeBlockAnalysisContext> handler);
    internal static Action`1<OperationAnalysisContext> DebuggableWrapper(Action`1<OperationAnalysisContext> handler);
    internal static Action`1<OperationBlockStartAnalysisContext> DebuggableWrapper(Action`1<OperationBlockStartAnalysisContext> handler);
    [ExtensionAttribute]
internal static bool TryGetNewOrExistingSemanticModel(SyntaxNodeAnalysisContext context, SyntaxTree syntaxTree, SemanticModel& semanticModel);
    internal static bool IsEqualToOrDerivedFrom(ITypeSymbol type, ITypeSymbol expectedType);
    internal static bool IsDerivedFrom(ITypeSymbol type, ITypeSymbol expectedType);
    internal static ITypeSymbol ResolveTypeFromSymbol(ISymbol symbol);
    [ExtensionAttribute]
internal static bool BelongsToNamespace(ISymbol symbol, IReadOnlyList`1<string> namespaces);
    internal static IBlockOperation GetContainingFunctionBlock(IOperation operation);
    internal static ISymbol GetContainingFunction(IOperation operation, ISymbol operationBlockContainingSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool HasAsyncCompatibleReturnType(IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsAsyncCompatibleReturnType(ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
internal static bool IsLazyOfT(INamedTypeSymbol constructedType);
    [NullableContextAttribute("2")]
internal static bool IsTask(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
internal static bool IsAsyncReady(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
internal static bool HasAsyncAlternative(IMethodSymbol methodSymbol, CancellationToken cancellationToken);
    internal static bool IsXAtLeastAsPublicAsY(ISymbol x, ISymbol y);
    [NullableContextAttribute("2")]
internal static bool IsPublic(ISymbol symbol);
    [NullableContextAttribute("2")]
internal static bool IsEntrypointMethod(ISymbol symbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static bool IsEntrypointMethod(ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsObsolete(ISymbol symbol);
    [ExtensionAttribute]
internal static IEnumerable`1<ITypeSymbol> FindInterfacesImplemented(ISymbol symbol);
    internal static string GetFullName(ISymbol symbol);
    [ExtensionAttribute]
internal static void Deconstruct(Tuple`2<T1, T2> tuple, T1& item1, T2& item2);
    [ExtensionAttribute]
internal static void Deconstruct(Tuple`3<T1, T2, T3> tuple, T1& item1, T2& item2, T3& item3);
    [ExtensionAttribute]
internal static void Deconstruct(Tuple`4<T1, T2, T3, T4> tuple, T1& item1, T2& item2, T3& item3, T4& item4);
    internal static string GetHelpLink(string analyzerId);
    internal static IEnumerable`1<ISymbol> FindCancellationToken(SemanticModel semanticModel, int positionForLookup, CancellationToken cancellationToken);
    internal static IEnumerable`1<IMethodSymbol> FindMethodGroup(SemanticModel semanticModel, string methodAsString);
    internal static IEnumerable`1<IMethodSymbol> FindMethodGroup(SemanticModel semanticModel, QualifiedMember method);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Threading.Analyzers.Utils/<FindInstanceOf>d__32")]
internal static IEnumerable`1<Tuple`2<bool, ISymbol>> FindInstanceOf(INamedTypeSymbol typeSymbol, SemanticModel semanticModel, int positionForLookup, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static T FirstAncestor(SyntaxNode startingNode, IReadOnlyCollection`1<Type> doNotPassNodeTypes);
    [NullableContextAttribute("2")]
internal static Tuple`2<string, string> SplitOffLastElement(string qualifiedName);
    internal static bool IsCancellationTokenParameter(IParameterSymbol parameterSymbol);
    [NullableContextAttribute("2")]
internal static ISymbol GetUnderlyingSymbol(IOperation operation);
    [NullableContextAttribute("2")]
internal static bool IsSameSymbol(IOperation op1, IOperation op2);
    internal static IOperation FindFinalAncestor(IOperation operation);
    internal static T FindAncestor(IOperation operation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ISymbol FindContainingNamedOrAssemblySymbol(ISymbol symbol);
    private static bool IsSymbolTheRightType(ISymbol symbol, string typeName, IReadOnlyList`1<string> namespaces);
    private static bool IsSymbolTheRightType(ISymbol symbol, string typeName, INamespaceSymbol namespaces);
    private static bool LaunchDebuggerExceptionFilter();
    [CompilerGeneratedAttribute]
internal static bool <IsAsyncCompatibleReturnType>g__IsIAsyncEnumerable|13_1(ITypeSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Threading.Analyzers.VSTHRD100AsyncVoidMethodAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static VSTHRD100AsyncVoidMethodAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNode(SymbolAnalysisContext context);
    private static void AnalyzeOperation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Threading.Analyzers.VSTHRD101AsyncVoidLambdaAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static VSTHRD101AsyncVoidLambdaAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Threading.Analyzers.VSTHRD106UseInvokeAsyncForAsyncEventsAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static VSTHRD106UseInvokeAsyncForAsyncEventsAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(OperationBlockStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Threading.Analyzers.VSTHRD111UseConfigureAwaitAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static VSTHRD111UseConfigureAwaitAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeAwaitOperation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Threading.Analyzers.VSTHRD113CheckForSystemIAsyncDisposableAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static VSTHRD113CheckForSystemIAsyncDisposableAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeTypeCheck(OperationAnalysisContext context, INamedTypeSymbol vsThreadingAsyncDisposableType, INamedTypeSymbol bclAsyncDisposableType);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeTypeCheck>g__ConsiderTypeCheck|5_0(OperationAnalysisContext context, ITypeSymbol operand, INamedTypeSymbol vsThreadingAsyncDisposableType, INamedTypeSymbol bclAsyncDisposableType);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeTypeCheck>g__IsTypeCheck|5_1(IOperation operation, INamedTypeSymbol typeChecked);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Threading.Analyzers.VSTHRD200UseAsyncNamingConventionAnalyzer : DiagnosticAnalyzer {
    public static string Id;
    internal static string NewNameKey;
    internal static string MandatoryAsyncSuffix;
    internal static DiagnosticDescriptor AddAsyncDescriptor;
    internal static DiagnosticDescriptor RemoveAsyncDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static VSTHRD200UseAsyncNamingConventionAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeLocalFunction(OperationAnalysisContext context, AwaitableTypeTester awaitableTypes);
    private void AnalyzeNode(SymbolAnalysisContext context, AwaitableTypeTester awaitableTypes);
    private Diagnostic AnalyzeMethodSymbol(Compilation compilation, IMethodSymbol methodSymbol, AwaitableTypeTester awaitableTypes, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(CompilationStartAnalysisContext context);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.133.12845")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
