[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest : object {
    private HttpWebRequest request;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Url { get; }
    public string Method { get; public set; }
    public int Timeout { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ContentType { get; public set; }
    public AsyncHttpWebRequest(string url);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Url();
    public sealed virtual string get_Method();
    public sealed virtual void set_Method(string value);
    public sealed virtual int get_Timeout();
    public sealed virtual void set_Timeout(int value);
    public sealed virtual RequestCachePolicy get_CachePolicy();
    public sealed virtual void set_CachePolicy(RequestCachePolicy value);
    public sealed virtual string get_ContentType();
    public sealed virtual void set_ContentType(string value);
    public sealed virtual void AddHeaders(IEnumerable`1<KeyValuePair`2<string, string>> headers);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest/<GetResponseAsync>d__18")]
public sealed virtual Task`1<IStreamedHttpWebResponse> GetResponseAsync();
    [CompilerGeneratedAttribute]
private WebResponse <GetResponseAsync>b__18_0();
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Utilities.Internal.CodeContract : object {
    [ExtensionAttribute]
public static void RequiresArgumentNotNull(T value, string argumentName);
    [ExtensionAttribute]
public static void RequiresArgumentNotEmptyOrWhitespace(string value, string argumentName);
    [ExtensionAttribute]
public static void RequiresArgumentNotNullAndNotEmpty(string value, string argumentName);
    [ExtensionAttribute]
public static void RequiresArgumentNotNullAndNotWhiteSpace(string value, string argumentName);
    [ExtensionAttribute]
public static void RequiresArgumentNotEmpty(Guid guid, string argumentName);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Utilities.Internal.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TV GetOrDefault(IDictionary`2<TK, TV> dictionary, TK key);
    [ExtensionAttribute]
public static void AddRange(IDictionary`2<TKey, TValue> target, IDictionary`2<TKey, TValue> source, bool forceUpdate);
    [ExtensionAttribute]
public static void Remove(ConcurrentDictionary`2<TK, TV> dictionary, TK key);
}
public enum Microsoft.VisualStudio.Utilities.Internal.ErrorCode : Enum {
    public int value__;
    public static ErrorCode NoError;
    public static ErrorCode NullResponse;
    public static ErrorCode RequestTimedOut;
    public static ErrorCode WebExceptionThrown;
}
public class Microsoft.VisualStudio.Utilities.Internal.FileBasedRegistry : object {
    private static string LinuxXdgCacheHomeEnvVar;
    private static string HomeEnvVar;
    private static string LinuxCacheFolderName;
    private static string MacLibraryString;
    private static string MacApplicationSupportString;
    private string filepath;
    private string currentUserRootPath;
    private Hashtable values;
    private bool dropped;
    private bool modified;
    public bool Exists { get; }
    public FileBasedRegistry(string key);
    public bool get_Exists();
    public sealed virtual void Dispose();
    public void Drop();
    public void SetValue(string name, object value);
    public String[] GetValueNames();
    public String[] GetSubKeyNames(string subKeyPath);
    public void RemoveValue(string key);
    public object GetValue(string key);
    public void Clear();
    internal static string GetBaseCacheDirectory();
    private static string ConvertWinRegistryPathToMacosPath(string keyname);
    private void EnsureNotDropped();
    private void LoadXml();
    private void SaveXml();
}
public class Microsoft.VisualStudio.Utilities.Internal.FileBasedRegistryTools : object {
    public sealed virtual bool DeleteRegistryKeyFromCurrentUserRoot(string regKeyPath);
    public sealed virtual bool DoesRegistryKeyExistInCurrentUserRoot(string regKeyPath);
    public sealed virtual bool DeleteRegistryValueFromCurrentUserRoot(string regKeyPath, string regKeyName);
    public sealed virtual object GetRegistryValueFromCurrentUserRoot(string regKeyPath, string regKeyName, object defaultOnError);
    public sealed virtual String[] GetRegistryValueNamesFromCurrentUserRoot(string regKeyPath);
    public sealed virtual bool SetRegistryFromCurrentUserRoot(string regKeyPath, string regKeyName, object value);
    public sealed virtual bool SetRegistryFromCurrentUserRoot(string regKeyPath, string regKeyName, object value, RegistryValueKind valueKind);
    public sealed virtual object GetRegistryValueFromLocalMachineRoot(string regKeyPath, string regKeyName, object defaultOnError);
    public sealed virtual object GetRegistryValueFromLocalMachineRoot(string regKeyPath, string regKeyName, bool use64Bit, object defaultOnError);
    public sealed virtual bool SetRegistryFromLocalMachineRoot(string regKeyPath, string regKeyName, object value, bool use64Bit);
    public sealed virtual bool TryGetRegistryValueKindFromCurrentUserRoot(string regKeyPath, string regKeyName, RegistryValueKind& kind);
    public sealed virtual bool TryGetRegistryValueKindFromLocalMachineRoot(string regKeyPath, string regKeyName, RegistryValueKind& kind, bool use64Bit);
    public sealed virtual bool DeleteRegistryKeyFromLocalMachineRoot(string regKeyPath, bool use64Bit);
    public sealed virtual bool DeleteRegistryValueFromLocalMachineRoot(string regKeyPath, string regKeyName, bool use64Bit);
    public sealed virtual bool DoesRegistryKeyExistInLocalMachineRoot(string regKeyPath, bool use64Bit);
    public sealed virtual Nullable`1<int> GetRegistryIntValueFromLocalMachineRoot(string regKeyPath, string regKeyName, Nullable`1<int> defaultOnError);
    public sealed virtual Nullable`1<int> GetRegistryIntValueFromLocalMachineRoot(string regKeyPath, string regKeyName, bool use64Bit, Nullable`1<int> defaultOnError);
    public sealed virtual String[] GetRegistrySubKeyNamesFromLocalMachineRoot(string regKeyPath, bool use64Bit);
    public sealed virtual String[] GetRegistrySubKeyNamesFromCurrentUserRoot(string regKeyPath);
    public sealed virtual String[] GetRegistryValueNamesFromLocalMachineRoot(string regKeyPath, bool use64Bit);
}
public interface Microsoft.VisualStudio.Utilities.Internal.IAsyncHttpWebRequest {
    public string Url { get; }
    public string Method { get; public set; }
    public int Timeout { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ContentType { get; public set; }
    public abstract virtual string get_Url();
    public abstract virtual string get_Method();
    public abstract virtual void set_Method(string value);
    public abstract virtual int get_Timeout();
    public abstract virtual void set_Timeout(int value);
    public abstract virtual RequestCachePolicy get_CachePolicy();
    public abstract virtual void set_CachePolicy(RequestCachePolicy value);
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual void AddHeaders(IEnumerable`1<KeyValuePair`2<string, string>> headers);
    public abstract virtual Task`1<IStreamedHttpWebResponse> GetResponseAsync();
}
public interface Microsoft.VisualStudio.Utilities.Internal.IRegistryTools {
    public abstract virtual Nullable`1<int> GetRegistryIntValueFromLocalMachineRoot(string regKeyPath, string regKeyName, Nullable`1<int> defaultOnError);
    public abstract virtual Nullable`1<int> GetRegistryIntValueFromLocalMachineRoot(string regKeyPath, string regKeyName, bool use64Bit, Nullable`1<int> defaultOnError);
    public abstract virtual object GetRegistryValueFromLocalMachineRoot(string regKeyPath, string regKeyName, object defaultOnError);
    public abstract virtual object GetRegistryValueFromLocalMachineRoot(string regKeyPath, string regKeyName, bool use64Bit, object defaultOnError);
    public abstract virtual object GetRegistryValueFromCurrentUserRoot(string regKeyPath, string regKeyName, object defaultOnError);
    public abstract virtual bool SetRegistryFromCurrentUserRoot(string regKeyPath, string regKeyName, object value);
    public abstract virtual bool SetRegistryFromLocalMachineRoot(string regKeyPath, string regKeyName, object value, bool use64Bit);
}
public interface Microsoft.VisualStudio.Utilities.Internal.IRegistryTools2 {
    public abstract virtual String[] GetRegistryValueNamesFromCurrentUserRoot(string regKeyPath);
    public abstract virtual String[] GetRegistryValueNamesFromLocalMachineRoot(string regKeyPath, bool use64Bit);
    public abstract virtual String[] GetRegistrySubKeyNamesFromCurrentUserRoot(string regKeyPath);
    public abstract virtual String[] GetRegistrySubKeyNamesFromLocalMachineRoot(string regKeyPath, bool use64Bit);
    public abstract virtual bool DoesRegistryKeyExistInCurrentUserRoot(string regKeyPath);
    public abstract virtual bool DoesRegistryKeyExistInLocalMachineRoot(string regKeyPath, bool use64Bit);
    public abstract virtual bool DeleteRegistryKeyFromCurrentUserRoot(string regKeyPath);
    public abstract virtual bool DeleteRegistryKeyFromLocalMachineRoot(string regKeyPath, bool use64Bit);
    public abstract virtual bool DeleteRegistryValueFromCurrentUserRoot(string regKeyPath, string regKeyName);
    public abstract virtual bool DeleteRegistryValueFromLocalMachineRoot(string regKeyPath, string regKeyName, bool use64Bit);
}
public interface Microsoft.VisualStudio.Utilities.Internal.IRegistryTools3 {
    public abstract virtual bool TryGetRegistryValueKindFromCurrentUserRoot(string regKeyPath, string regKeyName, RegistryValueKind& kind);
    public abstract virtual bool TryGetRegistryValueKindFromLocalMachineRoot(string regKeyPath, string regKeyName, RegistryValueKind& kind, bool use64Bit);
}
public interface Microsoft.VisualStudio.Utilities.Internal.IRegistryTools4 {
    public abstract virtual bool SetRegistryFromCurrentUserRoot(string regKeyPath, string regKeyName, object value, RegistryValueKind valueKind);
}
public interface Microsoft.VisualStudio.Utilities.Internal.IStreamedHttpWebResponse {
    public ErrorCode ErrorCode { get; }
    public WebExceptionStatus ExceptionCode { get; }
    public HttpStatusCode StatusCode { get; }
    public abstract virtual ErrorCode get_ErrorCode();
    public abstract virtual WebExceptionStatus get_ExceptionCode();
    public abstract virtual HttpStatusCode get_StatusCode();
    public abstract virtual Stream GetResponseStream();
}
public static class Microsoft.VisualStudio.Utilities.Internal.MacNativeMethods : object {
    private static int sysctlbyname(string property, IntPtr output, IntPtr oldLen, IntPtr newp, UInt32 newlen);
    private static int Gestalt(int selector, Int32& result);
    private static int uname(IntPtr buf);
    public static void GetSystemInfo(SystemInfo& info);
    public static void GetOSVersionInfo(OSVersionInfo& info);
    internal static bool IsRunningOnMac();
    private static int Gestalt(string selector);
    private static int SysctlValueAsInt(string name);
    private static long SysctlValueAsInt64(string name);
    private static string SysctlValueAsString(string name);
    private static IntPtr SysctlGetValue(string name);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Utilities.Internal.NativeFlagsEx : object {
    [ExtensionAttribute]
internal static FILE_ACCESS_FLAGS ToFILE_ACCESS_FLAGS(FileAccess fileAccess);
    [ExtensionAttribute]
internal static FILE_SHARE_MODE ToFILE_SHARE_MODE(FileShare fileShare);
}
internal static class Microsoft.VisualStudio.Utilities.Internal.NativeMethods : object {
    internal static UInt32 FILE_RENAME_IGNORE_READONLY_ATTRIBUTE;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Utilities.Internal.ObjectExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Utilities.Internal.ObjectExtensions/<Enumerate>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Enumerate(T value);
    [ExtensionAttribute]
public static IEnumerable`1<T> EmptyIfNull(IEnumerable`1<T> enumeration);
}
public static class Microsoft.VisualStudio.Utilities.Internal.Platform : object {
    public static bool IsWindows;
    public static bool IsMac;
    public static bool IsLinux;
    private static Platform();
    public static void Initialize();
}
internal class Microsoft.VisualStudio.Utilities.Internal.RegistryHelpers : object {
    public static bool TryGetRegistryValueKindForSet(object value, RegistryValueKind& registryValueKind);
}
[ExcludeFromCodeCoverageAttribute]
public class Microsoft.VisualStudio.Utilities.Internal.RegistryTools : object {
    public sealed virtual Nullable`1<int> GetRegistryIntValueFromLocalMachineRoot(string regKeyPath, string regKeyName, Nullable`1<int> defaultOnError);
    public sealed virtual Nullable`1<int> GetRegistryIntValueFromLocalMachineRoot(string regKeyPath, string regKeyName, bool use64Bit, Nullable`1<int> defaultOnError);
    public sealed virtual object GetRegistryValueFromLocalMachineRoot(string regKeyPath, string regKeyName, object defaultOnError);
    public sealed virtual object GetRegistryValueFromLocalMachineRoot(string regKeyPath, string regKeyName, bool use64Bit, object defaultOnError);
    public sealed virtual object GetRegistryValueFromCurrentUserRoot(string regKeyPath, string regKeyName, object defaultOnError);
    public sealed virtual bool TryGetRegistryValueKindFromCurrentUserRoot(string regKeyPath, string regKeyName, RegistryValueKind& kind);
    public sealed virtual bool TryGetRegistryValueKindFromLocalMachineRoot(string regKeyPath, string regKeyName, RegistryValueKind& kind, bool use64Bit);
    public sealed virtual String[] GetRegistryValueNamesFromCurrentUserRoot(string regKeyPath);
    public sealed virtual String[] GetRegistryValueNamesFromLocalMachineRoot(string regKeyPath, bool use64Bit);
    public sealed virtual String[] GetRegistrySubKeyNamesFromCurrentUserRoot(string regKeyPath);
    public sealed virtual String[] GetRegistrySubKeyNamesFromLocalMachineRoot(string regKeyPath, bool use64Bit);
    public sealed virtual bool DoesRegistryKeyExistInCurrentUserRoot(string regKeyPath);
    public sealed virtual bool DoesRegistryKeyExistInLocalMachineRoot(string regKeyPath, bool use64Bit);
    public sealed virtual bool SetRegistryFromCurrentUserRoot(string regKeyPath, string regKeyName, object value);
    public sealed virtual bool SetRegistryFromCurrentUserRoot(string regKeyPath, string regKeyName, object value, RegistryValueKind valueKind);
    public sealed virtual bool SetRegistryFromLocalMachineRoot(string regKeyPath, string regKeyName, object value, bool use64Bit);
    public sealed virtual bool DeleteRegistryKeyFromCurrentUserRoot(string regKeyPath);
    public sealed virtual bool DeleteRegistryKeyFromLocalMachineRoot(string regKeyPath, bool use64Bit);
    public sealed virtual bool DeleteRegistryValueFromCurrentUserRoot(string regKeyPath, string regKeyName);
    public sealed virtual bool DeleteRegistryValueFromLocalMachineRoot(string regKeyPath, string regKeyName, bool use64Bit);
    private object GetRegistryValue(RegistryKey rootKey, string regKeyPath, string regKeyName, object defaultOnError);
    private bool TryGetRegistryValueKind(RegistryKey rootKey, string regKeyPath, string regKeyName, RegistryValueKind& kind);
    private String[] GetRegistryValueNames(RegistryKey rootKey, string regKeyPath);
    private String[] GetRegistrySubKeyNames(RegistryKey rootKey, string regKeyPath);
    private bool DoesRegistryKeyExist(RegistryKey rootKey, string regKeyPath);
    private bool SetRegistryValue(RegistryKey rootKey, string regKeyPath, string regKeyName, object value, RegistryValueKind valueKind);
    private bool DeleteRegistrySubKey(RegistryKey rootKey, string regKeyPath);
    private bool DeleteRegistryValue(RegistryKey rootKey, string regKeyPath, string regKeyName);
}
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Utilities.Internal.RegistryValue : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Strings>k__BackingField;
    [XmlAttributeAttribute]
public string Name { get; public set; }
    [XmlAttributeAttribute]
public string Type { get; public set; }
    [XmlTextAttribute("System.String")]
public string Text { get; public set; }
    [XmlElementAttribute]
public String[] Strings { get; public set; }
    [XmlIgnoreAttribute]
public object Value { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public String[] get_Strings();
    [CompilerGeneratedAttribute]
public void set_Strings(String[] value);
    public object get_Value();
    public static RegistryValue FromValue(string name, object value);
    private object GetObjectValue();
}
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Utilities.Internal.RegistryValues : List`1<RegistryValue> {
}
public static class Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware : object {
    private static string DevicePathPrefix;
    public static void RequireSamePath(SafeFileHandle handle, string expectedPath);
    public static void RequireNoReparsePoints(string expectedPath, bool asDirectory);
    public static void DeleteFile(string path);
    public static void MoveFile(string sourceFileName, string destFileName);
    public static void WriteAllText(string path, string contents);
    public static StreamWriter CreateText(string path);
    public static FileStream OpenWrite(string path);
    public static FileStream OpenRead(string path);
    public static FileStream OpenFile(string path, FileMode mode, FileAccess access, FileShare share);
    public static void SetFileAttributeNormal(string path);
    public static DirectoryInfo CreateDirectory(string path);
    public static SafeFileHandle PinAndRequireNoReparsePoints(string expectedPath, bool asDirectory);
    public static SafeFileHandle PinHandle(string fullPath, bool asDirectory);
    public static string GetFinalPath(SafeFileHandle handle);
    public static bool HasReparsePoints(SafeFileHandle safeHandle, string expectedPath);
    private static void ThrowIfFalse(bool condition);
    private static void SetDeleteOnClose(SafeHandle handle);
    private static bool RenameFileByHandle(SafeHandle handle, string targetFileName);
    private static FileStream SafeCreateOrOpenFile(string path, FileAccess fileAccess, FileShare fileShare);
    private static SafeFileHandle SafeCreateNewFile(string path, FileAccess fileAccess, FileShare fileShare);
    private static SafeFileHandle SafeOpenExistingFile(string path, FileAccess fileAccess, FileShare fileShare);
    private static SafeFileHandle UnsafeCreateDirectoryInternal(string path);
    private static void SafeSetFileAttributesNormal(string path);
    private static SafeFileHandle UnsafeCreateFileStub(string lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, SafeHandle hTemplateFile);
    internal static SafeFileHandle TESTUSEONLY_CreateFileStub(string lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
    internal static void TESTUSEONLY_SetDeleteOnClose(SafeHandle handle);
}
public class Microsoft.VisualStudio.Utilities.Internal.StreamedHttpWebResponse : object {
    [CompilerGeneratedAttribute]
private ErrorCode <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private WebExceptionStatus <ExceptionCode>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpWebResponse <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    public ErrorCode ErrorCode { get; public set; }
    public WebExceptionStatus ExceptionCode { get; public set; }
    public HttpWebResponse Response { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ErrorCode get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(ErrorCode value);
    [CompilerGeneratedAttribute]
public sealed virtual WebExceptionStatus get_ExceptionCode();
    [CompilerGeneratedAttribute]
public void set_ExceptionCode(WebExceptionStatus value);
    [CompilerGeneratedAttribute]
public HttpWebResponse get_Response();
    [CompilerGeneratedAttribute]
public void set_Response(HttpWebResponse value);
    [CompilerGeneratedAttribute]
public sealed virtual HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    public sealed virtual Stream GetResponseStream();
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Utilities.Internal.StringExtensions : object {
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> values, string separator);
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Utilities.Internal.TaskExtensions : object {
    [ExtensionAttribute]
public static void SwallowException(Task task);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.128.36433")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
[IsReadOnlyAttribute]
internal class Windows.Win32.Foundation.BOOL : ValueType {
    private int value;
    internal int Value { get; }
    internal BOOL(bool value);
    internal BOOL(int value);
    internal int get_Value();
    public static bool op_Implicit(BOOL value);
    public static BOOL op_Implicit(bool value);
    public static BOOL op_Explicit(int value);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.BOOLEAN : ValueType {
    internal byte Value;
    internal BOOLEAN(byte value);
    public static byte op_Implicit(BOOLEAN value);
    public static BOOLEAN op_Explicit(byte value);
    public static bool op_Equality(BOOLEAN left, BOOLEAN right);
    public static bool op_Inequality(BOOLEAN left, BOOLEAN right);
    public sealed virtual bool Equals(BOOLEAN other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.HANDLE : ValueType {
    internal IntPtr Value;
    internal bool IsNull { get; }
    internal HANDLE(IntPtr value);
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HANDLE value);
    public static HANDLE op_Explicit(IntPtr value);
    public static bool op_Equality(HANDLE left, HANDLE right);
    public static bool op_Inequality(HANDLE left, HANDLE right);
    public sealed virtual bool Equals(HANDLE other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class Windows.Win32.Foundation.PCWSTR : ValueType {
    internal Char* Value;
    internal int Length { get; }
    private string DebuggerDisplay { get; }
    internal PCWSTR(Char* value);
    public static Char* op_Explicit(PCWSTR value);
    public static PCWSTR op_Implicit(Char* value);
    public static PCWSTR op_Implicit(PWSTR value);
    public sealed virtual bool Equals(PCWSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Length();
    public virtual string ToString();
    private string get_DebuggerDisplay();
    internal ReadOnlySpan`1<char> AsSpan();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
internal class Windows.Win32.Foundation.PWSTR : ValueType {
    internal Char* Value;
    internal int Length { get; }
    internal PWSTR(Char* value);
    public static Char* op_Implicit(PWSTR value);
    public static PWSTR op_Implicit(Char* value);
    public static bool op_Equality(PWSTR left, PWSTR right);
    public static bool op_Inequality(PWSTR left, PWSTR right);
    public sealed virtual bool Equals(PWSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Length();
    public virtual string ToString();
    internal Span`1<char> AsSpan();
}
[ExtensionAttribute]
internal static class Windows.Win32.InlineArrayIndexerExtensions : object {
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_1& this, int index);
    [ExtensionAttribute]
internal static Char& ItemRef(__char_1& this, int index);
}
internal static class Windows.Win32.PInvoke : object {
    internal static UInt32 DELETE;
    internal static UInt32 FILE_RENAME_FLAG_POSIX_SEMANTICS;
    internal static UInt32 FILE_RENAME_FLAG_REPLACE_IF_EXISTS;
    internal static UInt32 GENERIC_READ;
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL CloseHandle(HANDLE hObject);
    internal static SafeFileHandle CreateFile(string lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, SafeHandle hTemplateFile);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE CreateFile(PCWSTR lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, HANDLE hTemplateFile);
    internal static BOOL CreateHardLink(string lpFileName, string lpExistingFileName, SECURITY_ATTRIBUTES& lpSecurityAttributes);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL CreateHardLink(PCWSTR lpFileName, PCWSTR lpExistingFileName, SECURITY_ATTRIBUTES* lpSecurityAttributes);
    internal static BOOLEAN CreateSymbolicLink(string lpSymlinkFileName, string lpTargetFileName, SYMBOLIC_LINK_FLAGS dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOLEAN CreateSymbolicLink(PCWSTR lpSymlinkFileName, PCWSTR lpTargetFileName, SYMBOLIC_LINK_FLAGS dwFlags);
    internal static BOOL GetFileInformationByHandle(SafeHandle hFile, BY_HANDLE_FILE_INFORMATION& lpFileInformation);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetFileInformationByHandle(HANDLE hFile, BY_HANDLE_FILE_INFORMATION* lpFileInformation);
    internal static UInt32 GetFinalPathNameByHandle(SafeHandle hFile, PWSTR lpszFilePath, UInt32 cchFilePath, FILE_NAME dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetFinalPathNameByHandle(HANDLE hFile, PWSTR lpszFilePath, UInt32 cchFilePath, FILE_NAME dwFlags);
    internal static SafeFileHandle ReOpenFile(SafeHandle hOriginalFile, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE ReOpenFile(HANDLE hOriginalFile, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_MODE dwShareMode, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
    internal static BOOL SetFileInformationByHandle(SafeHandle hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
}
internal class Windows.Win32.Security.SECURITY_ATTRIBUTES : ValueType {
    internal UInt32 nLength;
    internal Void* lpSecurityDescriptor;
    internal BOOL bInheritHandle;
}
internal class Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION : ValueType {
    internal UInt32 dwFileAttributes;
    internal FILETIME ftCreationTime;
    internal FILETIME ftLastAccessTime;
    internal FILETIME ftLastWriteTime;
    internal UInt32 dwVolumeSerialNumber;
    internal UInt32 nFileSizeHigh;
    internal UInt32 nFileSizeLow;
    internal UInt32 nNumberOfLinks;
    internal UInt32 nFileIndexHigh;
    internal UInt32 nFileIndexLow;
}
[FlagsAttribute]
internal enum Windows.Win32.Storage.FileSystem.FILE_ACCESS_FLAGS : Enum {
    public UInt32 value__;
    public static FILE_ACCESS_FLAGS FILE_READ_DATA;
    public static FILE_ACCESS_FLAGS FILE_LIST_DIRECTORY;
    public static FILE_ACCESS_FLAGS FILE_WRITE_DATA;
    public static FILE_ACCESS_FLAGS FILE_ADD_FILE;
    public static FILE_ACCESS_FLAGS FILE_APPEND_DATA;
    public static FILE_ACCESS_FLAGS FILE_ADD_SUBDIRECTORY;
    public static FILE_ACCESS_FLAGS FILE_CREATE_PIPE_INSTANCE;
    public static FILE_ACCESS_FLAGS FILE_READ_EA;
    public static FILE_ACCESS_FLAGS FILE_WRITE_EA;
    public static FILE_ACCESS_FLAGS FILE_EXECUTE;
    public static FILE_ACCESS_FLAGS FILE_TRAVERSE;
    public static FILE_ACCESS_FLAGS FILE_DELETE_CHILD;
    public static FILE_ACCESS_FLAGS FILE_READ_ATTRIBUTES;
    public static FILE_ACCESS_FLAGS FILE_WRITE_ATTRIBUTES;
    public static FILE_ACCESS_FLAGS READ_CONTROL;
    public static FILE_ACCESS_FLAGS SYNCHRONIZE;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_REQUIRED;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_READ;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_WRITE;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_EXECUTE;
    public static FILE_ACCESS_FLAGS STANDARD_RIGHTS_ALL;
    public static FILE_ACCESS_FLAGS SPECIFIC_RIGHTS_ALL;
    public static FILE_ACCESS_FLAGS FILE_ALL_ACCESS;
    public static FILE_ACCESS_FLAGS FILE_GENERIC_READ;
    public static FILE_ACCESS_FLAGS FILE_GENERIC_WRITE;
    public static FILE_ACCESS_FLAGS FILE_GENERIC_EXECUTE;
}
internal class Windows.Win32.Storage.FileSystem.FILE_BASIC_INFO : ValueType {
    internal long CreationTime;
    internal long LastAccessTime;
    internal long LastWriteTime;
    internal long ChangeTime;
    internal UInt32 FileAttributes;
}
internal enum Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION : Enum {
    public UInt32 value__;
    public static FILE_CREATION_DISPOSITION CREATE_NEW;
    public static FILE_CREATION_DISPOSITION CREATE_ALWAYS;
    public static FILE_CREATION_DISPOSITION OPEN_EXISTING;
    public static FILE_CREATION_DISPOSITION OPEN_ALWAYS;
    public static FILE_CREATION_DISPOSITION TRUNCATE_EXISTING;
}
internal class Windows.Win32.Storage.FileSystem.FILE_DISPOSITION_INFO : ValueType {
    internal BOOLEAN DeleteFileA;
}
[FlagsAttribute]
internal enum Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES : Enum {
    public UInt32 value__;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_READONLY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_HIDDEN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_SYSTEM;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_DIRECTORY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_ARCHIVE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_DEVICE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NORMAL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_TEMPORARY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_SPARSE_FILE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_REPARSE_POINT;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_COMPRESSED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_OFFLINE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_ENCRYPTED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_INTEGRITY_STREAM;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_VIRTUAL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NO_SCRUB_DATA;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_EA;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_PINNED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_UNPINNED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_RECALL_ON_OPEN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_WRITE_THROUGH;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OVERLAPPED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_NO_BUFFERING;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_RANDOM_ACCESS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_SEQUENTIAL_SCAN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_DELETE_ON_CLOSE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_BACKUP_SEMANTICS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_POSIX_SEMANTICS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_SESSION_AWARE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OPEN_REPARSE_POINT;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OPEN_NO_RECALL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_FIRST_PIPE_INSTANCE;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_DUPLEX;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_INBOUND;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_OUTBOUND;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_ANONYMOUS;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_IDENTIFICATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_IMPERSONATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_DELEGATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_CONTEXT_TRACKING;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_EFFECTIVE_ONLY;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_SQOS_PRESENT;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_VALID_SQOS_FLAGS;
}
internal enum Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS : Enum {
    public int value__;
    public static FILE_INFO_BY_HANDLE_CLASS FileBasicInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStandardInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileNameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileRenameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileDispositionInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAllocationInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileEndOfFileInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStreamInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileCompressionInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAttributeTagInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdBothDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdBothDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIoPriorityHintInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileRemoteProtocolInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileFullDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileFullDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStorageInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAlignmentInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdExtdDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdExtdDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileDispositionInfoEx;
    public static FILE_INFO_BY_HANDLE_CLASS FileRenameInfoEx;
    public static FILE_INFO_BY_HANDLE_CLASS FileCaseSensitiveInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileNormalizedNameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS MaximumFileInfoByHandleClass;
}
internal enum Windows.Win32.Storage.FileSystem.FILE_NAME : Enum {
    public UInt32 value__;
    public static FILE_NAME FILE_NAME_NORMALIZED;
    public static FILE_NAME FILE_NAME_OPENED;
}
internal class Windows.Win32.Storage.FileSystem.FILE_RENAME_INFO : ValueType {
    internal _Anonymous_e__Union Anonymous;
    internal HANDLE RootDirectory;
    internal UInt32 FileNameLength;
    internal __char_1 FileName;
}
[FlagsAttribute]
internal enum Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE : Enum {
    public UInt32 value__;
    public static FILE_SHARE_MODE FILE_SHARE_NONE;
    public static FILE_SHARE_MODE FILE_SHARE_DELETE;
    public static FILE_SHARE_MODE FILE_SHARE_READ;
    public static FILE_SHARE_MODE FILE_SHARE_WRITE;
}
[FlagsAttribute]
internal enum Windows.Win32.Storage.FileSystem.SYMBOLIC_LINK_FLAGS : Enum {
    public UInt32 value__;
    public static SYMBOLIC_LINK_FLAGS SYMBOLIC_LINK_FLAG_DIRECTORY;
    public static SYMBOLIC_LINK_FLAGS SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE;
}
