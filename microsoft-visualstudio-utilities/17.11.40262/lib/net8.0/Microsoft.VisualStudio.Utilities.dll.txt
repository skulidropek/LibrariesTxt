internal class Microsoft.Internal.Performance.CodeMarkerExStartEnd : ValueType {
    private int _end;
    private Byte[] _aBuff;
    internal CodeMarkerExStartEnd(int begin, int end, Byte[] aBuff, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, Guid guidData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, string stringData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, UInt32 uintData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, ulong ulongData, bool correlated);
    public sealed virtual void Dispose();
}
internal class Microsoft.Internal.Performance.CodeMarkers : object {
    public static CodeMarkers Instance;
    private static string AtomName;
    private static string TestDllName;
    private static string ProductDllName;
    private State state;
    private RegistryView registryView;
    private string regroot;
    private Nullable`1<bool> shouldUseTestDll;
    private static Byte[] CorrelationMarkBytes;
    public bool IsEnabled { get; }
    public bool ShouldUseTestDll { get; }
    private static CodeMarkers();
    public bool get_IsEnabled();
    public bool get_ShouldUseTestDll();
    public bool CodeMarker(int nTimerID);
    public bool CodeMarkerEx(int nTimerID, Byte[] aBuff);
    public void SetStateDLLException();
    public bool CodeMarkerEx(int nTimerID, Guid guidData);
    public bool CodeMarkerEx(int nTimerID, string stringData);
    internal static Byte[] StringToBytesZeroTerminated(string stringData);
    public static Byte[] AttachCorrelationId(Byte[] buffer, Guid correlationId);
    public bool CodeMarkerEx(int nTimerID, UInt32 uintData);
    public bool CodeMarkerEx(int nTimerID, ulong ulongData);
    private static bool UsePrivateCodeMarkers(string regRoot, RegistryView registryView);
}
internal class Microsoft.Internal.Performance.CodeMarkerStartEnd : ValueType {
    private int _end;
    private Byte[] _buffer;
    internal CodeMarkerStartEnd(int begin, int end, bool correlated);
    public sealed virtual void Dispose();
    private void CodeMarker(int id);
}
public interface Microsoft.Internal.VisualStudio.Diagnostics.IVsEtwActivityEventWriter {
    public abstract virtual void OnActivityStart(VsEtwActivityInfo activityInfo);
    public abstract virtual void OnActivityStart(VsEtwActivityInfo activityInfo, T data);
    public abstract virtual void OnActivityStop(VsEtwActivityInfo activityInfo);
    public abstract virtual void OnActivityStop(VsEtwActivityInfo activityInfo, T data);
    public abstract virtual void OnActivityAbort(VsEtwActivityInfo activityInfo);
}
public class Microsoft.Internal.VisualStudio.Diagnostics.VsEtwActivity : object {
    [CompilerGeneratedAttribute]
private VsEtwActivityInfo <ActivityInfo>k__BackingField;
    private IVsEtwActivityEventWriter eventWriter;
    private bool isDisposed;
    internal VsEtwActivityInfo ActivityInfo { get; }
    public string Name { get; }
    public Guid ActivityId { get; }
    public Guid RelatedActivityId { get; }
    private VsEtwActivity(IVsEtwActivityEventWriter source, string activityName, VsEtwKeywords keyword, VsEtwLevel level, Guid activityId, Guid relatedActivityId);
    private VsEtwActivity(IVsEtwActivityEventWriter source, string activityName, VsEtwKeywords keyword, VsEtwLevel level, VsEtwActivity relatedActivity);
    [CompilerGeneratedAttribute]
internal VsEtwActivityInfo get_ActivityInfo();
    public string get_Name();
    public Guid get_ActivityId();
    public Guid get_RelatedActivityId();
    internal static VsEtwActivity CreateInstance(IVsEtwActivityEventWriter source, string activityName, VsEtwKeywords keyword, VsEtwLevel level, VsEtwActivity relatedActivity, T data);
    internal static VsEtwActivity CreateInstanceWithNoData(IVsEtwActivityEventWriter source, string activityName, VsEtwKeywords keyword, VsEtwLevel level, VsEtwActivity relatedActivity);
    private void Start(T data);
    private void Start();
    public void End(T data);
    public void End();
    public void Abort();
    public sealed virtual void Dispose();
}
internal class Microsoft.Internal.VisualStudio.Diagnostics.VsEtwActivityEventWriter : object {
    private EventSource eventSource;
    public VsEtwActivityEventWriter(EventSource eventSource);
    public sealed virtual void OnActivityAbort(VsEtwActivityInfo activityInfo);
    public sealed virtual void OnActivityStart(VsEtwActivityInfo activityInfo);
    public sealed virtual void OnActivityStart(VsEtwActivityInfo activityInfo, T data);
    public sealed virtual void OnActivityStop(VsEtwActivityInfo activityInfo);
    public sealed virtual void OnActivityStop(VsEtwActivityInfo activityInfo, T data);
    private void Write(VsEtwActivityInfo activityInfo, EventSourceOptions options, T eventData);
    private EventSourceOptions GetOptions(VsEtwActivityInfo activityInfo, EventOpcode opcode);
}
public class Microsoft.Internal.VisualStudio.Diagnostics.VsEtwActivityInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <ActivityName>k__BackingField;
    [CompilerGeneratedAttribute]
private VsEtwKeywords <ActivityKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private VsEtwLevel <ActivityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RelatedActivityId>k__BackingField;
    public string ActivityName { get; private set; }
    public VsEtwKeywords ActivityKeyword { get; private set; }
    public VsEtwLevel ActivityLevel { get; private set; }
    public Guid ActivityId { get; private set; }
    public Guid RelatedActivityId { get; private set; }
    public VsEtwActivityInfo(string name, VsEtwKeywords keyword, VsEtwLevel level);
    public VsEtwActivityInfo(string name, VsEtwKeywords keyword, VsEtwLevel level, Guid relatedActivityId);
    public VsEtwActivityInfo(string name, VsEtwKeywords keyword, VsEtwLevel level, Guid activityId, Guid relatedActivityId);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ActivityName();
    [CompilerGeneratedAttribute]
private void set_ActivityName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public VsEtwKeywords get_ActivityKeyword();
    [CompilerGeneratedAttribute]
private void set_ActivityKeyword(VsEtwKeywords value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public VsEtwLevel get_ActivityLevel();
    [CompilerGeneratedAttribute]
private void set_ActivityLevel(VsEtwLevel value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_ActivityId();
    [CompilerGeneratedAttribute]
private void set_ActivityId(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_RelatedActivityId();
    [CompilerGeneratedAttribute]
private void set_RelatedActivityId(Guid value);
}
[EventDataAttribute]
internal class Microsoft.Internal.VisualStudio.Diagnostics.VsEtwEventData : ValueType {
    [CompilerGeneratedAttribute]
private VsEtwSessionData <Session>k__BackingField;
    [EventFieldAttribute]
public VsEtwSessionData Session { get; public set; }
    public VsEtwEventData(VsEtwSessionData sessionData);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public VsEtwSessionData get_Session();
    [CompilerGeneratedAttribute]
public void set_Session(VsEtwSessionData value);
}
[EventDataAttribute]
internal class Microsoft.Internal.VisualStudio.Diagnostics.VsEtwEventData`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <UserData>k__BackingField;
    [CompilerGeneratedAttribute]
private VsEtwSessionData <Session>k__BackingField;
    [EventFieldAttribute]
public T UserData { get; public set; }
    [EventFieldAttribute]
public VsEtwSessionData Session { get; public set; }
    public VsEtwEventData`1(T data, VsEtwSessionData sessionData);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public T get_UserData();
    [CompilerGeneratedAttribute]
public void set_UserData(T value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public VsEtwSessionData get_Session();
    [CompilerGeneratedAttribute]
public void set_Session(VsEtwSessionData value);
}
[FlagsAttribute]
public enum Microsoft.Internal.VisualStudio.Diagnostics.VsEtwKeywords : Enum {
    public ulong value__;
    public static VsEtwKeywords Core;
    public static VsEtwKeywords Ide;
    public static VsEtwKeywords Solution;
    public static VsEtwKeywords Diagnostics;
    public static VsEtwKeywords WebTools;
    public static VsEtwKeywords FileWatcher;
    public static VsEtwKeywords TelemetryEvents;
    public static VsEtwKeywords Reserved;
}
public enum Microsoft.Internal.VisualStudio.Diagnostics.VsEtwLevel : Enum {
    public short value__;
    public static VsEtwLevel Default;
    public static VsEtwLevel Critical;
    public static VsEtwLevel Performance;
    public static VsEtwLevel ErrorAssert;
    public static VsEtwLevel Information;
    public static VsEtwLevel Verbose;
}
public static class Microsoft.Internal.VisualStudio.Diagnostics.VsEtwLogging : object {
    private static string ProviderName;
    internal static Lazy`1<EventSource> VSCommonProvider;
    internal static VsEtwSessionData SessionData;
    internal static Lazy`1<IVsEtwActivityEventWriter> ActivityEventSource;
    private static VsEtwLogging();
    public static void WriteEvent(string eventName, VsEtwKeywords keyword, VsEtwLevel level, T data, VsEtwActivity relatedActivity);
    public static void WriteEvent(string eventName, VsEtwKeywords keyword, VsEtwLevel level, T data, Guid relatedActivityId);
    public static void WriteEvent(string eventName, VsEtwKeywords keyword, T data);
    public static void WriteEvent(string eventName, VsEtwKeywords keyword, VsEtwLevel level);
    public static void WriteEvent(string eventName, VsEtwKeywords keyword, VsEtwLevel level, VsEtwActivity relatedActivity);
    public static void WriteEvent(string eventName, VsEtwKeywords keyword, VsEtwLevel level, Guid relatedActivityId);
    public static void WriteEvent(string eventName, VsEtwKeywords keyword);
    public static VsEtwActivity CreateActivity(string activityName, VsEtwKeywords keyword, VsEtwLevel level, T data);
    public static VsEtwActivity CreateActivity(string activityName, VsEtwKeywords keyword, VsEtwLevel level, VsEtwActivity relatedActivity, T data);
    public static VsEtwActivity CreateActivity(string activityName, VsEtwKeywords keyword, VsEtwLevel level);
    public static VsEtwActivity CreateActivity(string activityName, VsEtwKeywords keyword, VsEtwLevel level, VsEtwActivity relatedActivity);
    public static void WriteActivityStart(string activityName, VsEtwKeywords keyword, VsEtwLevel level, Guid activityId, Guid relatedActivityId);
    public static void WriteActivityStart(string activityName, VsEtwKeywords keyword, VsEtwLevel level, Guid activityId, Guid relatedActivityId, T data);
    public static void WriteActivityStop(string activityName, VsEtwKeywords keyword, VsEtwLevel level, Guid activityId, Guid relatedActivityId);
    public static void WriteActivityStop(string activityName, VsEtwKeywords keyword, VsEtwLevel level, Guid activityId, Guid relatedActivityId, T data);
    public static bool IsProviderEnabled(VsEtwKeywords keywords, VsEtwLevel level);
}
[EventDataAttribute]
internal class Microsoft.Internal.VisualStudio.Diagnostics.VsEtwSessionData : ValueType {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppName>k__BackingField;
    [EventFieldAttribute]
public string Version { get; public set; }
    [EventFieldAttribute]
public string AppName { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_AppName();
    [CompilerGeneratedAttribute]
public void set_AppName(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.CacheMetadataReader`2 : object {
    private ExtensionCacheEntry extensionCacheEntry;
    private IExtensionMetadataCache metadataCache;
    private IKeyConverter`1<TKey> keyConverter;
    private TraceSource traceSource;
    public ExtensionIdentificationToken Identifier { get; }
    public IEnumerable`1<string> FilePathsForUptodateCheck { get; }
    public CacheMetadataReader`2(ExtensionCacheEntry extensionCacheEntry, IExtensionMetadataCache metadataCache, IKeyConverter`1<TKey> keyConverter, TraceSource traceSource);
    public sealed virtual ExtensionIdentificationToken get_Identifier();
    public sealed virtual IEnumerable`1<string> get_FilePathsForUptodateCheck();
    public sealed virtual Task`1<ICollection`1<TKey>> GetKeysAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.CacheMetadataReader`2/<GetValueAsync>d__10")]
public sealed virtual Task`1<TValue> GetValueAsync(TKey key, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private TKey <GetKeysAsync>b__9_0(string p);
}
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.DisposableHolder`1 : object {
    private TDisposable Value;
    public DisposableHolder`1(TDisposable value);
    public TDisposable GetValue();
    public TDisposable TakeValue();
    public DisposableHolder`1<TDisposable> Move();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Microsoft.Internal.VisualStudio.Extensibility.Framework.DisposableHolderExtensions : object {
    [ExtensionAttribute]
public static DisposableHolder`1<TDisposable> Hold(TDisposable value);
}
[DataContractAttribute]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionCacheEntry : object {
    [CompilerGeneratedAttribute]
private ExtensionIdentificationToken <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, DateTime> <Timestamps>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DataMoniker>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <SectionNames>k__BackingField;
    [DataMemberAttribute]
public ExtensionIdentificationToken Extension { get; public set; }
    [DataMemberAttribute]
public IReadOnlyDictionary`2<string, DateTime> Timestamps { get; }
    [DataMemberAttribute]
public string DataMoniker { get; }
    [DataMemberAttribute]
public IReadOnlyCollection`1<string> SectionNames { get; }
    public ExtensionCacheEntry(ExtensionIdentificationToken extension, IReadOnlyDictionary`2<string, DateTime> timestamps, string dataMoniker, IReadOnlyCollection`1<string> sectionNames);
    [CompilerGeneratedAttribute]
public ExtensionIdentificationToken get_Extension();
    [CompilerGeneratedAttribute]
public void set_Extension(ExtensionIdentificationToken value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, DateTime> get_Timestamps();
    [CompilerGeneratedAttribute]
public string get_DataMoniker();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_SectionNames();
}
[IsReadOnlyAttribute]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionInstallInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInstalled>k__BackingField;
    public string Identifier { get; }
    public string InstallPath { get; }
    public bool IsInstalled { get; }
    public ExtensionInstallInfo(string identifier, string installPath, bool isInstalled);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public string get_InstallPath();
    [CompilerGeneratedAttribute]
public bool get_IsInstalled();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ExtensionIdentificationToken AsIdentificationToken();
}
[IsReadOnlyAttribute]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionInstallStateNotification : ValueType {
    public IReadOnlyList`1<ExtensionInstallInfo> ExtensionInstallStates;
    public ExtensionInstallStateNotification(IEnumerable`1<ExtensionInstallInfo> extensionInstallInfos);
}
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataReader : MetadataReader`2<string, JToken> {
    private static int MinLazyLoadFileSize;
    public static string ExtensionJsonFileName;
    public ExtensionMetadataReader(ExtensionIdentificationToken identifier, TraceSource logger, JoinableTaskFactory joinableTaskFactory, CancellationToken disposalToken);
    [IteratorStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataReader/<GetCandidateFilePaths>d__3")]
protected virtual IEnumerable`1<string> GetCandidateFilePaths(string basePath);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataReader/<ProcessMetadataFileAsync>d__4")]
protected virtual Task`1<Dictionary`2<string, AsyncLazy`1<JToken>>> ProcessMetadataFileAsync(string file, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataReader/<ProcessSectionAsync>d__5")]
private Task`1<JToken> ProcessSectionAsync(string sectionName, string filePath);
}
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataService : object {
    private IExtensionMetadataStore extensionMetadataStore;
    private CancellationTokenSource disposeToken;
    private JoinableTaskFactory joinableTaskFactory;
    private HashSet`1<ObserverRegistration> initializedObserverSet;
    private ImmutableList`1<ObserverRegistration> observers;
    private bool isInitialized;
    private object syncObject;
    public ExtensionMetadataService(IExtensionMetadataStore store, JoinableTaskFactory joinableTaskFactory);
    public sealed virtual Task`1<IDisposable> SubscribeForMetadataEventsAsync(IEnumerable`1<string> sectionNames, IObserver`1<ExtensionMetadata> observer, CancellationToken cancellationToken);
    public sealed virtual Task`1<IDisposable> SubscribeAsync(IReadOnlyList`1<string> sectionNames, IExtensionMetadataObserver observer, IReadOnlyList`1<string> dependentSections, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataService/<InternalSubscribeAsync>d__11")]
private Task`1<IDisposable> InternalSubscribeAsync(ObserverRegistration observer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataService/<OnMetadataChangedAsync>d__12")]
private Task OnMetadataChangedAsync(MetadataStoreChangedEventArgs`1<string> metadataStoreChanged, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataService/<NotifyObserverAsync>d__13")]
private Task NotifyObserverAsync(ObserverRegistration registration, HashSet`1<ObserverRegistration> notifiedObservers, IEnumerable`1<ExtensionIdentificationToken> addedExtensions, IEnumerable`1<ExtensionIdentificationToken> removedExtensions, CancellationToken cancellationToken);
    private void OnStoreChanged(object sender, MetadataStoreChangedEventArgs`1<string> args);
    private void Unsubscribe(ObserverRegistration registration);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataServiceFactory : MetadataServiceFactory`5<ExtensionMetadataService, ExtensionMetadataStore, ExtensionMetadataReader, string, JToken> {
    [NullableAttribute("2")]
private IExtensionMetadataCache extensionMetadataCache;
    public ExtensionMetadataServiceFactory(MetadataStoreSynchronizer storeSynchronizer, JoinableTaskFactory joinableTaskFactory, TraceSource logger, IExtensionMetadataCache extensionMetadataCache);
    protected virtual ExtensionMetadataService CreateService(ExtensionMetadataStore store, JoinableTaskFactory joinableTaskFactory);
    protected virtual ExtensionMetadataStore CreateStore(TraceSource logger, JoinableTaskFactory joinableTaskFactory);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataServiceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Cache_KeyNotFound { get; }
    internal static string DuplicateStringResourceFoundError { get; }
    internal static string ExtensionMetadataFileMissing { get; }
    internal static string ExtensionMetadataParseError { get; }
    internal static string ExtensionWatcher_DirectoryWatcherFailure { get; }
    internal static string ExtensionWatcher_ExtensionsChanged { get; }
    internal static string ExtensionWatcher_TriggerNotification { get; }
    internal static string MetadataStore_ExtensionProcessingError { get; }
    internal static string MetadataStore_ExtensionProvidesKeys { get; }
    internal static string MetadataStoreCache_Error { get; }
    internal static string ResourceDictionary_DuplicateKeyRemoved { get; }
    internal static string ResourceIdNotFound { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Cache_KeyNotFound();
    internal static string get_DuplicateStringResourceFoundError();
    internal static string get_ExtensionMetadataFileMissing();
    internal static string get_ExtensionMetadataParseError();
    internal static string get_ExtensionWatcher_DirectoryWatcherFailure();
    internal static string get_ExtensionWatcher_ExtensionsChanged();
    internal static string get_ExtensionWatcher_TriggerNotification();
    internal static string get_MetadataStore_ExtensionProcessingError();
    internal static string get_MetadataStore_ExtensionProvidesKeys();
    internal static string get_MetadataStoreCache_Error();
    internal static string get_ResourceDictionary_DuplicateKeyRemoved();
    internal static string get_ResourceIdNotFound();
}
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataStore : MetadataStore`3<ExtensionMetadataReader, string, JToken> {
    public static string CacheDataTypeMoniker;
    private MetadataStoreChangedEventArgs`1<string> currentStoreSet;
    private object syncObject;
    protected string DataTypeMoniker { get; }
    public ExtensionMetadataStore(TraceSource logger, JoinableTaskFactory joinableTaskFactory, IExtensionMetadataCache cache);
    protected virtual string get_DataTypeMoniker();
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionMetadataStore/<GetMetadataAsync>d__6")]
public sealed virtual Task`1<IEnumerable`1<ExtensionMetadataHeader>> GetMetadataAsync(string sectionName, CancellationToken cancellationToken);
    public virtual string ConvertStringToKey(string keyData);
    protected virtual ExtensionMetadataReader CreateReader(ExtensionIdentificationToken identifier);
    protected virtual Task OnStoreChangedAsync(MetadataStoreChangedEventArgs`1<string> args, CancellationToken cancellationToken);
    protected virtual void OnNewStoreChangedEventHandler(EventHandler`1<MetadataStoreChangedEventArgs`1<string>> eventHandler);
    private static MetadataStoreChangedEventArgs`1<string> CombineArgs(MetadataStoreChangedEventArgs`1<string> previous, MetadataStoreChangedEventArgs`1<string> next);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartCollection`1 : ExtensionPartCollectionBase`1<TContract> {
    private ImmutableDictionary`2<ExtensionPartRecord`1<TContract>, TContract> contracts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IEnumerable`1<ExtensionPartMetadata>, bool> filterCallback;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ExtensionPartsChangedEventArgs`1<TContract>> PartsAdded;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ExtensionPartsChangedEventArgs`1<TContract>> PartsRemoved;
    public ExtensionPartCollection`1(IProxyCache proxyManager, Func`2<IEnumerable`1<ExtensionPartMetadata>, bool> filterCallback, TraceSource logger);
    [NullableContextAttribute("2")]
public ExtensionPartCollection`1(IProxyCache proxyManager, Func`2<IEnumerable`1<ExtensionPartMetadata>, bool> filterCallback, TraceSource logger, JoinableTaskFactory jtf);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PartsAdded(EventHandler`1<ExtensionPartsChangedEventArgs`1<TContract>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PartsAdded(EventHandler`1<ExtensionPartsChangedEventArgs`1<TContract>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PartsRemoved(EventHandler`1<ExtensionPartsChangedEventArgs`1<TContract>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PartsRemoved(EventHandler`1<ExtensionPartsChangedEventArgs`1<TContract>> value);
    public sealed virtual IEnumerable`1<TContract> GetCurrentSet();
    protected virtual bool IsPartMetadataApplicable(ExtensionPartRegistration part);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartCollection`1/<OnExtensionPartsAddedAsync>d__12")]
protected virtual Task OnExtensionPartsAddedAsync(IEnumerable`1<ExtensionPartRecord`1<TContract>> parts, bool force);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartCollection`1/<OnExtensionPartsRemovedAsync>d__13")]
protected virtual Task OnExtensionPartsRemovedAsync(IEnumerable`1<ExtensionPartRecord`1<TContract>> parts);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartCollection`1/<OnExtensionPartUpdatedAsync>d__14")]
protected virtual Task OnExtensionPartUpdatedAsync(ExtensionPartRecord`1<TContract> oldPart, ExtensionPartRecord`1<TContract> newPart);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartCollectionBase`1 : object {
    private IProxyCache proxyManager;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<ServiceMoniker, ServiceRpcDescriptor> descriptorFactory;
    private TaskCompletionSource`1<bool> activationTaskCompletionSource;
    private AsyncSemaphore eventSemaphore;
    [NullableAttribute("2")]
private JoinableTaskFactory jtf;
    private bool disposedValue;
    private Dictionary`2<ServiceMoniker, ExtensionPartRecord`1<TContract>> contracts;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TraceSource <Logger>k__BackingField;
    private Type Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartListener.ContractType { get; }
    private Task Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartListener.ActivationTask { get; }
    [NullableAttribute("2")]
protected TraceSource Logger { get; private set; }
    public ExtensionPartCollectionBase`1(IProxyCache proxyManager, TraceSource logger, Func`2<ServiceMoniker, ServiceRpcDescriptor> descriptorFactory);
    [NullableContextAttribute("2")]
public ExtensionPartCollectionBase`1(IProxyCache proxyManager, TraceSource logger, JoinableTaskFactory jtf, Func`2<ServiceMoniker, ServiceRpcDescriptor> descriptorFactory);
    private sealed virtual override Type Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartListener.get_ContractType();
    private sealed virtual override Task Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartListener.get_ActivationTask();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected TraceSource get_Logger();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Logger(TraceSource value);
    public virtual void Activate();
    public sealed virtual void Dispose();
    protected virtual bool IsPartMetadataApplicable(ExtensionPartRegistration part);
    protected abstract virtual Task OnExtensionPartsAddedAsync(IEnumerable`1<ExtensionPartRecord`1<TContract>> parts, bool force);
    protected abstract virtual Task OnExtensionPartsRemovedAsync(IEnumerable`1<ExtensionPartRecord`1<TContract>> parts);
    protected abstract virtual Task OnExtensionPartUpdatedAsync(ExtensionPartRecord`1<TContract> oldPart, ExtensionPartRecord`1<TContract> newPart);
    private sealed virtual override bool Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartListener.IsPartApplicable(ExtensionPartRegistration part);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartCollectionBase`1/<Microsoft-Internal-VisualStudio-Extensibility-Framework-IExtensionPartListener-OnExtensionPartsAddedAsync>d__24")]
private sealed virtual override Task Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartListener.OnExtensionPartsAddedAsync(IEnumerable`1<ExtensionPartRegistration> parts, bool force);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartCollectionBase`1/<Microsoft-Internal-VisualStudio-Extensibility-Framework-IExtensionPartListener-OnExtensionPartsRemovedAsync>d__25")]
private sealed virtual override Task Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartListener.OnExtensionPartsRemovedAsync(IEnumerable`1<ExtensionPartRegistration> parts);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartCollectionBase`1/<Microsoft-Internal-VisualStudio-Extensibility-Framework-IExtensionPartListener-OnServiceAvailabilityChangedAsync>d__26")]
private sealed virtual override Task Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartListener.OnServiceAvailabilityChangedAsync(ServiceMoniker serviceMoniker);
    protected virtual void Dispose(bool disposing);
    protected void ThrowIfDisposed();
    private Task`1<TContract> GetPartProxyAsync(ServiceMoniker moniker, ExtensionIdentificationToken extension);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartLazyCollection`1 : ExtensionPartCollectionBase`1<TContract> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<LazyExtensionPartsChangedEventArgs`1<TContract>> PartsAdded;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<LazyExtensionPartsChangedEventArgs`1<TContract>> PartsRemoved;
    public ExtensionPartLazyCollection`1(IProxyCache proxyManager, TraceSource logger, Func`2<ServiceMoniker, ServiceRpcDescriptor> descriptorFactory);
    [NullableContextAttribute("2")]
public ExtensionPartLazyCollection`1(IProxyCache proxyManager, TraceSource logger, JoinableTaskFactory jtf, Func`2<ServiceMoniker, ServiceRpcDescriptor> descriptorFactory);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PartsAdded(EventHandler`1<LazyExtensionPartsChangedEventArgs`1<TContract>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PartsAdded(EventHandler`1<LazyExtensionPartsChangedEventArgs`1<TContract>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PartsRemoved(EventHandler`1<LazyExtensionPartsChangedEventArgs`1<TContract>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PartsRemoved(EventHandler`1<LazyExtensionPartsChangedEventArgs`1<TContract>> value);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartLazyCollection`1/<OnExtensionPartsAddedAsync>d__8")]
protected virtual Task OnExtensionPartsAddedAsync(IEnumerable`1<ExtensionPartRecord`1<TContract>> parts, bool force);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartLazyCollection`1/<OnExtensionPartsRemovedAsync>d__9")]
protected virtual Task OnExtensionPartsRemovedAsync(IEnumerable`1<ExtensionPartRecord`1<TContract>> parts);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartLazyCollection`1/<OnExtensionPartUpdatedAsync>d__10")]
protected virtual Task OnExtensionPartUpdatedAsync(ExtensionPartRecord`1<TContract> oldPart, ExtensionPartRecord`1<TContract> newPart);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartManager : object {
    internal static string SectionPartsName;
    private IServiceBroker serviceBroker;
    private AsyncLazy`1<ExtensionPartMetadataObserver> metadataObserver;
    private Dictionary`2<ServiceMoniker, ServiceMonikerData> cachedProxies;
    private bool disposedValue;
    [NullableAttribute("2")]
private TraceSource logger;
    public ExtensionPartManager(IServiceBroker serviceBroker);
    public ExtensionPartManager(IServiceBroker serviceBroker, JoinableTaskFactory jtf);
    public sealed virtual Task`1<IExtensionPartCollection`1<T>> GetCollectionAsync(Func`2<IEnumerable`1<ExtensionPartMetadata>, bool> filterCallback, CancellationToken cancellationToken);
    public sealed virtual Task`1<IExtensionPartCollection`1<T>> GetCollectionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartManager/<GetLazyCollectionAsync>d__10`1")]
public sealed virtual Task`1<IExtensionPartLazyCollection`1<TContract>> GetLazyCollectionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartManager/<GetLazyCollectionAsync>d__11`1")]
public sealed virtual Task`1<IExtensionPartLazyCollection`1<TContract>> GetLazyCollectionAsync(Func`2<ServiceMoniker, ServiceRpcDescriptor> descriptorFactory, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartManager/<Microsoft-Internal-VisualStudio-Extensibility-Framework-IProxyCache-GetProxyAsync>d__13`1")]
private sealed virtual override Task`1<T> Microsoft.Internal.VisualStudio.Extensibility.Framework.IProxyCache.GetProxyAsync(ServiceMoniker serviceMoniker, ExtensionIdentificationToken extension, IExtensionPartListener listener, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartManager/<Microsoft-Internal-VisualStudio-Extensibility-Framework-IProxyCache-GetProxyAsync>d__14`1")]
private sealed virtual override Task`1<T> Microsoft.Internal.VisualStudio.Extensibility.Framework.IProxyCache.GetProxyAsync(ServiceRpcDescriptor descriptor, ExtensionIdentificationToken extension, IExtensionPartListener listener, CancellationToken cancellationToken);
    private sealed virtual override void Microsoft.Internal.VisualStudio.Extensibility.Framework.IProxyCache.RemoveListener(IExtensionPartListener listener);
    protected virtual ExtensionPartServiceJsonRpcDescriptor GetServiceDescriptor(ServiceMoniker serviceMoniker, ExtensionIdentificationToken extension);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartManager/<GetCollectionInternalAsync>d__17`1")]
private Task`1<IExtensionPartCollection`1<T>> GetCollectionInternalAsync(Func`2<IEnumerable`1<ExtensionPartMetadata>, bool> filterCallback, CancellationToken cancellationToken);
    private Type[] GetInterfaceTypesForService(ServiceMoniker serviceMoniker);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartManager/<GetProxyAsync>d__19`1")]
private ValueTask`1<T> GetProxyAsync(ServiceRpcDescriptor descriptor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartManager/<GetObserverAsync>d__20")]
private Task`1<ExtensionPartMetadataObserver> GetObserverAsync();
    private void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private void InvalidateServiceMoniker(ServiceMoniker serviceMoniker, bool disposePrevious);
    private void ServiceBroker_AvailabilityChanged(object sender, BrokeredServicesChangedEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonConverterAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartMetadataConverter")]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartMetadata : object {
    [NullableAttribute("2")]
private JObject valuesObject;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Values>k__BackingField;
    public string Name { get; }
    public IReadOnlyDictionary`2<string, string> Values { get; }
    public ExtensionPartMetadata(string name, IReadOnlyDictionary`2<string, string> values, JObject valuesObject);
    public ExtensionPartMetadata(string name, IReadOnlyDictionary`2<string, string> values);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Values();
    [NullableContextAttribute("2")]
public bool TryDeserializeAs(T& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartMetadataConverter : JsonConverter`1<ExtensionPartMetadata> {
    public virtual ExtensionPartMetadata ReadJson(JsonReader reader, Type objectType, ExtensionPartMetadata existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, ExtensionPartMetadata value, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartMetadataObserver : object {
    private object syncObject;
    private IExtensionMetadataService service;
    [NullableAttribute("2")]
private TraceSource logger;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IExtensionPartListener, HashSet`1<ExtensionPartRegistration>> listeners;
    private ImmutableList`1<ExtensionPartRegistration> internalParts;
    private Dictionary`2<ServiceMoniker, HashSet`1<string>> typeMappings;
    private TaskCompletionSource`1<bool> initialDataSetAvailableTask;
    public ExtensionPartMetadataObserver(IExtensionMetadataService service, TraceSource logger);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(ExtensionMetadata value);
    public void RegisterListener(IExtensionPartListener listener);
    public void RemoveListener(IExtensionPartListener listener);
    public IReadOnlyCollection`1<string> GetTypesForServiceMoniker(ServiceMoniker serviceMoniker);
    private void NotifyListenerWithUpdatedExtensionParts(IExtensionPartListener listener, IEnumerable`1<ExtensionPartRegistration> newParts, IEnumerable`1<ExtensionPartRegistration> removedParts, bool force);
    private IEnumerable`1<ExtensionPartRegistration> RemovePartsForSection(ExtensionIdentificationToken identifier);
    private ExtensionPartRegistration AddNewPartRegistration(ExtensionPartRegistration part, ExtensionIdentificationToken identifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartRecord`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLazy`1<T> partFactory;
    private bool invalidated;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ExtensionPartMetadata> <Metadata>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ExtensionIdentificationToken <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceMoniker <ServiceMoniker>k__BackingField;
    public IEnumerable`1<ExtensionPartMetadata> Metadata { get; }
    [NullableAttribute("2")]
public ExtensionIdentificationToken Extension { get; }
    public string UniqueIdentifier { get; }
    public ServiceMoniker ServiceMoniker { get; }
    public ExtensionPartRecord`1(IEnumerable`1<ExtensionPartMetadata> metadata, AsyncLazy`1<T> partFactory, ExtensionIdentificationToken owningExtension, string uniqueIdentifier, ServiceMoniker serviceMoniker);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ExtensionPartMetadata> get_Metadata();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ExtensionIdentificationToken get_Extension();
    [CompilerGeneratedAttribute]
public string get_UniqueIdentifier();
    [CompilerGeneratedAttribute]
public ServiceMoniker get_ServiceMoniker();
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartRecord`1/<GetPartAsync>d__15")]
public Task`1<T> GetPartAsync();
    [NullableContextAttribute("2")]
public bool TryGetMetadata(string metadataName, TMetadata& value);
    internal void Invalidate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartRegistration : object {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceMoniker <ServiceMoniker>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ExtensionIdentificationToken <OwnerIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ExtensionPartMetadata> <Metadata>k__BackingField;
    public string Contract { get; }
    public ServiceMoniker ServiceMoniker { get; }
    [NullableAttribute("2")]
public ExtensionIdentificationToken OwnerIdentifier { get; public set; }
    public IReadOnlyList`1<ExtensionPartMetadata> Metadata { get; }
    public ExtensionPartRegistration(string contract, ServiceMoniker serviceMoniker, IReadOnlyList`1<ExtensionPartMetadata> metadata);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
public ServiceMoniker get_ServiceMoniker();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ExtensionIdentificationToken get_OwnerIdentifier();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_OwnerIdentifier(ExtensionIdentificationToken value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ExtensionPartMetadata> get_Metadata();
    public static ExtensionPartServiceJsonRpcDescriptor GetExtensionPartDescriptor(ServiceMoniker serviceMoniker, int version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartsChangedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private IEnumerable`1<T> <Parts>k__BackingField;
    public IEnumerable`1<T> Parts { get; }
    public ExtensionPartsChangedEventArgs`1(IEnumerable`1<T> parts);
    [CompilerGeneratedAttribute]
public IEnumerable`1<T> get_Parts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionPartServiceJsonRpcDescriptor : ServiceJsonRpcDescriptor {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CreateJsonRpcDelegate <CreateJsonRpcHook>k__BackingField;
    [NullableAttribute("2")]
public CreateJsonRpcDelegate CreateJsonRpcHook { get; public set; }
    public ExtensionPartServiceJsonRpcDescriptor(ServiceMoniker serviceMoniker, Formatters formatter, MessageDelimiters delimiter);
    protected ExtensionPartServiceJsonRpcDescriptor(ExtensionPartServiceJsonRpcDescriptor descriptor);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual CreateJsonRpcDelegate get_CreateJsonRpcHook();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CreateJsonRpcHook(CreateJsonRpcDelegate value);
    public virtual ServiceJsonRpcDescriptor WithCreateJsonRpcHook(CreateJsonRpcDelegate createJsonRpcDelegate);
    protected virtual ServiceRpcDescriptor Clone();
    protected virtual JsonRpc CreateJsonRpc(IJsonRpcMessageHandler handler);
    private sealed virtual override Void modreq(System.Runtime.CompilerServices.IsExternalInit) Microsoft.VisualStudio.RpcContracts.IHookableServiceJsonRpcDescriptor.set_CreateJsonRpcHook(CreateJsonRpcDelegate value);
}
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionary : object {
    private Dictionary`2<string, ExtensionResourceDictionaryItem> resourceDictionary;
    private Dictionary`2<string, Dictionary`2<ExtensionIdentificationToken, string>> removedDuplicateKeys;
    private TraceSource logger;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public CultureInfo Culture { get; }
    public TraceSource Logger { get; }
    public ExtensionResourceDictionary(CultureInfo culture, TraceSource logger);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    public TraceSource get_Logger();
    public bool TryGetValue(string key, String& value);
    public void RemoveResourcesProvidedByExtension(ExtensionIdentificationToken extensionIdentifier);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionary/<MergeReaderAsync>d__11")]
public Task MergeReaderAsync(IMetadataReader`2<CultureInfo, IDictionary`2<string, string>> reader, CancellationToken cancellationToken);
    private bool Add(ExtensionResourceDictionaryItem item);
    private bool Add(ExtensionIdentificationToken extensionIdentifier, string key, string value);
    private bool RemoveKey(string key);
    private bool TryGetValue(string key, ExtensionResourceDictionaryItem& resource);
}
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionaryItem : object {
    [CompilerGeneratedAttribute]
private ExtensionIdentificationToken <ExtensionIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public ExtensionIdentificationToken ExtensionIdentifier { get; }
    public string Key { get; }
    public string Value { get; }
    public ExtensionResourceDictionaryItem(ExtensionIdentificationToken extensionIdentifier, string key, string value);
    [CompilerGeneratedAttribute]
public ExtensionIdentificationToken get_ExtensionIdentifier();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionaryReader : MetadataReader`2<CultureInfo, IDictionary`2<string, string>> {
    public static CultureInfo DefaultCulture;
    public static string StringResourcesJsonFileName;
    [NullableAttribute("2")]
private CultureInfo testCulture;
    public ExtensionResourceDictionaryReader(ExtensionIdentificationToken identifier, TraceSource logger, JoinableTaskFactory joinableTaskFactory, CancellationToken disposalToken);
    public ExtensionResourceDictionaryReader(ExtensionIdentificationToken identifier, TraceSource logger, JoinableTaskFactory joinableTaskFactory, CultureInfo testCulture, CancellationToken disposalToken);
    private static ExtensionResourceDictionaryReader();
    [IteratorStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionaryReader/<GetCandidateFilePaths>d__5")]
protected virtual IEnumerable`1<string> GetCandidateFilePaths(string basePath);
    protected virtual Task`1<Dictionary`2<CultureInfo, AsyncLazy`1<IDictionary`2<string, string>>>> ProcessMetadataFileAsync(string file, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionaryReader/<ProcessDictionaryAsync>d__7")]
private Task`1<IDictionary`2<string, string>> ProcessDictionaryAsync(string filePath);
}
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionaryService : object {
    private ExtensionResourceDictionaryStore extensionResourceDictionaryStore;
    public ExtensionResourceDictionaryService(ExtensionResourceDictionaryStore extensionResourceDictionaryStore);
    public sealed virtual ValueTask`1<string> GetStringResourceAsync(CultureInfo culture, string resourceId, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionaryServiceFactory : MetadataServiceFactory`5<ExtensionResourceDictionaryService, ExtensionResourceDictionaryStore, ExtensionResourceDictionaryReader, CultureInfo, IDictionary`2<string, string>> {
    [NullableAttribute("2")]
private IExtensionMetadataCache extensionMetadataCache;
    public ExtensionResourceDictionaryServiceFactory(MetadataStoreSynchronizer storeSynchronizer, JoinableTaskFactory joinableTaskFactory, TraceSource logger, IExtensionMetadataCache extensionMetadataCache);
    protected virtual ExtensionResourceDictionaryService CreateService(ExtensionResourceDictionaryStore store, JoinableTaskFactory joinableTaskFactory);
    protected virtual ExtensionResourceDictionaryStore CreateStore(TraceSource logger, JoinableTaskFactory joinableTaskFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionaryStore : MetadataStore`3<ExtensionResourceDictionaryReader, CultureInfo, IDictionary`2<string, string>> {
    private Dictionary`2<CultureInfo, ExtensionResourceDictionary> resourceDictionaries;
    private AsyncSemaphore asyncSem;
    [NullableAttribute("2")]
private CultureInfo testCulture;
    protected string DataTypeMoniker { get; }
    public ExtensionResourceDictionaryStore(TraceSource logger, JoinableTaskFactory joinableTaskFactory, IExtensionMetadataCache extensionMetadataCache);
    public ExtensionResourceDictionaryStore(TraceSource logger, JoinableTaskFactory joinableTaskFactory, IExtensionMetadataCache extensionMetadataCache, CultureInfo testCulture);
    protected virtual string get_DataTypeMoniker();
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionaryStore/<GetStringResourceAsync>d__7")]
public sealed virtual ValueTask`1<string> GetStringResourceAsync(CultureInfo culture, string resourceId, CancellationToken cancellationToken);
    public virtual void Dispose();
    public virtual CultureInfo ConvertStringToKey(string keyData);
    public virtual string ConvertKeyToString(CultureInfo key);
    protected virtual ExtensionResourceDictionaryReader CreateReader(ExtensionIdentificationToken identifier);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionaryStore/<OnStoreChangedAsync>d__12")]
protected virtual Task OnStoreChangedAsync(MetadataStoreChangedEventArgs`1<CultureInfo> args, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionaryStore/<GetResourceDictionaryAsync>d__13")]
private Task`1<ExtensionResourceDictionary> GetResourceDictionaryAsync(CultureInfo culture, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionResourceDictionaryStore/<CreateDictionaryForCultureAsync>d__14")]
private Task`1<ExtensionResourceDictionary> CreateDictionaryForCultureAsync(CultureInfo culture, CancellationToken cancellationToken);
}
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionsChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ExtensionIdentificationToken> <AddedExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ExtensionIdentificationToken> <RemovedExtensions>k__BackingField;
    public IEnumerable`1<ExtensionIdentificationToken> AddedExtensions { get; private set; }
    public IEnumerable`1<ExtensionIdentificationToken> RemovedExtensions { get; private set; }
    public ExtensionsChangedEventArgs(IEnumerable`1<ExtensionIdentificationToken> extensionsAdded, IEnumerable`1<ExtensionIdentificationToken> extensionsRemoved);
    public ExtensionsChangedEventArgs(ExtensionsChangedEventArgs copy);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ExtensionIdentificationToken> get_AddedExtensions();
    [CompilerGeneratedAttribute]
private void set_AddedExtensions(IEnumerable`1<ExtensionIdentificationToken> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ExtensionIdentificationToken> get_RemovedExtensions();
    [CompilerGeneratedAttribute]
private void set_RemovedExtensions(IEnumerable`1<ExtensionIdentificationToken> value);
    public ExtensionsChangedEventArgs Clone();
    public void Merge(IEnumerable`1<ExtensionIdentificationToken> added, IEnumerable`1<ExtensionIdentificationToken> removed);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionWatcher : object {
    internal static string PendingDeleteFileName;
    private AsyncSemaphore extensionsChangedSemaphore;
    private IDisposable locationProviderSubscription;
    private IExtensionLocationProvider extensionsLocationProvider;
    private TraceSource logger;
    private JoinableTaskFactory joinableTaskFactory;
    private CancellationTokenSource disposalToken;
    private HashSet`1<ExtensionIdentificationToken> currentExtensions;
    private int hasInitialDirectoryInfo;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExtensionsChangedEventArgs> ExtensionsChanged;
    private ExtensionWatcher(IObservable`1<ExtensionInstallStateNotification> ExtensionInstallStateNotificationProvider, TraceSource logger, JoinableTaskFactory joinableTaskFactory, EventHandler`1<ExtensionsChangedEventArgs> extensionsChanged);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ExtensionsChanged(EventHandler`1<ExtensionsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ExtensionsChanged(EventHandler`1<ExtensionsChangedEventArgs> value);
    public static Task`1<ExtensionWatcher> CreateAsync(IObservable`1<ExtensionInstallStateNotification> ExtensionInstallStateNotificationProvider, TraceSource logger, JoinableTaskFactory joinableTaskFactory, EventHandler`1<ExtensionsChangedEventArgs> extensionsChanged, CancellationToken cancellationToken);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(ExtensionInstallStateNotification value);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.ExtensionWatcher/<ProcessExtensionChangedAsync>d__18")]
private Task ProcessExtensionChangedAsync(ExtensionInstallStateNotification installStatesToNotify, bool initializing, CancellationToken cancellationToken);
    private void HandleExtensionListUpdates(ExtensionInstallStateNotification extensionInstallStateNotification);
    private void HandleInstall(ExtensionInstallInfo installInfo);
    private void HandleUninstall(ExtensionInstallInfo installInfo);
}
internal interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IDynamicMetadataStore`1 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_StoreChanged(EventHandler`1<MetadataStoreChangedEventArgs`1<TKey>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StoreChanged(EventHandler`1<MetadataStoreChangedEventArgs`1<TKey>> value);
}
public interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionLocationProvider {
    [NullableContextAttribute("1")]
public abstract virtual bool IsExtensionValid(string extensionPath);
}
[NullableContextAttribute("1")]
public interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionMetadataCache {
    public abstract virtual Task`1<IReadOnlyCollection`1<ExtensionCacheEntry>> GetExtensionsAsync(string dataMoniker, CancellationToken cancellationToken);
    public abstract virtual Task`1<MetadataCacheResult`1<T>> TryReadFromCacheAsync(ExtensionIdentificationToken extension, string sectionName, string dataMoniker, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> InsertExtensionDataAsync(ExtensionIdentificationToken extension, IEnumerable`1<string> metadataFilePaths, string dataMoniker, Func`1<Task`1<IReadOnlyDictionary`2<string, T>>> updateFunction, CancellationToken cancellationToken);
    public abstract virtual Task RemoveExtensionDataAsync(ExtensionIdentificationToken extensionIdentificationToken, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[RpcMarshalableAttribute]
public interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionMetadataObserver {
    public abstract virtual Task OnMetadataUpdatedAsync(ExtensionMetadata updates, CancellationToken cancellationToken);
    public abstract virtual Task OnCompletedAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionMetadataStore {
    public abstract virtual Task`1<IEnumerable`1<ExtensionMetadataHeader>> GetMetadataAsync(string sectionName, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartCollection`1 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PartsAdded(EventHandler`1<ExtensionPartsChangedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PartsAdded(EventHandler`1<ExtensionPartsChangedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PartsRemoved(EventHandler`1<ExtensionPartsChangedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PartsRemoved(EventHandler`1<ExtensionPartsChangedEventArgs`1<T>> value);
    public abstract virtual void Activate();
    public abstract virtual IEnumerable`1<T> GetCurrentSet();
}
[NullableContextAttribute("1")]
public interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartLazyCollection`1 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PartsAdded(EventHandler`1<LazyExtensionPartsChangedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PartsAdded(EventHandler`1<LazyExtensionPartsChangedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PartsRemoved(EventHandler`1<LazyExtensionPartsChangedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PartsRemoved(EventHandler`1<LazyExtensionPartsChangedEventArgs`1<T>> value);
    public abstract virtual void Activate();
}
[NullableContextAttribute("1")]
internal interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartListener {
    public Type ContractType { get; }
    public Task ActivationTask { get; }
    public abstract virtual Type get_ContractType();
    public abstract virtual Task get_ActivationTask();
    public abstract virtual bool IsPartApplicable(ExtensionPartRegistration part);
    public abstract virtual Task OnExtensionPartsAddedAsync(IEnumerable`1<ExtensionPartRegistration> parts, bool force);
    public abstract virtual Task OnExtensionPartsRemovedAsync(IEnumerable`1<ExtensionPartRegistration> parts);
    public abstract virtual Task OnServiceAvailabilityChangedAsync(ServiceMoniker serviceMoniker);
}
[NullableContextAttribute("1")]
public interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionPartManager {
    public abstract virtual Task`1<IExtensionPartCollection`1<TContract>> GetCollectionAsync(Func`2<IEnumerable`1<ExtensionPartMetadata>, bool> filterCallback, CancellationToken cancellationToken);
    public abstract virtual Task`1<IExtensionPartCollection`1<TContract>> GetCollectionAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IExtensionPartLazyCollection`1<TContract>> GetLazyCollectionAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IExtensionPartLazyCollection`1<TContract>> GetLazyCollectionAsync(Func`2<ServiceMoniker, ServiceRpcDescriptor> descriptorFactory, CancellationToken cancellationToken);
}
internal interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IExtensionWatcher {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ExtensionsChanged(EventHandler`1<ExtensionsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ExtensionsChanged(EventHandler`1<ExtensionsChangedEventArgs> value);
}
public interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IInternalExtensionMetadataService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<IDisposable> SubscribeAsync(IReadOnlyList`1<string> sectionNames, IExtensionMetadataObserver observer, IReadOnlyList`1<string> dependentSections, CancellationToken cancellationToken);
}
internal interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IKeyConverter`1 {
    public abstract virtual TKey ConvertStringToKey(string keyData);
    public abstract virtual string ConvertKeyToString(TKey key);
}
internal interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IMetadataReader`2 {
    public ExtensionIdentificationToken Identifier { get; }
    public IEnumerable`1<string> FilePathsForUptodateCheck { get; }
    public abstract virtual ExtensionIdentificationToken get_Identifier();
    public abstract virtual IEnumerable`1<string> get_FilePathsForUptodateCheck();
    public abstract virtual Task`1<ICollection`1<TKey>> GetKeysAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<TValue> GetValueAsync(TKey key, CancellationToken cancellationToken);
}
internal interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IMetadataStore {
    public abstract virtual Task`1<object> OnMetadataChangedAsync(ExtensionsChangedEventArgs args, CancellationToken cancellationToken);
    public abstract virtual Task FireStoreChangedEventAsync(object eventArgs, bool force, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Internal.VisualStudio.Extensibility.Framework.IProxyCache {
    public abstract virtual Task`1<T> GetProxyAsync(ServiceMoniker serviceMoniker, ExtensionIdentificationToken extension, IExtensionPartListener listener, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> GetProxyAsync(ServiceRpcDescriptor serviceRpcDescriptor, ExtensionIdentificationToken extension, IExtensionPartListener listener, CancellationToken cancellationToken);
    public abstract virtual void RemoveListener(IExtensionPartListener listener);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.LazyExtensionPartsChangedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ExtensionPartRecord`1<T>> <Parts>k__BackingField;
    public IEnumerable`1<ExtensionPartRecord`1<T>> Parts { get; }
    public LazyExtensionPartsChangedEventArgs`1(IEnumerable`1<ExtensionPartRecord`1<T>> parts);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ExtensionPartRecord`1<T>> get_Parts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.MessageVersionContext : object {
    private AsyncLocal`1<MessageVersionHeader> executingSet;
    private ConcurrentDictionary`2<TaskCompletionSource`1<bool>, MessageVersionHeader> pendingOperations;
    private ImmutableDictionary`2<Guid, MessageVersionRequest> registeredSources;
    private ImmutableDictionary`2<Guid, long> lastObservedVersions;
    public bool TryRegisterComponent(Guid componentIdentifier, string displayName);
    public MessageVersionHeader GetCurrent();
    public bool TryIncrementVersion(Guid componentIdentifier);
    public MessageVersionHeader GetCurrentWithUpdates(MessageVersionHeader previousHeader);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MessageVersionContext/<ExecuteRequestAsync>d__8`1")]
public ValueTask`1<T> ExecuteRequestAsync(MessageVersionHeader header, Func`1<ValueTask`1<T>> func);
    private ImmutableArray`1<MessageVersionRequest> GetCurrentRequirements();
    private bool TryScheduleRequest(MessageVersionHeader header);
    private void UpdateStatePostCompletion(MessageVersionHeader header);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <UpdateStatePostCompletion>b__11_1(KeyValuePair`2<TaskCompletionSource`1<bool>, MessageVersionHeader> kvp);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.MessageVersionHeader : object {
    public static string TopLevelPropertyName;
    public static MessageVersionHeader Empty;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<MessageVersionRequest> <Requests>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public IReadOnlyCollection`1<MessageVersionRequest> Requests { get; }
    public MessageVersionHeader(IReadOnlyCollection`1<MessageVersionRequest> requests);
    [CompilerGeneratedAttribute]
protected MessageVersionHeader(MessageVersionHeader original);
    private static MessageVersionHeader();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<MessageVersionRequest> get_Requests();
    public MessageVersionHeader CreateUpdateTo(MessageVersionHeader newHeader);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MessageVersionHeader left, MessageVersionHeader right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MessageVersionHeader left, MessageVersionHeader right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(MessageVersionHeader other);
    [CompilerGeneratedAttribute]
public virtual MessageVersionHeader <Clone>$();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DataContractAttribute]
[DebuggerDisplayAttribute("v{RequiredVersion} to v{UpdatedVersion}")]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.MessageVersionRequest : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RequiredVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <UpdatedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public Guid Id { get; }
    [JsonPropertyAttribute]
[DataMemberAttribute]
public long RequiredVersion { get; }
    [JsonPropertyAttribute]
[DataMemberAttribute]
public Nullable`1<long> UpdatedVersion { get; }
    [JsonPropertyAttribute]
[DataMemberAttribute]
public string DisplayName { get; }
    public MessageVersionRequest(Guid id, long requiredVersion, Nullable`1<long> updatedVersion, string displayName);
    [CompilerGeneratedAttribute]
protected MessageVersionRequest(MessageVersionRequest original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public long get_RequiredVersion();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_UpdatedVersion();
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [NullableContextAttribute("1")]
public MessageVersionRequest WithoutDisplayName();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MessageVersionRequest left, MessageVersionRequest right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MessageVersionRequest left, MessageVersionRequest right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(MessageVersionRequest other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual MessageVersionRequest <Clone>$();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataCacheResult`1 : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public bool IsValid { get; public set; }
    public T Data { get; public set; }
    public MetadataCacheResult`1(bool IsValid, T Data);
    [CompilerGeneratedAttribute]
protected MetadataCacheResult`1(MetadataCacheResult`1<T> original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsValid(bool value);
    [CompilerGeneratedAttribute]
public T get_Data();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Data(T value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MetadataCacheResult`1<T> left, MetadataCacheResult`1<T> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MetadataCacheResult`1<T> left, MetadataCacheResult`1<T> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(MetadataCacheResult`1<T> other);
    [CompilerGeneratedAttribute]
public virtual MetadataCacheResult`1<T> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& IsValid, T& Data);
}
internal abstract class Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataReader`2 : object {
    public static string DefaultMetadataDirectoryName;
    protected CancellationToken DisposalToken;
    protected JoinableTaskFactory JoinableTaskFactory;
    private static Dictionary`2<TKey, AsyncLazy`1<TValue>> EmptyMap;
    private TraceSource logger;
    private AsyncLazy`1<Dictionary`2<TKey, AsyncLazy`1<TValue>>> map;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FilePathsForUptodateCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionIdentificationToken <Identifier>k__BackingField;
    public IEnumerable`1<string> FilePathsForUptodateCheck { get; private set; }
    public ExtensionIdentificationToken Identifier { get; }
    protected string ResolvedMetadataDirectoryName { get; }
    public MetadataReader`2(ExtensionIdentificationToken identifier, TraceSource logger, JoinableTaskFactory joinableTaskFactory, CancellationToken disposalToken);
    private static MetadataReader`2();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_FilePathsForUptodateCheck();
    [CompilerGeneratedAttribute]
private void set_FilePathsForUptodateCheck(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual ExtensionIdentificationToken get_Identifier();
    protected string get_ResolvedMetadataDirectoryName();
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataReader`2/<GetKeysAsync>d__16")]
public sealed virtual Task`1<ICollection`1<TKey>> GetKeysAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataReader`2/<GetValueAsync>d__17")]
public sealed virtual Task`1<TValue> GetValueAsync(TKey key, CancellationToken cancellationToken);
    protected abstract virtual IEnumerable`1<string> GetCandidateFilePaths(string basePath);
    protected abstract virtual Task`1<Dictionary`2<TKey, AsyncLazy`1<TValue>>> ProcessMetadataFileAsync(string file, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataReader`2/<InitializeMapAsync>d__20")]
private Task`1<Dictionary`2<TKey, AsyncLazy`1<TValue>>> InitializeMapAsync();
    private void LoadMetadataMapWithOtherMap(Dictionary`2<TKey, AsyncLazy`1<TValue>> map, Dictionary`2<TKey, AsyncLazy`1<TValue>> metadata);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataReader`2/<ProcessAndLoadJsonIntoMapAsync>d__22")]
private Task ProcessAndLoadJsonIntoMapAsync(Dictionary`2<TKey, AsyncLazy`1<TValue>> map, HashSet`1<string> filesRead, string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataServiceFactory`5 : object {
    private AsyncLazy`1<TStore> metadataStore;
    private CancellationTokenSource disposalToken;
    protected JoinableTaskFactory JoinableTaskFactory;
    public MetadataServiceFactory`5(MetadataStoreSynchronizer storeSynchronizer, JoinableTaskFactory joinableTaskFactory, TraceSource logger);
    protected abstract virtual TStore CreateStore(TraceSource logger, JoinableTaskFactory joinableTaskFactory);
    protected abstract virtual TService CreateService(TStore store, JoinableTaskFactory joinableTaskFactory);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataServiceFactory`5/<CreateServiceAsync>d__6")]
public Task`1<TService> CreateServiceAsync(JoinableTaskFactory joinableTaskFactory, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataServicesFactory : object {
    private static string TraceLevelEnvVarName;
    private MetadataStoreSynchronizer synchronizer;
    private JoinableTaskFactory joinableTaskFactory;
    [NullableAttribute("2")]
private IExtensionMetadataCache extensionMetadataCache;
    private TraceSource logger;
    private ExtensionMetadataServiceFactory extensionMetadataServiceFactory;
    private ExtensionResourceDictionaryServiceFactory extensionResourceDictionaryServiceFactory;
    private bool disposedValue;
    private MetadataServicesFactory(MetadataStoreSynchronizer synchronizer, JoinableTaskFactory joinableTaskFactory, IExtensionMetadataCache extensionMetadataCache, TraceSource logger);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataServicesFactory/<CreateExtensionMetadataServiceAsync>d__9")]
public Task`1<IExtensionMetadataService> CreateExtensionMetadataServiceAsync(TraceSource logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataServicesFactory/<CreateExtensionResourceDictionaryServiceAsync>d__10")]
public Task`1<IStringResourceDictionary> CreateExtensionResourceDictionaryServiceAsync(TraceSource logger, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataServicesFactory/<CreateAsync>d__13")]
public static Task`1<MetadataServicesFactory> CreateAsync(IObservable`1<ExtensionInstallStateNotification> extensionInstallStateNotification, TraceSource logger, JoinableTaskFactory joinableTaskFactory, IExtensionMetadataCache extensionMetadataCache, CancellationToken cancellationToken);
    public static Task`1<MetadataServicesFactory> CreateAsync(IObservable`1<ExtensionInstallStateNotification> extensionInstallStateNotification, TraceSource logger, JoinableTaskFactory joinableTaskFactory, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataServicesFactory/<CreateTraceSourceAsync>d__15`1")]
public static Task`1<TraceSource> CreateTraceSourceAsync(IServiceBroker serviceBroker, ServiceMoniker serviceMoniker, LoggerOptions options, CancellationToken cancellationToken);
    private static SourceLevels GetLogLevel();
}
internal abstract class Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStore`3 : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<MetadataStoreChangedEventArgs`1<TKey>> storeChanged;
    protected TraceSource Logger;
    protected CancellationToken DisposalToken;
    protected JoinableTaskFactory JoinableTaskFactory;
    private bool isInitialChangeRecieved;
    private CancellationTokenSource disposalToken;
    private AsyncSemaphore asyncSem;
    private AsyncSemaphore cachedUpdateSemaphore;
    private AsyncSemaphore storeChangedSemaphore;
    private IExtensionMetadataCache metadataCache;
    private Task initialCacheReadTask;
    private JoinableTaskCollection cacheUpdateTasks;
    private Dictionary`2<TKey, List`1<IMetadataReader`2<TKey, TValue>>> metadataMap;
    private Dictionary`2<ExtensionIdentificationToken, ExtensionCacheEntry> cachedExtensions;
    protected string DataTypeMoniker { get; }
    public MetadataStore`3(TraceSource logger, JoinableTaskFactory joinableTaskFactory, IExtensionMetadataCache extensionMetadataCache);
    [CompilerGeneratedAttribute]
private void add_storeChanged(EventHandler`1<MetadataStoreChangedEventArgs`1<TKey>> value);
    [CompilerGeneratedAttribute]
private void remove_storeChanged(EventHandler`1<MetadataStoreChangedEventArgs`1<TKey>> value);
    public sealed virtual void add_StoreChanged(EventHandler`1<MetadataStoreChangedEventArgs`1<TKey>> value);
    public sealed virtual void remove_StoreChanged(EventHandler`1<MetadataStoreChangedEventArgs`1<TKey>> value);
    protected abstract virtual string get_DataTypeMoniker();
    public virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStore`3/<GetMetadataReadersAsync>d__23")]
protected Task`1<IEnumerable`1<IMetadataReader`2<TKey, TValue>>> GetMetadataReadersAsync(TKey key, CancellationToken cancellationToken);
    protected abstract virtual TReader CreateReader(ExtensionIdentificationToken identifier);
    public abstract virtual TKey ConvertStringToKey(string keyData);
    public virtual string ConvertKeyToString(TKey key);
    protected virtual Task OnStoreChangedAsync(MetadataStoreChangedEventArgs`1<TKey> args, CancellationToken cancellationToken);
    protected virtual void OnNewStoreChangedEventHandler(EventHandler`1<MetadataStoreChangedEventArgs`1<TKey>> eventHandler);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStore`3/<ProcessExtensionAsync>d__29")]
private Task`1<ValueTuple`2<ICollection`1<TKey>, TReader>> ProcessExtensionAsync(ExtensionIdentificationToken identifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStore`3/<InitializeFromCacheAsync>d__30")]
private Task InitializeFromCacheAsync();
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStore`3/<OnMetadataChangedAsync>d__31")]
public sealed virtual Task`1<object> OnMetadataChangedAsync(ExtensionsChangedEventArgs args, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStore`3/<OnStoreChangedWithTelemetryAsync>d__32")]
private Task OnStoreChangedWithTelemetryAsync(MetadataStoreChangedEventArgs`1<TKey> args, CancellationToken cancellationToken);
    private void AddReader(TKey key, IMetadataReader`2<TKey, TValue> reader);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStore`3/<UpdateCacheAsync>d__34")]
private Task UpdateCacheAsync(ExtensionIdentificationToken extension, ICollection`1<TKey> keys, TReader reader);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStore`3/<FireStoreChangedEventAsync>d__35")]
public sealed virtual Task FireStoreChangedEventAsync(object eventArgs, bool force, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private TKey <InitializeFromCacheAsync>b__30_0(string p);
}
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStoreChangedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TKey> <ImpactedKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ExtensionIdentificationToken> <AddedExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ExtensionIdentificationToken> <RemovedExtensions>k__BackingField;
    public IEnumerable`1<TKey> ImpactedKeys { get; }
    public IEnumerable`1<ExtensionIdentificationToken> AddedExtensions { get; }
    public IEnumerable`1<ExtensionIdentificationToken> RemovedExtensions { get; }
    public MetadataStoreChangedEventArgs`1(IEnumerable`1<TKey> keysAffected, IEnumerable`1<ExtensionIdentificationToken> addedExtensions, IEnumerable`1<ExtensionIdentificationToken> removedExtensions);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TKey> get_ImpactedKeys();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ExtensionIdentificationToken> get_AddedExtensions();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ExtensionIdentificationToken> get_RemovedExtensions();
}
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStoreSynchronizer : object {
    private TraceSource logger;
    private CancellationTokenSource disposalToken;
    private JoinableTaskFactory joinableTaskFactory;
    private AsyncSemaphore asyncSem;
    private List`1<IMetadataStore> metadataStores;
    private ImmutableArray`1<ExtensionIdentificationToken> availableExtensions;
    private IExtensionWatcher extensionWatcher;
    private bool initialLoadComplete;
    internal MetadataStoreSynchronizer(IExtensionWatcher extensionWatcher, TraceSource logger, JoinableTaskFactory joinableTaskFactory);
    private MetadataStoreSynchronizer(TraceSource logger, JoinableTaskFactory joinableTaskFactory);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStoreSynchronizer/<CreateAsync>d__8")]
public static Task`1<MetadataStoreSynchronizer> CreateAsync(IObservable`1<ExtensionInstallStateNotification> ExtensionInstallStateNotification, TraceSource logger, JoinableTaskFactory joinableTaskFactory, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStoreSynchronizer/<CreateForUnitTestAsync>d__9")]
internal static Task`1<MetadataStoreSynchronizer> CreateForUnitTestAsync(IObservable`1<ExtensionInstallStateNotification> extensionLocations, TraceSource logger, JoinableTaskFactory joinableTaskFactory, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStoreSynchronizer/<RegisterMetadataStoreAsync>d__13")]
public Task RegisterMetadataStoreAsync(IMetadataStore store, CancellationToken cancellationToken);
    private void OnExtensionsChanged(object sender, ExtensionsChangedEventArgs args);
}
internal static class Microsoft.Internal.VisualStudio.Extensibility.Framework.MetadataStoreTelemetry : object {
    public static string EventPrefix;
    public static string PropertyPrefix;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Internal.VisualStudio.Extensibility.Framework.NullExtensionMetadataCache : object {
    public sealed virtual Task`1<bool> InsertExtensionDataAsync(ExtensionIdentificationToken extension, IEnumerable`1<string> metadataFilePaths, string dataMoniker, Func`1<Task`1<IReadOnlyDictionary`2<string, T>>> updateFunction, CancellationToken cancellationToken);
    public sealed virtual Task`1<IReadOnlyCollection`1<ExtensionCacheEntry>> GetExtensionsAsync(string dataMoniker, CancellationToken cancellationToken);
    public sealed virtual Task`1<MetadataCacheResult`1<T>> TryReadFromCacheAsync(ExtensionIdentificationToken extension, string sectionName, string dataMoniker, CancellationToken cancellationToken);
    public sealed virtual Task RemoveExtensionDataAsync(ExtensionIdentificationToken extensionIdentificationToken, CancellationToken cancellationToken);
}
internal static class Microsoft.Internal.VisualStudio.Extensibility.Framework.PathUtilities : object {
    public static bool ListContainsPathOrParentPath(IEnumerable`1<string> directories, string path);
    public static string TrimPathEnd(string path);
}
[GuidAttribute("4df39f1a-de14-4427-88a5-103e71745db5")]
public interface Microsoft.Internal.VisualStudio.Extensibility.Framework.SExtensionPartManager {
}
[NullableContextAttribute("1")]
public interface Microsoft.Internal.VisualStudio.FeatureFlags.IFeatureFlagsInternal {
    public abstract virtual string FeatureNameToPath(string featureName);
    public abstract virtual bool TryGetFlagVisibilityProperties(string featureName, string featureCollectionPath, FeatureFlag& info);
    public abstract virtual bool IsFeatureEnabledWithoutCustomization(string featureName, string featureCollectionPath, bool defaultValue);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class Microsoft.Internal.VisualStudio.PlatformUI.HybridDictionary`2 : object {
    private ICollection`1<KeyValuePair`2<TKey, TValue>> _inner;
    private IEqualityComparer`1<TKey> _keyComparer;
    internal static int cutoverPoint;
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private Dictionary`2<TKey, TValue> AsDictionary { get; }
    private List`1<KeyValuePair`2<TKey, TValue>> List { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public HybridDictionary`2(IEqualityComparer`1<TKey> keyComparer);
    [ObsoleteAttribute("Use the custructor that takes a custom comparer instead.")]
public HybridDictionary`2(bool caseInsensitive);
    public HybridDictionary`2(int capacity);
    [ObsoleteAttribute("Use the custructor that takes a custom comparer instead.")]
public HybridDictionary`2(int capacity, bool caseInsensitive);
    public HybridDictionary`2(int capacity, IEqualityComparer`1<TKey> keyComparer);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private Dictionary`2<TKey, TValue> get_AsDictionary();
    private List`1<KeyValuePair`2<TKey, TValue>> get_List();
    private int IndexOfKey(List`1<KeyValuePair`2<TKey, TValue>> list, TKey key);
    private void Insert(TKey key, TValue value, bool add);
    private Dictionary`2<TKey, TValue> UpgradeToDictionary(List`1<KeyValuePair`2<TKey, TValue>> list);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("#Entries={Count}")]
public class Microsoft.Internal.VisualStudio.PlatformUI.WeakValueDictionary`2 : object {
    private ImmutableDictionary`2<K, WeakReference> backingDictionary;
    private int capacity;
    public int Count { get; }
    public V Item { get; public set; }
    public IEnumerable`1<V> Values { get; }
    public IEnumerable`1<K> Keys { get; }
    public WeakValueDictionary`2(IEqualityComparer`1<K> keyComparer);
    public int get_Count();
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool Contains(K key);
    public bool TryGetValue(K key, V& value);
    public bool Remove(K key);
    [IteratorStateMachineAttribute("Microsoft.Internal.VisualStudio.PlatformUI.WeakValueDictionary`2/<get_Values>d__13")]
public IEnumerable`1<V> get_Values();
    public IEnumerable`1<K> get_Keys();
    public IEnumerable`1<K> GetAliveKeys();
    public void Scavenge();
    private void EnumerateAndScavenge(List`1<K> aliveKeys);
    public void Clear();
}
public enum Microsoft.Internal.VisualStudio.RemoteUI.DataTypeCode : Enum {
    public byte value__;
    public static DataTypeCode Boolean;
    public static DataTypeCode Byte;
    public static DataTypeCode SByte;
    public static DataTypeCode Int16;
    public static DataTypeCode UInt16;
    public static DataTypeCode Int32;
    public static DataTypeCode UInt32;
    public static DataTypeCode Int64;
    public static DataTypeCode UInt64;
    public static DataTypeCode Single;
    public static DataTypeCode Double;
    public static DataTypeCode DateTime;
    public static DataTypeCode Char;
    public static DataTypeCode String;
    public static DataTypeCode Invalid;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.Internal.VisualStudio.RemoteUI.Deserializer : object {
    public sealed virtual object Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    protected ValueTuple`2<object, Type> DeserializeWithTypeInfo(MessagePackReader& reader, MessagePackSerializerOptions options);
    public sealed virtual void Serialize(MessagePackWriter& writer, object value, MessagePackSerializerOptions options);
    public static Type ConvertToType(DataTypeCode typeCode);
    protected abstract virtual object GetEmptyObject();
    protected abstract virtual object GetReference(ObjectId id, MessagePackSerializerOptions options);
    protected abstract virtual object DeserializeComplexObject(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[ExtensionAttribute]
public static class Microsoft.Internal.VisualStudio.RemoteUI.RemoteUIUtilities : object {
    [NullableContextAttribute("2")]
public static object ConvertValue(object value, Type targetType);
    [ExtensionAttribute]
public static ObjectVersion NextServerVersion(ObjectVersion version);
    [ExtensionAttribute]
public static ObjectVersion NextClientVersion(ObjectVersion version);
    [ExtensionAttribute]
public static ObjectId Next(ObjectId id);
}
public enum Microsoft.Internal.VisualStudio.RemoteUI.SerializerFieldCode : Enum {
    public byte value__;
    public static SerializerFieldCode Reference;
    public static SerializerFieldCode Id;
    public static SerializerFieldCode Object;
    public static SerializerFieldCode Command;
    public static SerializerFieldCode Char;
    public static SerializerFieldCode Nullable;
    public static SerializerFieldCode NullableType;
    public static SerializerFieldCode CollectionType;
    public static SerializerFieldCode LocalDateTime;
    public static SerializerFieldCode UnspecifiedDateTime;
    public static SerializerFieldCode Version;
    public static SerializerFieldCode Collection;
    public static SerializerFieldCode NullableCollection;
    public static SerializerFieldCode Untyped;
    public static SerializerFieldCode Xaml;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.Internal.VisualStudio.RemoteUI.SimpleDataTypesSerializer : object {
    public static SerializeMethod GetSerializeMethod(Type type);
    public static SerializeMethod GetSerializeMethod(Type type, bool omitNullableHeader, DataTypeCode& dataTypeCode, Boolean& isNullableValueType);
    private static SerializeNonNullMethod GetSerializeMethodForValueType(Type type, DataTypeCode& dataTypeCode);
    private static SerializeNonNullMethod GetSerializeMethodForReferenceType(Type type, DataTypeCode& dataTypeCode);
    private static void SerializeChar(MessagePackWriter& writer, object value);
    private static void SerializeDateTime(MessagePackWriter& writer, object value);
    private static void SerializeNullable(MessagePackWriter& writer, object value, MessagePackSerializerOptions options, SerializeNonNullMethod serializeMethod);
    private static void SerializeNullableWithHeader(MessagePackWriter& writer, object value, MessagePackSerializerOptions options, DataTypeCode typeCode, SerializeNonNullMethod serializeMethod);
    private static void SerializeRerenceTypeWithHeader(MessagePackWriter& writer, object value, MessagePackSerializerOptions options, DataTypeCode typeCode, SerializeNonNullMethod serializeMethod);
}
public static class Microsoft.Internal.VisualStudio.Shell.HashHelpers : object {
    private static int HashSeed;
    private static int HashCombiningMultiplier;
    public static int GetStableHashCode(string s, bool ignoreCase);
    public static int CombineHashes(int hash1, int hash2);
}
public static class Microsoft.Internal.VisualStudio.Shell.Validate : object {
    public static void IsNotNull(object o, string paramName);
    public static void IsNull(object o, string paramName);
    public static void IsNotEmpty(string s, string paramName);
    public static void IsNotEmpty(Guid g, string paramName);
    public static void IsNotWhiteSpace(string s, string paramName);
    public static void IsNotNullAndNotEmpty(string s, string paramName);
    public static void IsNotNullAndNotWhiteSpace(string s, string paramName);
    public static void IsEqual(int value, int expectedValue, string paramName);
    public static void IsEqual(UInt32 value, UInt32 expectedValue, string paramName);
    public static void IsNotEqual(int value, int unexpectedValue, string paramName);
    public static void IsNotEqual(UInt32 value, UInt32 unexpectedValue, string paramName);
    public static void IsWithinRange(int value, int min, int max, string paramName);
    public static void IsWithinRange(long value, long min, long max, string paramName);
    public static void IsWithinRange(UInt32 value, UInt32 min, UInt32 max, string paramName);
    public static void IsWithinRange(ulong value, ulong min, ulong max, string paramName);
    public static void IsWithinRange(double value, double min, double max, string paramName);
    public static void IsNormalized(string path, string paramName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.FeatureFlags.FeatureFlag : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreviewPaneChannels>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LearnMoreUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequiredAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FeedbackUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OverrideDefaultValueChannels>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisibleToInternalUsersOnlyChannels>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisibleToExperiments>k__BackingField;
    public bool IsEnabled { get; }
    [NullableAttribute("1")]
public string Name { get; }
    public string Title { get; }
    public string PreviewPaneChannels { get; }
    public string LearnMoreUrl { get; }
    public string Description { get; }
    public string RequiredAction { get; }
    public string FeedbackUrl { get; }
    public string PackageGuid { get; }
    public string OverrideDefaultValueChannels { get; }
    public string VisibleToInternalUsersOnlyChannels { get; }
    public string VisibleToExperiments { get; }
    public FeatureFlag(string name, bool isEnabled, string title, string previewPaneChannels, string learnMoreUrl, string description, string requiredAction, string feedbackUrl, string packageGuid, string overrideDefaultValueChannels, string visibleToInternalUsersOnlyChannels, string visibleToExperiments);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Title();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PreviewPaneChannels();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_LearnMoreUrl();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Description();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_RequiredAction();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FeedbackUrl();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PackageGuid();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_OverrideDefaultValueChannels();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_VisibleToInternalUsersOnlyChannels();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_VisibleToExperiments();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.FeatureFlags.FeatureFlags : object {
    private static string FeatureNameRegExPattern;
    private static Regex FeatureNameRegex;
    private static string FlagValueName;
    private static string FlagTitleName;
    private static string FlagPreviewPaneChannels;
    private static string FlagLearnMoreUrl;
    private static string FlagDescription;
    private static string FlagRequiredAction;
    private static string FlagFeedbackUrl;
    private static string FlagPackageGuid;
    private static string FlagOverrideDefaultValueChannels;
    private static string FlagInternalVisibilityChannels;
    private static string FlagExperimentsVisibility;
    private IWritableFeatureFlagsStore customizationsStore;
    [NullableAttribute("2")]
private IFeatureFlagsStore remoteStore;
    private IFeatureFlagsStore defaultsStore;
    private object syncObject;
    private Dictionary`2<string, Nullable`1<bool>> defaultsOrRemoteStoreCache;
    private Dictionary`2<string, Nullable`1<bool>> customizationsStoreCache;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler`1<FeatureFlagsChangedEventArgs> Changed;
    internal FeatureFlags(string defaultsRegistryRoot, string customizationsRegistryRoot, string channelName);
    public FeatureFlags(IFeatureFlagsStore defaultsStore, IWritableFeatureFlagsStore customizationsStore);
    public FeatureFlags(IFeatureFlagsStore defaultsStore, IWritableFeatureFlagsStore customizationsStore, IFeatureFlagsStore remoteStore);
    private static FeatureFlags();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_Changed(EventHandler`1<FeatureFlagsChangedEventArgs> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_Changed(EventHandler`1<FeatureFlagsChangedEventArgs> value);
    public sealed virtual void Dispose();
    public sealed virtual bool IsFeatureEnabled(string featureName, bool defaultValue);
    public bool IsFeatureEnabledWithoutCustomization(string featureName, bool defaultValue);
    private sealed virtual override bool Microsoft.Internal.VisualStudio.FeatureFlags.IFeatureFlagsInternal.IsFeatureEnabledWithoutCustomization(string featureName, string featureCollectionPath, bool defaultValue);
    private bool GetFeatureValueFromStores(string featureName, bool defaultValue, bool getCustomizationValue, string flagPath);
    public sealed virtual IEnumerable`1<FeatureFlag> GetFlags();
    public bool TryGetFlag(string featureName, bool includeEnabledState, FeatureFlag& info);
    private sealed virtual override string Microsoft.Internal.VisualStudio.FeatureFlags.IFeatureFlagsInternal.FeatureNameToPath(string featureName);
    private sealed virtual override bool Microsoft.Internal.VisualStudio.FeatureFlags.IFeatureFlagsInternal.TryGetFlagVisibilityProperties(string featureName, string featureCollectionPath, FeatureFlag& info);
    private sealed virtual override void Microsoft.VisualStudio.FeatureFlags.IWritableFeatureFlags.EnableFeature(string featureName, bool enabled);
    internal static string FeatureNameToPath(string featureName);
    private void GetFlags(string collectionPath, List`1<FeatureFlag> flags);
    private bool TryGetFlag(string flagName, string collectionPath, bool includeEnabledState, bool onlyVisibilityProperties, FeatureFlag& info);
    [NullableContextAttribute("2")]
private void AddEventHandler(IFeatureFlagsStore store);
    [NullableContextAttribute("2")]
private void DropEventHandler(IFeatureFlagsStore store);
    [NullableContextAttribute("2")]
private void FeatureFlagsStoreChanged(object sender, FeatureFlagsChangedEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.FeatureFlags.FeatureFlagsChangedEventArgs : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Enabled>k__BackingField;
    public string Name { get; }
    public Nullable`1<bool> Enabled { get; }
    public FeatureFlagsChangedEventArgs(string name, Nullable`1<bool> enabled);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<bool> get_Enabled();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.FeatureFlags.IFeatureFlags {
    public abstract virtual bool IsFeatureEnabled(string name, bool defaultValue);
    public abstract virtual IEnumerable`1<FeatureFlag> GetFlags();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.FeatureFlags.IFeatureFlagsStore {
    public abstract virtual Nullable`1<bool> GetBoolValue(string collectionPath, string name);
    public abstract virtual IEnumerable`1<string> GetSubCollections(string collectionPath);
    public abstract virtual string GetString(string collectionPath, string name);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.FeatureFlags.IFeatureFlagsStore2 {
    public abstract virtual IFeatureFlagsStoreCollection GetCollection(string collectionPath);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.FeatureFlags.IFeatureFlagsStoreCollection {
    public abstract virtual Nullable`1<bool> GetBoolValue(string name);
    public abstract virtual IEnumerable`1<string> GetSubCollections();
    public abstract virtual string GetString(string name);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.FeatureFlags.IObservableFeatureFlagsStore {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler`1<FeatureFlagsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler`1<FeatureFlagsChangedEventArgs> value);
}
public interface Microsoft.VisualStudio.FeatureFlags.IObservableFeatureFlagsStore2 {
    [NullableContextAttribute("1")]
public abstract virtual void WatchForChanges(string name);
}
public interface Microsoft.VisualStudio.FeatureFlags.IWritableFeatureFlags {
    public abstract virtual void EnableFeature(string name, bool enabled);
}
public interface Microsoft.VisualStudio.FeatureFlags.IWritableFeatureFlagsStore {
    public abstract virtual void DeleteProperty(string collectionPath, string name);
    public abstract virtual void SetBool(string collectionPath, string name, bool enabled);
}
internal class Microsoft.VisualStudio.FeatureFlags.RegistryWritableFeatureFlagsStore : object {
    private static string CollectionRoot;
    private static string OverrideDefaultValueChannels;
    private string currentChannelName;
    private string registryRoot;
    public RegistryWritableFeatureFlagsStore(string registryRoot, string channelName);
    public sealed virtual void DeleteProperty(string collectionPath, string name);
    public sealed virtual void SetBool(string collectionPath, string name, bool enabled);
    public sealed virtual Nullable`1<bool> GetBoolValue(string collectionPath, string name);
    public sealed virtual string GetString(string collectionPath, string name);
    public sealed virtual IEnumerable`1<string> GetSubCollections(string collectionPath);
    private string GetFullCollectionPath(string baseCollectionPath);
    private bool DoOverrideDefaultInCurrentChannel(RegistryKey key);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.IVsService`1 {
    public abstract virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<T> GetValueOrNullAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.IVsService`2 {
}
[MessagePackObjectAttribute("False")]
public class Microsoft.VisualStudio.LogHub.Commanding.AllLogsFilter : object {
    public sealed virtual bool MatchesLogId(LogId id);
}
[UnionAttribute("1", "Microsoft.VisualStudio.LogHub.Commanding.AllLogsFilter")]
[UnionAttribute("2", "Microsoft.VisualStudio.LogHub.Commanding.LogNameFilter")]
[UnionAttribute("3", "Microsoft.VisualStudio.LogHub.Commanding.ServiceMonikerFilter")]
public interface Microsoft.VisualStudio.LogHub.Commanding.ILogIdFilter {
    public abstract virtual bool MatchesLogId(LogId id);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.LogHub.Commanding.ITraceHubCommandService {
    public abstract virtual Task FlushAsync(ILogIdFilter filter, CancellationToken cancellationToken);
    public abstract virtual Task SetVerbosityAsync(LoggingLevelSettings verbositySettings, ILogIdFilter filter, CancellationToken cancellationToken);
    public abstract virtual Task ResetVerbosityAsync(ILogIdFilter filter, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<string> GetLogPathPrefixAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MessagePackObjectAttribute("False")]
public class Microsoft.VisualStudio.LogHub.Commanding.LogNameFilter : object {
    private static Regex FilterValidator;
    [IgnoreMemberAttribute]
private string regexPattern;
    [CompilerGeneratedAttribute]
private string <NameFilter>k__BackingField;
    [KeyAttribute("0")]
public string NameFilter { get; }
    public LogNameFilter(string nameFilter);
    private static LogNameFilter();
    [CompilerGeneratedAttribute]
public string get_NameFilter();
    public sealed virtual bool MatchesLogId(LogId id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MessagePackObjectAttribute("False")]
public class Microsoft.VisualStudio.LogHub.Commanding.ServiceMonikerFilter : object {
    [CompilerGeneratedAttribute]
private ServiceMoniker <Moniker>k__BackingField;
    [KeyAttribute("0")]
public ServiceMoniker Moniker { get; }
    [SerializationConstructorAttribute]
public ServiceMonikerFilter(ServiceMoniker moniker);
    [CompilerGeneratedAttribute]
public ServiceMoniker get_Moniker();
    public sealed virtual bool MatchesLogId(LogId id);
}
public static class Microsoft.VisualStudio.LogHub.Commanding.TraceHubServices : object {
    [NullableAttribute("1")]
public static ServiceRpcDescriptor Command;
    private static TraceHubServices();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.LogHub.ITraceConfiguration {
    public abstract virtual ValueTask`1<TraceSource> RegisterLogSourceAsync(LogId id, LoggerOptions options, TraceSource traceSource, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<TraceSource> RegisterLogSourceAsync(LogId id, LoggerOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.LogHub.LocalTraceConfiguration : object {
    private static Lazy`1<LocalTraceHub> localTraceHubRegistration;
    private static LocalTraceConfiguration();
    public sealed virtual ValueTask`1<TraceSource> RegisterLogSourceAsync(LogId id, LoggerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.LogHub.LocalTraceConfiguration/<RegisterLogSourceAsync>d__2")]
public sealed virtual ValueTask`1<TraceSource> RegisterLogSourceAsync(LogId id, LoggerOptions options, TraceSource traceSource, CancellationToken cancellationToken);
    public TraceSource RegisterLogSource(LogId id, LoggerOptions options);
    public TraceSource RegisterLogSource(LogId id, LoggerOptions options, TraceSource traceSource);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.LogHub.LocalTraceHub : object {
    private static SourceLevels DefaultLoggingLevel;
    private static LoggingLevelSettings DefaultLogLevelSettings;
    private ConcurrentDictionary`2<string, RegisteredLog> logsByName;
    private ConcurrentDictionary`2<ServiceMoniker, List`1<string>> logNamesByService;
    private static LocalTraceHub();
    public sealed virtual Task`1<LogRegistration> RegisterTraceLogAsync(LogId logId, LoggerOptions options, CancellationToken cancellationToken);
    public LogRegistration RegisterTraceLog(LogId logId, LoggerOptions options);
    public sealed virtual Task`1<IDisposable> SubscribeToLogVerbosityAsync(IObserver`1<LogVerbosityState> observer, LogId logId, CancellationToken cancellationToken);
    private LoggingLevelSettings GetLogLevelSettings(LogId id, LoggerOptions options);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.LogHub.LoggingLevelSettingsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static LoggingLevelSettings ClampRange(LoggingLevelSettings value, LoggingLevelSettings min, LoggingLevelSettings max);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("SVCLog->{WriteCountedFileStreamWriter?.Name ?? "No File Attached"}")]
internal class Microsoft.VisualStudio.LogHub.ServiceLogTraceListener : TraceListener {
    private static Encoding noBOMnoFail;
    private static Random random;
    private static int maxWriteCount;
    private static int maxBytesWritten;
    private object logFilesLock;
    private string logFilePrefix;
    [NullableAttribute("2")]
private XmlWriterTraceListener underlyingListener;
    private ListenerMode state;
    private int nextFileNumber;
    private bool enableAutoFlush;
    public WriteCountedFileStreamWriter Writer { get; public set; }
    public ServiceLogTraceListener(string logFilePrefix, bool enableAutoFlush);
    private static ServiceLogTraceListener();
    public WriteCountedFileStreamWriter get_Writer();
    public void set_Writer(WriteCountedFileStreamWriter value);
    [NullableContextAttribute("2")]
public virtual void Write(string message);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string message);
    [NullableContextAttribute("2")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    [NullableContextAttribute("2")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    [NullableContextAttribute("2")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    [NullableContextAttribute("2")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    [NullableContextAttribute("2")]
public virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);
    public virtual void Flush();
    public virtual void Close();
    [NullableContextAttribute("2")]
private XmlWriterTraceListener GetUnderlyingListener();
    [NullableContextAttribute("2")]
private WriteCountedFileStreamWriter GetInitialWriter();
    private WriteCountedFileStreamWriter GetNextWriter(WriteCountedFileStreamWriter current);
    private string GetNextOutputFilePath(string currentFilePath);
    private WriteCountedFileStreamWriter CreateWriter(string filePath);
    private static string Get4RandomLetterTag();
    private static char GetRandomLetter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class Microsoft.VisualStudio.LogHub.TraceCallbackTarget : object {
    private LogId logId;
    private object operationLock;
    [NullableAttribute("2")]
private TraceSource traceSource;
    private bool flushOnSetTraceSource;
    private string DebuggerDisplay { get; }
    public TraceCallbackTarget(LogId id);
    private string get_DebuggerDisplay();
    public Task SetTraceSourceAsync(TraceSource registeredTraceSource, CancellationToken cancellationToken);
    public void SetTraceSource(TraceSource registeredTraceSource);
    public sealed virtual Task`1<IDisposable> BeginTraceStreamAsync(LogId logId, PipeWriter pipeWriter, LoggingLevelSettings verbositySettings, CancellationToken cancellationToken);
    public sealed virtual Task FlushAsync(LogId logId, CancellationToken cancellationToken);
    public void Flush(LogId logId);
    private void ValidateLogId(LogId logId);
    [CompilerGeneratedAttribute]
private void <FlushAsync>b__10_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.LogHub.TraceCollection : object {
    private static ConcurrentDictionary`2<LogId, ConcurrentBag`1<TraceSource>> traceCollection;
    private static TraceCollection();
    internal static void AddTraceSource(LogId logId, TraceSource traceSource);
    internal static IEnumerable`1<TraceSource> GetTraceSources(LogId logId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.LogHub.TraceConfiguration : object {
    private static Lazy`1<ITraceHubRegistrationService> localTraceHubRegistration;
    internal static string LogSessionKeyEnvVarName;
    private IServiceBroker serviceBroker;
    private bool ownsServiceBroker;
    private TraceConfiguration(IServiceBroker serviceBroker, bool ownsServiceBroker);
    private static TraceConfiguration();
    [ObsoleteAttribute("Use CreateTraceConfigurationInstanceAsync method with ownsServiceBroker parameter.")]
public static ValueTask`1<TraceConfiguration> CreateTraceConfigurationInstanceAsync(IServiceBroker serviceBroker, CancellationToken cancellationToken);
    public static ValueTask`1<TraceConfiguration> CreateTraceConfigurationInstanceAsync(IServiceBroker serviceBroker, bool ownsServiceBroker, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<TraceSource> RegisterLogSourceAsync(LogId id, LoggerOptions options, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<TraceSource> RegisterLogSourceAsync(LogId id, LoggerOptions options, TraceSource traceSource, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.LogHub.TraceConfiguration/<RegisterLogSourceAsync>d__9")]
public ValueTask`1<TraceSource> RegisterLogSourceAsync(LogId id, LoggerOptions options, TraceSource traceSource, bool isBootstrappedService, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static string GetLogSessionKey();
    public static string GetLogFilePathPrefix(string logName, string sessionKey);
}
internal class Microsoft.VisualStudio.LogHub.TraceSourceFactory : object {
    [NullableContextAttribute("1")]
internal static TraceSource CreateTraceSource(LogRegistration logRegistration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.LogHub.TraceSourceListener : object {
    private static ConcurrentDictionary`2<string, ServiceLogTraceListener> ListenerMap;
    private static TraceSourceListener();
    internal static bool AddListener(TraceSource traceSource, LogRegistration logRegistration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
public class Microsoft.VisualStudio.PlatformUI.AsyncObservableObject : ObservableObject {
    [IgnoreDataMemberAttribute]
private JoinableTaskFactory _jtf;
    protected AsyncObservableObject(JoinableTaskFactory jtf);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.PlatformUI.AsyncObservableObject/<NotifyPropertyChangedAsync>d__2")]
protected Task NotifyPropertyChangedAsync(CancellationToken cancellationToken, string propertyName);
    protected bool SetPropertyNotifyAsync(T& field, T newValue, Task& notificationTask, CancellationToken cancellationToken, string propertyName);
    protected bool SetPropertyNotifyAsync(T& field, T newValue, Action beforeNotifyAction, Task& notificationTask, CancellationToken cancellationToken, string propertyName);
    protected bool SetPropertyNotifyAsync(T& field, T newValue, Action`2<T, T> beforeNotifyAction, Task& notificationTask, CancellationToken cancellationToken, string propertyName);
    protected bool SetPropertyNotifyAsync(IntPtr& field, IntPtr newValue, Task& notificationTask, CancellationToken cancellationToken, string propertyName);
    protected bool SetPropertyNotifyAsync(UIntPtr& field, UIntPtr newValue, Task& notificationTask, CancellationToken cancellationToken, string propertyName);
}
public static class Microsoft.VisualStudio.PlatformUI.Boxes : object {
    public static object BooleanTrue;
    public static object BooleanFalse;
    public static object Int32Zero;
    public static object Int32One;
    public static object Int32NegativeOne;
    public static object UInt32Zero;
    public static object UInt32One;
    public static object UInt64Zero;
    public static object DoubleZero;
    private static Boxes();
    public static object Box(bool value);
    public static object Box(Nullable`1<bool> nullableValue);
    public static object Box(int value);
    public static object Box(UInt32 value);
    public static object Box(ulong value);
    public static object Box(double value);
}
public class Microsoft.VisualStudio.PlatformUI.CircularPropertyDependencyException : Exception {
    internal static string PropertyNameSeparator;
    [CompilerGeneratedAttribute]
private string <DuplicateProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Properties>k__BackingField;
    public string DuplicateProperty { get; }
    public String[] Properties { get; }
    public CircularPropertyDependencyException(string duplicateProperty, String[] properties);
    [CompilerGeneratedAttribute]
public string get_DuplicateProperty();
    [CompilerGeneratedAttribute]
public String[] get_Properties();
    private static string BuildExceptionMessage(string duplicateProperty, String[] properties);
}
public enum Microsoft.VisualStudio.PlatformUI.ContrastComparisonResult : Enum {
    public int value__;
    public static ContrastComparisonResult ContrastHigherWithBlack;
    public static ContrastComparisonResult ContrastHigherWithWhite;
    public static ContrastComparisonResult Equal;
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.PlatformUI.ConverterExceptionHelpers : object {
    private static string UnknownTypeName;
    [ExtensionAttribute]
public static Exception MakeValueNotOfTypeException(object converter, Type expectedValueType, Type actualValueType, string paramName, string caller);
    [ExtensionAttribute]
public static Exception MakeValueAtOffsetNotOfTypeException(object converter, Type expectedValueType, Type actualValueType, string paramName, int offset, string caller);
    [ExtensionAttribute]
public static Exception MakeTargetNotExtendingTypeException(object converter, Type expectedTargetType, Type actualTargetType, string caller);
    [ExtensionAttribute]
public static Exception MakeTargetAtOffsetNotExtendingTypeException(object converter, Type expectedTargetType, Type actualTargetType, int offset, string caller);
    [ExtensionAttribute]
public static Exception MakeConverterFunctionNotDefinedException(object converter, string caller);
    [ExtensionAttribute]
public static Exception MakeInsufficientSourceParametersException(object converter, int expectedCount, int actualCount, string caller);
    [ExtensionAttribute]
public static Exception MakeInsufficientTypeParametersException(object converter, int expectedCount, int actualCount, string caller);
}
[AttributeUsageAttribute("128")]
public class Microsoft.VisualStudio.PlatformUI.DependsOnPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; }
    public DependsOnPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
}
public class Microsoft.VisualStudio.PlatformUI.DependsOnPropertyNotFoundException : Exception {
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DependsOnPropertyName>k__BackingField;
    public Type DeclaringType { get; }
    public string PropertyName { get; }
    public string DependsOnPropertyName { get; }
    public DependsOnPropertyNotFoundException(Type declaringType, string propertyName, string dependsOnPropertyName);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public string get_DependsOnPropertyName();
    private static string BuildExceptionMessage(Type declaringType, string propertyName, string dependsOnPropertyName);
}
[ComVisibleAttribute("True")]
public class Microsoft.VisualStudio.PlatformUI.DisposableObject : object {
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    private EventHandler _disposing;
    public bool IsDisposed { get; private set; }
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public void add_Disposing(EventHandler value);
    public void remove_Disposing(EventHandler value);
    protected void ThrowIfDisposed();
    protected void Dispose(bool disposing);
    protected virtual void DisposeManagedResources();
    protected virtual void DisposeNativeResources();
}
public class Microsoft.VisualStudio.PlatformUI.DisposableWrapper : DisposableObject {
    private IDisposable wrappedDisposable;
    public DisposableWrapper(IDisposable wrappedDisposable);
    public DisposableWrapper(IDisposable wrappedDisposable, EventHandler disposeEventHandler);
    protected virtual void DisposeManagedResources();
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.PlatformUI.ExtensionMethods : object {
    [ExtensionAttribute]
public static bool IsCritical(Exception ex);
    [ExtensionAttribute]
public static void RaiseEvent(EventHandler`1<TEventArgs> eventHandler, object source, TEventArgs args);
    [ExtensionAttribute]
public static void RaiseEvent(EventHandler eventHandler, object source);
    [ExtensionAttribute]
public static void RaiseEvent(EventHandler eventHandler, object source, EventArgs args);
    [ExtensionAttribute]
public static void RaiseEvent(CancelEventHandler eventHandler, object source, CancelEventArgs args);
    [ExtensionAttribute]
public static void RaiseEvent(PropertyChangedEventHandler eventHandler, object source, PropertyChangedEventArgs args);
    [ExtensionAttribute]
public static void RaiseEvent(PropertyChangedEventHandler eventHandler, object source, string propertyName);
    [ExtensionAttribute]
public static void RaiseEvent(PropertyChangingEventHandler eventHandler, object source, PropertyChangingEventArgs args);
    [ExtensionAttribute]
public static void RaiseEvent(PropertyChangingEventHandler eventHandler, object source, string propertyName);
    [ExtensionAttribute]
public static void RaiseEvent(NotifyCollectionChangedEventHandler eventHandler, object source, NotifyCollectionChangedEventArgs args);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.PlatformUI.ExtensionMethods/<RaiseEventAsync>d__10`1")]
[ExtensionAttribute]
public static Task RaiseEventAsync(Delegate eventHandler, object source, T args);
}
public enum Microsoft.VisualStudio.PlatformUI.ImageScalingMode : Enum {
    public int value__;
    public static ImageScalingMode Default;
    public static ImageScalingMode BorderOnly;
    public static ImageScalingMode NearestNeighbor;
    public static ImageScalingMode Bilinear;
    public static ImageScalingMode Bicubic;
    public static ImageScalingMode HighQualityBilinear;
    public static ImageScalingMode HighQualityBicubic;
    public static ImageScalingMode MixedNearestNeighborHighQualityBicubic;
}
[DataContractAttribute]
public class Microsoft.VisualStudio.PlatformUI.ObservableObject : object {
    private static IDictionary`2<Type, IDictionary`2<string, OneOrMany`1<string>>> _typeMap;
    [IgnoreDataMemberAttribute]
private IDictionary`2<string, OneOrMany`1<string>> _propertyDependencies;
    [CompilerGeneratedAttribute]
[IgnoreDataMemberAttribute]
private PropertyChangedEventHandler PropertyChanged;
    protected bool HasPropertyChangedEventSinks { get; }
    private static ObservableObject();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void NotifyPropertyChanged(string propertyName);
    protected bool get_HasPropertyChangedEventSinks();
    protected bool SetProperty(T& field, T newValue, string propertyName);
    protected bool SetProperty(T& field, T newValue, Action beforeNotifyAction, string propertyName);
    protected bool SetProperty(T& field, T newValue, Action`2<T, T> beforeNotifyAction, string propertyName);
    protected bool SetProperty(IntPtr& field, IntPtr newValue, string propertyName);
    protected bool SetProperty(UIntPtr& field, UIntPtr newValue, string propertyName);
    private static IDictionary`2<string, OneOrMany`1<string>> BuildPropertyDependencies(Type type);
    private IEnumerable`1<string> GetDependentProperties(string property);
    private static bool AddDependentProperties(string rootProperty, string property, IDictionary`2<string, OneOrMany`1<string>> propertyDependencies, List`1& allDependentProperties);
    private static void ValidatePropertyDependencies(IDictionary`2<string, OneOrMany`1<string>> propertyDependencies);
    [CompilerGeneratedAttribute]
internal static void <BuildPropertyDependencies>g__AddToMapValues|14_1(IDictionary`2& map, string key, string valueToAdd);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.PlatformUI.PathUtil : object {
    private static string UncPrefix;
    private static Char[] DirectorySeparators;
    private static SimpleCache`1<string> _exactCasePathCache;
    private static Char[] invalidPathChars;
    private static SimpleCache`1<string> ExactCasePathCache { get; }
    private static PathUtil();
    private static SimpleCache`1<string> get_ExactCasePathCache();
    public static string Normalize(string path);
    public static bool IsNormalized(string path);
    [ExtensionAttribute]
public static string NormalizePath(string path);
    [ExtensionAttribute]
public static bool IsNormalizedPath(string path);
    public static bool IsDescendant(string parent, string child);
    public static string GetCommonPathPrefix(string path1, string path2);
    public static bool ArePathsEqual(string path1, string path2);
    public static bool IsRoot(string path);
    public static bool IsReparsePoint(string path);
    public static bool ContainsReparsePoint(string path, string pathRoot);
    public static bool IsDirectorySeparator(char c);
    public static bool IsImplicitDirectory(string directory);
    public static string SafeGetExtension(string path);
    [ExtensionAttribute]
public static string GetFileSystemCasing(string path);
    public static bool LooksLikeLocalRootedFilePath(string s);
    public static bool HasInvalidChars(string path);
    public static string MakeRelative(string relativePathBase, string pathToRelativize);
    public static string DerelativizePath(string relativePath, string basePath);
    private static string StripTrailingBackslash(string path);
    [CompilerGeneratedAttribute]
internal static bool <GetFileSystemCasing>g__CanCatchException|19_0(Exception e);
}
public class Microsoft.VisualStudio.PlatformUI.WeakCollection`1 : object {
    private List`1<WeakReference> innerList;
    public void Add(T item);
    public void Clear();
    public bool Remove(T item);
    public IList`1<T> ToList();
    public int GetAliveItemsCount();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void Prune(int anticipatedSize);
}
public class Microsoft.VisualStudio.Settings.AsyncEventHandler : MulticastDelegate {
    public AsyncEventHandler(object object, IntPtr method);
    public virtual Task Invoke(object sender, EventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs args, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.Settings.AsyncLocalBool : object {
    private AsyncLocal`1<object> asyncLocal;
    private bool defaultValue;
    public bool Value { get; public set; }
    public AsyncLocalBool(bool defaultValue);
    public bool get_Value();
    public void set_Value(bool value);
}
public class Microsoft.VisualStudio.Settings.AsyncLockedStorageCreatorDelegate`1 : MulticastDelegate {
    public AsyncLockedStorageCreatorDelegate`1(object object, IntPtr method);
    public virtual Task`1<T> Invoke(string path, bool writable, ITraceLogger logger, IDisposable storageLock, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(string path, bool writable, ITraceLogger logger, IDisposable storageLock, CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual Task`1<T> EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.Settings.AsyncStringStorageBase : object {
    protected SettingNameTranslatorWrapper nameTranslator;
    protected ITraceLogger traceLogger;
    [CompilerGeneratedAttribute]
private PropertyChangedAsyncEventHandler PropertyChangedAsync;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private StoreUpdatedEventHandler StoreUpdated;
    public AsyncStringStorageBase(IPubSubReceiver pubSubReceiver, ISettingNameTranslator nameTranslator, ITraceLogger traceLogger);
    private void OnPubSubMessageReceived(object sender, PubSubMessageEventArgs`1<string> args);
    private void OnPubSubReceiverConnected(object sender, EventArgs args);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChangedAsync(PropertyChangedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChangedAsync(PropertyChangedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StoreUpdated(StoreUpdatedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StoreUpdated(StoreUpdatedEventHandler value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Settings.ChangeSuppressor : object {
    private Func`1<int> getHighestSyncedRevisionFunc;
    private Func`2<string, Nullable`1<int>> getRevisionOfSettingFunc;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLocal`1<Suppression[]> activeSuppressions;
    public string CurrentSettingsVersion { get; }
    public ChangeSuppressor(Func`1<int> getHighestSyncedRevisionFunc, Func`2<string, Nullable`1<int>> getRevisionOfSettingFunc);
    public sealed virtual bool CanChange(string settingName);
    public sealed virtual string get_CurrentSettingsVersion();
    public sealed virtual IDisposable SuppressChangesToSettingsNewerThan(string version);
}
public class Microsoft.VisualStudio.Settings.CharSpanProcessorDelegate : MulticastDelegate {
    public CharSpanProcessorDelegate(object object, IntPtr method);
    public virtual bool Invoke(ReadOnlySpan`1<char> span);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<char> span, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.Settings.CollectionChangedAsyncEventHandler : MulticastDelegate {
    public CollectionChangedAsyncEventHandler(object object, IntPtr method);
    public virtual Task Invoke(object sender, SettingsListChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SettingsListChangedEventArgs e, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal static class Microsoft.VisualStudio.Settings.CommonStrings : object {
    public static string MetadataStorePathPrefix;
}
public class Microsoft.VisualStudio.Settings.CrossProcessMutexFactory : object {
    private static UInt32 MaxSemaphoreNameLength;
    private static string GlobalSemaphoreNamePrefix;
    private string semaphoreBaseName;
    private bool isSemaphoreNameCaseSensitive;
    private UInt32 mutexAccessMaxRetryCount;
    private TimeSpan mutexAccessRetryIntervalTimeSpan;
    private SHA256 sha256;
    private object sha256Lock;
    public CrossProcessMutexFactory(string semaphoreBaseName, bool isSemaphoreNameCaseSensitive);
    internal CrossProcessMutexFactory(string semaphoreBaseName, bool isSemaphoreNameCaseSensitive, UInt32 mutexAccessMaxRetryCount, UInt32 mutexAccessRetryIntervalInMsec);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.CrossProcessMutexFactory/<AcquireLockAsync>d__10")]
public sealed virtual Task`1<IDisposable> AcquireLockAsync(string name, CancellationToken cancellationToken);
    private string GetSemaphoreName(string name);
}
internal class Microsoft.VisualStudio.Settings.DateBasedLogFileNameProvider : object {
    private static Func`1<DateTime> DefaultClock;
    private Func`1<DateTime> clock;
    private long maxFileSize;
    private string lastFileName;
    private DateTime lastDate;
    internal DateBasedLogFileNameProvider(long maxFileSize);
    internal DateBasedLogFileNameProvider(long maxFileSize, Func`1<DateTime> clock);
    private static DateBasedLogFileNameProvider();
    public sealed virtual string GetCurrentLogFileName(string processName, int processId, long currentFileSize);
}
internal class Microsoft.VisualStudio.Settings.DebugOutputTraceLogger : object {
    public sealed virtual Task LogAsync(TraceLogEntryType entryType, string messageOrFormat, Object[] args);
    public sealed virtual Task LogSettingDeletionAsync(string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingDeletionFailureAsync(Exception exception, string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateAsync(string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateFailureAsync(Exception exception, string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateFailureAsync(string failureDescription, string storeName, string settingName, string settingValue, bool isMachineLocal, bool shouldLogTelemetry, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogClearSettingsAsync(string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual Task LogClearSettingsFailureAsync(Exception exception, string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual IDisposable BeginNoisyOperation();
    private static void WriteDebugLine(string message);
}
internal class Microsoft.VisualStudio.Settings.DelegatingTraceLogger : object {
    [CompilerGeneratedAttribute]
private ITraceLogger[] <Targets>k__BackingField;
    public ITraceLogger[] Targets { get; }
    public DelegatingTraceLogger(ITraceLogger[] targets);
    [CompilerGeneratedAttribute]
public ITraceLogger[] get_Targets();
    public sealed virtual Task LogAsync(TraceLogEntryType entryType, string messageOrFormat, Object[] args);
}
internal class Microsoft.VisualStudio.Settings.DisposableComposite : object {
    private IEnumerable`1<IDisposable> innerDisposables;
    public DisposableComposite(IEnumerable`1<IDisposable> innerDisposables);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.Settings.ExclusiveScheduler`1 : object {
    private Func`2<IReadOnlyList`1<T>, Task> worker;
    private Predicate`1<T> filter;
    private SemaphoreSlim semaphore;
    private TimeSpan batchingThreshold;
    private object pendingWorkLock;
    private List`1<T> batchedArguments;
    private bool hasPendingWork;
    private Task pendingWorkTask;
    private object batchUntilLock;
    private DateTimeOffset batchUntil;
    public ExclusiveScheduler`1(Func`2<IReadOnlyList`1<T>, Task> worker, Predicate`1<T> filter, SemaphoreSlim semaphore, TimeSpan batchingThreshold);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.ExclusiveScheduler`1/<DoWorkAsync>d__11")]
public Task DoWorkAsync(T arg);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.ExclusiveScheduler`1/<DoWorkInternalAsync>d__12")]
private Task DoWorkInternalAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.ExclusiveScheduler`1/<WaitForMoreWorkRequestsToBatchAsync>d__13")]
private Task WaitForMoreWorkRequestsToBatchAsync();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Settings.ExtensionMethods : object {
    [ExtensionAttribute]
public static StringBuilder AppendWithPadding(StringBuilder builder, ulong value, ulong max);
    [ExtensionAttribute]
public static IDictionary`2<K, V> Copy(IDictionary`2<K, V> source, IEqualityComparer`1<K> keyComparer, Func`2<V, V> valueCopier);
    [ExtensionAttribute]
public static ReadOnlyDictionary`2<K, V> CopyToReadOnly(IDictionary`2<K, V> source, IEqualityComparer`1<K> keyComparer, Func`2<V, V> valueCopier);
    [ExtensionAttribute]
public static ReadOnlyDictionary`2<K, V> ToReadOnlyDictionary(XmlElement element, IEqualityComparer`1<K> keyComparer, Func`2<XmlElement, K> keySelector, Func`2<XmlElement, V> valueSelector);
}
internal class Microsoft.VisualStudio.Settings.FileCollectionSizeController : object {
    [CompilerGeneratedAttribute]
private long <MinFileBytesToKeep>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxFileBytesToKeep>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxFileCountToKeep>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MinAgeToKeep>k__BackingField;
    public long MinFileBytesToKeep { get; }
    public long MaxFileBytesToKeep { get; }
    public int MaxFileCountToKeep { get; }
    public TimeSpan MinAgeToKeep { get; }
    public FileCollectionSizeController(long minBytes, TimeSpan minAge, long maxBytes, int maxFileCount);
    [CompilerGeneratedAttribute]
public long get_MinFileBytesToKeep();
    [CompilerGeneratedAttribute]
public long get_MaxFileBytesToKeep();
    [CompilerGeneratedAttribute]
public int get_MaxFileCountToKeep();
    [CompilerGeneratedAttribute]
public TimeSpan get_MinAgeToKeep();
    public sealed virtual void DeleteFilesIfNecessary(string folder);
}
internal class Microsoft.VisualStudio.Settings.FileTraceLogger : DisposableObject {
    private ConcurrentQueue`1<LogArgs> queue;
    private Task messageProcessorTask;
    private object messageProcessorSyncObj;
    private bool headerFileCreated;
    private Task cleanupTask;
    private object cleanupSyncObj;
    private string lastFilePath;
    private string lastFileName;
    private long lastFileSize;
    private LogArgs lastLogEntry;
    private long logEntryRepeatCount;
    private string processName;
    private int processId;
    private FileStream fileStream;
    private Mutex fileAccessMutex;
    private object disposableCacheObjectsLock;
    private Char[] charBuffer;
    private Byte[] byteBuffer;
    private string durableHostIdentity;
    [CompilerGeneratedAttribute]
private string <LogFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxFileAccessAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogFileNameProvider <FileNameProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogMessageFormatter <MessageFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileCollectionSizeController <FileCollectionSizeController>k__BackingField;
    public string LogFolder { get; }
    public int MaxFileAccessAttempts { get; }
    public ILogFileNameProvider FileNameProvider { get; }
    public ILogMessageFormatter MessageFormatter { get; }
    public IFileCollectionSizeController FileCollectionSizeController { get; }
    public FileTraceLogger(string logFolder, int maxFileAccessAttempts, ILogFileNameProvider fileNameProvider, ILogMessageFormatter messageFormatter, IFileCollectionSizeController sizeController, string durableHostIdentity);
    protected virtual void DisposeManagedResources();
    private void DisposeCacheObjects();
    [CompilerGeneratedAttribute]
public string get_LogFolder();
    [CompilerGeneratedAttribute]
public int get_MaxFileAccessAttempts();
    [CompilerGeneratedAttribute]
public ILogFileNameProvider get_FileNameProvider();
    [CompilerGeneratedAttribute]
public ILogMessageFormatter get_MessageFormatter();
    [CompilerGeneratedAttribute]
public IFileCollectionSizeController get_FileCollectionSizeController();
    public static string GetMutexName(string filePath);
    public sealed virtual Task LogAsync(TraceLogEntryType entryType, string messageOrFormat, Object[] args);
    public sealed virtual Task LogSettingUpdateAsync(string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateFailureAsync(Exception exception, string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateFailureAsync(string failureDescription, string storeName, string settingName, string settingValue, bool isMachineLocal, bool shouldLogTelemetry, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingDeletionAsync(string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingDeletionFailureAsync(Exception exception, string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogClearSettingsAsync(string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual Task LogClearSettingsFailureAsync(Exception exception, string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual IDisposable BeginNoisyOperation();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.FileTraceLogger/<InternalLogAsync>d__48")]
private Task InternalLogAsync(Task predecessor);
    private void StartLogFolderCleanupIfNotAlreadyRunning();
    private void EnsureHeaderFileCreated();
    private int SerializeWithNewline(string text);
    [CompilerGeneratedAttribute]
private void <StartLogFolderCleanupIfNotAlreadyRunning>b__49_0();
}
internal class Microsoft.VisualStudio.Settings.FilteringStoreUpdateLogger : object {
    private IStoreUpdateLogger inner;
    private string settingNamePrefixToSuppress;
    public FilteringStoreUpdateLogger(IStoreUpdateLogger inner, string settingNamePrefixToSuppress);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.FilteringStoreUpdateLogger/<LogSettingDeletionAsync>d__3")]
public sealed virtual Task LogSettingDeletionAsync(string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.FilteringStoreUpdateLogger/<LogSettingDeletionFailureAsync>d__4")]
public sealed virtual Task LogSettingDeletionFailureAsync(Exception exception, string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.FilteringStoreUpdateLogger/<LogSettingUpdateAsync>d__5")]
public sealed virtual Task LogSettingUpdateAsync(string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.FilteringStoreUpdateLogger/<LogSettingUpdateFailureAsync>d__6")]
public sealed virtual Task LogSettingUpdateFailureAsync(Exception exception, string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.FilteringStoreUpdateLogger/<LogSettingUpdateFailureAsync>d__7")]
public sealed virtual Task LogSettingUpdateFailureAsync(string failureDescription, string storeName, string settingName, string settingValue, bool isMachineLocal, bool shouldLogTelemetry, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogClearSettingsAsync(string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual Task LogClearSettingsFailureAsync(Exception exception, string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual IDisposable BeginNoisyOperation();
    private bool ShouldLog(string settingName);
}
public enum Microsoft.VisualStudio.Settings.GetValueResult : Enum {
    public int value__;
    public static GetValueResult Success;
    public static GetValueResult Missing;
    public static GetValueResult Corrupt;
    public static GetValueResult IncompatibleType;
    public static GetValueResult ObsoleteFormat;
    public static GetValueResult UnknownError;
}
public interface Microsoft.VisualStudio.Settings.IAsyncStringStorage {
    public abstract virtual Task`1<VersionedString> GetAsync(string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<NamedVersionedString>> GetAllSinceVersionAsync(int modifiedAfterRevision, CancellationToken cancellationToken);
    public abstract virtual Task`1<ServiceUploadResult> SetAsync(NamedVersionedString value, CancellationToken cancellationToken);
    public abstract virtual Task DeleteIfExistsAsync(string name, CancellationToken cancellationToken);
    public abstract virtual Task ClearAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetStoreIdentityAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyChangedAsync(PropertyChangedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyChangedAsync(PropertyChangedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StoreUpdated(StoreUpdatedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StoreUpdated(StoreUpdatedEventHandler value);
}
public interface Microsoft.VisualStudio.Settings.ICrossProcessLockFactory {
    public abstract virtual Task`1<IDisposable> AcquireLockAsync(string name, CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Settings.IdleStateChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <IsIdle>k__BackingField;
    public bool IsIdle { get; private set; }
    public IdleStateChangedEventArgs(bool isIdle);
    [CompilerGeneratedAttribute]
public bool get_IsIdle();
    [CompilerGeneratedAttribute]
private void set_IsIdle(bool value);
}
internal interface Microsoft.VisualStudio.Settings.IFileCollectionSizeController {
    public abstract virtual void DeleteFilesIfNecessary(string folder);
}
internal interface Microsoft.VisualStudio.Settings.IJsonStringSerializer {
    public abstract virtual void Serialize(string s, StringBuilder buffer);
    public abstract virtual JsonStringDeserializationResult Deserialize(string json, int startIndex);
}
internal interface Microsoft.VisualStudio.Settings.IListChanges`2 {
    public IEnumerable`1<TKey> Deletions { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TValue>> Additions { get; }
    public abstract virtual IEnumerable`1<TKey> get_Deletions();
    public abstract virtual IEnumerable`1<KeyValuePair`2<TKey, TValue>> get_Additions();
}
public interface Microsoft.VisualStudio.Settings.IListMerger {
    public abstract virtual IEnumerable`1<KeyValuePair`2<T, U>> ThreeWayMerge(IReadOnlyList`1<KeyValuePair`2<T, U>> first, IReadOnlyList`1<KeyValuePair`2<T, U>> second, IReadOnlyList`1<KeyValuePair`2<T, U>> baseline, IEqualityComparer`1<T> keyComparer, IEqualityComparer`1<U> valueComparer, ISettingsLogger logger);
}
internal interface Microsoft.VisualStudio.Settings.ILogFileNameProvider {
    public abstract virtual string GetCurrentLogFileName(string processName, int processId, long currentFileSize);
}
internal interface Microsoft.VisualStudio.Settings.ILogMessageFormatter {
    public string Header { get; }
    public abstract virtual string get_Header();
    public abstract virtual string Format(DateTime timestamp, string processName, int processId, int threadId, TraceLogEntryType entryType, string messageOrFormat, Object[] args);
}
public class Microsoft.VisualStudio.Settings.Internal.AmbientContextStoreLoggerAdapter : object {
    private IStoreUpdateLogger inner;
    private AsyncLocal`1<StoreLogPropertyInstance[]> ambientProperties;
    public AmbientContextStoreLoggerAdapter(IStoreUpdateLogger inner);
    private T GetAmbientProperty(StoreLogPropertyDefinition`1<T> definition);
    private StoreLogPropertyInstance ReplaceOrCombineWithExistingProperty(StoreLogPropertyInstance newProperty);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.AmbientContextStoreLoggerAdapter/<LogSettingDeletionAsync>d__5")]
public sealed virtual Task LogSettingDeletionAsync(string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.AmbientContextStoreLoggerAdapter/<LogSettingDeletionFailureAsync>d__6")]
public sealed virtual Task LogSettingDeletionFailureAsync(Exception ex, string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.AmbientContextStoreLoggerAdapter/<LogSettingUpdateAsync>d__7")]
public sealed virtual Task LogSettingUpdateAsync(string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.AmbientContextStoreLoggerAdapter/<LogSettingUpdateFailureAsync>d__8")]
public sealed virtual Task LogSettingUpdateFailureAsync(Exception ex, string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.AmbientContextStoreLoggerAdapter/<LogSettingUpdateFailureAsync>d__9")]
public sealed virtual Task LogSettingUpdateFailureAsync(string failureDescription, string storeName, string settingName, string settingValue, bool isMachineLocal, bool shouldLogTelemetry, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.AmbientContextStoreLoggerAdapter/<LogClearSettingsAsync>d__10")]
public sealed virtual Task LogClearSettingsAsync(string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.AmbientContextStoreLoggerAdapter/<LogClearSettingsFailureAsync>d__11")]
public sealed virtual Task LogClearSettingsFailureAsync(Exception ex, string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual IDisposable BeginNoisyOperation();
    public sealed virtual IDisposable SetContext(StoreLogPropertyInstance[] properties);
}
public abstract class Microsoft.VisualStudio.Settings.Internal.AsyncLocalRestorer : object {
    public static AsyncLocalRestorer Create(AsyncLocal`1<T> asyncLocal);
    public abstract virtual void Dispose();
}
public class Microsoft.VisualStudio.Settings.Internal.AsyncStorageFactory`1 : object {
    private AsyncLockedStorageCreatorDelegate`1<T> constructWithLockAsync;
    public static int PendingAccessRequests { get; }
    public AsyncStorageFactory`1(AsyncLockedStorageCreatorDelegate`1<T> constructWithLockAsync);
    public static int get_PendingAccessRequests();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.AsyncStorageFactory`1/<OpenAsync>d__4")]
public Task`1<T> OpenAsync(string path, ITraceLogger logger, TimeSpan timeout, bool writable, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.AsyncStorageFactory`1/<CreateInstanceAsync>d__5")]
private Task`1<T> CreateInstanceAsync(string path, bool writable, ITraceLogger logger, IDisposable storageLock, CancellationToken cancellationToken);
}
internal class Microsoft.VisualStudio.Settings.Internal.ExclusiveFileOpener : object {
    private string path;
    private FileStream stream;
    private FileAccess access;
    private FileShare sharing;
    [CompilerGeneratedAttribute]
private bool <ShouldDelayBeforeNextAttempt>k__BackingField;
    public bool ShouldDelayBeforeNextAttempt { get; public set; }
    public bool ShouldTryAgain { get; }
    public ExclusiveFileOpener(string path, FileAccess access, FileShare sharing);
    [CompilerGeneratedAttribute]
public bool get_ShouldDelayBeforeNextAttempt();
    [CompilerGeneratedAttribute]
public void set_ShouldDelayBeforeNextAttempt(bool value);
    public bool get_ShouldTryAgain();
    public FileStream EnsureStream();
    public void TryOpenFileStream();
}
public class Microsoft.VisualStudio.Settings.Internal.FireAndForgetTaskTracker : object {
    private List`1<Task> workInProgress;
    public Task WorkInProgress { get; }
    public void Start(Task action, Action`1<Exception> exceptionHandler);
    private void AddToWorkInProgress(Task task);
    private static void RemoveCompletedTasksFromList(List`1<Task> list);
    public Task get_WorkInProgress();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.FireAndForgetTaskTracker/<FinishAllWorkAsync>d__6")]
public Task FinishAllWorkAsync();
}
public static class Microsoft.VisualStudio.Settings.Internal.HttpEscaper : object {
    public static char UriEscapeChar;
    private static char InternalEscapeChar;
    private static string InternalEscapeCharAsString;
    private static string EscapedInternalEscapeChar;
    public static string InternalEscapeCharNullEncoding;
    public static string Escape(string s);
    public static string Unescape(string s);
}
public interface Microsoft.VisualStudio.Settings.Internal.IIndexedStorage {
    public IDictionary`2<string, string> GlobalContent { get; }
    public IDictionary`2<string, IDictionary`2<string, string>> IndexedContent { get; }
    public abstract virtual IDictionary`2<string, string> get_GlobalContent();
    public abstract virtual IDictionary`2<string, IDictionary`2<string, string>> get_IndexedContent();
}
public interface Microsoft.VisualStudio.Settings.Internal.ISettingsManagerResetUserData {
    public bool ClearSettingsOnStoreInitialization { get; public set; }
    public IEnumerable`1<string> ClearSettings { get; public set; }
    public abstract virtual bool get_ClearSettingsOnStoreInitialization();
    public abstract virtual void set_ClearSettingsOnStoreInitialization(bool value);
    public abstract virtual IEnumerable`1<string> get_ClearSettings();
    public abstract virtual void set_ClearSettings(IEnumerable`1<string> value);
}
public interface Microsoft.VisualStudio.Settings.Internal.ITraceLogger {
    public abstract virtual Task LogAsync(TraceLogEntryType entryType, string messageOrFormat, Object[] args);
}
public class Microsoft.VisualStudio.Settings.Internal.JsonEqualityComparer : object {
    public static JsonEqualityComparer Instance;
    private static JsonEqualityComparer();
    private string DoSerialize(object o);
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
public class Microsoft.VisualStudio.Settings.Internal.JsonUtilities : object {
    public static bool TryGetContentOfJValue(object target, Object& result);
    public static IEnumerable`1<KeyValuePair`2<string, object>> GetPropertiesOfJsonObject(object target);
}
public static class Microsoft.VisualStudio.Settings.Internal.LoggerFactory : object {
    private static string durableHostIdentity;
    private static Lazy`1<DebugOutputTraceLogger> debugLoggerLazy;
    private static Lazy`1<FileTraceLogger> fileLoggerLazy;
    private static Lazy`1<ITraceLogger> traceLoggersLazy;
    private static Lazy`1<IStoreUpdateLogger> storeLoggersLazy;
    public static ITraceLogger DefaultTraceLogger { get; }
    public static IStoreUpdateLogger DefaultStoreUpdateLogger { get; }
    private static LoggerFactory();
    public static void Reset();
    public static void InitializeDefaultLogger(string durableHostIdentityVal);
    public static ITraceLogger get_DefaultTraceLogger();
    public static IStoreUpdateLogger get_DefaultStoreUpdateLogger();
    private static ITraceLogger CreateTraceLoggers();
    private static IStoreUpdateLogger CreateStoreLoggers();
    private static DebugOutputTraceLogger CreateDebugLogger();
    private static FileTraceLogger CreateFileLogger();
}
public class Microsoft.VisualStudio.Settings.Internal.NoOpDisposable : object {
    [CompilerGeneratedAttribute]
private static NoOpDisposable <Instance>k__BackingField;
    public static NoOpDisposable Instance { get; }
    private static NoOpDisposable();
    [CompilerGeneratedAttribute]
public static NoOpDisposable get_Instance();
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.Settings.Internal.PrioritizedFifoSemaphore : object {
    private AsyncReaderWriterLock accessLock;
    private List`1<Waiter> waiters;
    private AsyncSemaphore processingLock;
    public int WaitingCount { get; }
    public PrioritizedFifoSemaphore(JoinableTaskContext joinableTaskContext);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.PrioritizedFifoSemaphore/<WaitForAccessAsync>d__6")]
public Task`1<IDisposable> WaitForAccessAsync(int priority, LockType lockType, CancellationToken cancellationToken);
    public int get_WaitingCount();
    private Waiter EnqueueWaiter(int priority, LockType lockType);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.PrioritizedFifoSemaphore/<ProcessOneRequestAsync>d__10")]
private Task ProcessOneRequestAsync();
}
public class Microsoft.VisualStudio.Settings.Internal.Serializer : object {
    private static Type[] EmptyTypeArray;
    private static Object[] EmptyObjectArray;
    private static Char[] EmptyJsonArrayCharacters;
    private static char SpecialTypeIndicator;
    private static string NullValueAsString;
    private static string DecoratedNullValue;
    private static Dictionary`2<string, Tuple`2<Type, TypeConverter>> _specialTypes;
    private ISettingsLogger _logger;
    private static object jsonSerializerSettings;
    internal static object JsonSerializerSettings { get; }
    private static Serializer();
    public Serializer(ISettingsLogger logger);
    internal static object get_JsonSerializerSettings();
    public string Serialize(object obj, bool makeConsistentWithJsonRoundTripping);
    private static object ConvertToJsonDotNetPreferredDeserializationType(object obj);
    public static bool IsNullOrSerializedNull(string s);
    private static TypeConverter GetConverter(string typeName);
    public GetValueResult Deserialize(string s, T& result);
    public GetValueResult Deserialize(string s, bool shouldLogTypeConversionErrors, T& result);
    public static bool TryCastWithUnboxing(object value, T& result);
    private static bool TryReboxAnyIntegralTypeAs(Object& boxed);
    private static bool TryReboxByteAs(Object& boxed);
    private static bool TryReboxSbyteAs(Object& boxed);
    private static bool TryReboxInt16As(Object& boxed);
    private static bool TryReboxUint16As(Object& boxed);
    private static bool TryReboxInt32As(Object& boxed);
    private static bool TryReboxUint32As(Object& boxed);
    private static bool TryReboxInt64As(Object& boxed);
    private static bool TryReboxUint64As(Object& boxed);
    private static bool TryReboxFloatAs(Object& boxed);
    private static bool TryReboxDoubleAs(Object& boxed);
    private static bool TryReboxDecimalAs(Object& boxed);
    public string ConvertToEfficientRepresentation(string s);
    private string SerializeAsDoubleOrDecimal(JToken token);
    private static string SerializeToJson(object obj);
    private static string SerializeWithJsonDotNet(object obj);
    private GetValueResult DeserializeFromJson(SettingLogContext context, string s, bool shouldLogTypeConversionErrors, T& result);
    private static bool TryDefaultConstruct(T& result);
    private static bool IsEnumerableType(Type type);
    private static bool IsEmptyJsonArray(string s);
    private GetValueResult DeserializeWithJsonDotNet(SettingLogContext context, string s, bool shouldLogTypeConversionErrors, T& result);
    public static bool IsList(string json);
    private static bool IsListOfKeyValuePairs(JToken token);
    private static bool IsKeyValuePair(JToken token);
    private static bool IsProperty(JToken token, string expectedName);
    private static bool IsStringProperty(JToken token, string expectedName);
    private static bool IsString(JToken token);
    [CompilerGeneratedAttribute]
private void <Deserialize>g__LogErrorIfRequested|18_0(Exception ex, <>c__DisplayClass18_0`1& );
}
public static class Microsoft.VisualStudio.Settings.Internal.SettingsManagerConstants : object {
    public static string RoamingAndSharingEnabledSetting;
    public static string Dev12MigratedSettingPrefix;
    public static string SettingChangedPubSubMessage;
    public static string CoreProfileChangedPubSubMessage;
}
[SupportedOSPlatformAttribute("windows8.0")]
public class Microsoft.VisualStudio.Settings.Internal.SingleFileIndexedStorage : DisposableObject {
    private static Cache StaticCache;
    internal static string SizeName;
    internal static string ValueNameFormat;
    internal static string SettingPrefix;
    internal static string GlobalsName;
    internal static string SettingNamesName;
    private static int MaxValueLength;
    private static char ValuePrependChar;
    private string path;
    private bool writable;
    private IDisposable storageLock;
    private LazyDictionary`2<string, IDictionary`2<string, string>> indexedContent;
    private ITraceLogger logger;
    [CompilerGeneratedAttribute]
private static StorageFactory`1<IIndexedStorage> <Factory>k__BackingField;
    public static StorageFactory`1<IIndexedStorage> Factory { get; }
    public IDictionary`2<string, string> GlobalContent { get; }
    public IDictionary`2<string, IDictionary`2<string, string>> IndexedContent { get; }
    internal SingleFileIndexedStorage(string path, bool writable, ITraceLogger logger, IDisposable storageLock);
    private static SingleFileIndexedStorage();
    [CompilerGeneratedAttribute]
public static StorageFactory`1<IIndexedStorage> get_Factory();
    private void SetProfileString(string key, string value);
    private bool IsSameAsPreviousContent(string key, string value);
    private static bool CharacterNeedsEscape(char c);
    private void RemoveProfileStringSections(string key, int sectionStartIndex);
    private void RemoveProfileString(string key);
    private string GetProfileString(string key);
    private T ReadAndDeserialize(string key, Func`3<LimitedJsonSerializer, string, T> deserialize);
    private static string EscapeString(string toEscape);
    private static string UnescapeString(string toUnescape);
    private static int CountCharactersThatNeedEscaping(string input);
    private Dictionary`2<string, string> ReadDictionary(string key);
    private String[] ReadArray(string key);
    private IDictionary`2<string, string> ReadSettingContent(string name);
    protected virtual void DisposeManagedResources();
    public static void ClearCache();
    public sealed virtual IDictionary`2<string, string> get_GlobalContent();
    public sealed virtual IDictionary`2<string, IDictionary`2<string, string>> get_IndexedContent();
}
internal static class Microsoft.VisualStudio.Settings.Internal.StorageAccess : object {
    private static string LockFileSuffix;
    private static int SyncAccessPriority;
    private static int AsyncAccessPriority;
    private static PrioritizedFifoSemaphore accessQueue;
    public static int PendingAccessRequests { get; }
    private static StorageAccess();
    public static int get_PendingAccessRequests();
    public static IDisposable Open(string path, TimeSpan timeout, bool writable);
    public static Task`1<IDisposable> OpenAsync(string path, bool writable, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.StorageAccess/<OpenAsync>d__8")]
private static Task`1<IDisposable> OpenAsync(string path, int priority, bool writable, CancellationToken cancellationToken);
    public static Task`1<IDisposable> OpenAsync(string path, TimeSpan timeout, bool writable, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.StorageAccess/<OpenAsync>d__10")]
public static Task`1<IDisposable> OpenAsync(string path, int priority, TimeSpan timeout, bool writable, CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Settings.Internal.StorageFactory`1 : object {
    private NonLockedStorageCreatorDelegate`1<T> tryConstructWithoutLock;
    private LockedStorageCreatorDelegate`1<T> constructWithLock;
    public static int PendingAccessRequests { get; }
    public StorageFactory`1(NonLockedStorageCreatorDelegate`1<T> tryConstructWithoutLock, LockedStorageCreatorDelegate`1<T> constructWithLock);
    public static int get_PendingAccessRequests();
    public T Open(string path, TimeSpan timeout, bool writable);
    public T Open(string path, ITraceLogger logger, TimeSpan timeout, bool writable);
    public Task`1<T> OpenAsync(string path, bool writable, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.StorageFactory`1/<OpenAsync>d__8")]
public Task`1<T> OpenAsync(string path, ITraceLogger logger, bool writable, CancellationToken cancellationToken);
    public Task`1<T> OpenAsync(string path, TimeSpan timeout, bool writable, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.Internal.StorageFactory`1/<OpenAsync>d__10")]
public Task`1<T> OpenAsync(string path, ITraceLogger logger, TimeSpan timeout, bool writable, CancellationToken cancellationToken);
    private T CreateInstance(string path, bool writable, ITraceLogger logger, IDisposable storageLock);
}
public class Microsoft.VisualStudio.Settings.Internal.StoreUpdateLoggerComposite : object {
    [CompilerGeneratedAttribute]
private IStoreUpdateLogger[] <Targets>k__BackingField;
    public IStoreUpdateLogger[] Targets { get; }
    public StoreUpdateLoggerComposite(IStoreUpdateLogger[] targets);
    [CompilerGeneratedAttribute]
public IStoreUpdateLogger[] get_Targets();
    public sealed virtual Task LogSettingDeletionAsync(string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingDeletionFailureAsync(Exception exception, string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateAsync(string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateFailureAsync(Exception exception, string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateFailureAsync(string failureDescription, string storeName, string settingName, string settingValue, bool isMachineLocal, bool shouldLogTelemetry, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogClearSettingsAsync(string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual Task LogClearSettingsFailureAsync(Exception exception, string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual IDisposable BeginNoisyOperation();
}
public enum Microsoft.VisualStudio.Settings.Internal.TraceLogEntryType : Enum {
    public int value__;
    public static TraceLogEntryType Error;
    public static TraceLogEntryType Warning;
    public static TraceLogEntryType Info;
}
[SupportedOSPlatformAttribute("windows8.0")]
public class Microsoft.VisualStudio.Settings.Internal.XmlIndexedStorage : DisposableObject {
    private static string DataFileExtension;
    private static Cache cache;
    private static object cacheLock;
    private bool writable;
    private IDisposable storageLock;
    private ITraceLogger logger;
    private IDictionary`2<string, string> globalContent;
    private IDictionary`2<string, IDictionary`2<string, string>> indexedContent;
    private string path;
    [CompilerGeneratedAttribute]
private static StorageFactory`1<IIndexedStorage> <Factory>k__BackingField;
    public static StorageFactory`1<IIndexedStorage> Factory { get; }
    public IDictionary`2<string, string> GlobalContent { get; }
    public IDictionary`2<string, IDictionary`2<string, string>> IndexedContent { get; }
    public XmlIndexedStorage(string path, bool writable, ITraceLogger logger, IDisposable storageLock);
    private XmlIndexedStorage(Cache cacheSnapshot, ITraceLogger logger);
    private static XmlIndexedStorage();
    [CompilerGeneratedAttribute]
public static StorageFactory`1<IIndexedStorage> get_Factory();
    private static XmlIndexedStorage CreateInstanceAgainstCacheSnapshot(string path, bool writable, ITraceLogger logger);
    private Content TryReadXml(string filePath);
    private Content ReadOldFormat(string oldFormatFilePath);
    private static Content MakeReadOnlyContent(IDictionary`2<string, string> globalContent, IDictionary`2<string, IDictionary`2<string, string>> indexedContent);
    private static ReadOnlyDictionary`2<K, V> ReadOnlyOrNull(IDictionary`2<K, V> input);
    private static IDictionary`2<string, IDictionary`2<string, string>> DictionaryOfDictionariesFromElement(XmlElement element);
    private static IDictionary`2<string, V> DictionaryFromElement(XmlElement element, Func`2<XmlElement, V> valueSelector);
    private static IDictionary`2<string, string> DictionaryOrNullFromElement(XmlElement element);
    private static T ElementValueOrNull(XmlElement element, Func`2<XmlElement, T> valueSelector);
    private static IDictionary`2<string, string> DictionaryFromElement(XmlElement element);
    private static string ElementValueOrNull(XmlElement element);
    private static XmlElement CreateNamedValueElement(KeyValuePair`2<string, string> kvp, XmlDocument document);
    private static void AddValuesToElement(IDictionary`2<string, string> collection, XmlElement element, XmlDocument document);
    private static void AddCollectionsToElement(IDictionary`2<string, IDictionary`2<string, string>> collection, XmlElement element, XmlDocument document);
    private static void AddValuesToElement(IDictionary`2<T, V> collection, XmlElement element, XmlDocument document, Func`3<KeyValuePair`2<T, V>, XmlDocument, XmlElement> valueSerializer);
    private static XmlElement CreateNamedValueCollectionElement(KeyValuePair`2<string, IDictionary`2<string, string>> kvp, XmlDocument document);
    private static XmlElement CreateNamedValueElement(KeyValuePair`2<string, V> kvp, XmlDocument document, string nonNullName, Action`3<V, XmlElement, XmlDocument> valueSerializer);
    private static void CreateAndPopulateElement(string name, IDictionary`2<string, V> collection, XmlElement parent, XmlDocument document, Action`3<IDictionary`2<string, V>, XmlElement, XmlDocument> serializer);
    protected virtual void DisposeManagedResources();
    public static void ClearCache();
    public sealed virtual IDictionary`2<string, string> get_GlobalContent();
    public sealed virtual IDictionary`2<string, IDictionary`2<string, string>> get_IndexedContent();
}
internal interface Microsoft.VisualStudio.Settings.IPubSubReceiver {
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnMessageReceived(MessageReceivedEventHandler`1<string> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnMessageReceived(MessageReceivedEventHandler`1<string> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Connected(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Connected(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_EventReceived(EventHandler`1<SettingsEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EventReceived(EventHandler`1<SettingsEventArgs> value);
}
public interface Microsoft.VisualStudio.Settings.IRemoteDefaultsStore {
    public abstract virtual T GetSettingDefault(string collection, string name, T defaultValue);
    public abstract virtual bool CollectionExists(string collection);
}
internal interface Microsoft.VisualStudio.Settings.IServiceHubClient {
    public abstract virtual Task`1<Stream> RequestServiceAsync(string serviceName, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Settings.ISettingNameTranslator {
    public abstract virtual string GetSharedNameFromPrivateName(string privateName);
    public abstract virtual string GetPrivateNameFromSharedName(string sharedName);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Settings.ISettingsChangeSuppressor {
    public string CurrentSettingsVersion { get; }
    public abstract virtual string get_CurrentSettingsVersion();
    public abstract virtual IDisposable SuppressChangesToSettingsNewerThan(string version);
    public abstract virtual bool CanChange(string settingName);
}
public interface Microsoft.VisualStudio.Settings.ISettingsList {
    public String[] Keys { get; }
    public abstract virtual Task AddToFrontAsync(string key, object value, object state);
    public abstract virtual T GetValueOrDefault(string key, T defaultValue);
    public abstract virtual Task ClearAsync(object state);
    public abstract virtual Task RemoveAsync(string key, object state);
    public abstract virtual String[] get_Keys();
    public abstract virtual Task RefreshContentFromStoreAsync();
    [CompilerGeneratedAttribute]
public abstract virtual void add_CollectionChangedAsync(CollectionChangedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CollectionChangedAsync(CollectionChangedAsyncEventHandler value);
}
internal interface Microsoft.VisualStudio.Settings.ISettingsListInternal {
    public List`1<KeyValuePair`2<string, object>> Content { get; }
    public abstract virtual List`1<KeyValuePair`2<string, object>> get_Content();
    public abstract virtual Task RemoveAsync(IEnumerable`1<string> keys, object state);
    public abstract virtual Task InsertAtIndexAsync(int index, string key, object value, object state);
}
public interface Microsoft.VisualStudio.Settings.ISettingsManager {
    public abstract virtual Task SetValueAsync(string name, object value, bool isMachineLocal);
    public abstract virtual T GetValueOrDefault(string name, T defaultValue);
    public abstract virtual GetValueResult TryGetValue(string name, T& value);
    public abstract virtual ISettingsList GetOrCreateList(string name, bool isMachineLocal);
    public abstract virtual String[] NamesStartingWith(string prefix);
    public abstract virtual ISettingsSubset GetSubset(string namePattern);
    public abstract virtual void SetSharedStore(IAsyncStringStorage store);
    public abstract virtual void SetOnlineStore(IAsyncStringStorage store);
}
public interface Microsoft.VisualStudio.Settings.ISettingsManager2 {
    public IStoreUpdateLoggerWithAmbientContext StoreUpdateLogger { get; }
    public abstract virtual IStoreUpdateLoggerWithAmbientContext get_StoreUpdateLogger();
    public abstract virtual Nullable`1<int> GetRevision(string settingName);
}
public interface Microsoft.VisualStudio.Settings.ISettingsManager4 {
    [NullableAttribute("1")]
public ISettingsChangeSuppressor ChangeSuppressor { get; }
    [NullableContextAttribute("1")]
public abstract virtual ISettingsChangeSuppressor get_ChangeSuppressor();
}
public interface Microsoft.VisualStudio.Settings.ISettingsManagerHost {
    public Task AppInitCompletionTask { get; }
    public ISettingNameTranslator NameTranslator { get; }
    public IStringStorage PrivateStorage { get; }
    public ISettingsLogger Logger { get; }
    public string CollectionName { get; }
    [ObsoleteAttribute("Use ISettingsManagerHost2.GetTelemetrySettingsAsync instead.")]
public string TelemetrySettings { get; }
    public string AppDir { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_IdleStateChanged(EventHandler`1<IdleStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_IdleStateChanged(EventHandler`1<IdleStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_HostShuttingDown(AsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_HostShuttingDown(AsyncEventHandler value);
    public abstract virtual Task get_AppInitCompletionTask();
    public abstract virtual ISettingNameTranslator get_NameTranslator();
    public abstract virtual IStringStorage get_PrivateStorage();
    public abstract virtual ISettingsLogger get_Logger();
    public abstract virtual bool IsSharedOrRoamedSetting(string settingName);
    public abstract virtual string get_CollectionName();
    public abstract virtual string get_TelemetrySettings();
    public abstract virtual string get_AppDir();
}
public interface Microsoft.VisualStudio.Settings.ISettingsManagerHost2 {
    public abstract virtual Task`1<string> GetTelemetrySettingsAsync();
}
public interface Microsoft.VisualStudio.Settings.ISettingsManagerHost3 {
    public IRemoteDefaultsStore RemoteDefaultsStore { get; }
    public abstract virtual IRemoteDefaultsStore get_RemoteDefaultsStore();
}
public interface Microsoft.VisualStudio.Settings.ISettingsManagerHost4 {
    public string DurableHostIdentity { get; }
    public IStoreUpdateLogger StoreUpdateLogger { get; }
    public bool IsRoamingEnabledByDefault { get; }
    public abstract virtual string get_DurableHostIdentity();
    public abstract virtual IStoreUpdateLogger get_StoreUpdateLogger();
    public abstract virtual bool get_IsRoamingEnabledByDefault();
}
public interface Microsoft.VisualStudio.Settings.ISettingsManagerHost5 {
    public bool IsRoamingAndSharingAllowed { get; }
    public abstract virtual Task`1<Stream> GetServiceStreamAsync(CancellationToken cancellationToken);
    public abstract virtual bool get_IsRoamingAndSharingAllowed();
}
internal interface Microsoft.VisualStudio.Settings.ISettingsManagerInternal {
    public IStringStorage PrivateStore { get; }
    public IAsyncStringStorage SharedStore { get; public set; }
    public IAsyncStringStorage OnlineStore { get; }
    public ICrossProcessLockFactory CrossProcessLockFactory { get; }
    public abstract virtual IStringStorage get_PrivateStore();
    public abstract virtual IAsyncStringStorage get_SharedStore();
    public abstract virtual void set_SharedStore(IAsyncStringStorage value);
    public abstract virtual IAsyncStringStorage get_OnlineStore();
    public abstract virtual string Serialize(object value, bool makeConsistentWithJsonRoundTripping);
    public abstract virtual T Deserialize(string value);
    public abstract virtual void AddSettingsChangedHandler(PropertyChangedAsyncEventHandler handler, string namePattern, bool useWeakReference, bool callHandlerBeforeCallingExternalHandlers);
    public abstract virtual void RemoveSettingsChangedHandler(PropertyChangedAsyncEventHandler handler, string namePattern);
    public abstract virtual TracedEvent GetEvent(SettingsEvent settingsEvent);
    public abstract virtual Task SetValueAsync(string name, object value, bool isMachineLocal, bool throwIfSettingTooLarge, Action onBeforePropertyChanged);
    public abstract virtual ICrossProcessLockFactory get_CrossProcessLockFactory();
}
public interface Microsoft.VisualStudio.Settings.ISettingsService {
    public abstract virtual Task InitAsync(string collectionName, bool isRoamingEnabled, int roamingEnabledRevision, Guid clientId, string durableClientIdentity);
    public abstract virtual Task`1<SerializedSetting> GetSettingAsync(string settingName);
    public abstract virtual Task`1<ServiceUploadResult> PutSettingAsync(string settingName, ServiceUploadParameters settingInfo);
    public abstract virtual Task`1<bool> DeleteSettingAsync(string settingName, Guid clientId);
    public abstract virtual Task`1<SerializedSetting[]> GetMultipleSettingsAsync(int modifiedAfter);
    public abstract virtual Task DeleteAllSettingsAsync(Guid clientId);
    public abstract virtual Task`1<string> GetStoreIdentityAsync();
}
public interface Microsoft.VisualStudio.Settings.ISettingsSubset {
    [CompilerGeneratedAttribute]
public abstract virtual void add_SettingChangedAsync(PropertyChangedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SettingChangedAsync(PropertyChangedAsyncEventHandler value);
}
public interface Microsoft.VisualStudio.Settings.IStoreUpdateLogger {
    public abstract virtual Task LogSettingUpdateAsync(string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public abstract virtual Task LogSettingUpdateFailureAsync(Exception exception, string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public abstract virtual Task LogSettingUpdateFailureAsync(string failureDescription, string storeName, string settingName, string settingValue, bool isMachineLocal, bool shouldLogTelemetry, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public abstract virtual Task LogSettingDeletionAsync(string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public abstract virtual Task LogSettingDeletionFailureAsync(Exception exception, string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public abstract virtual Task LogClearSettingsAsync(string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public abstract virtual Task LogClearSettingsFailureAsync(Exception ex, string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public abstract virtual IDisposable BeginNoisyOperation();
}
public interface Microsoft.VisualStudio.Settings.IStoreUpdateLoggerWithAmbientContext {
    public abstract virtual IDisposable SetContext(StoreLogPropertyInstance[] properties);
}
public interface Microsoft.VisualStudio.Settings.IStringStorage {
    public abstract virtual StringWithMachineLocalFlag Get(string name);
    public abstract virtual String[] NamesStartingWith(string prefix);
    public abstract virtual Task SetAsync(string name, StringWithMachineLocalFlag value, Action onBeforePropertyChanged, CancellationToken cancellationToken);
    public abstract virtual Task DeleteIfExistsAsync(string name, CancellationToken cancellationToken);
    public abstract virtual Task ClearAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyChangedAsync(PropertyChangedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyChangedAsync(PropertyChangedAsyncEventHandler value);
}
public interface Microsoft.VisualStudio.Settings.IStringStorage2 {
    [NullableContextAttribute("1")]
public abstract virtual void ForEachSettingNameStartingWith(string prefix, CharSpanProcessorDelegate processFunc);
}
internal interface Microsoft.VisualStudio.Settings.ITelemetryAndTraceLogger {
}
internal interface Microsoft.VisualStudio.Settings.IUploaderDownloader {
    public abstract virtual Task UpdateSharedStoreFromPrivateStoreAsync(string name, IAsyncStringStorage sharedStore);
    public abstract virtual Task UploadNotYetUploadedSettingsAsync(Predicate`1<string> isUploadable, IAsyncStringStorage sharedStore);
    public abstract virtual int GetHighestSyncedRevision();
    public abstract virtual Task UpdatePrivateStoreWithDownloadedValueAsync(string name, VersionedString value, bool isFromNotification);
    public abstract virtual Task`1<string> PrepareForInitialSyncWithSharedStoreAsync(IAsyncStringStorage sharedStore);
    public abstract virtual Task ForgetRevisionNumbersAsync();
}
internal class Microsoft.VisualStudio.Settings.JsonStringDeserializationResult : ValueType {
    public string Deserialized;
    public int NextIndex;
    public JsonStringDeserializationResult(string deserialized, int nextIndex);
}
internal class Microsoft.VisualStudio.Settings.JsonStrings : object {
    public static string Revision;
    public static string MachineLocal;
    public static string Value;
    public static string Name;
}
internal class Microsoft.VisualStudio.Settings.JsonStringSerializer : object {
    private static string NullToken;
    public sealed virtual void Serialize(string s, StringBuilder buffer);
    public sealed virtual JsonStringDeserializationResult Deserialize(string json, int startIndex);
    private static int ComputeParsedLength(string json, int i);
    private static int Parse(string json, int i, StringBuilder builder);
    private static bool NullTokenIsAt(string json, int i);
    private static int SkipWhitespace(string s, int startIndex);
    private static Exception CreateExceptionForParseError(string message, string input, int index);
}
internal class Microsoft.VisualStudio.Settings.LazyDictionary`2 : Dictionary`2<TKey, Lazy`1<TValue>> {
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public LazyDictionary`2(IEqualityComparer`1<TKey> keyComparer);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.TryGetValue(TKey key, TValue& value);
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.VisualStudio.Settings.LimitedJsonSerializer : object {
    private static string NullToken;
    private IJsonStringSerializer stringSerializer;
    public LimitedJsonSerializer(IJsonStringSerializer stringSerializer);
    private static int NullOrQuotedStringLength(string s);
    private static int CombinedQuotedStringLengths(IEnumerable`1<string> strings);
    private static string BuildStringFromCollection(char begin, char end, int capacity, IEnumerable`1<T> items, Action`3<StringBuilder, T, IJsonStringSerializer> addItemAction, IJsonStringSerializer stringSerializer);
    public string Serialize(String[] stringArray);
    public string Serialize(IDictionary`2<string, string> stringDictionary);
    public String[] DeserializeStringArray(string json);
    public Dictionary`2<string, string> DeserializeStringDictionary(string json);
    public Dictionary`2<string, string> DeserializeStringDictionary(string json, IEqualityComparer`1<string> keyComparer);
    private static void EnsureCharEquals(string source, int i, char expected);
    private static void FindDelimitedSpan(string json, char openingDelimiter, char closingDelimiter, Int32& firstDelimiter, Int32& secondDelimiter);
}
public class Microsoft.VisualStudio.Settings.ListMerger : object {
    public static IEnumerable`1<KeyValuePair`2<T, U>> ThreeWayMerge(IReadOnlyList`1<KeyValuePair`2<T, U>> first, IReadOnlyList`1<KeyValuePair`2<T, U>> second, IReadOnlyList`1<KeyValuePair`2<T, U>> baseline, IEqualityComparer`1<T> keyComparer, IEqualityComparer`1<U> valueComparer, ISettingsLogger logger);
    private static ListChanges`2<T, U> MergeChanges(ListChanges`2<T, U> first, ListChanges`2<T, U> second, IEqualityComparer`1<T> keyComparer);
    internal static IListChanges`2<T, U> GenerateTransformation(IReadOnlyList`1<KeyValuePair`2<T, U>> original, IReadOnlyList`1<KeyValuePair`2<T, U>> target, IEqualityComparer`1<T> keyComparer, IEqualityComparer`1<U> valueComparer);
    private static ListChanges`2<T, U> GenerateTransformationInternal(IReadOnlyList`1<KeyValuePair`2<T, U>> original, IReadOnlyList`1<KeyValuePair`2<T, U>> target, IEqualityComparer`1<T> keyComparer, IEqualityComparer`1<U> valueComparer);
    private static IEnumerable`1<KeyValuePair`2<T, U>> ApplyChanges(IEnumerable`1<KeyValuePair`2<T, U>> baseline, ListChanges`2<T, U> changes, IEqualityComparer`1<T> keyComparer);
    private sealed virtual override IEnumerable`1<KeyValuePair`2<T, U>> Microsoft.VisualStudio.Settings.IListMerger.ThreeWayMerge(IReadOnlyList`1<KeyValuePair`2<T, U>> first, IReadOnlyList`1<KeyValuePair`2<T, U>> second, IReadOnlyList`1<KeyValuePair`2<T, U>> baseline, IEqualityComparer`1<T> keyComparer, IEqualityComparer`1<U> valueComparer, ISettingsLogger logger);
}
public class Microsoft.VisualStudio.Settings.LockedStorageCreatorDelegate`1 : MulticastDelegate {
    public LockedStorageCreatorDelegate`1(object object, IntPtr method);
    public virtual T Invoke(string path, bool writable, ITraceLogger logger, IDisposable storageLock);
    public virtual IAsyncResult BeginInvoke(string path, bool writable, ITraceLogger logger, IDisposable storageLock, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.Settings.MessageReceivedEventHandler`1 : MulticastDelegate {
    public MessageReceivedEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, PubSubMessageEventArgs`1<T> e);
    public virtual IAsyncResult BeginInvoke(object sender, PubSubMessageEventArgs`1<T> e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.Settings.NamedVersionedString : VersionedString {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public NamedVersionedString(string name, string value, bool machineLocal, int revision);
    [CompilerGeneratedAttribute]
public string get_Name();
}
internal class Microsoft.VisualStudio.Settings.NameTranslatingStoreUpdateLogger : object {
    private IStoreUpdateLogger inner;
    private ISettingNameTranslator nameTranslator;
    public NameTranslatingStoreUpdateLogger(IStoreUpdateLogger inner, ISettingNameTranslator nameTranslator);
    public sealed virtual Task LogSettingDeletionAsync(string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingDeletionFailureAsync(Exception exception, string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateAsync(string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateFailureAsync(Exception exception, string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateFailureAsync(string failureDescription, string storeName, string settingName, string settingValue, bool isMachineLocal, bool shouldLogTelemetry, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogClearSettingsAsync(string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual Task LogClearSettingsFailureAsync(Exception exception, string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual IDisposable BeginNoisyOperation();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.VisualStudio.Settings.NestingStringStoreLogPropertyDefinition : StoreLogPropertyDefinition`1<string> {
    public bool IsNesting { get; }
    public virtual bool get_IsNesting();
}
public class Microsoft.VisualStudio.Settings.NonLockedStorageCreatorDelegate`1 : MulticastDelegate {
    public NonLockedStorageCreatorDelegate`1(object object, IntPtr method);
    public virtual T Invoke(string path, bool writable, ITraceLogger logger);
    public virtual IAsyncResult BeginInvoke(string path, bool writable, ITraceLogger logger, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal static class Microsoft.VisualStudio.Settings.Parameters : object {
    private static Lazy`1<bool> debugOutputLazy;
    public static bool DebugOutput { get; }
    private static Parameters();
    public static bool get_DebugOutput();
    private static T ReadValue(string name, T defaultValue);
}
public class Microsoft.VisualStudio.Settings.PropertyChangedAsyncEventHandler : MulticastDelegate {
    public PropertyChangedAsyncEventHandler(object object, IntPtr method);
    public virtual Task Invoke(object sender, PropertyChangedEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangedEventArgs args, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.Settings.PubSubMessageEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private Guid <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <TopicName>k__BackingField;
    public Guid ActivityId { get; private set; }
    public T Message { get; private set; }
    public Uri TopicName { get; private set; }
    public PubSubMessageEventArgs`1(Uri topicName, T message, Guid activityId);
    [CompilerGeneratedAttribute]
public Guid get_ActivityId();
    [CompilerGeneratedAttribute]
private void set_ActivityId(Guid value);
    [CompilerGeneratedAttribute]
public T get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(T value);
    [CompilerGeneratedAttribute]
public Uri get_TopicName();
    [CompilerGeneratedAttribute]
private void set_TopicName(Uri value);
}
internal class Microsoft.VisualStudio.Settings.RuntimeInvocationException : Exception {
    public RuntimeInvocationException(string message);
    public RuntimeInvocationException(string message, Exception inner);
}
internal class Microsoft.VisualStudio.Settings.SerializeAndStoreValueAsyncDelegate : MulticastDelegate {
    public SerializeAndStoreValueAsyncDelegate(object object, IntPtr method);
    public virtual Task Invoke(string name, object value, bool isMachineLocal, Action onBeforePropertyChanged);
    public virtual IAsyncResult BeginInvoke(string name, object value, bool isMachineLocal, Action onBeforePropertyChanged, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.Settings.SerializedSetting : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineLocal>k__BackingField;
    public string Name { get; }
    public string Value { get; }
    public int Revision { get; }
    public bool IsMachineLocal { get; }
    public SerializedSetting(string name, string value, int revision, bool isMachineLocal);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public int get_Revision();
    [CompilerGeneratedAttribute]
public bool get_IsMachineLocal();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SerializedSetting first, SerializedSetting second);
    public static bool op_Inequality(SerializedSetting first, SerializedSetting second);
}
internal class Microsoft.VisualStudio.Settings.ServiceHubConnector : object {
    private TaskCompletionSource`1<JsonRpc> rpcChannelSource;
    private Func`2<CancellationToken, Task`1<Stream>> getServiceStreamFunc;
    private object callbackReceiver;
    private string collectionName;
    private ITelemetryAndTraceLogger logger;
    private Guid clientId;
    private string durableHostIdentity;
    private bool isRoamingEnabled;
    private int roamingEnabledRevision;
    public ServiceHubConnector(Func`2<CancellationToken, Task`1<Stream>> getServiceStreamFunc, object callbackReceiver, string collectionName, ITelemetryAndTraceLogger logger, Guid clientId, string durableHostIdentity, bool isRoamingEnabled, int roamingEnabledRevision);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.ServiceHubConnector/<GetOrInitiateConnectionAsync>d__10")]
public Task`1<JsonRpc> GetOrInitiateConnectionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.ServiceHubConnector/<OnHostShutdownAsync>d__11")]
public Task OnHostShutdownAsync();
}
internal class Microsoft.VisualStudio.Settings.ServiceHubPubSubReceiver : DisposableObject {
    private static JsonSerializer Serializer;
    private Guid clientId;
    private ITraceLogger logger;
    private string collectionName;
    [CompilerGeneratedAttribute]
private MessageReceivedEventHandler`1<string> OnMessageReceived;
    [CompilerGeneratedAttribute]
private EventHandler Connected;
    [CompilerGeneratedAttribute]
private EventHandler`1<SettingsEventArgs> EventReceived;
    public ServiceHubPubSubReceiver(Guid clientId, ITraceLogger logger, string collectionName);
    private static ServiceHubPubSubReceiver();
    public void OnMessagePublished(string topicName, JToken message, Guid activityId);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnMessageReceived(MessageReceivedEventHandler`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnMessageReceived(MessageReceivedEventHandler`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Connected(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Connected(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_EventReceived(EventHandler`1<SettingsEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_EventReceived(EventHandler`1<SettingsEventArgs> value);
    private void OnSettingsEventPublished(JToken message, Guid activityId);
    private void OnSettingChanged(string topicName, JToken message, Guid activityId);
}
public static class Microsoft.VisualStudio.Settings.ServiceHubPubSubTopic : object {
    public static string SettingsEvent;
    public static string SettingChanged;
}
internal class Microsoft.VisualStudio.Settings.ServiceHubStringStorage : AsyncStringStorageBase {
    private Guid clientId;
    private Func`2<CancellationToken, Task`1<JsonRpc>> getRpcChannelAsync;
    public ServiceHubStringStorage(Func`2<CancellationToken, Task`1<JsonRpc>> getRpcChannelAsync, IPubSubReceiver pubSubReceiver, Guid clientId, ISettingNameTranslator nameTranslator, ITraceLogger traceLogger);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.ServiceHubStringStorage/<GetAsync>d__3")]
public sealed virtual Task`1<VersionedString> GetAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.ServiceHubStringStorage/<GetAllSinceVersionAsync>d__4")]
public sealed virtual Task`1<IEnumerable`1<NamedVersionedString>> GetAllSinceVersionAsync(int modifiedAfterRevision, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.ServiceHubStringStorage/<SetAsync>d__5")]
public sealed virtual Task`1<ServiceUploadResult> SetAsync(NamedVersionedString value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.ServiceHubStringStorage/<DeleteIfExistsAsync>d__6")]
public sealed virtual Task DeleteIfExistsAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.ServiceHubStringStorage/<ClearAsync>d__7")]
public sealed virtual Task ClearAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.ServiceHubStringStorage/<GetStoreIdentityAsync>d__8")]
public sealed virtual Task`1<string> GetStoreIdentityAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <GetAllSinceVersionAsync>b__4_0(SerializedSetting ss);
    [CompilerGeneratedAttribute]
private NamedVersionedString <GetAllSinceVersionAsync>b__4_1(SerializedSetting ss);
}
public class Microsoft.VisualStudio.Settings.ServiceUploadParameters : object {
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MachineLocal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ClientId>k__BackingField;
    public int Revision { get; private set; }
    public bool MachineLocal { get; private set; }
    public string Value { get; private set; }
    public Guid ClientId { get; private set; }
    public ServiceUploadParameters(int revision, bool machineLocal, string value, Guid clientId);
    [CompilerGeneratedAttribute]
public int get_Revision();
    [CompilerGeneratedAttribute]
private void set_Revision(int value);
    [CompilerGeneratedAttribute]
public bool get_MachineLocal();
    [CompilerGeneratedAttribute]
private void set_MachineLocal(bool value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public Guid get_ClientId();
    [CompilerGeneratedAttribute]
private void set_ClientId(Guid value);
}
public class Microsoft.VisualStudio.Settings.ServiceUploadResult : object {
    [CompilerGeneratedAttribute]
private ServiceUploadResultKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewRevision>k__BackingField;
    [CompilerGeneratedAttribute]
private static ServiceUploadResult <Conflict>k__BackingField;
    [CompilerGeneratedAttribute]
private static ServiceUploadResult <ParseError>k__BackingField;
    [CompilerGeneratedAttribute]
private static ServiceUploadResult <UnknownError>k__BackingField;
    public ServiceUploadResultKind Kind { get; }
    public int NewRevision { get; }
    public static ServiceUploadResult Conflict { get; }
    public static ServiceUploadResult ParseError { get; }
    public static ServiceUploadResult UnknownError { get; }
    [JsonConstructorAttribute]
private ServiceUploadResult(ServiceUploadResultKind kind, int newRevision);
    public ServiceUploadResult(int newRevision);
    private static ServiceUploadResult();
    [CompilerGeneratedAttribute]
public ServiceUploadResultKind get_Kind();
    [CompilerGeneratedAttribute]
public int get_NewRevision();
    [CompilerGeneratedAttribute]
public static ServiceUploadResult get_Conflict();
    [CompilerGeneratedAttribute]
public static ServiceUploadResult get_ParseError();
    [CompilerGeneratedAttribute]
public static ServiceUploadResult get_UnknownError();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ServiceUploadResult first, ServiceUploadResult second);
    public static bool op_Inequality(ServiceUploadResult first, ServiceUploadResult second);
}
public enum Microsoft.VisualStudio.Settings.ServiceUploadResultKind : Enum {
    public int value__;
    public static ServiceUploadResultKind Success;
    public static ServiceUploadResultKind Conflict;
    public static ServiceUploadResultKind ParseError;
    public static ServiceUploadResultKind Unknown;
}
public class Microsoft.VisualStudio.Settings.SettingNameTooLongException : Exception {
    [CompilerGeneratedAttribute]
private int <ActualSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumSize>k__BackingField;
    public int ActualSize { get; private set; }
    public int MaximumSize { get; private set; }
    public SettingNameTooLongException(int actualSize, int maxSize);
    [CompilerGeneratedAttribute]
public int get_ActualSize();
    [CompilerGeneratedAttribute]
private void set_ActualSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaximumSize();
    [CompilerGeneratedAttribute]
private void set_MaximumSize(int value);
}
internal class Microsoft.VisualStudio.Settings.SettingNameTranslatorWrapper : object {
    private ISettingNameTranslator translator;
    public SettingNameTranslatorWrapper(ISettingNameTranslator translator);
    public string GetSharedNameFromPrivateName(string privateName);
    public string GetPrivateNameFromSharedName(string sharedName);
    public bool ShouldApply(string sharedName);
}
public enum Microsoft.VisualStudio.Settings.SettingsEvent : Enum {
    public int value__;
    public static SettingsEvent None;
    public static SettingsEvent SyncWithServerAndClientsEnded;
    public static SettingsEvent ProcessSignInStateChangeEnded;
    public static SettingsEvent SyncWithSharedStoreEnded;
    public static SettingsEvent UploadsComplete;
    public static SettingsEvent AllPendingUploadsCompletedOrFailed;
}
public class Microsoft.VisualStudio.Settings.SettingsEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SettingsEvent <Event>k__BackingField;
    public SettingsEvent Event { get; }
    public SettingsEventArgs(SettingsEvent settingsEvent);
    [CompilerGeneratedAttribute]
public SettingsEvent get_Event();
}
internal class Microsoft.VisualStudio.Settings.SettingsList : object {
    private string _listName;
    private Lazy`1<List`1<KeyValuePair`2<string, object>>> _collectionLazy;
    private ISettingsLogger _logger;
    private object _collectionSyncObj;
    private Func`1<Task> _refreshAction;
    private SettingType _telemetrySettingType;
    private IRemoteDefaultsStore _remoteDefaultsStore;
    private Lazy`1<bool> _remoteDefaultsExist;
    [CompilerGeneratedAttribute]
private CollectionChangedAsyncEventHandler CollectionChangedAsync;
    private bool AnyEventHandlers { get; }
    private List`1<KeyValuePair`2<string, object>> Collection { get; }
    public String[] Keys { get; }
    public List`1<KeyValuePair`2<string, object>> Content { get; }
    public SettingsList(IEnumerable`1<KeyValuePair`2<string, object>> collection, string listName, ISettingsLogger logger, Func`1<Task> refreshAction, SettingType telemetrySettingType, IRemoteDefaultsStore remoteDefaultsStore);
    public SettingsList(Func`1<IEnumerable`1<KeyValuePair`2<string, object>>> collectionCreator, string listName, ISettingsLogger logger, Func`1<Task> refreshAction, SettingType telemetrySettingType, IRemoteDefaultsStore remoteDefaultsStore);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsList/<FireEventAsync>d__10")]
private Task FireEventAsync(SettingsListChangedEventArgs args);
    private bool get_AnyEventHandlers();
    private static bool TryUnwrapJToken(object value, T& result);
    private bool DoesRemoteDefaultCollectionExist();
    private T GetRemoteDefault(string key, T defaultValue);
    private List`1<KeyValuePair`2<string, object>> get_Collection();
    public sealed virtual Task AddToFrontAsync(string key, object value, object state);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsList/<InsertAtIndexAsync>d__19")]
public sealed virtual Task InsertAtIndexAsync(int index, string key, object value, object state);
    private static void GetInsertionLoggingParameters(int index, Int32& codeMarkerStart, Int32& codeMarkerEnd, SettingAction& insertionAction, SettingAction& moveAction);
    public sealed virtual T GetValueOrDefault(string key, T defaultValue);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsList/<ClearAsync>d__22")]
public sealed virtual Task ClearAsync(object state);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsList/<RemoveAsync>d__23")]
public sealed virtual Task RemoveAsync(string key, object state);
    public sealed virtual String[] get_Keys();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsList/<RefreshContentFromStoreAsync>d__26")]
public sealed virtual Task RefreshContentFromStoreAsync();
    public sealed virtual List`1<KeyValuePair`2<string, object>> get_Content();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsList/<RemoveAsync>d__29")]
public sealed virtual Task RemoveAsync(IEnumerable`1<string> keys, object state);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChangedAsync(CollectionChangedAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChangedAsync(CollectionChangedAsyncEventHandler value);
}
public class Microsoft.VisualStudio.Settings.SettingsListChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SettingsListOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValuePair`2<string, object> <ItemAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, object>> <ItemsRemoved>k__BackingField;
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    public SettingsListOperation Operation { get; private set; }
    public KeyValuePair`2<string, object> ItemAdded { get; private set; }
    public IEnumerable`1<KeyValuePair`2<string, object>> ItemsRemoved { get; private set; }
    public object State { get; private set; }
    public static SettingsListChangedEventArgs Adding(KeyValuePair`2<string, object> item, object state);
    public static SettingsListChangedEventArgs Removing(KeyValuePair`2<string, object> item, object state);
    public static SettingsListChangedEventArgs Removing(IEnumerable`1<KeyValuePair`2<string, object>> items, object state);
    public static SettingsListChangedEventArgs Replacing(KeyValuePair`2<string, object> item, KeyValuePair`2<string, object> replacement, object state);
    public static SettingsListChangedEventArgs Clearing(IEnumerable`1<KeyValuePair`2<string, object>> itemsRemoved, object state);
    [CompilerGeneratedAttribute]
public SettingsListOperation get_Operation();
    [CompilerGeneratedAttribute]
private void set_Operation(SettingsListOperation value);
    [CompilerGeneratedAttribute]
public KeyValuePair`2<string, object> get_ItemAdded();
    [CompilerGeneratedAttribute]
private void set_ItemAdded(KeyValuePair`2<string, object> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<KeyValuePair`2<string, object>> get_ItemsRemoved();
    [CompilerGeneratedAttribute]
private void set_ItemsRemoved(IEnumerable`1<KeyValuePair`2<string, object>> value);
    [CompilerGeneratedAttribute]
public object get_State();
    [CompilerGeneratedAttribute]
private void set_State(object value);
}
internal class Microsoft.VisualStudio.Settings.SettingsListCreatorDelegate : MulticastDelegate {
    public SettingsListCreatorDelegate(object object, IntPtr method);
    public virtual ISettingsListInternal Invoke(Func`1<List`1<KeyValuePair`2<string, object>>> contentCreator, Func`1<Task> refreshAction);
    public virtual IAsyncResult BeginInvoke(Func`1<List`1<KeyValuePair`2<string, object>>> contentCreator, Func`1<Task> refreshAction, AsyncCallback callback, object object);
    public virtual ISettingsListInternal EndInvoke(IAsyncResult result);
}
public enum Microsoft.VisualStudio.Settings.SettingsListOperation : Enum {
    public int value__;
    public static SettingsListOperation AddItem;
    public static SettingsListOperation RemoveItem;
    public static SettingsListOperation RemoveMultipleItems;
    public static SettingsListOperation ReplaceItem;
    public static SettingsListOperation Clear;
}
internal class Microsoft.VisualStudio.Settings.SettingsListSynchronizer : object {
    private string _listName;
    private bool _isMachineLocal;
    private string _rawBaseline;
    private ISettingsManagerInternal _manager;
    private PropertyChangedAsyncEventHandler modreq(System.Runtime.CompilerServices.IsVolatile) _storeChangedHandler;
    private PropertyChangedAsyncEventHandler _blockingStoreChangedHandler;
    private PropertyChangedAsyncEventHandler _deferredStoreChangedHandler;
    private object eventState;
    private ISettingsLogger _operationLogger;
    private IStoreUpdateLoggerWithAmbientContext _storeLogger;
    private SemaphoreSlim _semaphore;
    private ExclusiveScheduler`1<SettingsListChangedEventArgs> _listChangedWorkScheduler;
    [CompilerGeneratedAttribute]
private ISettingsListInternal <List>k__BackingField;
    private List`1<KeyValuePair`2<string, object>> _baseline;
    public ISettingsListInternal List { get; private set; }
    private List`1<KeyValuePair`2<string, object>> Baseline { get; private set; }
    public SettingsListSynchronizer(string listName, bool isMachineLocal, ISettingsManagerInternal manager, SettingsListCreatorDelegate listCreator, ISettingsLogger operationLogger, IStoreUpdateLoggerWithAmbientContext storeLogger);
    private bool ShouldProcessListChange(SettingsListChangedEventArgs args);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsListSynchronizer/<OnListChangedAsync>d__14")]
private Task OnListChangedAsync(IReadOnlyList`1<SettingsListChangedEventArgs> args);
    private static bool IsRemovalOperation(SettingsListChangedEventArgs args);
    private Task OnStoreChangedDeferredAsync(object sender, PropertyChangedEventArgs args);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsListSynchronizer/<OnStoreChangedAsync>d__17")]
private Task OnStoreChangedAsync(object sender, PropertyChangedEventArgs args);
    [CompilerGeneratedAttribute]
public ISettingsListInternal get_List();
    [CompilerGeneratedAttribute]
private void set_List(ISettingsListInternal value);
    private List`1<KeyValuePair`2<string, object>> get_Baseline();
    private void set_Baseline(List`1<KeyValuePair`2<string, object>> value);
    [CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<string, object>> <.ctor>b__12_0();
    [CompilerGeneratedAttribute]
private Task <.ctor>b__12_1();
    [CompilerGeneratedAttribute]
private Task <.ctor>b__12_2(object sender, SettingsListChangedEventArgs args);
    [CompilerGeneratedAttribute]
private Task <.ctor>b__12_3(object sender, PropertyChangedEventArgs args);
}
internal class Microsoft.VisualStudio.Settings.SettingsManager : object {
    internal static int SettingSizeLimit;
    internal static int SettingNameLengthLimit;
    private IStringStorage2 _privateStore;
    private Guid _clientId;
    private ISettingsManagerHost5 _host5;
    private StorageWithPubSub storeWithPubSub;
    private IAsyncStringStorage _sharedStore;
    private IAsyncStringStorage _onlineStore;
    private Func`6<ISettingsManagerHost5, ITelemetryAndTraceLogger, Guid, bool, int, StorageWithPubSub> _sharedStoreFactory;
    private List`1<ScopedEventHandler> _eventHandlers;
    private List`1<ScopedEventHandler> _priorityEventHandlers;
    private Dictionary`2<string, WeakReference`1<SettingsListSynchronizer>> _listSynchronizers;
    private Serializer _serializer;
    private TaskCompletionSource`1<bool> _initialSharedStoreSyncTcs;
    private FireAndForgetTaskTracker _fireAndForgetTaskTracker;
    private ActionBlock`1<TaskCompletionSource`1<bool>> _storeUpdatedActionBlock;
    private AsyncLocalBool uploadsShouldAwaitInitialSync;
    private int setValueCallsInProgress;
    private AsyncLocalBool privateStoreChangesShouldTriggerUpload;
    private IUploaderDownloader uploaderDownloader;
    private IDictionary`2<SettingsEvent, TracedEvent> settingsEvents;
    private IRemoteDefaultsStore remoteDefaultsStore;
    private ISettingsLogger settingsLogger;
    private ITraceLogger traceLogger;
    private AsyncSemaphore downloadingSemaphore;
    private AsyncLocalBool shouldAwaitSharedStoreSyncAndChangeHandlersAfterPrivateStoreChange;
    [CompilerGeneratedAttribute]
private IStoreUpdateLoggerWithAmbientContext <StoreUpdateLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private ICrossProcessLockFactory <CrossProcessLockFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsChangeSuppressor <ChangeSuppressor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ClearSettingsOnStoreInitialization>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ClearSettings>k__BackingField;
    private bool IsRoamingAndSharingEnabled { get; }
    public Task AsyncInit { get; }
    public IStoreUpdateLoggerWithAmbientContext StoreUpdateLogger { get; }
    public IStringStorage PrivateStore { get; }
    public IAsyncStringStorage SharedStore { get; public set; }
    public IAsyncStringStorage OnlineStore { get; }
    public ICrossProcessLockFactory CrossProcessLockFactory { get; }
    public ISettingsChangeSuppressor ChangeSuppressor { get; }
    public bool ClearSettingsOnStoreInitialization { get; public set; }
    public IEnumerable`1<string> ClearSettings { get; public set; }
    public SettingsManager(ISettingsManagerHost5 host5, Guid clientId, Func`6<ISettingsManagerHost5, ITelemetryAndTraceLogger, Guid, bool, int, StorageWithPubSub> sharedStoreFactory, Func`2<UploaderDownloaderParameters, IUploaderDownloader> uploaderDownloaderFactory, ISettingsLogger settingsOperationLogger, IStoreUpdateLoggerWithAmbientContext storeUpdateLogger, ITraceLogger traceLogger);
    private bool get_IsRoamingAndSharingEnabled();
    private SettingsScope ChooseScope(string name);
    private void ConnectToSharedStore();
    private void DisconnectFromSharedStore();
    private Task OnStoreUpdatedAsync(object sender);
    public Task get_AsyncInit();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<SetSharedSettingsForPrivateStoreAsync>d__39")]
private Task SetSharedSettingsForPrivateStoreAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<DownloadNewSettingValuesFromSharedStoreAsync>d__40")]
private Task DownloadNewSettingValuesFromSharedStoreAsync(SettingLogContext context, string actionSourceDescriptionForLogging, bool isFromNotification);
    private static bool IsArgumentOutOfRangeException(RemoteInvocationException ex);
    private static bool IsDangerousStaleValue(string serialized);
    private GetValueResult TryDeserialize(string data, bool shouldLogTypeConversionErrors, T& result);
    private static bool IsInternalMetadata(string settingName);
    private SettingsScope GetScope(string settingName);
    private static void ValidateSettingNameLength(string name);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<FinishFireAndForgetOperationsAsync>d__47")]
internal Task FinishFireAndForgetOperationsAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<CallSetSharedSettingsFromActionBlockAsync>d__48")]
private Task CallSetSharedSettingsFromActionBlockAsync(TaskCompletionSource`1<bool> taskCompletionSource);
    private Task SynchronizeSettingsAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<SetSharedStoreAsync>d__50")]
private Task SetSharedStoreAsync(IAsyncStringStorage store);
    private SettingLogContext CreateGetValueTelemetryContext(string name, StringWithMachineLocalFlag result);
    private void LogGetValueFailure(string name, StringWithMachineLocalFlag result, Exception ex);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<SetValueInternalAsync>d__53")]
private Task SetValueInternalAsync(string name, object value, bool isMachineLocal, bool throwIfSettingTooLarge, bool shouldAwaitSharedStoreSyncAndChangeHandlers, Action onBeforePropertyChanged);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<OnPropertyChangedAsync>d__54")]
private Task OnPropertyChangedAsync(object sender, PropertyChangedEventArgs args);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<UploadToSharedStoreIfSharedAsync>d__55")]
private Task UploadToSharedStoreIfSharedAsync(string settingName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<FireLocalSettingChangeEventAsync>d__56")]
private Task FireLocalSettingChangeEventAsync(PropertyChangedEventArgs args);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<FireLocalSettingChangeEventAsync>d__57")]
private Task FireLocalSettingChangeEventAsync(PropertyChangedEventArgs args, List`1<ScopedEventHandler> handlers);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<UpdateSharedStoreFromPrivateStoreAsync>d__58")]
private Task UpdateSharedStoreFromPrivateStoreAsync(string name);
    private static bool WildcardMatch(string pattern, string candidate);
    private void AddSettingsChangedHandler(IEventHandler handler, string namePattern, bool callHandlerBeforeCallingExternalHandlers);
    private SettingType GetTelemetrySettingType(string name);
    private SettingType GetTelemetrySettingType(string name, bool isMachineLocal);
    private void OnSettingsEvent(object sender, SettingsEventArgs e);
    private void OnSettingsEvent(SettingsEvent settingsEvent);
    private void OnUploadsComplete();
    private void OnSyncWithSharedStoreEnded(object sender, EventArgs e);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<SetValueAsync>d__67")]
public sealed virtual Task SetValueAsync(string name, object value, bool isMachineLocal);
    public sealed virtual T GetValueOrDefault(string name, T defaultValue);
    public sealed virtual GetValueResult TryGetValue(string name, T& value);
    public sealed virtual ISettingsList GetOrCreateList(string name, bool isMachineLocal);
    public sealed virtual String[] NamesStartingWith(string prefix);
    public sealed virtual ISettingsSubset GetSubset(string namePattern);
    public sealed virtual void AddSettingsChangedHandler(PropertyChangedAsyncEventHandler handler, string namePattern, bool useWeakReference, bool callHandlerBeforeCallingExternalHandlers);
    public sealed virtual void RemoveSettingsChangedHandler(PropertyChangedAsyncEventHandler handler, string namePattern);
    private void RemoveHandlers(List`1<ScopedEventHandler> handlers, PropertyChangedAsyncEventHandler handler, string namePattern);
    public sealed virtual void SetSharedStore(IAsyncStringStorage store);
    public sealed virtual void SetOnlineStore(IAsyncStringStorage store);
    [CompilerGeneratedAttribute]
public sealed virtual IStoreUpdateLoggerWithAmbientContext get_StoreUpdateLogger();
    public sealed virtual Nullable`1<int> GetRevision(string settingName);
    public sealed virtual IStringStorage get_PrivateStore();
    public sealed virtual IAsyncStringStorage get_SharedStore();
    public sealed virtual void set_SharedStore(IAsyncStringStorage value);
    public sealed virtual IAsyncStringStorage get_OnlineStore();
    public sealed virtual string Serialize(object value, bool makeConsistentWithJsonRoundTripping);
    public sealed virtual T Deserialize(string value);
    public sealed virtual TracedEvent GetEvent(SettingsEvent settingsEvent);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<SetValueAsync>d__92")]
public sealed virtual Task SetValueAsync(string name, object value, bool isMachineLocal, bool throwIfSettingTooLarge, Action onBeforePropertyChanged);
    [CompilerGeneratedAttribute]
public sealed virtual ICrossProcessLockFactory get_CrossProcessLockFactory();
    [CompilerGeneratedAttribute]
public sealed virtual ISettingsChangeSuppressor get_ChangeSuppressor();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ClearSettingsOnStoreInitialization();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClearSettingsOnStoreInitialization(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_ClearSettings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClearSettings(IEnumerable`1<string> value);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<string, object>> <.ctor>b__30_0(string data);
    [CompilerGeneratedAttribute]
private Task <.ctor>b__30_1(string name, object value, bool isMachineLocal, Action onBeforePropertyChanged);
    [CompilerGeneratedAttribute]
private void <.ctor>b__30_2(Task task);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.SettingsManager/<<ConnectToSharedStore>b__34_0>d")]
[CompilerGeneratedAttribute]
private Task <ConnectToSharedStore>b__34_0();
    [CompilerGeneratedAttribute]
private bool <SetSharedSettingsForPrivateStoreAsync>b__39_0(string name);
}
public static class Microsoft.VisualStudio.Settings.SettingsManagerFactory : object {
    public static ISettingsManager CreateInstance(ISettingsManagerHost host);
    private static StorageWithPubSub CreateServiceHubSharedStore(ISettingsManagerHost5 host, ITelemetryAndTraceLogger combinedLogger, Guid clientId, bool isRoamingEnabled, int roamingEnabledRevision);
}
internal enum Microsoft.VisualStudio.Settings.SettingsScope : Enum {
    public int value__;
    public static SettingsScope Private;
    public static SettingsScope Shared;
}
internal class Microsoft.VisualStudio.Settings.SettingsSubset : object {
    private ISettingsManagerInternal manager;
    private string namePattern;
    public SettingsSubset(ISettingsManagerInternal manager, string namePattern);
    public sealed virtual void add_SettingChangedAsync(PropertyChangedAsyncEventHandler value);
    public sealed virtual void remove_SettingChangedAsync(PropertyChangedAsyncEventHandler value);
}
public class Microsoft.VisualStudio.Settings.SettingTooLargeException : Exception {
    [CompilerGeneratedAttribute]
private int <ActualSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumSize>k__BackingField;
    public int ActualSize { get; private set; }
    public int MaximumSize { get; private set; }
    public SettingTooLargeException(int actualSize, int maxSize);
    [CompilerGeneratedAttribute]
public int get_ActualSize();
    [CompilerGeneratedAttribute]
private void set_ActualSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaximumSize();
    [CompilerGeneratedAttribute]
private void set_MaximumSize(int value);
}
internal class Microsoft.VisualStudio.Settings.StorageWithPubSub : object {
    [CompilerGeneratedAttribute]
private IAsyncStringStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private IPubSubReceiver <PubSub>k__BackingField;
    public IAsyncStringStorage Storage { get; }
    public IPubSubReceiver PubSub { get; }
    public StorageWithPubSub(IAsyncStringStorage storage, IPubSubReceiver pubSub);
    [CompilerGeneratedAttribute]
public IAsyncStringStorage get_Storage();
    [CompilerGeneratedAttribute]
public IPubSubReceiver get_PubSub();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Settings.StoreLogPropertyDefinition : object {
    [CompilerGeneratedAttribute]
private static StoreLogPropertyDefinition`1<string> <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private static StoreLogPropertyDefinition`1<Nullable`1<int>> <OnlineRevision>k__BackingField;
    [CompilerGeneratedAttribute]
private static StoreLogPropertyDefinition`1<Nullable`1<int>> <LocalRevision>k__BackingField;
    [CompilerGeneratedAttribute]
private static StoreLogPropertyDefinition`1<string> <ListMergeBaseline>k__BackingField;
    [CompilerGeneratedAttribute]
private static StoreLogPropertyDefinition`1<string> <CanonicalRepresentation>k__BackingField;
    [CompilerGeneratedAttribute]
private static StoreLogPropertyDefinition`1<Nullable`1<bool>> <IsRoamingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static StoreLogPropertyDefinition`1<Nullable`1<bool>> <IsRoamable>k__BackingField;
    public static StoreLogPropertyDefinition`1<string> Source { get; }
    public static StoreLogPropertyDefinition`1<Nullable`1<int>> OnlineRevision { get; }
    public static StoreLogPropertyDefinition`1<Nullable`1<int>> LocalRevision { get; }
    public static StoreLogPropertyDefinition`1<string> ListMergeBaseline { get; }
    public static StoreLogPropertyDefinition`1<string> CanonicalRepresentation { get; }
    public static StoreLogPropertyDefinition`1<Nullable`1<bool>> IsRoamingEnabled { get; }
    public static StoreLogPropertyDefinition`1<Nullable`1<bool>> IsRoamable { get; }
    public bool IsNesting { get; }
    private static StoreLogPropertyDefinition();
    [CompilerGeneratedAttribute]
public static StoreLogPropertyDefinition`1<string> get_Source();
    [CompilerGeneratedAttribute]
public static StoreLogPropertyDefinition`1<Nullable`1<int>> get_OnlineRevision();
    [CompilerGeneratedAttribute]
public static StoreLogPropertyDefinition`1<Nullable`1<int>> get_LocalRevision();
    [CompilerGeneratedAttribute]
public static StoreLogPropertyDefinition`1<string> get_ListMergeBaseline();
    [CompilerGeneratedAttribute]
public static StoreLogPropertyDefinition`1<string> get_CanonicalRepresentation();
    [CompilerGeneratedAttribute]
public static StoreLogPropertyDefinition`1<Nullable`1<bool>> get_IsRoamingEnabled();
    [CompilerGeneratedAttribute]
public static StoreLogPropertyDefinition`1<Nullable`1<bool>> get_IsRoamable();
    public abstract virtual bool get_IsNesting();
}
public class Microsoft.VisualStudio.Settings.StoreLogPropertyDefinition`1 : StoreLogPropertyDefinition {
    public bool IsNesting { get; }
    [NullableContextAttribute("1")]
public StoreLogPropertyInstance WithValue(T value);
    public StoreLogPropertyInstance WithoutValue();
    public virtual bool get_IsNesting();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Settings.StoreLogPropertyInstance : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreLogPropertyDefinition <Definition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldOverrideExistingProperty>k__BackingField;
    public bool IsInitialized { get; }
    public StoreLogPropertyDefinition Definition { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public bool ShouldOverrideExistingProperty { get; }
    public bool HasValue { get; }
    public StoreLogPropertyInstance(StoreLogPropertyDefinition definition, object value);
    private StoreLogPropertyInstance(StoreLogPropertyDefinition definition, object value, bool shouldOverrideExistingProperty);
    public static StoreLogPropertyInstance WithoutValue(StoreLogPropertyDefinition definition);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public StoreLogPropertyDefinition get_Definition();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ShouldOverrideExistingProperty();
    public bool get_HasValue();
    public StoreLogPropertyInstance ReplaceOrCombine(StoreLogPropertyInstance other);
}
public class Microsoft.VisualStudio.Settings.StoreUpdatedEventHandler : MulticastDelegate {
    public StoreUpdatedEventHandler(object object, IntPtr method);
    public virtual Task Invoke(object sender);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.Settings.StringWithMachineLocalFlag : object {
    [CompilerGeneratedAttribute]
private bool <MachineLocal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public bool MachineLocal { get; private set; }
    public string Value { get; private set; }
    public StringWithMachineLocalFlag(string value, bool machineLocal);
    [CompilerGeneratedAttribute]
public bool get_MachineLocal();
    [CompilerGeneratedAttribute]
private void set_MachineLocal(bool value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
}
internal class Microsoft.VisualStudio.Settings.TabDelimitingLogMessageFormatter : object {
    public string Header { get; }
    public sealed virtual string get_Header();
    public sealed virtual string Format(DateTime timestamp, string processName, int processId, int threadId, TraceLogEntryType entryType, string messageOrFormat, Object[] args);
    private static string EnumValueName(TraceLogEntryType entryType);
}
internal class Microsoft.VisualStudio.Settings.Telemetry.DummyLogger : object {
    [CompilerGeneratedAttribute]
private static DummyLogger <Instance>k__BackingField;
    public static DummyLogger Instance { get; }
    private static DummyLogger();
    [CompilerGeneratedAttribute]
public static DummyLogger get_Instance();
    public sealed virtual void LogFailure(SettingLogContext result);
    public sealed virtual void LogFailure(SettingLogContext result, Exception ex);
    public sealed virtual void LogSuccess(SettingLogContext result);
    public sealed virtual Task LogAsync(TraceLogEntryType entryType, string messageOrFormat, Object[] args);
    public sealed virtual Task LogSettingUpdateAsync(string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateFailureAsync(Exception exception, string storeName, string settingName, string settingValue, bool isMachineLocal, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingUpdateFailureAsync(string failureDescription, string storeName, string settingName, string settingValue, bool isMachineLocal, bool shouldLogTelemetry, string source, Nullable`1<int> onlineRevision, Nullable`1<int> localRevision, string listMergeBaseline, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingDeletionAsync(string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogSettingDeletionFailureAsync(Exception exception, string storeName, string settingName, string source, Nullable`1<bool> isRoamingEnabled, Nullable`1<bool> isRoamable);
    public sealed virtual Task LogClearSettingsAsync(string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual Task LogClearSettingsFailureAsync(Exception exception, string storeName, string source, Nullable`1<bool> isRoamingEnabled);
    public sealed virtual IDisposable BeginNoisyOperation();
    public sealed virtual IDisposable SetContext(StoreLogPropertyInstance[] properties);
}
public interface Microsoft.VisualStudio.Settings.Telemetry.ISettingsLogger {
    public abstract virtual void LogFailure(SettingLogContext result);
    public abstract virtual void LogFailure(SettingLogContext result, Exception ex);
    public abstract virtual void LogSuccess(SettingLogContext result);
}
public static class Microsoft.VisualStudio.Settings.Telemetry.LogHelpers : object {
    public static string FormatSettingValue(string value);
}
public enum Microsoft.VisualStudio.Settings.Telemetry.SettingAction : Enum {
    public int value__;
    public static SettingAction GetValueFromPrivateStore;
    public static SettingAction GetValueFromLocalStore;
    public static SettingAction GetValueFromOnlineStore;
    public static SettingAction SetValueInPrivateStore;
    public static SettingAction SetValueInLocalStore;
    public static SettingAction SetValueInOnlineStore;
    public static SettingAction GetOrCreateList;
    public static SettingAction HandleSettingChangeEvent;
    public static SettingAction AddNewItemToFrontOfList;
    public static SettingAction GetItemFromList;
    public static SettingAction ClearList;
    public static SettingAction RemoveItemFromList;
    public static SettingAction TruncateList;
    public static SettingAction RemoveMultipleItemsFromList;
    public static SettingAction ThreeWayMergeList;
    public static SettingAction UpdatePrivateStoreFromSharedStore;
    public static SettingAction UpdateSharedStoreFromPrivateStore;
    public static SettingAction DeserializeValue;
    public static SettingAction RefreshListContentFromStore;
    public static SettingAction SerializeValue;
    public static SettingAction MoveItemToFrontOfList;
    public static SettingAction SetValueIfUnchangedInPrivateStore;
    public static SettingAction ReadSettingRegistration;
    public static SettingAction EnumeratePrivateStoreContents;
    public static SettingAction DeleteValueFromPrivateStore;
    public static SettingAction ClearPrivateStore;
    public static SettingAction DownloadSharedSettingsToPrivateStore;
    public static SettingAction GetAllSinceVersionAsync;
    public static SettingAction UpdatePrivateStoreFromSharedStoreAsync;
    public static SettingAction IdleStateChange;
    public static SettingAction AddNewItemToInteriorOfList;
    public static SettingAction MoveItemToInteriorListIndex;
}
public class Microsoft.VisualStudio.Settings.Telemetry.SettingLogContext : object {
    [CompilerGeneratedAttribute]
private SettingScenario <Scenario>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingType <SettingType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SettingName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SettingValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SettingValueSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Step>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResultDetail>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SettingValue>k__BackingField;
    public SettingScenario Scenario { get; }
    public SettingAction Action { get; public set; }
    public SettingType SettingType { get; public set; }
    public string SettingName { get; public set; }
    public string SettingValueType { get; }
    public int SettingValueSize { get; public set; }
    public string Step { get; }
    public string ResultDetail { get; public set; }
    public string SettingValue { get; public set; }
    public SettingLogContext(SettingScenario scenario, SettingAction action, SettingType settingType, string settingName, string settingValueType, int settingValueSize, string settingValue, string resultDetail, string step);
    [CompilerGeneratedAttribute]
public SettingScenario get_Scenario();
    [CompilerGeneratedAttribute]
public SettingAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(SettingAction value);
    [CompilerGeneratedAttribute]
public SettingType get_SettingType();
    [CompilerGeneratedAttribute]
public void set_SettingType(SettingType value);
    [CompilerGeneratedAttribute]
public string get_SettingName();
    [CompilerGeneratedAttribute]
public void set_SettingName(string value);
    [CompilerGeneratedAttribute]
public string get_SettingValueType();
    [CompilerGeneratedAttribute]
public int get_SettingValueSize();
    [CompilerGeneratedAttribute]
public void set_SettingValueSize(int value);
    [CompilerGeneratedAttribute]
public string get_Step();
    [CompilerGeneratedAttribute]
public string get_ResultDetail();
    [CompilerGeneratedAttribute]
public void set_ResultDetail(string value);
    [CompilerGeneratedAttribute]
public string get_SettingValue();
    [CompilerGeneratedAttribute]
public void set_SettingValue(string value);
}
public enum Microsoft.VisualStudio.Settings.Telemetry.SettingScenario : Enum {
    public int value__;
    public static SettingScenario Get;
    public static SettingScenario Set;
    public static SettingScenario List;
    public static SettingScenario HandleSettingChange;
    public static SettingScenario Serialization;
    public static SettingScenario Initialization;
}
public enum Microsoft.VisualStudio.Settings.Telemetry.SettingType : Enum {
    public int value__;
    public static SettingType PrivateSetting;
    public static SettingType LocalSetting;
    public static SettingType OnlineSetting;
    public static SettingType LocalOrOnlineSetting;
    public static SettingType Unknown;
}
internal class Microsoft.VisualStudio.Settings.TelemetryAndTraceLogger : object {
    private ISettingsLogger telemetryLogger;
    private ITraceLogger traceLogger;
    public TelemetryAndTraceLogger(ISettingsLogger telemetryLogger, ITraceLogger traceLogger);
    public sealed virtual void LogFailure(SettingLogContext result);
    public sealed virtual void LogFailure(SettingLogContext result, Exception ex);
    public sealed virtual void LogSuccess(SettingLogContext result);
    public sealed virtual Task LogAsync(TraceLogEntryType entryType, string messageOrFormat, Object[] args);
    private void LogTraceMessage(SettingLogContext context, TraceLogEntryType entryType);
}
internal static class Microsoft.VisualStudio.Settings.ThreadingUtilities : object {
    public static Task`1<T> RunAtLowIoPriority(Func`1<T> doWork);
}
internal class Microsoft.VisualStudio.Settings.UploaderDownloader : object {
    internal static string RevisionsPrefix;
    internal static string UploadFlagsPrefix;
    private UploaderDownloaderParameters parameters;
    private ConcurrentDictionary`2<string, SemaphoreSlim> settingUploadLocks;
    private HashSet`1<string> listUploadsInProgress;
    private Nullable`1<int> highestSyncedRevision;
    public UploaderDownloader(UploaderDownloaderParameters parameters);
    public static string RevisionName(string settingName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.UploaderDownloader/<UpdateSharedStoreFromPrivateStoreAsync>d__8")]
public sealed virtual Task UpdateSharedStoreFromPrivateStoreAsync(string name, IAsyncStringStorage sharedStore);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.UploaderDownloader/<UploadNotYetUploadedSettingsAsync>d__9")]
public sealed virtual Task UploadNotYetUploadedSettingsAsync(Predicate`1<string> isUploadable, IAsyncStringStorage sharedStore);
    public sealed virtual int GetHighestSyncedRevision();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.UploaderDownloader/<UpdatePrivateStoreWithDownloadedValueAsync>d__11")]
public sealed virtual Task UpdatePrivateStoreWithDownloadedValueAsync(string name, VersionedString value, bool isFromNotification);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.UploaderDownloader/<PrepareForInitialSyncWithSharedStoreAsync>d__12")]
public sealed virtual Task`1<string> PrepareForInitialSyncWithSharedStoreAsync(IAsyncStringStorage sharedStore);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.UploaderDownloader/<ForgetRevisionNumbersAsync>d__13")]
public sealed virtual Task ForgetRevisionNumbersAsync();
    private SemaphoreSlim GetUploadLockForCategory(string name);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.UploaderDownloader/<RegisterUploadAsync>d__15")]
private Task RegisterUploadAsync(string settingName);
    public static string UploadFlagName(string settingName);
    private bool LatestValueHasBeenUploaded(string settingName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.UploaderDownloader/<UploadAsync>d__18")]
private Task`1<ServiceUploadResult> UploadAsync(string name, string value, bool machineLocal, int revisionToReplace, IAsyncStringStorage sharedStore);
    private bool IsList(string serialized);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Settings.UploaderDownloader/<UpdateRevisionAsync>d__20")]
private Task UpdateRevisionAsync(string settingName, int revision);
    [CompilerGeneratedAttribute]
private bool <GetHighestSyncedRevision>g__UpdateHighestSyncedRevision|10_0(ReadOnlySpan`1<char> settingName);
}
internal class Microsoft.VisualStudio.Settings.UploaderDownloaderParameters : object {
    [CompilerGeneratedAttribute]
private ISettingsManager <SettingsManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IStringStorage2 <PrivateStore>k__BackingField;
    [CompilerGeneratedAttribute]
private Serializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, List`1<KeyValuePair`2<string, object>>> <TryDeserializeAsList>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializeAndStoreValueAsyncDelegate <SerializeAndStoreLocalValueAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncLocalBool <PrivateStoreChangesShouldTriggerUpload>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Task> <RegisterTaskWithoutAwaiting>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<PropertyChangedEventArgs, Task> <FireLocalSettingChangeEventAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private ICrossProcessLockFactory <CrossProcessLockFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private IStoreUpdateLoggerWithAmbientContext <StoreLogger>k__BackingField;
    public ISettingsManager SettingsManager { get; }
    public IStringStorage2 PrivateStore { get; }
    public Serializer Serializer { get; }
    public Func`2<string, List`1<KeyValuePair`2<string, object>>> TryDeserializeAsList { get; }
    public SerializeAndStoreValueAsyncDelegate SerializeAndStoreLocalValueAsync { get; }
    public AsyncLocalBool PrivateStoreChangesShouldTriggerUpload { get; }
    public Action`1<Task> RegisterTaskWithoutAwaiting { get; }
    public Func`2<PropertyChangedEventArgs, Task> FireLocalSettingChangeEventAsync { get; }
    public ICrossProcessLockFactory CrossProcessLockFactory { get; }
    public string CollectionName { get; }
    public IStoreUpdateLoggerWithAmbientContext StoreLogger { get; }
    public UploaderDownloaderParameters(ISettingsManager settingsManager, IStringStorage2 privateStore, Serializer serializer, Func`2<string, List`1<KeyValuePair`2<string, object>>> tryDeserializeAsList, SerializeAndStoreValueAsyncDelegate serializeAndStoreLocalValueAsync, AsyncLocalBool privateStoreChangesShouldTriggerUpload, Action`1<Task> registerTaskWithoutAwaiting, Func`2<PropertyChangedEventArgs, Task> fireLocalSettingChangeEventAsync, ICrossProcessLockFactory crossProcessLockFactory, IStoreUpdateLoggerWithAmbientContext storeLogger);
    [CompilerGeneratedAttribute]
public ISettingsManager get_SettingsManager();
    [CompilerGeneratedAttribute]
public IStringStorage2 get_PrivateStore();
    [CompilerGeneratedAttribute]
public Serializer get_Serializer();
    [CompilerGeneratedAttribute]
public Func`2<string, List`1<KeyValuePair`2<string, object>>> get_TryDeserializeAsList();
    [CompilerGeneratedAttribute]
public SerializeAndStoreValueAsyncDelegate get_SerializeAndStoreLocalValueAsync();
    [CompilerGeneratedAttribute]
public AsyncLocalBool get_PrivateStoreChangesShouldTriggerUpload();
    [CompilerGeneratedAttribute]
public Action`1<Task> get_RegisterTaskWithoutAwaiting();
    [CompilerGeneratedAttribute]
public Func`2<PropertyChangedEventArgs, Task> get_FireLocalSettingChangeEventAsync();
    [CompilerGeneratedAttribute]
public ICrossProcessLockFactory get_CrossProcessLockFactory();
    [CompilerGeneratedAttribute]
public string get_CollectionName();
    [CompilerGeneratedAttribute]
public IStoreUpdateLoggerWithAmbientContext get_StoreLogger();
}
public class Microsoft.VisualStudio.Settings.VersionedString : StringWithMachineLocalFlag {
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    public int Revision { get; }
    public VersionedString(string value, bool machineLocal, int revision);
    [CompilerGeneratedAttribute]
public int get_Revision();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.ServiceUnavailableException : Exception {
    public ServiceUnavailableException(Type serviceType);
    public ServiceUnavailableException(string serviceName);
    public ServiceUnavailableException(string serviceName, string additionalMessage);
    public ServiceUnavailableException(Type serviceType, Exception innerException);
    public ServiceUnavailableException(string serviceName, Exception innerException);
    private static string FormatErrorMessage(string serviceName, string additionalMessage);
}
public static class Microsoft.VisualStudio.Utilities.Accelerator : object {
    public static string StripAccelerators(string input);
    public static string StripAccelerators(string input, char accessSpecifier);
    public static string StripAccelerators(string input, object accessKeySpecifier);
    public static char AccessKeySpecifierFromObject(object accessKeySpecifier);
}
public static class Microsoft.VisualStudio.Utilities.BitRotator : object {
    public static sbyte RotateLeft(sbyte value, int count);
    public static byte RotateLeft(byte value, int count);
    public static sbyte RotateRight(sbyte value, int count);
    public static byte RotateRight(byte value, int count);
    public static short RotateLeft(short value, int count);
    public static ushort RotateLeft(ushort value, int count);
    public static short RotateRight(short value, int count);
    public static ushort RotateRight(ushort value, int count);
    public static int RotateLeft(int value, int count);
    public static UInt32 RotateLeft(UInt32 value, int count);
    public static int RotateRight(int value, int count);
    public static UInt32 RotateRight(UInt32 value, int count);
    public static long RotateLeft(long value, int count);
    public static ulong RotateLeft(ulong value, int count);
    public static long RotateRight(long value, int count);
    public static ulong RotateRight(ulong value, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Microsoft.VisualStudio.Utilities.CircularBuffer`1 : object {
    private T[] _buffer;
    private int _start;
    private int _end;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFixedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SyncRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSynchronized>k__BackingField;
    public int Capacity { get; }
    public bool IsFull { get; }
    public bool IsEmpty { get; }
    public int Count { get; private set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public T Item { get; public set; }
    public CircularBuffer`1(int capacity);
    public CircularBuffer`1(int capacity, T[] items);
    public int get_Capacity();
    public bool get_IsFull();
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public bool get_IsFixedSize();
    [CompilerGeneratedAttribute]
public object get_SyncRoot();
    [CompilerGeneratedAttribute]
public bool get_IsSynchronized();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public T[] ToArray();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Utilities.CircularBuffer`1/<GetEnumerator>d__39")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private int InternalIndex(int index);
    private void Increment(Int32& index);
    private void Decrement(Int32& index);
}
public class Microsoft.VisualStudio.Utilities.ColorEntry : ValueType {
    [CompilerGeneratedAttribute]
private ColorType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public ColorType Type { get; public set; }
    public UInt32 Value { get; public set; }
    public bool IsColorValid { get; }
    internal ColorEntry(BinaryReader reader);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ColorType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ColorType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(UInt32 value);
    public bool get_IsColorValid();
    internal void WriteToStream(BinaryWriter writer);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("452")]
public class Microsoft.VisualStudio.Utilities.CommandIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CommandSetGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CommandId>k__BackingField;
    public string CommandSetGuid { get; }
    public int CommandId { get; }
    public CommandIdAttribute(string commandSetGuid, int commandId);
    [CompilerGeneratedAttribute]
public string get_CommandSetGuid();
    [CompilerGeneratedAttribute]
public int get_CommandId();
}
public static class Microsoft.VisualStudio.Utilities.CustomStringComparers : object {
    [CompilerGeneratedAttribute]
private static StringComparer <Logical>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringComparer <LogicalIgnoreCase>k__BackingField;
    public static StringComparer Logical { get; }
    public static StringComparer LogicalIgnoreCase { get; }
    private static CustomStringComparers();
    [CompilerGeneratedAttribute]
public static StringComparer get_Logical();
    [CompilerGeneratedAttribute]
public static StringComparer get_LogicalIgnoreCase();
}
public static class Microsoft.VisualStudio.Utilities.DpiAwareness : object {
    private static Lazy`1<double> LazySystemDpiX;
    private static Lazy`1<double> LazySystemDpiY;
    private static Lazy`1<double> LazySystemDpiScaleX;
    private static Lazy`1<double> LazySystemDpiScaleY;
    private static Nullable`1<bool> _isPerMonitorAwarenessEnabled;
    private static Nullable`1<DpiAwarenessContext> _processDpiAwarenessContext;
    public static double DefaultLogicalDpi;
    private static int S_OK;
    private static int E_INVALIDARG;
    private static string Gdi32;
    private static string Shcore;
    private static string User32;
    public static bool IsPerMonitorAwarenessEnabled { get; }
    public static DpiAwarenessContext ProcessDpiAwarenessContext { get; }
    public static double SystemDpiX { get; }
    public static double SystemDpiY { get; }
    public static double SystemDpiXScale { get; }
    public static double SystemDpiYScale { get; }
    private static DpiAwareness();
    public static bool get_IsPerMonitorAwarenessEnabled();
    public static DpiAwarenessContext get_ProcessDpiAwarenessContext();
    public static double get_SystemDpiX();
    public static double get_SystemDpiY();
    public static double get_SystemDpiXScale();
    public static double get_SystemDpiYScale();
    private static bool IsValidDpi(double dpi);
    private static double GetSystemDpi(bool getDpiX);
    private static int GetDeviceCaps(IntPtr hdc, DeviceCaps index);
    private static int GetDpiForMonitor(IntPtr hmonitor, MONITOR_DPI_TYPE dpiType, UInt32& dpiX, UInt32& dpiY);
    private static UInt32 GetProcessDpiAwareness(IntPtr process, PROCESS_DPI_AWARENESS& awareness);
    private static bool AreDpiAwarenessContextsEqual(IntPtr dpiContextA, IntPtr dpiContextB);
    private static IntPtr GetDC(IntPtr hwnd);
    private static UInt32 GetDpiForWindow(IntPtr hwnd);
    private static IntPtr GetThreadDpiAwarenessContext();
    private static IntPtr GetWindowDpiAwarenessContext(IntPtr hwnd);
    private static bool GetWindowRect(IntPtr hwnd, RECT& rect);
    private static int ReleaseDC(IntPtr hwnd, IntPtr hdc);
    private static IntPtr SetThreadDpiAwarenessContext(IntPtr awareness);
    public static IDisposable EnterDpiScope(DpiAwarenessContext awareness);
    public static IDisposable EnterDpiScope(IntPtr hwnd);
}
public enum Microsoft.VisualStudio.Utilities.DpiAwarenessContext : Enum {
    public int value__;
    public static DpiAwarenessContext Unaware;
    public static DpiAwarenessContext SystemAware;
    public static DpiAwarenessContext PerMonitorAware;
    public static DpiAwarenessContext PerMonitorAwareV2;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.Utilities.DpiAwarenessResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Error_DpiAwarenessThreadChanged { get; }
    internal static string Error_DpiInvalid { get; }
    internal static string Error_DpiScaleInvalid { get; }
    internal static string Error_DpiScaleObjectNull { get; }
    internal static string Error_DpiWindowInvalid { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Error_DpiAwarenessThreadChanged();
    internal static string get_Error_DpiInvalid();
    internal static string get_Error_DpiScaleInvalid();
    internal static string get_Error_DpiScaleObjectNull();
    internal static string get_Error_DpiWindowInvalid();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Utilities.EnvironmentVariablesChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Variables>k__BackingField;
    public IReadOnlyDictionary`2<string, string> Variables { get; }
    public EnvironmentVariablesChangedEventArgs(IReadOnlyDictionary`2<string, string> variables);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Variables();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.EnvironmentVariableService : object {
    private EnvironmentVariableServiceState state;
    private CancellationTokenSource disposeToken;
    private ImmutableHashSet`1<IObserver`1<IReadOnlyDictionary`2<string, string>>> observers;
    public EnvironmentVariableService(EnvironmentVariableServiceState state);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Utilities.EnvironmentVariableService/<SubscribeAsync>d__4")]
public sealed virtual Task`1<IDisposable> SubscribeAsync(IObserver`1<IReadOnlyDictionary`2<string, string>> observer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Utilities.EnvironmentVariableService/<UpdateEnvironmentVariablesAsync>d__5")]
public sealed virtual Task UpdateEnvironmentVariablesAsync(IReadOnlyDictionary`2<string, string> updatedVariables, CancellationToken cancellationToken);
    public sealed virtual Task RefreshEnvironmentVariablesAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void AssertNotDisposed();
    private void NotifyObservers(object sender, EnvironmentVariablesChangedEventArgs args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.EnvironmentVariableServiceState : object {
    private static StringComparer EnvironmentVariableComparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<EnvironmentVariablesChangedEventArgs> EnvironmentVariablesChanged;
    private CancellationTokenSource disposeToken;
    private ActionBlock`1<ActionData> block;
    private ImmutableDictionary`2<string, string> lastKnownVariables;
    private static EnvironmentVariableServiceState();
    [CompilerGeneratedAttribute]
internal void add_EnvironmentVariablesChanged(EventHandler`1<EnvironmentVariablesChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_EnvironmentVariablesChanged(EventHandler`1<EnvironmentVariablesChangedEventArgs> value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Utilities.EnvironmentVariableServiceState/<UpdateAsync>d__8")]
internal Task UpdateAsync(IReadOnlyDictionary`2<string, string> updatedVariables, Action`1<IReadOnlyDictionary`2<string, string>> noChangesCallback, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void AssertNotDisposed();
    private void ApplyUpdate(ActionData data);
    [MemberNotNullAttribute("lastKnownVariables")]
private bool Refresh();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.VisualStudio.Utilities.FileStreamStorage`1 : DisposableObject {
    public static string AllExtensions;
    private string _storagePath;
    private string _storageFileExtension;
    private IStreamStorageKeyFactory`1<TKey> _keyFactory;
    private Nullable`1<UInt32> _clusterSize;
    private EventHandler`1<TKey> _streamCreated;
    private EventHandler`1<TKey> _streamDeleted;
    private EventHandler`1<TKey> _streamChanged;
    private int _eventSinkCount;
    private bool _enableRaisingEvents;
    private FileSystemWatcher _watcher;
    public string StoragePath { get; }
    public string StorageFileExtension { get; }
    public Stream Item { get; }
    public bool EnableRaisingEvents { get; public set; }
    internal FileSystemWatcher Watcher { get; }
    private int EventSinkCount { get; private set; }
    [SupportedOSPlatformAttribute("windows8.0")]
private UInt32 ClusterSize { get; }
    public FileStreamStorage`1(IStreamStorageKeyFactory`1<TKey> keyFactory, string storagePath, string fileExtension);
    protected virtual void DisposeManagedResources();
    public string get_StoragePath();
    public string get_StorageFileExtension();
    private string GetFullPath(TKey key);
    private bool IsStorageExtension(TKey key);
    public sealed virtual Stream Open(TKey key, StreamAccess streamAccess);
    public sealed virtual Stream Create(TKey key);
    public sealed virtual bool Delete(TKey key);
    public sealed virtual bool Contains(TKey key);
    public sealed virtual Stream get_Item(TKey key);
    public sealed virtual DateTime GetTimestamp(TKey key, TimestampKind kind);
    public sealed virtual void SetTimestamp(TKey key, TimestampKind kind, DateTime timestamp);
    public sealed virtual void GetStreamSize(TKey key, Int64& actualSize, Int64& reservedSize);
    public sealed virtual IEnumerator`1<TKey> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool get_EnableRaisingEvents();
    public sealed virtual void set_EnableRaisingEvents(bool value);
    public sealed virtual void add_StreamCreated(EventHandler`1<TKey> value);
    public sealed virtual void remove_StreamCreated(EventHandler`1<TKey> value);
    public sealed virtual void add_StreamDeleted(EventHandler`1<TKey> value);
    public sealed virtual void remove_StreamDeleted(EventHandler`1<TKey> value);
    public sealed virtual void add_StreamChanged(EventHandler`1<TKey> value);
    public sealed virtual void remove_StreamChanged(EventHandler`1<TKey> value);
    private static Exception WrapAccessException(TKey key, Exception ex);
    internal FileSystemWatcher get_Watcher();
    private int get_EventSinkCount();
    private void set_EventSinkCount(int value);
    private void CreateFileSystemWatcher();
    private void DeleteFileSystemWatcher();
    private void DeleteFileSystemWatcherCore();
    private void OnStreamCreated(object sender, FileSystemEventArgs e);
    private void OnStreamCreated(string streamName);
    private void OnStreamDeleted(object sender, FileSystemEventArgs e);
    private void OnStreamDeleted(string streamName);
    private void OnStreamChanged(object sender, FileSystemEventArgs e);
    private void OnStreamRenamed(object sender, RenamedEventArgs e);
    private void RaiseEvent(EventHandler`1<TKey> streamEvent, string streamName);
    private static void ValidateStoragePath(string path, string paramName);
    private static void ValidateExtension(string extension, string paramName);
    private void ValidateStreamAccess(StreamAccess access, string paramName);
    private static void ValidateTimestampKind(TimestampKind kind, string paramName);
    private UInt32 get_ClusterSize();
}
public class Microsoft.VisualStudio.Utilities.FontColorCategory : object {
    [CompilerGeneratedAttribute]
private Guid <CategoryGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private FontInformation <Font>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FontColorEntry> <Colors>k__BackingField;
    public Guid CategoryGuid { get; }
    public FontInformation Font { get; public set; }
    public List`1<FontColorEntry> Colors { get; }
    public FontColorCategory(Guid categoryGuid);
    internal FontColorCategory(BinaryReader reader, int version);
    [CompilerGeneratedAttribute]
public Guid get_CategoryGuid();
    [CompilerGeneratedAttribute]
public FontInformation get_Font();
    [CompilerGeneratedAttribute]
public void set_Font(FontInformation value);
    [CompilerGeneratedAttribute]
public List`1<FontColorEntry> get_Colors();
    internal void WriteToStream(BinaryWriter writer, int version);
}
public class Microsoft.VisualStudio.Utilities.FontColorEntry : object {
    public static int DefaultMergePriority;
    private AvailableFontStyles validOptions;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DescriptionResource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalizedNameResource>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorEntry <BackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorEntry <ForegroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <FontColorItemFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LineStyles> <LineStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MarkerStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorEntry <AutoBackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorEntry <AutoForegroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <FontFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MergePriority>k__BackingField;
    public string Name { get; }
    public string DescriptionResource { get; public set; }
    public string LocalizedNameResource { get; public set; }
    public ColorEntry BackgroundColor { get; public set; }
    public ColorEntry ForegroundColor { get; public set; }
    public Nullable`1<UInt32> FontColorItemFlags { get; public set; }
    public Nullable`1<LineStyles> LineStyle { get; public set; }
    public Nullable`1<int> MarkerStyle { get; public set; }
    public ColorEntry AutoBackgroundColor { get; public set; }
    public ColorEntry AutoForegroundColor { get; public set; }
    public Nullable`1<UInt32> FontFlags { get; public set; }
    public int MergePriority { get; public set; }
    public FontColorEntry(string name);
    internal FontColorEntry(BinaryReader reader, int version);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_DescriptionResource();
    [CompilerGeneratedAttribute]
public void set_DescriptionResource(string value);
    [CompilerGeneratedAttribute]
public string get_LocalizedNameResource();
    [CompilerGeneratedAttribute]
public void set_LocalizedNameResource(string value);
    [CompilerGeneratedAttribute]
public ColorEntry get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(ColorEntry value);
    [CompilerGeneratedAttribute]
public ColorEntry get_ForegroundColor();
    [CompilerGeneratedAttribute]
public void set_ForegroundColor(ColorEntry value);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_FontColorItemFlags();
    [CompilerGeneratedAttribute]
public void set_FontColorItemFlags(Nullable`1<UInt32> value);
    [CompilerGeneratedAttribute]
public Nullable`1<LineStyles> get_LineStyle();
    [CompilerGeneratedAttribute]
public void set_LineStyle(Nullable`1<LineStyles> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MarkerStyle();
    [CompilerGeneratedAttribute]
public void set_MarkerStyle(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public ColorEntry get_AutoBackgroundColor();
    [CompilerGeneratedAttribute]
public void set_AutoBackgroundColor(ColorEntry value);
    [CompilerGeneratedAttribute]
public ColorEntry get_AutoForegroundColor();
    [CompilerGeneratedAttribute]
public void set_AutoForegroundColor(ColorEntry value);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_FontFlags();
    [CompilerGeneratedAttribute]
public void set_FontFlags(Nullable`1<UInt32> value);
    [CompilerGeneratedAttribute]
public int get_MergePriority();
    [CompilerGeneratedAttribute]
public void set_MergePriority(int value);
    internal void WriteToStream(BinaryWriter writer, int version);
    private AvailableFontStyles CalculateAvailableStyles();
}
public class Microsoft.VisualStudio.Utilities.FontColorTheme : object {
    public static int VersionWithOnlyColor;
    public static int VersionWithFontColor;
    private Dictionary`2<Guid, FontColorCategory> categories;
    public IEnumerable`1<FontColorCategory> Categories { get; }
    public FontColorTheme(VersionedBinaryReader reader);
    public IEnumerable`1<FontColorCategory> get_Categories();
    public FontColorCategory GetCategory(Guid categoryGuid);
    public void AddCategory(FontColorCategory category);
    public void WriteToStream(VersionedBinaryWriter writer, bool includeFontInformation);
    internal static void ThrowIfInvalidVersion(int version);
}
public class Microsoft.VisualStudio.Utilities.FontInformation : ValueType {
    [CompilerGeneratedAttribute]
private string <Typeface>k__BackingField;
    [CompilerGeneratedAttribute]
private short <PointSize>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <CharSet>k__BackingField;
    public string Typeface { get; public set; }
    public short PointSize { get; public set; }
    public byte CharSet { get; public set; }
    public bool IsValid { get; }
    internal FontInformation(BinaryReader reader);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Typeface();
    [CompilerGeneratedAttribute]
public void set_Typeface(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public short get_PointSize();
    [CompilerGeneratedAttribute]
public void set_PointSize(short value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public byte get_CharSet();
    [CompilerGeneratedAttribute]
public void set_CharSet(byte value);
    public bool get_IsValid();
    internal void WriteToStream(BinaryWriter writer);
}
public static class Microsoft.VisualStudio.Utilities.GZip : object {
    public static Byte[] Compress(Byte[] data);
    public static Byte[] Decompress(Byte[] data, int bufferSize);
}
public class Microsoft.VisualStudio.Utilities.InvalidDpiException : InvalidOperationException {
    [CompilerGeneratedAttribute]
private double <InvalidDpi>k__BackingField;
    public double InvalidDpi { get; }
    public InvalidDpiException(double invalidDpi, string message);
    [CompilerGeneratedAttribute]
public double get_InvalidDpi();
}
[DefaultMemberAttribute("Item")]
public interface Microsoft.VisualStudio.Utilities.IOrderedStreamStorage`1 {
    public int Count { get; }
    public Stream Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual Stream get_Item(int index);
    public abstract virtual Stream CreateAt(int index, TKey key);
    public abstract virtual bool DeleteAt(int index);
    public abstract virtual void Reset(IEnumerable`1<TKey> newKeys);
}
[DefaultMemberAttribute("Item")]
public interface Microsoft.VisualStudio.Utilities.IStreamStorage`1 {
    public Stream Item { get; }
    public abstract virtual Stream Open(TKey key, StreamAccess access);
    public abstract virtual Stream Create(TKey key);
    public abstract virtual bool Delete(TKey key);
    public abstract virtual bool Contains(TKey key);
    public abstract virtual Stream get_Item(TKey key);
    public abstract virtual DateTime GetTimestamp(TKey key, TimestampKind kind);
    public abstract virtual void SetTimestamp(TKey key, TimestampKind kind, DateTime timestamp);
    public abstract virtual void GetStreamSize(TKey key, Int64& actualSize, Int64& reservedSize);
}
public interface Microsoft.VisualStudio.Utilities.IStreamStorageEvents`1 {
    public bool EnableRaisingEvents { get; public set; }
    public abstract virtual bool get_EnableRaisingEvents();
    public abstract virtual void set_EnableRaisingEvents(bool value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StreamCreated(EventHandler`1<TKey> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StreamCreated(EventHandler`1<TKey> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StreamDeleted(EventHandler`1<TKey> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StreamDeleted(EventHandler`1<TKey> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StreamChanged(EventHandler`1<TKey> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StreamChanged(EventHandler`1<TKey> value);
}
public interface Microsoft.VisualStudio.Utilities.IStreamStorageKeyFactory`1 {
    public abstract virtual T CreateKey(string streamName);
}
public interface Microsoft.VisualStudio.Utilities.ITracer {
    public TraceSource Source { get; }
    public SourceLevels Level { get; public set; }
    public int IndentLevel { get; }
    public abstract virtual TraceSource get_Source();
    public abstract virtual SourceLevels get_Level();
    public abstract virtual void set_Level(SourceLevels value);
    public abstract virtual int get_IndentLevel();
    public abstract virtual void Trace(TraceEventType eventType, string message);
    public abstract virtual void Trace(TraceEventType eventType, string message, object arg0);
    public abstract virtual void Trace(TraceEventType eventType, string message, object arg0, object arg1);
    public abstract virtual void Trace(TraceEventType eventType, string message, Object[] args);
    public abstract virtual void TraceError(string message);
    public abstract virtual void TraceError(string message, object arg0);
    public abstract virtual void TraceError(string message, object arg0, object arg1);
    public abstract virtual void TraceError(string message, Object[] args);
    public abstract virtual void TraceWarning(string message);
    public abstract virtual void TraceWarning(string message, object arg0);
    public abstract virtual void TraceWarning(string message, object arg0, object arg1);
    public abstract virtual void TraceWarning(string message, Object[] args);
    public abstract virtual void TraceInformation(string message);
    public abstract virtual void TraceInformation(string message, object arg0);
    public abstract virtual void TraceInformation(string message, object arg0, object arg1);
    public abstract virtual void TraceInformation(string message, Object[] args);
    public abstract virtual void TraceVerbose(string message);
    public abstract virtual void TraceVerbose(string message, object arg0);
    public abstract virtual void TraceVerbose(string message, object arg0, object arg1);
    public abstract virtual void TraceVerbose(string message, Object[] args);
    public abstract virtual void TraceException(Exception ex, TraceEventType eventType);
    public abstract virtual bool ShouldTrace(TraceEventType eventType);
    public abstract virtual IDisposable Indent(int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Utilities.LogHub.WriteCountedFileStream : FileStream {
    private UInt32 writeCount;
    private ulong bytesWritten;
    public UInt32 WriteCount { get; }
    public ulong BytesWritten { get; }
    public WriteCountedFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public UInt32 get_WriteCount();
    public ulong get_BytesWritten();
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void WriteByte(byte value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Utilities.LogHub.WriteCountedFileStreamWriter : StreamWriter {
    [CompilerGeneratedAttribute]
private WriteCountedFileStream <WriteCountedFileStream>k__BackingField;
    public WriteCountedFileStream WriteCountedFileStream { get; }
    public string FilePath { get; }
    public UInt32 WriteCount { get; }
    public ulong BytesWritten { get; }
    private WriteCountedFileStreamWriter(WriteCountedFileStream writeCountedFileStream, Encoding encoding);
    [CompilerGeneratedAttribute]
public WriteCountedFileStream get_WriteCountedFileStream();
    public string get_FilePath();
    public UInt32 get_WriteCount();
    public ulong get_BytesWritten();
    public static WriteCountedFileStreamWriter Create(string path, FileMode mode, FileAccess access, FileShare share, Encoding encoding, bool enableAutoFlush);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.LogicalStringComparer : StringComparer {
    private StringComparer _comparer;
    private StringComparison _comparison;
    internal LogicalStringComparer(bool ignoreCase);
    [NullableContextAttribute("2")]
public virtual int Compare(string s1, string s2);
    [NullableContextAttribute("2")]
public virtual bool Equals(string s1, string s2);
    [NullableContextAttribute("2")]
public virtual int GetHashCode(string s);
    [NullableContextAttribute("2")]
public int Compare(string s1, int start1, int length1, string s2, int start2, int length2);
    [NullableContextAttribute("2")]
public bool Equals(string s1, int start1, int length1, string s2, int start2, int length2);
    private static int DistanceToFirstDigit(string s, int start, int length);
    private static int DistanceToFirstNonDigit(string s, int start, int length);
    private static int DistanceToFirst(string s, int start, int length, Predicate`1<char> pred);
    private static ulong ComputeNumericValue(string s, int start, int length);
    private static void ValidateStartIndexAndLength(string s, int start, Int32& length, string startParamName, string lengthParamName);
    private static void ValidateStartIndex(string s, int start, string paramName);
    private static void ValidateLength(string s, int start, int length, string paramName);
}
public class Microsoft.VisualStudio.Utilities.MonitorDpiAwarenessException : Win32DpiAwarenessException {
    [CompilerGeneratedAttribute]
private IntPtr <MonitorHandle>k__BackingField;
    public IntPtr MonitorHandle { get; }
    public MonitorDpiAwarenessException(IntPtr hmon, int hr, double invalidDpi, string message);
    [CompilerGeneratedAttribute]
public IntPtr get_MonitorHandle();
}
public class Microsoft.VisualStudio.Utilities.OnDisposeActionDisposable : object {
    private Action onDispose;
    private bool isDisposed;
    public OnDisposeActionDisposable(Action onDispose);
    public sealed virtual void Dispose();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class Microsoft.VisualStudio.Utilities.OneOrMany`1 : ValueType {
    private int _capacity;
    private object _data;
    private IEqualityComparer`1<T> comparer;
    public int Count { get; }
    public IEqualityComparer`1<T> Comparer { get; public set; }
    public T Item { get; public set; }
    public OneOrMany`1(int capacity);
    public OneOrMany`1(List`1<T> list);
    public OneOrMany`1(T data);
    public Enumerator<T> GetEnumerator();
    public void Add(T value);
    public int get_Count();
    public IEqualityComparer`1<T> get_Comparer();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Comparer(IEqualityComparer`1<T> value);
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void RemoveAt(int index);
    public IReadOnlyList`1<T> AsList();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.VisualStudio.Utilities.OSVersionHelper : object {
    private static short GetVersionEx(OSVERSIONINFOEX& o);
    public static bool IsSinceWinX(WindowsVersions version);
}
public static class Microsoft.VisualStudio.Utilities.PooledSpan : object {
    [NullableContextAttribute("2")]
public static PooledSpan`1<T> Create(int minimumSize, bool clearWhenDisposed, ArrayPool`1<T> pool);
    [NullableContextAttribute("1")]
public static PooledSpan`1<T> Create(IEnumerable`1<T> original, bool clearWhenDisposed, ArrayPool`1<T> pool);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class Microsoft.VisualStudio.Utilities.PooledSpan`1 : ValueType {
    private bool clearWhenDisposed;
    private T[] pooledArray;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private ArrayPool`1<T> <Pool>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Span`1<T> <Span>k__BackingField;
    public ArrayPool`1<T> Pool { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span`1<T> Span { get; }
    public PooledSpan`1(int minimumSize, bool clearWhenDisposed, ArrayPool`1<T> pool);
    public PooledSpan`1(IEnumerable`1<T> original, bool clearWhenDisposed, ArrayPool`1<T> pool);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ArrayPool`1<T> get_Pool();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Span`1<T> get_Span();
    public Enumerator<T> GetEnumerator();
    public void Dispose();
}
public class Microsoft.VisualStudio.Utilities.ReaderWriterLockSlimWrapper : object {
    [CompilerGeneratedAttribute]
private ReaderWriterLockSlim <InnerLock>k__BackingField;
    public ReaderWriterLockSlim InnerLock { get; }
    public ReaderWriterLockSlimWrapper(ReaderWriterLockSlim innerLock);
    [CompilerGeneratedAttribute]
public ReaderWriterLockSlim get_InnerLock();
    public IDisposable EnterReadLock();
    public IDisposable EnterUpgradeableReadLock();
    public IDisposable EnterWriteLock();
    public IDisposable TryEnterReadLock(int millisecondsTimeout);
    public IDisposable TryEnterReadLock(TimeSpan timeout);
    public IDisposable TryEnterUpgradeableReadLock(int millisecondsTimeout);
    public IDisposable TryEnterUpgradeableReadLock(TimeSpan timeout);
    public IDisposable TryEnterWriteLock(int millisecondsTimeout);
    public IDisposable TryEnterWriteLock(TimeSpan timeout);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.Utilities.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Error_CircularPropertyDependency { get; }
    internal static string Error_ConverterFunctionNotDefined { get; }
    internal static string Error_DependsOnPropertyNotFound { get; }
    internal static string Error_DeserializationCallbackFailure { get; }
    internal static string Error_FailedToAcquireMutex { get; }
    internal static string Error_FailedToUpdateInternalState { get; }
    internal static string Error_FlagNotRegistered { get; }
    internal static string Error_InsufficientSourceParameters { get; }
    internal static string Error_InsufficientTypeParameters { get; }
    internal static string Error_InvalidExtensionNoLeadingPeriod { get; }
    internal static string Error_InvalidExtensionTooManyPeriods { get; }
    internal static string Error_InvalidExternalClientProcessPid { get; }
    internal static string Error_InvalidMaxStorageSize { get; }
    internal static string Error_InvalidMaxStreamCount { get; }
    internal static string Error_InvalidMessageVersionHeader { get; }
    internal static string Error_InvalidNameFilter { get; }
    internal static string Error_InvalidNullableTypeCode { get; }
    internal static string Error_InvalidPatternForFeatureName { get; }
    internal static string Error_InvalidRootPath { get; }
    internal static string Error_InvalidStreamAccess { get; }
    internal static string Error_InvalidTimestampKind { get; }
    internal static string Error_MaximumObjectIdentifierExceeded { get; }
    internal static string Error_MetadataMapShouldHaveSize { get; }
    internal static string Error_NeedStreamCountOrStorageSize { get; }
    internal static string Error_NeedSuccessCode { get; }
    internal static string Error_NoStreamStorageEvents { get; }
    internal static string Error_NullSerializerFieldCodeNullable { get; }
    internal static string Error_PrivateToSharedNameTranslatorReturnedNullOrEmpty { get; }
    internal static string Error_TargetAtOffsetNotExtendingType { get; }
    internal static string Error_TargetNotExtendingType { get; }
    internal static string Error_ThicknessConverter_InvalidTargetType { get; }
    internal static string Error_ThicknessConverter_InvalidValues { get; }
    internal static string Error_UnexpectedStreamVersion { get; }
    internal static string Error_ValueAtOffsetNotOfType { get; }
    internal static string Error_ValueNotOfType { get; }
    internal static string IncompatibleSettingTypeMessage { get; }
    internal static string JsonSerializationFailed { get; }
    internal static string MisplacedSettingPathWildcard { get; }
    internal static string NormalizeError_InvalidPathChar { get; }
    internal static string ServiceUnavailable_Format { get; }
    internal static string SettingNotRegisteredMessage { get; }
    internal static string ValidateError_BitmapNotBgra32 { get; }
    internal static string ValidateError_GuidEmpty { get; }
    internal static string ValidateError_InvalidOperation { get; }
    internal static string ValidateError_InvalidValue_Format { get; }
    internal static string ValidateError_OutOfRange_Format { get; }
    internal static string ValidateError_PathNotNormalized_Format { get; }
    internal static string ValidateError_StringEmpty { get; }
    internal static string ValidateError_StringWhiteSpace { get; }
    internal static string ValidateError_UnexpectedValue_Format { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Error_CircularPropertyDependency();
    internal static string get_Error_ConverterFunctionNotDefined();
    internal static string get_Error_DependsOnPropertyNotFound();
    internal static string get_Error_DeserializationCallbackFailure();
    internal static string get_Error_FailedToAcquireMutex();
    internal static string get_Error_FailedToUpdateInternalState();
    internal static string get_Error_FlagNotRegistered();
    internal static string get_Error_InsufficientSourceParameters();
    internal static string get_Error_InsufficientTypeParameters();
    internal static string get_Error_InvalidExtensionNoLeadingPeriod();
    internal static string get_Error_InvalidExtensionTooManyPeriods();
    internal static string get_Error_InvalidExternalClientProcessPid();
    internal static string get_Error_InvalidMaxStorageSize();
    internal static string get_Error_InvalidMaxStreamCount();
    internal static string get_Error_InvalidMessageVersionHeader();
    internal static string get_Error_InvalidNameFilter();
    internal static string get_Error_InvalidNullableTypeCode();
    internal static string get_Error_InvalidPatternForFeatureName();
    internal static string get_Error_InvalidRootPath();
    internal static string get_Error_InvalidStreamAccess();
    internal static string get_Error_InvalidTimestampKind();
    internal static string get_Error_MaximumObjectIdentifierExceeded();
    internal static string get_Error_MetadataMapShouldHaveSize();
    internal static string get_Error_NeedStreamCountOrStorageSize();
    internal static string get_Error_NeedSuccessCode();
    internal static string get_Error_NoStreamStorageEvents();
    internal static string get_Error_NullSerializerFieldCodeNullable();
    internal static string get_Error_PrivateToSharedNameTranslatorReturnedNullOrEmpty();
    internal static string get_Error_TargetAtOffsetNotExtendingType();
    internal static string get_Error_TargetNotExtendingType();
    internal static string get_Error_ThicknessConverter_InvalidTargetType();
    internal static string get_Error_ThicknessConverter_InvalidValues();
    internal static string get_Error_UnexpectedStreamVersion();
    internal static string get_Error_ValueAtOffsetNotOfType();
    internal static string get_Error_ValueNotOfType();
    internal static string get_IncompatibleSettingTypeMessage();
    internal static string get_JsonSerializationFailed();
    internal static string get_MisplacedSettingPathWildcard();
    internal static string get_NormalizeError_InvalidPathChar();
    internal static string get_ServiceUnavailable_Format();
    internal static string get_SettingNotRegisteredMessage();
    internal static string get_ValidateError_BitmapNotBgra32();
    internal static string get_ValidateError_GuidEmpty();
    internal static string get_ValidateError_InvalidOperation();
    internal static string get_ValidateError_InvalidValue_Format();
    internal static string get_ValidateError_OutOfRange_Format();
    internal static string get_ValidateError_PathNotNormalized_Format();
    internal static string get_ValidateError_StringEmpty();
    internal static string get_ValidateError_StringWhiteSpace();
    internal static string get_ValidateError_UnexpectedValue_Format();
}
public class Microsoft.VisualStudio.Utilities.ReusableArray`1 : ReusableResourceStore`2<T[], int> {
    private bool requiresExactSize;
    private int maximumCacheArrayLength;
    public ReusableArray`1(bool requiresExactSize, int maximumCacheArrayLength);
    protected virtual T[] Allocate(int constructorParameter);
    protected virtual bool CanReuse(T[] value, int parameter);
    protected virtual bool Cleanup(T[] value);
}
public class Microsoft.VisualStudio.Utilities.ReusableMemoryStream : ReusableResourceStore`2<MemoryStream, int> {
    private int maximumStreamCapacity;
    public ReusableMemoryStream(int maximumStreamCapacity);
    protected virtual MemoryStream Allocate(int constructorParameter);
    protected virtual bool Cleanup(MemoryStream value);
}
public class Microsoft.VisualStudio.Utilities.ReusableResourceHolder`1 : ValueType {
    private ReusableResourceStoreBase`1<TResource> store;
    private TResource resource;
    public TResource Resource { get; }
    internal ReusableResourceHolder`1(ReusableResourceStoreBase`1<TResource> store, TResource value);
    public sealed virtual void Dispose();
    public TResource get_Resource();
}
public abstract class Microsoft.VisualStudio.Utilities.ReusableResourceStore`1 : ReusableResourceStoreBase`1<TResource> {
    public ReusableResourceHolder`1<TResource> Acquire();
    protected abstract virtual TResource Allocate();
    protected virtual bool CanReuse(TResource value);
}
public abstract class Microsoft.VisualStudio.Utilities.ReusableResourceStore`2 : ReusableResourceStoreBase`1<TResource> {
    public ReusableResourceHolder`1<TResource> Acquire(TConstructorParameter constructorParameter);
    protected abstract virtual TResource Allocate(TConstructorParameter constructorParameter);
    protected virtual bool CanReuse(TResource value, TConstructorParameter parameter);
}
public abstract class Microsoft.VisualStudio.Utilities.ReusableResourceStoreBase`1 : object {
    private TResource resource;
    protected TResource AcquireCore();
    internal void ReleaseCore(TResource value);
    protected virtual bool Cleanup(TResource value);
}
public class Microsoft.VisualStudio.Utilities.ReusableStringBuilder : ReusableResourceStore`2<StringBuilder, int> {
    private int maximumCacheCapacity;
    private static ReusableStringBuilder defaultInstance;
    public ReusableStringBuilder(int maximumCacheCapacity);
    private static ReusableStringBuilder();
    public static ReusableResourceHolder`1<StringBuilder> AcquireDefault(int capacity);
    protected virtual StringBuilder Allocate(int constructorParameter);
    protected virtual bool Cleanup(StringBuilder value);
    protected virtual bool CanReuse(StringBuilder value, int parameter);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Utilities.SerializationExtensions : object {
    private static int GuidByteSize;
    [ExtensionAttribute]
public static Guid ReadGuid(BinaryReader reader);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, Guid guid);
    [ExtensionAttribute]
public static string ReadUTF8String(BinaryReader reader);
    [ExtensionAttribute]
public static void WriteUTF8String(BinaryWriter writer, string value);
    [ExtensionAttribute]
public static Nullable`1<bool> ReadNullableBoolean(BinaryReader reader);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, Nullable`1<bool> value);
    [ExtensionAttribute]
public static Nullable`1<char> ReadNullableChar(BinaryReader reader);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, Nullable`1<char> value);
    [ExtensionAttribute]
public static Nullable`1<double> ReadNullableDouble(BinaryReader reader);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, Nullable`1<double> value);
    [ExtensionAttribute]
public static Nullable`1<short> ReadNullableInt16(BinaryReader reader);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, Nullable`1<short> value);
    [ExtensionAttribute]
public static Nullable`1<int> ReadNullableInt32(BinaryReader reader);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, Nullable`1<int> value);
    [ExtensionAttribute]
public static Nullable`1<long> ReadNullableInt64(BinaryReader reader);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, Nullable`1<long> value);
    [ExtensionAttribute]
public static Nullable`1<float> ReadNullableSingle(BinaryReader reader);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, Nullable`1<float> value);
    [ExtensionAttribute]
public static Nullable`1<ushort> ReadNullableUInt16(BinaryReader reader);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, Nullable`1<ushort> value);
    [ExtensionAttribute]
public static Nullable`1<UInt32> ReadNullableUInt32(BinaryReader reader);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, Nullable`1<UInt32> value);
    [ExtensionAttribute]
public static Nullable`1<ulong> ReadNullableUInt64(BinaryReader reader);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, Nullable`1<ulong> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Utilities.ServiceBroker.BrokeredServiceContainerWithTelemetry : GlobalBrokeredServiceContainer {
    [NullableAttribute("2")]
private TelemetrySession telemetrySession;
    private Dictionary`2<ServiceMoniker, int> monikersWithPostedEvents;
    private object syncObject;
    protected BrokeredServiceContainerWithTelemetry(ImmutableDictionary`2<ServiceMoniker, ServiceRegistration> services, bool isClientOfExclusiveServer, TelemetrySession telemetrySession, JoinableTaskFactory joinableTaskFactory, TraceSource traceSource);
    [NullableContextAttribute("2")]
protected virtual void OnRequestHandled(ServiceMoniker moniker, ServiceRpcDescriptor descriptor, RequestType type, RequestResult result, IProffered proffered);
    [CompilerGeneratedAttribute]
private ValueTask`1<object> <.ctor>b__3_0(View view, ServiceMoniker mk, ServiceActivationOptions options, IServiceBroker sb, CancellationToken ct);
}
internal class Microsoft.VisualStudio.Utilities.SimpleCache`1 : object {
    private static int DefaultMaxSize;
    private HashSet`1<Entry<T>> _cache;
    [CompilerGeneratedAttribute]
private int <MaxSize>k__BackingField;
    public int MaxSize { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SimpleCache`1(IEqualityComparer`1<T> comparer, int maxSize);
    public bool TryGetValue(T value, T& cachedValue);
    [CompilerGeneratedAttribute]
public int get_MaxSize();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual bool Remove(T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Microsoft.VisualStudio.Utilities.SimpleDynamicMemberAccessor : object {
    private Dictionary`2<Type, Dictionary`2<string, PropertyInfo>> _propertyInfoCache;
    public bool TryGetProperty(object instance, string propertyName, T& propertyValue);
    private PropertyInfo GetOrCreatePropertyInfo(object instance, string propertyName);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Utilities.StreamAccess : Enum {
    public int value__;
    public static StreamAccess Read;
    public static StreamAccess Write;
    public static StreamAccess ReadWrite;
}
public class Microsoft.VisualStudio.Utilities.StreamAccessException : StreamException {
    public StreamAccessException(object key);
    public StreamAccessException(object key, string message);
    public StreamAccessException(object key, string message, Exception internalEx);
}
public class Microsoft.VisualStudio.Utilities.StreamException : Exception {
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    public object Key { get; private set; }
    public StreamException(object key);
    public StreamException(object key, string message);
    public StreamException(object key, string message, Exception internalEx);
    [CompilerGeneratedAttribute]
public object get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(object value);
    public virtual string ToString();
}
public class Microsoft.VisualStudio.Utilities.StreamNotFoundException : StreamException {
    public StreamNotFoundException(object key);
    public StreamNotFoundException(object key, string message);
    public StreamNotFoundException(object key, string message, Exception internalEx);
}
public class Microsoft.VisualStudio.Utilities.StreamStorageMonitor`1 : DisposableObject {
    private IStreamStorage`1<TKey> _storage;
    private IStreamStorageEvents`1<TKey> _events;
    private Dictionary`2<TKey, StreamInfo<TKey>> _streams;
    private object _syncObject;
    private int _maxStreamCount;
    private long _maxStorageSize;
    private bool _enableMonitoring;
    [CompilerGeneratedAttribute]
private long <StorageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Task <LastScrubTask>k__BackingField;
    public bool EnableMonitoring { get; public set; }
    private int StreamCount { get; }
    private long StorageSize { get; private set; }
    private bool WatchingStreamCount { get; }
    private bool WatchingStorageSize { get; }
    private bool StorageNeedsScrubbing { get; }
    internal Task LastScrubTask { get; private set; }
    public StreamStorageMonitor`1(IStreamStorage`1<TKey> storage, int maxStreamCount, long maxStorageSize, bool enable, IEqualityComparer`1<TKey> keyComparer);
    public static void ValidateLimits(int maxStreamCount, long maxStorageSize);
    protected virtual void DisposeManagedResources();
    public bool get_EnableMonitoring();
    public void set_EnableMonitoring(bool value);
    private int get_StreamCount();
    [CompilerGeneratedAttribute]
private long get_StorageSize();
    [CompilerGeneratedAttribute]
private void set_StorageSize(long value);
    private bool get_WatchingStreamCount();
    private bool get_WatchingStorageSize();
    private bool get_StorageNeedsScrubbing();
    [CompilerGeneratedAttribute]
internal Task get_LastScrubTask();
    [CompilerGeneratedAttribute]
private void set_LastScrubTask(Task value);
    private void InitializeStreamTable();
    private void AddStreamInfo(TKey key);
    private void RemoveStreamInfo(TKey key);
    private void UpdateStreamInfo(TKey key);
    private void ScheduleScrubStorage();
    private void ScrubStorage();
    private StreamInfo<TKey> GetStreamInfo(TKey key);
    private long GetStreamSize(TKey key);
    private void HookEvents();
    private void UnhookEvents();
    private void OnStreamCreated(object sender, TKey key);
    private void OnStreamDeleted(object sender, TKey key);
    private void OnStreamChanged(object sender, TKey key);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <ScheduleScrubStorage>b__33_0(Task _);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Utilities.StringExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ExpandEnvironmentVariables(string s);
}
public enum Microsoft.VisualStudio.Utilities.TimestampKind : Enum {
    public int value__;
    public static TimestampKind Creation;
    public static TimestampKind LastAccess;
    public static TimestampKind LastWrite;
}
public class Microsoft.VisualStudio.Utilities.TracedEvent : object {
    private object syncRoot;
    private Action handler;
    private bool hasFired;
    public bool HasFired { get; }
    public bool get_HasFired();
    public void Fire();
    public void Attach(Action handler);
    public void Remove(Action handler);
    public bool AttachIfNotFired(Action handler, bool invokeIfFired);
}
public class Microsoft.VisualStudio.Utilities.Tracer : object {
    public static string IndentString;
    public static int MaxIndent;
    public static ITracer Null;
    private TraceSource _traceSource;
    private WeakReference`1<StringBuilder> _weakBuilder;
    [CompilerGeneratedAttribute]
private int <IndentLevel>k__BackingField;
    public TraceSource Source { get; }
    public SourceLevels Level { get; public set; }
    public int IndentLevel { get; private set; }
    public Tracer(string name);
    private static Tracer();
    public virtual string ToString();
    public sealed virtual TraceSource get_Source();
    public sealed virtual SourceLevels get_Level();
    public sealed virtual void set_Level(SourceLevels value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IndentLevel();
    [CompilerGeneratedAttribute]
private void set_IndentLevel(int value);
    public sealed virtual void Trace(TraceEventType eventType, string message);
    public sealed virtual void Trace(TraceEventType eventType, string message, object arg0);
    public sealed virtual void Trace(TraceEventType eventType, string message, object arg0, object arg1);
    public sealed virtual void Trace(TraceEventType eventType, string message, Object[] args);
    public sealed virtual void TraceError(string message);
    public sealed virtual void TraceError(string message, object arg0);
    public sealed virtual void TraceError(string message, object arg0, object arg1);
    public sealed virtual void TraceError(string message, Object[] args);
    public sealed virtual void TraceWarning(string message);
    public sealed virtual void TraceWarning(string message, object arg0);
    public sealed virtual void TraceWarning(string message, object arg0, object arg1);
    public sealed virtual void TraceWarning(string message, Object[] args);
    public sealed virtual void TraceInformation(string message);
    public sealed virtual void TraceInformation(string message, object arg0);
    public sealed virtual void TraceInformation(string message, object arg0, object arg1);
    public sealed virtual void TraceInformation(string message, Object[] args);
    public sealed virtual void TraceVerbose(string message);
    public sealed virtual void TraceVerbose(string message, object arg0);
    public sealed virtual void TraceVerbose(string message, object arg0, object arg1);
    public sealed virtual void TraceVerbose(string message, Object[] args);
    public sealed virtual void TraceException(Exception ex, TraceEventType eventType);
    public sealed virtual bool ShouldTrace(TraceEventType eventType);
    public sealed virtual IDisposable Indent(int count);
    private string FormatMessage(TraceEventType eventType, string format, Object[] args);
    private string BuildExceptionTraceMessage(Exception ex);
    private StringBuilder GetStringBuilder();
    private static string GetAlignmentString(TraceEventType eventType);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Utilities.TraceSourceExtensionMethods : object {
    public static int TraceEventIdUnknown;
    [ExtensionAttribute]
internal static void TraceException(TraceSource logger, Exception exception);
    [ExtensionAttribute]
internal static void TraceError(TraceSource logger, string message);
    [ExtensionAttribute]
internal static void TraceError(TraceSource logger, string format, Object[] args);
    [ExtensionAttribute]
internal static string ToStringWithInnerExceptions(Exception exception);
    [ExtensionAttribute]
internal static void TraceException(TraceSource logger, Exception exception, string format, Object[] args);
    private static string FormatException(Exception exception, string format, Object[] args);
    private static string FormatException(Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnifiedSettings.ArraySettingContent : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, object>> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UserSelectedDefaultItemIndex>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<IReadOnlyDictionary`2<string, object>> Items { get; public set; }
    public int UserSelectedDefaultItemIndex { get; public set; }
    public ArraySettingContent(IReadOnlyList`1<IReadOnlyDictionary`2<string, object>> Items, int UserSelectedDefaultItemIndex);
    [CompilerGeneratedAttribute]
protected ArraySettingContent(ArraySettingContent original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IReadOnlyDictionary`2<string, object>> get_Items();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Items(IReadOnlyList`1<IReadOnlyDictionary`2<string, object>> value);
    [CompilerGeneratedAttribute]
public int get_UserSelectedDefaultItemIndex();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UserSelectedDefaultItemIndex(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ArraySettingContent left, ArraySettingContent right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ArraySettingContent left, ArraySettingContent right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ArraySettingContent other);
    [CompilerGeneratedAttribute]
public virtual ArraySettingContent <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IReadOnlyList`1& Items, Int32& UserSelectedDefaultItemIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnifiedSettings.DynamicMessageTextChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    public string MessageId { get; }
    public DynamicMessageTextChangedEventArgs(string messageId);
    [CompilerGeneratedAttribute]
public string get_MessageId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnifiedSettings.EnumChoice : object {
    [CompilerGeneratedAttribute]
private string <Moniker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Moniker { get; public set; }
    public string Title { get; public set; }
    public EnumChoice(string Moniker, string Title);
    [CompilerGeneratedAttribute]
protected EnumChoice(EnumChoice original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Moniker();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Moniker(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Title(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(EnumChoice left, EnumChoice right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(EnumChoice left, EnumChoice right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(EnumChoice other);
    [CompilerGeneratedAttribute]
public virtual EnumChoice <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Moniker, String& Title);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnifiedSettings.EnumSettingChoicesChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <SettingMoniker>k__BackingField;
    public string SettingMoniker { get; }
    public EnumSettingChoicesChangedEventArgs(string settingMoniker);
    [CompilerGeneratedAttribute]
public string get_SettingMoniker();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Utilities.UnifiedSettings.ExternalSettingOperationResult : object {
    private static Task`1<ExternalSettingOperationResult> successResultTask;
    private static ExternalSettingOperationResult();
    public static ExternalSettingOperationResult`1<T> SuccessResult(T result);
    public static ExternalSettingOperationResult`1<T> ConvertSuccessResult(object result);
    public static Task`1<ExternalSettingOperationResult> SuccessResultTask();
    public static Task`1<ExternalSettingOperationResult`1<T>> SuccessResultTask(T result);
    public static Task`1<ExternalSettingOperationResult`1<T>> ConvertSuccessResultTask(object result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Utilities.UnifiedSettings.ExternalSettingOperationResult`1 : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnifiedSettings.ExternalSettingsChangedEventArgs : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OneOrMany`1<string> monikers;
    [CompilerGeneratedAttribute]
private static ExternalSettingsChangedEventArgs <SomeOrAll>k__BackingField;
    public static ExternalSettingsChangedEventArgs SomeOrAll { get; }
    private ExternalSettingsChangedEventArgs(OneOrMany`1<string> monikers);
    private static ExternalSettingsChangedEventArgs();
    public static ExternalSettingsChangedEventArgs Single(string moniker);
    public static ExternalSettingsChangedEventArgs Multiple(IEnumerable`1<string> monikers);
    [CompilerGeneratedAttribute]
public static ExternalSettingsChangedEventArgs get_SomeOrAll();
    public bool AppliesTo(string moniker);
}
public enum Microsoft.VisualStudio.Utilities.UnifiedSettings.ExternalSettingsErrorScope : Enum {
    public int value__;
    public static ExternalSettingsErrorScope Unknown;
    public static ExternalSettingsErrorScope SingleSettingOnly;
    public static ExternalSettingsErrorScope EntireRegion;
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.UnifiedSettings.IArraySettingMigrator {
    public abstract virtual Task`1<ArraySettingContent> MigrateToUnifiedSettingsAsync(string arraySettingMoniker, CancellationToken cancellationToken);
    public abstract virtual bool SupportsIncompleteItems(string arraySettingMoniker);
    public abstract virtual Task MigrateFromUnifiedSettingsAsync(string arraySettingMoniker, ArraySettingContent arrayContent, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Utilities.UnifiedSettings.ICachingExternalSettingsProvider {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ExternalSettingOperationResult> CommitPendingChangesAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ExternalSettingOperationResult> RefreshCacheAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.UnifiedSettings.IExternalSettingsProvider {
    [CompilerGeneratedAttribute]
public abstract virtual void add_SettingValuesChanged(EventHandler`1<ExternalSettingsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SettingValuesChanged(EventHandler`1<ExternalSettingsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_EnumSettingChoicesChanged(EventHandler`1<EnumSettingChoicesChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EnumSettingChoicesChanged(EventHandler`1<EnumSettingChoicesChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DynamicMessageTextChanged(EventHandler`1<DynamicMessageTextChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DynamicMessageTextChanged(EventHandler`1<DynamicMessageTextChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ErrorConditionResolved(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ErrorConditionResolved(EventHandler value);
    public abstract virtual Task`1<ExternalSettingOperationResult`1<T>> GetValueAsync(string moniker, CancellationToken cancellationToken);
    public abstract virtual Task`1<ExternalSettingOperationResult> SetValueAsync(string moniker, T value, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetMessageTextAsync(string messageId, CancellationToken cancellationToken);
    public abstract virtual Task`1<ExternalSettingOperationResult`1<IReadOnlyList`1<EnumChoice>>> GetEnumChoicesAsync(string enumSettingMoniker, CancellationToken cancellationToken);
    public abstract virtual Task OpenBackingStoreAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnifiedSettings.IncompatibleSettingTypeException : Exception {
    public IncompatibleSettingTypeException(string value, string targetType);
    protected IncompatibleSettingTypeException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[GuidAttribute("2f26e586-2b51-40ed-8a5d-7d83ab877c0f")]
public interface Microsoft.VisualStudio.Utilities.UnifiedSettings.ISettingsManager {
    public abstract virtual ISettingsReader GetReader();
    public abstract virtual ISettingsWriter GetWriter(string callerName);
    public abstract virtual ISettingsWriter GetWriter(string callerName, Guid eventSource);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.UnifiedSettings.ISettingsReader {
    public abstract virtual IDisposable SubscribeToChanges(Action`1<SettingsUpdate> handler, String[] monikerPatterns);
    public abstract virtual SettingRetrieval`1<IReadOnlyList`1<T>> GetArray(string moniker, SettingReadOptions readOptions);
    public abstract virtual SettingRetrieval`1<T> GetValue(string moniker, SettingReadOptions readOptions);
    public abstract virtual SettingRetrieval`1<object> GetValue(string moniker, Type targetType, SettingReadOptions readOptions);
    public abstract virtual IReadOnlyList`1<T> GetArrayOrThrow(string moniker);
    public abstract virtual T GetValueOrThrow(string moniker);
    public abstract virtual object GetValueOrThrow(string moniker, Type targetType);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Utilities.UnifiedSettings.ISettingsWriter {
    public abstract virtual SettingChangeResult EnqueueChange(string moniker, T value);
    public abstract virtual SettingChangeResult EnqueueChange(string moniker, T value, SettingWriteOptions options);
    public abstract virtual SettingChangeResult EnqueueArrayChange(string moniker, IReadOnlyList`1<T> value);
    public abstract virtual SettingCommitResult RequestCommit(string changeDescription);
    [ObsoleteAttribute("This method will be removed. Use RequestCommit instead.")]
public abstract virtual SettingCommitResult Commit(string changeDescription);
}
public enum Microsoft.VisualStudio.Utilities.UnifiedSettings.SettingChangeOutcome : Enum {
    public int value__;
    public static SettingChangeOutcome PendingCommit;
    public static SettingChangeOutcome PendingCommitWithoutValidation;
    public static SettingChangeOutcome Denied;
    public static SettingChangeOutcome InvalidValue;
    public static SettingChangeOutcome NoMigration;
    public static SettingChangeOutcome MigrationFailed;
    public static SettingChangeOutcome InternalError;
    public static SettingChangeOutcome NotSupportedInClassicMode;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnifiedSettings.SettingChangeResult : object {
    [CompilerGeneratedAttribute]
private SettingChangeOutcome <Outcome>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CommitWillChangeEffectiveValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public SettingChangeOutcome Outcome { get; public set; }
    public bool CommitWillChangeEffectiveValue { get; public set; }
    public string Message { get; public set; }
    public SettingChangeResult(SettingChangeOutcome Outcome, bool CommitWillChangeEffectiveValue, string Message);
    [CompilerGeneratedAttribute]
protected SettingChangeResult(SettingChangeResult original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public SettingChangeOutcome get_Outcome();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Outcome(SettingChangeOutcome value);
    [CompilerGeneratedAttribute]
public bool get_CommitWillChangeEffectiveValue();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CommitWillChangeEffectiveValue(bool value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Message(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SettingChangeResult left, SettingChangeResult right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SettingChangeResult left, SettingChangeResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SettingChangeResult other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual SettingChangeResult <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(SettingChangeOutcome& Outcome, Boolean& CommitWillChangeEffectiveValue, String& Message);
}
public enum Microsoft.VisualStudio.Utilities.UnifiedSettings.SettingCommitOutcome : Enum {
    public int value__;
    public static SettingCommitOutcome NoChangesQueued;
    public static SettingCommitOutcome Success;
    public static SettingCommitOutcome PendingApproval;
    public static SettingCommitOutcome InternalError;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnifiedSettings.SettingCommitResult : object {
    [CompilerGeneratedAttribute]
private SettingCommitOutcome <Outcome>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public SettingCommitOutcome Outcome { get; public set; }
    public string Message { get; public set; }
    public SettingCommitResult(SettingCommitOutcome Outcome, string Message);
    [CompilerGeneratedAttribute]
protected SettingCommitResult(SettingCommitResult original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public SettingCommitOutcome get_Outcome();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Outcome(SettingCommitOutcome value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Message(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SettingCommitResult left, SettingCommitResult right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SettingCommitResult left, SettingCommitResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SettingCommitResult other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual SettingCommitResult <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(SettingCommitOutcome& Outcome, String& Message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnifiedSettings.SettingNotRegisteredException : Exception {
    public SettingNotRegisteredException(string moniker);
    protected SettingNotRegisteredException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Utilities.UnifiedSettings.SettingReadOptions : Enum {
    public int value__;
    public static SettingReadOptions NoRequirements;
    public static SettingReadOptions RequireRegistration;
    public static SettingReadOptions RequireValidation;
    public static SettingReadOptions NoFallbackToDefault;
    public static SettingReadOptions ApplyMigration;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnifiedSettings.SettingRetrieval`1 : object {
    [CompilerGeneratedAttribute]
private SettingRetrievalOutcome <Outcome>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public SettingRetrievalOutcome Outcome { get; public set; }
    public string Message { get; public set; }
    public T Value { get; public set; }
    public SettingRetrieval`1(SettingRetrievalOutcome Outcome, string Message, T Value);
    [CompilerGeneratedAttribute]
protected SettingRetrieval`1(SettingRetrieval`1<T> original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public SettingRetrievalOutcome get_Outcome();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Outcome(SettingRetrievalOutcome value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Message(string value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(T value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SettingRetrieval`1<T> left, SettingRetrieval`1<T> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SettingRetrieval`1<T> left, SettingRetrieval`1<T> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SettingRetrieval`1<T> other);
    [CompilerGeneratedAttribute]
public virtual SettingRetrieval`1<T> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(SettingRetrievalOutcome& Outcome, String& Message, T& Value);
}
public enum Microsoft.VisualStudio.Utilities.UnifiedSettings.SettingRetrievalOutcome : Enum {
    public int value__;
    public static SettingRetrievalOutcome Success;
    public static SettingRetrievalOutcome FailedValidation;
    public static SettingRetrievalOutcome NotRegistered;
    public static SettingRetrievalOutcome NotPersisted;
    public static SettingRetrievalOutcome InvalidType;
    public static SettingRetrievalOutcome InternalError;
    public static SettingRetrievalOutcome NoMigration;
    public static SettingRetrievalOutcome MigrationFailed;
    public static SettingRetrievalOutcome NotSupportedInClassicMode;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnifiedSettings.SettingsUpdate : object {
    [CompilerGeneratedAttribute]
private Guid <EventSource>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ChangedSettingMonikers>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Guid EventSource { get; public set; }
    public HashSet`1<string> ChangedSettingMonikers { get; public set; }
    public SettingsUpdate(Guid EventSource, HashSet`1<string> ChangedSettingMonikers);
    [CompilerGeneratedAttribute]
protected SettingsUpdate(SettingsUpdate original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Guid get_EventSource();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EventSource(Guid value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ChangedSettingMonikers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ChangedSettingMonikers(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SettingsUpdate left, SettingsUpdate right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SettingsUpdate left, SettingsUpdate right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SettingsUpdate other);
    [CompilerGeneratedAttribute]
public virtual SettingsUpdate <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Guid& EventSource, HashSet`1& ChangedSettingMonikers);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Utilities.UnifiedSettings.SettingWriteOptions : Enum {
    public int value__;
    public static SettingWriteOptions None;
    public static SettingWriteOptions ApplyMigration;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Utilities.UnorderedDictionaryComparer`2 : object {
    private IEqualityComparer`1<TValue> valueComparer;
    [CompilerGeneratedAttribute]
private static UnorderedDictionaryComparer`2<TKey, TValue> <Default>k__BackingField;
    public static UnorderedDictionaryComparer`2<TKey, TValue> Default { get; }
    public UnorderedDictionaryComparer`2(IEqualityComparer`1<TValue> valueComparer);
    private static UnorderedDictionaryComparer`2();
    [CompilerGeneratedAttribute]
public static UnorderedDictionaryComparer`2<TKey, TValue> get_Default();
    public sealed virtual bool Equals(Dictionary`2<TKey, TValue> x, Dictionary`2<TKey, TValue> y);
    public sealed virtual int GetHashCode(Dictionary`2<TKey, TValue> obj);
}
public class Microsoft.VisualStudio.Utilities.VARIANT : ValueType {
    private TypeUnion _typeUnion;
    private decimal _decimal;
    public VarEnum vt { get; public set; }
    public sbyte i1 { get; public set; }
    public short i2 { get; public set; }
    public char ch { get; public set; }
    public int i4 { get; public set; }
    public long i8 { get; public set; }
    public byte ui1 { get; public set; }
    public ushort ui2 { get; public set; }
    public UInt32 ui4 { get; public set; }
    public ulong ui8 { get; public set; }
    public int int { get; public set; }
    public UInt32 uint { get; public set; }
    public bool bool { get; public set; }
    public int error { get; public set; }
    public float r4 { get; public set; }
    public double r8 { get; public set; }
    public decimal decimal { get; public set; }
    public long cy { get; public set; }
    public double date { get; public set; }
    public IntPtr bstrVal { get; public set; }
    public IntPtr punkVal { get; public set; }
    public IntPtr pdispVal { get; public set; }
    public static VARIANT ToVariant(IntPtr pIn);
    public VarEnum get_vt();
    public void set_vt(VarEnum value);
    public sbyte get_i1();
    public void set_i1(sbyte value);
    public short get_i2();
    public void set_i2(short value);
    public char get_ch();
    public void set_ch(char value);
    public int get_i4();
    public void set_i4(int value);
    public long get_i8();
    public void set_i8(long value);
    public byte get_ui1();
    public void set_ui1(byte value);
    public ushort get_ui2();
    public void set_ui2(ushort value);
    public UInt32 get_ui4();
    public void set_ui4(UInt32 value);
    public ulong get_ui8();
    public void set_ui8(ulong value);
    public int get_int();
    public void set_int(int value);
    public UInt32 get_uint();
    public void set_uint(UInt32 value);
    public bool get_bool();
    public void set_bool(bool value);
    public int get_error();
    public void set_error(int value);
    public float get_r4();
    public void set_r4(float value);
    public double get_r8();
    public void set_r8(double value);
    public decimal get_decimal();
    public void set_decimal(decimal value);
    public long get_cy();
    public void set_cy(long value);
    public double get_date();
    public void set_date(double value);
    public IntPtr get_bstrVal();
    public void set_bstrVal(IntPtr value);
    public IntPtr get_punkVal();
    public void set_punkVal(IntPtr value);
    public IntPtr get_pdispVal();
    public void set_pdispVal(IntPtr value);
}
public class Microsoft.VisualStudio.Utilities.VersionedBinaryReader : BinaryReader {
    public VersionedBinaryReader(Stream stream);
    public VersionedBinaryReader(Stream stream, Encoding encoding, bool leaveOpen);
    public void ReadVersioned(int expectedVersion, ReadCallback callback, bool throwOnUnexpectedVersion);
    public void ReadVersioned(int expectedVersion, MultiVersionReadCallback callback);
    private StreamInfo ReadHeader();
}
public class Microsoft.VisualStudio.Utilities.VersionedBinaryWriter : BinaryWriter {
    public static int HeaderLength;
    public VersionedBinaryWriter(Stream stream);
    public VersionedBinaryWriter(Stream stream, Encoding encoding, bool leaveOpen);
    public void WriteVersioned(int version, WriteCallback callback);
}
public class Microsoft.VisualStudio.Utilities.Win32DpiAwarenessException : InvalidDpiException {
    [CompilerGeneratedAttribute]
private int <DpiMethodResult>k__BackingField;
    public int DpiMethodResult { get; }
    public Win32DpiAwarenessException(int hr, double invalidDpi, string message);
    [CompilerGeneratedAttribute]
public int get_DpiMethodResult();
}
public class Microsoft.VisualStudio.Utilities.WindowDpiAwarenessException : Win32DpiAwarenessException {
    [CompilerGeneratedAttribute]
private IntPtr <WindowHandle>k__BackingField;
    public IntPtr WindowHandle { get; }
    public WindowDpiAwarenessException(IntPtr hwnd, int hr, double invalidDpi, string message);
    [CompilerGeneratedAttribute]
public IntPtr get_WindowHandle();
}
internal static class MinTargetVersion : object {
    internal static string MinimumWindowsTarget;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Diagnostics.StartActivityExtension : object {
    [ExtensionAttribute]
internal static TraceActivity StartActivity(TraceSource traceSource, string displayName, Object[] displayNameFormattingArgs);
    [ExtensionAttribute]
internal static TraceActivity StartActivity(TraceSource traceSource, string displayName);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.133.12845")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string RootNamespace;
    private static ThisAssembly();
}
[DefaultMemberAttribute("Item")]
internal class Windows.Win32.__byte_3 : ValueType {
    private static int SpanLength;
    [FixedBufferAttribute("System.Byte", "3")]
internal <Value>e__FixedBuffer Value;
    internal int Length { get; }
    [UnscopedRefAttribute]
internal Byte& Item { get; }
    [IsReadOnlyAttribute]
internal int get_Length();
    internal Byte& get_Item(int index);
    [UnscopedRefAttribute]
internal Span`1<byte> AsSpan();
    [IsReadOnlyAttribute]
[UnscopedRefAttribute]
internal ReadOnlySpan`1<byte> AsReadOnlySpan();
    [IsReadOnlyAttribute]
internal bool Equals(ReadOnlySpan`1<byte> value);
    public static __byte_3 op_Implicit(ReadOnlySpan`1<byte> value);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.BOOL : ValueType {
    internal int Value;
    internal BOOL(int value);
    internal BOOL(bool value);
    public static int op_Implicit(BOOL value);
    public static BOOL op_Explicit(int value);
    public static bool op_Equality(BOOL left, BOOL right);
    public static bool op_Inequality(BOOL left, BOOL right);
    public sealed virtual bool Equals(BOOL other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Implicit(BOOL value);
    public static BOOL op_Implicit(bool value);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.BOOLEAN : ValueType {
    internal byte Value;
    internal BOOLEAN(byte value);
    internal BOOLEAN(bool value);
    public static byte op_Implicit(BOOLEAN value);
    public static BOOLEAN op_Explicit(byte value);
    public static bool op_Equality(BOOLEAN left, BOOLEAN right);
    public static bool op_Inequality(BOOLEAN left, BOOLEAN right);
    public sealed virtual bool Equals(BOOLEAN other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Implicit(BOOLEAN value);
    public static BOOLEAN op_Implicit(bool value);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.HANDLE : ValueType {
    internal IntPtr Value;
    internal static HANDLE Null { get; }
    internal bool IsNull { get; }
    internal HANDLE(IntPtr value);
    internal static HANDLE get_Null();
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HANDLE value);
    public static HANDLE op_Explicit(IntPtr value);
    public static bool op_Equality(HANDLE left, HANDLE right);
    public static bool op_Inequality(HANDLE left, HANDLE right);
    public sealed virtual bool Equals(HANDLE other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.HWND : ValueType {
    internal IntPtr Value;
    internal static HWND Null { get; }
    internal bool IsNull { get; }
    internal HWND(IntPtr value);
    internal static HWND get_Null();
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HWND value);
    public static HWND op_Explicit(IntPtr value);
    public static bool op_Equality(HWND left, HWND right);
    public static bool op_Inequality(HWND left, HWND right);
    public sealed virtual bool Equals(HWND other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static HANDLE op_Implicit(HWND value);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class Windows.Win32.Foundation.PCWSTR : ValueType {
    internal Char* Value;
    internal int Length { get; }
    private string DebuggerDisplay { get; }
    internal PCWSTR(Char* value);
    public static Char* op_Explicit(PCWSTR value);
    public static PCWSTR op_Implicit(Char* value);
    public sealed virtual bool Equals(PCWSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Length();
    public virtual string ToString();
    internal ReadOnlySpan`1<char> AsSpan();
    private string get_DebuggerDisplay();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.PSID : ValueType {
    internal Void* Value;
    internal PSID(Void* value);
    public static Void* op_Implicit(PSID value);
    public static PSID op_Explicit(Void* value);
    public static bool op_Equality(PSID left, PSID right);
    public static bool op_Inequality(PSID left, PSID right);
    public sealed virtual bool Equals(PSID other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.PWSTR : ValueType {
    internal Char* Value;
    internal int Length { get; }
    private string DebuggerDisplay { get; }
    internal PWSTR(Char* value);
    public static Char* op_Implicit(PWSTR value);
    public static PWSTR op_Implicit(Char* value);
    public static bool op_Equality(PWSTR left, PWSTR right);
    public static bool op_Inequality(PWSTR left, PWSTR right);
    public sealed virtual bool Equals(PWSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static PCWSTR op_Implicit(PWSTR value);
    internal int get_Length();
    internal Span`1<char> AsSpan();
    private string get_DebuggerDisplay();
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.RECT : ValueType {
    internal int left;
    internal int top;
    internal int right;
    internal int bottom;
    internal int Width { get; }
    internal int Height { get; }
    internal bool IsEmpty { get; }
    internal int X { get; }
    internal int Y { get; }
    internal Size Size { get; }
    internal RECT(Rectangle value);
    internal RECT(Point location, Size size);
    internal RECT(int left, int top, int right, int bottom);
    internal static RECT FromXYWH(int x, int y, int width, int height);
    [IsReadOnlyAttribute]
internal int get_Width();
    [IsReadOnlyAttribute]
internal int get_Height();
    [IsReadOnlyAttribute]
internal bool get_IsEmpty();
    [IsReadOnlyAttribute]
internal int get_X();
    [IsReadOnlyAttribute]
internal int get_Y();
    [IsReadOnlyAttribute]
internal Size get_Size();
    public static Rectangle op_Implicit(RECT value);
    public static RectangleF op_Implicit(RECT value);
    public static RECT op_Implicit(Rectangle value);
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Graphics.Gdi.GET_DEVICE_CAPS_INDEX : Enum {
    public UInt32 value__;
    public static GET_DEVICE_CAPS_INDEX DRIVERVERSION;
    public static GET_DEVICE_CAPS_INDEX TECHNOLOGY;
    public static GET_DEVICE_CAPS_INDEX HORZSIZE;
    public static GET_DEVICE_CAPS_INDEX VERTSIZE;
    public static GET_DEVICE_CAPS_INDEX HORZRES;
    public static GET_DEVICE_CAPS_INDEX VERTRES;
    public static GET_DEVICE_CAPS_INDEX BITSPIXEL;
    public static GET_DEVICE_CAPS_INDEX PLANES;
    public static GET_DEVICE_CAPS_INDEX NUMBRUSHES;
    public static GET_DEVICE_CAPS_INDEX NUMPENS;
    public static GET_DEVICE_CAPS_INDEX NUMMARKERS;
    public static GET_DEVICE_CAPS_INDEX NUMFONTS;
    public static GET_DEVICE_CAPS_INDEX NUMCOLORS;
    public static GET_DEVICE_CAPS_INDEX PDEVICESIZE;
    public static GET_DEVICE_CAPS_INDEX CURVECAPS;
    public static GET_DEVICE_CAPS_INDEX LINECAPS;
    public static GET_DEVICE_CAPS_INDEX POLYGONALCAPS;
    public static GET_DEVICE_CAPS_INDEX TEXTCAPS;
    public static GET_DEVICE_CAPS_INDEX CLIPCAPS;
    public static GET_DEVICE_CAPS_INDEX RASTERCAPS;
    public static GET_DEVICE_CAPS_INDEX ASPECTX;
    public static GET_DEVICE_CAPS_INDEX ASPECTY;
    public static GET_DEVICE_CAPS_INDEX ASPECTXY;
    public static GET_DEVICE_CAPS_INDEX LOGPIXELSX;
    public static GET_DEVICE_CAPS_INDEX LOGPIXELSY;
    public static GET_DEVICE_CAPS_INDEX SIZEPALETTE;
    public static GET_DEVICE_CAPS_INDEX NUMRESERVED;
    public static GET_DEVICE_CAPS_INDEX COLORRES;
    public static GET_DEVICE_CAPS_INDEX PHYSICALWIDTH;
    public static GET_DEVICE_CAPS_INDEX PHYSICALHEIGHT;
    public static GET_DEVICE_CAPS_INDEX PHYSICALOFFSETX;
    public static GET_DEVICE_CAPS_INDEX PHYSICALOFFSETY;
    public static GET_DEVICE_CAPS_INDEX SCALINGFACTORX;
    public static GET_DEVICE_CAPS_INDEX SCALINGFACTORY;
    public static GET_DEVICE_CAPS_INDEX VREFRESH;
    public static GET_DEVICE_CAPS_INDEX DESKTOPVERTRES;
    public static GET_DEVICE_CAPS_INDEX DESKTOPHORZRES;
    public static GET_DEVICE_CAPS_INDEX BLTALIGNMENT;
    public static GET_DEVICE_CAPS_INDEX SHADEBLENDCAPS;
    public static GET_DEVICE_CAPS_INDEX COLORMGMTCAPS;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Graphics.Gdi.HDC : ValueType {
    internal IntPtr Value;
    internal HDC(IntPtr value);
    public static IntPtr op_Implicit(HDC value);
    public static HDC op_Explicit(IntPtr value);
    public static bool op_Equality(HDC left, HDC right);
    public static bool op_Inequality(HDC left, HDC right);
    public sealed virtual bool Equals(HDC other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal static class Windows.Win32.InlineArrayIndexerExtensions : object {
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> SliceAtNull(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
internal static Byte& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__byte_3& this, int index);
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal static class Windows.Win32.PInvoke : object {
    internal static UInt32 FILE_FILE_COMPRESSION;
    internal static UInt32 FSCTL_SET_COMPRESSION;
    internal static UInt32 MAX_PATH;
    internal static int SECURITY_MANDATORY_MEDIUM_RID;
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.1.2600")]
internal static UInt32* GetSidSubAuthority(PSID pSid, UInt32 nSubAuthority);
    [SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL GetTokenInformation(SafeHandle TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, Void* TokenInformation, UInt32 TokenInformationLength, UInt32& ReturnLength);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, Void* TokenInformation, UInt32 TokenInformationLength, UInt32* ReturnLength);
    [SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL OpenProcessToken(SafeHandle ProcessHandle, TOKEN_ACCESS_MASK DesiredAccess, SafeFileHandle& TokenHandle);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL OpenProcessToken(HANDLE ProcessHandle, TOKEN_ACCESS_MASK DesiredAccess, HANDLE* TokenHandle);
    [SupportedOSPlatformAttribute("windows5.0")]
internal static int GetDeviceCaps(HDC hdc, GET_DEVICE_CAPS_INDEX index);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.0")]
internal static BOOL CloseHandle(HANDLE hObject);
    [SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL DeviceIoControl(SafeHandle hDevice, UInt32 dwIoControlCode, Void* lpInBuffer, UInt32 nInBufferSize, Void* lpOutBuffer, UInt32 nOutBufferSize, UInt32* lpBytesReturned, NativeOverlapped* lpOverlapped);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL DeviceIoControl(HANDLE hDevice, UInt32 dwIoControlCode, Void* lpInBuffer, UInt32 nInBufferSize, Void* lpOutBuffer, UInt32 nOutBufferSize, UInt32* lpBytesReturned, NativeOverlapped* lpOverlapped);
    [SupportedOSPlatformAttribute("windows5.1.2600")]
internal static SafeFileHandle GetCurrentThread_SafeHandle();
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.1.2600")]
internal static HANDLE GetCurrentThread();
    [SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL GetDiskFreeSpace(string lpRootPathName, UInt32* lpSectorsPerCluster, UInt32* lpBytesPerSector, UInt32* lpNumberOfFreeClusters, UInt32* lpTotalNumberOfClusters);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL GetDiskFreeSpace(PCWSTR lpRootPathName, UInt32* lpSectorsPerCluster, UInt32* lpBytesPerSector, UInt32* lpNumberOfFreeClusters, UInt32* lpTotalNumberOfClusters);
    [SupportedOSPlatformAttribute("windows6.0.6000")]
internal static BOOL GetFileInformationByHandleEx(SafeHandle hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows6.0.6000")]
internal static BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
    [SupportedOSPlatformAttribute("windows6.0.6000")]
internal static BOOL GetNamedPipeClientProcessId(SafeHandle Pipe, UInt32& ClientProcessId);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows6.0.6000")]
internal static BOOL GetNamedPipeClientProcessId(HANDLE Pipe, UInt32* ClientProcessId);
    [SupportedOSPlatformAttribute("windows5.0")]
internal static int GetPrivateProfileInt(string lpAppName, string lpKeyName, int nDefault, string lpFileName);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.0")]
internal static int GetPrivateProfileInt(PCWSTR lpAppName, PCWSTR lpKeyName, int nDefault, PCWSTR lpFileName);
    [SupportedOSPlatformAttribute("windows5.0")]
internal static UInt32 GetPrivateProfileString(string lpAppName, string lpKeyName, string lpDefault, PWSTR lpReturnedString, UInt32 nSize, string lpFileName);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.0")]
internal static UInt32 GetPrivateProfileString(PCWSTR lpAppName, PCWSTR lpKeyName, PCWSTR lpDefault, PWSTR lpReturnedString, UInt32 nSize, PCWSTR lpFileName);
    [SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL GetVolumeInformation(string lpRootPathName, PWSTR lpVolumeNameBuffer, UInt32 nVolumeNameSize, UInt32* lpVolumeSerialNumber, UInt32* lpMaximumComponentLength, UInt32* lpFileSystemFlags, PWSTR lpFileSystemNameBuffer, UInt32 nFileSystemNameSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL GetVolumeInformation(PCWSTR lpRootPathName, PWSTR lpVolumeNameBuffer, UInt32 nVolumeNameSize, UInt32* lpVolumeSerialNumber, UInt32* lpMaximumComponentLength, UInt32* lpFileSystemFlags, PWSTR lpFileSystemNameBuffer, UInt32 nFileSystemNameSize);
    [SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL SetThreadPriority(SafeHandle hThread, THREAD_PRIORITY nPriority);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.1.2600")]
internal static BOOL SetThreadPriority(HANDLE hThread, THREAD_PRIORITY nPriority);
    [SupportedOSPlatformAttribute("windows5.0")]
internal static BOOL WritePrivateProfileString(string lpAppName, string lpKeyName, string lpString, string lpFileName);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.0")]
internal static BOOL WritePrivateProfileString(PCWSTR lpAppName, PCWSTR lpKeyName, PCWSTR lpString, PCWSTR lpFileName);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.0")]
internal static BOOL DestroyIcon(HICON hIcon);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.0")]
internal static HDC GetDC(HWND hWnd);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.0")]
internal static HWND GetFocus();
    [SupportedOSPlatformAttribute("windows5.0")]
internal static BOOL GetWindowInfo(HWND hwnd, WINDOWINFO& pwi);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.0")]
internal static BOOL GetWindowInfo(HWND hwnd, WINDOWINFO* pwi);
    [SupportedOSPlatformAttribute("windows5.0")]
internal static BOOL GetWindowRect(HWND hWnd, RECT& lpRect);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.0")]
internal static BOOL GetWindowRect(HWND hWnd, RECT* lpRect);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.0")]
internal static int ReleaseDC(HWND hWnd, HDC hDC);
    [DefaultDllImportSearchPathsAttribute("2048")]
[SupportedOSPlatformAttribute("windows5.0")]
internal static HWND SetFocus(HWND hWnd);
    [CompilerGeneratedAttribute]
internal static int <GetDeviceCaps>g__LocalExternFunction|9_0(HDC hdc, GET_DEVICE_CAPS_INDEX index);
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Security.SID_AND_ATTRIBUTES : ValueType {
    internal PSID Sid;
    internal UInt32 Attributes;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Security.TOKEN_ACCESS_MASK : Enum {
    public UInt32 value__;
    public static TOKEN_ACCESS_MASK TOKEN_DELETE;
    public static TOKEN_ACCESS_MASK TOKEN_READ_CONTROL;
    public static TOKEN_ACCESS_MASK TOKEN_WRITE_DAC;
    public static TOKEN_ACCESS_MASK TOKEN_WRITE_OWNER;
    public static TOKEN_ACCESS_MASK TOKEN_ACCESS_SYSTEM_SECURITY;
    public static TOKEN_ACCESS_MASK TOKEN_ASSIGN_PRIMARY;
    public static TOKEN_ACCESS_MASK TOKEN_DUPLICATE;
    public static TOKEN_ACCESS_MASK TOKEN_IMPERSONATE;
    public static TOKEN_ACCESS_MASK TOKEN_QUERY;
    public static TOKEN_ACCESS_MASK TOKEN_QUERY_SOURCE;
    public static TOKEN_ACCESS_MASK TOKEN_ADJUST_PRIVILEGES;
    public static TOKEN_ACCESS_MASK TOKEN_ADJUST_GROUPS;
    public static TOKEN_ACCESS_MASK TOKEN_ADJUST_DEFAULT;
    public static TOKEN_ACCESS_MASK TOKEN_ADJUST_SESSIONID;
    public static TOKEN_ACCESS_MASK TOKEN_READ;
    public static TOKEN_ACCESS_MASK TOKEN_WRITE;
    public static TOKEN_ACCESS_MASK TOKEN_EXECUTE;
    public static TOKEN_ACCESS_MASK TOKEN_TRUST_CONSTRAINT_MASK;
    public static TOKEN_ACCESS_MASK TOKEN_ACCESS_PSEUDO_HANDLE_WIN8;
    public static TOKEN_ACCESS_MASK TOKEN_ACCESS_PSEUDO_HANDLE;
    public static TOKEN_ACCESS_MASK TOKEN_ALL_ACCESS;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Security.TOKEN_INFORMATION_CLASS : Enum {
    public int value__;
    public static TOKEN_INFORMATION_CLASS TokenUser;
    public static TOKEN_INFORMATION_CLASS TokenGroups;
    public static TOKEN_INFORMATION_CLASS TokenPrivileges;
    public static TOKEN_INFORMATION_CLASS TokenOwner;
    public static TOKEN_INFORMATION_CLASS TokenPrimaryGroup;
    public static TOKEN_INFORMATION_CLASS TokenDefaultDacl;
    public static TOKEN_INFORMATION_CLASS TokenSource;
    public static TOKEN_INFORMATION_CLASS TokenType;
    public static TOKEN_INFORMATION_CLASS TokenImpersonationLevel;
    public static TOKEN_INFORMATION_CLASS TokenStatistics;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedSids;
    public static TOKEN_INFORMATION_CLASS TokenSessionId;
    public static TOKEN_INFORMATION_CLASS TokenGroupsAndPrivileges;
    public static TOKEN_INFORMATION_CLASS TokenSessionReference;
    public static TOKEN_INFORMATION_CLASS TokenSandBoxInert;
    public static TOKEN_INFORMATION_CLASS TokenAuditPolicy;
    public static TOKEN_INFORMATION_CLASS TokenOrigin;
    public static TOKEN_INFORMATION_CLASS TokenElevationType;
    public static TOKEN_INFORMATION_CLASS TokenLinkedToken;
    public static TOKEN_INFORMATION_CLASS TokenElevation;
    public static TOKEN_INFORMATION_CLASS TokenHasRestrictions;
    public static TOKEN_INFORMATION_CLASS TokenAccessInformation;
    public static TOKEN_INFORMATION_CLASS TokenVirtualizationAllowed;
    public static TOKEN_INFORMATION_CLASS TokenVirtualizationEnabled;
    public static TOKEN_INFORMATION_CLASS TokenIntegrityLevel;
    public static TOKEN_INFORMATION_CLASS TokenUIAccess;
    public static TOKEN_INFORMATION_CLASS TokenMandatoryPolicy;
    public static TOKEN_INFORMATION_CLASS TokenLogonSid;
    public static TOKEN_INFORMATION_CLASS TokenIsAppContainer;
    public static TOKEN_INFORMATION_CLASS TokenCapabilities;
    public static TOKEN_INFORMATION_CLASS TokenAppContainerSid;
    public static TOKEN_INFORMATION_CLASS TokenAppContainerNumber;
    public static TOKEN_INFORMATION_CLASS TokenUserClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenDeviceClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedUserClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedDeviceClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenDeviceGroups;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedDeviceGroups;
    public static TOKEN_INFORMATION_CLASS TokenSecurityAttributes;
    public static TOKEN_INFORMATION_CLASS TokenIsRestricted;
    public static TOKEN_INFORMATION_CLASS TokenProcessTrustLevel;
    public static TOKEN_INFORMATION_CLASS TokenPrivateNameSpace;
    public static TOKEN_INFORMATION_CLASS TokenSingletonAttributes;
    public static TOKEN_INFORMATION_CLASS TokenBnoIsolation;
    public static TOKEN_INFORMATION_CLASS TokenChildProcessFlags;
    public static TOKEN_INFORMATION_CLASS TokenIsLessPrivilegedAppContainer;
    public static TOKEN_INFORMATION_CLASS TokenIsSandboxed;
    public static TOKEN_INFORMATION_CLASS TokenIsAppSilo;
    public static TOKEN_INFORMATION_CLASS MaxTokenInfoClass;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Security.TOKEN_MANDATORY_LABEL : ValueType {
    internal SID_AND_ATTRIBUTES Label;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Storage.FileSystem.COMPRESSION_FORMAT : Enum {
    public ushort value__;
    public static COMPRESSION_FORMAT COMPRESSION_FORMAT_NONE;
    public static COMPRESSION_FORMAT COMPRESSION_FORMAT_DEFAULT;
    public static COMPRESSION_FORMAT COMPRESSION_FORMAT_LZNT1;
    public static COMPRESSION_FORMAT COMPRESSION_FORMAT_XPRESS;
    public static COMPRESSION_FORMAT COMPRESSION_FORMAT_XPRESS_HUFF;
    public static COMPRESSION_FORMAT COMPRESSION_FORMAT_XP10;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Storage.FileSystem.FILE_COMPRESSION_INFO : ValueType {
    internal long CompressedFileSize;
    internal COMPRESSION_FORMAT CompressionFormat;
    internal byte CompressionUnitShift;
    internal byte ChunkShift;
    internal byte ClusterShift;
    internal __byte_3 Reserved;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS : Enum {
    public int value__;
    public static FILE_INFO_BY_HANDLE_CLASS FileBasicInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStandardInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileNameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileRenameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileDispositionInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAllocationInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileEndOfFileInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStreamInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileCompressionInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAttributeTagInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdBothDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdBothDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIoPriorityHintInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileRemoteProtocolInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileFullDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileFullDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStorageInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAlignmentInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdExtdDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdExtdDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileDispositionInfoEx;
    public static FILE_INFO_BY_HANDLE_CLASS FileRenameInfoEx;
    public static FILE_INFO_BY_HANDLE_CLASS FileCaseSensitiveInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileNormalizedNameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS MaximumFileInfoByHandleClass;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Storage.FileSystem.FILE_STANDARD_INFO : ValueType {
    internal long AllocationSize;
    internal long EndOfFile;
    internal UInt32 NumberOfLinks;
    internal BOOLEAN DeletePending;
    internal BOOLEAN Directory;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.System.Threading.THREAD_PRIORITY : Enum {
    public int value__;
    public static THREAD_PRIORITY THREAD_MODE_BACKGROUND_BEGIN;
    public static THREAD_PRIORITY THREAD_MODE_BACKGROUND_END;
    public static THREAD_PRIORITY THREAD_PRIORITY_ABOVE_NORMAL;
    public static THREAD_PRIORITY THREAD_PRIORITY_BELOW_NORMAL;
    public static THREAD_PRIORITY THREAD_PRIORITY_HIGHEST;
    public static THREAD_PRIORITY THREAD_PRIORITY_IDLE;
    public static THREAD_PRIORITY THREAD_PRIORITY_MIN;
    public static THREAD_PRIORITY THREAD_PRIORITY_LOWEST;
    public static THREAD_PRIORITY THREAD_PRIORITY_NORMAL;
    public static THREAD_PRIORITY THREAD_PRIORITY_TIME_CRITICAL;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.UI.WindowsAndMessaging.HICON : ValueType {
    internal IntPtr Value;
    internal static HICON Null { get; }
    internal bool IsNull { get; }
    internal HICON(IntPtr value);
    internal static HICON get_Null();
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HICON value);
    public static HICON op_Explicit(IntPtr value);
    public static bool op_Equality(HICON left, HICON right);
    public static bool op_Inequality(HICON left, HICON right);
    public sealed virtual bool Equals(HICON other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE : Enum {
    public UInt32 value__;
    public static WINDOW_EX_STYLE WS_EX_DLGMODALFRAME;
    public static WINDOW_EX_STYLE WS_EX_NOPARENTNOTIFY;
    public static WINDOW_EX_STYLE WS_EX_TOPMOST;
    public static WINDOW_EX_STYLE WS_EX_ACCEPTFILES;
    public static WINDOW_EX_STYLE WS_EX_TRANSPARENT;
    public static WINDOW_EX_STYLE WS_EX_MDICHILD;
    public static WINDOW_EX_STYLE WS_EX_TOOLWINDOW;
    public static WINDOW_EX_STYLE WS_EX_WINDOWEDGE;
    public static WINDOW_EX_STYLE WS_EX_CLIENTEDGE;
    public static WINDOW_EX_STYLE WS_EX_CONTEXTHELP;
    public static WINDOW_EX_STYLE WS_EX_RIGHT;
    public static WINDOW_EX_STYLE WS_EX_LEFT;
    public static WINDOW_EX_STYLE WS_EX_RTLREADING;
    public static WINDOW_EX_STYLE WS_EX_LTRREADING;
    public static WINDOW_EX_STYLE WS_EX_LEFTSCROLLBAR;
    public static WINDOW_EX_STYLE WS_EX_RIGHTSCROLLBAR;
    public static WINDOW_EX_STYLE WS_EX_CONTROLPARENT;
    public static WINDOW_EX_STYLE WS_EX_STATICEDGE;
    public static WINDOW_EX_STYLE WS_EX_APPWINDOW;
    public static WINDOW_EX_STYLE WS_EX_OVERLAPPEDWINDOW;
    public static WINDOW_EX_STYLE WS_EX_PALETTEWINDOW;
    public static WINDOW_EX_STYLE WS_EX_LAYERED;
    public static WINDOW_EX_STYLE WS_EX_NOINHERITLAYOUT;
    public static WINDOW_EX_STYLE WS_EX_NOREDIRECTIONBITMAP;
    public static WINDOW_EX_STYLE WS_EX_LAYOUTRTL;
    public static WINDOW_EX_STYLE WS_EX_COMPOSITED;
    public static WINDOW_EX_STYLE WS_EX_NOACTIVATE;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE : Enum {
    public UInt32 value__;
    public static WINDOW_STYLE WS_OVERLAPPED;
    public static WINDOW_STYLE WS_POPUP;
    public static WINDOW_STYLE WS_CHILD;
    public static WINDOW_STYLE WS_MINIMIZE;
    public static WINDOW_STYLE WS_VISIBLE;
    public static WINDOW_STYLE WS_DISABLED;
    public static WINDOW_STYLE WS_CLIPSIBLINGS;
    public static WINDOW_STYLE WS_CLIPCHILDREN;
    public static WINDOW_STYLE WS_MAXIMIZE;
    public static WINDOW_STYLE WS_CAPTION;
    public static WINDOW_STYLE WS_BORDER;
    public static WINDOW_STYLE WS_DLGFRAME;
    public static WINDOW_STYLE WS_VSCROLL;
    public static WINDOW_STYLE WS_HSCROLL;
    public static WINDOW_STYLE WS_SYSMENU;
    public static WINDOW_STYLE WS_THICKFRAME;
    public static WINDOW_STYLE WS_GROUP;
    public static WINDOW_STYLE WS_TABSTOP;
    public static WINDOW_STYLE WS_MINIMIZEBOX;
    public static WINDOW_STYLE WS_MAXIMIZEBOX;
    public static WINDOW_STYLE WS_TILED;
    public static WINDOW_STYLE WS_ICONIC;
    public static WINDOW_STYLE WS_SIZEBOX;
    public static WINDOW_STYLE WS_TILEDWINDOW;
    public static WINDOW_STYLE WS_OVERLAPPEDWINDOW;
    public static WINDOW_STYLE WS_POPUPWINDOW;
    public static WINDOW_STYLE WS_CHILDWINDOW;
    public static WINDOW_STYLE WS_ACTIVECAPTION;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.UI.WindowsAndMessaging.WINDOWINFO : ValueType {
    internal UInt32 cbSize;
    internal RECT rcWindow;
    internal RECT rcClient;
    internal WINDOW_STYLE dwStyle;
    internal WINDOW_EX_STYLE dwExStyle;
    internal UInt32 dwWindowStatus;
    internal UInt32 cxWindowBorders;
    internal UInt32 cyWindowBorders;
    internal ushort atomWindowType;
    internal ushort wCreatorVersion;
}
