public class Microsoft.Web.LibraryManager.Cache.CacheFileMetadata : object {
    [CompilerGeneratedAttribute]
private string <DestinationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public string DestinationPath { get; private set; }
    public string Source { get; private set; }
    public CacheFileMetadata(string source, string cacheFile);
    [CompilerGeneratedAttribute]
public string get_DestinationPath();
    [CompilerGeneratedAttribute]
private void set_DestinationPath(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(string value);
    public sealed virtual bool Equals(CacheFileMetadata other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.Web.LibraryManager.Cache.CacheService : object {
    private static int DefaultCacheExpiresAfterDays;
    private static int MaxConcurrentDownloads;
    private IWebRequestHandler _requestHandler;
    private static string CacheFolderValue;
    public static string CacheFolder { get; }
    public CacheService(IWebRequestHandler requestHandler);
    public static string get_CacheFolder();
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Cache.CacheService/<DownloadToFileAsync>d__7")]
private Task DownloadToFileAsync(string url, string fileName, int attempts, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Cache.CacheService/<GetResourceAsync>d__8")]
private Task`1<string> GetResourceAsync(string url, string localFile, int expiration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Cache.CacheService/<RefreshCacheAsync>d__9")]
public Task RefreshCacheAsync(IEnumerable`1<CacheFileMetadata> librariesCacheMetadata, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Cache.CacheService/<GetContentsFromUriWithCacheFallbackAsync>d__10")]
public sealed virtual Task`1<string> GetContentsFromUriWithCacheFallbackAsync(string url, string cacheFile, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Cache.CacheService/<GetContentsFromCachedFileWithWebRequestFallbackAsync>d__11")]
public sealed virtual Task`1<string> GetContentsFromCachedFileWithWebRequestFallbackAsync(string cacheFile, string url, CancellationToken cancellationToken);
}
internal class Microsoft.Web.LibraryManager.Cache.WebRequestHandler : object {
    private ConcurrentDictionary`2<string, HttpClient> _cachedHttpClients;
    [CompilerGeneratedAttribute]
private static IWebRequestHandler <Instance>k__BackingField;
    private ProxySettings _proxySettings;
    public static IWebRequestHandler Instance { get; }
    public WebRequestHandler(ProxySettings proxySettings);
    private static WebRequestHandler();
    [CompilerGeneratedAttribute]
public static IWebRequestHandler get_Instance();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Cache.WebRequestHandler/<GetStreamAsync>d__7")]
public sealed virtual Task`1<Stream> GetStreamAsync(string url, CancellationToken cancellationToken);
    private HttpClient CreateHttpClient(string url);
    [CompilerGeneratedAttribute]
private HttpClient <GetStreamAsync>b__7_0(string host);
}
internal class Microsoft.Web.LibraryManager.Configuration.Constants : object {
    public static string HttpProxy;
    public static string HttpProxyUser;
    public static string HttpProxyPassword;
    public static string HttpProxyBypass;
    public static string HttpsProxy;
    public static string HttpsProxyUser;
    public static string HttpsProxyPassword;
    public static string HttpsProxyBypass;
}
public class Microsoft.Web.LibraryManager.Configuration.ProxySettings : object {
    private ISettings _settings;
    private List`1<Uri> _bypassUris;
    public static ProxySettings Default { get; }
    public ProxySettings(ISettings settings);
    public static ProxySettings get_Default();
    public IWebProxy GetProxy(Uri uri);
    private bool CheckForProxyBypass(Uri uri);
    private IWebProxy GetUserConfiguredProxy();
    private IWebProxy TryConfigureProxy(string proxySettingName, string proxyUserSettingName, string proxyPasswordSettingName);
}
public class Microsoft.Web.LibraryManager.Configuration.Settings : object {
    private static string ConfigFileName;
    private JObject _rootObject;
    private JObject _configObject;
    [CompilerGeneratedAttribute]
private static Settings <DefaultSettings>k__BackingField;
    protected string ConfigFilePath { get; }
    public static Settings DefaultSettings { get; }
    public string UserDataRoot { get; }
    private static Settings();
    protected virtual string get_ConfigFilePath();
    [CompilerGeneratedAttribute]
public static Settings get_DefaultSettings();
    private void InitSettingsFile(string configFilePath);
    public sealed virtual string get_UserDataRoot();
    public sealed virtual bool TryGetValue(string settingName, String& value);
    public sealed virtual bool TryGetEncryptedValue(string settingName, String& value);
    public sealed virtual void SetValue(string settingName, string value);
    public sealed virtual void SetEncryptedValue(string settingName, string value);
    public sealed virtual void RemoveValue(string settingName);
    private static void SaveSettingsFile(string filePath, JToken token);
}
internal class Microsoft.Web.LibraryManager.FileConflict : object {
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ILibraryInstallationState> <Libraries>k__BackingField;
    public string File { get; }
    public IList`1<ILibraryInstallationState> Libraries { get; }
    public FileConflict(string file, List`1<ILibraryInstallationState> libraries);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public IList`1<ILibraryInstallationState> get_Libraries();
}
internal class Microsoft.Web.LibraryManager.FileIdentifier : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Path { get; }
    public string Version { get; }
    public FileIdentifier(string path, string version);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Version();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.Web.LibraryManager.Helpers.CancellationHelpers : object {
    [ExtensionAttribute]
public static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Microsoft.Web.LibraryManager.Helpers.Extensions : object {
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Helpers.Extensions/<IsValidAsync>d__0")]
[ExtensionAttribute]
public static Task`1<ILibraryOperationResult> IsValidAsync(ILibraryInstallationState state, IDependencies dependencies);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Helpers.Extensions/<IsValidAsync>d__1")]
[ExtensionAttribute]
public static Task`1<ILibraryOperationResult> IsValidAsync(ILibraryInstallationState state, IProvider provider);
    [ExtensionAttribute]
public static IReadOnlyList`1<string> GetInvalidFiles(ILibrary library, IReadOnlyList`1<string> files);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Helpers.Extensions/<GetJsonObjectViaGetAsync>d__3")]
[ExtensionAttribute]
public static Task`1<JObject> GetJsonObjectViaGetAsync(IWebRequestHandler webRequestHandler, string url, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GetJObjectMemberStringValue(JObject jObject, string propertyName, string defaultValue);
}
internal class Microsoft.Web.LibraryManager.Helpers.LibraryStateTypeConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class Microsoft.Web.LibraryManager.Json.LibraryInstallationStateOnDisk : object {
    [CompilerGeneratedAttribute]
private string <ProviderId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Files>k__BackingField;
    [JsonPropertyAttribute("provider")]
public string ProviderId { get; public set; }
    [JsonPropertyAttribute("library")]
public string LibraryId { get; public set; }
    [JsonPropertyAttribute("destination")]
public string DestinationPath { get; public set; }
    [JsonPropertyAttribute("files")]
public IReadOnlyList`1<string> Files { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProviderId();
    [CompilerGeneratedAttribute]
public void set_ProviderId(string value);
    [CompilerGeneratedAttribute]
public string get_LibraryId();
    [CompilerGeneratedAttribute]
public void set_LibraryId(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationPath();
    [CompilerGeneratedAttribute]
public void set_DestinationPath(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IReadOnlyList`1<string> value);
}
internal class Microsoft.Web.LibraryManager.Json.LibraryStateToFileConverter : object {
    private string _defaultProvider;
    private string _defaultDestination;
    public LibraryStateToFileConverter(string defaultProvider, string defaultDestination);
    public ILibraryInstallationState ConvertToLibraryInstallationState(LibraryInstallationStateOnDisk stateOnDisk);
    public LibraryInstallationStateOnDisk ConvertToLibraryInstallationStateOnDisk(ILibraryInstallationState state);
}
internal class Microsoft.Web.LibraryManager.Json.ManifestOnDisk : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultDestination>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryInstallationStateOnDisk> <Libraries>k__BackingField;
    [JsonPropertyAttribute("version")]
public string Version { get; public set; }
    [JsonPropertyAttribute("defaultProvider")]
public string DefaultProvider { get; public set; }
    [JsonPropertyAttribute("defaultDestination")]
public string DefaultDestination { get; public set; }
    [JsonPropertyAttribute("libraries")]
public IEnumerable`1<LibraryInstallationStateOnDisk> Libraries { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultProvider();
    [CompilerGeneratedAttribute]
public void set_DefaultProvider(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultDestination();
    [CompilerGeneratedAttribute]
public void set_DefaultDestination(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryInstallationStateOnDisk> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(IEnumerable`1<LibraryInstallationStateOnDisk> value);
}
internal class Microsoft.Web.LibraryManager.Json.ManifestToFileConverter : object {
    public Manifest ConvertToManifest(ManifestOnDisk manifestOnDisk, IDependencies dependencies);
    public ManifestOnDisk ConvertToManifestOnDisk(Manifest manifest);
}
internal static class Microsoft.Web.LibraryManager.LibrariesValidator : object {
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.LibrariesValidator/<GetLibrariesErrorsAsync>d__0")]
public static Task`1<IEnumerable`1<ILibraryOperationResult>> GetLibrariesErrorsAsync(IEnumerable`1<ILibraryInstallationState> libraries, IDependencies dependencies, string defaultDestination, string defaultProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.LibrariesValidator/<GetManifestErrorsAsync>d__1")]
public static Task`1<IEnumerable`1<ILibraryOperationResult>> GetManifestErrorsAsync(Manifest manifest, IDependencies dependencies, CancellationToken cancellationToken);
    private static bool IsValidManifestVersion(string version);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.LibrariesValidator/<ValidatePropertiesAsync>d__3")]
private static Task`1<IEnumerable`1<ILibraryOperationResult>> ValidatePropertiesAsync(IEnumerable`1<ILibraryInstallationState> libraries, IDependencies dependencies, CancellationToken cancellationToken);
    private static IEnumerable`1<ILibraryOperationResult> GetDuplicateLibrariesErrors(IEnumerable`1<ILibraryInstallationState> libraries);
    private static HashSet`1<string> GetDuplicateLibraries(IEnumerable`1<ILibraryInstallationState> libraries);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.LibrariesValidator/<ExpandLibrariesAsync>d__6")]
private static Task`1<IEnumerable`1<ILibraryOperationResult>> ExpandLibrariesAsync(IEnumerable`1<ILibraryInstallationState> libraries, IDependencies dependencies, string defaultDestination, string defaultProvider, CancellationToken cancellationToken);
    private static IEnumerable`1<FileConflict> GetFilesConflicts(IEnumerable`1<ILibraryInstallationState> libraries);
    private static ILibraryOperationResult GetConflictErrors(IEnumerable`1<FileConflict> fileConflicts);
}
internal class Microsoft.Web.LibraryManager.LibraryInstallationState : object {
    [CompilerGeneratedAttribute]
private string <ProviderId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUsingDefaultProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUsingDefaultDestination>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string ProviderId { get; public set; }
    public string DestinationPath { get; public set; }
    public IReadOnlyList`1<string> Files { get; public set; }
    public bool IsUsingDefaultProvider { get; public set; }
    public bool IsUsingDefaultDestination { get; public set; }
    public string Name { get; public set; }
    public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProviderId();
    [CompilerGeneratedAttribute]
public void set_ProviderId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DestinationPath();
    [CompilerGeneratedAttribute]
public void set_DestinationPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsUsingDefaultProvider();
    [CompilerGeneratedAttribute]
public void set_IsUsingDefaultProvider(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsUsingDefaultDestination();
    [CompilerGeneratedAttribute]
public void set_IsUsingDefaultDestination(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    public static LibraryInstallationState FromInterface(ILibraryInstallationState state, string defaultProviderId, string defaultDestination);
}
internal interface Microsoft.Web.LibraryManager.LibraryNaming.ILibraryNamingScheme {
    public abstract virtual bool IsValidLibraryId(string libraryId);
    public abstract virtual ValueTuple`2<string, string> GetLibraryNameAndVersion(string libraryId);
    public abstract virtual string GetLibraryId(string name, string version);
}
public class Microsoft.Web.LibraryManager.LibraryNaming.LibraryIdToNameAndVersionConverter : object {
    [CompilerGeneratedAttribute]
private static LibraryIdToNameAndVersionConverter <Instance>k__BackingField;
    private object _syncObject;
    private ILibraryNamingScheme _versionedNamingScheme;
    private ILibraryNamingScheme _simpleNamingScheme;
    private ILibraryNamingScheme _default;
    private IDependencies _dependencies;
    private Dictionary`2<string, ILibraryNamingScheme> _perProviderNamingScheme;
    private bool _isInitialized;
    public static LibraryIdToNameAndVersionConverter Instance { get; }
    private static LibraryIdToNameAndVersionConverter();
    [CompilerGeneratedAttribute]
public static LibraryIdToNameAndVersionConverter get_Instance();
    public void EnsureInitialized(IDependencies dependencies);
    internal void Reinitialize(IDependencies dependencies);
    public ValueTuple`2<string, string> GetLibraryNameAndVersion(string libraryId, string providerId);
    public string GetLibraryId(string name, string version, string providerId);
    public bool IsWellFormedLibraryId(string libraryId, string providerId);
    private ILibraryNamingScheme GetSchemeForProvider(string providerId);
}
internal class Microsoft.Web.LibraryManager.LibraryNaming.SimpleLibraryNamingScheme : object {
    public sealed virtual string GetLibraryId(string name, string version);
    public sealed virtual ValueTuple`2<string, string> GetLibraryNameAndVersion(string libraryId);
    public sealed virtual bool IsValidLibraryId(string libraryId);
}
internal class Microsoft.Web.LibraryManager.LibraryNaming.VersionedLibraryNamingScheme : object {
    private static char Separator;
    public sealed virtual ValueTuple`2<string, string> GetLibraryNameAndVersion(string libraryId);
    public sealed virtual string GetLibraryId(string name, string version);
    public sealed virtual bool IsValidLibraryId(string libraryId);
}
internal class Microsoft.Web.LibraryManager.LibraryOperationResult : object {
    [CompilerGeneratedAttribute]
private bool <Cancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpToDate>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IError> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private ILibraryInstallationState <InstallationState>k__BackingField;
    public bool Cancelled { get; public set; }
    public bool UpToDate { get; public set; }
    public bool Success { get; }
    public IList`1<IError> Errors { get; public set; }
    public ILibraryInstallationState InstallationState { get; public set; }
    public LibraryOperationResult(ILibraryInstallationState installationState);
    public LibraryOperationResult(ILibraryInstallationState installationState, IError[] error);
    public LibraryOperationResult(IError[] error);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Cancelled();
    [CompilerGeneratedAttribute]
public void set_Cancelled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UpToDate();
    [CompilerGeneratedAttribute]
public void set_UpToDate(bool value);
    public sealed virtual bool get_Success();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IError> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(IList`1<IError> value);
    [CompilerGeneratedAttribute]
public sealed virtual ILibraryInstallationState get_InstallationState();
    [CompilerGeneratedAttribute]
public void set_InstallationState(ILibraryInstallationState value);
    public static LibraryOperationResult FromSuccess(ILibraryInstallationState installationState);
    public static LibraryOperationResult FromCancelled(ILibraryInstallationState installationState);
    public static LibraryOperationResult FromError(IError error);
    public static ILibraryOperationResult FromUpToDate(ILibraryInstallationState installationState);
}
public static class Microsoft.Web.LibraryManager.Logging.LogMessageGenerator : object {
    public static string GetPartialSuccessString(OperationType operation, int successfulResults, int failedResults, int cancelledResults, int uptodateResults, TimeSpan timeSpan);
    public static string GetAllSuccessString(OperationType operation, int totalCount, TimeSpan timeSpan, string libraryId);
    public static string GetAllFailuresString(OperationType operation, int totalCount, string libraryId);
    public static string GetAllCancelledString(OperationType operation, int totalCount, TimeSpan timeSpan, string libraryId);
    public static string GetOperationHeaderString(OperationType operationType, string libraryId);
    public static string GetSummaryHeaderString(OperationType operationType);
    public static string GetErrorsHeaderString(OperationType operationType);
    public static string GetOperationSummaryString(IEnumerable`1<ILibraryOperationResult> results, OperationType operation, TimeSpan elapsedTime);
    private static string GetLibraryId(IEnumerable`1<ILibraryOperationResult> totalResults, OperationType operation);
}
public class Microsoft.Web.LibraryManager.Manifest : object {
    public static Version[] SupportedVersions;
    private IHostInteraction _hostInteraction;
    private List`1<ILibraryInstallationState> _libraries;
    private IDependencies _dependencies;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultDestination>k__BackingField;
    public string Version { get; public set; }
    public string DefaultProvider { get; public set; }
    public string DefaultDestination { get; public set; }
    public IEnumerable`1<ILibraryInstallationState> Libraries { get; }
    public Manifest(IDependencies dependencies);
    private static Manifest();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultProvider();
    [CompilerGeneratedAttribute]
public void set_DefaultProvider(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultDestination();
    [CompilerGeneratedAttribute]
public void set_DefaultDestination(string value);
    public IEnumerable`1<ILibraryInstallationState> get_Libraries();
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<FromFileAsync>d__19")]
public static Task`1<Manifest> FromFileAsync(string fileName, IDependencies dependencies, CancellationToken cancellationToken);
    internal static Manifest FromJson(string json, IDependencies dependencies);
    public static void UpdateLibraryVersion(ILibraryInstallationState libraryToUpdate, string newVersion);
    private static void UpdateLibraryProviderAndDestination(Manifest manifest);
    private static void UpdateLibraryProviderAndDestination(ILibraryInstallationState state, string defaultProvider, string defaultDestination);
    public Manifest Clone();
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<InstallLibraryAsync>d__25")]
public Task`1<IEnumerable`1<ILibraryOperationResult>> InstallLibraryAsync(string libraryName, string version, string providerId, IReadOnlyList`1<string> files, string destination, CancellationToken cancellationToken);
    private ILibraryInstallationState SetDefaultProviderIfNeeded(LibraryInstallationState desiredState);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<CheckLibraryForConflictsAsync>d__27")]
private Task`1<IEnumerable`1<ILibraryOperationResult>> CheckLibraryForConflictsAsync(ILibraryInstallationState desiredState, CancellationToken cancellationToken);
    internal void AddLibrary(ILibraryInstallationState state, bool setDefaultProvider);
    public void AddVersion(string version);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<RestoreAsync>d__30")]
public Task`1<IEnumerable`1<ILibraryOperationResult>> RestoreAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<GetValidationResultsAsync>d__31")]
public Task`1<IEnumerable`1<ILibraryOperationResult>> GetValidationResultsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<RestoreLibraryAsync>d__32")]
private Task`1<ILibraryOperationResult> RestoreLibraryAsync(ILibraryInstallationState libraryState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<UninstallAsync>d__33")]
public Task`1<ILibraryOperationResult> UninstallAsync(string libraryName, string version, Func`2<IEnumerable`1<string>, Task`1<bool>> deleteFilesFunction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<SaveAsync>d__34")]
public Task SaveAsync(string fileName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<CleanAsync>d__35")]
public Task`1<IEnumerable`1<ILibraryOperationResult>> CleanAsync(Func`2<IEnumerable`1<string>, Task`1<bool>> deleteFileAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<RemoveUnwantedFilesAsync>d__36")]
public Task`1<bool> RemoveUnwantedFilesAsync(Manifest newManifest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<GetAllManifestFilesWithVersionsAsync>d__37")]
private Task`1<IEnumerable`1<FileIdentifier>> GetAllManifestFilesWithVersionsAsync(IEnumerable`1<ILibraryInstallationState> libraries);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<GetFilesWithVersionsAsync>d__38")]
private Task`1<IEnumerable`1<FileIdentifier>> GetFilesWithVersionsAsync(ILibraryInstallationState state);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Manifest/<DeleteLibraryFilesAsync>d__39")]
private Task`1<ILibraryOperationResult> DeleteLibraryFilesAsync(ILibraryInstallationState state, Func`2<IEnumerable`1<string>, Task`1<bool>> deleteFilesFunction, CancellationToken cancellationToken);
}
public static class Microsoft.Web.LibraryManager.ManifestConstants : object {
    public static string Version;
    public static string Libraries;
    public static string Library;
    public static string Destination;
    public static string DefaultDestination;
    public static string Provider;
    public static string DefaultProvider;
    public static string Files;
}
internal abstract class Microsoft.Web.LibraryManager.Providers.BaseProvider : object {
    protected CacheService _cacheService;
    private string _cacheFolder;
    [CompilerGeneratedAttribute]
private IHostInteraction <HostInteraction>k__BackingField;
    [CompilerGeneratedAttribute]
private ILibraryNamingScheme <LibraryNamingScheme>k__BackingField;
    public string Id { get; }
    public string NuGetPackageId { get; }
    public string LibraryIdHintText { get; }
    public IHostInteraction HostInteraction { get; }
    public bool SupportsLibraryVersions { get; }
    protected ILibraryNamingScheme LibraryNamingScheme { get; }
    public string CacheFolder { get; }
    public BaseProvider(IHostInteraction hostInteraction, CacheService cacheService);
    public abstract virtual string get_Id();
    public virtual string get_NuGetPackageId();
    public abstract virtual string get_LibraryIdHintText();
    [CompilerGeneratedAttribute]
public sealed virtual IHostInteraction get_HostInteraction();
    public virtual bool get_SupportsLibraryVersions();
    public abstract virtual ILibraryCatalog GetCatalog();
    public abstract virtual string GetSuggestedDestination(ILibrary library);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.BaseProvider/<InstallAsync>d__16")]
public virtual Task`1<ILibraryOperationResult> InstallAsync(ILibraryInstallationState desiredState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.BaseProvider/<UpdateStateAsync>d__17")]
public virtual Task`1<ILibraryOperationResult> UpdateStateAsync(ILibraryInstallationState desiredState, CancellationToken cancellationToken);
    protected virtual ILibraryOperationResult CheckForInvalidFiles(ILibraryInstallationState desiredState, string libraryId, ILibrary library);
    [CompilerGeneratedAttribute]
protected virtual ILibraryNamingScheme get_LibraryNamingScheme();
    public string get_CacheFolder();
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.BaseProvider/<WriteToFilesAsync>d__24")]
protected Task`1<ILibraryOperationResult> WriteToFilesAsync(ILibraryInstallationState state, CancellationToken cancellationToken);
    private string GetCachedFileLocalPath(ILibraryInstallationState state, string sourceFile);
    private bool IsLibraryUpToDate(ILibraryInstallationState state);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.BaseProvider/<RefreshCacheAsync>d__27")]
private Task`1<ILibraryOperationResult> RefreshCacheAsync(ILibraryInstallationState state, CancellationToken cancellationToken);
    protected abstract virtual string GetDownloadUrl(ILibraryInstallationState state, string sourceFile);
}
internal class Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsCatalog : object {
    private static string FileName;
    public static string CatalogUrl;
    public static string MetaPackageUrlFormat;
    public static string PackageVersionUrlFormat;
    private string _cacheFile;
    private CdnjsProvider _provider;
    private ICacheService _cacheService;
    private ILibraryNamingScheme _libraryNamingScheme;
    private IEnumerable`1<CdnjsLibraryGroup> _libraryGroups;
    public CdnjsCatalog(CdnjsProvider provider, ICacheService cacheService, ILibraryNamingScheme libraryNamingScheme);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsCatalog/<GetLibraryCompletionSetAsync>d__10")]
public sealed virtual Task`1<CompletionSet> GetLibraryCompletionSetAsync(string value, int caretPosition);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsCatalog/<SearchAsync>d__11")]
public sealed virtual Task`1<IReadOnlyList`1<ILibraryGroup>> SearchAsync(string term, int maxHits, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsCatalog/<GetLibraryAsync>d__12")]
public sealed virtual Task`1<ILibrary> GetLibraryAsync(string libraryName, string version, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsCatalog/<GetLatestVersion>d__13")]
public sealed virtual Task`1<string> GetLatestVersion(string libraryName, bool includePreReleases, CancellationToken cancellationToken);
    private IEnumerable`1<CdnjsLibraryGroup> GetSortedSearchResult(string term);
    private static string NormalizedGroupName(string groupName);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsCatalog/<EnsureCatalogAsync>d__16")]
private Task`1<bool> EnsureCatalogAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsCatalog/<GetLibraryVersionsAsync>d__17")]
private Task`1<IEnumerable`1<string>> GetLibraryVersionsAsync(string groupName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsCatalog/<GetLibraryGroupMetadataAsync>d__18")]
private Task`1<JObject> GetLibraryGroupMetadataAsync(string groupName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsCatalog/<GetLibraryFilesAsync>d__19")]
private Task`1<IEnumerable`1<string>> GetLibraryFilesAsync(string libraryName, string version, CancellationToken cancellationToken);
    internal IEnumerable`1<CdnjsLibraryGroup> ConvertToLibraryGroups(string json);
}
internal class Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, bool> <Files>k__BackingField;
    public string Name { get; public set; }
    public string ProviderId { get; public set; }
    public string Version { get; public set; }
    public IReadOnlyDictionary`2<string, bool> Files { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProviderId();
    [CompilerGeneratedAttribute]
public void set_ProviderId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, bool> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IReadOnlyDictionary`2<string, bool> value);
    public virtual string ToString();
}
internal class Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsLibraryGroup : object {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task`1<IEnumerable`1<string>>> <DisplayInfosTask>k__BackingField;
    [JsonPropertyAttribute("name")]
public string DisplayName { get; public set; }
    [JsonPropertyAttribute("description")]
public string Description { get; public set; }
    [JsonPropertyAttribute("version")]
public string Version { get; public set; }
    public Func`2<CancellationToken, Task`1<IEnumerable`1<string>>> DisplayInfosTask { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    public sealed virtual Task`1<IEnumerable`1<string>> GetLibraryVersions(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, Task`1<IEnumerable`1<string>>> get_DisplayInfosTask();
    [CompilerGeneratedAttribute]
public void set_DisplayInfosTask(Func`2<CancellationToken, Task`1<IEnumerable`1<string>>> value);
    public virtual string ToString();
}
internal class Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsProvider : BaseProvider {
    private static string DownloadUrlFormat;
    public static string IdText;
    private CdnjsCatalog _catalog;
    public string Id { get; }
    public string LibraryIdHintText { get; }
    public CdnjsProvider(IHostInteraction hostInteraction, CacheService cacheService);
    public virtual string get_Id();
    public virtual string get_LibraryIdHintText();
    public virtual ILibraryCatalog GetCatalog();
    public virtual string GetSuggestedDestination(ILibrary library);
    protected virtual string GetDownloadUrl(ILibraryInstallationState state, string sourceFile);
}
internal class Microsoft.Web.LibraryManager.Providers.Cdnjs.CdnjsProviderFactory : object {
    public sealed virtual IProvider CreateProvider(IHostInteraction hostInteraction);
}
internal class Microsoft.Web.LibraryManager.Providers.FileSystem.FileSystemCatalog : object {
    private FileSystemProvider _provider;
    private bool _underTest;
    public FileSystemCatalog(FileSystemProvider provider, bool underTest);
    public sealed virtual Task`1<CompletionSet> GetLibraryCompletionSetAsync(string value, int caretPosition);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.FileSystem.FileSystemCatalog/<GetLibraryAsync>d__4")]
public sealed virtual Task`1<ILibrary> GetLibraryAsync(string libraryName, string version, CancellationToken cancellationToken);
    private Task`1<IReadOnlyDictionary`2<string, bool>> GetFilesAsync(string libraryId);
    public sealed virtual Task`1<IReadOnlyList`1<ILibraryGroup>> SearchAsync(string term, int maxHits, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> GetLatestVersion(string libraryId, bool includePreReleases, CancellationToken cancellationToken);
}
internal class Microsoft.Web.LibraryManager.Providers.FileSystem.FileSystemLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, bool> <Files>k__BackingField;
    public string Name { get; public set; }
    public string ProviderId { get; public set; }
    public string Version { get; }
    public IReadOnlyDictionary`2<string, bool> Files { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProviderId();
    [CompilerGeneratedAttribute]
public void set_ProviderId(string value);
    public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, bool> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IReadOnlyDictionary`2<string, bool> value);
    public virtual string ToString();
}
internal class Microsoft.Web.LibraryManager.Providers.FileSystem.FileSystemLibraryGroup : object {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    public string DisplayName { get; }
    public string Description { get; }
    public FileSystemLibraryGroup(string groupName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    public sealed virtual string get_Description();
    public sealed virtual Task`1<IEnumerable`1<string>> GetLibraryVersions(CancellationToken cancellationToken);
    public virtual string ToString();
}
internal class Microsoft.Web.LibraryManager.Providers.FileSystem.FileSystemProvider : BaseProvider {
    private FileSystemCatalog _catalog;
    [CompilerGeneratedAttribute]
private ILibraryNamingScheme <LibraryNamingScheme>k__BackingField;
    public string Id { get; }
    public string LibraryIdHintText { get; }
    public bool SupportsLibraryVersions { get; }
    protected ILibraryNamingScheme LibraryNamingScheme { get; }
    public FileSystemProvider(IHostInteraction hostInteraction);
    public virtual string get_Id();
    public virtual string get_LibraryIdHintText();
    public virtual bool get_SupportsLibraryVersions();
    public virtual ILibraryCatalog GetCatalog();
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.FileSystem.FileSystemProvider/<InstallAsync>d__9")]
public virtual Task`1<ILibraryOperationResult> InstallAsync(ILibraryInstallationState desiredState, CancellationToken cancellationToken);
    protected virtual ILibraryOperationResult CheckForInvalidFiles(ILibraryInstallationState desiredState, string libraryId, ILibrary library);
    public virtual string GetSuggestedDestination(ILibrary library);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.FileSystem.FileSystemProvider/<GetStreamAsync>d__12")]
private Task`1<Stream> GetStreamAsync(ILibraryInstallationState state, string file, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.FileSystem.FileSystemProvider/<GetRemoteResourceAsync>d__13")]
private static Task`1<Stream> GetRemoteResourceAsync(string sourceUrl);
    [CompilerGeneratedAttribute]
protected virtual ILibraryNamingScheme get_LibraryNamingScheme();
    protected virtual string GetDownloadUrl(ILibraryInstallationState state, string sourceFile);
}
internal class Microsoft.Web.LibraryManager.Providers.FileSystem.FileSystemProviderFactory : object {
    public sealed virtual IProvider CreateProvider(IHostInteraction hostInteraction);
}
internal class Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrCatalog : object {
    public static string CacheFileName;
    public static string LibraryFileListUrlFormat;
    public static string LatestLibraryVersionUrl;
    public static string LibraryFileListUrlFormatGH;
    public static string LatestLibraryVersionUrlGH;
    public static string LatestVersionTag;
    private INpmPackageInfoFactory _packageInfoFactory;
    private INpmPackageSearch _packageSearch;
    private string _providerId;
    private ILibraryNamingScheme _libraryNamingScheme;
    private ILogger _logger;
    private ICacheService _cacheService;
    private string _cacheFolder;
    public JsDelivrCatalog(string providerId, ILibraryNamingScheme namingScheme, ILogger logger, INpmPackageInfoFactory packageInfoFactory, INpmPackageSearch packageSearch, ICacheService cacheService, string cacheFolder);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrCatalog/<GetLatestVersion>d__14")]
public sealed virtual Task`1<string> GetLatestVersion(string libraryId, bool includePreReleases, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrCatalog/<GetLibraryAsync>d__15")]
public sealed virtual Task`1<ILibrary> GetLibraryAsync(string name, string version, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrCatalog/<GetLibraryFilesAsync>d__16")]
private Task`1<IEnumerable`1<string>> GetLibraryFilesAsync(string libraryId, CancellationToken cancellationToken);
    private void GetFiles(JObject fileObject, List`1<string> result);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrCatalog/<GetLibraryCompletionSetAsync>d__18")]
public sealed virtual Task`1<CompletionSet> GetLibraryCompletionSetAsync(string libraryNameStart, int caretPosition);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrCatalog/<SearchAsync>d__19")]
public sealed virtual Task`1<IReadOnlyList`1<ILibraryGroup>> SearchAsync(string term, int maxHits, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrCatalog/<GetGithubLibraryVersionsAsync>d__20")]
private Task`1<IEnumerable`1<string>> GetGithubLibraryVersionsAsync(string name, CancellationToken cancellationToken);
    public static bool IsGitHub(string libraryId);
    [CompilerGeneratedAttribute]
private JsDelivrLibraryGroup <SearchAsync>b__19_1(string packageName);
}
internal class Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, bool> <Files>k__BackingField;
    public string Name { get; public set; }
    public string ProviderId { get; public set; }
    public string Version { get; public set; }
    public IReadOnlyDictionary`2<string, bool> Files { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProviderId();
    [CompilerGeneratedAttribute]
public void set_ProviderId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, bool> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IReadOnlyDictionary`2<string, bool> value);
    public virtual string ToString();
}
internal class Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrLibraryGroup : object {
    private INpmPackageInfoFactory _infoCache;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string DisplayName { get; }
    public string Description { get; }
    public JsDelivrLibraryGroup(INpmPackageInfoFactory infoCache, string displayName, string description);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrLibraryGroup/<GetLibraryVersions>d__8")]
public sealed virtual Task`1<IEnumerable`1<string>> GetLibraryVersions(CancellationToken cancellationToken);
}
internal class Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrProvider : BaseProvider {
    private INpmPackageSearch _packageSearch;
    private INpmPackageInfoFactory _infoFactory;
    public static string IdText;
    public static string DownloadUrlFormat;
    public static string DownloadUrlFormatGH;
    private ILibraryCatalog _catalog;
    public string Id { get; }
    public string LibraryIdHintText { get; }
    public JsDelivrProvider(IHostInteraction hostInteraction, CacheService cacheService, INpmPackageSearch packageSearch, INpmPackageInfoFactory infoFactory);
    public virtual string get_Id();
    public virtual ILibraryCatalog GetCatalog();
    public virtual string get_LibraryIdHintText();
    public virtual string GetSuggestedDestination(ILibrary library);
    protected virtual string GetDownloadUrl(ILibraryInstallationState state, string sourceFile);
}
internal class Microsoft.Web.LibraryManager.Providers.jsDelivr.JsDelivrProviderFactory : object {
    private INpmPackageSearch _packageSearch;
    private INpmPackageInfoFactory _packageInfoFactory;
    public JsDelivrProviderFactory(INpmPackageSearch packageSearch, INpmPackageInfoFactory packageInfoFactory);
    public sealed virtual IProvider CreateProvider(IHostInteraction hostInteraction);
}
public interface Microsoft.Web.LibraryManager.Providers.Unpkg.INpmPackageInfoFactory {
    public abstract virtual Task`1<NpmPackageInfo> GetPackageInfoAsync(string packageName, CancellationToken cancellationToken);
}
public interface Microsoft.Web.LibraryManager.Providers.Unpkg.INpmPackageSearch {
    public abstract virtual Task`1<IEnumerable`1<NpmPackageInfo>> GetPackageNamesAsync(string searchTerm, CancellationToken cancellationToken);
}
public class Microsoft.Web.LibraryManager.Providers.Unpkg.NpmPackageInfo : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LatestVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SemanticVersion> <Versions>k__BackingField;
    public string Description { get; private set; }
    public string LatestVersion { get; private set; }
    public string Name { get; private set; }
    public IList`1<SemanticVersion> Versions { get; private set; }
    internal NpmPackageInfo(string name, string description, string latestVersion);
    internal NpmPackageInfo(string name, string description, string latestVersion, IList`1<SemanticVersion> versions);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_LatestVersion();
    [CompilerGeneratedAttribute]
private void set_LatestVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public IList`1<SemanticVersion> get_Versions();
    [CompilerGeneratedAttribute]
private void set_Versions(IList`1<SemanticVersion> value);
    internal static NpmPackageInfo Parse(JObject packageInfo);
}
internal class Microsoft.Web.LibraryManager.Providers.Unpkg.NpmPackageInfoFactory : object {
    public static string NpmPackageInfoUrl;
    public static string NpmLatestPackageInfoUrl;
    private Dictionary`2<string, NpmPackageInfo> _cachedPackages;
    private IWebRequestHandler _requestHandler;
    public NpmPackageInfoFactory(IWebRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.NpmPackageInfoFactory/<GetPackageInfoAsync>d__5")]
public sealed virtual Task`1<NpmPackageInfo> GetPackageInfoAsync(string packageName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.NpmPackageInfoFactory/<GetNewPackageInfoAsync>d__6")]
private Task`1<NpmPackageInfo> GetNewPackageInfoAsync(string packageName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.NpmPackageInfoFactory/<GetPackageInfoForScopedPackageAsync>d__7")]
private Task`1<NpmPackageInfo> GetPackageInfoForScopedPackageAsync(string packageName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.NpmPackageInfoFactory/<GetPackageInfoForUnscopedPackageAsync>d__8")]
private Task`1<NpmPackageInfo> GetPackageInfoForUnscopedPackageAsync(string packageName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.NpmPackageInfoFactory/<CreatePackageInfoAsync>d__9")]
private Task`1<NpmPackageInfo> CreatePackageInfoAsync(string packageName, NpmPackageInfo packageInfo, CancellationToken cancellationToken);
    private static IList`1<SemanticVersion> FilterOldPrereleaseVersions(List`1<SemanticVersion> semanticVersions);
}
internal class Microsoft.Web.LibraryManager.Providers.Unpkg.NpmPackageSearch : object {
    private static string NpmPackageSearchUrl;
    public static string NpmsPackageSearchUrl;
    private IWebRequestHandler _requestHandler;
    public NpmPackageSearch(IWebRequestHandler webRequestHandler);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.NpmPackageSearch/<GetPackageNamesAsync>d__4")]
public sealed virtual Task`1<IEnumerable`1<NpmPackageInfo>> GetPackageNamesAsync(string searchTerm, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.NpmPackageSearch/<GetPackageNamesWithScopeAsync>d__5")]
private Task`1<IEnumerable`1<NpmPackageInfo>> GetPackageNamesWithScopeAsync(string searchTerm, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.NpmPackageSearch/<GetPackageNamesFromSimpleQueryAsync>d__6")]
private Task`1<IEnumerable`1<NpmPackageInfo>> GetPackageNamesFromSimpleQueryAsync(string searchTerm, CancellationToken cancellationToken);
}
internal class Microsoft.Web.LibraryManager.Providers.Unpkg.UnpkgCatalog : object {
    public static string CacheFileName;
    public static string LibraryFileListUrlFormat;
    public static string LatestLibraryVersonUrl;
    public static string LatestVersionTag;
    private INpmPackageInfoFactory _packageInfoFactory;
    private INpmPackageSearch _packageSearch;
    private string _providerId;
    private ILibraryNamingScheme _libraryNamingScheme;
    private ILogger _logger;
    private ICacheService _cacheService;
    private string _cacheFolder;
    public UnpkgCatalog(string providerId, ILibraryNamingScheme namingScheme, ILogger logger, INpmPackageInfoFactory packageInfoFactory, INpmPackageSearch packageSearch, ICacheService cacheService, string cacheFolder);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.UnpkgCatalog/<GetLatestVersion>d__12")]
public sealed virtual Task`1<string> GetLatestVersion(string libraryName, bool includePreReleases, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.UnpkgCatalog/<GetLibraryAsync>d__13")]
public sealed virtual Task`1<ILibrary> GetLibraryAsync(string libraryName, string version, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.UnpkgCatalog/<GetLibraryFilesAsync>d__14")]
private Task`1<IEnumerable`1<string>> GetLibraryFilesAsync(string libraryName, string version, CancellationToken cancellationToken);
    private void GetFiles(JObject fileObject, List`1<string> files);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.UnpkgCatalog/<GetLibraryCompletionSetAsync>d__16")]
public sealed virtual Task`1<CompletionSet> GetLibraryCompletionSetAsync(string libraryNameStart, int caretPosition);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.UnpkgCatalog/<SearchAsync>d__17")]
public sealed virtual Task`1<IReadOnlyList`1<ILibraryGroup>> SearchAsync(string term, int maxHits, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private UnpkgLibraryGroup <SearchAsync>b__17_1(string packageName);
}
internal class Microsoft.Web.LibraryManager.Providers.Unpkg.UnpkgLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, bool> <Files>k__BackingField;
    public string Name { get; public set; }
    public string ProviderId { get; public set; }
    public string Version { get; public set; }
    public IReadOnlyDictionary`2<string, bool> Files { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProviderId();
    [CompilerGeneratedAttribute]
public void set_ProviderId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, bool> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IReadOnlyDictionary`2<string, bool> value);
    public virtual string ToString();
}
internal class Microsoft.Web.LibraryManager.Providers.Unpkg.UnpkgLibraryGroup : object {
    private INpmPackageInfoFactory _infoFactory;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string DisplayName { get; }
    public string Description { get; }
    public UnpkgLibraryGroup(INpmPackageInfoFactory infoFactory, string displayName, string description);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Providers.Unpkg.UnpkgLibraryGroup/<GetLibraryVersions>d__8")]
public sealed virtual Task`1<IEnumerable`1<string>> GetLibraryVersions(CancellationToken cancellationToken);
}
internal class Microsoft.Web.LibraryManager.Providers.Unpkg.UnpkgProvider : BaseProvider {
    public static string IdText;
    public static string DownloadUrlFormat;
    private INpmPackageSearch _packageSearch;
    private INpmPackageInfoFactory _infoFactory;
    private ILibraryCatalog _catalog;
    public string Id { get; }
    public string LibraryIdHintText { get; }
    public UnpkgProvider(IHostInteraction hostInteraction, CacheService cacheService, INpmPackageSearch packageSearch, INpmPackageInfoFactory infoFactory);
    public virtual string get_Id();
    public virtual ILibraryCatalog GetCatalog();
    public virtual string get_LibraryIdHintText();
    public virtual string GetSuggestedDestination(ILibrary library);
    protected virtual string GetDownloadUrl(ILibraryInstallationState state, string sourceFile);
}
internal class Microsoft.Web.LibraryManager.Providers.Unpkg.UnpkgProviderFactory : object {
    private INpmPackageSearch _packageSearch;
    private INpmPackageInfoFactory _packageInfoFactory;
    public UnpkgProviderFactory(INpmPackageSearch packageSearch, INpmPackageInfoFactory packageInfoFactory);
    public sealed virtual IProvider CreateProvider(IHostInteraction hostInteraction);
}
internal class Microsoft.Web.LibraryManager.RelativePathEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static RelativePathEqualityComparer <Instance>k__BackingField;
    public static RelativePathEqualityComparer Instance { get; }
    private static RelativePathEqualityComparer();
    [CompilerGeneratedAttribute]
public static RelativePathEqualityComparer get_Instance();
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
    private string NormalizePath(string path);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class Microsoft.Web.LibraryManager.Resources.Text : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string CdnjsLibraryIdHintText { get; }
    public static string Clean_NumberOfLibrariesCancelled { get; }
    public static string Clean_NumberOfLibrariesFailed { get; }
    public static string Clean_NumberOfLibrariesSucceeded { get; }
    public static string Clean_OperationCancelled { get; }
    public static string Clean_OperationCompleted { get; }
    public static string Clean_OperationCompletedWithErrors { get; }
    public static string Clean_OperationFailed { get; }
    public static string Clean_OperationStarted { get; }
    public static string DownloadingFile { get; }
    public static string FailedToDownloadCatalog { get; }
    public static string FileDeleted { get; }
    public static string FileDeleteFail { get; }
    public static string FileSystemLibraryIdHintText { get; }
    public static string FileWrittenToDisk { get; }
    public static string Install_LibraryFailed { get; }
    public static string Install_LibraryStarted { get; }
    public static string JsDelivrProviderHintText { get; }
    public static string LibraryDetail_Unavailable { get; }
    public static string LibraryInfoUpdateFailed { get; }
    public static string Restore_LibrariesForProject { get; }
    public static string Restore_LibrariesUptodate { get; }
    public static string Restore_LibraryRestoreCancelled { get; }
    public static string Restore_LibraryRestoreFailed { get; }
    public static string Restore_LibraryRestoreSucceeded { get; }
    public static string Restore_NumberOfLibrariesCancelled { get; }
    public static string Restore_NumberOfLibrariesFailed { get; }
    public static string Restore_NumberOfLibrariesSucceeded { get; }
    public static string Restore_NumberOfLibrariesUptodate { get; }
    public static string Restore_OperationCancelled { get; }
    public static string Restore_OperationCompleted { get; }
    public static string Restore_OperationCompletedWithErrors { get; }
    public static string Restore_OperationFailed { get; }
    public static string Restore_OperationHasErrors { get; }
    public static string Restore_OperationStarted { get; }
    public static string Restore_RestoreOfLibraryStarted { get; }
    public static string SummaryEndLine { get; }
    public static string TimeElapsed { get; }
    public static string Uninstall_LibraryCancelled { get; }
    public static string Uninstall_LibraryFailed { get; }
    public static string Uninstall_LibraryStarted { get; }
    public static string Uninstall_LibrarySucceeded { get; }
    public static string Uninstall_OperationCompleted { get; }
    public static string Uninstall_OperationCompletedWithErrors { get; }
    public static string UnpkgProviderHintText { get; }
    public static string Update_LibraryCancelled { get; }
    public static string Update_LibraryFailed { get; }
    public static string Update_LibraryStarted { get; }
    public static string Update_LibrarySucceeded { get; }
    public static string Upgrade_OperationCompleted { get; }
    public static string Upgrade_OperationCompletedWithErrors { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_CdnjsLibraryIdHintText();
    public static string get_Clean_NumberOfLibrariesCancelled();
    public static string get_Clean_NumberOfLibrariesFailed();
    public static string get_Clean_NumberOfLibrariesSucceeded();
    public static string get_Clean_OperationCancelled();
    public static string get_Clean_OperationCompleted();
    public static string get_Clean_OperationCompletedWithErrors();
    public static string get_Clean_OperationFailed();
    public static string get_Clean_OperationStarted();
    public static string get_DownloadingFile();
    public static string get_FailedToDownloadCatalog();
    public static string get_FileDeleted();
    public static string get_FileDeleteFail();
    public static string get_FileSystemLibraryIdHintText();
    public static string get_FileWrittenToDisk();
    public static string get_Install_LibraryFailed();
    public static string get_Install_LibraryStarted();
    public static string get_JsDelivrProviderHintText();
    public static string get_LibraryDetail_Unavailable();
    public static string get_LibraryInfoUpdateFailed();
    public static string get_Restore_LibrariesForProject();
    public static string get_Restore_LibrariesUptodate();
    public static string get_Restore_LibraryRestoreCancelled();
    public static string get_Restore_LibraryRestoreFailed();
    public static string get_Restore_LibraryRestoreSucceeded();
    public static string get_Restore_NumberOfLibrariesCancelled();
    public static string get_Restore_NumberOfLibrariesFailed();
    public static string get_Restore_NumberOfLibrariesSucceeded();
    public static string get_Restore_NumberOfLibrariesUptodate();
    public static string get_Restore_OperationCancelled();
    public static string get_Restore_OperationCompleted();
    public static string get_Restore_OperationCompletedWithErrors();
    public static string get_Restore_OperationFailed();
    public static string get_Restore_OperationHasErrors();
    public static string get_Restore_OperationStarted();
    public static string get_Restore_RestoreOfLibraryStarted();
    public static string get_SummaryEndLine();
    public static string get_TimeElapsed();
    public static string get_Uninstall_LibraryCancelled();
    public static string get_Uninstall_LibraryFailed();
    public static string get_Uninstall_LibraryStarted();
    public static string get_Uninstall_LibrarySucceeded();
    public static string get_Uninstall_OperationCompleted();
    public static string get_Uninstall_OperationCompletedWithErrors();
    public static string get_UnpkgProviderHintText();
    public static string get_Update_LibraryCancelled();
    public static string get_Update_LibraryFailed();
    public static string get_Update_LibraryStarted();
    public static string get_Update_LibrarySucceeded();
    public static string get_Upgrade_OperationCompleted();
    public static string get_Upgrade_OperationCompletedWithErrors();
}
public class Microsoft.Web.LibraryManager.SemanticVersion : object {
    private int _hashCode;
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Patch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrereleaseVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalText>k__BackingField;
    public int Major { get; private set; }
    public int Minor { get; private set; }
    public int Patch { get; private set; }
    public string BuildMetadata { get; private set; }
    public string PrereleaseVersion { get; private set; }
    public string OriginalText { get; private set; }
    private SemanticVersion(string originalText);
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
private void set_Major(int value);
    [CompilerGeneratedAttribute]
public int get_Minor();
    [CompilerGeneratedAttribute]
private void set_Minor(int value);
    [CompilerGeneratedAttribute]
public int get_Patch();
    [CompilerGeneratedAttribute]
private void set_Patch(int value);
    [CompilerGeneratedAttribute]
public string get_BuildMetadata();
    [CompilerGeneratedAttribute]
private void set_BuildMetadata(string value);
    [CompilerGeneratedAttribute]
public string get_PrereleaseVersion();
    [CompilerGeneratedAttribute]
private void set_PrereleaseVersion(string value);
    [CompilerGeneratedAttribute]
public string get_OriginalText();
    [CompilerGeneratedAttribute]
private void set_OriginalText(string value);
    internal static SemanticVersion Parse(string value);
    public sealed virtual int CompareTo(SemanticVersion other);
    public sealed virtual bool Equals(SemanticVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(SemanticVersion left, SemanticVersion right);
    public static bool op_Inequality(SemanticVersion left, SemanticVersion right);
    public static bool op_LessThan(SemanticVersion left, SemanticVersion right);
    public static bool op_LessThanOrEqual(SemanticVersion left, SemanticVersion right);
    public static bool op_GreaterThan(SemanticVersion left, SemanticVersion right);
    public static bool op_GreaterThanOrEqual(SemanticVersion left, SemanticVersion right);
}
internal static class Microsoft.Web.LibraryManager.Utilities.EncryptionUtility : object {
    private static Byte[] EntropyBytes;
    private static EncryptionUtility();
    public static string EncryptString(string value);
    public static string DecryptString(string encryptedString);
}
internal class Microsoft.Web.LibraryManager.Utilities.FileGlobbingUtility : object {
    private static Char[] GlobIndicatorCharacters;
    private static FileGlobbingUtility();
    public static IEnumerable`1<string> ExpandFileGlobs(IEnumerable`1<string> potentialGlobs, IEnumerable`1<string> libraryFiles);
}
internal static class Microsoft.Web.LibraryManager.Utilities.ParallelUtility : object {
    public static Task ForEachAsync(Func`2<T, Task> action, int degreeOfParallelism, IEnumerable`1<T> items);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Utilities.ParallelUtility/<ForEachAsync>d__1`1")]
public static Task ForEachAsync(Func`2<T, Task> action, int degreeOfParallelism, IEnumerable`1<T> items, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Web.LibraryManager.Utilities.ParallelUtility/<DoActionAndRelease>d__2`1")]
private static Task DoActionAndRelease(Func`2<T, Task> act, T input, SemaphoreSlim s);
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.3.37.35081")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
