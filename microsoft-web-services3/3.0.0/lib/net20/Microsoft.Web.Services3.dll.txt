internal class AssemblyRef : object {
    internal static string EcmaPublicKey;
    internal static string Mscorlib;
    internal static string SystemData;
    internal static string System;
    internal static string SystemRuntimeRemoting;
    internal static string SystemWindowsForms;
    internal static string SystemXml;
    internal static string MicrosoftPublicKey;
    internal static string SystemConfigurationInstall;
    internal static string SystemDesign;
    internal static string SystemDirectoryServices;
    internal static string SystemDrawingDesign;
    internal static string SystemDrawing;
    internal static string SystemEnterpriseServices;
    internal static string SystemManagement;
    internal static string SystemMessaging;
    internal static string SystemRuntimeSerializationFormattersSoap;
    internal static string SystemSecurity;
    internal static string SystemServiceProcess;
    internal static string SystemWeb;
    internal static string SystemWebMobile;
    internal static string SystemWebRegularExpressions;
    internal static string SystemWebServices;
    internal static string MicrosoftVisualStudio;
    internal static string MicrosoftVSDesigner;
    internal static string MicrosoftJScript;
}
public class Microsoft.Web.Services3.Addressing.Action : OpenAttributeUriString {
    private XmlElement _targetElement;
    private bool _mustUnderstand;
    public bool MustUnderstand { get; public set; }
    public string EncodedMustUnderstand { get; public set; }
    public XmlElement TargetElement { get; }
    public Action(string action);
    public Action(XmlElement element);
    public static string op_Explicit(Action obj);
    public static Action op_Implicit(string obj);
    public static bool op_Equality(Action obj1, Action obj2);
    public static bool op_Inequality(Action obj1, Action obj2);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public string get_EncodedMustUnderstand();
    public void set_EncodedMustUnderstand(string value);
    public sealed virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
    public XmlElement get_TargetElement();
    public virtual string ToString();
}
public class Microsoft.Web.Services3.Addressing.Address : OpenAttributeUriElement {
    public Address(Uri address);
    public Address(XmlElement element);
    public static Uri op_Explicit(Address obj);
    public static Address op_Implicit(Uri uri);
    public static bool op_Equality(Address obj1, Address obj2);
    public static bool op_Inequality(Address obj1, Address obj2);
    public sealed virtual object Clone();
    internal int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
}
public class Microsoft.Web.Services3.Addressing.AddressingFault : WseSoapHeaderException {
    public static XmlQualifiedName ActionNotSupportedCode;
    public static string ActionNotSupportedMessage;
    public static XmlQualifiedName DestinationUnreachableCode;
    public static string DestinationUnreachableMessage;
    public static XmlQualifiedName EndpointUnavailableCode;
    public static string EndpointUnavailableMessage;
    public static XmlQualifiedName HeaderRequiredCode;
    public static string HeaderRequiredMessage;
    public static XmlQualifiedName InvalidHeaderCode;
    public static string InvalidHeaderMessage;
    public AddressingFault(string message, XmlQualifiedName code);
    public AddressingFault(string message, XmlQualifiedName code, Exception ex);
    private static AddressingFault();
}
public class Microsoft.Web.Services3.Addressing.AddressingFormatException : SoapHeaderException {
    public static string MissingActionElement;
    public static string MissingToElement;
    public static string MissingMessageIDElement;
    public static string InvalidReferenceProperties;
    public static string InvalidReferenceParameters;
    public AddressingFormatException(string message);
    private static AddressingFormatException();
}
public class Microsoft.Web.Services3.Addressing.AddressingHeaders : object {
    private Action _action;
    private EndpointReference _destination;
    private FaultTo _faultTo;
    private From _from;
    private MessageID _messageID;
    private RelatesTo _relatesTo;
    private ReplyTo _replyTo;
    private To _to;
    private Via _via;
    private bool _mustUnderstand;
    public Action Action { get; public set; }
    public EndpointReference Destination { get; public set; }
    public FaultTo FaultTo { get; public set; }
    public From From { get; public set; }
    public MessageID MessageID { get; }
    public bool MustUnderstand { get; public set; }
    public RelatesTo RelatesTo { get; public set; }
    public ReplyTo ReplyTo { get; public set; }
    public To To { get; public set; }
    public Via Via { get; public set; }
    public AddressingHeaders(SoapEnvelope envelope);
    public Action get_Action();
    public void set_Action(Action value);
    private void AddEnvelopeNamespaceDeclaration(SoapEnvelope envelope, string prefix, string namespaceUri);
    public void Clear();
    private void CheckValid();
    public AddressingHeaders Clone();
    public void Defaults();
    public EndpointReference get_Destination();
    public void set_Destination(EndpointReference value);
    public FaultTo get_FaultTo();
    public void set_FaultTo(FaultTo value);
    public From get_From();
    public void set_From(From value);
    public void GetXml(SoapEnvelope envelope);
    public void Load(SoapEnvelope envelope);
    public MessageID get_MessageID();
    internal void SetMessageID(MessageID msgID);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public RelatesTo get_RelatesTo();
    public void set_RelatesTo(RelatesTo value);
    public void RemoveXml(SoapEnvelope envelope);
    public ReplyTo get_ReplyTo();
    public void set_ReplyTo(ReplyTo value);
    public void SetFaultResponseHeaders(AddressingHeaders source);
    internal void SetSoapAction(string soapAction);
    public void SetResponseHeaders(AddressingHeaders source);
    public void SetRequestHeaders(Via localEndpoint, Via remoteEndpoint);
    public To get_To();
    public void set_To(To value);
    public Via get_Via();
    public void set_Via(Via value);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Addressing.AddressList : object {
    private ArrayList _list;
    public Address Item { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public Address get_Item(int index);
    public void set_Item(int index, Address value);
    public int Add(Address address);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Address[] array, int index);
    public bool Contains(Address address);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(Address address);
    public void Insert(int index, Address address);
    public bool get_IsFixedSize();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public void Remove(Address address);
    public void RemoveAt(int index);
    public sealed virtual object get_SyncRoot();
}
public class Microsoft.Web.Services3.Addressing.EndpointReference : OpenElement {
    private Address _address;
    private PortType _portType;
    private ReferenceProperties _properties;
    private ReferenceParameters _parameters;
    private ServiceName _serviceName;
    private Via _via;
    public Address Address { get; public set; }
    public bool IsAnonymousAddress { get; }
    public bool IsAnonymousTransportAddress { get; }
    public bool IsRoutableTransportAddress { get; }
    public PortType PortType { get; public set; }
    public ReferenceParameters ReferenceParameters { get; public set; }
    public ReferenceProperties ReferenceProperties { get; public set; }
    public ServiceName ServiceName { get; public set; }
    public Uri TransportAddress { get; }
    public Via Via { get; public set; }
    public EndpointReference(Uri address);
    public EndpointReference(Uri address, Uri via);
    public EndpointReference(Address address);
    public EndpointReference(Address address, Via via);
    public EndpointReference(EndpointReference epr);
    public EndpointReference(XmlElement element);
    public static Uri op_Explicit(EndpointReference obj);
    public static EndpointReference op_Implicit(Uri obj);
    public static bool op_Equality(EndpointReference obj1, EndpointReference obj2);
    public static bool op_Inequality(EndpointReference obj1, EndpointReference obj2);
    public Address get_Address();
    public void set_Address(Address value);
    protected void Clear();
    public virtual object Clone();
    protected virtual void MemberClone(EndpointReference clone);
    internal int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    protected virtual void GetXmlElements(XmlDocument document, XmlElement element);
    public bool get_IsAnonymousAddress();
    public bool get_IsAnonymousTransportAddress();
    public bool get_IsRoutableTransportAddress();
    public virtual void LoadXml(XmlElement element);
    protected virtual void LoadXmlElements(XmlElement element);
    public bool Matches(SoapEnvelope message);
    public PortType get_PortType();
    public void set_PortType(PortType value);
    public ReferenceParameters get_ReferenceParameters();
    public void set_ReferenceParameters(ReferenceParameters value);
    public ReferenceProperties get_ReferenceProperties();
    public void set_ReferenceProperties(ReferenceProperties value);
    public ServiceName get_ServiceName();
    public void set_ServiceName(ServiceName value);
    public Uri get_TransportAddress();
    public Via get_Via();
    public void set_Via(Via value);
}
public class Microsoft.Web.Services3.Addressing.FaultTo : EndpointReference {
    private bool _mustUnderstand;
    private XmlElement _targetElement;
    public string EncodedMustUnderstand { get; public set; }
    public bool MustUnderstand { get; public set; }
    public XmlElement TargetElement { get; }
    public FaultTo(Uri address);
    public FaultTo(Address address);
    public FaultTo(EndpointReference epr);
    public FaultTo(XmlElement element);
    public static Uri op_Explicit(FaultTo obj);
    public static FaultTo op_Implicit(Uri obj);
    public virtual object Clone();
    public string get_EncodedMustUnderstand();
    public void set_EncodedMustUnderstand(string value);
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public XmlElement get_TargetElement();
}
public class Microsoft.Web.Services3.Addressing.From : EndpointReference {
    private bool _mustUnderstand;
    private XmlElement _targetElement;
    public string EncodedMustUnderstand { get; public set; }
    public bool MustUnderstand { get; public set; }
    public XmlElement TargetElement { get; }
    public From(Uri address);
    public From(Address address);
    public From(EndpointReference reference);
    public From(XmlElement element);
    public static Uri op_Explicit(From obj);
    public static From op_Implicit(Uri obj);
    public virtual object Clone();
    public string get_EncodedMustUnderstand();
    public void set_EncodedMustUnderstand(string value);
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public XmlElement get_TargetElement();
}
public class Microsoft.Web.Services3.Addressing.MessageID : OpenAttributeUriElement {
    private XmlElement _targetElement;
    private bool _mustUnderstand;
    public string EncodedMustUnderstand { get; public set; }
    public bool MustUnderstand { get; public set; }
    public XmlElement TargetElement { get; }
    public MessageID(Uri id);
    public MessageID(XmlElement element);
    public static Uri op_Explicit(MessageID obj);
    public static MessageID op_Implicit(Uri obj);
    public static bool op_Equality(MessageID obj1, MessageID obj2);
    public static bool op_Inequality(MessageID obj1, MessageID obj2);
    public string get_EncodedMustUnderstand();
    public void set_EncodedMustUnderstand(string value);
    public sealed virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public XmlElement get_TargetElement();
}
public class Microsoft.Web.Services3.Addressing.PortType : OpenAttributeQNameElement {
    public PortType(string name, string ns);
    public PortType(string prefix, string name, string ns);
    public PortType(XmlQualifiedName qname);
    public PortType(string prefix, XmlQualifiedName qname);
    public PortType(XmlElement element);
    public static bool op_Equality(PortType obj1, PortType obj2);
    public static bool op_Inequality(PortType obj1, PortType obj2);
    public sealed virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
}
public class Microsoft.Web.Services3.Addressing.ReferenceParameters : OpenElementElement {
    public ReferenceParameters(XmlElement element);
    public static bool op_Equality(ReferenceParameters obj1, ReferenceParameters obj2);
    public static bool op_Inequality(ReferenceParameters obj1, ReferenceParameters obj2);
    private void CheckNamespace(bool isReceive);
    public sealed virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
}
public class Microsoft.Web.Services3.Addressing.ReferenceProperties : OpenElementElement {
    private RelatesTo _relatesTo;
    private int _score;
    public RelatesTo RelatesTo { get; public set; }
    public ReferenceProperties(XmlElement element);
    public static bool op_Equality(ReferenceProperties obj1, ReferenceProperties obj2);
    public static bool op_Inequality(ReferenceProperties obj1, ReferenceProperties obj2);
    private void CheckNamespace(bool isReceive);
    public sealed virtual object Clone();
    internal int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
    public bool Matches(SoapEnvelope message);
    public RelatesTo get_RelatesTo();
    public void set_RelatesTo(RelatesTo value);
}
public class Microsoft.Web.Services3.Addressing.RelatesTo : OpenAttributeUriElement {
    private XmlElement _targetElement;
    private bool _mustUnderstand;
    public string EncodedMustUnderstand { get; public set; }
    public bool MustUnderstand { get; public set; }
    public QualifiedName RelationshipType { get; }
    public XmlElement TargetElement { get; }
    public RelatesTo(Uri related);
    public RelatesTo(XmlElement element);
    public static Uri op_Explicit(RelatesTo obj);
    public static RelatesTo op_Implicit(Uri obj);
    public static bool op_Equality(RelatesTo obj1, RelatesTo obj2);
    public static bool op_Inequality(RelatesTo obj1, RelatesTo obj2);
    public string get_EncodedMustUnderstand();
    public void set_EncodedMustUnderstand(string value);
    public sealed virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
    public bool Matches(SoapEnvelope message);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public QualifiedName get_RelationshipType();
    public XmlElement get_TargetElement();
}
public class Microsoft.Web.Services3.Addressing.ReplyTo : EndpointReference {
    private bool _mustUnderstand;
    private XmlElement _targetElement;
    public string EncodedMustUnderstand { get; public set; }
    public bool MustUnderstand { get; public set; }
    public XmlElement TargetElement { get; }
    public ReplyTo(Uri address);
    public ReplyTo(Address address);
    public ReplyTo(EndpointReference epr);
    public ReplyTo(XmlElement element);
    public static Uri op_Explicit(ReplyTo obj);
    public static ReplyTo op_Implicit(Uri obj);
    public virtual object Clone();
    public string get_EncodedMustUnderstand();
    public void set_EncodedMustUnderstand(string value);
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public XmlElement get_TargetElement();
}
public class Microsoft.Web.Services3.Addressing.ServiceName : OpenAttributeQNameElement {
    private string _port;
    public string PortName { get; public set; }
    public ServiceName(string name, string ns);
    public ServiceName(string prefix, string name, string ns);
    public ServiceName(XmlQualifiedName qname);
    public ServiceName(string prefix, XmlQualifiedName qname);
    public ServiceName(XmlElement element);
    public sealed virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
    public string get_PortName();
    public void set_PortName(string value);
}
public class Microsoft.Web.Services3.Addressing.To : OpenAttributeUriElement {
    private XmlElement _targetElement;
    private bool _mustUnderstand;
    public string EncodedMustUnderstand { get; public set; }
    public bool MustUnderstand { get; public set; }
    public XmlElement TargetElement { get; }
    public To(Uri to);
    public To(Address address);
    public To(XmlElement element);
    public static Uri op_Explicit(To obj);
    public static To op_Implicit(Uri uri);
    public static bool op_Equality(To obj1, To obj2);
    public static bool op_Inequality(To obj1, To obj2);
    public string get_EncodedMustUnderstand();
    public void set_EncodedMustUnderstand(string value);
    public sealed virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public XmlElement get_TargetElement();
}
public static class Microsoft.Web.Services3.Addressing.WSAddressing : object {
    public static string Prefix;
    public static string NamespaceURI;
    public static string ResponseAction;
    public static string FaultAction;
    public static Uri AnonymousRole;
    public static Uri AnyRole;
    private static WSAddressing();
}
public class Microsoft.Web.Services3.AsynchronousOperationException : Exception {
    public AsynchronousOperationException(Exception wrapped);
}
public abstract class Microsoft.Web.Services3.AsyncResult : object {
    private AsyncCallback _callback;
    private bool _completed;
    private bool _completedSync;
    private bool _endCalled;
    private Exception _exception;
    private ManualResetEvent _event;
    private object _state;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    protected AsyncResult(object state);
    protected AsyncResult(AsyncCallback callback, object state);
    public sealed virtual object get_AsyncState();
    public virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    protected void Complete(bool completedSynchronously);
    protected void Complete(bool completedSynchronously, Exception exception);
    public static void End(IAsyncResult result);
    private void RaiseUnhandledException(object o);
}
internal class Microsoft.Web.Services3.BadRequestException : ApplicationException {
    public BadRequestException(string s);
}
internal class Microsoft.Web.Services3.Collections.DoubleLink : object {
    internal DoubleLink _next;
    internal DoubleLink _prev;
    internal object Item;
    internal DoubleLink Next { get; }
    internal DoubleLink(object item);
    internal DoubleLink get_Next();
    internal void InsertAfter(DoubleLink after);
    internal void InsertBefore(DoubleLink before);
    internal void Remove();
}
internal class Microsoft.Web.Services3.Collections.DoubleLinkList : DoubleLink {
    internal virtual void InsertHead(DoubleLink entry);
    internal virtual void InsertTail(DoubleLink entry);
    internal DoubleLinkListEnumerator GetEnumerator();
}
internal class Microsoft.Web.Services3.Collections.DoubleLinkListEnumerator : object {
    private DoubleLinkList _list;
    private DoubleLink _current;
    public object Current { get; }
    internal DoubleLinkListEnumerator(DoubleLinkList list);
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    internal DoubleLink GetDoubleLink();
}
internal class Microsoft.Web.Services3.CompletedAsyncResult : AsyncResult {
    public CompletedAsyncResult(AsyncCallback callback, object state);
}
public class Microsoft.Web.Services3.Configuration.ConfigElementInterceptor : ConfigurationElement {
    private XmlDocument elementXml;
    internal XmlElement ElementAsXml { get; }
    internal XmlNodeList ChildNodes { get; }
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual bool OnDeserializeUnrecognizedAttribute(string name, string value);
    protected virtual bool OnDeserializeUnrecognizedElement(string elementName, XmlReader reader);
    internal XmlElement get_ElementAsXml();
    internal XmlNodeList get_ChildNodes();
}
internal class Microsoft.Web.Services3.Configuration.ConfigurationBase : object {
    public static bool CheckForChildElements(XmlNode node);
    public static void CheckForChildNodes(XmlNode node);
    public static void CheckForDuplicateChildNodes(XmlNode node);
    public static void CheckForUnrecognizedAttributes(XmlNode node);
    public static void ThrowIfElement(XmlNode node);
    public static void ThrowIfNotComment(XmlNode node);
    public static XmlNode GetAndRemoveAttribute(XmlNode node, string attrib, bool fRequired);
    public static XmlNode GetAndRemoveStringAttribute(XmlNode node, string attrib, bool fRequired, String& val);
    public static XmlNode GetAndRemoveIntegerAttribute(XmlNode node, string attrib, bool fRequired, Int32& val);
    public static XmlNode GetAndRemoveBoolAttribute(XmlNode node, string attrib, bool fRequired, Boolean& val);
    protected static bool ImplementsInterface(Type type, Type interfaceType);
}
public class Microsoft.Web.Services3.Configuration.EnabledAttributeElement : ConfigurationElement {
    private ConfigurationProperty _enabled;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal bool Enabled { get; }
    internal EnabledAttributeElement(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal bool get_Enabled();
}
public class Microsoft.Web.Services3.Configuration.Install.ConfigInstaller : Installer {
    internal static string EventLogSource;
    public void Install();
    public virtual void Install(IDictionary stateSaver);
    public virtual void Commit(IDictionary savedState);
    public virtual void Rollback(IDictionary savedState);
    public void Uninstall();
    public virtual void Uninstall(IDictionary savedState);
}
[RunInstallerAttribute("True")]
public class Microsoft.Web.Services3.Configuration.Install.WebServicesInstaller : Installer {
}
internal class Microsoft.Web.Services3.Configuration.Install.XmlEncoding : UTF8Encoding {
    public virtual Byte[] GetPreamble();
}
public class Microsoft.Web.Services3.Configuration.NameAttributeElement : ConfigurationElement {
    private ConfigurationProperty _name;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Name { get; }
    internal NameAttributeElement(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Name();
}
public class Microsoft.Web.Services3.Configuration.PolicyConfiguration : ConfigurationElement {
    private ConfigurationProperty _name;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    public string FileName { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public Policies GetPolicies();
    public string get_FileName();
}
internal class Microsoft.Web.Services3.Configuration.SystemTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class Microsoft.Web.Services3.Configuration.SysWebServicesConfiguration : object {
    private static string SectionName;
    private static object _configurationLock;
    private static WebServiceProtocols _protocols;
    internal static WebServiceProtocols EnabledProtocols { get; }
    private static SysWebServicesConfiguration();
    internal static WebServiceProtocols get_EnabledProtocols();
}
internal class Microsoft.Web.Services3.Configuration.TimeSpanConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class Microsoft.Web.Services3.Configuration.ValueAttributeElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Value { get; }
    internal ValueAttributeElement(string value);
    internal ValueAttributeElement(int value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Value();
}
public class Microsoft.Web.Services3.Configuration.WebServicesConfiguration : ConfigurationSection {
    private static string SectionName;
    private ConfigurationProperty _diagnosticsConfiguration;
    private ConfigurationProperty _referralConfiguration;
    private ConfigurationProperty _securityConfiguration;
    private ConfigurationProperty _policyConfiguration;
    private ConfigurationProperty _tokenIssuerConfiguration;
    private ConfigurationProperty _messagingConfiguration;
    private ConfigurationPropertyCollection _properties;
    private static WebServicesConfiguration _configuration;
    private static Exception _configurationException;
    private static object _configurationLock;
    private static int _recursionGuard;
    private static WebServicesConfiguration Current { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public static DiagnosticsConfiguration DiagnosticsConfiguration { get; }
    public static MessagingConfiguration MessagingConfiguration { get; }
    public static PolicyConfiguration PolicyConfiguration { get; }
    public static ReferralConfiguration ReferralConfiguration { get; }
    public static SecurityConfiguration SecurityConfiguration { get; }
    public static TokenIssuerConfiguration TokenIssuerConfiguration { get; }
    private static WebServicesConfiguration();
    private static WebServicesConfiguration get_Current();
    protected virtual ConfigurationPropertyCollection get_Properties();
    private static void Initialize();
    public static DiagnosticsConfiguration get_DiagnosticsConfiguration();
    internal static bool IsInitialized();
    public static MessagingConfiguration get_MessagingConfiguration();
    public static PolicyConfiguration get_PolicyConfiguration();
    public static ReferralConfiguration get_ReferralConfiguration();
    public static SecurityConfiguration get_SecurityConfiguration();
    public static TokenIssuerConfiguration get_TokenIssuerConfiguration();
}
internal class Microsoft.Web.Services3.ContentType : object {
    internal static string TextBase;
    internal static string TextXml;
    internal static string TextPlain;
    internal static string TextHtml;
    internal static string ApplicationBase;
    internal static string ApplicationXml;
    internal static string ApplicationSoap;
    internal static string ContentEncoding;
    internal static string GetBase(string contentType);
    internal static string GetMediaType(string contentType);
    internal static string GetCharset(string contentType);
    internal static string GetAction(string contentType);
    private static string GetParameter(string contentType, string paramName);
    internal static bool MatchesBase(string contentType, string baseContentType);
    internal static bool IsApplication(string contentType);
    internal static bool IsSoap(string contentType);
    internal static bool IsXml(string contentType);
    internal static bool IsHtml(string contentType);
    internal static string Compose(string contentType, Encoding encoding);
    internal static string Compose(string contentType, Encoding encoding, string action);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.CredentialContext : object {
    private SoapContext context;
    public CredentialSet UltimateReceiver { get; }
    public CredentialSet Item { get; }
    internal CredentialContext(SoapContext context);
    public CredentialSet get_UltimateReceiver();
    public CredentialSet get_Item(string actor);
    public CredentialSet SetCredentials(CredentialSet credentials);
    public CredentialSet SetCredentials(CredentialSet credentials, string actor);
    public void SetSecurityContextToken(SecurityContextToken token);
    public void SetSecurityContextToken(SecurityContextToken token, string actor);
    public SecurityContextToken GetSecurityContextToken();
    public SecurityContextToken GetSecurityContextToken(string actor);
}
internal class Microsoft.Web.Services3.Description.SchemaCreator : object {
    private ArrayList _typeInfos;
    private XmlSchemas _schemas;
    private bool _addTrust;
    public bool AddTrust { get; }
    public XmlSchemas Schemas { get; }
    public bool get_AddTrust();
    public void AddTypeInfo(Type type, XmlRootAttribute attribute);
    public void GenerateSchemas(string defaultNamespace);
    internal void AddAnySchema(string targetNamespace);
    public XmlSchemas get_Schemas();
}
internal class Microsoft.Web.Services3.Description.WsdlCreator : object {
    private string GetTypeName(Type type, string defaultNamespace);
    public ServiceDescription GenerateDescription(IDictionary methods, string location, WebServiceProtocols protocols);
    private PortType CreatePortType(Type service);
    private string CreateTargetNamespace(Type service);
    private Binding CreateBinding(Type service, PortType portType, string targetNamespace, string location, SoapProtocolVersion soapVersion);
    private Message CreateInputMessage(MethodInfo method, string messageName, string targetNamespace, SchemaCreator schemaCreator, Boolean& anySchemaNeeded);
    private Message CreateOutputMessage(MethodInfo method, string messageName, string targetNamespace, SchemaCreator schemaCreator, Boolean& anySchemaNeeded);
    private Operation CreateOperation(MethodInfo method, Message inMessage, Message outMessage, string methodName, string messageName, string targetNamespace);
    private OperationBinding CreateOperationBinding(MethodInfo method, string messageName, SoapProtocolVersion soapVersion);
    private Service CreateService(Type service, string targetNamespace, Binding soap11Binding, Binding soap12Binding, string location);
    private Port CreatePort(string soapServiceName, string location, string bindingName, string targetNamespace, SoapProtocolVersion soapVersion);
    private string GetRequestAction(MethodInfo method);
    private string GetResponseAction(MethodInfo method);
    private void SetAction(DocumentableItem item, string action);
}
public class Microsoft.Web.Services3.Description.WseExtensionImporter : SoapExtensionImporter {
    private static string RecursionGuard;
    private static string WebConfig;
    public static IsWseReferenced IsWseReferencedImplementation;
    public static IsWseReferencedInActiveProject IsWseReferencedActiveProjectImplementation;
    private bool _classGenerated;
    public virtual void ImportMethod(CodeAttributeDeclarationCollection metadata);
}
public class Microsoft.Web.Services3.Design.AccessCheckRule : object {
    private bool isAllowRule;
    private string user;
    private string role;
    public bool IsAllowRule { get; }
    public string User { get; }
    public string Role { get; }
    public AccessCheckRule(bool isAllowRule);
    public AccessCheckRule(bool isAllowRule, string user);
    public AccessCheckRule(bool isAllowRule, string user, string role);
    public bool get_IsAllowRule();
    public string get_User();
    public string get_Role();
    public bool TryCheckAccess(IPrincipal principal, Boolean& accessCheckResult);
    private bool IsRuleMatching(IPrincipal principal);
    internal void WriteXml(XmlWriter writer);
    internal void ReadXml(XmlReader reader);
}
public class Microsoft.Web.Services3.Design.AnonymousForCertificateAssertion : SecurityPolicyAssertion {
    private TokenProvider`1<X509SecurityToken> serviceX509TokenProvider;
    public TokenProvider`1<X509SecurityToken> ServiceX509TokenProvider { get; public set; }
    public TokenProvider`1<X509SecurityToken> get_ServiceX509TokenProvider();
    public void set_ServiceX509TokenProvider(TokenProvider`1<X509SecurityToken> value);
    public virtual SoapFilter CreateClientInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateClientOutputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceOutputFilter(FilterCreationContext context);
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public class Microsoft.Web.Services3.Design.AppliesTo : object {
    private EndpointReference _endpointReference;
    public EndpointReference EndpointReference { get; }
    public AppliesTo(Uri address);
    public AppliesTo(EndpointReference endpointReference);
    public AppliesTo(string address);
    public AppliesTo(XmlElement element);
    public static Uri op_Implicit(AppliesTo obj);
    public static AppliesTo op_Implicit(Uri obj);
    public static AppliesTo op_Implicit(string obj);
    private void CheckValid();
    public EndpointReference get_EndpointReference();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public sealed virtual void LoadXml(XmlElement element);
}
public class Microsoft.Web.Services3.Design.AuthorizationAssertion : PolicyAssertion {
    private Collection`1<AccessCheckRule> rules;
    private string roleProviderName;
    public string RoleProviderName { get; public set; }
    public Collection`1<AccessCheckRule> Rules { get; }
    public AuthorizationAssertion(string roleProviderName);
    public string get_RoleProviderName();
    public void set_RoleProviderName(string value);
    public Collection`1<AccessCheckRule> get_Rules();
    public virtual SoapFilter CreateClientInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateClientOutputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceOutputFilter(FilterCreationContext context);
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
    private RoleProvider GetRoleProvider();
    private static IPrincipal GetPrincipal(SoapEnvelope envelope, RoleProvider roleProvider);
}
public class Microsoft.Web.Services3.Design.EndpointProtectionRequirements : object {
    private OperationProtectionRequirements defaultOperation;
    private Dictionary`2<string, OperationProtectionRequirements> operations;
    public MessageProtectionRequirements Request { get; }
    public MessageProtectionRequirements Response { get; }
    public MessageProtectionRequirements Fault { get; }
    public OperationProtectionRequirements DefaultOperation { get; public set; }
    public IDictionary`2<string, OperationProtectionRequirements> Operations { get; }
    public EndpointProtectionRequirements(EndpointProtectionRequirements other);
    public MessageProtectionRequirements get_Request();
    public MessageProtectionRequirements get_Response();
    public MessageProtectionRequirements get_Fault();
    public OperationProtectionRequirements get_DefaultOperation();
    public void set_DefaultOperation(OperationProtectionRequirements value);
    public IDictionary`2<string, OperationProtectionRequirements> get_Operations();
    public void WriteInnerXml(XmlWriter writer);
    public void ReadInnerXml(XmlReader reader);
    internal OperationProtectionRequirements GetRequirementsForRequest(SoapEnvelope envelope);
}
public class Microsoft.Web.Services3.Design.FilterCreationContext : object {
    private Policy policy;
    private PipelineCreationContext pipelineCreationContext;
    public PipelineCreationContext PipelineCreationContext { get; }
    public Policy Policy { get; }
    internal FilterCreationContext(PipelineCreationContext pipelineContext, Policy policy);
    public PipelineCreationContext get_PipelineCreationContext();
    public Policy get_Policy();
}
public class Microsoft.Web.Services3.Design.KerberosAssertion : SecurityPolicyAssertion {
    private TokenProvider`1<KerberosToken> kerberosTokenProvider;
    public TokenProvider`1<KerberosToken> KerberosTokenProvider { get; public set; }
    public TokenProvider`1<KerberosToken> get_KerberosTokenProvider();
    public void set_KerberosTokenProvider(TokenProvider`1<KerberosToken> value);
    public virtual SoapFilter CreateClientInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateClientOutputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceOutputFilter(FilterCreationContext context);
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public class Microsoft.Web.Services3.Design.KerberosTokenProvider : TokenProvider`1<KerberosToken> {
    private string targetPrincipal;
    private ImpersonationLevel impersonationLevel;
    public string TargetPrincipal { get; public set; }
    public ImpersonationLevel ImpersonationLevel { get; public set; }
    public KerberosTokenProvider(string targetPrincipal);
    public KerberosTokenProvider(string targetPrincipal, ImpersonationLevel impersonationLevel);
    public string get_TargetPrincipal();
    public void set_TargetPrincipal(string value);
    public ImpersonationLevel get_ImpersonationLevel();
    public void set_ImpersonationLevel(ImpersonationLevel value);
    public virtual KerberosToken GetToken();
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public enum Microsoft.Web.Services3.Design.MessageProtectionOrder : Enum {
    public int value__;
    public static MessageProtectionOrder SignBeforeEncrypt;
    public static MessageProtectionOrder SignBeforeEncryptAndEncryptSignature;
    public static MessageProtectionOrder EncryptBeforeSign;
}
internal static class Microsoft.Web.Services3.Design.MessageProtectionOrderHelper : object {
    public static bool IsDefined(MessageProtectionOrder value);
}
public class Microsoft.Web.Services3.Design.MessageProtectionRequirements : object {
    private SignatureOptions signatureOptions;
    private Collection`1<XmlQualifiedName> customSignedHeaders;
    private bool encryptBody;
    public ICollection`1<XmlQualifiedName> CustomSignedHeaders { get; }
    public bool EncryptBody { get; public set; }
    public SignatureOptions SignatureOptions { get; public set; }
    public MessageProtectionRequirements(MessageProtectionRequirements other);
    public ICollection`1<XmlQualifiedName> get_CustomSignedHeaders();
    public bool get_EncryptBody();
    public void set_EncryptBody(bool value);
    public SignatureOptions get_SignatureOptions();
    public void set_SignatureOptions(SignatureOptions value);
    public void WriteXml(string name, XmlWriter writer);
    public void ReadXml(XmlReader reader, string name);
    public void Protect(SoapEnvelope envelope, Security security, SecurityToken signingToken, SecurityToken encryptingToken, bool requireDerivedKey, MessageProtectionOrder messageProtectionOrder, bool requireSignatureConfirmation, IEnumerable`1<SecurityToken> endorsedTokens, IEnumerable`1<SecurityToken> attachedTokens, SecurityToken basicAttachedToken);
    private MessageSignature Sign(SoapEnvelope envelope, Security security, SecurityToken token, bool requireDerivedKey, bool requireSignatureConfirmation, IEnumerable`1<SecurityToken> endorsedTokens, IEnumerable`1<SecurityToken> attachedTokens, SecurityToken basicAttachedToken);
    private void SignCustomHeaders(MessageSignature signature, SoapEnvelope envelope);
    private void Encrypt(Security security, SecurityToken token, bool referenceListInside, bool deriveKey, MessageSignature signature, SecurityToken basicToken);
    private bool AreSignatureRequirementsSatisfied(SoapFilter filter, SoapEnvelope envelope, Security security, bool requireDerivedKeys, MessageProtectionOrder messageProtectionOrder, Type signatureToken, Type encryptionToken, Type basicAttachedToken, SecurityToken& signingToken, MessageSignature& messageSignature);
    private bool IsSatisfactorySignature(SoapFilter filter, MessageSignature signature, SoapEnvelope envelope, Security security, bool requireDerivedKeys, MessageProtectionOrder messageProtectionOrder, Type signatureToken, Type encryptionToken, Type basicAttachedToken);
    private bool IsSignatureConfirmationEncrypted(Security security, bool requireDerivedKeys, Type encryptionToken);
    private bool IsSignatureEncrypted(MessageSignature signature, Security security, bool requireDerivedKeys, Type encryptionToken);
    private bool IsBasicAttachedTokenSigned(MessageSignature signature, Security security, Type basicAttachedToken);
    private bool AreMessagePartsSigned(SoapFilter filter, MessageSignature signature, SoapEnvelope envelope, Security security);
    private bool AreCustomHeadersSigned(SoapFilter filter, MessageSignature signature, SoapEnvelope envelope);
    private bool IsCustomHeaderSignedIfPresent(XmlQualifiedName header, MessageSignature signature, SoapEnvelope envelope);
    private bool IsPartAbsent(SoapFilter filter, SignatureOptions options, Security security, SoapEnvelope envelope);
    private bool AreEncryptionRequirementsSatisfied(SoapFilter filter, Security security, bool requireDerivedKeys, Type encryptionToken, Type basicAttachedToken, SecurityToken& encryptingToken, EncryptedData& bodyEncryption);
    private SecurityToken TryGetUniqueBasicAttachedToken(Security security, Type type);
    private bool IsBasicAttachedTokenEncrypted(Security security, bool requireDerivedKeys, Type encryptionToken, Type basicAttachedToken);
    private bool IsBodyEncryptionRequirementSatisfied(Security security, bool requireDerivedKeys, Type encryptionToken, SecurityToken& encryptingToken, EncryptedData& bodyEncryption);
    private bool IsTokenRequirementSatisfied(SecurityToken token, bool requireDerivedKeys, Type type);
    private bool IsTokenRequirementSatisfied(SecurityToken token, bool requireDerivedKeys, SecurityToken tokenExpected);
    public bool AreRequirementsSatisfied(SoapFilter filter, SoapEnvelope envelope, Security security, bool requireDerivedKeys, MessageProtectionOrder messageProtectionOrder, bool requireSignatureConfirmation, Type signatureTokenType, Type encryptionTokenType, Type basicAttachedTokenType, SecurityToken tokenFromRequest);
    private bool IsTimestampRequirementSatisfied(Security security);
    private bool IsProtectionOrderSatisfied(MessageProtectionOrder messageProtectionOrder, Security security, MessageSignature signature, EncryptedData encryption);
}
public class Microsoft.Web.Services3.Design.MutualCertificate10Assertion : SecurityPolicyAssertion {
    private TokenProvider`1<X509SecurityToken> serviceX509TokenProvider;
    private TokenProvider`1<X509SecurityToken> clientX509TokenProvider;
    public TokenProvider`1<X509SecurityToken> ClientX509TokenProvider { get; public set; }
    public TokenProvider`1<X509SecurityToken> ServiceX509TokenProvider { get; public set; }
    public TokenProvider`1<X509SecurityToken> get_ClientX509TokenProvider();
    public void set_ClientX509TokenProvider(TokenProvider`1<X509SecurityToken> value);
    public TokenProvider`1<X509SecurityToken> get_ServiceX509TokenProvider();
    public void set_ServiceX509TokenProvider(TokenProvider`1<X509SecurityToken> value);
    private void ValidateConfiguration();
    public virtual SoapFilter CreateClientInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateClientOutputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceOutputFilter(FilterCreationContext context);
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
    private static X509SecurityToken ChangeReferenceToIssuerSerial(X509SecurityToken token);
}
public class Microsoft.Web.Services3.Design.MutualCertificate11Assertion : SecurityPolicyAssertion {
    private TokenProvider`1<X509SecurityToken> serviceX509TokenProvider;
    private TokenProvider`1<X509SecurityToken> clientX509TokenProvider;
    public TokenProvider`1<X509SecurityToken> ClientX509TokenProvider { get; public set; }
    public TokenProvider`1<X509SecurityToken> ServiceX509TokenProvider { get; public set; }
    public TokenProvider`1<X509SecurityToken> get_ClientX509TokenProvider();
    public void set_ClientX509TokenProvider(TokenProvider`1<X509SecurityToken> value);
    public TokenProvider`1<X509SecurityToken> get_ServiceX509TokenProvider();
    public void set_ServiceX509TokenProvider(TokenProvider`1<X509SecurityToken> value);
    public virtual SoapFilter CreateClientInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateClientOutputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceOutputFilter(FilterCreationContext context);
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public class Microsoft.Web.Services3.Design.OperationProtectionRequirements : object {
    private MessageProtectionRequirements request;
    private MessageProtectionRequirements response;
    private MessageProtectionRequirements fault;
    public MessageProtectionRequirements Request { get; }
    public MessageProtectionRequirements Response { get; }
    public MessageProtectionRequirements Fault { get; }
    public OperationProtectionRequirements(OperationProtectionRequirements other);
    public MessageProtectionRequirements get_Request();
    public MessageProtectionRequirements get_Response();
    public MessageProtectionRequirements get_Fault();
    public void WriteElements(XmlWriter writer, string name, string requestAction);
    public void ReadElements(XmlReader reader, string name, String& action);
    public sealed virtual void WriteXml(XmlWriter writer);
    public sealed virtual void ReadXml(XmlReader reader);
    public sealed virtual XmlSchema GetSchema();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Design.Policies : object {
    private static string PolicyNamespace;
    private Dictionary`2<string, Policy> policies;
    private static Policies defaultPolicies;
    public static Policies Default { get; }
    public Policy Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<Policy> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private static Policies();
    public static Policies get_Default();
    public sealed virtual void WriteXml(XmlWriter writer);
    private void WriteExtensions(XmlWriter writer);
    private IDictionary`2<string, Type> CollectExtensions();
    private void WritePolicies(XmlWriter writer);
    public sealed virtual void ReadXml(XmlReader reader);
    private void ReadPolicies(XmlReader reader, IDictionary`2<string, Type> extensions);
    private IDictionary`2<string, Type> ReadExtensions(XmlReader reader);
    private void AddBuiltInExtensions(Dictionary`2<string, Type> extensions);
    private void AddBuiltInExtension(Dictionary`2<string, Type> extensions, string name, Type type);
    public sealed virtual XmlSchema GetSchema();
    public sealed virtual Policy get_Item(string key);
    public sealed virtual void set_Item(string key, Policy value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<Policy> get_Values();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void Add(string key, Policy value);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Policy& value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Web.Services3.Design.Policy>>.Add(KeyValuePair`2<string, Policy> item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Web.Services3.Design.Policy>>.Contains(KeyValuePair`2<string, Policy> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Web.Services3.Design.Policy>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Web.Services3.Design.Policy>>.Remove(KeyValuePair`2<string, Policy> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, Policy>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Web.Services3.Design.Policy>>.GetEnumerator();
    public sealed virtual IEnumerator GetEnumerator();
}
public class Microsoft.Web.Services3.Design.Policy : object {
    private Collection`1<PolicyAssertion> assertions;
    public Collection`1<PolicyAssertion> Assertions { get; }
    public Policy(PolicyAssertion[] assertions);
    public Collection`1<PolicyAssertion> get_Assertions();
    public static Policy CreateWse2PipelinePolicy();
    public sealed virtual Pipeline CreateClientPipeline(PipelineCreationContext context);
    public sealed virtual Pipeline CreateServicePipeline(PipelineCreationContext context);
    internal void WriteXml(XmlWriter writer, string policyName);
    internal static Policy ReadFrom(XmlReader reader, IDictionary`2<string, Type> extensions, String& policyName);
    private void ReadFrom(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public abstract class Microsoft.Web.Services3.Design.PolicyAssertion : object {
    public abstract virtual SoapFilter CreateClientInputFilter(FilterCreationContext context);
    public abstract virtual SoapFilter CreateClientOutputFilter(FilterCreationContext context);
    public abstract virtual SoapFilter CreateServiceInputFilter(FilterCreationContext context);
    public abstract virtual SoapFilter CreateServiceOutputFilter(FilterCreationContext context);
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    internal PolicyAssertion DeepClone();
    internal static T CreateExtensionInstance(string name, IDictionary`2<string, Type> extensions);
    internal static bool TryGetAttribute(XmlReader reader, string name, T& value);
    internal static void WriteAttribute(XmlWriter writer, string name, T value);
}
public class Microsoft.Web.Services3.Design.RequireActionHeaderAssertion : RequireSoapHeaderAssertion {
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public class Microsoft.Web.Services3.Design.RequireSoapHeaderAssertion : PolicyAssertion {
    private string name;
    private string ns;
    private string actor;
    public string Name { get; }
    public string Namespace { get; }
    public string Actor { get; }
    public RequireSoapHeaderAssertion(string name, string ns);
    public RequireSoapHeaderAssertion(string name, string ns, string actor);
    public string get_Name();
    public string get_Namespace();
    public string get_Actor();
    public virtual SoapFilter CreateClientInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateClientOutputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceOutputFilter(FilterCreationContext context);
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public abstract class Microsoft.Web.Services3.Design.SecurityPolicyAssertion : PolicyAssertion {
    private bool establishSecurityContext;
    private bool renewExpiredSecurityContext;
    private bool requireSignatureConfirmation;
    private MessageProtectionOrder messageProtectionOrder;
    private bool requireDerivedKeys;
    private EndpointProtectionRequirements protection;
    private int ttlInSeconds;
    private string clientActor;
    private string serviceActor;
    public string ClientActor { get; public set; }
    public string ServiceActor { get; public set; }
    public int TtlInSeconds { get; public set; }
    public bool RequireDerivedKeys { get; public set; }
    public bool EstablishSecurityContext { get; public set; }
    public bool RenewExpiredSecurityContext { get; public set; }
    public MessageProtectionOrder MessageProtectionOrder { get; public set; }
    public bool RequireSignatureConfirmation { get; public set; }
    public EndpointProtectionRequirements Protection { get; }
    public string get_ClientActor();
    public void set_ClientActor(string value);
    public string get_ServiceActor();
    public void set_ServiceActor(string value);
    public int get_TtlInSeconds();
    public void set_TtlInSeconds(int value);
    public bool get_RequireDerivedKeys();
    public void set_RequireDerivedKeys(bool value);
    public bool get_EstablishSecurityContext();
    public void set_EstablishSecurityContext(bool value);
    public bool get_RenewExpiredSecurityContext();
    public void set_RenewExpiredSecurityContext(bool value);
    public MessageProtectionOrder get_MessageProtectionOrder();
    public void set_MessageProtectionOrder(MessageProtectionOrder value);
    public bool get_RequireSignatureConfirmation();
    public void set_RequireSignatureConfirmation(bool value);
    public EndpointProtectionRequirements get_Protection();
    protected void WriteAttributes(XmlWriter writer);
    protected void ReadAttributes(XmlReader reader);
    protected void WriteElements(XmlWriter writer);
    protected void ReadElements(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public abstract class Microsoft.Web.Services3.Design.TokenProvider`1 : object {
    public abstract virtual TToken GetToken();
    public abstract virtual void WriteXml(XmlWriter writer);
    public abstract virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
}
public class Microsoft.Web.Services3.Design.UsernameForCertificateAssertion : SecurityPolicyAssertion {
    private TokenProvider`1<X509SecurityToken> x509TokenProvider;
    private TokenProvider`1<UsernameToken> usernameTokenProvider;
    public TokenProvider`1<UsernameToken> UsernameTokenProvider { get; public set; }
    public TokenProvider`1<X509SecurityToken> X509TokenProvider { get; public set; }
    public TokenProvider`1<UsernameToken> get_UsernameTokenProvider();
    public void set_UsernameTokenProvider(TokenProvider`1<UsernameToken> value);
    public TokenProvider`1<X509SecurityToken> get_X509TokenProvider();
    public void set_X509TokenProvider(TokenProvider`1<X509SecurityToken> value);
    public virtual SoapFilter CreateClientInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateClientOutputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceOutputFilter(FilterCreationContext context);
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public class Microsoft.Web.Services3.Design.UsernameOverTransportAssertion : PolicyAssertion {
    private string serviceActor;
    private string clientActor;
    private TokenProvider`1<UsernameToken> usernameTokenProvider;
    public string ServiceActor { get; public set; }
    public string ClientActor { get; public set; }
    public TokenProvider`1<UsernameToken> UsernameTokenProvider { get; public set; }
    public string get_ServiceActor();
    public void set_ServiceActor(string value);
    public string get_ClientActor();
    public void set_ClientActor(string value);
    public TokenProvider`1<UsernameToken> get_UsernameTokenProvider();
    public void set_UsernameTokenProvider(TokenProvider`1<UsernameToken> value);
    public virtual SoapFilter CreateClientInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateClientOutputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceInputFilter(FilterCreationContext context);
    public virtual SoapFilter CreateServiceOutputFilter(FilterCreationContext context);
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public class Microsoft.Web.Services3.Design.UsernameTokenProvider : TokenProvider`1<UsernameToken> {
    private string username;
    private string password;
    public string Username { get; public set; }
    public string Password { get; public set; }
    public UsernameTokenProvider(string username, string password);
    public string get_Username();
    public void set_Username(string value);
    public string get_Password();
    public void set_Password(string value);
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual UsernameToken GetToken();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public static class Microsoft.Web.Services3.Design.WSPolicy : object {
    public static string NamespaceURI;
    public static string Prefix;
}
public class Microsoft.Web.Services3.Design.X509TokenProvider : TokenProvider`1<X509SecurityToken> {
    private StoreLocation storeLocation;
    private StoreName storeName;
    private string findValue;
    private X509FindType findType;
    public StoreLocation StoreLocation { get; public set; }
    public StoreName StoreName { get; public set; }
    public string FindValue { get; public set; }
    public X509FindType FindType { get; public set; }
    public X509TokenProvider(StoreLocation location, StoreName storeName, string subjectName);
    public X509TokenProvider(StoreLocation location, StoreName storeName, string findValue, X509FindType findType);
    public StoreLocation get_StoreLocation();
    public void set_StoreLocation(StoreLocation value);
    public StoreName get_StoreName();
    public void set_StoreName(StoreName value);
    public string get_FindValue();
    public void set_FindValue(string value);
    public X509FindType get_FindType();
    public void set_FindType(X509FindType value);
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> GetExtensions();
    public virtual X509SecurityToken GetToken();
    public static X509SecurityToken CreateToken(StoreLocation location, StoreName storeName, string subjectName);
    public static X509SecurityToken CreateToken(StoreLocation location, StoreName storeName, string findValue, X509FindType findType);
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader, IDictionary`2<string, Type> extensions);
}
public class Microsoft.Web.Services3.Diagnostics.Configuration.DiagnosticsConfiguration : ConfigurationElement {
    private ConfigurationProperty _trace;
    private ConfigurationProperty _detailedErrors;
    private ConfigurationPropertyCollection _properties;
    private static ReaderWriterLock _inputLock;
    private static ReaderWriterLock _outputLock;
    protected ConfigurationPropertyCollection Properties { get; }
    public bool SendDetailedErrors { get; }
    public ReaderWriterLock InputLock { get; }
    public ReaderWriterLock OutputLock { get; }
    public bool TraceEnabled { get; }
    public string InputFileName { get; }
    public string OutputFileName { get; }
    private static DiagnosticsConfiguration();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_SendDetailedErrors();
    public ReaderWriterLock get_InputLock();
    public ReaderWriterLock get_OutputLock();
    public bool get_TraceEnabled();
    public string get_InputFileName();
    public string get_OutputFileName();
}
public class Microsoft.Web.Services3.Diagnostics.Configuration.TraceConfiguration : ConfigurationElement {
    private static string _receiveFileName;
    private static string _sendFileName;
    private ConfigurationProperty _enabled;
    private ConfigurationProperty _inputFileName;
    private ConfigurationProperty _outputFileName;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    public bool Enabled { get; }
    public string InputFileName { get; }
    public string OutputFileName { get; }
    private static TraceConfiguration();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_Enabled();
    public string get_InputFileName();
    public string get_OutputFileName();
}
public class Microsoft.Web.Services3.Diagnostics.EventLog : object {
    private static EventLog _aLog;
    private static EventLog();
    private static void WriteEntry(string message, EventLogEntryType type);
    public static void WriteError(string message);
    public static void WriteWarning(string message);
    public static void WriteLog(Exception ex);
    public static void WriteFailedFaultProcessingEntry(Pipeline outputPipeline, SoapContext requestContext, Exception originalException, Exception processingFailureException);
}
internal class Microsoft.Web.Services3.Diagnostics.TraceInputFilter : object {
    private string _fileName;
    private FileStream _fileStream;
    private XmlDocument _document;
    private static TraceInputFilter instance;
    public static TraceInputFilter Instance { get; }
    public static TraceInputFilter get_Instance();
    private string GetPath();
    private void OpenLoadExistingFile(string path);
    private void TryCreateFileInitDoc(string path);
    private void Load(string path);
    public void TraceMessage(string messageId, Collection`1<XmlElement> traceEntries);
}
internal class Microsoft.Web.Services3.Diagnostics.TraceOutputFilter : object {
    private string _fileName;
    private FileStream _fileStream;
    private XmlDocument _document;
    private static TraceOutputFilter instance;
    public static TraceOutputFilter Instance { get; }
    public static TraceOutputFilter get_Instance();
    private string GetPath();
    private void OpenLoadExistingFile(string path);
    private void TryCreateFileInitDoc(string path);
    private void Load(string path);
    public void TraceMessage(string messageId, Collection`1<XmlElement> traceEntries);
}
internal class Microsoft.Web.Services3.DnsCache : object {
    private static int _limit;
    private static string _localhostName;
    private static Dictionary`2<string, IPHostEntry> _hostEntriesByName;
    private static Dictionary`2<IPAddress, IPHostEntry> _hostEntriesByAddress;
    private static DnsCache();
    internal static string GetHostName();
    internal static IPHostEntry GetHostEntry(string hostNameOrAddress);
    internal static IPHostEntry GetHostEntry(IPAddress address);
}
internal class Microsoft.Web.Services3.GxaUri : object {
    internal static bool PrefixEquals(Uri fullUri, Uri prefix);
    internal static bool IsAbsoluteUri(Uri uri);
    internal static Uri RemoveQuery(Uri uri);
    private static bool HasNoQuery(Uri uri);
    private static string Append(Uri uri1, Uri uri2);
}
public interface Microsoft.Web.Services3.IPipelineProvider {
    public abstract virtual Pipeline CreateClientPipeline(PipelineCreationContext context);
    public abstract virtual Pipeline CreateServicePipeline(PipelineCreationContext context);
}
internal class Microsoft.Web.Services3.MemberInfoHelper : object {
    internal static object GetCustomAttribute(MemberInfo memberInfo, Type attributeType);
}
internal class Microsoft.Web.Services3.MessagePartHeaders : object {
    private HybridDictionary _headers;
    public MessagePartHeaders(SoapEnvelope envelope);
    public void Add(XmlElement header);
    public bool Contains(XmlQualifiedName qname);
    public XmlElement[] GetHeaders(XmlQualifiedName qname);
}
internal class Microsoft.Web.Services3.Messaging.BufferedInputStream : DelegatedStream {
    private Byte[] preReadBuffer;
    public BufferedInputStream(Stream stream, Byte[] preReadBuffer);
    private bool ReadFromBuffer(Byte[] buffer, int offset, int count, Int32& bytesRead);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult result);
}
public class Microsoft.Web.Services3.Messaging.Configuration.AllowRedirectedResponseConfigElement : ConfigurationElement {
    private ConfigurationProperty _enabled;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal bool Enabled { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal bool get_Enabled();
}
public class Microsoft.Web.Services3.Messaging.Configuration.DefaultPortConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public class Microsoft.Web.Services3.Messaging.Configuration.ExecutionTimeoutConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public class Microsoft.Web.Services3.Messaging.Configuration.IdleTimeoutConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public class Microsoft.Web.Services3.Messaging.Configuration.MaxMessageLengthConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public class Microsoft.Web.Services3.Messaging.Configuration.MessagingConfiguration : ConfigurationElement {
    private ConfigurationProperty _allowRedirectedResponses;
    private ConfigurationProperty _executionTimeout;
    private ConfigurationProperty _maxMessageLength;
    private ConfigurationProperty _transports;
    private ConfigurationProperty _mtom;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    public bool AllowRedirectedResponses { get; }
    public TimeSpan ExecutionTimeout { get; }
    public int MaxMessageLengthInBytes { get; }
    public bool MtomRequireSoapEnvelopeFirst { get; }
    public int MtomMaxMimeParts { get; }
    public MtomReceiveMode MtomReceiveMode { get; }
    public MtomSendMode MtomSendMode { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_AllowRedirectedResponses();
    public TimeSpan get_ExecutionTimeout();
    public int get_MaxMessageLengthInBytes();
    public bool get_MtomRequireSoapEnvelopeFirst();
    public int get_MtomMaxMimeParts();
    public MtomReceiveMode get_MtomReceiveMode();
    public MtomSendMode get_MtomSendMode();
    public void AddTransport(string scheme, Type transport);
    public ISoapTransport GetTransport(string scheme);
}
public class Microsoft.Web.Services3.Messaging.Configuration.MessagingTransportConfiguration : ConfigElementInterceptor {
    private ConfigurationProperty _scheme;
    private ConfigurationProperty _type;
    private ConfigurationProperty _exclusiveAddressUse;
    private ConfigurationProperty _defaultPort;
    private ConfigurationProperty _idleTimeout;
    private ConfigurationProperty _sendTimeout;
    private ConfigurationProperty _receiveTimeout;
    private ConfigurationProperty _noDelay;
    private ConfigurationProperty _connectionLimit;
    private ConfigurationProperty _hosts;
    private ConfigurationPropertyCollection _properties;
    private ISoapTransport _transport;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Scheme { get; }
    internal string TypeName { get; }
    internal ISoapTransport Transport { get; }
    internal MessagingTransportConfiguration(string scheme, string type);
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected virtual void PostDeserialize();
    internal string get_Scheme();
    internal string get_TypeName();
    internal ISoapTransport get_Transport();
    private ISoapTransport LoadTransport(string typeName, XmlNodeList configData);
}
public class Microsoft.Web.Services3.Messaging.Configuration.MessagingTransportsCollection : ConfigurationElementCollection {
    protected bool ThrowOnDuplicate { get; }
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual bool get_ThrowOnDuplicate();
    public void Add(MessagingTransportConfiguration element);
    internal ISoapTransport GetTransport(string scheme);
}
public class Microsoft.Web.Services3.Messaging.Configuration.MtomConfigElement : ConfigurationElement {
    private ConfigurationProperty _sendMode;
    private ConfigurationProperty _receiveMode;
    private ConfigurationProperty _requireSoapEnvelopeFirst;
    private ConfigurationProperty _maxMimeParts;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal MtomReceiveMode ReceiveMode { get; }
    internal MtomSendMode SendMode { get; }
    internal bool RequireSoapEnvelopeFirst { get; }
    internal int MaxMimeParts { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal MtomReceiveMode get_ReceiveMode();
    internal MtomSendMode get_SendMode();
    internal bool get_RequireSoapEnvelopeFirst();
    internal int get_MaxMimeParts();
}
public enum Microsoft.Web.Services3.Messaging.Configuration.MtomReceiveMode : Enum {
    public int value__;
    public static MtomReceiveMode Optional;
    public static MtomReceiveMode Always;
    public static MtomReceiveMode Never;
}
public enum Microsoft.Web.Services3.Messaging.Configuration.MtomSendMode : Enum {
    public int value__;
    public static MtomSendMode On;
    public static MtomSendMode Off;
}
public class Microsoft.Web.Services3.Messaging.Configuration.TimeoutConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public class Microsoft.Web.Services3.Messaging.Configuration.TransportConnectionLimit : ConfigurationElement {
    private ConfigurationProperty _inbound;
    private ConfigurationProperty _outbound;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class Microsoft.Web.Services3.Messaging.Configuration.TransportHosts : ConfigurationElement {
    private ConfigurationProperty _default;
    private ConfigurationProperty _allow;
    private ConfigurationProperty _deny;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Default { get; }
    internal string Allow { get; }
    internal string Deny { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Default();
    internal string get_Allow();
    internal string get_Deny();
}
public class Microsoft.Web.Services3.Messaging.Framing.FramingFormatException : WseSoapHeaderException {
    public FramingFormatException(string message);
    public FramingFormatException(string message, Exception ex);
}
public class Microsoft.Web.Services3.Messaging.Framing.FramingReader : object {
    private bool _closed;
    private FramingRecord _currentRecord;
    private Stream _stream;
    private int _totalBytesRead;
    private int _maxRequestLength;
    public bool CanRead { get; }
    private int MaxRecordLength { get; }
    public FramingReader(Stream stream);
    public FramingReader(Stream stream, int maxRequestLength);
    public bool get_CanRead();
    public FramingRecord ReadRecord();
    private int get_MaxRecordLength();
    public void Close();
    private void UpdateTotalBytesRead(FramingRecord record);
}
public class Microsoft.Web.Services3.Messaging.Framing.FramingRecord : object {
    private static int BaseHeaderSize;
    private static int MaxIdTypeLength;
    private static int PaddingMultiple;
    private static byte Version;
    private static byte VersionMask;
    private static byte FlagMask;
    private FileAccess _mode;
    private Stream _stream;
    private FramingStream _payloadStream;
    private MemoryStream _payloadBufferStream;
    private bool m_chunked;
    private bool m_firstChunk;
    private bool m_startedChunk;
    private bool m_headerWritten;
    private bool m_beginOfMessage;
    private bool m_endOfMessage;
    private bool m_closed;
    private int m_chunkSize;
    private string m_id;
    private string m_type;
    private FramingTypeFormat m_typeFormat;
    private int m_contentLength;
    private int m_bytesReadWritten;
    private int _totalBytesRead;
    private int _maxRecordLength;
    private bool disposed;
    public Stream BodyStream { get; }
    internal bool CanRead { get; }
    internal bool CanWrite { get; }
    public bool Chunked { get; }
    public int ChunkSize { get; public set; }
    public int ContentLength { get; }
    public bool MessageBegin { get; }
    public bool MessageEnd { get; }
    internal int TotalBytesRead { get; }
    public string Type { get; }
    public FramingTypeFormat TypeFormat { get; }
    public string Id { get; }
    internal FramingRecord(Stream stream);
    internal FramingRecord(Stream stream, int maxRecordLength);
    internal FramingRecord(Stream stream, string id, string type, FramingTypeFormat typeFormat, bool beginOfMessage, int contentLength, int chunkSize, bool endOfMessage);
    public void Dispose();
    private void Dispose(bool isDisposing);
    public Stream get_BodyStream();
    internal bool get_CanRead();
    internal bool get_CanWrite();
    public bool get_Chunked();
    public int get_ChunkSize();
    public void set_ChunkSize(int value);
    public int get_ContentLength();
    public bool get_MessageBegin();
    public bool get_MessageEnd();
    internal int get_TotalBytesRead();
    public string get_Type();
    public FramingTypeFormat get_TypeFormat();
    public string get_Id();
    public void Close();
    internal void Close(bool endOfMessage);
    internal void ReadHeader();
    private void CheckValid(string type, string id, FramingTypeFormat typeFormat);
    private void ForceRead(Stream stream, Byte[] buffer, int length);
    internal int ReadBody(Byte[] buffer, int offset, int count);
    internal void SetType(string type, FramingTypeFormat typeFormat);
    internal void WriteHeader(bool endOfRecord, long contentLength);
    private static int PaddedCount(int byteCount);
    internal void WriteMessageEndRecord();
    internal void WriteBody(Byte[] buffer, int offset, int count);
    private void WritePadding(Stream stream, int bytesWritten);
    private void ReadPadding(Stream stream, int bytesRead);
    internal void WriteChunkedPayload(bool endOfRecord, bool endOfMessage);
    internal void WriteChunkedPayload(bool endOfRecord, bool endOfMessage, Byte[] bytes, int offset, int count);
    private void UpdateTotalBytesRead(int bytesRead);
}
internal class Microsoft.Web.Services3.Messaging.Framing.FramingStream : Stream {
    private FramingRecord _dimeRecord;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal FramingStream(FramingRecord dimeRecord);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[FlagsAttribute]
public enum Microsoft.Web.Services3.Messaging.Framing.FramingTypeFormat : Enum {
    public int value__;
    public static FramingTypeFormat Unchanged;
    public static FramingTypeFormat MediaType;
    public static FramingTypeFormat AbsoluteUri;
    public static FramingTypeFormat Unknown;
    public static FramingTypeFormat None;
}
public class Microsoft.Web.Services3.Messaging.Framing.FramingWriter : object {
    private static int DefaultChunkSize;
    private Stream _stream;
    private FramingRecord _currentRecord;
    private bool _closed;
    private bool _messageBegin;
    private bool _lastRecordSeen;
    private int _chunkSize;
    public int ChunkSize { get; public set; }
    public FramingWriter(Stream stream);
    public FramingRecord NewRecord();
    public FramingRecord NewRecord(string id, string type, FramingTypeFormat typeFormat);
    public FramingRecord NewRecord(string id, string type, FramingTypeFormat typeFormat, int contentLength);
    public FramingRecord LastRecord();
    public FramingRecord LastRecord(string id, string type, FramingTypeFormat typeFormat);
    public FramingRecord LastRecord(string id, string type, FramingTypeFormat typeFormat, int contentLength);
    private FramingRecord CreateRecord(string id, string type, FramingTypeFormat typeFormat, int contentLength, bool lastRecord);
    public int get_ChunkSize();
    public void set_ChunkSize(int value);
    public void Close();
}
public interface Microsoft.Web.Services3.Messaging.ISoapChannel {
    public SoapChannelCapabilities Capabilities { get; }
    public bool IsClosed { get; }
    public abstract virtual SoapChannelCapabilities get_Capabilities();
    public abstract virtual void Close();
    public abstract virtual void add_Closed(EventHandler value);
    public abstract virtual void remove_Closed(EventHandler value);
    public abstract virtual bool get_IsClosed();
}
public interface Microsoft.Web.Services3.Messaging.ISoapDuplexChannel {
}
public interface Microsoft.Web.Services3.Messaging.ISoapFormatter {
    public abstract virtual string GetContentType(SoapProtocolVersion soapVersion);
    public abstract virtual bool MatchContentType(string contentType);
    public abstract virtual void Serialize(SoapEnvelope envelope, Stream stream);
    public abstract virtual SoapEnvelope Deserialize(Stream stream);
}
public interface Microsoft.Web.Services3.Messaging.ISoapInputChannel {
    public EndpointReference LocalEndpoint { get; }
    public abstract virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public abstract virtual SoapEnvelope EndReceive(IAsyncResult result);
    public abstract virtual EndpointReference get_LocalEndpoint();
    public abstract virtual SoapEnvelope Receive();
}
public interface Microsoft.Web.Services3.Messaging.ISoapOutputChannel {
    public EndpointReference RemoteEndpoint { get; }
    public abstract virtual IAsyncResult BeginSend(SoapEnvelope message, AsyncCallback callback, object state);
    public abstract virtual void EndSend(IAsyncResult result);
    public abstract virtual EndpointReference get_RemoteEndpoint();
    public abstract virtual void Send(SoapEnvelope message);
}
public interface Microsoft.Web.Services3.Messaging.ISoapTransport {
    public string SoapBindingTransportUri { get; }
    public abstract virtual ISoapInputChannel GetInputChannel(EndpointReference endpoint, SoapChannelCapabilities capabilities);
    public abstract virtual ISoapOutputChannel GetOutputChannel(EndpointReference endpoint, SoapChannelCapabilities capabilities);
    public abstract virtual string get_SoapBindingTransportUri();
}
internal class Microsoft.Web.Services3.Messaging.MessageOptimizationState : object {
    private bool _shouldOptimize;
    public bool ShouldOptimize { get; public set; }
    public MessageOptimizationState(bool shouldOptimize);
    public bool get_ShouldOptimize();
    public void set_ShouldOptimize(bool value);
}
internal class Microsoft.Web.Services3.Messaging.MtomNotMatchedException : Exception {
}
[AttributeUsageAttribute("4")]
public class Microsoft.Web.Services3.Messaging.SoapActorAttribute : Attribute {
    private static string WildcardActor;
    private Uri _actor;
    public Uri Actor { get; }
    public SoapActorAttribute(string actor);
    public Uri get_Actor();
}
public class Microsoft.Web.Services3.Messaging.SoapAspNetRequestChannel : SoapChannel {
    private HttpContext _context;
    private EndpointReference _localEndpoint;
    private EndpointReference _remoteEndpoint;
    private SoapAspNetTransport _transport;
    public EndpointReference LocalEndpoint { get; }
    public EndpointReference RemoteEndpoint { get; }
    internal SoapAspNetRequestChannel(EndpointReference endpoint, EndpointReference remoteEP, SoapAspNetTransport transport);
    public virtual void Close();
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual SoapEnvelope EndReceive(IAsyncResult result);
    public sealed virtual EndpointReference get_LocalEndpoint();
    public sealed virtual SoapEnvelope Receive();
    public sealed virtual IAsyncResult BeginSend(SoapEnvelope message, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual EndpointReference get_RemoteEndpoint();
    public sealed virtual void Send(SoapEnvelope message);
    public void Close(int statusCode);
    private SoapEnvelope DeserializeMessage(Stream stream, string contentType);
    private void SerializeMessage(SoapEnvelope message, Stream stream);
}
public class Microsoft.Web.Services3.Messaging.SoapAspNetTransport : SoapTransport {
    private static string soapBindingTransportUri;
    public static string UriScheme;
    private SoapOutputChannelCollection _outputChannels;
    public string SoapBindingTransportUri { get; }
    public SoapAspNetTransport(XmlNodeList configData);
    private static SoapAspNetTransport();
    [ConditionalAttribute("DEBUG")]
internal static void Debug(string text);
    internal ISoapInputChannel GetInputChannel(Uri address);
    public sealed virtual ISoapInputChannel GetInputChannel(EndpointReference endpoint, SoapChannelCapabilities capabilities);
    public sealed virtual ISoapOutputChannel GetOutputChannel(EndpointReference endpoint, SoapChannelCapabilities capabilities);
    public sealed virtual string get_SoapBindingTransportUri();
    private EndpointReference GetRemoteEndpoint(HttpContext context);
    private void OnChannelClosed(object sender, EventArgs args);
}
public abstract class Microsoft.Web.Services3.Messaging.SoapChannel : object {
    private SoapChannelCapabilities _capabilities;
    private int _closed;
    private EventHandler Closed;
    public SoapChannelCapabilities Capabilities { get; }
    public bool IsClosed { get; }
    protected SoapChannel(SoapChannelCapabilities capabilities);
    public sealed virtual SoapChannelCapabilities get_Capabilities();
    public virtual void Close();
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public virtual bool get_IsClosed();
    protected void OnClosed();
}
[FlagsAttribute]
public enum Microsoft.Web.Services3.Messaging.SoapChannelCapabilities : Enum {
    public int value__;
    public static SoapChannelCapabilities None;
    public static SoapChannelCapabilities ActivelyListening;
}
public abstract class Microsoft.Web.Services3.Messaging.SoapClient : SoapSender {
    private static int _defaultTimeout;
    private SoapProtocolVersion _soapVersion;
    private int _timeout;
    private HybridDictionary _actionTable;
    private HybridDictionary _responseActionTable;
    private SoapServiceAttribute _soapServiceAttribute;
    public static int DefaultTimeout { get; public set; }
    protected SoapServiceAttribute SoapServiceAttribute { get; }
    public SoapProtocolVersion SoapVersion { get; public set; }
    public int Timeout { get; public set; }
    protected SoapClient(Uri destination);
    protected SoapClient(EndpointReference destination);
    private static SoapClient();
    public static int get_DefaultTimeout();
    public static void set_DefaultTimeout(int value);
    protected IAsyncResult BeginSendOneWay(string methodname, object obj, AsyncCallback callback, object state);
    protected IAsyncResult BeginSendOneWay(string methodname, SoapEnvelope envelope, AsyncCallback callback, object state);
    protected IAsyncResult BeginSendRequestResponse(string methodname, object obj, AsyncCallback callback, object state);
    protected IAsyncResult BeginSendRequestResponse(string methodname, SoapEnvelope envelope, AsyncCallback callback, object state);
    private void BuildActionTable(Type soapClientType);
    protected void EndSendOneWay(IAsyncResult result);
    protected SoapEnvelope EndSendRequestResponse(IAsyncResult result);
    protected void SendOneWay(string methodname, object obj);
    protected void SendOneWay(string methodname, SoapEnvelope envelope);
    protected SoapEnvelope SendRequestResponse(string methodname, object obj);
    protected SoapEnvelope SendRequestResponse(string methodname, SoapEnvelope envelope);
    private void SetBodyObject(SoapEnvelope envelope, object obj);
    protected SoapServiceAttribute get_SoapServiceAttribute();
    public SoapProtocolVersion get_SoapVersion();
    public void set_SoapVersion(SoapProtocolVersion value);
    public int get_Timeout();
    public void set_Timeout(int value);
    private void VerifyRequestSoapVersion(SoapEnvelope request);
    private void VerifyResponseAction(string methodname, SoapEnvelope response);
}
public class Microsoft.Web.Services3.Messaging.SoapFramingFormatter : object {
    private sealed virtual override string Microsoft.Web.Services3.Messaging.ISoapFormatter.GetContentType(SoapProtocolVersion soapVersion);
    private sealed virtual override bool Microsoft.Web.Services3.Messaging.ISoapFormatter.MatchContentType(string contentType);
    private sealed virtual override void Microsoft.Web.Services3.Messaging.ISoapFormatter.Serialize(SoapEnvelope envelope, Stream stream);
    private sealed virtual override SoapEnvelope Microsoft.Web.Services3.Messaging.ISoapFormatter.Deserialize(Stream stream);
}
public class Microsoft.Web.Services3.Messaging.SoapHttpChannelOptions : object {
    private string _agent;
    private bool _allowAutoRedirect;
    private X509CertificateCollection _certificates;
    private string _connectionGroupName;
    private string _connection;
    private CookieContainer _cookies;
    private ICredentials _credentials;
    private bool _keepAlive;
    private bool _preAuthenticate;
    private IWebProxy _proxy;
    private bool _unsafeSharing;
    private int _timeout;
    private bool _sendChunked;
    public bool AllowAutoRedirect { get; public set; }
    public X509CertificateCollection ClientCertificates { get; }
    public string Connection { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public CookieContainer CookieContainer { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool KeepAlive { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public bool SendChunked { get; public set; }
    public int Timeout { get; public set; }
    public bool UnsafeAuthenticatedConnectionSharing { get; public set; }
    public string UserAgent { get; public set; }
    public bool get_AllowAutoRedirect();
    public void set_AllowAutoRedirect(bool value);
    public X509CertificateCollection get_ClientCertificates();
    public string get_Connection();
    public void set_Connection(string value);
    public string get_ConnectionGroupName();
    public void set_ConnectionGroupName(string value);
    public CookieContainer get_CookieContainer();
    public void set_CookieContainer(CookieContainer value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public bool get_PreAuthenticate();
    public void set_PreAuthenticate(bool value);
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    public int get_Timeout();
    public void set_Timeout(int value);
    public bool get_UnsafeAuthenticatedConnectionSharing();
    public void set_UnsafeAuthenticatedConnectionSharing(bool value);
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public void ExportTo(HttpWebRequest webRequest);
    public void ImportFrom(HttpWebRequest webRequest);
    public void ImportFrom(SoapHttpChannelOptions options);
}
public class Microsoft.Web.Services3.Messaging.SoapHttpInputChannel : SoapInputChannel {
    private SoapHttpTransport _transport;
    internal SoapHttpInputChannel(EndpointReference endpoint, SoapHttpTransport transport);
}
public class Microsoft.Web.Services3.Messaging.SoapHttpOutputChannel : SoapOutputChannel {
    private SoapHttpTransport _transport;
    private SoapHttpChannelOptions _options;
    public SoapHttpChannelOptions Options { get; }
    internal SoapHttpOutputChannel(EndpointReference endpoint, SoapHttpTransport transport);
    public virtual void Send(SoapEnvelope message);
    public SoapHttpChannelOptions get_Options();
}
public class Microsoft.Web.Services3.Messaging.SoapHttpRouter : object {
    internal static int DefaultCopyBufferSize;
    private Pipeline forwardRequestPipeline;
    private Pipeline requestPipeline;
    private bool System.Web.IHttpHandler.IsReusable { get; }
    private sealed virtual override bool System.Web.IHttpHandler.get_IsReusable();
    private sealed virtual override void System.Web.IHttpHandler.ProcessRequest(HttpContext context);
    private sealed virtual override IAsyncResult System.Web.IHttpAsyncHandler.BeginProcessRequest(HttpContext context, AsyncCallback callback, object extraData);
    private sealed virtual override void System.Web.IHttpAsyncHandler.EndProcessRequest(IAsyncResult result);
    protected virtual Policy GetForwardRequestPolicy();
    protected virtual Policy GetRequestPolicy();
    protected virtual Pipeline CreateForwardRequestPipeline();
    protected virtual Pipeline CreateRequestPipeline();
    internal Pipeline GetForwardRequestPipeline();
    internal Pipeline GetRequestPipeline();
    protected virtual Uri ProcessRequestMessage(SoapEnvelope message);
    protected virtual void ProcessResponseMessage(SoapEnvelope message);
}
public class Microsoft.Web.Services3.Messaging.SoapHttpTransport : SoapTransport {
    private static string soapBindingTransportUri;
    public string SoapBindingTransportUri { get; }
    public SoapHttpTransport(XmlNodeList configData);
    [ConditionalAttribute("DEBUG")]
internal static void Debug(string text);
    public virtual ISoapInputChannel GetInputChannel(EndpointReference endpoint, SoapChannelCapabilities capabilities);
    public virtual ISoapOutputChannel GetOutputChannel(EndpointReference endpoint, SoapChannelCapabilities capabilities);
    public sealed virtual string get_SoapBindingTransportUri();
    private void OnChannelClosed(object sender, EventArgs args);
    private Encoding GetEncoding(string contentType);
    private string ReadResponse(WebResponse response, Stream stream);
    private string CreateResponseExceptionString(WebResponse response, Stream stream);
    internal void Send(SoapEnvelope message, EndpointReference destination, SoapHttpChannelOptions options);
    private bool IsEmptyResponse(HttpWebResponse webResponse, Stream& responseStream);
    private void OnBadResponseContentType(HttpWebResponse webResponse, Stream responseStream, string expectedContentType);
    private SoapEnvelope DeserializePlainHttpResponse(HttpWebResponse webResponse, Stream responseStream, SoapProtocolVersion requestSoapVersion);
    private SoapEnvelope DeserializeMtomHttpResponse(HttpWebResponse webResponse, Stream responseStream);
    private static bool IsSupportedContentType(string contentType);
    private static bool SendHttpRequest(SoapEnvelope message, HttpWebRequest webRequest);
    private static void SendMtomHttpRequest(SoapEnvelope message, HttpWebRequest webRequest);
    private static void SendPlainHttpRequest(SoapEnvelope message, HttpWebRequest webRequest);
}
public abstract class Microsoft.Web.Services3.Messaging.SoapInputChannel : SoapChannel {
    private EndpointReference _endpoint;
    private object _syncRoot;
    private Queue _queue;
    private ManualResetEvent _waitHandle;
    public EndpointReference LocalEndpoint { get; }
    protected SoapInputChannel(EndpointReference endpoint);
    public virtual void Close();
    public virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public virtual SoapEnvelope EndReceive(IAsyncResult result);
    public virtual EndpointReference get_LocalEndpoint();
    public virtual SoapEnvelope Receive();
    public virtual void Enqueue(SoapEnvelope message);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Messaging.SoapInputChannelCollection : object {
    private HybridDictionary _channels;
    private int _count;
    public ISoapInputChannel Item { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public ISoapInputChannel get_Item(EndpointReference endpoint);
    public void Add(ISoapInputChannel channel);
    public void Clear();
    public bool Contains(ISoapInputChannel channel);
    public int get_Count();
    public IEnumerator GetEnumerator(Uri address);
    public void Remove(ISoapInputChannel channel);
    public object get_SyncRoot();
}
public class Microsoft.Web.Services3.Messaging.SoapMessageQueue : object {
    private int _count;
    private bool _disposed;
    private Queue _queue;
    private object _syncRoot;
    private AutoResetEvent _waitHandle;
    public int Count { get; }
    public object SyncRoot { get; }
    public WaitHandle WaitHandle { get; }
    protected virtual void Finalize();
    public IAsyncResult BeginDequeue(AsyncCallback callback, object state);
    public int get_Count();
    public object Dequeue();
    private object DequeueInternal();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public object EndDequeue(IAsyncResult ar);
    public void Enqueue(object obj);
    public object get_SyncRoot();
    public WaitHandle get_WaitHandle();
}
[AttributeUsageAttribute("64")]
public class Microsoft.Web.Services3.Messaging.SoapMethodAttribute : Attribute {
    private string _action;
    private string _responseAction;
    private string _uniqueMethodName;
    public string SoapAction { get; }
    public string ResponseAction { get; public set; }
    public string UniqueMethodName { get; public set; }
    public SoapMethodAttribute(string soapAction);
    public string get_SoapAction();
    public string get_ResponseAction();
    public void set_ResponseAction(string value);
    public string get_UniqueMethodName();
    public void set_UniqueMethodName(string value);
}
public abstract class Microsoft.Web.Services3.Messaging.SoapMethodInvoker : object {
    public bool OneWay { get; }
    public abstract virtual SoapEnvelope Invoke(SoapEnvelope message);
    public void InvokeBackground(SoapEnvelope message);
    private void OnInvokeBackground(object state);
    public abstract virtual bool get_OneWay();
}
public class Microsoft.Web.Services3.Messaging.SoapMtomFormatter : object {
    private sealed virtual override string Microsoft.Web.Services3.Messaging.ISoapFormatter.GetContentType(SoapProtocolVersion soapVersion);
    private sealed virtual override bool Microsoft.Web.Services3.Messaging.ISoapFormatter.MatchContentType(string contentType);
    private sealed virtual override void Microsoft.Web.Services3.Messaging.ISoapFormatter.Serialize(SoapEnvelope envelope, Stream stream);
    private static void WriteStringToStream(Stream s, string data, Encoding enc);
    private sealed virtual override SoapEnvelope Microsoft.Web.Services3.Messaging.ISoapFormatter.Deserialize(Stream stream);
    public SoapEnvelope DeserializeMessage(Stream stream, string contentType);
    public void SerializeMessage(Stream stream, SoapEnvelope envelope, string mimeBoundary, string startId);
}
internal class Microsoft.Web.Services3.Messaging.SoapMtomFormatterWithFraming : object {
    private sealed virtual override string Microsoft.Web.Services3.Messaging.ISoapFormatter.GetContentType(SoapProtocolVersion soapVersion);
    private sealed virtual override bool Microsoft.Web.Services3.Messaging.ISoapFormatter.MatchContentType(string contentType);
    private sealed virtual override void Microsoft.Web.Services3.Messaging.ISoapFormatter.Serialize(SoapEnvelope envelope, Stream stream);
    private sealed virtual override SoapEnvelope Microsoft.Web.Services3.Messaging.ISoapFormatter.Deserialize(Stream stream);
}
public abstract class Microsoft.Web.Services3.Messaging.SoapOutputChannel : SoapChannel {
    private EndpointReference _endpoint;
    public EndpointReference RemoteEndpoint { get; }
    protected SoapOutputChannel(EndpointReference endpoint);
    public virtual IAsyncResult BeginSend(SoapEnvelope message, AsyncCallback callback, object state);
    public virtual void EndSend(IAsyncResult result);
    public virtual EndpointReference get_RemoteEndpoint();
    public abstract virtual void Send(SoapEnvelope message);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Messaging.SoapOutputChannelCollection : object {
    private HybridDictionary _channels;
    private int _count;
    public ISoapOutputChannel Item { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public ISoapOutputChannel get_Item(EndpointReference endpoint);
    public void Add(ISoapOutputChannel channel);
    public void Clear();
    public bool Contains(ISoapOutputChannel channel);
    public int get_Count();
    public IEnumerator GetEnumerator(Uri address);
    public void Remove(ISoapOutputChannel channel);
    public object get_SyncRoot();
}
public class Microsoft.Web.Services3.Messaging.SoapPlainFormatter : object {
    private sealed virtual override string Microsoft.Web.Services3.Messaging.ISoapFormatter.GetContentType(SoapProtocolVersion soapVersion);
    private sealed virtual override bool Microsoft.Web.Services3.Messaging.ISoapFormatter.MatchContentType(string contentType);
    private sealed virtual override void Microsoft.Web.Services3.Messaging.ISoapFormatter.Serialize(SoapEnvelope envelope, Stream stream);
    private sealed virtual override SoapEnvelope Microsoft.Web.Services3.Messaging.ISoapFormatter.Deserialize(Stream stream);
}
public abstract class Microsoft.Web.Services3.Messaging.SoapPort : object {
    private Pipeline _pipeline;
    public Pipeline Pipeline { get; public set; }
    public virtual Pipeline get_Pipeline();
    public virtual void set_Pipeline(Pipeline value);
    protected abstract virtual bool FilterMessage(SoapEnvelope envelope);
}
public abstract class Microsoft.Web.Services3.Messaging.SoapReceiver : SoapPort {
    public static string RequestDescriptionAction;
    private static HybridDictionary _receiverTypes;
    private static ReaderWriterLock _receiverTypesLock;
    private MessageDispatch _dispatchModel;
    private SoapReceiverType _receiverType;
    private bool defaultPipeline;
    internal bool IsDefaultPipeline { get; }
    public Uri Actor { get; }
    public MessageDispatch DispatchModel { get; public set; }
    public bool IsReusable { get; }
    internal SoapReceiverType ReceiverType { get; }
    protected SoapReceiver(Type targetType);
    private static SoapReceiver();
    internal bool get_IsDefaultPipeline();
    private void InitializePipeline(Type serverType);
    public void SetPolicy(Policy policy);
    public void SetPolicy(string policyName);
    public Uri get_Actor();
    public void DispatchMessage(SoapEnvelope message);
    public MessageDispatch get_DispatchModel();
    public void set_DispatchModel(MessageDispatch value);
    internal virtual SoapReceiverType GetSoapReceiverType();
    public virtual bool get_IsReusable();
    protected virtual void PreProcessAspNetMessage(SoapEnvelope message);
    public virtual void ProcessMessage(SoapEnvelope message);
    protected virtual void ProcessMessageHeaders(SoapEnvelope message);
    protected virtual void ProcessAspNetNonSoapRequest(HttpContext httpContext);
    protected virtual void ProcessAspNetSoapRequest(HttpContext httpContext);
    public virtual void ProcessRequest(HttpContext context);
    protected virtual bool FilterMessage(SoapEnvelope envelope);
    protected virtual ServiceDescription GetDescription(Uri location);
    protected virtual Type GetTargetType();
    protected virtual void Receive(SoapEnvelope envelope);
    protected virtual void Receive(SoapEnvelope envelope, Exception filterException);
    internal SoapReceiverType get_ReceiverType();
    protected virtual void SetActor(SoapEnvelope request);
    protected virtual SoapMethodInvoker RouteRequest(SoapEnvelope request);
    private void SendFault(SoapEnvelope request, Exception ex);
    private void ThrowMismatchException(SoapProtocolVersion expected);
    private void VerifySoapVersion(SoapEnvelope request);
}
public class Microsoft.Web.Services3.Messaging.SoapReceivers : object {
    private static Hashtable _channels;
    private static Hashtable _receivers;
    private static object _syncRoot;
    private static ThreadTimeoutManager _timeoutManager;
    public static int Count { get; }
    public static object SyncRoot { get; }
    private static SoapReceivers();
    public static object Receiver(EndpointReference endpoint);
    public static void Add(EndpointReference endpoint, object receiver);
    public static void Add(EndpointReference endpoint, object receiver, bool passive);
    public static void Add(EndpointReference endpoint, Type receiver);
    public static void Add(EndpointReference endpoint, Type receiver, bool passive);
    private static void AddReceiver(EndpointReference endpoint, object receiver, bool passive);
    public static void Clear();
    public static bool Contains(EndpointReference endpoint);
    public static int get_Count();
    public static IEnumerator GetEnumerator();
    private static void OnReceiveComplete(IAsyncResult ar);
    public static void Remove(EndpointReference endpoint);
    public static object get_SyncRoot();
}
internal class Microsoft.Web.Services3.Messaging.SoapReceiverType : object {
    private SoapActorAttribute _actorAttribute;
    private Type _receiverType;
    public Uri Actor { get; }
    public bool IsActorValidationEnabled { get; }
    public Type ReceiverType { get; }
    public SoapReceiverType(Type type);
    public virtual Uri get_Actor();
    public virtual bool get_IsActorValidationEnabled();
    protected virtual void ProcessAttribute(object attribute);
    public Type get_ReceiverType();
}
public class Microsoft.Web.Services3.Messaging.SoapSender : SoapPort {
    private EndpointReference _destination;
    private ISoapOutputChannel _channel;
    private bool defaultPipeline;
    private bool _requireMtom;
    private StateManager _sessionState;
    internal bool IsDefaultPipeline { get; }
    public EndpointReference Destination { get; public set; }
    public bool RequireMtom { get; public set; }
    public StateManager SessionState { get; public set; }
    public ISoapOutputChannel Channel { get; }
    public SoapSender(Uri destination);
    public SoapSender(EndpointReference destination);
    internal bool get_IsDefaultPipeline();
    private void InitializePipeline();
    public void SetPolicy(Policy policy);
    public void SetPolicy(string policyName);
    public virtual IAsyncResult BeginSend(SoapEnvelope envelope, AsyncCallback callback, object state);
    public virtual void EndSend(IAsyncResult result);
    public EndpointReference get_Destination();
    public void set_Destination(EndpointReference value);
    protected virtual bool FilterMessage(SoapEnvelope envelope);
    public bool get_RequireMtom();
    public void set_RequireMtom(bool value);
    public virtual void Send(SoapEnvelope envelope);
    public StateManager get_SessionState();
    public void set_SessionState(StateManager value);
    public ISoapOutputChannel get_Channel();
}
public class Microsoft.Web.Services3.Messaging.SoapService : SoapReceiver {
    protected virtual ServiceDescription GetDescription(Uri location);
    internal virtual SoapReceiverType GetSoapReceiverType();
    [SoapMethodAttribute("http://schemas.microsoft.com/wse/2003/06/RequestDescription")]
public virtual SoapEnvelope RequestDescription(SoapEnvelope message);
    protected virtual SoapMethodInvoker RouteRequest(SoapEnvelope request);
}
[AttributeUsageAttribute("4")]
public class Microsoft.Web.Services3.Messaging.SoapServiceAttribute : Attribute {
    private string _targetNamespace;
    public string TargetNamespace { get; }
    public SoapServiceAttribute(string targetNamespace);
    public string get_TargetNamespace();
}
public class Microsoft.Web.Services3.Messaging.SoapServiceMethodInvoker : SoapMethodInvoker {
    private SoapReceiver _service;
    private MethodInfo _method;
    private string _responseAction;
    public bool OneWay { get; }
    public string ResponseAction { get; public set; }
    public SoapServiceMethodInvoker(SoapReceiver service, MethodInfo method);
    public virtual SoapEnvelope Invoke(SoapEnvelope message);
    public virtual bool get_OneWay();
    public string get_ResponseAction();
    public void set_ResponseAction(string value);
}
internal class Microsoft.Web.Services3.Messaging.SoapServiceType : SoapReceiverType {
    private HybridDictionary _actionTable;
    private HybridDictionary _responseActionTable;
    private SoapServiceAttribute _serviceAttribute;
    public IDictionary ActionTable { get; }
    public IDictionary ResponseActionTable { get; }
    public string TargetNamespace { get; }
    public SoapServiceType(Type type);
    public IDictionary get_ActionTable();
    public IDictionary get_ResponseActionTable();
    private void BuildActionTable();
    protected virtual void ProcessAttribute(object attribute);
    public virtual string get_TargetNamespace();
}
public class Microsoft.Web.Services3.Messaging.SoapTcpActiveInputChannel : SoapTcpInputChannel {
    private IPEndPoint _localEP;
    internal IPEndPoint LocalEP { get; }
    internal SoapTcpActiveInputChannel(EndpointReference endpoint, IPEndPoint localEP, SoapTcpTransport transport);
    internal IPEndPoint get_LocalEP();
}
internal class Microsoft.Web.Services3.Messaging.SoapTcpAddressMask : object {
    private Byte[] _maskBytes;
    private int _length;
    internal SoapTcpAddressMask(IPAddress address, int length);
    private Byte[] BuildMask(Byte[] bytes, int length);
    internal bool Matches(IPAddress address);
}
internal class Microsoft.Web.Services3.Messaging.SoapTcpConnection : object {
    private static int WSABASEERR;
    private static int WSAECONNABORTED;
    private static int WSAECONNRESET;
    private Uri _localEndpoint;
    private Uri _remoteEndpoint;
    private bool _isOutbound;
    private int _isConnected;
    private ISoapFormatter _formatter;
    private string _hostname;
    private SoapTcpListener _listener;
    private SoapTcpTransportOptions _options;
    private int _port;
    private Socket _socket;
    private SoapTcpNetworkStream _stream;
    private object _syncRoot;
    private DateTime _idleExpiry;
    private DateTime _receiveExpiry;
    private DateTime _sendExpiry;
    private object _serializeLock;
    private object _deserializeLock;
    internal bool Connected { get; }
    internal bool IsOutbound { get; }
    internal Uri RemoteEndpoint { get; }
    internal SoapTcpConnection(Uri remoteEndpoint, SoapTcpTransportOptions options, ISoapFormatter formatter);
    internal SoapTcpConnection(SoapTcpListener listener, Socket socket, SoapTcpTransportOptions options, ISoapFormatter formatter);
    protected virtual void Finalize();
    internal bool get_Connected();
    internal IAsyncResult BeginReceive(AsyncCallback callback, object state);
    internal SoapEnvelope EndReceive(IAsyncResult ar);
    internal void Close();
    internal void Close(bool force);
    internal void Closed();
    private void Connect();
    private SoapEnvelope DeserializeMessage();
    internal bool IsExpired(DateTime now);
    internal bool get_IsOutbound();
    internal Uri get_RemoteEndpoint();
    internal void Send(SoapEnvelope envelope);
    private void SerializeMessage(SoapEnvelope envelope);
    private void SetReceiveTimeout();
    private void SetSendTimeout();
    private void ClearReceiveTimeout();
    private void ClearSendTimeout();
    internal void UpdateIdleTimeout();
}
public abstract class Microsoft.Web.Services3.Messaging.SoapTcpInputChannel : SoapInputChannel {
    private SoapTcpTransport _transport;
    protected SoapTcpInputChannel(EndpointReference endpoint, SoapTcpTransport transport);
    public virtual void Close();
}
internal class Microsoft.Web.Services3.Messaging.SoapTcpListener : object {
    private static int WSABASEERR;
    private static int WSAECONNABORTED;
    private static int WSAECONNRESET;
    private bool _active;
    private ArrayList _connections;
    private SoapTcpTransportOptions _options;
    private int _refCount;
    private IPEndPoint _localEP;
    private Socket _socket;
    private object _syncRoot;
    internal bool Active { get; }
    internal IPEndPoint LocalEndPoint { get; }
    internal SoapTcpListener(int port, SoapTcpTransportOptions options);
    internal SoapTcpListener(IPAddress address, int port, SoapTcpTransportOptions options);
    internal SoapTcpListener(IPEndPoint endpoint, SoapTcpTransportOptions options);
    protected virtual void Finalize();
    internal bool get_Active();
    internal void AddConnection(SoapTcpConnection connection);
    internal void AddReference();
    internal IAsyncResult BeginAccept(AsyncCallback callback, object state);
    internal Socket EndAccept(IAsyncResult ar);
    internal IPEndPoint get_LocalEndPoint();
    internal int ReleaseReference();
    internal void RemoveConnection(SoapTcpConnection connection);
    internal void Start();
    internal void Stop();
}
internal class Microsoft.Web.Services3.Messaging.SoapTcpNetworkStream : Stream {
    private Socket _socket;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal SoapTcpNetworkStream(Socket socket);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual long get_Length();
    public virtual void SetLength(long value);
    public virtual void Close();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
}
public class Microsoft.Web.Services3.Messaging.SoapTcpOutputChannel : SoapOutputChannel {
    private SoapTcpTransport _transport;
    internal SoapTcpOutputChannel(EndpointReference endpoint, SoapTcpTransport transport);
    public virtual void Send(SoapEnvelope message);
}
public class Microsoft.Web.Services3.Messaging.SoapTcpPassiveInputChannel : SoapTcpInputChannel {
    internal SoapTcpPassiveInputChannel(EndpointReference endpoint, SoapTcpTransport transport);
}
[FlagsAttribute]
internal enum Microsoft.Web.Services3.Messaging.SoapTcpSocketEvents : Enum {
    public int value__;
    public static SoapTcpSocketEvents NONE;
    public static SoapTcpSocketEvents FD_READ;
    public static SoapTcpSocketEvents FD_WRITE;
    public static SoapTcpSocketEvents FD_OOB;
    public static SoapTcpSocketEvents FD_ACCEPT;
    public static SoapTcpSocketEvents FD_CONNECT;
    public static SoapTcpSocketEvents FD_CLOSE;
}
public class Microsoft.Web.Services3.Messaging.SoapTcpTransport : SoapTransport {
    private static string soapBindingTransportUri;
    public static string UriScheme;
    private ISoapFormatter _formatter;
    private ArrayList _hostAddresses;
    private string _longHostName;
    private string _shortHostName;
    private Hashtable _listeners;
    private Hashtable _connections;
    private int _outboundCount;
    private int _inboundCount;
    private Timer _timer;
    private int _timerInterval;
    private SoapTcpTransportOptions _options;
    private bool disposed;
    public string SoapBindingTransportUri { get; }
    public SoapTcpTransportOptions Options { get; }
    public SoapTcpTransport(XmlNodeList configData);
    private static SoapTcpTransport();
    [ConditionalAttribute("DEBUG")]
internal static void Debug(string text);
    public sealed virtual void Dispose();
    private void Dispose(bool isDisposing);
    public sealed virtual ISoapInputChannel GetInputChannel(EndpointReference endpoint, SoapChannelCapabilities capabilities);
    public sealed virtual ISoapOutputChannel GetOutputChannel(EndpointReference endpoint, SoapChannelCapabilities capabilities);
    public sealed virtual string get_SoapBindingTransportUri();
    private bool CheckAccess(IPAddress address);
    private bool CheckAccessMasks(IPAddress address, ArrayList masks);
    internal void CloseInputChannel(SoapTcpInputChannel channel);
    private IPEndPoint GetLocalIPEndPoint(Uri transportAddress);
    private Uri GetCanonicalAddress(Uri to);
    private SoapTcpConnection GetConnection(Uri destination);
    private SoapTcpConnection CreateConnection(Uri transportAddress);
    private void OnAcceptComplete(IAsyncResult ar);
    private void OnProcessExit(object sender, EventArgs args);
    private void OnReceiveComplete(IAsyncResult ar);
    private void OnTimerElapsed(object sender, ElapsedEventArgs args);
    private void ParseHosts(XmlElement element);
    private ArrayList ParseHostsList(string list);
    private void PurgeConnections();
    public SoapTcpTransportOptions get_Options();
    internal void Send(SoapEnvelope envelope, EndpointReference destination);
    [ConditionalAttribute("DEBUG")]
private static void SendDebugHelper(SoapEnvelope envelope);
    private void ResetIdleTimer();
}
public class Microsoft.Web.Services3.Messaging.SoapTcpTransportOptions : object {
    private bool _defaultAllow;
    private int _defaultPort;
    private bool _exclusiveUse;
    private ArrayList _hostsAllow;
    private ArrayList _hostsDeny;
    private int _idleTimeout;
    private int _receiveTimeout;
    private int _sendTimeout;
    private bool _noDelay;
    private int _inboundLimit;
    private int _outboundLimit;
    public int InboundConnectionLimit { get; public set; }
    public int OutboundConnectionLimit { get; public set; }
    public bool DefaultAllow { get; public set; }
    public int DefaultPort { get; public set; }
    public bool ExclusiveAddressUse { get; public set; }
    public ArrayList HostsAllow { get; }
    public ArrayList HostsDeny { get; }
    public int IdleTimeout { get; public set; }
    public bool NoDelay { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendTimeout { get; public set; }
    public sealed virtual object Clone();
    public int get_InboundConnectionLimit();
    public void set_InboundConnectionLimit(int value);
    public int get_OutboundConnectionLimit();
    public void set_OutboundConnectionLimit(int value);
    public bool get_DefaultAllow();
    public void set_DefaultAllow(bool value);
    public int get_DefaultPort();
    public void set_DefaultPort(int value);
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public ArrayList get_HostsAllow();
    public ArrayList get_HostsDeny();
    public int get_IdleTimeout();
    public void set_IdleTimeout(int value);
    public bool get_NoDelay();
    public void set_NoDelay(bool value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
}
public abstract class Microsoft.Web.Services3.Messaging.SoapTransport : object {
    private static DispatchFailedEventHandler DispatchFailed;
    private static object _hostNameLock;
    private static string _longHostName;
    private static string _shortHostName;
    private static ArrayList _hostAddresses;
    private SoapInputChannelCollection _inputChannels;
    protected SoapInputChannelCollection InputChannels { get; }
    private static SoapTransport();
    public static void add_DispatchFailed(DispatchFailedEventHandler value);
    public static void remove_DispatchFailed(DispatchFailedEventHandler value);
    public static string GetCanonicalHostName(Uri uri);
    private static string GetHostByAddress(string host);
    private static string GetHostByName(string host);
    public static ISoapFormatter LoadFormatter(string typeName);
    public static ISoapFormatter LoadFormatter(Type type);
    public static ISoapInputChannel StaticGetInputChannel(EndpointReference endpoint, SoapChannelCapabilities capabilities);
    public static ISoapOutputChannel StaticGetOutputChannel(EndpointReference endpoint);
    public static ISoapTransport GetTransport(EndpointReference endpoint);
    public static ISoapTransport GetTransport(string scheme);
    protected virtual void RaiseDispatchFailed(SoapEnvelope message);
    protected bool DispatchMessage(SoapEnvelope message);
    protected ISoapInputChannel GetInputChannel(SoapEnvelope message);
    protected SoapEnvelope GetFaultMessage(SoapEnvelope message, Exception fault);
    protected SoapInputChannelCollection get_InputChannels();
}
internal class Microsoft.Web.Services3.Messaging.SocketEventSelectAsyncResult : AsyncResult {
    private SoapTcpSocketEvents _events;
    private Socket _socket;
    private RegisteredWaitHandle _registeredWaitHandle;
    private ManualResetEvent _waitHandle;
    private IntPtr _invalidHandle;
    internal SoapTcpSocketEvents Events { get; }
    internal SocketEventSelectAsyncResult(Socket socket, SoapTcpSocketEvents events, AsyncCallback callback, object state);
    internal SoapTcpSocketEvents get_Events();
    private void OnSignalled(object state, bool timedOut);
    private static int WSAEventSelect(IntPtr s, SafeWaitHandle hEventObject, SoapTcpSocketEvents lNetworkEvents);
    private static int WSAEnumNetworkEvents(IntPtr s, SafeWaitHandle hEventObject, IntPtr lpNetworkEvents);
    private static int WSAGetLastError();
}
internal class Microsoft.Web.Services3.Messaging.WebServiceMethodInvoker : SoapMethodInvoker {
    private static string EncodingStyle;
    private static string Rpc;
    private static string Soapenc;
    private static string Tns;
    private static string Types;
    private SoapServerMethod _method;
    private SoapServerType _serverType;
    private object _service;
    public bool OneWay { get; }
    public WebServiceMethodInvoker(object service, SoapReceiverType receiverType, SoapServerMethod method);
    private static string GetEncodedNamespace(string ns, bool serviceDefaultIsEncoded);
    private static string GetLiteralNamespace(string ns, bool serviceDefaultIsEncoded);
    public virtual SoapEnvelope Invoke(SoapEnvelope request);
    private void WriteException(SoapEnvelope message, object target, Exception e, SoapServerMethod serverMethod);
    private Object[] InvokeBare(object target, LogicalMethodInfo method, Object[] parameters);
    private Object[] InvokeTransacted(object target, LogicalMethodInfo method, Object[] parameters);
    public virtual bool get_OneWay();
    private SoapHeaderCollection ReadHeaders(SoapEnvelope message, SoapServerMethod serverMethod);
    private Object[] ReadBody(SoapEnvelope message, SoapServerMethod serverMethod);
    private void WriteHeaders(SoapEnvelope message, object target, SoapServerMethod serverMethod);
    private void WriteBody(SoapEnvelope message, Object[] values, SoapServerMethod serverMethod);
}
public class Microsoft.Web.Services3.Messaging.WebServiceReceiver : SoapReceiver {
    private object _target;
    private Type _type;
    private WebServiceProtocols _versionsSupported;
    private SoapServerType ServerType { get; }
    public WebServiceReceiver(object target);
    public WebServiceReceiver(Type type);
    private static Type GetTargetType(object target);
    protected virtual ServiceDescription GetDescription(Uri location);
    protected XmlQualifiedName GetRequestElement(SoapEnvelope request);
    protected virtual object GetServerInstance();
    internal virtual SoapReceiverType GetSoapReceiverType();
    protected virtual Type GetTargetType();
    private bool IsSupported(WebServiceProtocols protocol);
    protected virtual void ProcessMessageHeaders(SoapEnvelope message);
    protected ServiceDescription RequestDescription();
    protected virtual SoapMethodInvoker RouteRequest(SoapEnvelope request);
    protected virtual SoapServerMethod RouteSoap11Request(SoapEnvelope request);
    protected virtual SoapServerMethod RouteSoap12Request(SoapEnvelope request);
    private SoapServerType get_ServerType();
}
internal class Microsoft.Web.Services3.Messaging.WebServiceReceiverType : SoapReceiverType {
    private SoapServerType _soapServerType;
    private WebServiceProtocols _versionsSupported;
    public SoapServerType SoapServerType { get; }
    public WebServiceReceiverType(Type type);
    public SoapServerType get_SoapServerType();
}
public class Microsoft.Web.Services3.Mime.BMMatcher : object {
    private Pattern _pattern;
    public BMMatcher(Byte[] pattern);
    public bool Match(Byte[] data, Int32& shift);
    public bool Match(Byte[] data, int offset, int count, Int32& shift);
    public bool InsufficientData(Byte[] data, int offset, int count, Int32& shift);
    private bool BruteForcePrefixMatch(Byte[] buffer, int start, int end, Byte[] pattern);
}
internal class Microsoft.Web.Services3.Mime.BufferBuilder : object {
    private Byte[] _buffer;
    private int _offset;
    public int Length { get; }
    public BufferBuilder(int initialSize);
    private void EnsureBuffer(int count);
    public void Append(byte value);
    public void Append(char value);
    public void Append(int value);
    public void Append(Byte[] value);
    public void Append(Byte[] value, int offset, int count);
    public void Append(Char[] value);
    public void Append(Char[] value, int offset, int count);
    public void Append(string value);
    public void Append(string value, int offset, int count);
    public int get_Length();
    public Byte[] GetBuffer();
    public void Reset();
}
internal class Microsoft.Web.Services3.Mime.BufferedReadStream : DelegatedStream {
    private Byte[] storedBuffer;
    private int storedLength;
    private int storedOffset;
    private bool readMore;
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public BufferedReadStream(Stream stream);
    public BufferedReadStream(Stream stream, bool readMore);
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public int ReadBlock(Byte[] buffer, int offset, int count);
    public void Push(Byte[] buffer, int offset, int count);
}
internal class Microsoft.Web.Services3.Mime.ClosableStream : DelegatedStream {
    private EventHandler onClose;
    public ClosableStream(Stream stream, EventHandler onClose);
    public virtual void Close();
}
internal enum Microsoft.Web.Services3.Mime.ContentTransferEncoding : Enum {
    public int value__;
    public static ContentTransferEncoding SevenBit;
    public static ContentTransferEncoding EightBit;
    public static ContentTransferEncoding Binary;
    public static ContentTransferEncoding Base64;
    public static ContentTransferEncoding QuotedPrintable;
    public static ContentTransferEncoding Other;
    public static ContentTransferEncoding Unspecified;
}
internal class Microsoft.Web.Services3.Mime.ContentTypeParser : object {
    private string _contentType;
    private string _base;
    private string _mediaType;
    private string _subType;
    private StringDictionary _parameters;
    private int _pos;
    private int _endPos;
    public string ContentType { get; }
    public string Base { get; }
    public string MediaType { get; }
    public string SubType { get; }
    public StringDictionary Parameters { get; }
    public ContentTypeParser(string s);
    public string get_ContentType();
    public string get_Base();
    public string get_MediaType();
    public string get_SubType();
    public StringDictionary get_Parameters();
    private void Initialize(string s);
    private void ParseBase(string s);
    private Token GetToken();
    private void ConsumeQuotedString(StringBuilder sb);
}
internal class Microsoft.Web.Services3.Mime.DelegatedStream : Stream {
    private Stream stream;
    protected Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected DelegatedStream(Stream stream);
    protected Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class Microsoft.Web.Services3.Mime.DelimittedStreamReader : object {
    private bool canGetNextStream;
    private DelimittedReadStream currentStream;
    private Byte[] delimitter;
    private Byte[] matchBuffer;
    private Byte[] scratch;
    private BMMatcher matcher;
    private BufferedReadStream stream;
    public DelimittedStreamReader(Stream stream);
    private void Close(DelimittedReadStream caller);
    public Stream GetNextStream(Byte[] delimit);
    private int ProcessRead(Byte[] buffer, int offset, int read);
    private MatchState MatchDelimitter(Byte[] buffer, int start, int end);
    private int ProcessRead_old(Byte[] buffer, int offset, int read);
    private int Read(DelimittedReadStream caller, Byte[] buffer, int offset, int count);
    private bool MatchRemainder(int start, int count);
    internal void Push(Byte[] buffer, int offset, int count);
}
internal class Microsoft.Web.Services3.Mime.HeaderField : object {
    private string _name;
    private string _value;
    public string Name { get; }
    protected string Value { get; protected set; }
    public HeaderField(string name);
    public HeaderField(string name, string value);
    public virtual string get_Name();
    protected string get_Value();
    protected void set_Value(string value);
    public virtual string GetEncodedValue();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Web.Services3.Mime.HeaderFieldCollection : object {
    private Hashtable fields;
    private int extra;
    private int version;
    public HeaderField ContentDescription { get; public set; }
    public HeaderField ContentDisposition { get; public set; }
    public HeaderField ContentTransferEncoding { get; public set; }
    public HeaderField ContentID { get; public set; }
    public HeaderField ContentType { get; public set; }
    public HeaderField MimeVersion { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public HeaderField Item { get; public set; }
    public HeaderField get_ContentDescription();
    public void set_ContentDescription(HeaderField value);
    public HeaderField get_ContentDisposition();
    public void set_ContentDisposition(HeaderField value);
    public HeaderField get_ContentTransferEncoding();
    public void set_ContentTransferEncoding(HeaderField value);
    public HeaderField get_ContentID();
    public void set_ContentID(HeaderField value);
    public HeaderField get_ContentType();
    public void set_ContentType(HeaderField value);
    public HeaderField get_MimeVersion();
    public void set_MimeVersion(HeaderField value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public void Clear();
    public void Add(string name, string value);
    public void Add(HeaderField field);
    private static bool IsSingleton(string name);
    private void Add(HeaderField field, bool singleton);
    public void Remove(string name);
    public void Remove(HeaderField field);
    public bool Contains(string name);
    public bool Contains(HeaderField field);
    public HeaderField Find(string name);
    public HeaderField[] FindMultiple(string name);
    public HeaderField get_Item(string name);
    public void set_Item(string name, HeaderField value);
}
internal class Microsoft.Web.Services3.Mime.HeaderFieldReader : object {
    private string _value;
    private Byte[] _buffer;
    private int _length;
    private string _name;
    private int _offset;
    private ReadState _readState;
    private Stream _stream;
    public string Value { get; }
    public string Name { get; }
    public HeaderFieldReader(Stream stream);
    public string get_Value();
    public string get_Name();
    public void Close();
    private bool ProcessBuffer();
    private bool BufferEnd();
    public bool Read();
    public void Reset(Stream stream);
    private void AppendValue(string value);
    private void AppendName(string value);
}
internal interface Microsoft.Web.Services3.Mime.IMimePartProvider {
    public abstract virtual MimePart GetStartPart();
    public abstract virtual MimePart GetMimePartForContentId(string cid);
    public abstract virtual void Close(bool saveUnreadToMemory);
}
public interface Microsoft.Web.Services3.Mime.IStreamXmlReader {
    public bool CanStreamContents { get; }
    public abstract virtual bool get_CanStreamContents();
    public abstract virtual Stream ReadContentsAsStream();
}
public interface Microsoft.Web.Services3.Mime.IStreamXmlWriter {
    public abstract virtual void WriteStream(Stream stream);
}
internal class Microsoft.Web.Services3.Mime.MimeMessageReader : object {
    private static Byte[] CRLFCRLF;
    private bool getContentStreamCalled;
    private HeaderFieldReader headerFieldReader;
    private DelimittedStreamReader reader;
    public MimeMessageReader(Stream stream);
    private static MimeMessageReader();
    public Stream GetContentStream();
    public HeaderFieldCollection ReadHeaders();
    public HeaderField ReadHeader();
}
internal abstract class Microsoft.Web.Services3.Mime.MimePart : object {
    protected string _contentType;
    protected string _contentId;
    protected string _contentTransferEncoding;
    protected Stream _contents;
    private static MemoryStream EmptyMemoryStream;
    public string ContentType { get; }
    public string ContentId { get; }
    public string ContentTransferEncoding { get; }
    public Stream Contents { get; }
    private static MimePart();
    public string get_ContentType();
    public string get_ContentId();
    public string get_ContentTransferEncoding();
    public Stream get_Contents();
    public virtual void SerializeContentsToMemory();
}
internal class Microsoft.Web.Services3.Mime.MimeReader : object {
    private static Byte[] CRLFCRLF;
    private Byte[] boundary;
    private string content;
    private Stream currentStream;
    private HeaderFieldReader fieldReader;
    private DelimittedStreamReader reader;
    private Byte[] scratch;
    public string Preface { get; }
    public MimeReader(Stream stream, string boundary);
    private static MimeReader();
    public string get_Preface();
    public Stream GetContentStream(ContentTransferEncoding contentTransferEncoding);
    public Stream GetContentStream();
    public bool ReadNextPart();
    public HeaderFieldCollection ReadHeaders();
    public HeaderField ReadHeader();
    private int BlockRead(Stream stream, Byte[] buffer, int offset, int count);
}
internal class Microsoft.Web.Services3.Mime.MimeReaderMimePart : MimePart {
    public MimeReaderMimePart(MimeReader mimeReader);
}
internal class Microsoft.Web.Services3.Mime.MimeReaderMimePartProvider : object {
    private MimeReader _mimeReader;
    private Dictionary`2<string, MimePart> _mimeParts;
    private MimePart _firstPartRead;
    private MimePart _lastPartRead;
    private MimePart _startPart;
    private string _startId;
    private Exception _exception;
    internal Exception CachedException { get; }
    public MimeReaderMimePartProvider(MimeReader mimeReader, string startId);
    public sealed virtual void Close(bool saveUnreadToMemory);
    internal Exception get_CachedException();
    public sealed virtual MimePart GetStartPart();
    public sealed virtual MimePart GetMimePartForContentId(string cid);
    private MimePart GetNextMimePart(MimeReader reader, bool throwIfExceedLimit);
    private MimePart GetNextMimePart(MimeReader reader);
}
internal class Microsoft.Web.Services3.Mime.MimeWriter : object {
    private static int DefaultLineLength;
    private static Byte[] DASHDASH;
    private static Byte[] CRLF;
    private Byte[] boundaryBytes;
    private BufferBuilder bufferBuilder;
    private Stream contentStream;
    private bool isInContent;
    private int lineLength;
    private EventHandler onCloseHandler;
    private Stream stream;
    private bool writeBoundary;
    private string preface;
    public MimeWriter(Stream stream, string boundary);
    public MimeWriter(Stream stream, string boundary, int lineLength);
    public MimeWriter(Stream stream, string boundary, string preface);
    public MimeWriter(Stream stream, string boundary, string preface, int lineLength);
    private static MimeWriter();
    public void Close();
    public Stream GetContentStream();
    public void WriteHeader(HeaderField header);
    public void WriteHeader(string name, string value);
    public void WriteHeaders(HeaderFieldCollection headers);
    private void OnClose(object sender, EventArgs args);
    private void CheckBoundary();
    private void Flush();
}
internal class Microsoft.Web.Services3.Mime.MtomHelper : object {
    public static string DefaultBoundaryPrefix;
    public static string BaseMtomContentType;
    private static MtomHelper();
    public static string GetContentIdForPart(int partNo);
    public static string GetContentId(string cid);
    public static string GetContentIdFromInclude(string cid);
    public static string CreateBoundary();
    public static string CreateMtomContentType(string boundary, string startId, string startInfo);
    public static bool IsXopContentType(string contentType);
    public static bool IsXopContentType(ContentTypeParser ctp);
}
internal class Microsoft.Web.Services3.Mime.MtomWebResponse : WebResponse {
    private WebResponse _base;
    private string _shimContentType;
    public string ContentType { get; public set; }
    public string RealContentType { get; }
    public long ContentLength { get; public set; }
    public WebHeaderCollection Headers { get; }
    public bool IsFromCache { get; }
    public bool IsMutuallyAuthenticated { get; }
    public Uri ResponseUri { get; }
    internal MtomWebResponse(WebResponse wrappedResponse);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public string get_RealContentType();
    public virtual void Close();
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual Stream GetResponseStream();
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_IsFromCache();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual Uri get_ResponseUri();
}
public static class Microsoft.Web.Services3.Mime.MultipartMime : object {
    public static string ContentTypeBase;
    public static string BinaryContentTransferEncoding;
    public static string SevenBitContentTransferEncoding;
    public static string EightBitContentTransferEncoding;
}
internal class Microsoft.Web.Services3.Mime.Pattern : object {
    private Byte[] _pattern;
    private Int32[] _prefixFunction;
    private Int32[] _lastOccuranceFunction;
    private Int32[] _goodSuffixFunction;
    internal Byte[] P { get; }
    internal Int32[] Gamma { get; }
    internal Int32[] Lambda { get; }
    internal Int32[] Pi { get; }
    internal Pattern(Byte[] pattern);
    internal Byte[] get_P();
    internal Int32[] get_Gamma();
    internal Int32[] get_Lambda();
    internal Int32[] get_Pi();
    private Int32[] ComputePrefixFunction(Byte[] pattern);
    private void ComputeLastOccuranceFunction();
    private void ComputeGoodSuffixFunction();
    private Byte[] Reverse(Byte[] p);
}
internal class Microsoft.Web.Services3.Mime.XmlDOMTextWriter : XmlTextWriter {
    public XmlDOMTextWriter(Stream w, Encoding encoding);
    public XmlDOMTextWriter(string filename, Encoding encoding);
    public XmlDOMTextWriter(TextWriter w);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
}
public static class Microsoft.Web.Services3.Mime.Xop : object {
    public static string Prefix;
    public static string NamespaceURI;
    public static string ContentTypeBase;
    public static string CidScheme;
}
public class Microsoft.Web.Services3.Mime.XopContentsNode : XmlText {
    private bool _hideData;
    private bool _lockContents;
    private XopNodeData _nodeData;
    public bool HideData { get; public set; }
    public bool Locked { get; public set; }
    internal XopNodeData XopNodeData { get; }
    public Byte[] BinaryData { get; public set; }
    public Stream BinaryStream { get; public set; }
    public string Data { get; public set; }
    internal XopContentsNode(string text, XopDocument document);
    internal XopContentsNode(Byte[] bytes, XopDocument document);
    internal XopContentsNode(Stream stream, XopDocument document);
    internal XopContentsNode(XopDocument document, string contentId);
    public bool get_HideData();
    public void set_HideData(bool value);
    public bool get_Locked();
    public void set_Locked(bool value);
    internal XopNodeData get_XopNodeData();
    public virtual Byte[] get_BinaryData();
    public virtual void set_BinaryData(Byte[] value);
    public virtual Stream get_BinaryStream();
    public virtual void set_BinaryStream(Stream value);
    public virtual string get_Data();
    public virtual void set_Data(string value);
    public virtual void WriteTo(XmlWriter w);
}
public class Microsoft.Web.Services3.Mime.XopDocument : XmlDocument {
    private IMimePartProvider _mimePartProvider;
    private MemoryStream _startPartContents;
    private List`1<XmlElement> _xopIncludes;
    private bool _allowXopIncludeCreation;
    private Encoding _encoding;
    internal bool AllowXopIncludeCreation { get; internal set; }
    internal IMimePartProvider MimePartProvider { get; internal set; }
    public Encoding Encoding { get; public set; }
    internal bool get_AllowXopIncludeCreation();
    internal void set_AllowXopIncludeCreation(bool value);
    internal IMimePartProvider get_MimePartProvider();
    internal void set_MimePartProvider(IMimePartProvider value);
    private void ClearMimePartState();
    private void ClearXopState();
    public void CompleteLoadFromXopPackage(bool saveUnreadToMemory);
    public void CompleteLoadFromXopPackage();
    public virtual string LoadFromXopPackage(string contentType, Stream stream);
    public virtual void SaveToXopPackage(Stream stream, string infosetContentType, string boundary, string startId);
    public virtual XmlReader GetDocumentReader();
    public virtual XmlWriter GetDocumentWriter();
    protected virtual XmlReader GetReaderForNode(XmlNode node);
    protected virtual XmlWriter GetWriterForNode(XmlNode node);
    public virtual XmlElement CreateElement(string prefix, string localName, string namespaceURI);
    public virtual XmlText CreateTextNode(string text);
    public virtual XopContentsNode CreateBinaryNode(Byte[] bytes);
    public virtual XopContentsNode CreateBinaryNode(Stream stream);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    private string LoadStartPart(MimePart startPart);
    private static Encoding GetEncodingForCharSet(string charset);
    internal Stream GetStreamForContentId(string cid);
    private void OnDocumentWriterClosed(object source, EventArgs ea);
    private void ReplaceXopIncludeElements();
    internal void SetEncoding(string contentType, bool throwOnError);
    private void SetMimePartProvider(IMimePartProvider provider);
    private void VerifyExtractedPart(MimePart part);
    private void VerifyStartPart(MimePart part);
    private void VerifyXopInclude(XmlElement xopInclude);
}
internal class Microsoft.Web.Services3.Mime.XopDocumentBinaryReader : object {
    private XopDocumentReader reader;
    private State state;
    private bool isEnd;
    private Stream _currentNodeStream;
    private static UInt32 CanReadContentAsBitmap;
    internal XopDocumentBinaryReader(XopDocumentReader reader);
    private static XopDocumentBinaryReader();
    public static XopDocumentBinaryReader CreateOrReset(XopDocumentBinaryReader helper, XopDocumentReader reader);
    private static void VerifyParameters(Byte[] buffer, int index, int count);
    public int ReadContentAsBase64(Byte[] buffer, int index, int count);
    public int ReadElementContentAsBase64(Byte[] buffer, int index, int count);
    public void Finish();
    internal void Reset();
    private Stream GetStreamForNode(XopContentsNode node);
    private bool Init();
    private bool InitOnElement();
    private int ReadContentAsBinary(Byte[] buffer, int index, int count);
    private static int FillBufferFromStream(Byte[] buffer, int index, int count, Stream s);
    private int ReadElementContentAsBinary(Byte[] buffer, int index, int count);
    private bool MoveToNextContentNode(bool moveIfOnContentNode);
    internal static bool CanReadContentAs(XmlNodeType nodeType);
    private Exception CreateReadContentAsException(string methodName, XmlNodeType nodeType);
    private Exception CreateReadElementContentAsException(string methodName, XmlNodeType nodeType);
}
public class Microsoft.Web.Services3.Mime.XopDocumentException : XmlException {
    public XopDocumentException(string message);
}
internal class Microsoft.Web.Services3.Mime.XopDocumentReader : XmlReader {
    private XopNodeReaderNavigator readerNav;
    private XmlNodeType nodeType;
    private int curDepth;
    private ReadState readState;
    private bool fEOF;
    private bool bResolveEntity;
    private bool bStartFromDocument;
    private bool bInReadBinary;
    private XopDocumentBinaryReader readBinaryHelper;
    public XmlNodeType NodeType { get; }
    public string Name { get; }
    public XmlNode CurrentNode { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Prefix { get; }
    public bool HasValue { get; }
    public string Value { get; }
    public int Depth { get; }
    public string BaseURI { get; }
    public bool CanResolveEntity { get; }
    public bool IsEmptyElement { get; }
    public bool IsDefault { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public int AttributeCount { get; }
    public bool EOF { get; }
    public ReadState ReadState { get; }
    public bool HasAttributes { get; }
    public XmlNameTable NameTable { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanStreamContents { get; }
    public XopDocumentReader(XmlNode xmlNode);
    private void Init(XmlNode node);
    internal bool IsInReadingStates();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Name();
    public XmlNode get_CurrentNode();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Prefix();
    public virtual bool get_HasValue();
    public virtual string get_Value();
    public virtual int get_Depth();
    public virtual string get_BaseURI();
    public virtual bool get_CanResolveEntity();
    public virtual bool get_IsEmptyElement();
    public virtual bool get_IsDefault();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual int get_AttributeCount();
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string GetAttribute(int attributeIndex);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string namespaceURI);
    public virtual void MoveToAttribute(int attributeIndex);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToElement();
    public virtual bool Read();
    private bool Read(bool fSkipChildren);
    private bool ReadNextNode(bool fSkipChildren);
    private void SetEndOfFile();
    private bool ReadAtZeroLevel(bool fSkipChildren);
    private bool ReadForward(bool fSkipChildren);
    private void ReSetReadingMarks();
    public virtual bool get_EOF();
    public virtual void Close();
    public virtual ReadState get_ReadState();
    public virtual void Skip();
    public virtual string ReadString();
    public virtual bool get_HasAttributes();
    public virtual XmlNameTable get_NameTable();
    public virtual string LookupNamespace(string prefix);
    public virtual void ResolveEntity();
    public virtual bool ReadAttributeValue();
    public virtual bool get_CanReadBinaryContent();
    public sealed virtual bool get_CanStreamContents();
    public sealed virtual Stream ReadContentsAsStream();
    public virtual int ReadContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int index, int count);
    private void FinishReadBinary();
    private sealed virtual override IDictionary`2<string, string> System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope);
    private sealed virtual override string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName);
    private sealed virtual override string System.Xml.IXmlNamespaceResolver.LookupNamespace(string prefix);
}
internal class Microsoft.Web.Services3.Mime.XopDocumentWriter : XmlWrappingWriter {
    private XopDocument _doc;
    private Dictionary`2<string, MimePart> _mimeParts;
    private MemoryStream _currentMemoryStream;
    private Stream _userStream;
    private int _binaryStreamsWritten;
    public XmlWriter NodeWriter { get; }
    public XopDocumentWriter(XopDocument doc, XmlNode node);
    public XmlWriter get_NodeWriter();
    private static bool ShouldIgnoreDocOps(XopDocument doc, XmlNode node);
    public virtual void Close();
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public sealed virtual void WriteStream(Stream stream);
    public virtual void WriteFullEndElement();
    public virtual void WriteEndElement();
    private void WriteXopIncludes();
    private static bool ShouldInlineStream(Stream stream);
    private void WriteInlineStream(Stream stream);
    private void WriteXopStream(Stream stream);
    private sealed virtual override void Microsoft.Web.Services3.Mime.IMimePartProvider.Close(bool saveUnreadToMemory);
    private sealed virtual override MimePart Microsoft.Web.Services3.Mime.IMimePartProvider.GetStartPart();
    private sealed virtual override MimePart Microsoft.Web.Services3.Mime.IMimePartProvider.GetMimePartForContentId(string cid);
}
internal class Microsoft.Web.Services3.Mime.XopMimeContentType : ContentTypeParser {
    private string _boundary;
    private string _startId;
    private string _startInfo;
    public string Boundary { get; }
    public string StartId { get; }
    public string StartInfo { get; }
    public XopMimeContentType(string contentType);
    public string get_Boundary();
    public string get_StartId();
    public string get_StartInfo();
}
internal class Microsoft.Web.Services3.Mime.XopNodeData : object {
    private DataType _type;
    private string _stringData;
    private string _contentId;
    private Stream _streamData;
    private Byte[] _byteData;
    private XopContentsNode _owner;
    public DataType Type { get; }
    public XopNodeData(XopContentsNode owner);
    public DataType get_Type();
    private void ClearData();
    private void ConvertTo(DataType typeDesired);
    private Byte[] ConvertContentsToBytes();
    private Stream ConvertContentsToStream();
    private static Byte[] GetBufferSafelyFromStream(Stream stream);
    private static Byte[] GetMemoryStreamBuffer(MemoryStream ms, Byte[] rawBuffer);
    private Stream LoadXopStream();
    public string GetString();
    public Byte[] GetBinary();
    public Stream GetStream();
    public void SetAsString(string text);
    public void SetAsBinary(Byte[] octets);
    public void SetAsStream(Stream stream);
    public void SetAsXopStream(string contentId);
}
internal class Microsoft.Web.Services3.Mime.XopNodeReaderNavigator : object {
    private static string strPublicID;
    private static string strSystemID;
    private static string strVersion;
    private static string strStandalone;
    private static string strEncoding;
    private static string NsXml;
    private static string NsXmlNs;
    private XmlNode curNode;
    private XmlNode elemNode;
    private XmlNode logNode;
    private int _attrIndex;
    private int logAttrIndex;
    private XmlNameTable nameTable;
    private XmlDocument doc;
    private int nAttrInd;
    private int nDeclarationAttrCount;
    private int nDocTypeAttrCount;
    private int nLogLevel;
    private int nLogAttrInd;
    private bool bLogOnAttrVal;
    private bool bCreatedOnAttribute;
    internal VirtualAttribute[] decNodeAttributes;
    internal VirtualAttribute[] docTypeNodeAttributes;
    public bool bOnAttrVal;
    public XmlNode CurrentNode { get; }
    public XmlNodeType NodeType { get; }
    public string NamespaceURI { get; }
    public string Name { get; }
    public string LocalName { get; }
    internal bool IsOnAttrVal { get; }
    internal XmlNode OwnerElementNode { get; }
    internal bool CreatedOnAttribute { get; }
    public string Prefix { get; }
    public bool HasValue { get; }
    public string Value { get; }
    public string BaseURI { get; }
    public bool IsEmptyElement { get; }
    public bool IsDefault { get; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public XmlNameTable NameTable { get; }
    public int AttributeCount { get; }
    public string InnerXml { get; }
    public string OuterXml { get; }
    private bool IsOnDeclOrDocType { get; }
    public XopNodeReaderNavigator(XmlNode node);
    public XmlNode get_CurrentNode();
    public XmlNodeType get_NodeType();
    public string get_NamespaceURI();
    public string get_Name();
    public string get_LocalName();
    internal bool get_IsOnAttrVal();
    internal XmlNode get_OwnerElementNode();
    internal bool get_CreatedOnAttribute();
    private bool IsLocalNameEmpty(XmlNodeType nt);
    public string get_Prefix();
    public bool get_HasValue();
    public string get_Value();
    public string get_BaseURI();
    public bool get_IsEmptyElement();
    public bool get_IsDefault();
    public IXmlSchemaInfo get_SchemaInfo();
    public XmlNameTable get_NameTable();
    public int get_AttributeCount();
    private string WriteAttributeContent(string prefix, string localName, string ns, string value, bool bMarkup);
    public string get_InnerXml();
    public string get_OuterXml();
    private void CheckIndexCondition(int attributeIndex);
    private static XmlDeclaration DocDeclarationShim(XmlDocument doc);
    private static string DocVersionShim(XmlDocument doc);
    private static string DocEncodingShim(XmlDocument doc);
    private static string DocStandaloneShim(XmlDocument doc);
    private void InitDecAttr();
    public string GetDeclarationAttr(XmlDeclaration decl, string name);
    public string GetDeclarationAttr(int i);
    public int GetDecAttrInd(string name);
    private void InitDocTypeAttr();
    public string GetDocumentTypeAttr(XmlDocumentType docType, string name);
    public string GetDocumentTypeAttr(int i);
    public int GetDocTypeAttrInd(string name);
    private string GetAttributeFromElement(XmlElement elem, string name);
    public string GetAttribute(string name);
    private string GetAttributeFromElement(XmlElement elem, string name, string ns);
    public string GetAttribute(string name, string ns);
    public string GetAttribute(int attributeIndex);
    public void LogMove(int level);
    public void RollBackMove(Int32& level);
    private bool get_IsOnDeclOrDocType();
    public void ResetToAttribute(Int32& level);
    public void ResetMove(Int32& level, XmlNodeType& nt);
    public bool MoveToAttribute(string name);
    private bool MoveToAttributeFromElement(XmlElement elem, string name, string ns);
    private int FindNodeOffsetNS(XmlAttributeCollection attributes, XmlAttribute attr);
    public bool MoveToAttribute(string name, string namespaceURI);
    public void MoveToAttribute(int attributeIndex);
    public bool MoveToNextAttribute(Int32& level);
    public bool MoveToParent();
    public bool MoveToFirstChild();
    private bool MoveToNextSibling(XmlNode node);
    public bool MoveToNext();
    public bool MoveToElement();
    public string LookupNamespace(string prefix);
    internal string DefaultLookupNamespace(string prefix);
    internal string LookupPrefix(string namespaceName);
    internal IDictionary`2<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
    public bool ReadAttributeValue(Int32& level, Boolean& bResolveEntity, XmlNodeType& nt);
}
internal class Microsoft.Web.Services3.Mime.XopPackageWriter : XmlWrappingWriter {
    private static string BinaryContentTransferEncoding;
    public static int InlineBinaryContentThreshold;
    private Encoding _encoding;
    private string _startInfo;
    private string _boundary;
    private string _rootContentId;
    private string _rootPartContentType;
    private MimeWriter _mimeWriter;
    private int _depth;
    private bool _writeXopDecl;
    private List`1<XopContentsNode> _binaryDataQ;
    private List`1<MimePart> _mimeParts;
    private XopDocument _tempNodeParent;
    private MemoryStream _tempStream;
    private Stream _rootContentStream;
    private IList`1<XopContentsNode> DataQueue { get; }
    private IList`1<MimePart> MimeParts { get; }
    public string RootContentId { get; }
    public string RootContentType { get; }
    public string Boundary { get; }
    public bool WriteXopDecl { get; public set; }
    public XopPackageWriter(Stream s, Encoding encoding, string startId, string startInfo, string boundary);
    private IList`1<XopContentsNode> get_DataQueue();
    private IList`1<MimePart> get_MimeParts();
    public string get_RootContentId();
    public string get_RootContentType();
    public string get_Boundary();
    public bool get_WriteXopDecl();
    public void set_WriteXopDecl(bool value);
    private XmlWriter CreateContentsXmlWriter(Stream s, Encoding encoding);
    private HeaderFieldCollection CreateRootPartHeaders();
    private void IncrementDepth();
    private bool TryInlineBinaryData();
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public void WriteBinaryNode(XopContentsNode node);
    public sealed virtual void WriteStream(Stream stream);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    private void WriteAnyXopInclude();
    private void WriteAnyExtractedContent();
    public virtual void WriteEndDocument();
    private void WriteXmlnsAttribute(string prefix, string ns);
}
internal class Microsoft.Web.Services3.NonHttpSoapWebRequest : WebRequest {
    private Uri _requestUri;
    private string _method;
    private string _contentType;
    private static NoOpStream _stream;
    public Uri RequestUri { get; }
    public string ConnectionGroupName { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public int Timeout { get; public set; }
    public NonHttpSoapWebRequest(string uri);
    public NonHttpSoapWebRequest(Uri uri);
    private static NonHttpSoapWebRequest();
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback cb, object state);
    public virtual IAsyncResult BeginGetResponse(AsyncCallback cb, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual Uri get_RequestUri();
    public virtual void Abort();
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    public virtual WebHeaderCollection get_Headers();
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
}
internal class Microsoft.Web.Services3.NonHttpSoapWebResponse : WebResponse {
    public long ContentLength { get; }
    public string ContentType { get; }
    public WebHeaderCollection Headers { get; }
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public virtual Stream GetResponseStream();
    public virtual WebHeaderCollection get_Headers();
}
internal class Microsoft.Web.Services3.NoOpStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual void SetLength(long value);
    public virtual void Close();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
}
public class Microsoft.Web.Services3.Pipeline : object {
    private Collection`1<SoapFilter> inputFilters;
    private Collection`1<SoapFilter> outputFilters;
    private bool _isIntermediary;
    private Uri _actor;
    public Uri Actor { get; public set; }
    public bool IsIntermediary { get; public set; }
    public Pipeline(Pipeline pipeline);
    public Pipeline(IEnumerable`1<SoapFilter> inputFilters, IEnumerable`1<SoapFilter> outputFilters);
    public T GetOutputBehavior();
    public T GetInputBehavior();
    public Uri get_Actor();
    public void set_Actor(Uri value);
    public bool get_IsIntermediary();
    public void set_IsIntermediary(bool value);
    public SoapServerMethod ProcessInputMessage(SoapEnvelope envelope);
    public bool ProcessOutputMessage(SoapEnvelope envelope);
    public static Pipeline TryCreateForClient(Type type);
    public static Pipeline TryCreateForService(Type type);
    private static Pipeline TryCreate(Type type, bool forClient);
}
public class Microsoft.Web.Services3.PipelineCreationContext : object {
    private Type handler;
    public Type Handler { get; }
    internal PipelineCreationContext(Type handler);
    public Type get_Handler();
}
[AttributeUsageAttribute("4")]
public class Microsoft.Web.Services3.PolicyAttribute : Attribute {
    private string policyName;
    private Type policyType;
    public string PolicyName { get; }
    public Type PolicyType { get; }
    public PolicyAttribute(Type policyType);
    public PolicyAttribute(string policyName);
    private sealed virtual override Pipeline Microsoft.Web.Services3.IPipelineProvider.CreateClientPipeline(PipelineCreationContext context);
    private sealed virtual override Pipeline Microsoft.Web.Services3.IPipelineProvider.CreateServicePipeline(PipelineCreationContext context);
    public string get_PolicyName();
    public Type get_PolicyType();
}
internal class Microsoft.Web.Services3.Pool`1 : object {
    private T[] items;
    private int count;
    public int Count { get; }
    public Pool`1(int maxCount);
    public int get_Count();
    public T Take();
    public bool Return(T item);
    public void Clear();
}
public class Microsoft.Web.Services3.Referral.Configuration.ReferralCacheConfiguration : ConfigurationElement {
    private ConfigurationProperty _name;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    public string Name { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected virtual void PostDeserialize();
    public string get_Name();
}
public class Microsoft.Web.Services3.Referral.Configuration.ReferralConfiguration : ConfigurationElement {
    private ConfigurationProperty _cache;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    public string CacheFile { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_CacheFile();
}
public class Microsoft.Web.Services3.Referral.Desc : object {
    private Uri _refAddr;
    public Uri RefAddr { get; public set; }
    public Uri get_RefAddr();
    public void set_RefAddr(Uri value);
}
public class Microsoft.Web.Services3.Referral.For : object {
    private Uri _exact;
    private Uri _prefix;
    public Uri Exact { get; public set; }
    public Uri Prefix { get; public set; }
    public Uri get_Exact();
    public void set_Exact(Uri value);
    public Uri get_Prefix();
    public void set_Prefix(Uri value);
}
public class Microsoft.Web.Services3.Referral.If : object {
    private long _ttl;
    private UriList _invalidates;
    public long Ttl { get; public set; }
    public UriList Invalidates { get; }
    public long get_Ttl();
    public void set_Ttl(long value);
    public UriList get_Invalidates();
}
public class Microsoft.Web.Services3.Referral.Query : object {
    private For _for;
    public For For { get; }
    public For get_For();
}
public class Microsoft.Web.Services3.Referral.QueryResponse : object {
    private ReferralCollection _referrals;
    public ReferralCollection Referrals { get; }
    public ReferralCollection get_Referrals();
}
public class Microsoft.Web.Services3.Referral.Referral : object {
    private For _for;
    private If _if;
    private ViaCollection _go;
    private Uri _refId;
    private Desc _desc;
    private DateTime _created;
    internal DateTime Created { get; internal set; }
    public Desc Desc { get; }
    internal bool Expired { get; }
    public For For { get; }
    public ViaCollection Go { get; }
    public If If { get; }
    public Uri RefId { get; public set; }
    public Referral(Uri refId);
    internal Referral(XmlElement element);
    public void CheckValid();
    public sealed virtual object Clone();
    internal DateTime get_Created();
    internal void set_Created(DateTime value);
    public Desc get_Desc();
    internal bool get_Expired();
    public For get_For();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    internal XmlElement GetXmlInternal(XmlDocument document);
    public ViaCollection get_Go();
    public If get_If();
    public sealed virtual void LoadXml(XmlElement element);
    private void LoadXmlFor(XmlElement element);
    private void LoadXmlGo(XmlElement element);
    private void LoadXmlDesc(XmlElement element);
    private void LoadXmlIf(XmlElement element);
    public Uri get_RefId();
    public void set_RefId(Uri value);
}
public class Microsoft.Web.Services3.Referral.ReferralCache : object {
    private static string _cacheFile;
    private static Stream _cacheStream;
    private static Hashtable _exact;
    private static Hashtable _prefix;
    private static ReferralCollection _referrals;
    private static ReaderWriterLock _lock;
    private static bool _initialized;
    private static ReferralCache();
    private static void AcquireReadLock();
    private static void AcquireWriteLock();
    private static void Add(Referral referral);
    private static bool CheckConditions();
    private static void Initialize();
    private static void Load();
    private static void LoadIndexes();
    public static QueryResponse Query(Query referralQuery);
    public static void Register(Referral referral);
    private static void ReleaseReadLock();
    private static void ReleaseWriteLock();
    public static bool Remove(Uri refid);
    private static Referral Resolve(Uri destination);
    public static Uri ResolvePath(Uri uri);
    private static void Save();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Referral.ReferralCollection : WSESoapHeader {
    private Hashtable _referrals;
    public Referral Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal ReferralCollection Clone();
    public Referral get_Item(Uri refId);
    public void Add(Referral referral);
    public void AddRange(Referral[] referrals);
    public void Clear();
    public bool Contains(Referral referral);
    public bool Contains(Uri refId);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Referral[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual bool get_IsSynchronized();
    public void Remove(Referral referral);
    public void Remove(Uri refId);
    public sealed virtual object get_SyncRoot();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    internal void Load(Stream stream);
    public sealed virtual void LoadXml(XmlElement element);
    internal void Save(Stream stream);
}
public class Microsoft.Web.Services3.Referral.ReferralException : SystemException {
    public ReferralException(string message, Exception ex);
    public ReferralException(string message);
}
public class Microsoft.Web.Services3.Referral.ReferralFormatException : WseSoapHeaderException {
    public static string BadRefIdValue;
    public static string BadMatchCombination;
    public static string BadDescValue;
    public static string BadExactValue;
    public static string BadPrefixValue;
    public static string BadViaValue;
    public static string NegativeTtlValue;
    public static string BadTtlValue;
    public static string BadTransport;
    public static string BadRidValue;
    public static string SignedTtlValue;
    public static string ExactIsNotAbsoluteUri;
    public static string PrefixIsNotAbsoluteUri;
    public static string ViaIsNotAbsoluteUri;
    public static string MoreThanOneReferralHeaders;
    public static string BadRefAddrValue;
    public static string BadCreatedValue;
    public static string RefAddrIsNotAbsoluteUri;
    public ReferralFormatException(string message);
    public ReferralFormatException(Uri refid, string message);
    public ReferralFormatException(Uri refid, string message, Exception innerException);
    private static ReferralFormatException();
    private static string BuildMessage(Uri refid, string message);
}
internal class Microsoft.Web.Services3.Referral.ReferralInputFilter : SoapInputFilter {
    public virtual void ProcessMessage(SoapEnvelope envelope);
}
internal class Microsoft.Web.Services3.Referral.ReferralOutputFilter : SoapOutputFilter {
    public virtual void ProcessMessage(SoapEnvelope envelope);
}
internal class Microsoft.Web.Services3.Referral.ReferralUtility : object {
    internal static string NamespaceURI;
    internal static string Prefix;
}
public class Microsoft.Web.Services3.Referral.Registration : object {
    private Referral _referral;
    public Referral Referral { get; public set; }
    public Registration(Referral referral);
    public Referral get_Referral();
    public void set_Referral(Referral value);
}
[XmlTypeAttribute]
[XmlRootAttribute("registrationResponse")]
public class Microsoft.Web.Services3.Referral.RegistrationResponse : object {
}
public class Microsoft.Web.Services3.Referral.Via : WSESoapHeader {
    private Uri _value;
    public Uri Value { get; public set; }
    public Via(Uri value);
    public Via(XmlElement element);
    public static Uri op_Implicit(Via via);
    public static Via op_Implicit(Uri uri);
    public static bool op_Equality(Via obj1, Via obj2);
    public static bool op_Inequality(Via obj1, Via obj2);
    public sealed virtual object Clone();
    internal int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public sealed virtual void LoadXml(XmlElement element);
    public Uri get_Value();
    public void set_Value(Uri value);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Referral.ViaCollection : object {
    private ArrayList _vias;
    public Via Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public Via get_Item(int index);
    public void set_Item(int index, Via value);
    public int Add(Via via);
    public sealed virtual object Clone();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Via[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    public void Insert(int index, Via via);
    public void InsertRange(int index, ViaCollection collection);
    public sealed virtual bool get_IsSynchronized();
    public void RemoveAt(int index);
    public sealed virtual object get_SyncRoot();
}
public class Microsoft.Web.Services3.RequestSoapContext : object {
    [ThreadStaticAttribute]
private static SoapContext _current;
    public static SoapContext Current { get; public set; }
    private static RequestSoapContext();
    public static SoapContext get_Current();
    public static void set_Current(SoapContext value);
}
public class Microsoft.Web.Services3.ResponseProcessingException : ApplicationException {
    private SoapEnvelope _response;
    public SoapEnvelope Response { get; }
    public ResponseProcessingException(string s, Exception innerException, SoapEnvelope response);
    public SoapEnvelope get_Response();
}
public class Microsoft.Web.Services3.ResponseSoapContext : object {
    [ThreadStaticAttribute]
private static SoapContext _current;
    public static SoapContext Current { get; public set; }
    private static ResponseSoapContext();
    public static SoapContext get_Current();
    public static void set_Current(SoapContext value);
}
public class Microsoft.Web.Services3.Security.BinarySecret : OpenAttributeElement {
    private string _type;
    private Byte[] _secret;
    public string Type { get; public set; }
    public Byte[] Value { get; public set; }
    public BinarySecret(Byte[] secret);
    public BinarySecret(Byte[] secret, string type);
    public BinarySecret(XmlElement element);
    public static Byte[] op_Explicit(BinarySecret secret);
    private void CheckValid();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual void LoadXml(XmlElement element);
    public string get_Type();
    public void set_Type(string value);
    public Byte[] get_Value();
    public void set_Value(Byte[] value);
}
internal class Microsoft.Web.Services3.Security.CanonicalizationMethod : object {
    private string _algorithm;
    private string _prefixList;
    public string Algorithm { get; }
    public string PrefixList { get; }
    public CanonicalizationMethod(string algorithm);
    public CanonicalizationMethod(string algorithm, string prefixList);
    public CanonicalizationMethod(XmlElement element);
    public string get_Algorithm();
    public XmlElement GetXml(XmlDocument document);
    public void LoadXml(XmlElement element);
    public string get_PrefixList();
}
internal class Microsoft.Web.Services3.Security.CipherData : object {
    private Byte[] _cipherValue;
    public Byte[] CipherValue { get; public set; }
    public CipherData(Byte[] cipherValue);
    public CipherData(XmlElement element);
    public Byte[] get_CipherValue();
    public void set_CipherValue(Byte[] value);
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public sealed virtual void LoadXml(XmlElement element);
}
public class Microsoft.Web.Services3.Security.Configuration.BinarySecurityTokenManagerCollection : ConfigurationElementCollection {
    protected bool ThrowOnDuplicate { get; }
    public void Add(ConfigurationElement element);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual void PostDeserialize();
    internal ISecurityTokenManager GetSecurityToken(string valueType);
    internal static string GetStandardTokenType(string valueType);
}
public class Microsoft.Web.Services3.Security.Configuration.BinarySecurityTokenManagerElement : ConfigElementInterceptor {
    private ConfigurationProperty _valueType;
    private ConfigurationProperty _type;
    private ConfigurationProperty _keyAlgorithm;
    private ConfigurationProperty _sessionKeyAlgorithm;
    private ConfigurationProperty _renewalWindowInSeconds;
    private ConfigurationPropertyCollection _properties;
    private ISecurityTokenManager _stm;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string ValueType { get; }
    internal string TokenType { get; }
    internal ISecurityTokenManager Token { get; }
    internal BinarySecurityTokenManagerElement(string valueType, string type);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_ValueType();
    internal string get_TokenType();
    internal ISecurityTokenManager get_Token();
    internal void LoadSecurityTokenManager(string tokenType, XmlNodeList childNodes);
}
public class Microsoft.Web.Services3.Security.Configuration.BinaryTokenKeyAlgorithmElement : ConfigurationElement {
    private ConfigurationProperty _name;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Value();
}
public class Microsoft.Web.Services3.Security.Configuration.BinaryTokenSessionKeyElement : ConfigurationElement {
    private ConfigurationProperty _name;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Value();
}
public class Microsoft.Web.Services3.Security.Configuration.CacheLimitConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public class Microsoft.Web.Services3.Security.Configuration.DefaultTtlConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public class Microsoft.Web.Services3.Security.Configuration.EncryptionFormatterCollection : FormatterCollection {
    protected bool ThrowOnDuplicate { get; }
    protected virtual void InitializeDefault();
    protected virtual bool get_ThrowOnDuplicate();
}
public class Microsoft.Web.Services3.Security.Configuration.Formatter : ConfigurationElement {
    private ConfigurationProperty _uri;
    private ConfigurationProperty _type;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Uri { get; }
    internal Type Type { get; }
    internal Formatter(string uri, Type type);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Uri();
    internal Type get_Type();
}
public class Microsoft.Web.Services3.Security.Configuration.FormatterCollection : ConfigurationElementCollection {
    public void Add(ConfigurationElement element);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    internal bool Contains(string uri);
    internal Formatter Item(string uri);
}
public class Microsoft.Web.Services3.Security.Configuration.GenerationLimitConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public class Microsoft.Web.Services3.Security.Configuration.KeyAlgorithmCollection : ConfigurationElementCollection {
    protected bool ThrowOnDuplicate { get; }
    public void Add(ConfigurationElement element);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    internal bool Contains(string name);
    internal KeyAlgorithmElement Item(string name);
    protected virtual bool get_ThrowOnDuplicate();
}
public class Microsoft.Web.Services3.Security.Configuration.KeyAlgorithmElement : ConfigurationElement {
    private ConfigurationProperty _name;
    private ConfigurationProperty _type;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Name { get; }
    internal Type Type { get; }
    internal KeyAlgorithmElement(string name, Type type);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Name();
    internal Type get_Type();
}
public class Microsoft.Web.Services3.Security.Configuration.KeyExchangeFormatterCollection : FormatterCollection {
    protected bool ThrowOnDuplicate { get; }
    protected virtual bool get_ThrowOnDuplicate();
}
public class Microsoft.Web.Services3.Security.Configuration.KeyIdentifierMappingCollection : ConfigurationElementCollection {
    public void Add(ConfigurationElement element);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    internal bool Contains(string valueType);
    internal KeyIdentifierMappingElement Item(string valueType);
}
public class Microsoft.Web.Services3.Security.Configuration.KeyIdentifierMappingElement : ConfigurationElement {
    private ConfigurationProperty _valueType;
    private ConfigurationProperty _tokenType;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string ValueType { get; }
    internal string TokenType { get; }
    internal KeyIdentifierMappingElement(string valueType, string tokenType);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_ValueType();
    internal string get_TokenType();
}
public class Microsoft.Web.Services3.Security.Configuration.KeyInfoConfiguration : ConfigurationElement {
    private ConfigurationPropertyCollection _properties;
    private KeyInfo _tokenKeyInfo;
    protected ConfigurationPropertyCollection Properties { get; }
    public KeyInfo TokenKeyInfo { get; }
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public KeyInfo get_TokenKeyInfo();
}
public class Microsoft.Web.Services3.Security.Configuration.LabelConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Value();
}
public class Microsoft.Web.Services3.Security.Configuration.OffsetLimitConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public class Microsoft.Web.Services3.Security.Configuration.RenewalWindowConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public class Microsoft.Web.Services3.Security.Configuration.ReplayDetectionElement : ConfigurationElement {
    private ConfigurationProperty _enabled;
    private ConfigurationProperty _windowInSeconds;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class Microsoft.Web.Services3.Security.Configuration.RevocationModeValidation : ConfigurationValidatorBase {
    public virtual void Validate(object value);
    public virtual bool CanValidate(Type type);
}
public class Microsoft.Web.Services3.Security.Configuration.SecurityConfiguration : ConfigurationElement {
    private ConfigurationProperty _limits;
    private ConfigurationProperty _defaultTtlInSeconds;
    private ConfigurationProperty _timeToleranceInSeconds;
    private ConfigurationProperty _cryptography;
    private ConfigurationProperty _x509;
    private ConfigurationProperty _binarySecurityTokenManagers;
    private ConfigurationProperty _xmlSecurityTokenManagers;
    private ConfigurationProperty _keyIdentifierMappings;
    private ConfigurationPropertyCollection _properties;
    private IDictionary _securityTokenManagers;
    protected ConfigurationPropertyCollection Properties { get; }
    public X509RevocationMode RevocationMode { get; }
    public VerificationMode VerificationMode { get; }
    public bool AllowTestRoot { get; }
    public int DefaultTtlInSeconds { get; }
    public TimeSpan TimeToleranceInSeconds { get; }
    public int MaxTokens { get; }
    public int MaxSignedItems { get; }
    public int MaxEncryptedItems { get; }
    public StoreLocation StoreLocation { get; }
    public X509CertificateSkiMode SkiMode { get; }
    public bool VerifyTrust { get; }
    internal BinarySecurityTokenManagerCollection BinarySecurityTokenManagers { get; }
    internal SecurityTokenManagerCollection XmlSecurityTokenMangers { get; }
    internal IDictionary SecurityTokenManagers { get; }
    internal SecurityCryptographyConfiguration Cryptography { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected virtual void PostDeserialize();
    public X509RevocationMode get_RevocationMode();
    public VerificationMode get_VerificationMode();
    public bool get_AllowTestRoot();
    public int get_DefaultTtlInSeconds();
    public TimeSpan get_TimeToleranceInSeconds();
    public int get_MaxTokens();
    public int get_MaxSignedItems();
    public int get_MaxEncryptedItems();
    public StoreLocation get_StoreLocation();
    public X509CertificateSkiMode get_SkiMode();
    public bool get_VerifyTrust();
    internal BinarySecurityTokenManagerCollection get_BinarySecurityTokenManagers();
    internal SecurityTokenManagerCollection get_XmlSecurityTokenMangers();
    internal ISecurityTokenManager GetSecurityTokenManagerByQualifiedName(XmlQualifiedName qname);
    internal ISecurityTokenManager GetSecurityTokenManagerByTokenType(string tokenType);
    internal ISecurityTokenManager GetSecurityTokenManagerByValueType(string valueType);
    internal string GetTokenTypeFromKeyIdentifierValueType(string valueType);
    internal IDictionary get_SecurityTokenManagers();
    private IDictionary InitializeSecurityTokenManagers();
    private void CheckDefaultKeyAlgorithm(ISecurityTokenManager stm);
    private void CheckDefaultSessionKeyAlgorithm(ISecurityTokenManager stm);
    internal SecurityCryptographyConfiguration get_Cryptography();
}
public class Microsoft.Web.Services3.Security.Configuration.SecurityCryptographyConfiguration : ConfigurationElement {
    private ConfigurationProperty _encryptionFormatters;
    private ConfigurationProperty _keyExchangeFormatters;
    private ConfigurationProperty _signatureFormatters;
    private ConfigurationProperty _keyAlgorithm;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal EncryptionFormatterCollection EncryptionFormatters { get; }
    internal KeyExchangeFormatterCollection KeyExchangeFormatters { get; }
    internal SignatureFormatterCollection SignatureFormatters { get; }
    internal KeyAlgorithmCollection KeyAlgorithms { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal static ISecurityTokenManager LoadSecurityTokenManager(string typeName, string configSection, XmlNodeList configData);
    internal EncryptionFormatterCollection get_EncryptionFormatters();
    internal KeyExchangeFormatterCollection get_KeyExchangeFormatters();
    internal SignatureFormatterCollection get_SignatureFormatters();
    internal KeyAlgorithmCollection get_KeyAlgorithms();
}
public class Microsoft.Web.Services3.Security.Configuration.SecurityLimitsConfiguration : ConfigurationElement {
    private ConfigurationProperty _maxTokens;
    private ConfigurationProperty _maxSignedItems;
    private ConfigurationProperty _maxEncryptedItems;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    public int MaxTokens { get; }
    public int MaxSignedItems { get; }
    public int MaxEncryptedItems { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public int get_MaxTokens();
    public int get_MaxSignedItems();
    public int get_MaxEncryptedItems();
}
public class Microsoft.Web.Services3.Security.Configuration.SecurityLimitsValidation : ConfigurationValidatorBase {
    private string _propName;
    public SecurityLimitsValidation(string name);
    public virtual void Validate(object value);
    public virtual bool CanValidate(Type type);
}
public class Microsoft.Web.Services3.Security.Configuration.SecurityTokenKeyAlgorithmElement : ConfigurationElement {
    private ConfigurationProperty _name;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Value();
}
public class Microsoft.Web.Services3.Security.Configuration.SecurityTokenManagerCollection : ConfigurationElementCollection {
    private ISecurityTokenManager _issuedTokenManager;
    protected bool ThrowOnDuplicate { get; }
    internal ISecurityTokenManager IssuedTokenManagerInstance { get; }
    public void Add(ConfigurationElement element);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual void PostDeserialize();
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual object GetElementKey(ConfigurationElement element);
    internal ISecurityTokenManager GetSecurityToken(string qname);
    internal ISecurityTokenManager get_IssuedTokenManagerInstance();
    internal static string GetStandardTokenType(string qname);
}
public class Microsoft.Web.Services3.Security.Configuration.SecurityTokenManagerElement : ConfigElementInterceptor {
    private ConfigurationProperty _localName;
    private ConfigurationProperty _namespace;
    private ConfigurationProperty _type;
    private ConfigurationProperty _replayDetection;
    private ConfigurationProperty _renewalWindowsInSeconds;
    private ConfigurationProperty _cacheLimit;
    private ConfigurationProperty _generationLimit;
    private ConfigurationProperty _offsetlimit;
    private ConfigurationProperty _label;
    private ConfigurationProperty _keyAlgorithm;
    private ConfigurationPropertyCollection _properties;
    private ISecurityTokenManager _stm;
    protected ConfigurationPropertyCollection Properties { get; }
    internal ISecurityTokenManager Token { get; }
    internal string QName { get; }
    internal string LocalName { get; }
    internal string TokenType { get; }
    internal SecurityTokenManagerElement(string localName, string namespc, string type);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal ISecurityTokenManager get_Token();
    internal string get_QName();
    internal string get_LocalName();
    internal string get_TokenType();
    internal void LoadSecurityTokenManager(string tokenType, XmlNodeList childNodes);
}
public class Microsoft.Web.Services3.Security.Configuration.ServiceTokenCollection : ConfigurationElementCollection {
    protected bool ThrowOnDuplicate { get; }
    public void Add(ConfigurationElement element);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class Microsoft.Web.Services3.Security.Configuration.ServiceTokenConfiguration : ConfigurationElement {
    private ConfigurationProperty _uri;
    private ConfigurationProperty _keyInfo;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal KeyInfoConfiguration KeyInfo { get; }
    internal string Uri { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal KeyInfoConfiguration get_KeyInfo();
    internal string get_Uri();
}
public class Microsoft.Web.Services3.Security.Configuration.SignatureFormatterCollection : FormatterCollection {
    protected bool ThrowOnDuplicate { get; }
    protected virtual bool get_ThrowOnDuplicate();
}
public class Microsoft.Web.Services3.Security.Configuration.SkiModeValidation : ConfigurationValidatorBase {
    public virtual void Validate(object value);
    public virtual bool CanValidate(Type type);
}
public class Microsoft.Web.Services3.Security.Configuration.StatefulSCTConfiguration : ConfigurationElement {
    private ConfigurationProperty _enabled;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    public bool Enabled { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_Enabled();
}
public class Microsoft.Web.Services3.Security.Configuration.StoreLocationValidation : ConfigurationValidatorBase {
    public virtual void Validate(object value);
    public virtual bool CanValidate(Type type);
}
public class Microsoft.Web.Services3.Security.Configuration.TimeToleranceConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public class Microsoft.Web.Services3.Security.Configuration.TokenIssuerConfiguration : ConfigurationElement {
    private ConfigurationProperty _statefulSCT;
    private ConfigurationProperty _ttlInSeconds;
    private ConfigurationProperty _serviceToken;
    private ConfigurationPropertyCollection _properties;
    private IDictionary _serviceTokens;
    protected ConfigurationPropertyCollection Properties { get; }
    public bool EnableStatefulSCT { get; }
    public int TtlInSeconds { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_EnableStatefulSCT();
    private SecurityContextTokenService InstantiateSTSBehavior(Type type);
    public int get_TtlInSeconds();
    public SecurityToken GetServiceToken(AppliesTo appliesTo);
}
public class Microsoft.Web.Services3.Security.Configuration.TtlInSecondsConfigElement : ConfigurationElement {
    private ConfigurationProperty _value;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal int Value { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal int get_Value();
}
public enum Microsoft.Web.Services3.Security.Configuration.VerificationMode : Enum {
    public int value__;
    public static VerificationMode TrustedPeopleOnly;
    public static VerificationMode ChainOnly;
    public static VerificationMode TrustedPeopleOrChain;
}
public class Microsoft.Web.Services3.Security.Configuration.VerificationModeValidation : ConfigurationValidatorBase {
    public virtual void Validate(object value);
    public virtual bool CanValidate(Type type);
}
public class Microsoft.Web.Services3.Security.Configuration.X509Configuration : ConfigurationElement {
    private ConfigurationProperty _storeLocation;
    private ConfigurationProperty _verifyTrust;
    private ConfigurationProperty _allowTestRoot;
    private ConfigurationProperty _revocationMode;
    private ConfigurationProperty _verificationMode;
    private ConfigurationProperty _skiMode;
    private ConfigurationPropertyCollection _properties;
    protected ConfigurationPropertyCollection Properties { get; }
    internal StoreLocation StoreLocation { get; }
    internal bool VerifyTrust { get; }
    internal bool AllowTestRoot { get; }
    internal X509RevocationMode RevocationMode { get; }
    internal VerificationMode VerificationMode { get; }
    internal X509CertificateSkiMode SkiMode { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal StoreLocation get_StoreLocation();
    internal bool get_VerifyTrust();
    internal bool get_AllowTestRoot();
    internal X509RevocationMode get_RevocationMode();
    internal VerificationMode get_VerificationMode();
    internal X509CertificateSkiMode get_SkiMode();
}
public class Microsoft.Web.Services3.Security.CredentialSet : object {
    private Dictionary`2<Type, SecurityToken> clientTokens;
    private Dictionary`2<Type, SecurityToken> serviceTokens;
    public CredentialSet(SecurityToken clientToken);
    public CredentialSet(SecurityToken clientToken, SecurityToken serviceToken);
    public TSecurityToken SetClientToken(TSecurityToken token);
    public TSecurityToken GetClientToken();
    public IEnumerable`1<SecurityToken> GetClientTokens();
    public TSecurityToken SetServiceToken(TSecurityToken token);
    public IEnumerable`1<SecurityToken> GetServiceTokens();
    public TSecurityToken GetServiceToken();
    internal SecurityToken GetUniqueClientToken();
    internal SecurityToken GetUniqueServiceToken();
    internal static TSecurityToken ProvideClientToken(TSecurityToken token, string actor);
    internal static TSecurityToken ProvideServiceToken(TSecurityToken token, string actor);
    public sealed virtual void WriteXml(XmlWriter writer);
    private void WriteTokens(XmlWriter writer, string element, Dictionary`2<Type, SecurityToken> tokens);
    public sealed virtual void ReadXml(XmlReader reader);
    private void ReadTokens(XmlReader reader, string element, Dictionary`2<Type, SecurityToken> tokens);
    public sealed virtual XmlSchema GetSchema();
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.AES : SymmetricKeyAlgorithm {
    private Rijndael _key;
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    public SignatureFormatter SignatureFormatter { get; }
    protected AES(Rijndael key);
    protected AES(Byte[] keyBytes);
    public virtual void GenerateKey();
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public virtual Byte[] get_KeyBytes();
    public virtual void set_KeyBytes(Byte[] value);
    public virtual SignatureFormatter get_SignatureFormatter();
}
public class Microsoft.Web.Services3.Security.Cryptography.AES128 : AES {
    public EncryptionFormatter EncryptionFormatter { get; }
    public KeyExchangeFormatter KeyExchangeFormatter { get; }
    public int KeySize { get; }
    public AES128(Rijndael key);
    public AES128(Byte[] keyBytes);
    public virtual EncryptionFormatter get_EncryptionFormatter();
    public virtual KeyExchangeFormatter get_KeyExchangeFormatter();
    public virtual int get_KeySize();
}
public class Microsoft.Web.Services3.Security.Cryptography.AES128EncryptionFormatter : SymmetricEncryptionFormatter {
    public string AlgorithmURI { get; }
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    public AES128EncryptionFormatter(Rijndael key);
    public virtual string get_AlgorithmURI();
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public virtual Byte[] get_KeyBytes();
    public virtual void set_KeyBytes(Byte[] value);
}
public class Microsoft.Web.Services3.Security.Cryptography.AES128KeyExchangeFormatter : AESKeyExchangeFormatter {
    public string AlgorithmURI { get; }
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    public AES128KeyExchangeFormatter(Rijndael key);
    public virtual string get_AlgorithmURI();
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public virtual Byte[] get_KeyBytes();
    public virtual void set_KeyBytes(Byte[] value);
}
public class Microsoft.Web.Services3.Security.Cryptography.AES192 : AES {
    public EncryptionFormatter EncryptionFormatter { get; }
    public KeyExchangeFormatter KeyExchangeFormatter { get; }
    public int KeySize { get; }
    public AES192(Rijndael key);
    public AES192(Byte[] keyBytes);
    public virtual EncryptionFormatter get_EncryptionFormatter();
    public virtual KeyExchangeFormatter get_KeyExchangeFormatter();
    public virtual int get_KeySize();
}
public class Microsoft.Web.Services3.Security.Cryptography.AES192EncryptionFormatter : SymmetricEncryptionFormatter {
    public string AlgorithmURI { get; }
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    public AES192EncryptionFormatter(Rijndael key);
    public virtual string get_AlgorithmURI();
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public virtual Byte[] get_KeyBytes();
    public virtual void set_KeyBytes(Byte[] value);
}
public class Microsoft.Web.Services3.Security.Cryptography.AES192KeyExchangeFormatter : AESKeyExchangeFormatter {
    public string AlgorithmURI { get; }
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    public AES192KeyExchangeFormatter(Rijndael key);
    public virtual string get_AlgorithmURI();
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public virtual Byte[] get_KeyBytes();
    public virtual void set_KeyBytes(Byte[] value);
}
public class Microsoft.Web.Services3.Security.Cryptography.AES256 : AES {
    public EncryptionFormatter EncryptionFormatter { get; }
    public KeyExchangeFormatter KeyExchangeFormatter { get; }
    public int KeySize { get; }
    public AES256(Rijndael key);
    public AES256(Byte[] keyBytes);
    public virtual EncryptionFormatter get_EncryptionFormatter();
    public virtual KeyExchangeFormatter get_KeyExchangeFormatter();
    public virtual int get_KeySize();
}
public class Microsoft.Web.Services3.Security.Cryptography.AES256EncryptionFormatter : SymmetricEncryptionFormatter {
    public string AlgorithmURI { get; }
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    public AES256EncryptionFormatter(Rijndael key);
    public virtual string get_AlgorithmURI();
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public virtual Byte[] get_KeyBytes();
    public virtual void set_KeyBytes(Byte[] value);
}
public class Microsoft.Web.Services3.Security.Cryptography.AES256KeyExchangeFormatter : AESKeyExchangeFormatter {
    public string AlgorithmURI { get; }
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    public AES256KeyExchangeFormatter(Rijndael key);
    public virtual string get_AlgorithmURI();
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public virtual Byte[] get_KeyBytes();
    public virtual void set_KeyBytes(Byte[] value);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.AESKeyExchangeFormatter : SymmetricKeyExchangeFormatter {
    private static Byte[] AES_KW_IV;
    protected AESKeyExchangeFormatter(Rijndael key);
    private static AESKeyExchangeFormatter();
    public virtual Byte[] DecryptKey(Byte[] cipherKey);
    public virtual Byte[] EncryptKey(Byte[] plainKey);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.AsymmetricEncryptionFormatter : EncryptionFormatter {
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.AsymmetricKeyAlgorithm : KeyAlgorithm {
    private string _defaultSessionKeyAlgorithm;
    public string DefaultSessionKeyAlgorithm { get; public set; }
    public AsymmetricAlgorithm Key { get; public set; }
    protected AsymmetricKeyAlgorithm(AsymmetricAlgorithm key);
    public string get_DefaultSessionKeyAlgorithm();
    public void set_DefaultSessionKeyAlgorithm(string value);
    public virtual SymmetricKeyAlgorithm GenerateSessionKey();
    public virtual SymmetricKeyAlgorithm GenerateSessionKey(Byte[] keyBytes);
    public abstract virtual AsymmetricAlgorithm get_Key();
    public abstract virtual void set_Key(AsymmetricAlgorithm value);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.AsymmetricKeyExchangeFormatter : KeyExchangeFormatter {
    protected AsymmetricKeyExchangeFormatter(AsymmetricAlgorithm key);
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.AsymmetricSignatureFormatter : SignatureFormatter {
    public AsymmetricAlgorithm Key { get; public set; }
    public abstract virtual AsymmetricAlgorithm get_Key();
    public abstract virtual void set_Key(AsymmetricAlgorithm value);
}
internal class Microsoft.Web.Services3.Security.Cryptography.DataProtectionSecurityStateEncoder : SecurityStateEncoder {
    private Byte[] _entropy;
    private DataProtectionScope _protectionScope;
    public DataProtectionScope ProtectionScope { get; }
    public DataProtectionSecurityStateEncoder(DataProtectionScope protectionScope);
    public DataProtectionSecurityStateEncoder(DataProtectionScope protectionScope, Byte[] entropy);
    public DataProtectionScope get_ProtectionScope();
    public Byte[] GetEntropy();
    protected internal virtual Byte[] DecodeSecurityState(Byte[] data);
    protected internal virtual Byte[] EncodeSecurityState(Byte[] data);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.EncryptionFormatter : object {
    public string AlgorithmURI { get; }
    public string Parameters { get; public set; }
    public abstract virtual string get_AlgorithmURI();
    public abstract virtual Byte[] Decrypt(Byte[] data);
    public abstract virtual Byte[] Encrypt(Byte[] data);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
}
public class Microsoft.Web.Services3.Security.Cryptography.HMACSHA1SignatureFormatter : KeyedHashSignatureFormatter {
    private Byte[] _key;
    public string AlgorithmURI { get; }
    public Byte[] Key { get; public set; }
    public HMACSHA1SignatureFormatter(Byte[] key);
    public virtual string get_AlgorithmURI();
    public virtual Byte[] Sign(Byte[] data);
    public virtual Byte[] Sign(Stream data);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual bool Verify(Byte[] signature, Byte[] data);
    public virtual bool Verify(Byte[] signature, Stream data);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.KeyAlgorithm : object {
    public EncryptionFormatter EncryptionFormatter { get; }
    public KeyExchangeFormatter KeyExchangeFormatter { get; }
    public SignatureFormatter SignatureFormatter { get; }
    public static KeyAlgorithm Create(string name);
    public static void VerifyValidAlgorithm(string algorithm);
    private static object CreateFormatter(object typeOrName);
    public static object CreateEncryptionFormatter(string uri);
    public static object CreateKeyExchangeFormatter(string uri);
    public static object CreateSignatureFormatter(string uri);
    public abstract virtual EncryptionFormatter get_EncryptionFormatter();
    public abstract virtual KeyExchangeFormatter get_KeyExchangeFormatter();
    public abstract virtual SignatureFormatter get_SignatureFormatter();
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.KeyedHashSignatureFormatter : SignatureFormatter {
    public Byte[] Key { get; public set; }
    public abstract virtual Byte[] get_Key();
    public abstract virtual void set_Key(Byte[] value);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.KeyExchangeFormatter : object {
    public string AlgorithmURI { get; }
    public string Parameters { get; public set; }
    public abstract virtual string get_AlgorithmURI();
    public abstract virtual Byte[] DecryptKey(Byte[] cipherKey);
    public abstract virtual Byte[] EncryptKey(Byte[] plainKey);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
}
public class Microsoft.Web.Services3.Security.Cryptography.PSHA1 : object {
    private Byte[] secret;
    private Byte[] seed;
    private Byte[] aValue;
    private Byte[] chunk;
    private int index;
    private int _position;
    private HMACSHA1 hmac;
    public PSHA1(Byte[] secret, Byte[] labelSeed);
    public PSHA1(Byte[] secret, string label, Byte[] seed);
    private byte GetByte();
    public Byte[] GetKeyBytes(int position, int size);
}
internal class Microsoft.Web.Services3.Security.Cryptography.RandomKeyGenerator : object {
    private static int WeakKeyGenerationLoopLimit;
    internal static Byte[] GetBytes(int count);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.RSA : AsymmetricKeyAlgorithm {
    private RSA _key;
    public EncryptionFormatter EncryptionFormatter { get; }
    public SignatureFormatter SignatureFormatter { get; }
    public AsymmetricAlgorithm Key { get; public set; }
    protected RSA(RSA key);
    public virtual EncryptionFormatter get_EncryptionFormatter();
    public virtual SignatureFormatter get_SignatureFormatter();
    public virtual AsymmetricAlgorithm get_Key();
    public virtual void set_Key(AsymmetricAlgorithm value);
}
public class Microsoft.Web.Services3.Security.Cryptography.RSA15 : RSA {
    public KeyExchangeFormatter KeyExchangeFormatter { get; }
    public RSA15(RSA key);
    public virtual KeyExchangeFormatter get_KeyExchangeFormatter();
}
public class Microsoft.Web.Services3.Security.Cryptography.RSA15EncryptionFormatter : AsymmetricEncryptionFormatter {
    private RSA _key;
    public string AlgorithmURI { get; }
    public RSA15EncryptionFormatter(RSA key);
    public virtual string get_AlgorithmURI();
    public virtual Byte[] Decrypt(Byte[] data);
    public virtual Byte[] Encrypt(Byte[] data);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class Microsoft.Web.Services3.Security.Cryptography.RSA15KeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    private RSA _key;
    private string _parameters;
    public string AlgorithmURI { get; }
    public RSA15KeyExchangeFormatter(AsymmetricAlgorithm key);
    public virtual string get_AlgorithmURI();
    public virtual Byte[] DecryptKey(Byte[] cipherKey);
    public virtual Byte[] EncryptKey(Byte[] plainKey);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class Microsoft.Web.Services3.Security.Cryptography.RSAOAEP : RSA {
    public KeyExchangeFormatter KeyExchangeFormatter { get; }
    public RSAOAEP(RSA key);
    public virtual KeyExchangeFormatter get_KeyExchangeFormatter();
}
public class Microsoft.Web.Services3.Security.Cryptography.RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    private RSA _key;
    private string _parameters;
    public string AlgorithmURI { get; }
    public string Parameters { get; public set; }
    public RSAOAEPKeyExchangeFormatter(AsymmetricAlgorithm key);
    public virtual string get_AlgorithmURI();
    public virtual Byte[] DecryptKey(Byte[] cipherKey);
    public virtual Byte[] EncryptKey(Byte[] plainKey);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class Microsoft.Web.Services3.Security.Cryptography.RSASHA1SignatureFormatter : AsymmetricSignatureFormatter {
    private RSA _key;
    public string AlgorithmURI { get; }
    public AsymmetricAlgorithm Key { get; public set; }
    public RSASHA1SignatureFormatter(RSA key);
    public virtual string get_AlgorithmURI();
    public virtual bool Verify(Byte[] signature, Byte[] data);
    public virtual bool Verify(Byte[] signature, Stream data);
    private bool VerifyHash(Byte[] signature, Byte[] rgbHash);
    public virtual Byte[] Sign(Byte[] data);
    public virtual Byte[] Sign(Stream data);
    private Byte[] SignHash(Byte[] rgbHash);
    public virtual AsymmetricAlgorithm get_Key();
    public virtual void set_Key(AsymmetricAlgorithm value);
}
internal abstract class Microsoft.Web.Services3.Security.Cryptography.SecurityStateEncoder : object {
    protected internal abstract virtual Byte[] DecodeSecurityState(Byte[] data);
    protected internal abstract virtual Byte[] EncodeSecurityState(Byte[] data);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.SignatureFormatter : object {
    public string AlgorithmURI { get; }
    public abstract virtual string get_AlgorithmURI();
    public abstract virtual Byte[] Sign(Byte[] data);
    public abstract virtual Byte[] Sign(Stream data);
    public abstract virtual bool Verify(Byte[] signature, Byte[] data);
    public abstract virtual bool Verify(Byte[] signature, Stream data);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.SymmetricEncryptionFormatter : EncryptionFormatter {
    private SymmetricAlgorithm _key;
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    protected SymmetricEncryptionFormatter(SymmetricAlgorithm key);
    public virtual Byte[] Decrypt(Byte[] data);
    public virtual Byte[] Encrypt(Byte[] data);
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public abstract virtual Byte[] get_KeyBytes();
    public abstract virtual void set_KeyBytes(Byte[] value);
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.SymmetricKeyAlgorithm : KeyAlgorithm {
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    public int KeySize { get; }
    protected SymmetricKeyAlgorithm(SymmetricAlgorithm key);
    protected SymmetricKeyAlgorithm(Byte[] key);
    public abstract virtual void GenerateKey();
    public abstract virtual SymmetricAlgorithm get_Key();
    public abstract virtual void set_Key(SymmetricAlgorithm value);
    public abstract virtual Byte[] get_KeyBytes();
    public abstract virtual void set_KeyBytes(Byte[] value);
    public abstract virtual int get_KeySize();
}
public abstract class Microsoft.Web.Services3.Security.Cryptography.SymmetricKeyExchangeFormatter : KeyExchangeFormatter {
    private SymmetricAlgorithm _key;
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    protected SymmetricKeyExchangeFormatter(SymmetricAlgorithm key);
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public abstract virtual Byte[] get_KeyBytes();
    public abstract virtual void set_KeyBytes(Byte[] value);
}
public class Microsoft.Web.Services3.Security.Cryptography.TripleDES : SymmetricKeyAlgorithm {
    private TripleDES _key;
    public EncryptionFormatter EncryptionFormatter { get; }
    public KeyExchangeFormatter KeyExchangeFormatter { get; }
    public SignatureFormatter SignatureFormatter { get; }
    public SymmetricAlgorithm Key { get; public set; }
    public int KeySize { get; }
    public Byte[] KeyBytes { get; public set; }
    public TripleDES(SymmetricAlgorithm key);
    public TripleDES(Byte[] keyBytes);
    public virtual EncryptionFormatter get_EncryptionFormatter();
    public virtual KeyExchangeFormatter get_KeyExchangeFormatter();
    public virtual SignatureFormatter get_SignatureFormatter();
    public virtual void GenerateKey();
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public virtual int get_KeySize();
    public virtual Byte[] get_KeyBytes();
    public virtual void set_KeyBytes(Byte[] value);
}
public class Microsoft.Web.Services3.Security.Cryptography.TripleDESEncryptionFormatter : SymmetricEncryptionFormatter {
    public string AlgorithmURI { get; }
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    public TripleDESEncryptionFormatter(TripleDES key);
    public virtual string get_AlgorithmURI();
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public virtual Byte[] get_KeyBytes();
    public virtual void set_KeyBytes(Byte[] value);
}
public class Microsoft.Web.Services3.Security.Cryptography.TripleDESKeyExchangeFormatter : SymmetricKeyExchangeFormatter {
    private static Byte[] s_rgbTripleDES_KW_IV;
    public string AlgorithmURI { get; }
    public SymmetricAlgorithm Key { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    public TripleDESKeyExchangeFormatter(TripleDES key);
    private static TripleDESKeyExchangeFormatter();
    public virtual string get_AlgorithmURI();
    public virtual Byte[] DecryptKey(Byte[] cipherKey);
    public virtual Byte[] EncryptKey(Byte[] plainKey);
    public virtual SymmetricAlgorithm get_Key();
    public virtual void set_Key(SymmetricAlgorithm value);
    public virtual Byte[] get_KeyBytes();
    public virtual void set_KeyBytes(Byte[] value);
}
internal class Microsoft.Web.Services3.Security.DefaultSecurityTokenServicePolicy : Policy {
    private static DefaultSecurityTokenServicePolicy instance;
    public static DefaultSecurityTokenServicePolicy Instance { get; }
    public static DefaultSecurityTokenServicePolicy get_Instance();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Web.Services3.Security.DependancyTable : object {
    private ArrayList _undoneSet;
    internal DependancyTableItem Item { get; }
    internal DependancyTableItem get_Item(object value);
    internal DependancyTableItem Add(object value);
    internal ArrayList GetOrderedList();
    internal void AddNode(DependancyTableItem item, ArrayList doneSet);
}
internal class Microsoft.Web.Services3.Security.DependancyTableItem : object {
    private ArrayList _dependancyList;
    private object _value;
    private bool _done;
    private bool _waiting;
    internal ArrayList DependancyList { get; }
    internal object Value { get; }
    internal bool Done { get; internal set; }
    internal bool Waiting { get; internal set; }
    internal DependancyTableItem(object value);
    internal ArrayList get_DependancyList();
    internal object get_Value();
    internal bool get_Done();
    internal void set_Done(bool value);
    internal bool get_Waiting();
    internal void set_Waiting(bool value);
}
public class Microsoft.Web.Services3.Security.Embedded : OpenElement {
    private string _id;
    private SecurityToken _token;
    private bool _loaded;
    public string Id { get; public set; }
    public SecurityToken Token { get; public set; }
    public Embedded(SecurityToken token);
    public Embedded(XmlElement element);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public string get_Id();
    public void set_Id(string value);
    public virtual void LoadXml(XmlElement element);
    public SecurityToken get_Token();
    public void set_Token(SecurityToken value);
}
public class Microsoft.Web.Services3.Security.EncryptedData : object {
    private SecurityToken _token;
    private EncryptionMethod _encryptionMethod;
    private CipherData _cipherData;
    private Byte[] _ciphertext;
    private EncryptedKey _encryptedKey;
    private SymmetricKeyAlgorithm _encryptionKey;
    private string _id;
    private KeyInfo _keyInfo;
    private ReferenceList _referenceList;
    private string _type;
    private Security _container;
    private EncryptionReferenceCollection _encryptionReferences;
    private bool _includeBodyElement;
    private ArrayList _encryptedDataItems;
    private XmlElementCollection _targetElementList;
    private Dictionary`2<XmlElement, string> targetElementToEncryptedDataIdMap;
    private bool _referenceListInsideEKT;
    internal string Id { get; }
    internal Dictionary`2<XmlElement, string> TargetElementToEncryptedDataIdMap { get; }
    public Security Container { get; public set; }
    private SymmetricKeyAlgorithm EncryptionKey { get; }
    public EncryptionMethod EncryptionMethod { get; }
    public EncryptionReferenceCollection EncryptionReferences { get; }
    public bool IncludeBodyElement { get; public set; }
    public string Reference { get; }
    public SecurityToken SecurityToken { get; }
    public EncryptedKey EncryptedKey { get; }
    public KeyInfo KeyInfo { get; public set; }
    internal ReferenceList ReferenceList { get; }
    internal bool ReferenceListInsideEKT { get; }
    public XmlElement TargetElement { get; }
    public XmlElementCollection TargetElementList { get; }
    private SecurityTokenCollection Tokens { get; }
    public string Type { get; public set; }
    public EncryptedData(SecurityToken token);
    public EncryptedData(SecurityToken token, string reference);
    public EncryptedData(EncryptedKeyToken token, bool referenceListInsideToken);
    public EncryptedData(EncryptedKeyToken token, string reference, bool referenceListInsideToken);
    public EncryptedData(XmlElement element);
    public EncryptedData(XmlElement element, EncryptedKey encryptedKey);
    internal string get_Id();
    internal Dictionary`2<XmlElement, string> get_TargetElementToEncryptedDataIdMap();
    private void Initialize(SecurityToken token, string reference, bool referenceListInside);
    public void AddReference(EncryptionReference reference);
    public void AddReference(string reference, string type);
    public sealed virtual Security get_Container();
    public sealed virtual void set_Container(Security value);
    public void Decrypt();
    public XmlElement Decrypt(XmlElement encryptedElement);
    public void Encrypt(XmlDocument message);
    private void Encrypt(XmlDocument message, XmlElement targetElement, string type, string id);
    internal XmlElement EncryptContent(XmlDocument document, XmlElement element, string id);
    private XmlElement EncryptElement(XmlDocument document, XmlElement element, string id);
    private SymmetricKeyAlgorithm get_EncryptionKey();
    public EncryptionMethod get_EncryptionMethod();
    private XmlElement GetIdElement(XmlDocument document, string idValue);
    private XmlElement GetIdElement(XmlElement element, string idValue);
    public EncryptionReferenceCollection get_EncryptionReferences();
    public bool get_IncludeBodyElement();
    public void set_IncludeBodyElement(bool value);
    public string get_Reference();
    private KeyAlgorithm ResolveDecryptionKey(string algorithmUri, KeyInfo keyInfo);
    public SecurityToken get_SecurityToken();
    public EncryptedKey get_EncryptedKey();
    public KeyInfo get_KeyInfo();
    public void set_KeyInfo(KeyInfo value);
    internal ReferenceList get_ReferenceList();
    internal bool get_ReferenceListInsideEKT();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public sealed virtual void LoadXml(XmlElement element);
    public XmlElement get_TargetElement();
    public XmlElementCollection get_TargetElementList();
    private SecurityTokenCollection get_Tokens();
    public string get_Type();
    public void set_Type(string value);
}
public class Microsoft.Web.Services3.Security.EncryptedKey : object {
    private SecurityToken _token;
    private EncryptionMethod _encryptionMethod;
    private KeyInfo _keyInfo;
    private ReferenceList _referenceList;
    private Byte[] _keyCipher;
    private Byte[] _keyBytes;
    private Security _container;
    private string _carriedKeyName;
    private string _id;
    public string CarriedKeyName { get; public set; }
    public Security Container { get; public set; }
    private KeyAlgorithm DecryptionKey { get; }
    public EncryptionMethod EncryptionMethod { get; }
    private KeyAlgorithm EncryptionKey { get; }
    internal string Id { get; internal set; }
    public KeyInfo KeyInfo { get; public set; }
    public ReferenceList ReferenceList { get; }
    public SecurityToken SecurityToken { get; }
    public Byte[] KeyBytes { get; }
    public Byte[] KeyCipher { get; }
    public EncryptedKey(SecurityToken token, Byte[] keyData);
    public EncryptedKey(XmlElement element);
    public string get_CarriedKeyName();
    public void set_CarriedKeyName(string value);
    public Security get_Container();
    public void set_Container(Security value);
    public void Decrypt();
    private KeyAlgorithm get_DecryptionKey();
    public void Encrypt();
    public EncryptionMethod get_EncryptionMethod();
    private KeyAlgorithm get_EncryptionKey();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    internal string get_Id();
    internal void set_Id(string value);
    public KeyInfo get_KeyInfo();
    public void set_KeyInfo(KeyInfo value);
    public sealed virtual void LoadXml(XmlElement element);
    public ReferenceList get_ReferenceList();
    public SecurityToken get_SecurityToken();
    public Byte[] get_KeyBytes();
    public Byte[] get_KeyCipher();
}
public class Microsoft.Web.Services3.Security.EncryptionMethod : object {
    private string _algorithm;
    private string _parameters;
    public string Algorithm { get; }
    public string Parameters { get; public set; }
    public EncryptionMethod(string algorithm);
    public EncryptionMethod(XmlElement element);
    public string get_Algorithm();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public sealed virtual void LoadXml(XmlElement element);
    public string get_Parameters();
    public void set_Parameters(string value);
}
public class Microsoft.Web.Services3.Security.EncryptionReference : object {
    private string _type;
    private string _reference;
    private string _id;
    internal string Id { get; }
    public string Reference { get; }
    public string Type { get; public set; }
    public EncryptionReference(string reference);
    public EncryptionReference(string reference, string type);
    internal string get_Id();
    public string get_Reference();
    public string get_Type();
    public void set_Type(string value);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Security.EncryptionReferenceCollection : object {
    private ArrayList _referencesList;
    public EncryptionReference Item { get; }
    public int Count { get; }
    public EncryptionReference get_Item(int index);
    public void Add(EncryptionReference reference);
    public void Add(string reference, string type);
    public int get_Count();
    public IEnumerator GetEnumerator();
}
public class Microsoft.Web.Services3.Security.Entropy : OpenElement {
    private static int _entropySizeLimit;
    private EncryptedKey _encryptedKey;
    private BinarySecret _secret;
    public BinarySecret BinarySecret { get; }
    public EncryptedKey EncryptedKey { get; }
    public Byte[] KeyBytes { get; }
    public Entropy(int sizeInBytes);
    public Entropy(int sizeInBytes, SecurityToken encryptingToken);
    public Entropy(Byte[] secret);
    public Entropy(Byte[] key, SecurityToken encryptingToken);
    public Entropy(XmlElement element);
    public BinarySecret get_BinarySecret();
    public EncryptedKey get_EncryptedKey();
    public virtual XmlElement GetXml(XmlDocument document);
    public Byte[] get_KeyBytes();
    public virtual void LoadXml(XmlElement element);
}
public class Microsoft.Web.Services3.Security.GenericTokenServiceClient : SecurityTokenServiceClient {
    public GenericTokenServiceClient(EndpointReference endpoint);
    public virtual IAsyncResult BeginIssueGenericToken(string tokenType, AppliesTo appliesTo, AsyncCallback callback, object state);
    public virtual IssuedToken EndIssueGenericToken(IAsyncResult result);
    public virtual IAsyncResult BeginCancelGenericToken(IssuedToken cancelTarget, AsyncCallback callback, object state);
    public virtual void EndCancelGenericToken(IAsyncResult result);
    public IssuedToken IssueGenericToken(string tokenType, AppliesTo appliesTo);
    public void CancelGenericToken(IssuedToken cancelTarget);
    protected virtual IssuedToken RetrieveIssuedToken(RequestSecurityToken request, RequestSecurityTokenResponse response);
}
public class Microsoft.Web.Services3.Security.Identifier : object {
    private string _identifier;
    private XmlAttribute[] _attributes;
    public string Value { get; }
    public Identifier(string identifier);
    public Identifier(XmlElement element);
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public sealed virtual void LoadXml(XmlElement element);
    public string get_Value();
}
public interface Microsoft.Web.Services3.Security.ISecureConversationEvents {
    public abstract virtual void add_SecureConversationCreated(EventHandler`1<SecureConversationEventArgs> value);
    public abstract virtual void remove_SecureConversationCreated(EventHandler`1<SecureConversationEventArgs> value);
}
public interface Microsoft.Web.Services3.Security.ISecurityElement {
    public Security Container { get; public set; }
    public abstract virtual Security get_Container();
    public abstract virtual void set_Container(Security value);
}
public class Microsoft.Web.Services3.Security.KeyIdentifier : OpenAttributeElement {
    private string _identifier;
    private string _valueType;
    private string _encodingType;
    private string _id;
    private string _tokenType;
    public string EncodingType { get; }
    public string Id { get; public set; }
    public string Identifier { get; }
    public Byte[] Value { get; }
    internal string TokenType { get; }
    public string ValueType { get; }
    public KeyIdentifier(string identifier);
    public KeyIdentifier(string identifier, string valueType);
    public KeyIdentifier(string identifier, string valueType, string encodingType);
    public KeyIdentifier(Byte[] identifier);
    public KeyIdentifier(Byte[] identifier, string valueType);
    public KeyIdentifier(XmlElement element);
    private void CheckValid();
    public string get_EncodingType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public string get_Id();
    public void set_Id(string value);
    public string get_Identifier();
    public virtual void LoadXml(XmlElement element);
    public Byte[] get_Value();
    internal string get_TokenType();
    public string get_ValueType();
}
public class Microsoft.Web.Services3.Security.KeyInfoHelper : object {
    public static XmlElement GetXmlKeyInfo(XmlDocument document, KeyInfo keyInfo);
    public static KeyInfo LoadXmlKeyInfo(XmlElement element);
}
public class Microsoft.Web.Services3.Security.LifeTime : object {
    private Created _created;
    private Expires _expires;
    public DateTime Created { get; }
    public DateTime Expires { get; }
    public bool IsCurrent { get; }
    public bool IsExpired { get; }
    public LifeTime(long ttlInSeconds);
    public LifeTime(DateTime created, long ttlInSeconds);
    public LifeTime(DateTime expires);
    public LifeTime(DateTime created, DateTime expires);
    public LifeTime(XmlElement element);
    public DateTime get_Created();
    public DateTime get_Expires();
    public bool get_IsCurrent();
    public bool get_IsExpired();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public sealed virtual void LoadXml(XmlElement element);
}
internal enum Microsoft.Web.Services3.Security.LogonProvider : Enum {
    public int value__;
    public static LogonProvider LOGON32_PROVIDER_DEFAULT;
}
internal enum Microsoft.Web.Services3.Security.LogonType : Enum {
    public int value__;
    public static LogonType LOGON32_LOGON_INTERACTIVE;
    public static LogonType LOGON32_LOGON_NETWORK;
    public static LogonType LOGON32_LOGON_BATCH;
    public static LogonType LOGON32_LOGON_SERVICE;
    public static LogonType LOGON32_LOGON_UNLOCK;
    public static LogonType LOGON32_LOGON_NETWORK_CLEARTEXT;
    public static LogonType LOGON32_LOGON_NEW_CREDENTIALS;
}
public class Microsoft.Web.Services3.Security.MessageSignature : object {
    private static string Xml;
    private static string Xmlns;
    private static string XmlnsPrefix;
    private SignedXmlSignature m_signature;
    private ArrayList _autoReferences;
    private XmlDocument _document;
    private XmlElement _ownerElement;
    private KeyAlgorithm _signingKey;
    private SignatureOptions _signatureOptions;
    private bool _signing;
    private XmlElement m_parentElement;
    private XmlElement targetElement;
    private Boolean[] m_refProcessed;
    private Int32[] m_refLevelCache;
    private Hashtable _idElements;
    public XmlElement TargetElement { get; }
    public KeyInfo KeyInfo { get; public set; }
    public Security Container { get; public set; }
    public XmlDocument Document { get; public set; }
    public XmlElement OwnerElement { get; public set; }
    public SignedXmlSignature Signature { get; }
    public string SignatureLength { get; }
    public string SignatureMethod { get; }
    public SignatureOptions SignatureOptions { get; public set; }
    public Byte[] SignatureValue { get; }
    public SignedInfo SignedInfo { get; }
    public KeyAlgorithm SigningKey { get; public set; }
    public SecurityToken SigningToken { get; public set; }
    private KeyAlgorithm VerificationKey { get; private set; }
    public MessageSignature(SecurityToken token);
    public MessageSignature(XmlDocument document);
    public XmlElement get_TargetElement();
    public KeyInfo get_KeyInfo();
    public void set_KeyInfo(KeyInfo value);
    public void AddReference(SignatureReference reference);
    public void AddObject(DataObject dataObject);
    private void BuildDigestedReferences();
    private Byte[] BuildSignedInfo(SignatureFormatter formatter);
    private bool CheckDigestedReferences();
    private bool CheckAsymmetricSignature(AsymmetricKeyAlgorithm key);
    private bool CheckKeyedHashSignature(SymmetricKeyAlgorithm key);
    public bool CheckSignature();
    public bool CheckSignature(KeyAlgorithm key);
    public bool CheckSignature(SecurityToken token);
    private bool CheckSignedInfo(SignatureFormatter formatter);
    protected void ClearIdElements();
    private void ComputeAsymmetricSignature(AsymmetricKeyAlgorithm key);
    private void ComputeKeyedHashSignature(SymmetricKeyAlgorithm key);
    public void ComputeSignature();
    public void ComputeSignature(KeyAlgorithm signingKey);
    public void ComputeSignature(SecurityToken token);
    private Stream CanonicalizeSignedInfo();
    private object ComputeSignedInfo(HashAlgorithm hash);
    public sealed virtual Security get_Container();
    public sealed virtual void set_Container(Security value);
    internal static Transform CreateTransform(string algorithm);
    internal static Transform CreateTransform(string algorithm, string inclusiveNamespacesPrefixList);
    internal static string DiscardWhiteSpaces(string inputBuffer);
    internal static string DiscardWhiteSpaces(string inputBuffer, int inputOffset, int inputCount);
    public XmlDocument get_Document();
    public void set_Document(XmlDocument value);
    private void FindIdElements(XmlElement element);
    public virtual XmlElement GetIdElement(XmlDocument document, string idValue);
    internal static Hashtable GetPropagatedAttributes(XmlElement elem);
    private int GetReferenceLevel(int index, ArrayList references);
    public sealed virtual XmlElement GetXml(XmlDocument document);
    private static bool IsReferenceProperty(XmlDocument document, XmlElement child);
    private static bool IsReferenceParameter(XmlDocument document, XmlElement child);
    public sealed virtual void LoadXml(XmlElement element);
    public XmlElement get_OwnerElement();
    public void set_OwnerElement(XmlElement value);
    internal static void RemovePropagatedAttributes(ArrayList removeList, XmlElement targetElement);
    internal static ArrayList SetPropagatedAttributes(XmlElement parentNode, XmlElement targetNode);
    internal static ArrayList SetPropagatedAttributes(Hashtable namespaces, XmlElement targetNode);
    private void Sign(XmlElement element);
    private void Sign(XmlElement parent, string localName, string namespaceuri);
    public SignedXmlSignature get_Signature();
    public string get_SignatureLength();
    public string get_SignatureMethod();
    public SignatureOptions get_SignatureOptions();
    public void set_SignatureOptions(SignatureOptions value);
    public Byte[] get_SignatureValue();
    public SignedInfo get_SignedInfo();
    public KeyAlgorithm get_SigningKey();
    public void set_SigningKey(KeyAlgorithm value);
    public SecurityToken get_SigningToken();
    public void set_SigningToken(SecurityToken value);
    private KeyAlgorithm get_VerificationKey();
    private void set_VerificationKey(KeyAlgorithm value);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Web.Services3.Security.MRUHashtable : object {
    private int _capacity;
    private Hashtable _timeTable;
    private Hashtable _mruItemTable;
    public object Item { get; public set; }
    public int Count { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public MRUHashtable(int capacity);
    public object get_Item(object key);
    public void set_Item(object key, object value);
    public object Add(object key, object value);
    public void Clear();
    public bool Contains(object key);
    public int get_Count();
    public IEnumerator GetEnumerator();
    private object KickOutMRUItem();
    public void Remove(object key);
    public object get_SyncRoot();
    private void UpdateAccessTime(object key);
    public ICollection get_Values();
}
internal class Microsoft.Web.Services3.Security.NativeMethods : object {
    internal static bool CloseHandle(IntPtr hObject);
    internal static bool LogonUser(string lpszUsername, string lpszDomain, string lpszPassword, LogonType dwLogonType, LogonProvider dwLogonProvider, IntPtr& phToken);
}
public class Microsoft.Web.Services3.Security.Nonce : object {
    private static RandomNumberGenerator Generator;
    private Byte[] _nonce;
    private string _value;
    public string Value { get; }
    public Nonce(XmlElement element);
    public Nonce(int size);
    private static Nonce();
    public string get_Value();
    public Byte[] GetValueBytes();
    public sealed virtual void LoadXml(XmlElement element);
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public XmlElement GetXml(XmlDocument document, bool useSCNamespace);
}
internal class Microsoft.Web.Services3.Security.NonceTable : object {
    private TimeSpan _replayWindow;
    private Hashtable _table;
    private ArrayList _orderedList;
    public NonceTable(TimeSpan replayWindow);
    public void Process(string nonceString);
    private void Purge();
}
public class Microsoft.Web.Services3.Security.Properties : object {
    private string _name;
    private string _label;
    private Nonce _nonce;
    public string Label { get; public set; }
    public string Name { get; public set; }
    public Nonce Nonce { get; public set; }
    public Properties(XmlElement element);
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public string get_Label();
    public void set_Label(string value);
    public sealed virtual void LoadXml(XmlElement element);
    public string get_Name();
    public void set_Name(string value);
    public Nonce get_Nonce();
    public void set_Nonce(Nonce value);
}
public abstract class Microsoft.Web.Services3.Security.ReceiveSecurityFilter : SoapFilter {
    private string _localActor;
    private string _serviceActor;
    protected ReceiveSecurityFilter(string serviceActor, bool isClient);
    protected ReceiveSecurityFilter(string serviceActor, bool isClient, string clientActor);
    public virtual string GetServiceActor(Soap soapVersion);
    public virtual string GetLocalActor(Soap soapVersion);
    public virtual IEnumerable`1<SecurityToken> GetUnattachedTokens(SoapContext context);
    public abstract virtual void ValidateMessageSecurity(SoapEnvelope envelope, Security security);
    public virtual SoapServerMethod RouteRequest(SoapEnvelope envelope);
    public virtual SoapFilterResult ProcessMessage(SoapEnvelope envelope);
}
public class Microsoft.Web.Services3.Security.ReferenceList : object {
    private ArrayList _refList;
    public int Count { get; }
    public ReferenceList(XmlElement element);
    public void Add(string reference);
    public void Prepend(string reference);
    internal void Clear();
    public bool Contains(string reference);
    public int get_Count();
    public IEnumerator GetEnumerator();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public sealed virtual void LoadXml(XmlElement element);
}
public class Microsoft.Web.Services3.Security.RequestedProofToken : OpenElementElement {
    private EncryptedKey _encryptedKey;
    private BinarySecret _secret;
    private string _computedKeyAlgorithm;
    public BinarySecret BinarySecret { get; }
    public EncryptedKey EncryptedKey { get; }
    public Byte[] KeyBytes { get; }
    public string ComputedKeyAlgorithm { get; public set; }
    public RequestedProofToken(Byte[] secret);
    public RequestedProofToken(Byte[] key, SecurityToken encryptingToken);
    public RequestedProofToken(XmlElement element);
    public BinarySecret get_BinarySecret();
    public EncryptedKey get_EncryptedKey();
    public virtual XmlElement GetXml(XmlDocument document);
    public Byte[] get_KeyBytes();
    public virtual void LoadXml(XmlElement element);
    public string get_ComputedKeyAlgorithm();
    public void set_ComputedKeyAlgorithm(string value);
}
public class Microsoft.Web.Services3.Security.RequestedSecurityToken : object {
    private SecurityToken _securityToken;
    private SecurityToken _signingToken;
    public SecurityToken SecurityToken { get; public set; }
    public SecurityToken SigningToken { get; public set; }
    public RequestedSecurityToken(SecurityToken securityToken);
    public RequestedSecurityToken(XmlElement element);
    public static RequestedSecurityToken op_Implicit(SecurityToken token);
    public static SecurityToken op_Implicit(RequestedSecurityToken requestedSecurityToken);
    private void CheckValid();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public sealed virtual void LoadXml(XmlElement element);
    public SecurityToken get_SecurityToken();
    public void set_SecurityToken(SecurityToken value);
    public SecurityToken get_SigningToken();
    public void set_SigningToken(SecurityToken value);
}
internal class Microsoft.Web.Services3.Security.RequestSecurity : object {
    private Security security;
    public Security Security { get; }
    public RequestSecurity(Security security);
    public Security get_Security();
}
[XmlRootAttribute]
public class Microsoft.Web.Services3.Security.RequestSecurityToken : SecurityTokenMessage {
    private string _requestTypeUri;
    private SecurityToken _cancelTarget;
    public SecurityToken CancelTarget { get; }
    public string RequestTypeUri { get; public set; }
    public RequestSecurityToken(SecurityToken cancelTarget);
    public RequestSecurityToken(string tokenType);
    public RequestSecurityToken(string tokenType, AppliesTo appliesTo);
    public RequestSecurityToken(XmlElement element);
    public SecurityToken get_CancelTarget();
    private void CheckValid();
    public virtual XmlElement GetXml(XmlDocument document);
    private SecurityToken DeserializeToken(XmlElement tokenElement);
    public virtual void LoadXml(XmlElement element);
    public virtual string get_RequestTypeUri();
    public virtual void set_RequestTypeUri(string value);
    private XmlElement SerializeToken(SecurityToken token, XmlDocument document);
}
[XmlRootAttribute]
public class Microsoft.Web.Services3.Security.RequestSecurityTokenResponse : SecurityTokenMessage {
    private int _keySize;
    private string _keyType;
    private RequestedSecurityToken _requestedSecurityToken;
    private RequestedProofToken _requestedProofToken;
    private SecurityTokenReference _attachedReference;
    private SecurityTokenReference _unattachedReference;
    private bool _requestedTokenCancelled;
    public string KeyType { get; public set; }
    public int KeySize { get; public set; }
    public SecurityTokenReference RequestedAttachedReference { get; public set; }
    public RequestedSecurityToken RequestedSecurityToken { get; public set; }
    public RequestedProofToken RequestedProofToken { get; public set; }
    public SecurityTokenReference RequestedUnattachedReference { get; public set; }
    public bool RequestedTokenCancelled { get; public set; }
    public RequestSecurityTokenResponse(SecurityToken token);
    public RequestSecurityTokenResponse(SecurityToken token, string address);
    public RequestSecurityTokenResponse(XmlElement element);
    public virtual XmlElement GetXml(XmlDocument document);
    public string get_KeyType();
    public void set_KeyType(string value);
    public int get_KeySize();
    public void set_KeySize(int value);
    public virtual void LoadXml(XmlElement element);
    public SecurityTokenReference get_RequestedAttachedReference();
    public void set_RequestedAttachedReference(SecurityTokenReference value);
    public RequestedSecurityToken get_RequestedSecurityToken();
    public void set_RequestedSecurityToken(RequestedSecurityToken value);
    public RequestedProofToken get_RequestedProofToken();
    public void set_RequestedProofToken(RequestedProofToken value);
    public SecurityTokenReference get_RequestedUnattachedReference();
    public void set_RequestedUnattachedReference(SecurityTokenReference value);
    public bool get_RequestedTokenCancelled();
    public void set_RequestedTokenCancelled(bool value);
}
public static class Microsoft.Web.Services3.Security.SAML : object {
    public static string NamespaceURI;
    public static string Prefix;
}
public abstract class Microsoft.Web.Services3.Security.SecureConversationClientReceiveSecurityFilter : ReceiveSecurityFilter {
    private bool establishSecurityContext;
    private bool requireDerivedKeys;
    private MessageProtectionOrder messageProtectionOrder;
    private bool requireSignatureConfirmation;
    public bool RequireSignatureConfirmation { get; }
    public bool RequireDerivedKeys { get; }
    public MessageProtectionOrder MessageProtectionOrder { get; }
    protected SecureConversationClientReceiveSecurityFilter(SecurityPolicyAssertion assertion);
    public bool get_RequireSignatureConfirmation();
    public bool get_RequireDerivedKeys();
    public MessageProtectionOrder get_MessageProtectionOrder();
    private static string GetServiceActor(SecurityPolicyAssertion assertion);
    private static string GetClientActor(SecurityPolicyAssertion assertion);
    public sealed virtual IEnumerable`1<SecurityToken> GetUnattachedTokens(SoapContext context);
    public abstract virtual IEnumerable`1<SecurityToken> GetUnattachedTokensCore(SoapContext context);
    public sealed virtual void ValidateMessageSecurity(SoapEnvelope envelope, Security security);
    public abstract virtual void ValidateMessageSecurity(SoapEnvelope envelope, Security security, MessageProtectionRequirements response);
    private void ValidateCloseSecureConversationMessageSecurity(SoapEnvelope envelope, Security security);
    private void ValidateSecureConversationMessageSecurity(SoapEnvelope envelope, Security security, MessageProtectionRequirements response);
}
public abstract class Microsoft.Web.Services3.Security.SecureConversationClientSendSecurityFilter : SendSecurityFilter {
    private bool establishSecurityContext;
    private bool renewExpiredSecurityContext;
    private EndpointProtectionRequirements protection;
    private SecurityPolicyAssertion wsTrustAssertion;
    private bool requireDerivedKeys;
    private MessageProtectionOrder messageProtectionOrder;
    private int ttlInSeconds;
    private EventHandler`1<SecureConversationEventArgs> SecureConversationCreated;
    public bool RequireDerivedKeys { get; }
    public MessageProtectionOrder MessageProtectionOrder { get; }
    public int TtlInSeconds { get; }
    protected SecureConversationClientSendSecurityFilter(SecurityPolicyAssertion assertion);
    public sealed virtual void add_SecureConversationCreated(EventHandler`1<SecureConversationEventArgs> value);
    public sealed virtual void remove_SecureConversationCreated(EventHandler`1<SecureConversationEventArgs> value);
    public bool get_RequireDerivedKeys();
    public MessageProtectionOrder get_MessageProtectionOrder();
    public int get_TtlInSeconds();
    public virtual T GetBehavior();
    public virtual OperationProtectionRequirements GetOperationProtectionRequirements(SoapEnvelope request);
    public sealed virtual void SecureMessage(SoapEnvelope envelope, Security security);
    public abstract virtual void SecureMessage(SoapEnvelope envelope, Security security, MessageProtectionRequirements request);
    private void SecureSecurityConversationMessage(SoapEnvelope envelope, Security security, SecurityContextToken token, MessageProtectionRequirements request);
    private void SecureCloseSecureConversationMessage(SoapEnvelope envelope, Security security);
    private SecurityContextToken EstablishSecureConversation(SoapEnvelope envelope);
}
public class Microsoft.Web.Services3.Security.SecureConversationCorrelationState : SerializableTokenWrapper`1<SecurityContextToken> {
    public SecureConversationCorrelationState(SecurityContextToken token);
}
public class Microsoft.Web.Services3.Security.SecureConversationEventArgs : EventArgs {
    private SecurityContextToken securityContextToken;
    public SecurityContextToken SecurityContextToken { get; }
    public SecureConversationEventArgs(SecurityContextToken token);
    public SecurityContextToken get_SecurityContextToken();
}
public class Microsoft.Web.Services3.Security.SecureConversationFault : WseSoapHeaderException {
    public static string BadContextTokenMessage;
    public static string UnknownDerivationSourceMessage;
    public static XmlQualifiedName BadContextTokenCode;
    public static XmlQualifiedName UnknownDerivationSourceCode;
    public SecureConversationFault(string message);
    public SecureConversationFault(string message, XmlQualifiedName code);
    public SecureConversationFault(string message, XmlQualifiedName code, Exception ex);
    private static SecureConversationFault();
}
public abstract class Microsoft.Web.Services3.Security.SecureConversationServiceReceiveSecurityFilter : ReceiveSecurityFilter {
    private bool establishSecurityContext;
    private EndpointProtectionRequirements protection;
    private static MessageProtectionRequirements wsTrustRequest;
    private bool requireDerivedKeys;
    private MessageProtectionOrder messageProtectionOrder;
    public bool RequireDerivedKeys { get; }
    public MessageProtectionOrder MessageProtectionOrder { get; }
    internal static MessageProtectionRequirements WsTrustRequest { get; }
    protected SecureConversationServiceReceiveSecurityFilter(SecurityPolicyAssertion assertion);
    public bool get_RequireDerivedKeys();
    public MessageProtectionOrder get_MessageProtectionOrder();
    internal static MessageProtectionRequirements get_WsTrustRequest();
    private static string GetServiceActor(SecurityPolicyAssertion assertion);
    private static string GetClientActor(SecurityPolicyAssertion assertion);
    public virtual SoapServerMethod RouteRequest(SoapEnvelope envelope);
    public virtual OperationProtectionRequirements GetOperationProtectionRequirements(SoapEnvelope request);
    public sealed virtual void ValidateMessageSecurity(SoapEnvelope envelope, Security security);
    public abstract virtual void ValidateMessageSecurity(SoapEnvelope envelope, Security security, MessageProtectionRequirements request);
    protected virtual void ValidateCloseSecureConversationSecurity(SoapEnvelope envelope, Security security);
    private void ValidateSecureConversationMessageSecurity(SoapEnvelope envelope, Security security, MessageProtectionRequirements request);
}
public abstract class Microsoft.Web.Services3.Security.SecureConversationServiceSendSecurityFilter : SendSecurityFilter {
    private bool establishSecurityContext;
    private static MessageProtectionRequirements wsTrustResponse;
    private bool requireDerivedKeys;
    private MessageProtectionOrder messageProtectionOrder;
    private bool requireSignatureConfirmation;
    private int ttlInSeconds;
    public bool RequireSignatureConfirmation { get; }
    public bool RequireDerivedKeys { get; }
    public MessageProtectionOrder MessageProtectionOrder { get; }
    public int TtlInSeconds { get; }
    internal static MessageProtectionRequirements WsTrustResponse { get; }
    protected SecureConversationServiceSendSecurityFilter(SecurityPolicyAssertion assertion);
    public bool get_RequireSignatureConfirmation();
    public bool get_RequireDerivedKeys();
    public MessageProtectionOrder get_MessageProtectionOrder();
    public int get_TtlInSeconds();
    internal static MessageProtectionRequirements get_WsTrustResponse();
    private static string GetServiceActor(SecurityPolicyAssertion assertion);
    private static string GetClientActor(SecurityPolicyAssertion assertion);
    public sealed virtual void SecureMessage(SoapEnvelope envelope, Security security);
    public abstract virtual void SecureMessage(SoapEnvelope envelope, Security security, MessageProtectionRequirements response);
    private void SecureCloseSecureConversationMessage(SoapEnvelope envelope, Security security);
    private void SecureSecurityConversationMessage(SoapEnvelope envelope, Security security, MessageProtectionRequirements response);
}
public class Microsoft.Web.Services3.Security.Security : WSESoapHeader {
    private SecurityElementCollection _elements;
    private SecurityTokenCollection _tokens;
    private Timestamp _timestamp;
    private Security _requestSecurity;
    private SignatureConfirmationCollection _signatureConfirmationCollection;
    public SecurityElementCollection Elements { get; }
    internal bool IncludeSignatureConfirmation { get; }
    public Security RequestSecurity { get; public set; }
    public SignatureConfirmationCollection SignatureConfirmationCollection { get; }
    public SecurityTokenCollection Tokens { get; }
    public Timestamp Timestamp { get; }
    internal Security(string actor);
    internal Security(XmlElement element);
    internal Security Clone();
    private ArrayList ComputeSerializationPlan();
    private bool IsRLInsideEncryptedKeyToken(EncryptedData ed);
    public void Clear();
    private void ConfirmSignature(Security requestSecurity, SignatureConfirmationCollection signatureConfirmationCollection);
    public SecurityElementCollection get_Elements();
    public void SerializeXml(SoapEnvelope document);
    internal bool get_IncludeSignatureConfirmation();
    private void LoadToken(XmlElement element, SecurityConfiguration configuration, Int32& tokenCount);
    public void LoadXml(XmlElement element);
    private void MutateTokens();
    public Security get_RequestSecurity();
    public void set_RequestSecurity(Security value);
    private Hashtable RetrieveEncryptedDataNodes(XmlDocument message);
    private void RetrieveEncryptedDataNodes(XmlElement element, Hashtable table);
    private void SetTimestampSignatureOptions(XmlElement timestampElement);
    private void SetSignatureConfirmationOptions(SignatureConfirmationCollection list);
    public SignatureConfirmationCollection get_SignatureConfirmationCollection();
    public SecurityTokenCollection get_Tokens();
    public Timestamp get_Timestamp();
    internal static void AddEnvelopeNamespaceDeclaration(SoapEnvelope envelope, string prefix, string namespaceUri);
    internal void Execute(SoapEnvelope envelope);
    private static bool CanProcessHeader(XmlElement header, SoapContext context, string requestedActor);
    internal static Security CreateFrom(SoapEnvelope envelope, string localActor, string serviceActor);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Security.SecurityCollection : object {
    private ArrayList _list;
    public Security Item { get; }
    public Security Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public SecurityCollection Clone();
    public Security get_Item(Uri actor);
    public Security get_Item(string actor);
    public void Add(Security security);
    public void Clear();
    public bool Contains(Uri actor);
    public bool Contains(string actor);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Security[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual bool get_IsSynchronized();
    public void Remove(Uri actor);
    public void Remove(string actor);
    public sealed virtual object get_SyncRoot();
}
[SoapServiceAttribute("http://schemas.xmlsoap.org/ws/2005/02/sc")]
public class Microsoft.Web.Services3.Security.SecurityContextTokenService : SecurityTokenService {
    private static ISecurityTokenManager _sctManager;
    private static SecurityContextTokenService();
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT")]
public virtual RequestSecurityTokenResponse IssueSecurityContextTokenRequest(RequestSecurityToken request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/SCT")]
public virtual RequestSecurityTokenResponse IssueSecurityContextTokenRequest(RequestSecurityTokenResponse request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT/Cancel")]
public virtual RequestSecurityTokenResponse CancelSecurityContextTokenRequest(RequestSecurityToken request);
    protected virtual RequestSecurityTokenResponse IssueSecurityToken(SecurityTokenMessage request);
    protected virtual RequestSecurityTokenResponse CancelSecurityToken(SecurityTokenMessage request);
}
internal class Microsoft.Web.Services3.Security.SecurityContextTokenServiceAsmxShim : object {
    private static SecurityContextTokenService sctService;
    private static XmlDocument document;
    private static SoapServerMethod issueMethod;
    private static SoapServerMethod cancelMethod;
    public static SoapServerMethod IssueMethod { get; }
    public static SoapServerMethod CancelMethod { get; }
    private static SecurityContextTokenServiceAsmxShim();
    public static SoapServerMethod get_IssueMethod();
    public static SoapServerMethod get_CancelMethod();
    [SoapDocumentMethodAttribute]
[WebMethodAttribute]
public XmlElement[] IssueSecurityContextTokenRequest(XmlElement[] request);
    [SoapDocumentMethodAttribute]
[WebMethodAttribute]
public XmlElement[] CancelSecurityContextTokenRequest(XmlElement[] request);
}
public class Microsoft.Web.Services3.Security.SecurityContextTokenServiceClient : SecurityTokenServiceClient {
    public SecurityContextTokenServiceClient(EndpointReference endpoint);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT")]
public virtual IAsyncResult BeginIssueSecurityContextToken(AppliesTo appliesTo, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginIssueSecurityContextToken(AsyncCallback callback, object state);
    public virtual SecurityContextToken EndIssueSecurityContextToken(IAsyncResult result);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT/Cancel")]
public virtual IAsyncResult BeginCancelSecurityContextToken(SecurityToken cancelTarget, AsyncCallback callback, object state);
    public virtual void EndCancelSecurityContextToken(IAsyncResult result);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT")]
public virtual SecurityContextToken IssueSecurityContextToken(AppliesTo appliesTo);
    public virtual SecurityContextToken IssueSecurityContextToken();
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT/Cancel")]
public virtual void CancelSecurityContextToken(SecurityContextToken cancelTarget);
    protected SecurityContextToken RequestSecurityContextToken(AppliesTo appliesTo);
    protected IAsyncResult BeginRequestSecurityContextToken(AppliesTo appliesTo, AsyncCallback callback, object state);
    protected SecurityContextToken EndRequestSecurityContextToken(IAsyncResult result);
    protected void CloseSecurityContextToken(SecurityContextToken cancelTarget);
    protected IAsyncResult BeginCloseSecurityContextToken(SecurityToken cancelTarget, AsyncCallback callback, object state);
    protected void EndCloseSecurityContextToken(IAsyncResult result);
    protected virtual SecurityContextToken RetrieveSecurityContextToken(RequestSecurityToken request, RequestSecurityTokenResponse response);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Security.SecurityElementCollection : object {
    private ArrayList _elements;
    private Security _container;
    public ISecurityElement Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    unknown Security Container {internal set; }
    public ISecurityElement get_Item(int index);
    public void Add(ISecurityElement element);
    public void Clear();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ISecurityElement[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual bool get_IsSynchronized();
    public void Remove(ISecurityElement element);
    public sealed virtual object get_SyncRoot();
    internal void set_Container(Security value);
}
public class Microsoft.Web.Services3.Security.SecurityFault : WseSoapHeaderException {
    public static string FailedAuthenticationMessage;
    public static string FailedCheckMessage;
    public static string InvalidSecurityMessage;
    public static string InvalidSecurityTokenMessage;
    public static string SecurityTokenUnavailableMessage;
    public static string UnsupportedAlgorithmMessage;
    public static string UnsupportedSecurityTokenMessage;
    public static XmlQualifiedName FailedAuthenticationCode;
    public static XmlQualifiedName FailedCheckCode;
    public static XmlQualifiedName InvalidSecurityCode;
    public static XmlQualifiedName InvalidSecurityTokenCode;
    public static XmlQualifiedName SecurityTokenUnavailableCode;
    public static XmlQualifiedName UnsupportedAlgorithmCode;
    public static XmlQualifiedName UnsupportedSecurityTokenCode;
    public static XmlQualifiedName SecurityHeaderCode;
    public SecurityFault(string message);
    public SecurityFault(string message, XmlQualifiedName code);
    public SecurityFault(string message, XmlQualifiedName code, Exception ex);
    private static SecurityFault();
}
public class Microsoft.Web.Services3.Security.SecurityFormatException : WseSoapHeaderException {
    public static string InvalidKeyGenerationAlgorithm;
    public static string EitherGenerationOrOffset;
    public static string InvalidSecurityContextToken;
    public static string InvalidNonce;
    public static string InvalidCreated;
    public static string InvalidSecurityTokenReferenceInTransform;
    public SecurityFormatException(string message);
    public SecurityFormatException(string message, Exception ex);
    private static SecurityFormatException();
}
internal class Microsoft.Web.Services3.Security.SecurityInputFilter : SoapInputFilter {
    public virtual void ProcessMessage(SoapEnvelope envelope);
}
internal class Microsoft.Web.Services3.Security.SecurityOutputFilter : SoapOutputFilter {
    public virtual void ProcessMessage(SoapEnvelope envelope);
    private void ProcessHeader(Security security, SoapEnvelope envelope);
}
public abstract class Microsoft.Web.Services3.Security.SecurityTokenMessage : OpenElement {
    private string _tokenType;
    private AppliesTo _appliesTo;
    private Uri _context;
    private Entropy _entropy;
    private LifeTime _lifeTime;
    public AppliesTo AppliesTo { get; public set; }
    public Uri Context { get; public set; }
    public Entropy Entropy { get; public set; }
    public LifeTime LifeTime { get; public set; }
    public string TokenType { get; public set; }
    public AppliesTo get_AppliesTo();
    public void set_AppliesTo(AppliesTo value);
    public Uri get_Context();
    public void set_Context(Uri value);
    public Entropy get_Entropy();
    public void set_Entropy(Entropy value);
    public LifeTime get_LifeTime();
    public void set_LifeTime(LifeTime value);
    public string get_TokenType();
    public void set_TokenType(string value);
}
public class Microsoft.Web.Services3.Security.SecurityTokenReference : KeyInfoClause {
    private AttributeList _anyAttributes;
    private ElementList _anyElements;
    private SerializationOptions _options;
    private string _id;
    private Embedded _embedded;
    private KeyIdentifier _identifier;
    private string _reference;
    private string _valueType;
    private SecurityToken _token;
    public string AbsoluteReference { get; public set; }
    public AttributeList AnyAttributes { get; }
    public ElementList AnyElements { get; }
    public Embedded Embedded { get; public set; }
    public string Id { get; public set; }
    public KeyIdentifier KeyIdentifier { get; public set; }
    public string Reference { get; public set; }
    public string RelativeReference { get; public set; }
    public SecurityToken Token { get; }
    public string ValueType { get; public set; }
    public SecurityTokenReference(SecurityToken token);
    public SecurityTokenReference(SecurityToken token, SerializationOptions options);
    public SecurityTokenReference(XmlElement element);
    public static SecurityTokenReference op_Implicit(KeyInfo obj);
    public static KeyInfo op_Implicit(SecurityTokenReference str);
    public string get_AbsoluteReference();
    public void set_AbsoluteReference(string value);
    public AttributeList get_AnyAttributes();
    public ElementList get_AnyElements();
    public Embedded get_Embedded();
    public void set_Embedded(Embedded value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual XmlElement GetXml();
    public virtual XmlElement GetXml(XmlDocument document);
    protected void GetXmlAttributes(XmlElement element);
    protected virtual void GetInnerXml(XmlElement parent);
    public string get_Id();
    public void set_Id(string value);
    public virtual void LoadXml(XmlElement element);
    protected void LoadXmlAttributes(XmlElement element);
    protected virtual void LoadInnerXml(XmlElement parent);
    public KeyIdentifier get_KeyIdentifier();
    public void set_KeyIdentifier(KeyIdentifier value);
    public string get_Reference();
    public void set_Reference(string value);
    public string get_RelativeReference();
    public void set_RelativeReference(string value);
    public SecurityToken Resolve();
    public SecurityToken Resolve(SoapContext context);
    public SecurityToken get_Token();
    public string get_ValueType();
    public void set_ValueType(string value);
}
public class Microsoft.Web.Services3.Security.SecurityTokenService : SoapService {
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue")]
public virtual RequestSecurityTokenResponse IssueSecurityTokenRequest(RequestSecurityToken request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Issue")]
public virtual RequestSecurityTokenResponse IssueSecurityTokenRequest(RequestSecurityTokenResponse request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Renew")]
public virtual RequestSecurityTokenResponse RenewSecurityTokenRequest(RequestSecurityToken request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Renew")]
public virtual RequestSecurityTokenResponse RenewSecurityTokenRequest(RequestSecurityTokenResponse request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Validate")]
public virtual RequestSecurityTokenResponse ValidateSecurityTokenRequest(RequestSecurityToken request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Validate")]
public virtual RequestSecurityTokenResponse ValidateSecurityTokenRequest(RequestSecurityTokenResponse request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Cancel")]
public virtual RequestSecurityTokenResponse CancelSecurityTokenRequest(RequestSecurityToken request);
    protected virtual void SetupIssuedToken(SecurityTokenMessage request, RequestSecurityTokenResponse response);
    protected virtual RequestSecurityTokenResponse IssueSecurityToken(SecurityTokenMessage request);
    protected virtual RequestSecurityTokenResponse RenewSecurityToken(SecurityTokenMessage request);
    protected virtual RequestSecurityTokenResponse ValidateSecurityToken(SecurityTokenMessage request);
    protected virtual RequestSecurityTokenResponse CancelSecurityToken(SecurityTokenMessage request);
    protected virtual void VerifyCancelPolicy(RequestSecurityToken request);
}
public class Microsoft.Web.Services3.Security.SecurityTokenServiceClient : SoapClient {
    private SoapContext _requestSoapContext;
    private SoapContext _responseSoapContext;
    private StateManager sessionState;
    public SoapContext RequestSoapContext { get; }
    public SoapContext ResponseSoapContext { get; }
    public SecurityTokenServiceClient(Uri destination);
    public SecurityTokenServiceClient(EndpointReference destination);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue")]
public virtual IAsyncResult BeginIssueSecurityToken(RequestSecurityToken request, AsyncCallback callback, object state);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Issue")]
public virtual IAsyncResult BeginIssueSecurityTokenResponse(RequestSecurityTokenResponse request, AsyncCallback callback, object state);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Renew")]
public virtual IAsyncResult BeginRenewSecurityToken(RequestSecurityToken request, AsyncCallback callback, object state);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Renew")]
public virtual IAsyncResult BeginRenewSecurityTokenResponse(RequestSecurityTokenResponse request, AsyncCallback callback, object state);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Validate")]
public virtual IAsyncResult BeginValidateSecurityToken(RequestSecurityToken request, AsyncCallback callback, object state);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Validate")]
public virtual IAsyncResult BeginValidateSecurityTokenResponse(RequestSecurityTokenResponse request, AsyncCallback callback, object state);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Cancel")]
public virtual IAsyncResult BeginCancelSecurityToken(RequestSecurityToken request, AsyncCallback callback, object state);
    public virtual RequestSecurityTokenResponse EndIssueSecurityToken(IAsyncResult result);
    public virtual RequestSecurityTokenResponse EndIssueSecurityTokenResponse(IAsyncResult result);
    public virtual RequestSecurityTokenResponse EndRenewSecurityToken(IAsyncResult result);
    public virtual RequestSecurityTokenResponse EndRenewSecurityTokenResponse(IAsyncResult result);
    public virtual RequestSecurityTokenResponse EndValidateSecurityToken(IAsyncResult result);
    public virtual RequestSecurityTokenResponse EndValidateSecurityTokenResponse(IAsyncResult result);
    public virtual RequestSecurityTokenResponse EndCancelSecurityToken(IAsyncResult result);
    protected IAsyncResult BeginRequestSecurityToken(SecurityTokenMessage request, string methodName, AsyncCallback callback, object state);
    protected RequestSecurityTokenResponse EndRequestSecurityToken(IAsyncResult result);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue")]
public virtual RequestSecurityTokenResponse IssueSecurityToken(RequestSecurityToken request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Issue")]
public virtual RequestSecurityTokenResponse IssueSecurityTokenResponse(RequestSecurityTokenResponse request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Renew")]
public virtual RequestSecurityTokenResponse RenewSecurityToken(RequestSecurityToken request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Renew")]
public virtual RequestSecurityTokenResponse RenewSecurityTokenResponse(RequestSecurityTokenResponse request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Validate")]
public virtual RequestSecurityTokenResponse ValidateSecurityToken(RequestSecurityToken request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Validate")]
public virtual RequestSecurityTokenResponse ValidateSecurityTokenResponse(RequestSecurityTokenResponse request);
    [SoapMethodAttribute("http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Cancel")]
public virtual RequestSecurityTokenResponse CancelSecurityToken(RequestSecurityToken request);
    protected RequestSecurityTokenResponse RequestSecurityToken(SecurityTokenMessage request, string methodName);
    protected virtual void SetupIssuedToken(SecurityTokenMessage request, RequestSecurityTokenResponse response);
    public SoapContext get_RequestSoapContext();
    public SoapContext get_ResponseSoapContext();
}
public abstract class Microsoft.Web.Services3.Security.SendSecurityFilter : SoapFilter {
    private string _serviceActor;
    private string _remoteActor;
    protected SendSecurityFilter(string serviceActor, bool isClient);
    protected SendSecurityFilter(string serviceActor, bool isClient, string clientActor);
    public virtual string GetServiceActor(Soap soapVersion);
    public virtual string GetRemoteActor(Soap soapVersion);
    public abstract virtual void SecureMessage(SoapEnvelope envelope, Security security);
    public virtual SoapFilterResult ProcessMessage(SoapEnvelope envelope);
}
public class Microsoft.Web.Services3.Security.SerializableTokenWrapper`1 : object {
    private TSecurityToken _token;
    private static XmlDocument document;
    public TSecurityToken Token { get; public set; }
    public SerializableTokenWrapper`1(TSecurityToken token);
    private static SerializableTokenWrapper`1();
    public TSecurityToken get_Token();
    public void set_Token(TSecurityToken value);
    public sealed virtual void WriteXml(XmlWriter writer);
    public sealed virtual void ReadXml(XmlReader reader);
    public sealed virtual XmlSchema GetSchema();
    public void WriteToken(XmlWriter writer, TSecurityToken token);
    public TSecurityToken ReadToken(XmlReader reader);
}
public class Microsoft.Web.Services3.Security.SignatureConfirmation : object {
    private string _id;
    private string _signatureValue;
    private XmlElement _targetElement;
    public XmlElement TargetElement { get; }
    public string Id { get; public set; }
    public string SignatureValue { get; public set; }
    public SignatureConfirmation(string signatureValue);
    public SignatureConfirmation(Byte[] signatureValue);
    public SignatureConfirmation(XmlElement element);
    public XmlElement get_TargetElement();
    private void CheckValid();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public string get_Id();
    public void set_Id(string value);
    public sealed virtual void LoadXml(XmlElement element);
    public string get_SignatureValue();
    public void set_SignatureValue(string value);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Security.SignatureConfirmationCollection : object {
    private ArrayList _elements;
    public SignatureConfirmation Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public SignatureConfirmationCollection(Security requestSecurity);
    public SignatureConfirmation get_Item(int index);
    public void Add(SignatureConfirmation element);
    public bool ContainsReference(string reference);
    public bool ContainsSignatureValue(Byte[] signatureValue);
    public void Clear();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(SignatureConfirmation[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual bool get_IsSynchronized();
    public void Remove(SignatureConfirmation element);
    public sealed virtual object get_SyncRoot();
}
[FlagsAttribute]
public enum Microsoft.Web.Services3.Security.SignatureOptions : Enum {
    public int value__;
    public static SignatureOptions IncludeNone;
    public static SignatureOptions IncludeAction;
    public static SignatureOptions IncludeFaultTo;
    public static SignatureOptions IncludeFrom;
    public static SignatureOptions IncludeMessageId;
    public static SignatureOptions IncludeReferenceProperties;
    public static SignatureOptions IncludeRelatesTo;
    public static SignatureOptions IncludeReplyTo;
    public static SignatureOptions IncludeTo;
    public static SignatureOptions IncludeReferenceParameters;
    public static SignatureOptions IncludeAddressing;
    public static SignatureOptions IncludeTimestamp;
    public static SignatureOptions IncludeSoapBody;
    public static SignatureOptions IncludeSignatureConfirmation;
}
public class Microsoft.Web.Services3.Security.SignatureReference : object {
    private string m_strId;
    private string m_strUri;
    private string m_strType;
    private TransformChain m_transformChain;
    private string m_strDigestMethod;
    private Byte[] m_rgbDigestValue;
    private XmlElement _targetElement;
    private HashAlgorithm m_hashAlgorithm;
    private object m_refTarget;
    private TargetType m_refTargetType;
    private XmlElement m_cachedXml;
    private MessageSignature m_signedXml;
    internal bool CacheValid { get; }
    public string DigestMethod { get; public set; }
    public Byte[] DigestValue { get; public set; }
    public string Id { get; public set; }
    public XmlElement TargetElement { get; }
    public TransformChain TransformChain { get; }
    public string Type { get; public set; }
    unknown MessageSignature Signature {internal set; }
    public string Uri { get; public set; }
    public SignatureReference(Stream stream);
    public SignatureReference(string uri);
    internal SignatureReference(XmlElement element);
    public void AddTransform(Transform transform);
    internal bool get_CacheValid();
    internal Byte[] CalculateHashValue(XmlDocument document, CanonicalXmlNodeList refList);
    public string get_DigestMethod();
    public void set_DigestMethod(string value);
    public Byte[] get_DigestValue();
    public void set_DigestValue(Byte[] value);
    public XmlElement GetXml();
    public string get_Id();
    public void set_Id(string value);
    public void LoadXml(XmlElement value);
    public XmlElement get_TargetElement();
    public TransformChain get_TransformChain();
    public string get_Type();
    public void set_Type(string value);
    internal void set_Signature(MessageSignature value);
    internal void UpdateHashValue(XmlDocument document, CanonicalXmlNodeList refList);
    public string get_Uri();
    public void set_Uri(string value);
}
public class Microsoft.Web.Services3.Security.SignedInfo : object {
    private string m_strId;
    private CanonicalizationMethod _canonicalizationMethod;
    private string _signatureMethod;
    private string _signatureLength;
    private ArrayList _references;
    private XmlElement _cachedXml;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public string Id { get; public set; }
    public string CanonicalizationMethod { get; public set; }
    internal string InclusiveNamespacesPrefixList { get; }
    public string SignatureMethod { get; public set; }
    public string SignatureLength { get; public set; }
    public ArrayList References { get; }
    internal bool CacheValid { get; }
    public SignedInfo(string prefixList);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public string get_Id();
    public void set_Id(string value);
    public string get_CanonicalizationMethod();
    public void set_CanonicalizationMethod(string value);
    internal string get_InclusiveNamespacesPrefixList();
    public string get_SignatureMethod();
    public void set_SignatureMethod(string value);
    public string get_SignatureLength();
    public void set_SignatureLength(string value);
    public ArrayList get_References();
    internal bool get_CacheValid();
    public XmlElement GetXml();
    public void LoadXml(XmlElement value);
    public void AddReference(SignatureReference reference);
}
public class Microsoft.Web.Services3.Security.SignedXmlSignature : object {
    private string m_strId;
    private SignedInfo m_signedInfo;
    private Byte[] m_rgbSignatureValue;
    private KeyInfo m_keyInfo;
    private IList m_embeddedObjects;
    private CanonicalXmlNodeList m_referencedItems;
    private Security m_container;
    private SecurityToken m_signingToken;
    public Security Container { get; public set; }
    public string Id { get; public set; }
    public SignedInfo SignedInfo { get; public set; }
    public Byte[] SignatureValue { get; public set; }
    public SecurityToken SigningToken { get; public set; }
    public KeyInfo KeyInfo { get; public set; }
    public IList ObjectList { get; }
    internal CanonicalXmlNodeList ReferencedItems { get; }
    public Security get_Container();
    public void set_Container(Security value);
    public string get_Id();
    public void set_Id(string value);
    public SignedInfo get_SignedInfo();
    public void set_SignedInfo(SignedInfo value);
    public Byte[] get_SignatureValue();
    public void set_SignatureValue(Byte[] value);
    public SecurityToken get_SigningToken();
    public void set_SigningToken(SecurityToken value);
    public KeyInfo get_KeyInfo();
    public void set_KeyInfo(KeyInfo value);
    public IList get_ObjectList();
    internal CanonicalXmlNodeList get_ReferencedItems();
    private void CheckValid();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public sealed virtual void LoadXml(XmlElement element);
    public void AddObject(DataObject dataObject);
}
internal class Microsoft.Web.Services3.Security.STSUtility : object {
    public static void EnforceUsernameTokenConfidentiality(SoapContext context, SecurityToken encryptingToken);
    internal static IssuedToken RetrieveIssuedToken(RequestSecurityToken request, RequestSecurityTokenResponse response);
    public static void VerifyUsernameTokenConfidentiality(SoapContext context);
    public static bool CoverImportantParts(SoapEnvelope envelope, Security security, MessageSignature signature);
}
public abstract class Microsoft.Web.Services3.Security.Tokens.BinarySecurityToken : SecurityToken {
    private string _encodingType;
    private string _valueType;
    private Byte[] _rawData;
    public string ValueType { get; public set; }
    public string EncodingType { get; public set; }
    public Byte[] RawData { get; public set; }
    protected BinarySecurityToken(string valueType);
    protected BinarySecurityToken(string valueType, string tokenType);
    protected BinarySecurityToken(XmlElement element, string valueType);
    protected BinarySecurityToken(XmlElement element, string valueType, string tokenType);
    public virtual string get_ValueType();
    public virtual void set_ValueType(string value);
    public string get_EncodingType();
    public void set_EncodingType(string value);
    public virtual Byte[] get_RawData();
    public virtual void set_RawData(Byte[] value);
    public XmlElement GetSTRTransformXml(XmlDocument document, string STRPrefix, string STRNamespace);
    public virtual XmlElement GetXml(XmlDocument document);
    protected XmlElement GetXml(XmlDocument document, string valueType);
    public virtual void LoadXml(XmlElement element);
}
internal class Microsoft.Web.Services3.Security.Tokens.ByteArrayWrapper : object {
    private Byte[] _bytes;
    public ByteArrayWrapper(Byte[] bytes);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.Web.Services3.Security.Tokens.DerivedKeyToken : SecurityToken {
    private SecurityTokenReference _parentReference;
    private Properties _properties;
    private int _generation;
    private int _offset;
    private string _label;
    private Nonce _nonce;
    private int _length;
    private string _keyDerivationAlgorithm;
    private int _hasMutated;
    private int _generationLimit;
    private int _offsetLimit;
    private bool _isForSigningOnly;
    private SymmetricKeyAlgorithm _key;
    private IDerivableToken _parent;
    public KeyAlgorithm Key { get; }
    public Byte[] KeyBytes { get; }
    private PSHA1 DerivedKeyGenerator { get; }
    public int Generation { get; public set; }
    public int GenerationLimit { get; }
    public SecurityToken Root { get; }
    public bool IsCurrent { get; }
    public string KeyDerivationAlgorithm { get; }
    public string Label { get; public set; }
    public int Length { get; }
    public Nonce Nonce { get; }
    public int Offset { get; public set; }
    public int OffsetLimit { get; }
    public IDerivableToken Parent { get; }
    public IPrincipal Principal { get; public set; }
    public Properties Properties { get; }
    public SecurityTokenReference ParentReference { get; public set; }
    public bool SupportsDataEncryption { get; }
    public bool SupportsDigitalSignature { get; }
    public DerivedKeyToken(IDerivableToken parent);
    public DerivedKeyToken(IDerivableToken parent, bool isForSigningOnly);
    public DerivedKeyToken(XmlElement element);
    private DerivedKeyToken(DerivedKeyToken other);
    public virtual KeyAlgorithm get_Key();
    private void CheckValid();
    public sealed virtual Byte[] get_KeyBytes();
    public sealed virtual void Mutate();
    public sealed virtual IMutableSecurityToken Clone();
    private PSHA1 get_DerivedKeyGenerator();
    public virtual bool Equals(SecurityToken token);
    public int get_Generation();
    public void set_Generation(int value);
    private int GetKeyPosition();
    public virtual int get_GenerationLimit();
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual SecurityToken get_Root();
    private void InitializeLabel();
    public virtual bool get_IsCurrent();
    public string get_KeyDerivationAlgorithm();
    public string get_Label();
    public void set_Label(string value);
    public int get_Length();
    public virtual void LoadXml(XmlElement element);
    public Nonce get_Nonce();
    public int get_Offset();
    public void set_Offset(int value);
    public virtual int get_OffsetLimit();
    public IDerivableToken get_Parent();
    public virtual IPrincipal get_Principal();
    public virtual void set_Principal(IPrincipal value);
    public Properties get_Properties();
    public SecurityTokenReference get_ParentReference();
    public void set_ParentReference(SecurityTokenReference value);
    public virtual bool get_SupportsDataEncryption();
    public virtual bool get_SupportsDigitalSignature();
}
public class Microsoft.Web.Services3.Security.Tokens.DerivedKeyTokenManager : SecurityTokenManager {
    public static int DefaultGenerationLimit;
    public static int DefaultOffsetLimit;
    public static int DefaultSignatureKeyLength;
    private int _generationLimit;
    private int _offsetLimit;
    private int _signatureKeyLength;
    public int GenerationLimit { get; }
    public int OffsetLimit { get; }
    public int SignatureKeyLength { get; }
    public string TokenType { get; }
    public DerivedKeyTokenManager(XmlNodeList configData);
    public virtual void CacheSecurityToken(SecurityToken token);
    public virtual int get_GenerationLimit();
    public virtual int get_OffsetLimit();
    public int get_SignatureKeyLength();
    public virtual string get_TokenType();
    public virtual SecurityToken LoadTokenFromXml(XmlElement element);
    public virtual SecurityToken LoadTokenFromKeyInfo(KeyInfo keyInfo);
}
public class Microsoft.Web.Services3.Security.Tokens.EncryptedKeyToken : SecurityToken {
    private SymmetricKeyAlgorithm _key;
    private KeyIdentifier _keyIdentifier;
    private EncryptedKey _encryptedKey;
    public EncryptedKey EncryptedKey { get; }
    public Byte[] KeyBytes { get; }
    public KeyAlgorithm Key { get; }
    public KeyIdentifier KeyIdentifier { get; }
    public bool IsCurrent { get; }
    public bool SupportsDataEncryption { get; }
    public bool SupportsDigitalSignature { get; }
    public EncryptedKeyToken(SecurityToken encryptingToken);
    public EncryptedKeyToken(SecurityToken encryptingToken, Byte[] keyData);
    public EncryptedKeyToken(XmlElement element);
    public EncryptedKey get_EncryptedKey();
    public sealed virtual Byte[] get_KeyBytes();
    public virtual bool Equals(SecurityToken token);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public virtual KeyAlgorithm get_Key();
    public virtual KeyIdentifier get_KeyIdentifier();
    public virtual bool get_IsCurrent();
    public virtual void LoadXml(XmlElement element);
    public virtual bool get_SupportsDataEncryption();
    public virtual bool get_SupportsDigitalSignature();
    internal bool IsEncryptedFor(X509SecurityToken x509);
}
public class Microsoft.Web.Services3.Security.Tokens.EncryptedKeyTokenManager : KeyIdentifierCachedSecurityTokenManager {
    private string _defaultKeyAlgorithm;
    public string DefaultKeyAlgorithm { get; public set; }
    public string TokenType { get; }
    public EncryptedKeyTokenManager(XmlNodeList configData);
    public virtual string get_DefaultKeyAlgorithm();
    public virtual void set_DefaultKeyAlgorithm(string value);
    public virtual string get_TokenType();
    public virtual SecurityToken LoadTokenFromKeyInfo(KeyInfo keyInfo);
    public virtual SecurityToken LoadTokenFromXml(XmlElement element);
}
public interface Microsoft.Web.Services3.Security.Tokens.IDerivableToken {
    public Byte[] KeyBytes { get; }
    public abstract virtual Byte[] get_KeyBytes();
}
public interface Microsoft.Web.Services3.Security.Tokens.IIssuedToken {
    public AppliesTo AppliesTo { get; public set; }
    public SecurityToken BaseToken { get; public set; }
    public LifeTime LifeTime { get; public set; }
    public RequestedProofToken ProofToken { get; public set; }
    public SecurityTokenCollection SupportingTokens { get; }
    public EndpointReference TokenIssuer { get; public set; }
    public abstract virtual AppliesTo get_AppliesTo();
    public abstract virtual void set_AppliesTo(AppliesTo value);
    public abstract virtual SecurityToken get_BaseToken();
    public abstract virtual void set_BaseToken(SecurityToken value);
    public abstract virtual LifeTime get_LifeTime();
    public abstract virtual void set_LifeTime(LifeTime value);
    public abstract virtual RequestedProofToken get_ProofToken();
    public abstract virtual void set_ProofToken(RequestedProofToken value);
    public abstract virtual SecurityTokenCollection get_SupportingTokens();
    public abstract virtual EndpointReference get_TokenIssuer();
    public abstract virtual void set_TokenIssuer(EndpointReference value);
}
public enum Microsoft.Web.Services3.Security.Tokens.ImpersonationLevel : Enum {
    public int value__;
    public static ImpersonationLevel Identification;
    public static ImpersonationLevel Impersonation;
    public static ImpersonationLevel Delegation;
}
internal static class Microsoft.Web.Services3.Security.Tokens.ImpersonationLevelHelper : object {
    public static bool IsDefined(ImpersonationLevel value);
}
public interface Microsoft.Web.Services3.Security.Tokens.IMutableSecurityToken {
    public abstract virtual void Mutate();
    public abstract virtual IMutableSecurityToken Clone();
}
[DefaultMemberAttribute("Item")]
public interface Microsoft.Web.Services3.Security.Tokens.ISecurityTokenCache {
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public SecurityToken Item { get; }
    public abstract virtual void add_Changed(EventHandler value);
    public abstract virtual void remove_Changed(EventHandler value);
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual object get_SyncRoot();
    public abstract virtual SecurityToken get_Item(string identifier);
    public abstract virtual void Add(string identifier, SecurityToken token);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(string identifier);
    public abstract virtual void Remove(string identifier);
}
public interface Microsoft.Web.Services3.Security.Tokens.ISecurityTokenManager {
    public string DefaultKeyAlgorithm { get; public set; }
    public string TokenType { get; }
    public abstract virtual string get_DefaultKeyAlgorithm();
    public abstract virtual void set_DefaultKeyAlgorithm(string value);
    public abstract virtual string get_TokenType();
    public abstract virtual void CacheSecurityToken(SecurityToken token);
    public abstract virtual void RemoveSecurityTokenFromCache(SecurityToken token);
    public abstract virtual SecurityToken LoadTokenFromKeyInfo(KeyInfo keyInfo);
    public abstract virtual SecurityToken LoadTokenFromXml(XmlElement element);
    public abstract virtual void VerifyToken(SecurityToken token);
}
public class Microsoft.Web.Services3.Security.Tokens.IssuedToken : SecurityToken {
    private XmlElement _tokenXml;
    private SymmetricKeyAlgorithm _key;
    private SoapProtocolVersion _soapVersion;
    private SecurityToken _baseToken;
    private SecurityTokenCollection _supportTokens;
    private RequestedProofToken _proofToken;
    private EndpointReference _tokenIssuer;
    private LifeTime _lifeTime;
    private AppliesTo _appliesTo;
    public AppliesTo AppliesTo { get; public set; }
    public SecurityToken BaseToken { get; public set; }
    public LifeTime LifeTime { get; public set; }
    public RequestedProofToken ProofToken { get; public set; }
    public bool RequiresRenewal { get; }
    public SecurityTokenCollection SupportingTokens { get; }
    public EndpointReference TokenIssuer { get; public set; }
    public Byte[] KeyBytes { get; public set; }
    public KeyAlgorithm Key { get; }
    public int KeySize { get; }
    public bool IsCurrent { get; }
    public bool IsExpired { get; }
    public IPrincipal Principal { get; public set; }
    public IIdentity Identity { get; }
    internal SoapProtocolVersion SoapVersion { get; internal set; }
    public bool SupportsDataEncryption { get; }
    public bool SupportsDigitalSignature { get; }
    public IssuedToken(string tokenType);
    public IssuedToken(XmlElement element);
    public IssuedToken(XmlElement element, string tokenType);
    public virtual void Cancel();
    public sealed virtual AppliesTo get_AppliesTo();
    public sealed virtual void set_AppliesTo(AppliesTo value);
    public sealed virtual SecurityToken get_BaseToken();
    public sealed virtual void set_BaseToken(SecurityToken value);
    public sealed virtual LifeTime get_LifeTime();
    public sealed virtual void set_LifeTime(LifeTime value);
    public sealed virtual RequestedProofToken get_ProofToken();
    public sealed virtual void set_ProofToken(RequestedProofToken value);
    protected virtual void RecoverKey();
    public virtual bool get_RequiresRenewal();
    public sealed virtual SecurityTokenCollection get_SupportingTokens();
    public sealed virtual EndpointReference get_TokenIssuer();
    public sealed virtual void set_TokenIssuer(EndpointReference value);
    public sealed virtual Byte[] get_KeyBytes();
    public void set_KeyBytes(Byte[] value);
    public virtual KeyAlgorithm get_Key();
    public virtual bool Equals(SecurityToken token);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    protected void InitializeKey(SymmetricKeyAlgorithm key);
    public int get_KeySize();
    public virtual bool get_IsCurrent();
    public virtual bool get_IsExpired();
    public virtual void LoadXml(XmlElement element);
    public virtual IPrincipal get_Principal();
    public virtual void set_Principal(IPrincipal value);
    public virtual IIdentity get_Identity();
    internal SoapProtocolVersion get_SoapVersion();
    internal void set_SoapVersion(SoapProtocolVersion value);
    public virtual bool get_SupportsDataEncryption();
    public virtual bool get_SupportsDigitalSignature();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Security.Tokens.IssuedTokenCache : object {
    private MRUHashtable _tokens;
    private int _capacity;
    private EventHandler Changed;
    public SecurityToken Item { get; }
    public int Capacity { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public IssuedTokenCache(int capacity);
    public void add_Changed(EventHandler value);
    public void remove_Changed(EventHandler value);
    public virtual SecurityToken get_Item(SecurityTokenReference str);
    public virtual void Add(SecurityToken token);
    public virtual int get_Capacity();
    public virtual void Clear();
    public virtual bool Contains(SecurityToken token);
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    public bool get_IsSynchronized();
    protected void OnChanged();
    protected virtual void Purge();
    public virtual void Remove(SecurityToken token);
    public virtual object get_SyncRoot();
}
public class Microsoft.Web.Services3.Security.Tokens.IssuedTokenCacheReference : object {
    private SecurityTokenReference _internalReference;
    private SecurityTokenReference _externalReference;
    public SecurityTokenReference InternalReference { get; }
    public SecurityTokenReference ExternalReference { get; }
    public IssuedTokenCacheReference(SecurityToken token);
    public IssuedTokenCacheReference(SecurityTokenReference internalReference, SecurityTokenReference externalReference);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SecurityTokenReference get_InternalReference();
    public SecurityTokenReference get_ExternalReference();
}
public class Microsoft.Web.Services3.Security.Tokens.IssuedTokenManager : SecurityTokenManager {
    public static string IssuedTokenType;
    public static string NamespaceURI;
    public static string LocalName;
    private IssuedTokenCache _cache;
    private int _cacheLimit;
    private object _lock;
    private TimeSpan _renewalWindow;
    public string TokenType { get; }
    protected IssuedTokenCache IssuedTokenCache { get; }
    public int CacheLimit { get; }
    public TimeSpan RenewalWindow { get; }
    public IssuedTokenManager(XmlNodeList configData);
    public virtual string get_TokenType();
    protected virtual IssuedTokenCache get_IssuedTokenCache();
    public int get_CacheLimit();
    public virtual void CacheSecurityToken(SecurityToken token);
    public virtual void RemoveSecurityTokenFromCache(SecurityToken token);
    private void EnsureCache();
    public virtual SecurityToken LoadTokenFromXml(XmlElement element);
    public virtual SecurityToken LoadTokenFromKeyInfo(KeyInfo keyInfo);
    public TimeSpan get_RenewalWindow();
    public virtual IssuedToken RequestTokenFromIssuer(EndpointReference tokenIssuer, string tokenType, AppliesTo appliesTo, Policy policy, SoapProtocolVersion soapVersion, StateManager messageState, StateManager operationState, StateManager sessionState);
    public virtual void CancelTokenFromIssuer(IssuedToken cancelTarget);
}
internal enum Microsoft.Web.Services3.Security.Tokens.Kerberos.AscReq : Enum {
    public int value__;
    public static AscReq ASC_REQ_DELEGATE;
    public static AscReq ASC_REQ_MUTUAL_AUTH;
    public static AscReq ASC_REQ_REPLAY_DETECT;
    public static AscReq ASC_REQ_SEQUENCE_DETECT;
    public static AscReq ASC_REQ_CONFIDENTIALITY;
    public static AscReq ASC_REQ_USE_SESSION_KEY;
    public static AscReq ASC_REQ_ALLOCATE_MEMORY;
    public static AscReq ASC_REQ_USE_DCE_STYLE;
    public static AscReq ASC_REQ_DATAGRAM;
    public static AscReq ASC_REQ_CONNECTION;
    public static AscReq ASC_REQ_CALL_LEVEL;
    public static AscReq ASC_REQ_EXTENDED_ERROR;
    public static AscReq ASC_REQ_STREAM;
    public static AscReq ASC_REQ_INTEGRITY;
    public static AscReq ASC_REQ_LICENSING;
    public static AscReq ASC_REQ_IDENTIFY;
    public static AscReq ASC_REQ_ALLOW_NULL_SESSION;
    public static AscReq ASC_REQ_ALLOW_NON_USER_LOGONS;
    public static AscReq ASC_REQ_ALLOW_CONTEXT_REPLAY;
    public static AscReq ASC_REQ_FRAGMENT_TO_FIT;
    public static AscReq ASC_REQ_FRAGMENT_SUPPLIED;
    public static AscReq ASC_REQ_NO_TOKEN;
}
internal enum Microsoft.Web.Services3.Security.Tokens.Kerberos.AscRet : Enum {
    public int value__;
    public static AscRet ASC_RET_DELEGATE;
    public static AscRet ASC_RET_MUTUAL_AUTH;
    public static AscRet ASC_RET_REPLAY_DETECT;
    public static AscRet ASC_RET_SEQUENCE_DETECT;
    public static AscRet ASC_RET_CONFIDENTIALITY;
    public static AscRet ASC_RET_USE_SESSION_KEY;
    public static AscRet ASC_RET_ALLOCATED_MEMORY;
    public static AscRet ASC_RET_USED_DCE_STYLE;
    public static AscRet ASC_RET_DATAGRAM;
    public static AscRet ASC_RET_CONNECTION;
    public static AscRet ASC_RET_CALL_LEVEL;
    public static AscRet ASC_RET_THIRD_LEG_FAILED;
    public static AscRet ASC_RET_EXTENDED_ERROR;
    public static AscRet ASC_RET_STREAM;
    public static AscRet ASC_RET_INTEGRITY;
    public static AscRet ASC_RET_LICENSING;
    public static AscRet ASC_RET_IDENTIFY;
    public static AscRet ASC_RET_NULL_SESSION;
    public static AscRet ASC_RET_ALLOW_NON_USER_LOGONS;
    public static AscRet ASC_RET_ALLOW_CONTEXT_REPLAY;
    public static AscRet ASC_RET_FRAGMENT_ONLY;
    public static AscRet ASC_RET_NO_TOKEN;
}
internal enum Microsoft.Web.Services3.Security.Tokens.Kerberos.CredentialUse : Enum {
    public int value__;
    public static CredentialUse SECPKG_CRED_INBOUND;
    public static CredentialUse SECPKG_CRED_OUTBOUND;
    public static CredentialUse SECPKG_CRED_BOTH;
    public static CredentialUse SECPKG_CRED_DEFAULT;
    public static CredentialUse SECPKG_CRED_RESERVED;
}
internal enum Microsoft.Web.Services3.Security.Tokens.Kerberos.Endianness : Enum {
    public int value__;
    public static Endianness SECURITY_NATIVE_DREP;
    public static Endianness SECURITY_NETWORK_DREP;
}
internal enum Microsoft.Web.Services3.Security.Tokens.Kerberos.FormatMessageFlags : Enum {
    public int value__;
    public static FormatMessageFlags FORMAT_MESSAGE_FROM_SYSTEM;
    public static FormatMessageFlags FORMAT_MESSAGE_ALLOCATE_BUFFER;
}
internal enum Microsoft.Web.Services3.Security.Tokens.Kerberos.IscReq : Enum {
    public int value__;
    public static IscReq ISC_REQ_DELEGATE;
    public static IscReq ISC_REQ_MUTUAL_AUTH;
    public static IscReq ISC_REQ_REPLAY_DETECT;
    public static IscReq ISC_REQ_SEQUENCE_DETECT;
    public static IscReq ISC_REQ_CONFIDENTIALITY;
    public static IscReq ISC_REQ_USE_SESSION_KEY;
    public static IscReq ISC_REQ_PROMPT_FOR_CREDS;
    public static IscReq ISC_REQ_USE_SUPPLIED_CREDS;
    public static IscReq ISC_REQ_ALLOCATE_MEMORY;
    public static IscReq ISC_REQ_USE_DCE_STYLE;
    public static IscReq ISC_REQ_DATAGRAM;
    public static IscReq ISC_REQ_CONNECTION;
    public static IscReq ISC_REQ_CALL_LEVEL;
    public static IscReq ISC_REQ_FRAGMENT_SUPPLIED;
    public static IscReq ISC_REQ_EXTENDED_ERROR;
    public static IscReq ISC_REQ_STREAM;
    public static IscReq ISC_REQ_INTEGRITY;
    public static IscReq ISC_REQ_IDENTIFY;
    public static IscReq ISC_REQ_NULL_SESSION;
    public static IscReq ISC_REQ_MANUAL_CRED_VALIDATION;
    public static IscReq ISC_REQ_RESERVED1;
    public static IscReq ISC_REQ_FRAGMENT_TO_FIT;
}
internal enum Microsoft.Web.Services3.Security.Tokens.Kerberos.IscRet : Enum {
    public int value__;
    public static IscRet ISC_RET_DELEGATE;
    public static IscRet ISC_RET_MUTUAL_AUTH;
    public static IscRet ISC_RET_REPLAY_DETECT;
    public static IscRet ISC_RET_SEQUENCE_DETECT;
    public static IscRet ISC_RET_CONFIDENTIALITY;
    public static IscRet ISC_RET_USE_SESSION_KEY;
    public static IscRet ISC_RET_USED_COLLECTED_CREDS;
    public static IscRet ISC_RET_USED_SUPPLIED_CREDS;
    public static IscRet ISC_RET_ALLOCATED_MEMORY;
    public static IscRet ISC_RET_USED_DCE_STYLE;
    public static IscRet ISC_RET_DATAGRAM;
    public static IscRet ISC_RET_CONNECTION;
    public static IscRet ISC_RET_INTERMEDIATE_RETURN;
    public static IscRet ISC_RET_CALL_LEVEL;
    public static IscRet ISC_RET_EXTENDED_ERROR;
    public static IscRet ISC_RET_STREAM;
    public static IscRet ISC_RET_INTEGRITY;
    public static IscRet ISC_RET_IDENTIFY;
    public static IscRet ISC_RET_NULL_SESSION;
    public static IscRet ISC_RET_MANUAL_CRED_VALIDATION;
    public static IscRet ISC_RET_RESERVED1;
    public static IscRet ISC_RET_FRAGMENT_ONLY;
}
internal abstract class Microsoft.Web.Services3.Security.Tokens.Kerberos.KerberosBuffer : object {
    private IntPtr _buffer;
    private bool _disposed;
    public IntPtr Buffer { get; }
    public KerberosBuffer(int size);
    protected virtual void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public IntPtr get_Buffer();
}
public class Microsoft.Web.Services3.Security.Tokens.Kerberos.KerberosClientContext : KerberosContext {
    private string _targetPrincipalName;
    private ImpersonationLevel _impersonationLevel;
    private WindowsPrincipal _windowsPrincipal;
    private bool _continueNeeded;
    private UInt32 _flags;
    private bool _requireMutualAuthentication;
    public bool ContinueNeeded { get; }
    public ImpersonationLevel ImpersonationLevel { get; }
    public bool RequireMutualAuthentication { get; }
    public WindowsPrincipal WindowsPrincipal { get; }
    public KerberosClientContext(string targetPrincipalName);
    public KerberosClientContext(string targetPrincipalName, bool requireMutualAuthentication, ImpersonationLevel level);
    public virtual bool get_ContinueNeeded();
    public virtual ImpersonationLevel get_ImpersonationLevel();
    public virtual bool get_RequireMutualAuthentication();
    public Byte[] InitializeContext();
    public Byte[] InitializeContext(Byte[] inToken);
    public virtual WindowsPrincipal get_WindowsPrincipal();
}
public abstract class Microsoft.Web.Services3.Security.Tokens.Kerberos.KerberosContext : object {
    private IntPtr _context;
    private string _cname;
    private string _sname;
    private Byte[] _sessionKey;
    private bool _disposed;
    private KerberosCredential _credential;
    private SECURITY_INTEGER _tsExpiry;
    private DateTime _expirationTime;
    public string ClientPrincipalName { get; }
    protected IntPtr Context { get; protected set; }
    public bool ContinueNeeded { get; }
    internal KerberosCredential Credential { get; internal set; }
    internal SECURITY_INTEGER Expiry { get; }
    public DateTime ExpirationTime { get; }
    public ImpersonationLevel ImpersonationLevel { get; }
    public bool RequireMutualAuthentication { get; }
    public Byte[] SessionKey { get; }
    public string TargetPrincipalName { get; }
    public WindowsPrincipal WindowsPrincipal { get; }
    protected virtual void Finalize();
    public virtual string get_ClientPrincipalName();
    protected IntPtr get_Context();
    protected void set_Context(IntPtr value);
    public abstract virtual bool get_ContinueNeeded();
    internal KerberosCredential get_Credential();
    internal void set_Credential(KerberosCredential value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal SECURITY_INTEGER get_Expiry();
    public DateTime get_ExpirationTime();
    public abstract virtual ImpersonationLevel get_ImpersonationLevel();
    private void InitializeNames();
    public abstract virtual bool get_RequireMutualAuthentication();
    public virtual Byte[] get_SessionKey();
    public virtual string get_TargetPrincipalName();
    public abstract virtual WindowsPrincipal get_WindowsPrincipal();
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.KerberosCredential : object {
    private IntPtr _credHandle;
    private SECURITY_INTEGER _tsExpiry;
    private bool _disposed;
    internal IntPtr CredentialHandle { get; }
    internal KerberosCredential(CredentialUse usage);
    protected virtual void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal IntPtr get_CredentialHandle();
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.KerberosInputBuffer : KerberosBuffer {
    private Byte[] _token;
    public Byte[] Token { get; }
    public KerberosInputBuffer(Byte[] inToken);
    public Byte[] get_Token();
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.KerberosOutputBuffer : KerberosBuffer {
    private Byte[] _token;
    public Byte[] Token { get; }
    public Byte[] get_Token();
}
public class Microsoft.Web.Services3.Security.Tokens.Kerberos.KerberosServerContext : KerberosContext {
    private ImpersonationLevel _impersonationLevel;
    private WindowsPrincipal _windowsPrincipal;
    private bool _continueNeeded;
    private bool _requireMutualAuthentication;
    private UInt32 _flags;
    public bool ContinueNeeded { get; }
    public ImpersonationLevel ImpersonationLevel { get; }
    public bool RequireMutualAuthentication { get; }
    public WindowsPrincipal WindowsPrincipal { get; }
    public KerberosServerContext(bool requireMutualAuthentication, ImpersonationLevel level);
    public Byte[] AcceptContext(Byte[] inToken);
    public virtual bool get_ContinueNeeded();
    public virtual ImpersonationLevel get_ImpersonationLevel();
    public virtual bool get_RequireMutualAuthentication();
    public virtual WindowsPrincipal get_WindowsPrincipal();
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.LUID : ValueType {
    internal UInt32 LowPart;
    internal UInt32 HighPart;
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.LUID_AND_ATTRIBUTES : ValueType {
    public LUID Luid;
    public int Attributes;
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.NativeMethods : object {
    private static string SECUR32;
    private static string KERNEL32;
    private static string ADVAPI32;
    internal static int KERB_LOGON_FLAG_ALLOW_EXPIRED_TICKET;
    internal static string SE_SECURITY_NAME;
    internal static int STATUS_SUCCESS;
    internal static UInt32 TOKENBUFSIZE;
    internal static int TOKEN_ADJUST_PRIVILEGES;
    internal static int TOKEN_QUERY;
    internal static int SE_PRIVILEGE_ENABLED;
    private static NativeMethods();
    internal static bool CloseHandle(IntPtr hObject);
    internal static UInt32 LsaNtStatusToWinError(UInt32 status);
    internal static UInt32 LocalFileTimeToFileTime(SECURITY_INTEGER lpLocalFileTime, SECURITY_INTEGER lpFileTime);
    internal static UInt32 FormatMessage(FormatMessageFlags dwFlags, IntPtr lpSource, UInt32 dwMessageId, UInt32 dwLanguageId, StringBuilder lpBuffer, UInt32 nSize, IntPtr Arguments);
    internal static int AcquireCredentialsHandleW(string pszPrincipal, string pPackage, int fCredentialUse, IntPtr pvLogonId, IntPtr pAuthData, IntPtr pGetKeyFn, IntPtr pvGetKeyArgument, IntPtr phCredential, Int64& ptsExpiry);
    internal static UInt32 FreeCredentialsHandle(IntPtr phCredential);
    internal static UInt32 AcceptSecurityContext(IntPtr phCredential, IntPtr phContext, IntPtr pInput, UInt32 fContextReq, UInt32 TargetDataRep, IntPtr phNewContext, IntPtr pOutput, UInt32& pfContextAttr, SECURITY_INTEGER ptsTimeStamp);
    internal static UInt32 DeleteSecurityContext(IntPtr phContext);
    internal static UInt32 FreeContextBuffer(IntPtr buffer);
    internal static UInt32 InitializeSecurityContext(IntPtr phCredential, IntPtr phContext, string pszTargetName, UInt32 fContextReq, UInt32 Reserved1, UInt32 TargetDataRep, IntPtr pInput, UInt32 Reserved2, IntPtr phNewContext, IntPtr pOutput, UInt32& pfContextAttr, SECURITY_INTEGER ptsExpiry);
    internal static UInt32 QueryContextAttributes(IntPtr phContext, SecPkgAttr ulAttribute, SecPkgContext_SessionKey& pBuffer);
    internal static UInt32 QueryContextAttributes(IntPtr phContext, SecPkgAttr ulAttribute, SecPkgContext_NativeNames& pBuffer);
    internal static UInt32 QuerySecurityContextToken(IntPtr phContext, IntPtr& phToken);
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.SecBuffer : ValueType {
    internal UInt32 cbBuffer;
    internal UInt32 BufferType;
    internal IntPtr pvBuffer;
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.SecBufferDesc : ValueType {
    internal UInt32 ulVersion;
    internal UInt32 cBuffers;
    internal IntPtr pBuffers;
}
internal enum Microsoft.Web.Services3.Security.Tokens.Kerberos.SecBufferType : Enum {
    public int value__;
    public static SecBufferType SECBUFFER_VERSION;
    public static SecBufferType SECBUFFER_EMPTY;
    public static SecBufferType SECBUFFER_DATA;
    public static SecBufferType SECBUFFER_TOKEN;
    public static SecBufferType SECBUFFER_PKG_PARAMS;
    public static SecBufferType SECBUFFER_MISSING;
    public static SecBufferType SECBUFFER_EXTRA;
    public static SecBufferType SECBUFFER_STREAM_TRAILER;
    public static SecBufferType SECBUFFER_STREAM_HEADER;
    public static SecBufferType SECBUFFER_NEGOTIATION_INFO;
    public static SecBufferType SECBUFFER_PADDING;
    public static SecBufferType SECBUFFER_STREAM;
    public static SecBufferType SECBUFFER_MECHLIST;
    public static SecBufferType SECBUFFER_MECHLIST_SIGNATURE;
    public static SecBufferType SECBUFFER_TARGET;
    public static SecBufferType SECBUFFER_CHANNEL_BINDINGS;
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.SecHandle : ValueType {
    internal IntPtr dwLower;
    internal IntPtr dwUpper;
}
internal enum Microsoft.Web.Services3.Security.Tokens.Kerberos.SecPkgAttr : Enum {
    public UInt32 value__;
    public static SecPkgAttr SECPKG_ATTR_SIZES;
    public static SecPkgAttr SECPKG_ATTR_NAMES;
    public static SecPkgAttr SECPKG_ATTR_LIFESPAN;
    public static SecPkgAttr SECPKG_ATTR_DCE_INFO;
    public static SecPkgAttr SECPKG_ATTR_STREAM_SIZES;
    public static SecPkgAttr SECPKG_ATTR_KEY_INFO;
    public static SecPkgAttr SECPKG_ATTR_AUTHORITY;
    public static SecPkgAttr SECPKG_ATTR_PROTO_INFO;
    public static SecPkgAttr SECPKG_ATTR_PASSWORD_EXPIRY;
    public static SecPkgAttr SECPKG_ATTR_SESSION_KEY;
    public static SecPkgAttr SECPKG_ATTR_PACKAGE_INFO;
    public static SecPkgAttr SECPKG_ATTR_USER_FLAGS;
    public static SecPkgAttr SECPKG_ATTR_NEGOTIATION_INFO;
    public static SecPkgAttr SECPKG_ATTR_NATIVE_NAMES;
    public static SecPkgAttr SECPKG_ATTR_FLAGS;
    public static SecPkgAttr SECPKG_ATTR_USE_VALIDATED;
    public static SecPkgAttr SECPKG_ATTR_CREDENTIAL_NAME;
    public static SecPkgAttr SECPKG_ATTR_TARGET_INFORMATION;
    public static SecPkgAttr SECPKG_ATTR_ACCESS_TOKEN;
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.SecPkgContext_NativeNames : ValueType {
    internal string cname;
    internal string sname;
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.SecPkgContext_SessionKey : ValueType {
    internal UInt32 SessionKeyLength;
    internal IntPtr SessionKey;
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.SECURITY_INTEGER : object {
    internal UInt32 LowPart;
    internal int HighPart;
}
internal enum Microsoft.Web.Services3.Security.Tokens.Kerberos.SecurityStatus : Enum {
    public int value__;
    public static SecurityStatus OK;
    public static SecurityStatus OutOfMemory;
    public static SecurityStatus InvalidHandle;
    public static SecurityStatus Unsupported;
    public static SecurityStatus TargetUnknown;
    public static SecurityStatus InternalError;
    public static SecurityStatus PackageNotFound;
    public static SecurityStatus NotOwner;
    public static SecurityStatus CannotInstall;
    public static SecurityStatus InvalidToken;
    public static SecurityStatus UnknownCredential;
    public static SecurityStatus NoCredentials;
    public static SecurityStatus MessageAltered;
    public static SecurityStatus ContinueNeeded;
    public static SecurityStatus CompleteNeeded;
    public static SecurityStatus CompAndContinue;
    public static SecurityStatus ContextExpired;
    public static SecurityStatus IncompleteMessage;
    public static SecurityStatus IncompleteCred;
    public static SecurityStatus BufferNotEnough;
    public static SecurityStatus WrongPrincipal;
    public static SecurityStatus UntrustedRoot;
    public static SecurityStatus UnknownCertificate;
    public static SecurityStatus SECBUFFER_READONLY;
    public static SecurityStatus CredentialsNeeded;
    public static SecurityStatus Renegotiate;
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.TOKEN_PRIVILEGES : ValueType {
    public UInt32 PrivilegeCount;
    public LUID_AND_ATTRIBUTES Privileges;
}
internal class Microsoft.Web.Services3.Security.Tokens.Kerberos.Utility : object {
    internal static string GetStatusMessage(string apiName, UInt32 status);
    internal static string GetStatusMessage(UInt32 status);
    internal static string GetWinErrorMessage(string apiName, UInt32 winErrorCode);
    private static string GetWinErrorMessage(UInt32 winErrorCode);
    internal static DateTime TimestampToDateTime(SECURITY_INTEGER timestamp);
    internal static DateTime FromFileTime(FILETIME fileTime);
    internal static Byte[] BufferToByteArray(IntPtr bufPtr, UInt32 bufSize);
    internal static Byte[] BufferToByteArray(IntPtr bufPtr, int offset, int length);
}
public class Microsoft.Web.Services3.Security.Tokens.KerberosToken : BinarySecurityToken {
    private KerberosContext _context;
    private SymmetricKeyAlgorithm _key;
    private KeyIdentifier _keyIdentifier;
    private DateTime _creationTime;
    private SecurityToken _baseToken;
    private RequestedProofToken _proofToken;
    private SecurityTokenCollection _supportTokens;
    private EndpointReference _tokenIssuer;
    private LifeTime _lifeTime;
    private AppliesTo _appliesTo;
    public IIdentity Identity { get; }
    public AppliesTo AppliesTo { get; public set; }
    public SecurityToken BaseToken { get; public set; }
    public LifeTime LifeTime { get; public set; }
    public RequestedProofToken ProofToken { get; public set; }
    public bool RequiresRenewal { get; }
    public SecurityTokenCollection SupportingTokens { get; }
    public EndpointReference TokenIssuer { get; public set; }
    public ImpersonationLevel ImpersonationLevel { get; }
    public bool IsCurrent { get; }
    public bool IsExpired { get; }
    public KeyAlgorithm Key { get; }
    public Byte[] KeyBytes { get; }
    public KeyIdentifier KeyIdentifier { get; }
    public IPrincipal Principal { get; public set; }
    public Byte[] RawData { get; public set; }
    public bool SupportsDataEncryption { get; }
    public bool SupportsDigitalSignature { get; }
    public string TargetPrincipal { get; }
    public string ClientPrincipal { get; }
    public string ValueType { get; public set; }
    public KerberosToken(string serviceMachineName, string domain);
    public KerberosToken(string targetPrincipal);
    public KerberosToken(string serviceMachineName, string domain, ImpersonationLevel level);
    public KerberosToken(string targetPrincipal, ImpersonationLevel level);
    public KerberosToken(XmlElement element);
    public virtual IIdentity get_Identity();
    protected virtual void Finalize();
    public sealed virtual AppliesTo get_AppliesTo();
    public sealed virtual void set_AppliesTo(AppliesTo value);
    public sealed virtual SecurityToken get_BaseToken();
    public sealed virtual void set_BaseToken(SecurityToken value);
    public sealed virtual LifeTime get_LifeTime();
    public sealed virtual void set_LifeTime(LifeTime value);
    public sealed virtual RequestedProofToken get_ProofToken();
    public sealed virtual void set_ProofToken(RequestedProofToken value);
    public virtual bool get_RequiresRenewal();
    public sealed virtual SecurityTokenCollection get_SupportingTokens();
    public sealed virtual EndpointReference get_TokenIssuer();
    public sealed virtual void set_TokenIssuer(EndpointReference value);
    public ImpersonationLevel get_ImpersonationLevel();
    public sealed virtual void Dispose();
    private void Dispose(bool isDisposing);
    public virtual bool Equals(SecurityToken token);
    public virtual int GetHashCode();
    private void InitializeServerContext();
    private void InitializeLifeTime();
    private void InitializeKey();
    public virtual bool get_IsCurrent();
    public virtual bool get_IsExpired();
    public virtual KeyAlgorithm get_Key();
    public sealed virtual Byte[] get_KeyBytes();
    public virtual KeyIdentifier get_KeyIdentifier();
    public virtual IPrincipal get_Principal();
    public virtual void set_Principal(IPrincipal value);
    public virtual Byte[] get_RawData();
    public virtual void set_RawData(Byte[] value);
    public virtual bool get_SupportsDataEncryption();
    public virtual bool get_SupportsDigitalSignature();
    public string get_TargetPrincipal();
    public string get_ClientPrincipal();
    public virtual string get_ValueType();
    public virtual void set_ValueType(string value);
}
public class Microsoft.Web.Services3.Security.Tokens.KerberosTokenManager : KeyIdentifierCachedSecurityTokenManager {
    private TimeSpan _renewalWindow;
    private string _defaultKeyAlgorithm;
    public string DefaultKeyAlgorithm { get; public set; }
    public TimeSpan RenewalWindow { get; }
    public string TokenType { get; }
    public KerberosTokenManager(XmlNodeList configData);
    public virtual string get_DefaultKeyAlgorithm();
    public virtual void set_DefaultKeyAlgorithm(string value);
    public virtual SecurityToken LoadTokenFromKeyInfo(KeyInfo keyInfo);
    public virtual SecurityToken LoadTokenFromXml(XmlElement element);
    public TimeSpan get_RenewalWindow();
    public virtual string get_TokenType();
}
public abstract class Microsoft.Web.Services3.Security.Tokens.KeyIdentifierCachedSecurityTokenManager : SecurityTokenManager {
    private MRUSecurityTokenCache _cache;
    private int _cacheLimit;
    private object _lock;
    public int CacheCapacity { get; }
    protected ISecurityTokenCache TokenCache { get; }
    protected KeyIdentifierCachedSecurityTokenManager(XmlNodeList configData);
    public int get_CacheCapacity();
    public virtual void CacheSecurityToken(SecurityToken token);
    public virtual SecurityToken LoadTokenFromKeyInfo(KeyInfo keyInfo);
    protected virtual ISecurityTokenCache get_TokenCache();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Security.Tokens.MRUSecurityTokenCache : object {
    private int _capacity;
    private MRUHashtable _tokens;
    private EventHandler Changed;
    public SecurityToken Item { get; }
    public int Capacity { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public MRUSecurityTokenCache(int capacity);
    public sealed virtual void add_Changed(EventHandler value);
    public sealed virtual void remove_Changed(EventHandler value);
    public virtual SecurityToken get_Item(string identifier);
    public virtual void Add(string identifier, SecurityToken token);
    public virtual int get_Capacity();
    public virtual void Clear();
    public virtual bool Contains(string identifier);
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    public sealed virtual bool get_IsSynchronized();
    protected void OnChanged();
    protected virtual void Purge();
    public virtual void Remove(string identifier);
    public virtual object get_SyncRoot();
}
public enum Microsoft.Web.Services3.Security.Tokens.PasswordOption : Enum {
    public int value__;
    public static PasswordOption SendNone;
    public static PasswordOption SendHashed;
    public static PasswordOption SendPlainText;
}
public class Microsoft.Web.Services3.Security.Tokens.PasswordTypes : object {
    public static string PasswordText;
    public static string PasswordDigest;
}
public class Microsoft.Web.Services3.Security.Tokens.SecurityContextToken : IssuedToken {
    private Identifier _identifier;
    private AttributeList _anyAttribute;
    private ElementList _anyElement;
    private KeyInfo _keyInfo;
    private SecurityToken _serviceToken;
    private XmlElement _cookie;
    private bool _loaded;
    public KeyInfo UnattachedReference { get; public set; }
    public AttributeList AnyAttributes { get; }
    public ElementList AnyElements { get; }
    public string Identifier { get; }
    public SecurityToken ServiceToken { get; public set; }
    public SecurityContextToken(string identifier);
    public SecurityContextToken(SecurityToken baseToken);
    public SecurityContextToken(SecurityToken baseToken, string identifier);
    public SecurityContextToken(Byte[] keyBytes);
    public SecurityContextToken(XmlElement element);
    public virtual KeyInfo get_UnattachedReference();
    public virtual void set_UnattachedReference(KeyInfo value);
    public AttributeList get_AnyAttributes();
    public ElementList get_AnyElements();
    internal void CheckValid();
    public SecurityContextToken CreateBareToken();
    public virtual bool Equals(SecurityToken token);
    public virtual int GetHashCode();
    public virtual XmlElement GetXml(XmlDocument document);
    public string get_Identifier();
    public virtual void LoadXml(XmlElement element);
    protected virtual void RecoverKey();
    public SecurityToken get_ServiceToken();
    public void set_ServiceToken(SecurityToken value);
}
public class Microsoft.Web.Services3.Security.Tokens.SecurityContextTokenManager : IssuedTokenManager {
    internal static string Prefix;
    internal static string Cookie;
    internal static string Key;
    internal static string TokenInfo;
    internal static string EncodedData;
    internal static string Hash;
    internal static string EncodedElement;
    internal static string NamespaceUri;
    private ISecurityTokenCache _cache;
    private object _lock;
    public string TokenType { get; }
    protected ISecurityTokenCache TokenCache { get; }
    public SecurityContextTokenManager(XmlNodeList configData);
    public virtual void CacheSecurityToken(SecurityToken token);
    public virtual void CancelTokenFromIssuer(IssuedToken cancelTarget);
    private Byte[] ComputeHash(XmlElement element);
    public virtual XmlElement EncryptTokenInfo(SecurityContextToken sct, XmlDocument document);
    protected virtual XmlElement GetTokenInfoData(SecurityContextToken sct, XmlDocument document);
    protected virtual XmlElement EncodeTokenInfo(SecurityContextToken sct, XmlDocument document, XmlElement tokenInfo);
    protected virtual XmlElement DecodeTokenInfo(XmlElement encodedTokenInfo);
    public virtual void DecryptTokenInfo(SecurityContextToken sct, XmlElement encodedData);
    protected virtual void LoadTokenInfoData(SecurityContextToken sct, XmlElement tokenInfo);
    private void EnsureCache();
    public virtual SecurityToken LoadTokenFromXml(XmlElement element);
    public virtual SecurityToken LoadTokenFromKeyInfo(KeyInfo keyInfo);
    public virtual IssuedToken RequestTokenFromIssuer(EndpointReference tokenIssuer, string tokenType, AppliesTo appliesTo, Policy policy, SoapProtocolVersion soapVersion, StateManager messageState, StateManager operationState, StateManager sessionState);
    public virtual void RemoveSecurityTokenFromCache(SecurityToken token);
    public virtual string get_TokenType();
    protected virtual ISecurityTokenCache get_TokenCache();
    public virtual void VerifyToken(SecurityToken token);
}
public abstract class Microsoft.Web.Services3.Security.Tokens.SecurityToken : object {
    private string _id;
    private string _tokenType;
    private IPrincipal _principal;
    private KeyInfo _attachedReference;
    private KeyInfo _unattachedReference;
    public string Id { get; public set; }
    public bool IsCurrent { get; }
    public bool IsExpired { get; }
    public bool RequiresRenewal { get; }
    public KeyAlgorithm Key { get; }
    public KeyIdentifier KeyIdentifier { get; }
    public KeyInfo AttachedReference { get; public set; }
    public KeyInfo UnattachedReference { get; public set; }
    public IIdentity Identity { get; }
    public IPrincipal Principal { get; public set; }
    public bool SupportsDataEncryption { get; }
    public bool SupportsDigitalSignature { get; }
    public string TokenType { get; }
    protected SecurityToken(string tokenType);
    protected SecurityToken(XmlElement element, string tokenType);
    public virtual bool Equals(object obj);
    public abstract virtual bool Equals(SecurityToken token);
    public abstract virtual int GetHashCode();
    public abstract virtual XmlElement GetXml(XmlDocument document);
    public virtual XmlElement GetSignedTokenXml(SecurityToken signingToken);
    public virtual string get_Id();
    public virtual void set_Id(string value);
    public abstract virtual bool get_IsCurrent();
    public virtual bool get_IsExpired();
    public virtual bool get_RequiresRenewal();
    public abstract virtual KeyAlgorithm get_Key();
    public virtual KeyIdentifier get_KeyIdentifier();
    public virtual KeyInfo get_AttachedReference();
    public virtual void set_AttachedReference(KeyInfo value);
    public virtual KeyInfo get_UnattachedReference();
    public virtual void set_UnattachedReference(KeyInfo value);
    public abstract virtual void LoadXml(XmlElement element);
    public virtual IIdentity get_Identity();
    public virtual IPrincipal get_Principal();
    public virtual void set_Principal(IPrincipal value);
    public abstract virtual bool get_SupportsDataEncryption();
    public abstract virtual bool get_SupportsDigitalSignature();
    public virtual string get_TokenType();
    internal void SetTokenType(string tokenType);
    public virtual void VerifySignedTokenXml(XmlElement element, bool throwIfNoSignature);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Security.Tokens.SecurityTokenCollection : object {
    private Hashtable _tokens;
    private ArrayList _orderedTokens;
    public SecurityToken Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public SecurityToken get_Item(string refid);
    public int Add(SecurityToken token);
    public void AddRange(ICollection collection);
    public void Clear();
    public bool Contains(SecurityToken token);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(SecurityToken[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual bool get_IsSynchronized();
    public void Remove(SecurityToken token);
    public sealed virtual object get_SyncRoot();
    internal bool TryGetUniqueToken(TSecurityToken& token);
}
public abstract class Microsoft.Web.Services3.Security.Tokens.SecurityTokenManager : object {
    private string _defaultKeyAlgorithm;
    public string DefaultKeyAlgorithm { get; public set; }
    public string TokenType { get; }
    protected SecurityTokenManager(XmlNodeList configData);
    public virtual string get_DefaultKeyAlgorithm();
    public virtual void set_DefaultKeyAlgorithm(string value);
    public abstract virtual string get_TokenType();
    public virtual void CacheSecurityToken(SecurityToken token);
    public virtual void RemoveSecurityTokenFromCache(SecurityToken token);
    public virtual SecurityToken LoadTokenFromKeyInfo(KeyInfo keyInfo);
    public virtual SecurityToken LoadTokenFromXml(XmlElement element);
    public virtual void VerifyToken(SecurityToken token);
    public static void Cache(SecurityToken token);
    public static void RemoveFromCache(SecurityToken token);
    public static KeyAlgorithm CreateTokenKeyAlgorithm(string tokenType, Type algorithmType);
    public static ISecurityTokenManager GetSecurityTokenManagerByTokenType(string tokenType);
    public static ISecurityTokenManager GetSecurityTokenManagerByValueType(string valueType);
    public static SecurityToken GetTokenFromKeyInfo(KeyInfo keyInfo);
    public static SecurityToken GetTokenFromKeyInfo(KeyInfo keyInfo, SoapContext soapContext);
    public static SecurityToken GetTokenFromXml(XmlElement element);
    private static SecurityToken LoadBinarySecurityToken(XmlElement element);
    private static SecurityToken LoadXmlSecurityToken(XmlElement element);
    public static void VerifySecurityToken(SecurityToken token);
}
public class Microsoft.Web.Services3.Security.Tokens.UsernameToken : SecurityToken {
    private ElementList _anyElements;
    private Created _created;
    private Nonce _nonce;
    private string _password;
    private string _authenticatedPassword;
    private PasswordOption _passwordOption;
    private Byte[] _passwordDigest;
    private string _username;
    private int _hasMutated;
    private SymmetricKeyAlgorithm _key;
    private string _label;
    public IIdentity Identity { get; }
    public Byte[] KeyBytes { get; }
    public ElementList AnyElements { get; }
    private string AuthenticatedPassword { get; }
    public DateTime Created { get; }
    private PSHA1 DerivedKeyGenerator { get; }
    public KeyAlgorithm Key { get; }
    public bool IsCurrent { get; }
    public bool IsExpired { get; }
    public string Label { get; public set; }
    public Byte[] Nonce { get; }
    internal string NonceString { get; }
    public string Password { get; }
    public Byte[] PasswordDigest { get; }
    public PasswordOption PasswordOption { get; }
    public bool SupportsDataEncryption { get; }
    public bool SupportsDigitalSignature { get; }
    public string Username { get; }
    public UsernameToken(string username, string password);
    public UsernameToken(string username, string password, PasswordOption passwordOption);
    public UsernameToken(XmlElement element);
    private UsernameToken(UsernameToken other);
    public virtual IIdentity get_Identity();
    public sealed virtual Byte[] get_KeyBytes();
    public ElementList get_AnyElements();
    private string get_AuthenticatedPassword();
    private void CheckValid();
    private sealed virtual override IMutableSecurityToken Microsoft.Web.Services3.Security.Tokens.IMutableSecurityToken.Clone();
    public DateTime get_Created();
    private PSHA1 get_DerivedKeyGenerator();
    public virtual bool Equals(SecurityToken token);
    public virtual int GetHashCode();
    public static Byte[] ComputePasswordDigest(Byte[] nonce, DateTime created, string secret);
    public virtual XmlElement GetXml(XmlDocument document);
    private static Byte[] Hash(Byte[] value);
    public virtual KeyAlgorithm get_Key();
    public virtual bool get_IsCurrent();
    public virtual bool get_IsExpired();
    public string get_Label();
    public void set_Label(string value);
    public virtual void LoadXml(XmlElement element);
    public sealed virtual void Mutate();
    public Byte[] get_Nonce();
    internal string get_NonceString();
    public string get_Password();
    public Byte[] get_PasswordDigest();
    public PasswordOption get_PasswordOption();
    internal void SetAuthenticatedPassword(string authenticatedPassword);
    public virtual bool get_SupportsDataEncryption();
    public virtual bool get_SupportsDigitalSignature();
    public string get_Username();
}
public class Microsoft.Web.Services3.Security.Tokens.UsernameTokenManager : SecurityTokenManager {
    private string _label;
    private int _cacheLimit;
    private MRUSecurityTokenCache _cache;
    private TimeSpan _replayWindow;
    private bool _enableReplayDetection;
    private NonceTable _nonceCache;
    public int CacheCapacity { get; }
    public string Label { get; }
    private NonceTable NonceCache { get; }
    public string TokenType { get; }
    protected ISecurityTokenCache TokenCache { get; }
    public UsernameTokenManager(XmlNodeList configData);
    protected virtual void VerifyHashedPassword(UsernameToken token, string authenticatedPassword);
    protected virtual void VerifyPlainTextPassword(UsernameToken token, string authenticatedPassword);
    protected virtual void VerifyPassword(UsernameToken token, string authenticatedPassword);
    protected virtual void DetectReplay(UsernameToken token);
    protected virtual string AuthenticateToken(UsernameToken token);
    public int get_CacheCapacity();
    public virtual void CacheSecurityToken(SecurityToken token);
    public string get_Label();
    public static WindowsPrincipal LogonUser(string username, string password);
    public virtual SecurityToken LoadTokenFromXml(XmlElement element);
    private NonceTable get_NonceCache();
    protected virtual void OnLogonUserFailed(UsernameToken token);
    public virtual string get_TokenType();
    protected virtual ISecurityTokenCache get_TokenCache();
    public virtual void VerifyToken(SecurityToken token);
}
internal class Microsoft.Web.Services3.Security.Tokens.X509CertificateCache : object {
    private string _storeName;
    private HybridDictionary _exactSubjectCache;
    private object _exactSubjectCacheLock;
    private HybridDictionary _keyIdentifierCache;
    private object _keyIdentifierCacheLock;
    private Dictionary`2<string, X509Certificate2> issuerSerialCache;
    public static X509CertificateCache My;
    public static X509CertificateCache OtherPeople;
    private X509CertificateCache(string storeName);
    private static X509CertificateCache();
    public X509Certificate2 GetCertificateByIssuerSerial(string issuerName, string serialNumber);
    public X509Certificate2 GetCertificateByKeyId(Byte[] keyId);
    public X509Certificate2Collection GetCertificateByExactSubjectName(string subjectName);
}
public class Microsoft.Web.Services3.Security.Tokens.X509SecurityToken : BinarySecurityToken {
    private X509Certificate2 _certificate;
    private RSA _key;
    private RSA _publicKey;
    private bool wasUnattachedReferenceSet;
    public IIdentity Identity { get; }
    public KeyInfo UnattachedReference { get; public set; }
    public X509Certificate2 Certificate { get; public set; }
    public bool IsCurrent { get; }
    public KeyAlgorithm Key { get; }
    public KeyIdentifier KeyIdentifier { get; }
    public KeyAlgorithm PublicKey { get; }
    public Byte[] RawData { get; public set; }
    public string ValueType { get; public set; }
    public bool SupportsDataEncryption { get; }
    public bool SupportsDigitalSignature { get; }
    public X509SecurityToken(X509Certificate2 certificate);
    public X509SecurityToken(XmlElement element);
    public virtual IIdentity get_Identity();
    public virtual KeyInfo get_UnattachedReference();
    public virtual void set_UnattachedReference(KeyInfo value);
    public X509Certificate2 get_Certificate();
    public void set_Certificate(X509Certificate2 value);
    public virtual bool Equals(SecurityToken token);
    public virtual int GetHashCode();
    public virtual bool get_IsCurrent();
    public virtual KeyAlgorithm get_Key();
    public virtual KeyIdentifier get_KeyIdentifier();
    public KeyAlgorithm get_PublicKey();
    public virtual Byte[] get_RawData();
    public virtual void set_RawData(Byte[] value);
    public virtual string get_ValueType();
    public virtual void set_ValueType(string value);
    public virtual bool get_SupportsDataEncryption();
    public virtual bool get_SupportsDigitalSignature();
    public void Verify();
    private void VerifyTrust();
    private void VerifyChain(X509Chain chain);
}
public class Microsoft.Web.Services3.Security.Tokens.X509SecurityTokenManager : SecurityTokenManager {
    private string _defaultSessionKeyAlgorithm;
    public string DefaultSessionKeyAlgorithm { get; public set; }
    public string TokenType { get; }
    public X509SecurityTokenManager(XmlNodeList configData);
    private void SetPlatformDependentDefault();
    public virtual string get_DefaultSessionKeyAlgorithm();
    public virtual void set_DefaultSessionKeyAlgorithm(string value);
    public virtual string get_TokenType();
    protected virtual void AuthenticateToken(X509SecurityToken token);
    private X509SecurityToken GetKeyInfoName(KeyInfoName keyInfoName);
    private X509SecurityToken GetSecurityTokenReference(SecurityTokenReference str);
    public virtual SecurityToken LoadTokenFromKeyInfo(KeyInfo keyInfo);
    public virtual SecurityToken LoadTokenFromXml(XmlElement element);
    public virtual void VerifyToken(SecurityToken token);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Security.TransformChain : object {
    private ArrayList m_transforms;
    public int Count { get; }
    public Transform Item { get; }
    internal bool CanTransformAndHash { get; }
    public void Add(Transform transform);
    public IEnumerator GetEnumerator();
    public int get_Count();
    public Transform get_Item(int index);
    internal bool TransformAcceptsType(Transform transform, Type inputType);
    internal bool get_CanTransformAndHash();
    internal Byte[] TransformAndHash(object inputObject, HashAlgorithm algorithm);
    private object RunTransformChain(object inputObject, ArrayList chain);
    internal Stream TransformToOctetStream(object inputObject);
}
public class Microsoft.Web.Services3.Security.TrustFault : WseSoapHeaderException {
    public static string BadRequestMessage;
    public static string InvalidRequestMessage;
    public static string FailedAuthenticationMessage;
    public static string RequestFailedMessage;
    public static XmlQualifiedName BadRequestCode;
    public static XmlQualifiedName InvalidRequestCode;
    public static XmlQualifiedName FailedAuthenticationCode;
    public static XmlQualifiedName RequestFailedCode;
    public TrustFault(string message, XmlQualifiedName code);
    public TrustFault(string message, XmlQualifiedName code, Exception ex);
    private static TrustFault();
}
public class Microsoft.Web.Services3.Security.TrustFormatException : WseSoapHeaderException {
    public TrustFormatException(string message);
    public TrustFormatException(string message, Exception ex);
}
internal class Microsoft.Web.Services3.Security.UnattachedTokens : object {
    private IssuedTokenCache tokens;
    public IssuedTokenCache Tokens { get; }
    public UnattachedTokens(IEnumerable`1<SecurityToken> tokens);
    public IssuedTokenCache get_Tokens();
}
public class Microsoft.Web.Services3.Security.Utility.Created : OpenAttributeDateTimeElement {
    public Created(DateTime created);
    public Created(XmlElement element);
    public virtual XmlElement GetXml(XmlDocument document);
    public bool IsPostDated();
    public virtual void LoadXml(XmlElement element);
}
public class Microsoft.Web.Services3.Security.Utility.Expires : OpenAttributeDateTimeElement {
    public Expires(DateTime created, long ttlInSeconds);
    public Expires(DateTime expires);
    public Expires(XmlElement element);
    public virtual XmlElement GetXml(XmlDocument document);
    public bool IsExpired();
    public virtual void LoadXml(XmlElement element);
}
public class Microsoft.Web.Services3.Security.Utility.Timestamp : object {
    private XmlElement _targetElement;
    private Created _created;
    private Expires _expires;
    private long _ttlInSeconds;
    private string _id;
    private AttributeList _anyAttribute;
    private ElementList _anyElement;
    public AttributeList AnyAttributes { get; }
    public ElementList AnyElements { get; }
    public DateTime Created { get; }
    public DateTime Expires { get; }
    public long TtlInSeconds { get; public set; }
    public string Id { get; public set; }
    public XmlElement TargetElement { get; }
    public Timestamp(XmlElement element);
    public AttributeList get_AnyAttributes();
    public ElementList get_AnyElements();
    public Timestamp Clone();
    public DateTime get_Created();
    public DateTime get_Expires();
    public long get_TtlInSeconds();
    public void set_TtlInSeconds(long value);
    public void CheckValid();
    public sealed virtual XmlElement GetXml(XmlDocument document);
    public string get_Id();
    public void set_Id(string value);
    public sealed virtual void LoadXml(XmlElement element);
    public XmlElement get_TargetElement();
}
internal class Microsoft.Web.Services3.Security.Utility.TimestampFault : WseSoapHeaderException {
    public static string MessageExpiredMessage;
    public static XmlQualifiedName MessageExpiredCode;
    public TimestampFault(string message, XmlQualifiedName code);
    public TimestampFault(string message, XmlQualifiedName code, Exception ex);
    private static TimestampFault();
}
public class Microsoft.Web.Services3.Security.Utility.TimestampFormatException : WseSoapHeaderException {
    public static string BadCreatedElement;
    public static string BadExpiresElement;
    public TimestampFormatException(string message);
    public TimestampFormatException(string message, Exception ex);
    private static TimestampFormatException();
}
public static class Microsoft.Web.Services3.Security.Utility.WSUtility : object {
    public static string NamespaceURI;
    public static string Prefix;
    public static string TimeFormat;
}
internal class Microsoft.Web.Services3.Security.Wse2PipelinePolicy : Policy {
}
public static class Microsoft.Web.Services3.Security.WSSecureConversation : object {
    public static string NamespaceURI;
    public static string Prefix;
    public static string DefaultLabel;
}
public static class Microsoft.Web.Services3.Security.WSSecurity : object {
    public static string NamespaceURI;
    public static string Prefix;
    public static string SpecLocation;
}
public static class Microsoft.Web.Services3.Security.WSSecurity11 : object {
    public static string NamespaceURI;
    public static string Prefix;
    public static string SpecLocation;
}
public static class Microsoft.Web.Services3.Security.WSTrust : object {
    public static string NamespaceURI;
    public static string Prefix;
}
public enum Microsoft.Web.Services3.Security.X509.X509CertificateSkiMode : Enum {
    public int value__;
    public static X509CertificateSkiMode RFC3280;
    public static X509CertificateSkiMode CAPI;
    public static X509CertificateSkiMode ThumbprintSHA1;
    public static X509CertificateSkiMode IssuerSerial;
}
public static class Microsoft.Web.Services3.Security.X509.X509Util : object {
    public static string SubjectKeyIdentifierOID;
    public static string KeyUsageOID;
    private static XmlDocument doc;
    private static List`1<Byte[]> powersOfTwo;
    private static Char[] digitMap;
    private static X509Util();
    public static KeyInfo CreateIssuerSerialReference(X509Certificate2 certificate);
    internal static bool IsIssuerSerialReference(KeyInfo keyInfo);
    public static Byte[] GetKeyIdentifier(X509Certificate2 certificate);
    public static KeyIdentifier GetKeyIdentifier(X509Certificate2 certificate, X509CertificateSkiMode skiMode);
    public static Byte[] GetKeyIdentifierFromExtension(X509Certificate2 certificate);
    public static Byte[] GetKeyIdentifierFromCAPI(X509Certificate2 certificate);
    public static Byte[] GetKeyIdentifierFromPublicKey(X509Certificate2 certificate);
    public static Byte[] GetKeyIdentifierFromRawData(X509Certificate certificate);
    public static RSA GetKey(X509Certificate2 certificate);
    public static X509KeyUsageExtension GetKeyUsageExtension(X509Certificate2 certificate);
    public static bool IsCurrent(X509Certificate2 certificate);
    public static X509Certificate2Collection FindCertificateByKeyIdentifier(Byte[] keyIdentifier, StoreLocation storeLocation, string storeName);
    public static X509Certificate2Collection FindCertificateBySubjectName(string subjectName, StoreLocation storeLocation, string storeName);
    public static bool SupportsDigitalSignature(X509Certificate2 certificate);
    public static bool SupportsDataEncryption(X509Certificate2 certificate);
    public static bool SupportsKeyEncipherment(X509Certificate2 certificate);
    private static RSA AcquirePrivateKey(X509Certificate2 certificate);
    private static Byte[] ASNDecode(Byte[] id);
    internal static string DecimalSignedIntegerToHexUnsignedInteger(string decimalInt);
    private static bool ModuloTwo(List`1<byte> decimalDigits, Byte& modulo);
    internal static string Asn1IntegerToDecimalString(Byte[] asn1);
    private static Byte[] TwoToThePowerOf(int n);
    private static void AddSecondDecimalToFirst(List`1<byte> first, Byte[] second);
    private static void SubtractSecondDecimalFromFirst(List`1<byte> first, List`1<byte> second);
}
internal class Microsoft.Web.Services3.Security.Xml.C14nUtil : object {
    public static string NamespaceUrlForXmlPrefix;
    public static bool IsDefaultNamespaceNode(XmlAttribute a);
    public static bool IsEmptyDefaultNamespaceNode(XmlAttribute a);
    public static bool IsEmptyDefaultNamespaceDeclaration(string prefix, string value);
    public static bool IsNamespaceNode(XmlAttribute a, String& prefix, String& value);
    public static bool IsNamespaceNode(string prefix, string localName, String& nsPrefix);
    public static bool IsXmlPrefixDeclaration(string prefix, string value);
    public static String[] TokenizeString(string s);
}
internal class Microsoft.Web.Services3.Security.Xml.CanonicalAttributeManager : object {
    private static int InitialListSize;
    private static int MaxPoolSize;
    private AttributeEntry[] list;
    private int count;
    private Pool`1<AttributeEntry> pool;
    public int Count { get; }
    public int get_Count();
    public void Add(XmlAttribute a);
    public void Add(string prefix, string localName, string namespaceUri, string value);
    public void Clear();
    public void Encode(CanonicalEncoder encoder);
    public string FindAttributeValue(string name, string namespaceUri);
    public string GetPrefix(int index);
    public void Sort();
}
internal abstract class Microsoft.Web.Services3.Security.Xml.CanonicalEncoder : object {
    public static char Char10;
    public static char Char13;
    public static char Char9;
    public static char Char32;
    private static int charBufSize;
    private static int byteBufSize;
    private static UTF8Encoding Utf8WithoutPreamble;
    private Encoder _encoder;
    private Byte[] _byteBuf;
    private Char[] _charBuf;
    private int _count;
    private static CanonicalEncoder();
    public void Encode(char c);
    public void Encode(string str);
    public void Encode(Char[] buffer, int offset, int count);
    public void EncodeComment(string value, XmlDocumentPosition docPosition);
    public void EncodeProcessingInstruction(string name, string text, XmlDocumentPosition docPosition);
    public void EncodeWithLineBreakNormalization(string str);
    public void EncodeWithTranslation(Char[] buffer, int offset, int count, XmlStringType valueType);
    public void EncodeWithTranslation(string str, XmlStringType valueType);
    private void EncodeWithTranslation(Char* start, Char* end, XmlStringType valueType);
    public void Flush();
    protected virtual void ResetCore();
    private void WriteBuffer(bool flush);
    protected abstract virtual void WriteBufferCore(Byte[] buffer, int offset, int count, bool flush);
}
internal class Microsoft.Web.Services3.Security.Xml.CanonicalHashEncoder : CanonicalEncoder {
    private HashAlgorithm hash;
    private bool transformFinalBlockOnFlush;
    private bool needsHashReset;
    public HashAlgorithm HashAlgorithm { get; public set; }
    public CanonicalHashEncoder(HashAlgorithm hash);
    public CanonicalHashEncoder(HashAlgorithm hash, bool transformFinalBlockOnFlush);
    public HashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(HashAlgorithm value);
    protected virtual void ResetCore();
    protected virtual void WriteBufferCore(Byte[] buffer, int offset, int count, bool flush);
}
internal class Microsoft.Web.Services3.Security.Xml.CanonicalizationDriver : object {
    private bool closeReadersAfterProcessing;
    private XmlDocument documentRoot;
    private NodeSet nodeSet;
    private XmlReader _reader;
    private XmlElement targetElement;
    private bool isNodeListInput;
    private string inclusiveNamespacesPrefixList;
    private bool includeComments;
    private bool isFullDocument;
    private ExclusiveCanonicalNamespaceManager namespaceManager;
    private CanonicalAttributeManager attributeManager;
    public bool CloseReadersAfterProcessing { get; public set; }
    public bool IncludeComments { get; public set; }
    public string InclusiveNamespacesPrefixList { get; public set; }
    public bool IsFullDocument { get; public set; }
    public bool get_CloseReadersAfterProcessing();
    public void set_CloseReadersAfterProcessing(bool value);
    public bool get_IncludeComments();
    public void set_IncludeComments(bool value);
    public string get_InclusiveNamespacesPrefixList();
    public void set_InclusiveNamespacesPrefixList(string value);
    public bool get_IsFullDocument();
    public void set_IsFullDocument(bool value);
    public void Reset();
    public void SetInput(Stream stream);
    public void SetInput(XmlReader reader);
    public void SetInput(XmlDocument document);
    public void SetInput(XmlNodeList nodeList);
    public void SetInput(XmlElement element);
    public Byte[] GetBytes();
    public MemoryStream GetMemoryStream();
    public void WriteTo(Stream stream);
    public void WriteTo(HashAlgorithm hashAlgorithm);
    public void WriteTo(CanonicalEncoder encoder);
}
internal class Microsoft.Web.Services3.Security.Xml.CanonicalStreamEncoder : CanonicalEncoder {
    private Stream stream;
    internal Stream Stream { get; }
    public CanonicalStreamEncoder(Stream stream);
    protected virtual void WriteBufferCore(Byte[] buffer, int offset, int count, bool flush);
    internal Stream get_Stream();
}
internal class Microsoft.Web.Services3.Security.Xml.CanonicalXmlNodeList : XmlNodeList {
    private ArrayList nodeArray;
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public virtual XmlNode Item(int index);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    public sealed virtual int Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
}
internal class Microsoft.Web.Services3.Security.Xml.CryptoHelper : object {
    internal static void ValidateBufferBounds(Char[] buffer, int offset, int count);
}
internal class Microsoft.Web.Services3.Security.Xml.DocumentCanonicalizationDispatcher : object {
    private ExclusiveCanonicalNamespaceManager manager;
    private XmlDocumentPosition docPos;
    private CanonicalEncoder encoder;
    private NodeSet nodeSet;
    private int renderedDepth;
    private CanonicalAttributeManager attributesToRender;
    private String[] inclusivePrefixes;
    private bool isNodeListInput;
    private XmlNode currentNode;
    public string CurrentNodeName { get; }
    public DocumentCanonicalizationDispatcher(CanonicalEncoder encoder, ExclusiveCanonicalNamespaceManager namespaceManager, CanonicalAttributeManager attributeManager, string inclusiveNamespacesPrefixList, NodeSet nodeSet, bool isNodeListInput);
    public sealed virtual string get_CurrentNodeName();
    public sealed virtual string LookupNamespace(string prefix);
    public void Start(XmlNode node);
    private void Write(XmlNode node);
    private void WriteCData(XmlCDataSection node);
    private void WriteComment(XmlComment node);
    private void WriteDocument(XmlDocument node);
    private void WriteElement(XmlElement node);
    private void WriteEntityReference(XmlEntityReference node);
    private void WriteGeneric(XmlNode node);
    private void WriteProcessingInstruction(XmlProcessingInstruction node);
    private void WriteSignificantWhitespace(XmlSignificantWhitespace node);
    private void WriteText(XmlText node);
    private void WriteWhitespace(XmlWhitespace node);
}
internal class Microsoft.Web.Services3.Security.Xml.ElementCanonicalizationDispatcher : object {
    private ExclusiveCanonicalNamespaceManager manager;
    private XmlDocumentPosition docPos;
    private CanonicalEncoder encoder;
    private int renderedDepth;
    private CanonicalAttributeManager attributesToRender;
    private String[] inclusivePrefixes;
    private XmlNode currentNode;
    private bool includeComments;
    public string CurrentNodeName { get; }
    public ElementCanonicalizationDispatcher(CanonicalEncoder encoder, ExclusiveCanonicalNamespaceManager namespaceManager, CanonicalAttributeManager attributeManager, string inclusiveNamespacesPrefixList, bool includeComments);
    public sealed virtual string get_CurrentNodeName();
    public sealed virtual string LookupNamespace(string prefix);
    public void Start(XmlNode node);
    private void Write(XmlNode node);
    private void WriteCData(XmlCDataSection node);
    private void WriteComment(XmlComment node);
    private void WriteDocument(XmlDocument node);
    private void WriteElement(XmlElement node);
    private void WriteEntityReference(XmlEntityReference node);
    private void WriteGeneric(XmlNode node);
    private void WriteProcessingInstruction(XmlProcessingInstruction node);
    private void WriteSignificantWhitespace(XmlSignificantWhitespace node);
    private void WriteText(XmlText node);
    private void WriteWhitespace(XmlWhitespace node);
}
internal class Microsoft.Web.Services3.Security.Xml.ExclusiveCanonicalNamespaceManager : object {
    private static int MaxPoolSize;
    private List`1<NamespaceEntry> localNamespacesToRender;
    private List`1<NamespaceEntry> namespaceContext;
    private Pool`1<NamespaceEntry> pool;
    public void AddLocalNamespaceIfNotRedundant(string prefix, string namespaceUri);
    private NamespaceEntry CloneNamespaceEntryToRender(NamespaceEntry ne);
    private NamespaceEntry CreateNamespaceEntry(string prefix, string namespaceUri);
    private NamespaceEntry CreateNamespaceEntry(string prefix, string namespaceUri, bool render);
    public void EnterElementContext();
    public void ExitElementContext();
    private bool IsNonRedundantNamespaceDeclaration(string prefix, string namespaceUri);
    public string LookupNamespace(string prefix);
    public string LookupPrefix(string ne, bool isForAttribute);
    public void MarkToRenderForInclusivePrefix(string prefix, bool searchOuterContext, IAncestralNamespaceContextProvider context);
    public void MarkToRenderForVisiblyUsedPrefix(string prefix, bool searchOuterContext, IAncestralNamespaceContextProvider context);
    private bool MarkToRender(string prefix, bool searchOuterContext, IAncestralNamespaceContextProvider context, bool isInclusivePrefix);
    public void Render(CanonicalEncoder encoder);
    public void Reset();
}
internal interface Microsoft.Web.Services3.Security.Xml.IAncestralNamespaceContextProvider {
    public string CurrentNodeName { get; }
    public abstract virtual string get_CurrentNodeName();
    public abstract virtual string LookupNamespace(string prefix);
}
internal class Microsoft.Web.Services3.Security.Xml.NodeSet : object {
    private XmlDocument root;
    private Hashtable set;
    private NodeSetComposition setType;
    public XmlDocument Root { get; }
    public NodeSet(bool includeComments);
    public NodeSet(bool includeComments, XmlNodeList nodeList);
    public XmlDocument get_Root();
    public bool Contains(XmlNode node);
}
internal class Microsoft.Web.Services3.Security.Xml.ReaderCanonicalizationDispatcher : object {
    private ExclusiveCanonicalNamespaceManager manager;
    private XmlDocumentPosition docPos;
    private CanonicalEncoder encoder;
    private int renderedDepth;
    private CanonicalAttributeManager attributesToRender;
    private String[] inclusivePrefixes;
    private bool includeComments;
    private bool isFullDocument;
    private XmlReader _reader;
    public string CurrentNodeName { get; }
    public ReaderCanonicalizationDispatcher(CanonicalEncoder encoder, ExclusiveCanonicalNamespaceManager namespaceManager, CanonicalAttributeManager attributeManager, string inclusiveNamespacesPrefixList, bool includeComments, bool isFullDocument);
    public sealed virtual string get_CurrentNodeName();
    public sealed virtual string LookupNamespace(string prefix);
    public void Start(XmlReader reader);
    private void Write();
    private void WriteCData();
    private void WriteComment();
    private void WriteElement();
    private void WriteProcessingInstruction();
    private void WriteSignificantWhitespace();
    private void WriteText();
    private void WriteWhitespace();
}
public class Microsoft.Web.Services3.Security.Xml.SecurityTokenReferenceTransform : Transform {
    public static string SecurityTokenReferenceTransformUrl;
    private static Type[] _inputTypes;
    private static Type[] _outputTypes;
    private CanonicalizationMethod _canonicalizationMethod;
    private Transform _transform;
    public Type[] InputTypes { get; }
    public Type[] OutputTypes { get; }
    public SecurityTokenReferenceTransform(string canonicalizationMethod);
    public SecurityTokenReferenceTransform(string canonicalizationMethod, string prefixList);
    private static SecurityTokenReferenceTransform();
    public virtual Type[] get_InputTypes();
    public virtual Type[] get_OutputTypes();
    public virtual void LoadInnerXml(XmlNodeList nodeList);
    private XmlNode ReplaceReferencedToken(XmlElement node);
    public virtual void LoadInput(object obj);
    protected virtual XmlNodeList GetInnerXml();
    public virtual object GetOutput();
    public virtual object GetOutput(Type type);
}
internal enum Microsoft.Web.Services3.Security.Xml.XmlDocumentPosition : Enum {
    public int value__;
    public static XmlDocumentPosition BeforeRootElement;
    public static XmlDocumentPosition InRootElement;
    public static XmlDocumentPosition AfterRootElement;
}
public class Microsoft.Web.Services3.Security.Xml.XmlDsigEnvelopedSignatureTransform : Transform {
    private Type[] _inputTypes;
    private Type[] _outputTypes;
    private XmlNodeList _inputNodeList;
    private bool _includeComments;
    private XmlNamespaceManager _nsm;
    private XmlDocument _containingDocument;
    private int _signaturePosition;
    unknown int SignaturePosition {internal set; }
    public Type[] InputTypes { get; }
    public Type[] OutputTypes { get; }
    public XmlDsigEnvelopedSignatureTransform(bool includeComments);
    internal void set_SignaturePosition(int value);
    public XmlNodeList AllDescendantNodes(XmlNode node, bool includeComments);
    public virtual Type[] get_InputTypes();
    public virtual Type[] get_OutputTypes();
    public virtual void LoadInnerXml(XmlNodeList nodeList);
    protected virtual XmlNodeList GetInnerXml();
    public virtual void LoadInput(object obj);
    private void LoadStreamInput(Stream stream);
    private void LoadXmlNodeListInput(XmlNodeList nodeList);
    private void LoadXmlDocumentInput(XmlDocument doc);
    public virtual object GetOutput();
    public virtual object GetOutput(Type type);
}
public class Microsoft.Web.Services3.Security.Xml.XmlDsigExcC14NTransform : Transform {
    private static Type[] inputTypes;
    private static Type[] outputTypes;
    private bool includeComments;
    private string inclusiveNamespacesPrefixList;
    private CanonicalizationDriver driver;
    public string InclusiveNamespacesPrefixList { get; public set; }
    public Type[] InputTypes { get; }
    public Type[] OutputTypes { get; }
    public XmlDsigExcC14NTransform(bool includeComments);
    public XmlDsigExcC14NTransform(string inclusiveNamespacesPrefixList);
    public XmlDsigExcC14NTransform(bool includeComments, string inclusiveNamespacesPrefixList);
    private static XmlDsigExcC14NTransform();
    public string get_InclusiveNamespacesPrefixList();
    public void set_InclusiveNamespacesPrefixList(string value);
    public virtual Type[] get_InputTypes();
    public virtual Type[] get_OutputTypes();
    public virtual void LoadInnerXml(XmlNodeList nodeList);
    private CanonicalizationDriver GetConfiguredDriver();
    public virtual void LoadInput(object obj);
    protected virtual XmlNodeList GetInnerXml();
    public virtual object GetOutput();
    public virtual object GetOutput(Type type);
    public void GetHashedOutput(HashAlgorithm hash);
}
public class Microsoft.Web.Services3.Security.Xml.XmlDsigExcC14NWithCommentsTransform : XmlDsigExcC14NTransform {
    public XmlDsigExcC14NWithCommentsTransform(string inclusiveNamespacesPrefixList);
}
public class Microsoft.Web.Services3.Security.Xml.XmlDsigXPathTransform : Transform {
    private static Type[] inputTypes;
    private static Type[] outputTypes;
    private CanonicalXmlNodeList _output;
    private string _xpath;
    private XmlNamespaceManager _nsm;
    private XmlDocument _inputDocument;
    private XPathExpression _xpathExpr;
    public Type[] InputTypes { get; }
    protected XmlNamespaceManager Namespaces { get; protected set; }
    public Type[] OutputTypes { get; }
    protected string XPath { get; protected set; }
    public XmlDsigXPathTransform(string xpath, XmlNamespaceManager namespaces);
    private static XmlDsigXPathTransform();
    protected virtual XmlNodeList GetInnerXml();
    public virtual object GetOutput();
    public virtual object GetOutput(Type type);
    public virtual Type[] get_InputTypes();
    protected XmlNamespaceManager get_Namespaces();
    protected void set_Namespaces(XmlNamespaceManager value);
    public virtual Type[] get_OutputTypes();
    public virtual void LoadInnerXml(XmlNodeList nodeList);
    public virtual void LoadInput(object obj);
    protected string get_XPath();
    protected void set_XPath(string value);
}
public static class Microsoft.Web.Services3.Security.XmlEncryption : object {
    public static string NamespaceURI;
    public static string Prefix;
}
public static class Microsoft.Web.Services3.Security.XmlSignature : object {
    public static string NamespaceURI;
    public static string Prefix;
}
public static class Microsoft.Web.Services3.Security.XrML : object {
    public static string NamespaceURI;
    public static string Prefix;
}
public abstract class Microsoft.Web.Services3.Soap : object {
    public static string ServerUnavailable;
    public static string InvalidSoapMessage;
    public static string InvalidXmlMessage;
    public static string FramingContentType;
    public static string MethodPost;
    public string NamespaceURI { get; }
    public string EncodingStyle { get; }
    public string Prefix { get; }
    public string ActorNext { get; }
    public Uri ActorNextUri { get; }
    public string ContentType { get; }
    public string AttributeNameActor { get; }
    public XmlQualifiedName[] ExcludedAttributesList { get; }
    public SoapProtocolVersion SoapVersion { get; }
    public abstract virtual string get_NamespaceURI();
    public abstract virtual string get_EncodingStyle();
    public abstract virtual string get_Prefix();
    public abstract virtual string get_ActorNext();
    public abstract virtual Uri get_ActorNextUri();
    public abstract virtual string get_ContentType();
    public abstract virtual string get_AttributeNameActor();
    public abstract virtual XmlQualifiedName[] get_ExcludedAttributesList();
    public abstract virtual SoapProtocolVersion get_SoapVersion();
    public virtual XmlElement CreateBodyElement(XmlDocument document);
    public virtual XmlElement CreateEnvelopeElement(XmlDocument document);
    public virtual XmlElement CreateHeaderElement(XmlDocument document);
    public abstract virtual Exception FromFaultXml(XmlElement element);
    public abstract virtual XmlElement GetFaultXml(XmlDocument document, Exception ex, string actor);
    protected abstract virtual string GetEncodedStringFromBoolean(bool value);
    public virtual string GetActorAttribute(XmlElement element);
    public virtual bool GetMustUnderstand(XmlElement element);
    public virtual bool IsBodyElement(XmlElement element);
    public virtual bool IsEnvelopeElement(XmlElement element);
    public virtual bool IsFaultElement(XmlElement element);
    public virtual bool IsHeaderElement(XmlElement element);
    public virtual bool IsMustUnderstandAttribute(XmlAttribute attribute);
    public virtual bool IsActorNext(Uri actor);
    public virtual void SetActorAttribute(XmlDocument document, XmlElement element, string actor);
    public virtual void SetMustUnderstand(XmlDocument document, XmlElement element, bool mustUnderstand);
}
public class Microsoft.Web.Services3.Soap11 : Soap {
    private static string _prefix;
    private static string _actorNext;
    private static string _namespaceURI;
    private static string _encodingStyle;
    private static string _contentType;
    private static XmlQualifiedName[] _excludedAttributes;
    private static Uri _actorNextURI;
    public string NamespaceURI { get; }
    public string EncodingStyle { get; }
    public string Prefix { get; }
    public string ActorNext { get; }
    public Uri ActorNextUri { get; }
    public string ContentType { get; }
    public string AttributeNameActor { get; }
    public XmlQualifiedName[] ExcludedAttributesList { get; }
    public SoapProtocolVersion SoapVersion { get; }
    private static Soap11();
    public virtual string get_NamespaceURI();
    public virtual string get_EncodingStyle();
    public virtual string get_Prefix();
    public virtual string get_ActorNext();
    public virtual Uri get_ActorNextUri();
    public virtual string get_ContentType();
    public virtual string get_AttributeNameActor();
    public virtual XmlQualifiedName[] get_ExcludedAttributesList();
    public virtual Exception FromFaultXml(XmlElement element);
    protected virtual string GetEncodedStringFromBoolean(bool value);
    public virtual XmlElement GetFaultXml(XmlDocument document, Exception ex, string actor);
    public virtual SoapProtocolVersion get_SoapVersion();
}
public class Microsoft.Web.Services3.Soap11AttributeNames : object {
    public static string Actor;
}
public class Microsoft.Web.Services3.Soap11ElementNames : object {
    public static string FaultActor;
    public static string FaultCode;
    public static string FaultDetail;
    public static string FaultString;
}
public class Microsoft.Web.Services3.Soap12 : Soap {
    private static string _prefix;
    private static string _actorNext;
    private static string _namespaceURI;
    private static string _rpcNamespaceURI;
    private static string _encodingStyle;
    private static string _mediaType;
    private static string _langAttributeNamespace;
    private static string _xml;
    private static string _en;
    private static XmlQualifiedName[] _excludedAttributes;
    private static Uri _actorNextURI;
    public string NamespaceURI { get; }
    public string RpcNamespaceURI { get; }
    public string EncodingStyle { get; }
    public string Prefix { get; }
    public string ActorNext { get; }
    public Uri ActorNextUri { get; }
    public string ContentType { get; }
    public XmlQualifiedName[] ExcludedAttributesList { get; }
    public string AttributeNameActor { get; }
    public SoapProtocolVersion SoapVersion { get; }
    private static Soap12();
    public virtual string get_NamespaceURI();
    public string get_RpcNamespaceURI();
    public virtual string get_EncodingStyle();
    public virtual string get_Prefix();
    public virtual string get_ActorNext();
    public virtual Uri get_ActorNextUri();
    public virtual string get_ContentType();
    public virtual XmlQualifiedName[] get_ExcludedAttributesList();
    public virtual string get_AttributeNameActor();
    public virtual Exception FromFaultXml(XmlElement element);
    protected virtual string GetEncodedStringFromBoolean(bool value);
    public virtual XmlElement GetFaultXml(XmlDocument document, Exception ex, string actor);
    private XmlElement GetSubCodeElement(XmlDocument document, SoapFaultSubCode subCode);
    public bool GetRelay(XmlElement element);
    private XmlQualifiedName ConvertToSoap12Code(XmlQualifiedName faultCode);
    public void SetRelay(XmlDocument document, XmlElement element, bool relay);
    public virtual SoapProtocolVersion get_SoapVersion();
}
public class Microsoft.Web.Services3.Soap12AttributeNames : object {
    public static string Relay;
    public static string Lang;
    public static string Role;
}
public class Microsoft.Web.Services3.Soap12ElementNames : object {
    public static string Role;
    public static string Code;
    public static string Node;
    public static string Detail;
    public static string Reason;
    public static string Value;
    public static string Subcode;
    public static string Text;
}
public class Microsoft.Web.Services3.SoapAttributeNames : object {
    public static string MustUnderstand;
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.SoapContext : object {
    [ThreadStaticAttribute]
private static SoapContext _current;
    private static Uri _fallbackActor;
    private CredentialContext credentials;
    private Uri _actor;
    private ISoapChannel _channel;
    private string _contentType;
    private SoapEnvelope _envelope;
    private bool _isInbound;
    private bool _isIntermediary;
    private bool _isOneWay;
    private bool _isRequest;
    private Hashtable _objects;
    private bool _processed;
    private ReferralCollection _referrals;
    private Security _security;
    private WebRequest _webRequest;
    private AddressingHeaders _addressing;
    private MessagePartHeaders _headers;
    private object _identityToken;
    private StateManager messageState;
    private StateManager operationState;
    private StateManager sessionState;
    private Collection`1<XmlElement> traceEntries;
    public static SoapContext Current { get; public set; }
    public CredentialContext Credentials { get; }
    internal static Uri FallbackActor { get; }
    public object Item { get; public set; }
    internal Collection`1<XmlElement> TraceEntries { get; }
    public Uri Actor { get; }
    public AddressingHeaders Addressing { get; public set; }
    public ISoapChannel Channel { get; public set; }
    public string ContentType { get; }
    public SoapEnvelope Envelope { get; public set; }
    public SecurityToken IdentityToken { get; public set; }
    public bool IsInbound { get; }
    internal bool IsIntermediary { get; internal set; }
    public bool IsOneWay { get; public set; }
    public bool IsRequest { get; public set; }
    private Hashtable Objects { get; }
    internal MessagePartHeaders PreProcessedHeaderNames { get; }
    public bool Processed { get; }
    public ReferralCollection Referrals { get; }
    [ObsoleteAttribute("SoapContext.Security is obsolete. Consider deriving from SendSecurityFilter or ReceiveSecurityFilter and creating a custom policy assertion that generates these filters.")]
public Security Security { get; internal set; }
    public WebRequest WebRequest { get; public set; }
    public StateManager MessageState { get; public set; }
    public StateManager OperationState { get; public set; }
    public StateManager SessionState { get; public set; }
    private static SoapContext();
    internal SoapContext(SoapEnvelope envelope);
    public static SoapContext get_Current();
    public static void set_Current(SoapContext value);
    public CredentialContext get_Credentials();
    internal static Uri get_FallbackActor();
    public object get_Item(string key);
    public void set_Item(string key, object value);
    internal Collection`1<XmlElement> get_TraceEntries();
    public Uri get_Actor();
    internal void SetActor(Uri actor);
    public AddressingHeaders get_Addressing();
    public void set_Addressing(AddressingHeaders value);
    public void Add(string key, object value);
    public ISoapChannel get_Channel();
    public void set_Channel(ISoapChannel value);
    public void Clear();
    public void CopyTo(SoapContext context);
    public bool Contains(string key);
    public string get_ContentType();
    internal void SetContentType(string contentType);
    public SoapEnvelope get_Envelope();
    public void set_Envelope(SoapEnvelope value);
    internal void SetEnvelope(SoapEnvelope envelope);
    public IDictionaryEnumerator GetEnumerator();
    internal void CopyStateTo(SoapContext other);
    public SecurityToken get_IdentityToken();
    public void set_IdentityToken(SecurityToken value);
    public bool get_IsInbound();
    internal void SetIsInbound(bool isInbound);
    internal bool get_IsIntermediary();
    internal void set_IsIntermediary(bool value);
    public bool get_IsOneWay();
    public void set_IsOneWay(bool value);
    public bool get_IsRequest();
    public void set_IsRequest(bool value);
    private Hashtable get_Objects();
    internal MessagePartHeaders get_PreProcessedHeaderNames();
    internal void PreProcessHeaders(SoapEnvelope envelope);
    public bool get_Processed();
    internal void SetProcessed(bool processed);
    public ReferralCollection get_Referrals();
    public void Remove(string key);
    public Security get_Security();
    internal void set_Security(Security value);
    public WebRequest get_WebRequest();
    public void set_WebRequest(WebRequest value);
    public StateManager get_MessageState();
    public void set_MessageState(StateManager value);
    public StateManager get_OperationState();
    public void set_OperationState(StateManager value);
    public StateManager get_SessionState();
    public void set_SessionState(StateManager value);
}
public class Microsoft.Web.Services3.SoapElementNames : object {
    public static string Envelope;
    public static string Header;
    public static string Body;
    public static string Fault;
    public static string StackTrace;
    public static string Message;
}
public class Microsoft.Web.Services3.SoapEnvelope : XopDocument {
    private static string DefaultBodyNamespace;
    private Exception _ex;
    private XmlElement _body;
    private XmlElement _header;
    private bool _postLoad;
    private bool _processed;
    private SoapContext _context;
    private Exception _faultException;
    private SoapProtocolVersion _soapVersion;
    private Soap _soap;
    public XmlElement Body { get; }
    public SoapContext Context { get; public set; }
    public XmlElement Envelope { get; }
    public Exception Fault { get; public set; }
    internal Exception FaultInternal { get; }
    public XmlElement Header { get; }
    public bool Processed { get; }
    public SoapProtocolVersion SoapVersion { get; }
    public Soap CurrentSoap { get; }
    public SoapEnvelope(SoapProtocolVersion soapVersion);
    internal SoapEnvelope(SoapProtocolVersion soapVersion, SoapContext context);
    internal SoapEnvelope(SoapProtocolVersion soapVersion, SoapContext context, bool bare);
    internal SoapEnvelope(Exception ex, Uri actor);
    internal SoapEnvelope(Exception ex, Uri actor, SoapProtocolVersion soapVersion);
    public XmlElement get_Body();
    public SoapContext get_Context();
    public void set_Context(SoapContext value);
    internal void SetContext(SoapContext context);
    public XmlElement CreateBody();
    public XmlElement CreateHeader();
    public XmlElement get_Envelope();
    public Exception get_Fault();
    public void set_Fault(Exception value);
    internal Exception get_FaultInternal();
    public object GetBodyObject(Type bodyType);
    public object GetBodyObject(Type bodyType, string defaultNamespace);
    public XmlReader GetBodyReader();
    public XmlWriter GetBodyWriter();
    public XmlReader GetHeaderReader();
    public XmlWriter GetHeaderWriter();
    public XmlElement get_Header();
    public virtual void Load(Stream inStream);
    public virtual void Load(string filename);
    public virtual void Load(TextReader txtReader);
    public virtual void Load(XmlReader reader);
    public virtual void PostLoad();
    internal virtual void PostLoad(bool loadAddressing);
    public bool get_Processed();
    public void RemoveHeader();
    internal void SetHeader(XmlElement element);
    internal void SetProcessed(bool processed);
    internal void SetSoapVersion(SoapProtocolVersion soapVersion);
    public virtual void Save(Stream outStream);
    public virtual void Save(string filename);
    public void SetBodyObject(object body);
    public void SetBodyObject(object body, string defaultNamespace);
    public SoapProtocolVersion get_SoapVersion();
    public Soap get_CurrentSoap();
}
public abstract class Microsoft.Web.Services3.SoapFilter : object {
    private static XmlDocument doc;
    private static SoapFilter();
    public virtual T GetBehavior();
    public abstract virtual SoapFilterResult ProcessMessage(SoapEnvelope envelope);
    internal static XmlElement CreateTraceEntry(Type processor, string description, XmlNode content);
    private void TraceEntry(XmlElement entry);
    protected internal void Trace(string description);
    protected internal void Trace(XmlElement content);
    protected internal void Trace(string description, XmlElement content);
}
public class Microsoft.Web.Services3.SoapFilterResult : object {
    private bool stop;
    private SoapServerMethod targetMethod;
    private static SoapFilterResult terminateProcessing;
    private static SoapFilterResult continueProcessing;
    public static SoapFilterResult Terminate { get; }
    public static SoapFilterResult Continue { get; }
    public bool Stop { get; }
    public SoapServerMethod TargetMethod { get; }
    private SoapFilterResult(bool stop);
    public SoapFilterResult(SoapServerMethod targetMethod);
    public static SoapFilterResult get_Terminate();
    public static SoapFilterResult get_Continue();
    public bool get_Stop();
    public SoapServerMethod get_TargetMethod();
}
public class Microsoft.Web.Services3.SoapFormatException : WseSoapHeaderException {
    public SoapFormatException(string message);
}
public class Microsoft.Web.Services3.SoapHelper : object {
    private static Soap11 _soap11;
    private static Soap12 _soap12;
    public static Soap DefaultSoap { get; }
    public static Soap11 Soap11 { get; }
    public static Soap12 Soap12 { get; }
    private static SoapHelper();
    public static Soap get_DefaultSoap();
    public static Soap11 get_Soap11();
    public static Soap12 get_Soap12();
    public static string GetActorAttribute(XmlElement element);
    public static string GetAction(AddressingHeaders addressing);
    public static string GetAction(SoapMessage message);
    public static string GetAction(HttpContext httpContext);
    public static string GetActorNext(XmlDocument document);
    public static string GetContentType(SoapProtocolVersion soapVersion);
    public static bool GetMustUnderstand(XmlElement element);
    public static string GetEncodedStringFromBoolean(bool value);
    public static bool GetBooleanFromEncodedString(string value);
    public static bool GetRelay(XmlElement element);
    public static Soap GetSoap(string namespaceURI);
    private static Soap GetSoap(XmlElement element);
    private static Soap GetSoap(XmlDocument document);
    public static bool IsSoapNamespace(string namespaceUri);
    public static bool IsSoapContentType(string contentType);
    public static bool IsSoap11ContentType(string contentType);
    public static bool IsSoap12ContentType(string contentType);
    public static bool IsActorNext(Uri actor);
    public static bool IsActorNext(XmlElement element, Uri actor);
    public static bool IsBodyElement(XmlNode element);
    public static bool IsEnvelopeElement(XmlNode element);
    public static bool IsHeaderElement(XmlNode element);
    public static bool IsFaultElement(XmlElement element);
    public static bool IsMustUnderstandAttribute(XmlAttribute attribute);
    public static bool Matches(SoapProtocolVersion soapVersion1, SoapProtocolVersion soapVersion2);
    public static void SetAction(WebRequest request, SoapEnvelope message);
    public static void SetActorAttribute(XmlDocument document, XmlElement element, string actor);
    public static void SetMustUnderstand(XmlDocument document, XmlElement element, bool mustUnderstand);
    public static void SetRelay(XmlDocument document, XmlElement element, bool relay);
    internal static string TryGetIdFromElement(XmlElement element);
}
internal abstract class Microsoft.Web.Services3.SoapInputFilter : object {
    protected virtual bool CanProcessHeader(XmlElement header, SoapContext context);
    public abstract virtual void ProcessMessage(SoapEnvelope envelope);
}
internal abstract class Microsoft.Web.Services3.SoapOutputFilter : object {
    public abstract virtual void ProcessMessage(SoapEnvelope envelope);
    protected void AddEnvelopeNamespaceDeclaration(SoapEnvelope envelope, string prefix, string namespaceUri);
}
internal class Microsoft.Web.Services3.SR : object {
    internal static string WSE001;
    internal static string WSE002;
    internal static string WSE003;
    internal static string WSE004;
    internal static string WSE005;
    internal static string WSE006;
    internal static string WSE007;
    internal static string WSE008;
    internal static string WSE009;
    internal static string WSE010;
    internal static string WSE011;
    internal static string WSE012;
    internal static string WSE013;
    internal static string WSE017;
    internal static string WSE018;
    internal static string WSE019;
    internal static string WSE020;
    internal static string WSE021;
    internal static string WSE022;
    internal static string WSE023;
    internal static string WSE024;
    internal static string WSE025;
    internal static string WSE027;
    internal static string WSE028;
    internal static string WSE029;
    internal static string WSE030;
    internal static string WSE031;
    internal static string WSE032;
    internal static string WSE033;
    internal static string WSE034;
    internal static string WSE035;
    internal static string WSE036;
    internal static string WSE037;
    internal static string WSE038;
    internal static string WSE039;
    internal static string WSE040;
    internal static string WSE041;
    internal static string WSE042;
    internal static string WSE043;
    internal static string WSE044;
    internal static string WSE045;
    internal static string WSE046;
    internal static string WSE047;
    internal static string WSE048;
    internal static string WSE049;
    internal static string WSE050;
    internal static string WSE051;
    internal static string WSE052;
    internal static string WSE053;
    internal static string WSE054;
    internal static string WSE060;
    internal static string WSE061;
    internal static string WSE062;
    internal static string WSE063;
    internal static string WSE064;
    internal static string WSE065;
    internal static string WSE066;
    internal static string unsafe_UnableToAcquireKerberosCredentialHandle;
    internal static string unsafe_UnableToAcquireKerbAuthPackage;
    internal static string unsafe_UnableToRetrieveKerbTicket;
    internal static string unsafe_UnableToValidateIncomingKerbST;
    internal static string unsafe_UnableToGetLogonSessionData;
    internal static string unsafe_UnableToAcquireKerberosPrincipalName;
    internal static string unsafe_UnableToFreeKerbCredHandle;
    internal static string unsafe_UnableToRetrieveProcessHandle;
    internal static string unsafe_UnableToLookupTCBPrivilege;
    internal static string unsafe_UnableToAdjustTokenPrivilege;
    internal static string unsafe_UnableToAdjustTokenPrivilegeNoErrorCode;
    internal static string unsafe_UnableToDeregisterLogonProcess;
    internal static string unsafe_UnableToLsaConnectUntrusted;
    internal static string WSE101;
    internal static string WSE102;
    internal static string WSE103;
    internal static string WSE104;
    internal static string WSE105;
    internal static string WSE201;
    internal static string WSE202;
    internal static string WSE203;
    internal static string WSE204;
    internal static string WSE205;
    internal static string WSE206;
    internal static string WSE207;
    internal static string WSE301;
    internal static string WSE302;
    internal static string WSE303;
    internal static string WSE304;
    internal static string WSE305;
    internal static string WSE306;
    internal static string WSE307;
    internal static string WSE308;
    internal static string WSE309;
    internal static string WSE310;
    internal static string WSE311;
    internal static string WSE312;
    internal static string WSE313;
    internal static string WSE314;
    internal static string WSE315;
    internal static string WSE316;
    internal static string WSE317;
    internal static string WSE318;
    internal static string WSE319;
    internal static string WSE320;
    internal static string WSE321;
    internal static string WSE322;
    internal static string WSE323;
    internal static string WSE324;
    internal static string WSE325;
    internal static string WSE326;
    internal static string WSE327;
    internal static string WSE328;
    internal static string WSE329;
    internal static string WSE330;
    internal static string WSE331;
    internal static string WSE332;
    internal static string WSE333;
    internal static string WSE334;
    internal static string WSE335;
    internal static string WSE336;
    internal static string WSE337;
    internal static string WSE338;
    internal static string WSE339;
    internal static string WSE340;
    internal static string WSE341;
    internal static string WSE342;
    internal static string WSE343;
    internal static string WSE344;
    internal static string WSE345;
    internal static string WSE346;
    internal static string WSE347;
    internal static string WSE348;
    internal static string WSE349;
    internal static string WSE350;
    internal static string WSE351;
    internal static string WSE352;
    internal static string WSE401;
    internal static string WSE402;
    internal static string WSE403;
    internal static string WSE404;
    internal static string WSE405;
    internal static string WSE406;
    internal static string WSE407;
    internal static string WSE408;
    internal static string WSE409;
    internal static string WSE410;
    internal static string WSE411;
    internal static string WSE412;
    internal static string WSE413;
    internal static string WSE414;
    internal static string WSE415;
    internal static string WSE416;
    internal static string WSE417;
    internal static string WSE418;
    internal static string WSE419;
    internal static string WSE420;
    internal static string WSE421;
    internal static string WSE422;
    internal static string WSE423;
    internal static string WSE424;
    internal static string WSE425;
    internal static string WSE426;
    internal static string WSE427;
    internal static string WSE428;
    internal static string WSE429;
    internal static string WSE430;
    internal static string WSE431;
    internal static string WSE432;
    internal static string WSE433;
    internal static string WSE434;
    internal static string WSE435;
    internal static string WSE436;
    internal static string WSE437;
    internal static string WSE438;
    internal static string WSE439;
    internal static string WSE440;
    internal static string WSE441;
    internal static string WSE442;
    internal static string WSE443;
    internal static string WSE444;
    internal static string WSE445;
    internal static string WSE446;
    internal static string WSE447;
    internal static string WSE448;
    internal static string WSE449;
    internal static string WSE450;
    internal static string WSE451;
    internal static string WSE452;
    internal static string WSE453;
    internal static string WSE454;
    internal static string WSE455;
    internal static string WSE456;
    internal static string WSE457;
    internal static string WSE458;
    internal static string WSE459;
    internal static string WSE460;
    internal static string WSE461;
    internal static string WSE462;
    internal static string WSE463;
    internal static string WSE464;
    internal static string WSE465;
    internal static string WSE466;
    internal static string WSE467;
    internal static string WSE468;
    internal static string WSE469;
    internal static string WSE470;
    internal static string WSE480;
    internal static string WSE481;
    internal static string WSE482;
    internal static string WSE501;
    internal static string WSE502;
    internal static string WSE503;
    internal static string WSE504;
    internal static string WSE505;
    internal static string WSE506;
    internal static string WSE507;
    internal static string WSE508;
    internal static string WSE509;
    internal static string WSE510;
    internal static string WSE511;
    internal static string WSE512;
    internal static string WSE513;
    internal static string WSE514;
    internal static string WSE520;
    internal static string WSE521;
    internal static string WSE522;
    internal static string WSE523;
    internal static string WSE524;
    internal static string WSE525;
    internal static string WSE526;
    internal static string WSE527;
    internal static string WSE528;
    internal static string WSE529;
    internal static string WSE530;
    internal static string WSE531;
    internal static string WSE532;
    internal static string WSE533;
    internal static string WSE534;
    internal static string WSE535;
    internal static string WSE536;
    internal static string WSE537;
    internal static string WSE538;
    internal static string WSE539;
    internal static string WSE540;
    internal static string WSE541;
    internal static string WSE542;
    internal static string WSE543;
    internal static string WSE544;
    internal static string WSE545;
    internal static string WSE546;
    internal static string WSE547;
    internal static string WSE548;
    internal static string WSE549;
    internal static string WSE550;
    internal static string WSE551;
    internal static string WSE552;
    internal static string WSE553;
    internal static string WSE554;
    internal static string WSE555;
    internal static string WSE556;
    internal static string WSE557;
    internal static string WSE558;
    internal static string WSE559;
    internal static string WSE560;
    internal static string WSE561;
    internal static string WSE562;
    internal static string WSE563;
    internal static string WSE564;
    internal static string WSE565;
    internal static string WSE566;
    internal static string WSE567;
    internal static string WSE568;
    internal static string WSE569;
    internal static string WSE570;
    internal static string WSE571;
    internal static string WSE572;
    internal static string WSE573;
    internal static string WSE574;
    internal static string WSE575;
    internal static string WSE576;
    internal static string WSE577;
    internal static string WSE578;
    internal static string WSE579;
    internal static string WSE580;
    internal static string WSE581;
    internal static string WSE582;
    internal static string WSE583;
    internal static string WSE584;
    internal static string WSE585;
    internal static string WSE586;
    internal static string WSE587;
    internal static string WSE588;
    internal static string WSE589;
    internal static string WSE590;
    internal static string WSE591;
    internal static string WSE592;
    internal static string WSE593;
    internal static string WSE594;
    internal static string WSE595;
    internal static string WSE596;
    internal static string WSE597;
    internal static string WSE598;
    internal static string WSE599;
    internal static string WSE600;
    internal static string WSE601;
    internal static string WSE602;
    internal static string WSE603;
    internal static string WSE604;
    internal static string WSE605;
    internal static string WSE606;
    internal static string WSE607;
    internal static string WSE608;
    internal static string WSE609;
    internal static string WSE610;
    internal static string WSE611;
    internal static string WSE612;
    internal static string WSE613;
    internal static string WSE614;
    internal static string WSE615;
    internal static string WSE616;
    internal static string WSE617;
    internal static string WSE618;
    internal static string WSE619;
    internal static string WSE620;
    internal static string WSE621;
    internal static string WSE622;
    internal static string WSE623;
    internal static string WSE624;
    internal static string WSE625;
    internal static string WSE626;
    internal static string WSE627;
    internal static string WSE628;
    internal static string WSE629;
    internal static string WSE630;
    internal static string WSE631;
    internal static string WSE632;
    internal static string WSE633;
    internal static string WSE634;
    internal static string WSE635;
    internal static string WSE701;
    internal static string WSE702;
    internal static string WSE703;
    internal static string WSE704;
    internal static string WSE705;
    internal static string WSE706;
    internal static string WSE707;
    internal static string WSE708;
    internal static string WSE709;
    internal static string WSE710;
    internal static string WSE711;
    internal static string WSE712;
    internal static string WSE713;
    internal static string WSE715;
    internal static string WSE716;
    internal static string WSE717;
    internal static string WSE718;
    internal static string WSE719;
    internal static string WSE720;
    internal static string WSE721;
    internal static string WSE801;
    internal static string WSE802;
    internal static string WSE803;
    internal static string WSE804;
    internal static string WSE805;
    internal static string WSE806;
    internal static string WSE807;
    internal static string WSE808;
    internal static string WSE809;
    internal static string WSE810;
    internal static string WSE811;
    internal static string WSE812;
    internal static string WSE813;
    internal static string WSE814;
    internal static string WSE815;
    internal static string WSE816;
    internal static string WSE817;
    internal static string WSE818;
    internal static string WSE819;
    internal static string WSE820;
    internal static string WSE821;
    internal static string WSE822;
    internal static string WSE823;
    internal static string WSE824;
    internal static string WSE825;
    internal static string WSE826;
    internal static string WSE827;
    internal static string WSE828;
    internal static string WSE829;
    internal static string WSE830;
    internal static string WSE831;
    internal static string WSE832;
    internal static string WSE833;
    internal static string WSE834;
    internal static string WSE835;
    internal static string WSE836;
    internal static string WSE837;
    internal static string WSE838;
    internal static string WSE839;
    internal static string WSE840;
    internal static string WSE841;
    internal static string WSE842;
    internal static string WSE843;
    internal static string WSE844;
    internal static string WSE845;
    internal static string WSE846;
    internal static string WSE847;
    internal static string WSE848;
    internal static string WSE901;
    internal static string WSE902;
    internal static string WSE903;
    internal static string WSE904;
    internal static string WSE905;
    internal static string WSE906;
    internal static string WSE907;
    internal static string WSE908;
    internal static string WSE909;
    internal static string WSE910;
    internal static string WSE911;
    internal static string WSE912;
    internal static string WSE913;
    internal static string WSE914;
    internal static string Cryptography_Xml_SoapHeader;
    internal static string Cryptography_Xml_EnvelopedSignatureRequiresContext;
    internal static string WSE1300;
    internal static string WSE1301;
    internal static string WSE1302;
    internal static string WSE1303;
    internal static string WSE1400;
    internal static string WSE1500;
    internal static string WSE1501;
    internal static string WSE1600;
    internal static string WSE1601;
    internal static string WSE1602;
    internal static string WSE1603;
    internal static string WSE1604;
    internal static string WSE1605;
    internal static string WSE1606;
    internal static string WSE1607;
    internal static string WSE1608;
    internal static string WSE1609;
    internal static string WSE1610;
    internal static string WSE1611;
    internal static string WSE1612;
    internal static string WSE1613;
    internal static string WSE1614;
    internal static string WSE1615;
    internal static string WSE1616;
    internal static string WSE1617;
    internal static string WSE1618;
    internal static string WSE1619;
    internal static string WSE1620;
    internal static string WSE1621;
    internal static string WSE1622;
    internal static string WSE1623;
    internal static string WSE2000;
    internal static string WSE2001;
    internal static string WSE2002;
    internal static string WSE2003;
    internal static string WSE2004;
    internal static string WSE2005;
    internal static string WSE2006;
    internal static string WSE2007;
    internal static string WSE2008;
    internal static string WSE2009;
    internal static string WSE2010;
    internal static string WSE2011;
    internal static string WSE2012;
    internal static string WSE2013;
    internal static string WSE2014;
    internal static string WSE2015;
    internal static string WSE2016;
    internal static string WSE2017;
    internal static string WSE2018;
    internal static string WSE2100;
    internal static string WSE2101;
    internal static string WSE2102;
    internal static string WSE2103;
    internal static string WSE2104;
    internal static string WSE2105;
    internal static string WSE2109;
    internal static string WSE2113;
    internal static string WSE2114;
    internal static string WSE2115;
    internal static string WSE2116;
    internal static string WSE2117;
    internal static string WSE2118;
    internal static string WSE2119;
    internal static string WSE2120;
    internal static string WSE2121;
    internal static string WSE2122;
    internal static string WSE2123;
    internal static string WSE2124;
    internal static string WSE2125;
    internal static string WSE2126;
    internal static string WSE2127;
    internal static string WSE2128;
    internal static string WSE2129;
    internal static string WSE2130;
    internal static string WSE2131;
    internal static string WSE2132;
    internal static string WSE2133;
    internal static string WSE2134;
    internal static string WSE2135;
    internal static string WSE2136;
    internal static string WSE2137;
    internal static string WSE2138;
    internal static string WSE2139;
    internal static string WSE2140;
    internal static string WSE2141;
    internal static string WSE2142;
    internal static string WSE2143;
    internal static string WSE2144;
    internal static string WSE2145;
    internal static string WSE2146;
    internal static string WSE2147;
    internal static string WSE2148;
    internal static string WSE2149;
    internal static string WSE2150;
    internal static string WSE2151;
    internal static string WSE2152;
    internal static string WSE2154;
    internal static string WSE2155;
    internal static string WSE2156;
    internal static string WSE2157;
    internal static string WSE2158;
    internal static string WSE2159;
    internal static string WSE2160;
    internal static string WSE2161;
    internal static string WSE2162;
    internal static string WSE2163;
    internal static string WSE2166;
    internal static string WSE2167;
    internal static string WSE2168;
    internal static string WSE2169;
    internal static string WSE2170;
    internal static string WSE2173;
    internal static string WSE2187;
    internal static string WSE2188;
    internal static string WSE2193;
    internal static string WSE2194;
    internal static string WSE2195;
    internal static string WSE2198;
    internal static string WSE2199;
    internal static string WSE2200;
    internal static string WSE2201;
    internal static string WSE2202;
    internal static string WSE2203;
    internal static string WSE2204;
    internal static string WSE2208;
    internal static string WSE2209;
    internal static string WSE2210;
    internal static string WSE2211;
    internal static string WSE2212;
    internal static string WSE2213;
    internal static string WSE2214;
    internal static string WSE2215;
    internal static string WSE2216;
    internal static string WSE2217;
    internal static string WSE2218;
    internal static string WSE2219;
    internal static string WSE2223;
    internal static string WSE2226;
    internal static string WSE2238;
    internal static string WSE2242;
    internal static string WSE2243;
    internal static string WSE2244;
    internal static string WSE2246;
    internal static string WSE2247;
    internal static string WSE2248;
    internal static string WSE2249;
    internal static string WSE2251;
    internal static string WSE2254;
    internal static string WSE2255;
    internal static string WSE2256;
    internal static string WSE2257;
    internal static string WSE2268;
    internal static string WSE2273;
    internal static string WSE2275;
    internal static string WSE2283;
    internal static string WSE2284;
    internal static string WSE2288;
    internal static string WSE2289;
    internal static string WSE2290;
    internal static string WSE2292;
    internal static string WSE2293;
    internal static string WSE2294;
    internal static string WSE2297;
    internal static string WSE2298;
    internal static string WSE2299;
    internal static string WSE2300;
    internal static string WSE2301;
    internal static string WSE2302;
    internal static string WSE2304;
    internal static string WSE2307;
    internal static string WSE2310;
    internal static string WSE2312;
    internal static string WSE2314;
    internal static string WSE2316;
    internal static string WSE2319;
    internal static string WSE2321;
    internal static string WSE2324;
    internal static string WSE2326;
    internal static string WSE2330;
    internal static string WSE2339;
    internal static string WSE2340;
    internal static string WSE2345;
    internal static string WSE2346;
    internal static string WSE2347;
    internal static string WSE2348;
    internal static string WSE2349;
    internal static string WSE2350;
    internal static string WSE2351;
    internal static string WSE2352;
    internal static string WSE2353;
    internal static string WSE2354;
    internal static string WSE2355;
    internal static string WSE2356;
    internal static string WSE2357;
    internal static string WSE2358;
    internal static string WSE2359;
    internal static string WSE2360;
    internal static string WSE2361;
    internal static string WSE2362;
    internal static string WSE2363;
    internal static string WSE2364;
    internal static string WSE2365;
    internal static string WSE2366;
    internal static string WSE2367;
    internal static string WSE2368;
    internal static string WSE2369;
    internal static string WSE2370;
    internal static string WSE2371;
    internal static string WSE2373;
    internal static string WSE2375;
    internal static string WSE2376;
    internal static string WSE2377;
    internal static string WSE2378;
    internal static string WSE2379;
    internal static string WSE2380;
    internal static string WSE2381;
    internal static string WSE2382;
    internal static string WSE2383;
    internal static string WSE2384;
    internal static string WSE2385;
    internal static string WSE2386;
    internal static string WSE2387;
    internal static string WSE2388;
    internal static string WSE2389;
    internal static string WSE2390;
    internal static string WSE2391;
    internal static string WSE2392;
    internal static string WSE2393;
    internal static string WSE2394;
    internal static string WSE2395;
    internal static string WSE2396;
    internal static string WSE2397;
    internal static string WSE2398;
    internal static string WSE2399;
    internal static string WSE2400;
    internal static string WSE2401;
    internal static string WSE2402;
    internal static string WSE2403;
    internal static string WSE2404;
    internal static string WSE2407;
    internal static string WSE2408;
    internal static string WSE2409;
    internal static string WSE2410;
    internal static string WSE2411;
    internal static string WSE2412;
    internal static string WSE2415;
    internal static string WSE2416;
    internal static string WSE2417;
    internal static string WSE2418;
    internal static string WSE2419;
    internal static string WSE2420;
    internal static string WSE2421;
    internal static string WSE2422;
    internal static string WSE2423;
    internal static string WSE2424;
    internal static string WSE2427;
    internal static string WSE2428;
    internal static string WSE2429;
    internal static string WSE2430;
    internal static string WSE2439;
    internal static string WSE2442;
    internal static string WSE2443;
    internal static string WSE2447;
    internal static string WSE2454;
    internal static string WSE2455;
    internal static string WSE2456;
    internal static string WSE2457;
    internal static string WSE2458;
    internal static string WSE2459;
    internal static string WSE2460;
    internal static string WSE2461;
    internal static string WSE2462;
    internal static string WSE2463;
    internal static string WSE2464;
    internal static string WSE2465;
    internal static string WSE2466;
    internal static string WSE2467;
    internal static string WSE2468;
    internal static string WSE2469;
    internal static string MessageProcessingTerminatedByFilter;
    internal static string UnprocessedMessage;
    internal static string ProcessedMessage;
    internal static string EnteringFilter;
    internal static string ExitedFilter;
    internal static string ExceptionThrownWhenProcessingMessage;
    internal static string SignatureConfirmationCheckFailed;
    internal static string ProtectionOrderCheckFailed;
    internal static string TimestampCheckFailed;
    internal static string SignatureTokenCheckFailed;
    internal static string EncryptionTokenCheckFailed;
    internal static string DerivedKeyTokenCheckFailed;
    internal static string BodyEncryptionCheckFailed;
    internal static string UsernameTokenEncryptionCheckFailed;
    internal static string SignatureTokenRequirementCheckFailed;
    internal static string UsernameTokenSignatureCheckFailed;
    internal static string SignatureEncryptionCheckFailed;
    internal static string SignatureOptionsCheckFailed;
    internal static string CustomHeaderSignatureCheckFailed;
    internal static string WSE3001;
    internal static string WSE3002;
    internal static string WSE3003;
    internal static string WSE3004;
    internal static string WSE3005;
    internal static string WSE3006;
    private static SR _instance;
    private static object _lock;
    private ResourceManager resources;
    private static SR();
    private static SR GetLoader();
    public static string GetString(string name);
    public static string GetString(string name, Object[] args);
    public static string GetString(CultureInfo culture, string name);
    public static string GetString(CultureInfo culture, string name, Object[] args);
    public static bool GetBoolean(string name);
    public static bool GetBoolean(CultureInfo culture, string name);
    public static char GetChar(string name);
    public static char GetChar(CultureInfo culture, string name);
    public static byte GetByte(string name);
    public static byte GetByte(CultureInfo culture, string name);
    public static short GetShort(string name);
    public static short GetShort(CultureInfo culture, string name);
    public static int GetInt(string name);
    public static int GetInt(CultureInfo culture, string name);
    public static long GetLong(string name);
    public static long GetLong(CultureInfo culture, string name);
    public static float GetFloat(string name);
    public static float GetFloat(CultureInfo culture, string name);
    public static double GetDouble(string name);
    public static double GetDouble(CultureInfo culture, string name);
    public static object GetObject(string name);
    public static object GetObject(CultureInfo culture, string name);
}
[AttributeUsageAttribute("32767")]
internal class Microsoft.Web.Services3.SRCategoryAttribute : CategoryAttribute {
    public SRCategoryAttribute(string category);
    protected virtual string GetLocalizedString(string value);
}
[AttributeUsageAttribute("32767")]
internal class Microsoft.Web.Services3.SRDescriptionAttribute : DescriptionAttribute {
    private bool replaced;
    public string Description { get; }
    public SRDescriptionAttribute(string description);
    public virtual string get_Description();
}
public class Microsoft.Web.Services3.StateManager : object {
    private Dictionary`2<string, Dictionary`2<Type, object>> state;
    public StateManager(StateManager other);
    public T Set(T value);
    public T Set(T value, string actor);
    private object SetInternal(object value, Type key, string actor);
    public T Get();
    public T Get(string actor);
    public sealed virtual void WriteXml(XmlWriter writer);
    private void WriteStateForActor(XmlWriter writer, string actor);
    public sealed virtual void ReadXml(XmlReader reader);
    private void ReadStateForActor(XmlReader reader, string actor);
    public sealed virtual XmlSchema GetSchema();
}
internal class Microsoft.Web.Services3.StreamHelper : object {
    internal static int DefaultBufferSize;
    internal static void BinaryCopy(Stream from, Stream to);
    internal static void BinaryCopy(Stream from, Stream to, int bufferSize);
}
internal class Microsoft.Web.Services3.StringHelper : object {
    private static int Max16BitUtf8SequenceLength;
    internal static Char[] HexUpperChars;
    private static StringHelper();
    internal static string EscapeString(string s);
    internal static string EscapeString(string s, Encoding e);
    internal static string UnEscapeString(string s);
    private static string EscapeStringInternal(string s, Encoding e);
    private static string UnEscapeStringInternal(string s, Encoding e);
    private static void HexEscape8(StringBuilder sb, char c);
}
internal class Microsoft.Web.Services3.ThreadTimeoutEntry : TimeoutEntry {
    private Thread _thread;
    internal ThreadTimeoutEntry(Thread thread, TimeSpan lifetime);
    internal virtual bool Timeout(DateTime now);
}
internal class Microsoft.Web.Services3.ThreadTimeoutManager : TimeoutManager {
    internal ThreadTimeoutManager(TimeSpan timerPeriod);
    internal ThreadTimeoutEntry Add(Thread thread, TimeSpan lifetime);
    internal void Remove(ThreadTimeoutEntry entry);
}
internal abstract class Microsoft.Web.Services3.TimeoutEntry : DoubleLink {
    private DateTime _expiry;
    private DoubleLinkList _list;
    protected DateTime Expiry { get; protected set; }
    internal DoubleLinkList List { get; internal set; }
    protected TimeoutEntry(TimeSpan lifetime);
    protected DateTime get_Expiry();
    protected void set_Expiry(DateTime value);
    internal DoubleLinkList get_List();
    internal void set_List(DoubleLinkList value);
    internal abstract virtual bool Timeout(DateTime now);
}
internal abstract class Microsoft.Web.Services3.TimeoutManager : object {
    private DoubleLinkList[] _lists;
    private int _currentList;
    private int _count;
    private Timer _timer;
    private object _lock;
    protected TimeoutManager(TimeSpan timerPeriod);
    protected void AddEntry(TimeoutEntry entry);
    private void BareAddEntry(TimeoutEntry entry);
    private void BareRemoveEntry(TimeoutEntry entry);
    private void EnableTimer();
    protected void RemoveEntry(TimeoutEntry entry);
    private void TimerElapsed(object sender, ElapsedEventArgs e);
}
internal abstract class Microsoft.Web.Services3.TypedAsyncResult`1 : AsyncResult {
    private T data;
    public T Data { get; }
    public TypedAsyncResult`1(AsyncCallback callback, object state);
    public T get_Data();
    protected void Complete(T data, bool completedSynchronously);
    public static T End(IAsyncResult result);
}
internal class Microsoft.Web.Services3.TypedCompletedAsyncResult`1 : TypedAsyncResult`1<T> {
    public TypedCompletedAsyncResult`1(T data, AsyncCallback callback, object state);
    public static T End(IAsyncResult result);
}
internal class Microsoft.Web.Services3.TypeHelper : object {
    internal static Type GetType(string typeName);
    internal static Type GetType(string typeName, bool throwOnError);
    internal static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.UriList : object {
    private ArrayList _uriList;
    public Uri Item { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public Uri get_Item(int index);
    public void set_Item(int index, Uri value);
    public int Add(Uri uri);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Uri[] array, int index);
    public bool Contains(Uri uri);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(Uri uri);
    public void Insert(int index, Uri uri);
    public bool get_IsFixedSize();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public void Remove(Uri uri);
    public void RemoveAt(int index);
    public sealed virtual object get_SyncRoot();
}
internal class Microsoft.Web.Services3.Utilities.AspNetHelper : object {
    internal static Uri GetActor(SoapContext context, HttpContext httpContext);
    internal static void SetDefaultAddressingProperties(SoapContext context, HttpContext httpContext);
    internal static void DenySuspiciousMessages(HttpContext httpContext);
}
internal class Microsoft.Web.Services3.Utilities.IOHelper : object {
    private static int BufferLength;
    public static bool CompareBuffers(Byte[] buf1, Byte[] buf2);
    public static int BlockRead(Stream stream, Byte[] buffer, int offset, int count);
    public static MemoryStream ReadIntoMemoryStream(Stream stream);
    public static void WriteStreamToStream(Stream inStream, Stream outStream, Byte[] buf);
}
internal class Microsoft.Web.Services3.Utilities.SoapEncodingHelper : object {
    public static Encoding GetEncoding(string contentType);
}
internal class Microsoft.Web.Services3.Utility : object {
    public static string UrnScheme;
    public static string UuidScheme;
    public static Char[] WhitespaceChars;
    public static IComparer QNameComparer;
    public static IComparer AttributeComparer;
    private static int MAX_PATH;
    private static Utility();
    public static void AddToken(SecurityToken token, SecurityTokenCollection tokens);
    public static bool CompareArray(Byte[] a, Byte[] b);
    public static bool CompareXmlQualifiedName(XmlQualifiedName a, XmlQualifiedName b);
    public static int CompareXmlAttribute(XmlAttribute attribute1, XmlAttribute attribute2);
    public static int CompareXmlElement(XmlElement element1, XmlElement element2);
    public static int CompareXmlElement(XmlElement element1, XmlElement element2, XmlQualifiedName[] excludedAttributes);
    public static XmlAttribute GetAttribute(XmlAttributeCollection attributes, string name, string namespace);
    public static string GetDomainFromWindowsName(string name);
    public static string GetDomainFromPrincipalName(string name);
    public static XmlElement GetIdElement(XmlDocument document, string idValue);
    public static string GetFaultString(Exception e);
    internal static void FindIdElements(XmlElement element, Hashtable idElements);
    public static int GetHashCode(Byte[] data);
    public static string GetNodeText(XmlElement element);
    public static string GetNodeText(XmlElement element, bool throwOnChildElement);
    public static XmlElement GetSoapBody(XmlDocument document);
    public static bool ImplementsInterface(Type type, Type interfaceType);
    private static bool IsExcluded(XmlAttribute attr, XmlQualifiedName[] excludedAttributes);
    private static ArrayList GetSignificantAttributes(XmlAttributeCollection attrs, XmlQualifiedName[] excludedAttributes);
    public static SecurityToken GetRootToken(SecurityToken token);
    public static SecurityTokenReference GetSecurityTokenReference(KeyInfo ki);
    public static string GetTransportUri(Uri location);
    public static SecurityTokenReference GetTokenReference(XmlDocument document, SecurityToken token);
    public static KeyInfo GetKeyInfo(SecurityTokenReference str);
    internal static bool IsLocalPath(string path);
}
public class Microsoft.Web.Services3.WaitHandleAsyncResult : AsyncResult {
    private RegisteredWaitHandle _registeredWaitHandle;
    private object _lock;
    private WaitHandle _waitHandle;
    protected WaitHandle WaitHandle { get; }
    public WaitHandleAsyncResult(WaitHandle waitHandle, AsyncCallback callback, object state);
    protected virtual void OnSignalled(object state, bool timedOut);
    protected virtual void StartWait(WaitHandle waitHandle);
    protected WaitHandle get_WaitHandle();
}
internal class Microsoft.Web.Services3.WebServicesClientAsyncResult : AsyncResult {
    private ISoapInputChannel _channel;
    private ISoapOutputChannel _outputChannel;
    private SoapEnvelope _response;
    private SoapEnvelope _request;
    public SoapEnvelope Request { get; }
    public SoapEnvelope Response { get; }
    public WebServicesClientAsyncResult(WebServicesClientProtocol client, SoapEnvelope envelope);
    public WebServicesClientAsyncResult(WebServicesClientProtocol client, SoapEnvelope envelope, AsyncCallback callback, object state);
    protected virtual void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private void OnReceiveComplete(IAsyncResult result);
    private void OnSendComplete(IAsyncResult result);
    public SoapEnvelope get_Request();
    public SoapEnvelope get_Response();
}
public class Microsoft.Web.Services3.WebServicesClientProtocol : SoapHttpClientProtocol {
    private EndpointReference _destination;
    private SoapContext _requestContext;
    private SoapContext _responseContext;
    private Pipeline _pipeline;
    private WebServicesClientAsyncResult _asyncResult;
    private StateManager currentOperationState;
    private CredentialSet credentials;
    private bool _requireMtom;
    private string _responseContentType;
    private bool useDefaultCredentialsSetExplicitly;
    internal StateManager CurrentOperationState { get; internal set; }
    internal WebServicesClientAsyncResult AsyncResult { get; internal set; }
    public EndpointReference Destination { get; public set; }
    public Pipeline Pipeline { get; public set; }
    public bool RequireMtom { get; public set; }
    public SoapContext RequestSoapContext { get; }
    public SoapContext ResponseSoapContext { get; }
    public string Url { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    internal StateManager get_CurrentOperationState();
    internal void set_CurrentOperationState(StateManager value);
    internal WebServicesClientAsyncResult get_AsyncResult();
    internal void set_AsyncResult(WebServicesClientAsyncResult value);
    private void InitializePipeline();
    public void SetPolicy(Policy policy);
    public void SetPolicy(string policyName);
    public EndpointReference get_Destination();
    public void set_Destination(EndpointReference value);
    public Pipeline get_Pipeline();
    public void set_Pipeline(Pipeline value);
    public bool get_RequireMtom();
    public void set_RequireMtom(bool value);
    public SoapContext get_RequestSoapContext();
    public SoapContext get_ResponseSoapContext();
    public void SetClientCredential(TSecurityToken clientToken);
    public TSecurityToken GetClientCredential();
    public void SetServiceCredential(TSecurityToken serviceToken);
    public TSecurityToken GetServiceCredential();
    internal void SetResponseSoapContext(SoapContext context);
    protected virtual XmlReader GetReaderForMessage(SoapClientMessage message, int bufferSize);
    protected virtual WebRequest GetWebRequest(Uri uri);
    protected virtual WebResponse GetWebResponse(WebRequest request);
    private WebResponse GetResponse(WebRequest request, IAsyncResult result);
    protected virtual WebResponse GetWebResponse(WebRequest request, IAsyncResult result);
    protected virtual XmlWriter GetWriterForMessage(SoapClientMessage message, int bufferSize);
    public string get_Url();
    public void set_Url(string value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    private bool IsLocalFileSystemWebService(string url);
}
internal class Microsoft.Web.Services3.WseProtocol : SoapServerProtocol {
    private Pipeline _pipeline;
    private SoapActorAttribute _soapActorAttribute;
    private StateManager _operationState;
    private SoapEnvelope _requestEnvelope;
    private SoapEnvelope _responseEnvelope;
    private SoapServerMessage _responseMessage;
    private Exception _faultException;
    private object _targetRedirect;
    private static Dictionary`2<Uri, Pipeline> pipelines;
    private static Dictionary`2<Uri, SoapActorAttribute> soapActorAttributes;
    protected object Target { get; }
    private static WseProtocol();
    protected virtual object get_Target();
    private static bool CheckMtomContentType(SoapServerMessage message);
    private SoapEnvelope CreateGenericFault(SoapEnvelope outputEnvelope, Exception ex, Exception faultFilteringException);
    private void CreateProtocolPipeline();
    private SoapContext CreateRequestSoapContext(SoapEnvelope requestEnvelope);
    private SoapEnvelope CreateRequestSoapEnvelope(SoapServerMessage message);
    private static SoapEnvelope CreateResponseFault(Exception ex, SoapEnvelope request);
    internal static void DenySuspiciousMessages(HttpContext httpContext);
    private void EstablishResponseAddressingHeaders(AddressingHeaders addressingHeaders);
    private SoapServerMethod FilterRequest(SoapEnvelope requestEnvelope);
    private StateManager GetOrCreateSessionStateFromHttpContext();
    private SoapEnvelope GetFilteredResponseEnvelope(SoapEnvelope outputEnvelope);
    private XmlWriter GetFilteredWriterForResponse(SoapServerMessage message);
    protected virtual XmlReader GetReaderForMessage(SoapServerMessage message, int bufferSize);
    private SoapEnvelope GetRequestEnvelopeFromMessage(SoapServerMessage message);
    protected virtual XmlWriter GetWriterForMessage(SoapServerMessage message, int bufferSize);
    private static void HandleLoadingException(Exception loadingException);
    protected virtual SoapExtension[] ModifyInitializedExtensions(PriorityGroup group, SoapExtension[] extensions);
    public void ProcessBeforeDeserializeStage(SoapServerMessage message);
    private void ProcessResponseEnvelope(object sender, EventArgs e);
    [WebMethodAttribute]
public void RouteOnBodyRequestConfigurationExceptionWorkAroundStub();
    protected virtual SoapServerMethod RouteRequest(SoapServerMessage message);
    private void SetFault(Exception faultException);
    private void WriteEnvelopeToStream(SoapEnvelope envelope, SoapServerMessage message);
}
internal class Microsoft.Web.Services3.WseProtocolExtension : SoapExtension {
    private WseProtocol _protocol;
    public WseProtocolExtension(WseProtocol protocol);
    public virtual void ProcessMessage(SoapMessage soapMessage);
    public virtual object GetInitializer(Type serviceType);
    public virtual object GetInitializer(LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute);
    public virtual void Initialize(object initializer);
}
public class Microsoft.Web.Services3.WseProtocolFactory : SoapServerProtocolFactory {
    protected virtual ServerProtocol CreateIfRequestCompatible(HttpRequest request);
}
public class Microsoft.Web.Services3.WseSoapHeaderException : SoapHeaderException {
    public WseSoapHeaderException(string message, XmlQualifiedName code);
    public WseSoapHeaderException(string message, XmlQualifiedName code, Exception innerException);
    private static string GetActor();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Xml.AttributeList : object {
    private ArrayList _innerList;
    private XmlDocument _document;
    public XmlAttribute Item { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public XmlAttribute get_Item(int index);
    public void set_Item(int index, XmlAttribute value);
    public int Add(XmlAttribute element);
    public void Clear();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(XmlAttribute[] array, int index);
    public bool Contains(XmlAttribute element);
    public sealed virtual int get_Count();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(XmlAttribute element);
    public bool get_IsFixedSize();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public void Remove(XmlAttribute element);
    public void RemoveAt(int index);
    public sealed virtual object get_SyncRoot();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Xml.ElementList : object {
    private XmlDocument _document;
    private ArrayList _innerList;
    public XmlElement Item { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public XmlElement get_Item(int index);
    public void set_Item(int index, XmlElement value);
    public int Add(XmlElement element);
    public void Clear();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(XmlElement[] array, int index);
    public bool Contains(XmlElement element);
    public sealed virtual int get_Count();
    public virtual bool Equals(object obj);
    public sealed virtual IEnumerator GetEnumerator();
    public virtual int GetHashCode();
    public int IndexOf(XmlElement element);
    public bool get_IsFixedSize();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public void Remove(XmlElement element);
    public void RemoveAt(int index);
    public sealed virtual object get_SyncRoot();
}
public interface Microsoft.Web.Services3.Xml.IXmlElement {
    public abstract virtual XmlElement GetXml(XmlDocument document);
    public abstract virtual void LoadXml(XmlElement element);
}
public abstract class Microsoft.Web.Services3.Xml.OpenAttributeDateTimeElement : OpenAttributeElement {
    private DateTime _dateTime;
    public DateTime Value { get; public set; }
    protected OpenAttributeDateTimeElement(DateTime dateTime);
    protected void GetXmlElements(XmlDocument document, XmlElement element);
    protected void LoadXmlElements(XmlElement element);
    public DateTime get_Value();
    public void set_Value(DateTime value);
}
public abstract class Microsoft.Web.Services3.Xml.OpenAttributeElement : object {
    private AttributeList _anyAttributes;
    public AttributeList AnyAttributes { get; }
    protected OpenAttributeElement(XmlElement element);
    public AttributeList get_AnyAttributes();
    public abstract virtual XmlElement GetXml(XmlDocument document);
    protected virtual void GetXmlAttributes(XmlDocument document, XmlElement element);
    public abstract virtual void LoadXml(XmlElement element);
    protected virtual void LoadXmlAttributes(XmlElement element);
}
public abstract class Microsoft.Web.Services3.Xml.OpenAttributeQNameElement : QualifiedNameElement {
    private AttributeList _anyAttributes;
    public AttributeList AnyAttributes { get; }
    protected OpenAttributeQNameElement(string name, string ns);
    protected OpenAttributeQNameElement(string prefix, string name, string ns);
    protected OpenAttributeQNameElement(XmlQualifiedName qname);
    protected OpenAttributeQNameElement(string prefix, XmlQualifiedName qname);
    protected OpenAttributeQNameElement(XmlElement element);
    public AttributeList get_AnyAttributes();
    protected virtual void GetXmlAttributes(XmlDocument document, XmlElement element);
    protected virtual void LoadXmlAttributes(XmlElement element);
}
public abstract class Microsoft.Web.Services3.Xml.OpenAttributeUriElement : OpenAttributeElement {
    private Uri _uri;
    public Uri Value { get; }
    protected OpenAttributeUriElement(Uri uri);
    protected OpenAttributeUriElement(OpenAttributeUriElement uri);
    protected OpenAttributeUriElement(XmlElement element);
    protected void GetXmlElements(XmlDocument document, XmlElement element);
    protected void LoadXmlElements(XmlElement element);
    public Uri get_Value();
}
public abstract class Microsoft.Web.Services3.Xml.OpenAttributeUriString : OpenAttributeElement {
    private string _uri;
    public string Value { get; }
    protected OpenAttributeUriString(string uri);
    protected void GetXmlElements(XmlDocument document, XmlElement element);
    protected void LoadXmlElements(XmlElement element);
    public string get_Value();
}
public abstract class Microsoft.Web.Services3.Xml.OpenElement : OpenElementElement {
    private AttributeList _anyAttribute;
    public AttributeList AnyAttributes { get; }
    public AttributeList get_AnyAttributes();
    protected virtual void GetXmlAttributes(XmlDocument document, XmlElement element);
    protected virtual void LoadXmlAttributes(XmlElement element);
}
public abstract class Microsoft.Web.Services3.Xml.OpenElementElement : object {
    private ElementList _anyElements;
    public ElementList AnyElements { get; }
    public ElementList get_AnyElements();
    public abstract virtual XmlElement GetXml(XmlDocument document);
    protected virtual void GetXmlAttributes(XmlDocument document, XmlElement element);
    protected virtual void GetXmlElements(XmlDocument document, XmlElement element);
    public abstract virtual void LoadXml(XmlElement element);
    protected virtual void LoadXmlAttributes(XmlElement element);
    protected virtual void LoadXmlElements(XmlElement element);
}
public class Microsoft.Web.Services3.Xml.QualifiedName : XmlQualifiedName {
    private static int prefixIndex;
    private string _prefix;
    public string Prefix { get; }
    public string Value { get; }
    public QualifiedName(string name, string ns);
    public QualifiedName(string prefix, string name, string ns);
    public QualifiedName(XmlQualifiedName qname);
    public QualifiedName(string prefix, XmlQualifiedName qname);
    private static QualifiedName();
    private static String[] GetQNameParts(string value);
    public static QualifiedName FromString(string value, XmlNode context);
    public static QualifiedName FromString(string value, XmlReader context);
    public static QualifiedName FromXmlAttribute(XmlAttribute attribute);
    public static QualifiedName FromXmlElement(XmlElement element);
    private static string GetNextPrefix();
    private static string GetName(XmlQualifiedName qname);
    private static string GetNamespace(XmlQualifiedName qname);
    public void GetInnerXml(XmlDocument document, XmlAttribute attribute);
    public void GetInnerXml(XmlDocument document, XmlElement element);
    public string get_Prefix();
    private bool ResolvePrefix(XmlNode target, String& resolvedPrefix);
    public string get_Value();
}
public abstract class Microsoft.Web.Services3.Xml.QualifiedNameElement : object {
    private QualifiedName _qname;
    public QualifiedName Value { get; }
    protected QualifiedNameElement(string name, string ns);
    protected QualifiedNameElement(string prefix, string name, string ns);
    protected QualifiedNameElement(XmlQualifiedName qname);
    protected QualifiedNameElement(string prefix, XmlQualifiedName qname);
    protected QualifiedNameElement(XmlElement element);
    public abstract virtual XmlElement GetXml(XmlDocument document);
    protected virtual void GetXmlElements(XmlDocument document, XmlElement element);
    public abstract virtual void LoadXml(XmlElement element);
    protected virtual void LoadXmlAttributes(XmlElement element);
    protected virtual void LoadXmlElements(XmlElement element);
    public QualifiedName get_Value();
}
internal class Microsoft.Web.Services3.Xml.SoapEnvelopeReaderWrapper : object {
    private XmlReader _reader;
    internal XmlReader Reader { get; }
    public SoapEnvelopeReaderWrapper(SoapClientMessage message, string messageContentType);
    internal XmlReader get_Reader();
}
internal class Microsoft.Web.Services3.Xml.SoapEnvelopeWriter : XmlWrappingWriter {
    private Stream _stream;
    private SoapEnvelope _envelope;
    private Pipeline _pipeline;
    private WebServicesClientProtocol _proxy;
    public SoapEnvelopeWriter(SoapClientMessage message);
    protected virtual void Finish();
}
public abstract class Microsoft.Web.Services3.Xml.WSESoapHeader : object {
    private string _actor;
    private bool _mustUnderstand;
    private bool _didUnderstand;
    private bool _relay;
    public string Actor { get; public set; }
    public bool MustUnderstand { get; public set; }
    public bool DidUnderstand { get; public set; }
    public string EncodedMustUnderstand { get; public set; }
    public string EncodedRelay { get; public set; }
    public bool Relay { get; public set; }
    public string get_Actor();
    public void set_Actor(string value);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public bool get_DidUnderstand();
    public void set_DidUnderstand(bool value);
    public string get_EncodedMustUnderstand();
    public void set_EncodedMustUnderstand(string value);
    public string get_EncodedRelay();
    public void set_EncodedRelay(string value);
    protected void GetAttributeXml(XmlDocument document, XmlElement element);
    protected void LoadAttributeXml(XmlElement element);
    public bool get_Relay();
    public void set_Relay(bool value);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Web.Services3.Xml.XmlElementCollection : object {
    private ArrayList _elementList;
    public XmlElement Item { get; }
    public int Count { get; }
    public XmlElement get_Item(int index);
    public void Add(XmlElement element);
    public bool Contains(XmlElement element);
    public int get_Count();
    public IEnumerator GetEnumerator();
}
public class Microsoft.Web.Services3.Xml.XmlSerializerCache : object {
    private static MRUHashtable table;
    private static XmlSerializerCache();
    public static XmlSerializer GetXmlSerializer(Type type, string defaultNamespace);
    public static ConstructorInfo GetXmlElementConstructor(Type type);
}
internal class Microsoft.Web.Services3.Xml.XmlSkipDTDReader : XmlTextReader {
    internal XmlSkipDTDReader(Stream stream);
    public virtual bool Read();
}
internal class Microsoft.Web.Services3.Xml.XmlWrappingWriter : XmlWriter {
    protected XmlWriter writer;
    private int _elementsWritten;
    private bool _ignoreDocumentOps;
    private bool _finishAfterFlush;
    private bool _finished;
    private EventHandler OnClosed;
    public XmlWriterSettings Settings { get; }
    public WriteState WriteState { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    protected XmlWriter Writer { get; protected set; }
    internal XmlWrappingWriter(XmlWriter baseWriter);
    internal XmlWrappingWriter(XmlWriter baseWriter, bool ignoreDocumentOps, bool finishAfterLastFlush);
    public void add_OnClosed(EventHandler value);
    public void remove_OnClosed(EventHandler value);
    protected virtual void Finish();
    public virtual XmlWriterSettings get_Settings();
    public virtual WriteState get_WriteState();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteEndDocument();
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteEndAttribute();
    public virtual void WriteCData(string text);
    public virtual void WriteComment(string text);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void Close();
    public virtual void Flush();
    public virtual string LookupPrefix(string ns);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    protected XmlWriter get_Writer();
    protected void set_Writer(XmlWriter value);
}
internal class ThisAssembly : object {
    internal static string Title;
    internal static string Description;
    internal static string DefaultAlias;
    internal static string Copyright;
    internal static string Trademark;
    internal static string Version;
    internal static string InformationalVersion;
}
