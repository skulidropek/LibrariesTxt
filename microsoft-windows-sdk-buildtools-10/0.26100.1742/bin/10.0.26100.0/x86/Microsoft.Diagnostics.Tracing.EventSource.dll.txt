internal class Microsoft.Diagnostics.Tracing.ActivityTracker : object {
    private static ushort MAX_ACTIVITY_DEPTH;
    private AsyncLocal`1<ActivityInfo> m_current;
    private bool m_checkedForEnable;
    private static ActivityTracker s_activityTrackerInstance;
    private static long m_nextId;
    public static ActivityTracker Instance { get; }
    private Guid CurrentActivityId { get; }
    private static ActivityTracker();
    public void OnStart(string providerName, string activityName, int task, Guid& activityId, Guid& relatedActivityId, EventActivityOptions options);
    public void OnStop(string providerName, string activityName, int task, Guid& activityId);
    [SecuritySafeCriticalAttribute]
public void Enable();
    public static ActivityTracker get_Instance();
    private Guid get_CurrentActivityId();
    private ActivityInfo FindActiveActivity(string name, ActivityInfo startLocation);
    private string NormalizeActivityName(string providerName, string activityName, int task);
    private void ActivityChanging(AsyncLocalValueChangedArgs`1<ActivityInfo> args);
}
internal class Microsoft.Diagnostics.Tracing.ArrayTypeInfo`1 : TraceLoggingTypeInfo`1<ElementType[]> {
    private TraceLoggingTypeInfo`1<ElementType> elementInfo;
    public ArrayTypeInfo`1(TraceLoggingTypeInfo`1<ElementType> elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, ElementType[]& value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.AsyncLocal`1 : object {
    public T Value { get; public set; }
    public AsyncLocal`1(Action`1<AsyncLocalValueChangedArgs`1<T>> valueChangedHandler);
    public T get_Value();
    public void set_Value(T value);
}
internal class Microsoft.Diagnostics.Tracing.AsyncLocalValueChangedArgs`1 : object {
    public T PreviousValue { get; }
    public T CurrentValue { get; }
    public T get_PreviousValue();
    public T get_CurrentValue();
}
internal class Microsoft.Diagnostics.Tracing.BooleanArrayTypeInfo : TraceLoggingTypeInfo`1<Boolean[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Boolean[]& value);
}
internal class Microsoft.Diagnostics.Tracing.BooleanTypeInfo : TraceLoggingTypeInfo`1<bool> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Boolean& value);
}
internal class Microsoft.Diagnostics.Tracing.ByteArrayTypeInfo : TraceLoggingTypeInfo`1<Byte[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Byte[]& value);
}
internal class Microsoft.Diagnostics.Tracing.ByteTypeInfo : TraceLoggingTypeInfo`1<byte> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Byte& value);
}
internal class Microsoft.Diagnostics.Tracing.CharArrayTypeInfo : TraceLoggingTypeInfo`1<Char[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Char[]& value);
}
internal class Microsoft.Diagnostics.Tracing.CharTypeInfo : TraceLoggingTypeInfo`1<char> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Char& value);
}
internal class Microsoft.Diagnostics.Tracing.ClassPropertyWriter`2 : PropertyAccessor`1<ContainerType> {
    private TraceLoggingTypeInfo`1<ValueType> valueTypeInfo;
    private Getter<ContainerType, ValueType> getter;
    public ClassPropertyWriter`2(PropertyAnalysis property);
    public virtual void Write(TraceLoggingDataCollector collector, ContainerType& container);
    public virtual object GetData(ContainerType container);
}
internal class Microsoft.Diagnostics.Tracing.ConcurrentSet`2 : ValueType {
    private ItemType[] items;
    public ItemType TryGet(KeyType key);
    public ItemType GetOrAdd(ItemType newItem);
}
internal abstract class Microsoft.Diagnostics.Tracing.ConcurrentSetItem`2 : object {
    public abstract virtual int Compare(ItemType other);
    public abstract virtual int Compare(KeyType key);
}
internal enum Microsoft.Diagnostics.Tracing.ControllerCommand : Enum {
    public int value__;
    public static ControllerCommand Update;
    public static ControllerCommand SendManifest;
    public static ControllerCommand Enable;
    public static ControllerCommand Disable;
}
[SecurityCriticalAttribute]
internal class Microsoft.Diagnostics.Tracing.DataCollector : ValueType {
    [ThreadStaticAttribute]
internal static DataCollector ThreadInstance;
    private Byte* scratchEnd;
    private EventData* datasEnd;
    private GCHandle* pinsEnd;
    private EventData* datasStart;
    private Byte* scratch;
    private EventData* datas;
    private GCHandle* pins;
    private Byte[] buffer;
    private int bufferPos;
    private int bufferNesting;
    private bool writingScalars;
    internal void Enable(Byte* scratch, int scratchSize, EventData* datas, int dataCount, GCHandle* pins, int pinCount);
    internal void Disable();
    internal EventData* Finish();
    internal void AddScalar(Void* value, int size);
    internal void AddBinary(string value, int size);
    internal void AddBinary(Array value, int size);
    internal void AddArray(Array value, int length, int itemSize);
    internal int BeginBufferedArray();
    internal void EndBufferedArray(int bookmark, int count);
    internal void BeginBuffered();
    internal void EndBuffered();
    private void EnsureBuffer();
    private void EnsureBuffer(int additionalSize);
    private void GrowBuffer(int required);
    private void PinArray(object value, int size);
    private void ScalarsBegin();
    private void ScalarsEnd();
}
internal class Microsoft.Diagnostics.Tracing.DateTimeOffsetTypeInfo : TraceLoggingTypeInfo`1<DateTimeOffset> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, DateTimeOffset& value);
}
internal class Microsoft.Diagnostics.Tracing.DateTimeTypeInfo : TraceLoggingTypeInfo`1<DateTime> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, DateTime& value);
}
internal class Microsoft.Diagnostics.Tracing.DecimalTypeInfo : TraceLoggingTypeInfo`1<decimal> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Decimal& value);
}
internal class Microsoft.Diagnostics.Tracing.DoubleArrayTypeInfo : TraceLoggingTypeInfo`1<Double[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Double[]& value);
}
internal class Microsoft.Diagnostics.Tracing.DoubleTypeInfo : TraceLoggingTypeInfo`1<double> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Double& value);
}
internal class Microsoft.Diagnostics.Tracing.EmptyStruct : ValueType {
}
internal class Microsoft.Diagnostics.Tracing.EnumByteTypeInfo`1 : TraceLoggingTypeInfo`1<EnumType> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, EnumType& value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.EnumerableTypeInfo`2 : TraceLoggingTypeInfo`1<IterableType> {
    private TraceLoggingTypeInfo`1<ElementType> elementInfo;
    public EnumerableTypeInfo`2(TraceLoggingTypeInfo`1<ElementType> elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, IterableType& value);
    public virtual object GetData(object value);
}
internal static class Microsoft.Diagnostics.Tracing.EnumHelper`1 : object {
    private static MethodInfo IdentityInfo;
    private static EnumHelper`1();
    public static UnderlyingType Cast(ValueType value);
    internal static UnderlyingType Identity(UnderlyingType value);
}
internal class Microsoft.Diagnostics.Tracing.EnumInt16TypeInfo`1 : TraceLoggingTypeInfo`1<EnumType> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, EnumType& value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.EnumInt32TypeInfo`1 : TraceLoggingTypeInfo`1<EnumType> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, EnumType& value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.EnumInt64TypeInfo`1 : TraceLoggingTypeInfo`1<EnumType> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, EnumType& value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.EnumSByteTypeInfo`1 : TraceLoggingTypeInfo`1<EnumType> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, EnumType& value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.EnumUInt16TypeInfo`1 : TraceLoggingTypeInfo`1<EnumType> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, EnumType& value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.EnumUInt32TypeInfo`1 : TraceLoggingTypeInfo`1<EnumType> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, EnumType& value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.EnumUInt64TypeInfo`1 : TraceLoggingTypeInfo`1<EnumType> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, EnumType& value);
    public virtual object GetData(object value);
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventActivityOptions : Enum {
    public int value__;
    public static EventActivityOptions None;
    public static EventActivityOptions Disable;
    public static EventActivityOptions Recursive;
    public static EventActivityOptions Detachable;
}
[AttributeUsageAttribute("64")]
public class Microsoft.Diagnostics.Tracing.EventAttribute : Attribute {
    private EventOpcode m_opcode;
    private bool m_opcodeSet;
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTask <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private EventActivityOptions <ActivityOptions>k__BackingField;
    public int EventId { get; private set; }
    public EventLevel Level { get; public set; }
    public EventKeywords Keywords { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventTask Task { get; public set; }
    public EventChannel Channel { get; public set; }
    public byte Version { get; public set; }
    public string Message { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventAttribute(int eventId);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(int value);
    [CompilerGeneratedAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(EventLevel value);
    [CompilerGeneratedAttribute]
public EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(EventKeywords value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    [CompilerGeneratedAttribute]
public EventTask get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(EventTask value);
    [CompilerGeneratedAttribute]
public EventChannel get_Channel();
    [CompilerGeneratedAttribute]
public void set_Channel(EventChannel value);
    [CompilerGeneratedAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(byte value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public EventTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventTags value);
    [CompilerGeneratedAttribute]
public EventActivityOptions get_ActivityOptions();
    [CompilerGeneratedAttribute]
public void set_ActivityOptions(EventActivityOptions value);
}
public enum Microsoft.Diagnostics.Tracing.EventChannel : Enum {
    public byte value__;
    public static EventChannel None;
    public static EventChannel Admin;
    public static EventChannel Operational;
    public static EventChannel Analytic;
    public static EventChannel Debug;
}
[AttributeUsageAttribute("256")]
internal class Microsoft.Diagnostics.Tracing.EventChannelAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannelType <EventChannelType>k__BackingField;
    public bool Enabled { get; public set; }
    public EventChannelType EventChannelType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public EventChannelType get_EventChannelType();
    [CompilerGeneratedAttribute]
public void set_EventChannelType(EventChannelType value);
}
internal enum Microsoft.Diagnostics.Tracing.EventChannelType : Enum {
    public int value__;
    public static EventChannelType Admin;
    public static EventChannelType Operational;
    public static EventChannelType Analytic;
    public static EventChannelType Debug;
}
public enum Microsoft.Diagnostics.Tracing.EventCommand : Enum {
    public int value__;
    public static EventCommand Update;
    public static EventCommand SendManifest;
    public static EventCommand Enable;
    public static EventCommand Disable;
}
public class Microsoft.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
    internal EventSource eventSource;
    internal EventDispatcher dispatcher;
    internal EventListener listener;
    internal int perEventSourceSessionId;
    internal int etwSessionId;
    internal bool enable;
    internal EventLevel level;
    internal EventKeywords matchAnyKeyword;
    internal EventCommandEventArgs nextCommand;
    [CompilerGeneratedAttribute]
private EventCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Arguments>k__BackingField;
    public EventCommand Command { get; internal set; }
    public IDictionary`2<string, string> Arguments { get; internal set; }
    internal EventCommandEventArgs(EventCommand command, IDictionary`2<string, string> arguments, EventSource eventSource, EventListener listener, int perEventSourceSessionId, int etwSessionId, bool enable, EventLevel level, EventKeywords matchAnyKeyword);
    [CompilerGeneratedAttribute]
public EventCommand get_Command();
    [CompilerGeneratedAttribute]
internal void set_Command(EventCommand value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Arguments();
    [CompilerGeneratedAttribute]
internal void set_Arguments(IDictionary`2<string, string> value);
    public bool EnableEvent(int eventId);
    public bool DisableEvent(int eventId);
}
public class Microsoft.Diagnostics.Tracing.EventCounter : object {
    private static int BufferedSize;
    private static float UnusedBufferSlotValue;
    private static int UnsetIndex;
    private string _name;
    private Single[] modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedValues;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedValuesIndex;
    private int _count;
    private float _sum;
    private float _sumSquared;
    private float _min;
    private float _max;
    public EventCounter(string name, EventSource eventSource);
    public void WriteMetric(float value);
    private void InitializeBuffer();
    private void Enqueue(float value);
    private void Flush();
    private void OnMetricWritten(float value);
    internal EventCounterPayload GetEventCounterPayload();
    private void ResetStatistics();
}
internal class Microsoft.Diagnostics.Tracing.EventCounterGroup : object {
    private EventSource _eventSource;
    private int _eventSourceIndex;
    private List`1<EventCounter> _eventCounters;
    private static EventCounterGroup[] s_eventCounterGroups;
    private DateTime _timeStampSinceCollectionStarted;
    private int _pollingIntervalInMilliseconds;
    private Timer _pollingTimer;
    private bool _disposed;
    internal EventCounterGroup(EventSource eventSource, int eventSourceIndex);
    private void Add(EventCounter eventCounter);
    private void RegisterCommandCallback();
    private void OnEventSourceCommand(object sender, EventCommandEventArgs e);
    internal static void AddEventCounter(EventSource eventSource, EventCounter eventCounter);
    private static void EnsureEventSourceIndexAvailable(int eventSourceIndex);
    private static EventCounterGroup GetEventCounterGroup(EventSource eventSource);
    private void EnableTimer(float pollingIntervalInSeconds);
    private void OnTimer(object state);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[EventDataAttribute]
internal class Microsoft.Diagnostics.Tracing.EventCounterPayload : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private float <StandardDerivation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private float <IntervalSec>k__BackingField;
    public string Name { get; public set; }
    public float Mean { get; public set; }
    public float StandardDerivation { get; public set; }
    public int Count { get; public set; }
    public float Min { get; public set; }
    public float Max { get; public set; }
    public float IntervalSec { get; internal set; }
    private IEnumerable`1<KeyValuePair`2<string, object>> ForEnumeration { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public float get_Mean();
    [CompilerGeneratedAttribute]
public void set_Mean(float value);
    [CompilerGeneratedAttribute]
public float get_StandardDerivation();
    [CompilerGeneratedAttribute]
public void set_StandardDerivation(float value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public float get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(float value);
    [CompilerGeneratedAttribute]
public float get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(float value);
    [CompilerGeneratedAttribute]
public float get_IntervalSec();
    [CompilerGeneratedAttribute]
internal void set_IntervalSec(float value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IEnumerable`1<KeyValuePair`2<string, object>> get_ForEnumeration();
}
[AttributeUsageAttribute("12")]
public class Microsoft.Diagnostics.Tracing.EventDataAttribute : Attribute {
    private EventLevel level;
    private EventOpcode opcode;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    public string Name { get; public set; }
    internal EventLevel Level { get; internal set; }
    internal EventOpcode Opcode { get; internal set; }
    internal EventKeywords Keywords { get; internal set; }
    internal EventTags Tags { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    internal EventLevel get_Level();
    internal void set_Level(EventLevel value);
    internal EventOpcode get_Opcode();
    internal void set_Opcode(EventOpcode value);
    [CompilerGeneratedAttribute]
internal EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
internal void set_Keywords(EventKeywords value);
    [CompilerGeneratedAttribute]
internal EventTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventTags value);
}
[HostProtectionAttribute]
internal class Microsoft.Diagnostics.Tracing.EventDescriptor : ValueType {
    private int m_traceloggingId;
    private ushort m_id;
    private byte m_version;
    private byte m_channel;
    private byte m_level;
    private byte m_opcode;
    private ushort m_task;
    private long m_keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    public EventDescriptor(int traceloggingId, byte level, byte opcode, long keywords);
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EventDescriptor other);
    public static bool op_Equality(EventDescriptor event1, EventDescriptor event2);
    public static bool op_Inequality(EventDescriptor event1, EventDescriptor event2);
}
internal class Microsoft.Diagnostics.Tracing.EventDispatcher : object {
    internal EventListener m_Listener;
    internal Boolean[] m_EventEnabled;
    internal EventDispatcher m_Next;
    internal EventDispatcher(EventDispatcher next, Boolean[] eventEnabled, EventListener listener);
}
[AttributeUsageAttribute("128")]
public class Microsoft.Diagnostics.Tracing.EventFieldAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventFieldFormat <Format>k__BackingField;
    public EventFieldTags Tags { get; public set; }
    internal string Name { get; internal set; }
    public EventFieldFormat Format { get; public set; }
    [CompilerGeneratedAttribute]
public EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventFieldTags value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public EventFieldFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(EventFieldFormat value);
}
public enum Microsoft.Diagnostics.Tracing.EventFieldFormat : Enum {
    public int value__;
    public static EventFieldFormat Default;
    public static EventFieldFormat String;
    public static EventFieldFormat Boolean;
    public static EventFieldFormat Hexadecimal;
    public static EventFieldFormat Xml;
    public static EventFieldFormat Json;
    public static EventFieldFormat HResult;
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventFieldTags : Enum {
    public int value__;
    public static EventFieldTags None;
}
[AttributeUsageAttribute("128")]
public class Microsoft.Diagnostics.Tracing.EventIgnoreAttribute : Attribute {
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventKeywords : Enum {
    public long value__;
    public static EventKeywords None;
    public static EventKeywords All;
    public static EventKeywords WdiContext;
    public static EventKeywords WdiDiagnostic;
    public static EventKeywords Sqm;
    public static EventKeywords AuditFailure;
    public static EventKeywords AuditSuccess;
    public static EventKeywords CorrelationHint;
    public static EventKeywords EventLogClassic;
}
public enum Microsoft.Diagnostics.Tracing.EventLevel : Enum {
    public int value__;
    public static EventLevel LogAlways;
    public static EventLevel Critical;
    public static EventLevel Error;
    public static EventLevel Warning;
    public static EventLevel Informational;
    public static EventLevel Verbose;
}
public abstract class Microsoft.Diagnostics.Tracing.EventListener : object {
    private EventHandler`1<EventSourceCreatedEventArgs> _EventSourceCreated;
    private EventHandler`1<EventWrittenEventArgs> EventWritten;
    internal EventListener modreq(System.Runtime.CompilerServices.IsVolatile) m_Next;
    internal static EventListener s_Listeners;
    internal static List`1<WeakReference> s_EventSources;
    private static bool s_CreatingListener;
    private static bool s_EventSourceShutdownRegistered;
    internal static object EventListenersLock { get; }
    private static EventListener();
    private void add__EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    private void remove__EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void add_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void remove_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void add_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    public void remove_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    public virtual void Dispose();
    public void EnableEvents(EventSource eventSource, EventLevel level);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments);
    public void DisableEvents(EventSource eventSource);
    public static int EventSourceIndex(EventSource eventSource);
    protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
    internal static void AddEventSource(EventSource newEventSource);
    private static void DisposeOnShutdown(object sender, EventArgs e);
    private static void RemoveReferencesToListenerInEventSources(EventListener listenerToRemove);
    [ConditionalAttribute("DEBUG")]
internal static void Validate();
    internal static object get_EventListenersLock();
    private void CallBackForExistingEventSources(bool addToListenersList, EventHandler`1<EventSourceCreatedEventArgs> callback);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(object obj, EventSourceCreatedEventArgs args);
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventManifestOptions : Enum {
    public int value__;
    public static EventManifestOptions None;
    public static EventManifestOptions Strict;
    public static EventManifestOptions AllCultures;
    public static EventManifestOptions OnlyIfNeededForRegistration;
    public static EventManifestOptions AllowEventSourceOverride;
}
public enum Microsoft.Diagnostics.Tracing.EventOpcode : Enum {
    public int value__;
    public static EventOpcode Info;
    public static EventOpcode Start;
    public static EventOpcode Stop;
    public static EventOpcode DataCollectionStart;
    public static EventOpcode DataCollectionStop;
    public static EventOpcode Extension;
    public static EventOpcode Reply;
    public static EventOpcode Resume;
    public static EventOpcode Suspend;
    public static EventOpcode Send;
    public static EventOpcode Receive;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Diagnostics.Tracing.EventPayload : object {
    private List`1<string> m_names;
    private List`1<object> m_values;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal EventPayload(List`1<string> payloadNames, List`1<object> payloadValues);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> payloadEntry);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> entry);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] payloadEntries, int count);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> entry);
    public sealed virtual bool TryGetValue(string key, Object& value);
}
[HostProtectionAttribute]
internal class Microsoft.Diagnostics.Tracing.EventProvider : object {
    private static int s_basicTypeAllocationBufferSize;
    private static int s_etwMaxNumberArguments;
    private static int s_etwAPIMaxRefObjCount;
    private static int s_maxEventDataDescriptors;
    private static int s_traceEventMaximumSize;
    private static int s_traceEventMaximumStringSize;
    private static bool m_setInformationMissing;
    [SecurityCriticalAttribute]
private EtwEnableCallback m_etwCallback;
    private long m_regHandle;
    private byte m_level;
    private long m_anyKeywordMask;
    private long m_allKeywordMask;
    private List`1<SessionInfo> m_liveSessions;
    private bool m_enabled;
    private Guid m_providerId;
    internal bool m_disposed;
    [ThreadStaticAttribute]
private static WriteEventErrorCode s_returnCode;
    private static Int32[] nibblebits;
    protected EventLevel Level { get; protected set; }
    protected EventKeywords MatchAnyKeyword { get; protected set; }
    protected EventKeywords MatchAllKeyword { get; protected set; }
    private static EventProvider();
    [SecurityCriticalAttribute]
internal void Register(Guid providerGuid);
    [SecurityCriticalAttribute]
internal int SetInformation(EVENT_INFO_CLASS eventInfoClass, Void* data, int dataSize);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public virtual void Close();
    protected virtual void Finalize();
    [SecurityCriticalAttribute]
private void Deregister();
    [SecurityCriticalAttribute]
private void EtwEnableCallBack(Guid& sourceId, int controlCode, byte setLevel, long anyKeyword, long allKeyword, EVENT_FILTER_DESCRIPTOR* filterData, Void* callbackContext);
    protected virtual void OnControllerCommand(ControllerCommand command, IDictionary`2<string, string> arguments, int sessionId, int etwSessionId);
    protected EventLevel get_Level();
    protected void set_Level(EventLevel value);
    protected EventKeywords get_MatchAnyKeyword();
    protected void set_MatchAnyKeyword(EventKeywords value);
    protected EventKeywords get_MatchAllKeyword();
    protected void set_MatchAllKeyword(EventKeywords value);
    private static int FindNull(Byte[] buffer, int idx);
    [SecuritySafeCriticalAttribute]
private List`1<Tuple`2<SessionInfo, bool>> GetSessions();
    private static void GetSessionInfoCallback(int etwSessionId, long matchAllKeywords, List`1& sessionList);
    [SecurityCriticalAttribute]
private void GetSessionInfo(Action`2<int, long> action);
    private static int IndexOfSessionInList(List`1<SessionInfo> sessions, int etwSessionId);
    [SecurityCriticalAttribute]
private bool GetDataFromController(int etwSessionId, EVENT_FILTER_DESCRIPTOR* filterData, ControllerCommand& command, Byte[]& data, Int32& dataStart);
    public bool IsEnabled();
    public bool IsEnabled(byte level, long keywords);
    public static WriteEventErrorCode GetLastWriteEventError();
    private static void SetLastError(int error);
    [SecurityCriticalAttribute]
private static object EncodeObject(Object& data, EventData*& dataDescriptor, Byte*& dataBuffer, UInt32& totalEventSize);
    [SecurityCriticalAttribute]
internal bool WriteEvent(EventDescriptor& eventDescriptor, Guid* activityID, Guid* childActivityID, Object[] eventPayload);
    [SecurityCriticalAttribute]
protected internal bool WriteEvent(EventDescriptor& eventDescriptor, Guid* activityID, Guid* childActivityID, int dataCount, IntPtr data);
    [SecurityCriticalAttribute]
internal bool WriteEventRaw(EventDescriptor& eventDescriptor, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    [SecurityCriticalAttribute]
private UInt32 EventRegister(Guid& providerId, EtwEnableCallback enableCallback);
    [SecurityCriticalAttribute]
private UInt32 EventUnregister();
    private static int bitcount(UInt32 n);
    private static int bitindex(UInt32 n);
}
public class Microsoft.Diagnostics.Tracing.EventSource : object {
    internal static string s_ActivityStartSuffix;
    internal static string s_ActivityStopSuffix;
    private string m_name;
    internal int m_id;
    private Guid m_guid;
    internal EventMetadata[] modreq(System.Runtime.CompilerServices.IsVolatile) m_eventData;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) m_rawManifest;
    private EventHandler`1<EventCommandEventArgs> m_eventCommandExecuted;
    private EventSourceSettings m_config;
    private bool m_eventSourceEnabled;
    internal EventLevel m_level;
    internal EventKeywords m_matchAnyKeyword;
    internal EventDispatcher modreq(System.Runtime.CompilerServices.IsVolatile) m_Dispatchers;
    private OverideEventProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_provider;
    private bool m_completelyInited;
    private Exception m_constructionException;
    private byte m_outOfBandMessageCount;
    private EventCommandEventArgs m_deferredCommands;
    private String[] m_traits;
    internal static UInt32 s_currentPid;
    [ThreadStaticAttribute]
private static byte m_EventSourceExceptionRecurenceCount;
    internal UInt64[] modreq(System.Runtime.CompilerServices.IsVolatile) m_channelData;
    private ActivityTracker m_activityTracker;
    private static Byte[] namespaceBytes;
    private Byte[] providerMetadata;
    public string Name { get; }
    public Guid Guid { get; }
    public EventSourceSettings Settings { get; }
    public static Guid CurrentThreadActivityId { get; }
    public Exception ConstructionException { get; }
    private bool IsDisposed { get; }
    private bool ThrowOnEventWriteErrors { get; private set; }
    private bool SelfDescribingEvents { get; private set; }
    protected EventSource(bool throwOnEventWriteErrors);
    protected EventSource(EventSourceSettings settings);
    protected EventSource(EventSourceSettings settings, String[] traits);
    internal EventSource(Guid eventSourceGuid, string eventSourceName);
    internal EventSource(Guid eventSourceGuid, string eventSourceName, EventSourceSettings settings, String[] traits);
    public EventSource(string eventSourceName);
    public EventSource(string eventSourceName, EventSourceSettings config);
    public EventSource(string eventSourceName, EventSourceSettings config, String[] traits);
    private static EventSource();
    public string get_Name();
    public Guid get_Guid();
    public bool IsEnabled();
    public bool IsEnabled(EventLevel level, EventKeywords keywords);
    public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
    public EventSourceSettings get_Settings();
    public static Guid GetGuid(Type eventSourceType);
    public static string GetName(Type eventSourceType);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
    public static IEnumerable`1<EventSource> GetSources();
    public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments);
    [SecuritySafeCriticalAttribute]
public static void SetCurrentThreadActivityId(Guid activityId);
    [SecuritySafeCriticalAttribute]
public static void SetCurrentThreadActivityId(Guid activityId, Guid& oldActivityThatWillContinue);
    [SecuritySafeCriticalAttribute]
public static Guid get_CurrentThreadActivityId();
    public Exception get_ConstructionException();
    public string GetTrait(string key);
    public virtual string ToString();
    public void add_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public void remove_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, int arg1);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, int arg1, int arg2);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, long arg1);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, long arg1, long arg2);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1, string arg2);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1, int arg2);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1, long arg2);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, long arg1, string arg2);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, int arg1, string arg2);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, Byte[] arg1);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, long arg1, Byte[] arg2);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
protected void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventData* data);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, Object[] args);
    [SecuritySafeCriticalAttribute]
protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, Object[] args);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void Finalize();
    [SecurityCriticalAttribute]
private void WriteEventRaw(EventDescriptor& eventDescriptor, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    [SecuritySafeCriticalAttribute]
private void Initialize(Guid eventSourceGuid, string eventSourceName, String[] traits);
    private static string GetName(Type eventSourceType, EventManifestOptions flags);
    private static Guid GenerateGuidFromName(string name);
    [SecurityCriticalAttribute]
private object DecodeObject(int eventId, int parameterId, EventData*& data);
    private EventDispatcher GetDispatcher(EventListener listener);
    [SecurityCriticalAttribute]
private void WriteEventVarargs(int eventId, Guid* childActivityID, Object[] args);
    [SecurityCriticalAttribute]
private Object[] SerializeEventArgs(int eventId, Object[] args);
    private void LogEventArgsMismatches(ParameterInfo[] infos, Object[] args);
    [SecurityCriticalAttribute]
private void WriteToAllListeners(int eventId, Guid* childActivityID, int eventDataCount, EventData* data);
    [SecurityCriticalAttribute]
private void WriteToAllListeners(int eventId, Guid* childActivityID, Object[] args);
    [SecurityCriticalAttribute]
private void DispatchToAllListeners(int eventId, Guid* childActivityID, EventWrittenEventArgs eventCallbackArgs);
    [SecuritySafeCriticalAttribute]
private void WriteEventString(EventLevel level, long keywords, string msgString);
    private void WriteStringToAllListeners(string eventName, string msg);
    private bool IsEnabledByDefault(int eventNum, bool enable, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword);
    private bool IsEnabledCommon(bool enabled, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword, EventLevel eventLevel, EventKeywords eventKeywords, EventChannel eventChannel);
    private void ThrowEventSourceException(Exception innerEx);
    private void ValidateEventOpcodeForTransfer(EventMetadata& eventData);
    internal static EventOpcode GetOpcodeWithDefault(EventOpcode opcode, string eventName);
    internal void SendCommand(EventListener listener, int perEventSourceSessionId, int etwSessionId, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> commandArguments);
    internal void DoCommand(EventCommandEventArgs commandArgs);
    internal bool EnableEventForDispatcher(EventDispatcher dispatcher, int eventId, bool value);
    private bool AnyEventEnabled();
    private bool get_IsDisposed();
    [SecuritySafeCriticalAttribute]
private void EnsureDescriptorsInitialized();
    [SecuritySafeCriticalAttribute]
private bool SendManifest(Byte[] rawManifest);
    internal static Attribute GetCustomAttributeHelper(Type type, Type attributeType, EventManifestOptions flags);
    internal static Attribute GetCustomAttributeHelper(MemberInfo member, Type attributeType, EventManifestOptions flags);
    private static bool AttributeTypeNamesMatch(Type attributeType, Type reflectedAttributeType);
    private static Type GetEventSourceBaseType(Type eventSourceType, bool allowEventSourceOverride, bool reflectionOnly);
    private static Byte[] CreateManifestAndDescriptors(Type eventSourceType, string eventSourceDllName, EventSource source, EventManifestOptions flags);
    private static bool RemoveFirstArgIfRelatedActivityId(ParameterInfo[]& args);
    private static void AddProviderEnumKind(ManifestBuilder manifest, FieldInfo staticField, string providerEnumKind);
    private static void AddEventDescriptor(EventMetadata[]& eventData, string eventName, EventAttribute eventAttribute, ParameterInfo[] eventParameters, bool hasRelatedActivityID);
    private static void TrimEventDescriptors(EventMetadata[]& eventData);
    internal void AddListener(EventListener listener);
    private static void DebugCheckEvent(Dictionary`2& eventsByName, EventMetadata[] eventData, MethodInfo method, EventAttribute eventAttribute, ManifestBuilder manifest, EventManifestOptions options);
    [SecuritySafeCriticalAttribute]
private static int GetHelperCallFirstArg(MethodInfo method);
    internal void ReportOutOfBandMessage(string msg, bool flush);
    private EventSourceSettings ValidateSettings(EventSourceSettings settings);
    private bool get_ThrowOnEventWriteErrors();
    private void set_ThrowOnEventWriteErrors(bool value);
    private bool get_SelfDescribingEvents();
    private void set_SelfDescribingEvents(bool value);
    [SecuritySafeCriticalAttribute]
public void Write(string eventName);
    [SecuritySafeCriticalAttribute]
public void Write(string eventName, EventSourceOptions options);
    [SecuritySafeCriticalAttribute]
public void Write(string eventName, T data);
    [SecuritySafeCriticalAttribute]
public void Write(string eventName, EventSourceOptions options, T data);
    [SecuritySafeCriticalAttribute]
public void Write(string eventName, EventSourceOptions& options, T& data);
    [SecuritySafeCriticalAttribute]
public void Write(string eventName, EventSourceOptions& options, Guid& activityId, Guid& relatedActivityId, T& data);
    [SecuritySafeCriticalAttribute]
private void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    [SecuritySafeCriticalAttribute]
private void WriteMultiMergeInner(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    [SecuritySafeCriticalAttribute]
internal void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, EventData* data);
    [SecuritySafeCriticalAttribute]
private void WriteImpl(string eventName, EventSourceOptions& options, T& data, Guid* pActivityId, Guid* pRelatedActivityId);
    [SecurityCriticalAttribute]
private void WriteToAllListeners(string eventName, EventDescriptor& eventDescriptor, EventTags tags, Guid* pActivityId, EventPayload payload);
    [NonEventAttribute]
[SecurityCriticalAttribute]
private void WriteCleanup(GCHandle* pPins, int cPins);
    private void InitializeProviderMetadata();
    private static int AddValueToMetaData(List`1<byte> metaData, string value);
    private static int HexDigit(char c);
    private NameInfo UpdateDescriptor(string name, TraceLoggingEventTypes eventInfo, EventSourceOptions& options, EventDescriptor& descriptor);
}
internal class Microsoft.Diagnostics.Tracing.EventSourceActivity : object {
    private EventSource eventSource;
    private EventSourceOptions startStopOptions;
    internal Guid activityId;
    private State state;
    private string eventName;
    internal static Guid s_empty;
    public EventSource EventSource { get; }
    public Guid Id { get; }
    private bool StartEventWasFired { get; }
    public EventSourceActivity(EventSource eventSource);
    public static EventSourceActivity op_Implicit(EventSource eventSource);
    public EventSource get_EventSource();
    public Guid get_Id();
    public EventSourceActivity Start(string eventName, EventSourceOptions options, T data);
    public EventSourceActivity Start(string eventName);
    public EventSourceActivity Start(string eventName, EventSourceOptions options);
    public EventSourceActivity Start(string eventName, T data);
    public void Stop(T data);
    public void Stop(string eventName);
    public void Stop(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options, T data);
    public void Write(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options);
    public void Write(string eventName);
    public void Write(EventSource source, string eventName, EventSourceOptions options, T data);
    public sealed virtual void Dispose();
    private EventSourceActivity Start(string eventName, EventSourceOptions& options, T& data);
    private void Write(EventSource eventSource, string eventName, EventSourceOptions& options, T& data);
    private void Stop(string eventName, T& data);
    private bool get_StartEventWasFired();
}
[AttributeUsageAttribute("4")]
public class Microsoft.Diagnostics.Tracing.EventSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalizationResources>k__BackingField;
    public string Name { get; public set; }
    public string Guid { get; public set; }
    public string LocalizationResources { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
public string get_LocalizationResources();
    [CompilerGeneratedAttribute]
public void set_LocalizationResources(string value);
}
public class Microsoft.Diagnostics.Tracing.EventSourceCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    public EventSource EventSource { get; internal set; }
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    [CompilerGeneratedAttribute]
internal void set_EventSource(EventSource value);
}
public class Microsoft.Diagnostics.Tracing.EventSourceException : Exception {
    public EventSourceException(string message);
    public EventSourceException(string message, Exception innerException);
    internal EventSourceException(Exception innerException);
}
public class Microsoft.Diagnostics.Tracing.EventSourceOptions : ValueType {
    internal static byte keywordsSet;
    internal static byte tagsSet;
    internal static byte levelSet;
    internal static byte opcodeSet;
    internal static byte activityOptionsSet;
    internal EventKeywords keywords;
    internal EventTags tags;
    internal EventActivityOptions activityOptions;
    internal byte level;
    internal byte opcode;
    internal byte valuesSet;
    public EventLevel Level { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventKeywords Keywords { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventLevel get_Level();
    public void set_Level(EventLevel value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    public EventKeywords get_Keywords();
    public void set_Keywords(EventKeywords value);
    public EventTags get_Tags();
    public void set_Tags(EventTags value);
    public EventActivityOptions get_ActivityOptions();
    public void set_ActivityOptions(EventActivityOptions value);
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventSourceSettings : Enum {
    public int value__;
    public static EventSourceSettings Default;
    public static EventSourceSettings ThrowOnEventWriteErrors;
    public static EventSourceSettings EtwManifestEventFormat;
    public static EventSourceSettings EtwSelfDescribingEventFormat;
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventTags : Enum {
    public int value__;
    public static EventTags None;
}
public enum Microsoft.Diagnostics.Tracing.EventTask : Enum {
    public int value__;
    public static EventTask None;
}
public class Microsoft.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
    private string m_message;
    private string m_eventName;
    private EventSource m_eventSource;
    private ReadOnlyCollection`1<string> m_payloadNames;
    internal EventTags m_tags;
    internal EventOpcode m_opcode;
    internal EventLevel m_level;
    internal EventKeywords m_keywords;
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RelatedActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<object> <Payload>k__BackingField;
    public string EventName { get; internal set; }
    public int EventId { get; internal set; }
    public Guid ActivityId { get; }
    public Guid RelatedActivityId { get; internal set; }
    public ReadOnlyCollection`1<object> Payload { get; internal set; }
    public ReadOnlyCollection`1<string> PayloadNames { get; internal set; }
    public EventSource EventSource { get; }
    public EventKeywords Keywords { get; }
    public EventOpcode Opcode { get; }
    public EventTask Task { get; }
    public EventTags Tags { get; }
    public string Message { get; internal set; }
    public EventChannel Channel { get; }
    public byte Version { get; }
    public EventLevel Level { get; }
    internal EventWrittenEventArgs(EventSource eventSource);
    public string get_EventName();
    internal void set_EventName(string value);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
internal void set_EventId(int value);
    [SecurityCriticalAttribute]
public Guid get_ActivityId();
    [SecurityCriticalAttribute]
[CompilerGeneratedAttribute]
public Guid get_RelatedActivityId();
    [CompilerGeneratedAttribute]
internal void set_RelatedActivityId(Guid value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<object> get_Payload();
    [CompilerGeneratedAttribute]
internal void set_Payload(ReadOnlyCollection`1<object> value);
    public ReadOnlyCollection`1<string> get_PayloadNames();
    internal void set_PayloadNames(ReadOnlyCollection`1<string> value);
    public EventSource get_EventSource();
    public EventKeywords get_Keywords();
    public EventOpcode get_Opcode();
    public EventTask get_Task();
    public EventTags get_Tags();
    public string get_Message();
    internal void set_Message(string value);
    public EventChannel get_Channel();
    public byte get_Version();
    public EventLevel get_Level();
}
internal class Microsoft.Diagnostics.Tracing.FieldMetadata : object {
    private string name;
    private int nameSize;
    private EventFieldTags tags;
    private Byte[] custom;
    private ushort fixedCount;
    private byte inType;
    private byte outType;
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, bool variableCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, ushort fixedCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, Byte[] custom);
    private FieldMetadata(string name, TraceLoggingDataType dataType, EventFieldTags tags, byte countFlags, ushort fixedCount, Byte[] custom);
    public void IncrementStructFieldCount();
    public void Encode(Int32& pos, Byte[] metadata);
}
internal class Microsoft.Diagnostics.Tracing.GuidArrayTypeInfo : TraceLoggingTypeInfo`1<Guid[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Guid[]& value);
}
internal class Microsoft.Diagnostics.Tracing.GuidTypeInfo : TraceLoggingTypeInfo`1<Guid> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Guid& value);
}
internal class Microsoft.Diagnostics.Tracing.Int16ArrayTypeInfo : TraceLoggingTypeInfo`1<Int16[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Int16[]& value);
}
internal class Microsoft.Diagnostics.Tracing.Int16TypeInfo : TraceLoggingTypeInfo`1<short> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Int16& value);
}
internal class Microsoft.Diagnostics.Tracing.Int32ArrayTypeInfo : TraceLoggingTypeInfo`1<Int32[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Int32[]& value);
}
internal class Microsoft.Diagnostics.Tracing.Int32TypeInfo : TraceLoggingTypeInfo`1<int> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Int32& value);
}
internal class Microsoft.Diagnostics.Tracing.Int64ArrayTypeInfo : TraceLoggingTypeInfo`1<Int64[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Int64[]& value);
}
internal class Microsoft.Diagnostics.Tracing.Int64TypeInfo : TraceLoggingTypeInfo`1<long> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Int64& value);
}
internal static class Microsoft.Diagnostics.Tracing.Internal.Environment : object {
    public static string NewLine;
    private static ResourceManager rm;
    public static int TickCount { get; }
    private static Environment();
    public static int get_TickCount();
    public static string GetResourceString(string key, Object[] args);
    public static string GetRuntimeResourceString(string key, Object[] args);
}
internal class Microsoft.Diagnostics.Tracing.IntPtrArrayTypeInfo : TraceLoggingTypeInfo`1<IntPtr[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, IntPtr[]& value);
}
internal class Microsoft.Diagnostics.Tracing.IntPtrTypeInfo : TraceLoggingTypeInfo`1<IntPtr> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, IntPtr& value);
}
internal class Microsoft.Diagnostics.Tracing.InvokeTypeInfo`1 : TraceLoggingTypeInfo`1<ContainerType> {
    private PropertyAnalysis[] properties;
    private PropertyAccessor`1[] accessors;
    public InvokeTypeInfo`1(TypeAnalysis typeAnalysis);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, ContainerType& value);
    public virtual object GetData(object value);
    public virtual void WriteObjectData(TraceLoggingDataCollector collector, object valueObj);
}
internal class Microsoft.Diagnostics.Tracing.KeyValuePairTypeInfo`2 : TraceLoggingTypeInfo`1<KeyValuePair`2<K, V>> {
    private TraceLoggingTypeInfo`1<K> keyInfo;
    private TraceLoggingTypeInfo`1<V> valueInfo;
    public KeyValuePairTypeInfo`2(List`1<Type> recursionCheck);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, KeyValuePair`2& value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.ManifestBuilder : object {
    private static int MaxCountChannels;
    private Dictionary`2<int, string> opcodeTab;
    private Dictionary`2<int, string> taskTab;
    private Dictionary`2<int, ChannelInfo> channelTab;
    private Dictionary`2<ulong, string> keywordTab;
    private Dictionary`2<string, Type> mapsTab;
    private Dictionary`2<string, string> stringTab;
    private ulong nextChannelKeywordBit;
    private StringBuilder sb;
    private StringBuilder events;
    private StringBuilder templates;
    private string providerName;
    private ResourceManager resources;
    private EventManifestOptions flags;
    private IList`1<string> errors;
    private Dictionary`2<string, List`1<int>> perEventByteArrayArgIndices;
    private string eventName;
    private int numParams;
    private List`1<int> byteArrArgIndices;
    [CompilerGeneratedAttribute]
private static Comparison`1<KeyValuePair`2<int, ChannelInfo>> CS$<>9__CachedAnonymousMethodDelegate2;
    public IList`1<string> Errors { get; }
    public ManifestBuilder(string providerName, Guid providerGuid, string dllName, ResourceManager resources, EventManifestOptions flags);
    public void AddOpcode(string name, int value);
    public void AddTask(string name, int value);
    public void AddKeyword(string name, ulong value);
    public void AddChannel(string name, int value, EventChannelAttribute channelAttribute);
    private EventChannelType EventChannelToChannelType(EventChannel channel);
    private EventChannelAttribute GetDefaultChannelAttribute(EventChannel channel);
    public UInt64[] GetChannelData();
    public void StartEvent(string eventName, EventAttribute eventAttribute);
    public void AddEventParameter(Type type, string name);
    public void EndEvent();
    public ulong GetChannelKeyword(EventChannel channel);
    public Byte[] CreateManifest();
    public IList`1<string> get_Errors();
    public void ManifestError(string msg, bool runtimeCritical);
    private string CreateManifestString();
    private void WriteNameAndMessageAttribs(StringBuilder stringBuilder, string elementName, string name);
    private void WriteMessageAttrib(StringBuilder stringBuilder, string elementName, string name, string value);
    internal string GetLocalizedMessage(string key, CultureInfo ci, bool etwFormat);
    private static List`1<CultureInfo> GetSupportedCultures(ResourceManager resources);
    private static string GetLevelName(EventLevel level);
    private string GetChannelName(EventChannel channel, string eventName, string eventMessage);
    private string GetTaskName(EventTask task, string eventName);
    private string GetOpcodeName(EventOpcode opcode, string eventName);
    private string GetKeywords(ulong keywords, string eventName);
    private string GetTypeName(Type type);
    private static void UpdateStringBuilder(StringBuilder& stringBuilder, string eventMessage, int startIndex, int count);
    private string TranslateToManifestConvention(string eventMessage, string evtName);
    private int TranslateIndexToManifestConvention(int idx, string evtName);
    [CompilerGeneratedAttribute]
private static int <CreateManifestString>b__1(KeyValuePair`2<int, ChannelInfo> p1, KeyValuePair`2<int, ChannelInfo> p2);
}
internal class Microsoft.Diagnostics.Tracing.ManifestEnvelope : ValueType {
    public static int MaxChunkSize;
    public ManifestFormats Format;
    public byte MajorVersion;
    public byte MinorVersion;
    public byte Magic;
    public ushort TotalChunks;
    public ushort ChunkNumber;
}
internal class Microsoft.Diagnostics.Tracing.NameInfo : ConcurrentSetItem`2<KeyValuePair`2<string, EventTags>, NameInfo> {
    private static int lastIdentity;
    internal string name;
    internal EventTags tags;
    internal int identity;
    internal Byte[] nameMetadata;
    public NameInfo(string name, EventTags tags, int typeMetadataSize);
    private static NameInfo();
    internal static void ReserveEventIDsBelow(int eventId);
    public virtual int Compare(NameInfo other);
    public virtual int Compare(KeyValuePair`2<string, EventTags> key);
    private int Compare(string otherName, EventTags otherTags);
}
[AttributeUsageAttribute("64")]
public class Microsoft.Diagnostics.Tracing.NonEventAttribute : Attribute {
}
internal class Microsoft.Diagnostics.Tracing.NonGenericProperytWriter`1 : PropertyAccessor`1<ContainerType> {
    private TraceLoggingTypeInfo typeInfo;
    private MethodInfo getterInfo;
    public NonGenericProperytWriter`1(PropertyAnalysis property);
    public virtual void Write(TraceLoggingDataCollector collector, ContainerType& container);
    public virtual object GetData(ContainerType container);
}
internal class Microsoft.Diagnostics.Tracing.NullableTypeInfo`1 : TraceLoggingTypeInfo`1<Nullable`1<T>> {
    private TraceLoggingTypeInfo`1<T> valueInfo;
    public NullableTypeInfo`1(List`1<Type> recursionCheck);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Nullable`1& value);
}
internal class Microsoft.Diagnostics.Tracing.NullTypeInfo`1 : TraceLoggingTypeInfo`1<DataType> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, DataType& value);
    public virtual object GetData(object value);
}
internal abstract class Microsoft.Diagnostics.Tracing.PropertyAccessor`1 : object {
    public abstract virtual void Write(TraceLoggingDataCollector collector, ContainerType& value);
    public abstract virtual object GetData(ContainerType value);
    public static PropertyAccessor`1<ContainerType> Create(PropertyAnalysis property);
}
internal class Microsoft.Diagnostics.Tracing.PropertyAnalysis : object {
    internal string name;
    internal MethodInfo getterInfo;
    internal TraceLoggingTypeInfo typeInfo;
    internal EventFieldAttribute fieldAttribute;
    public PropertyAnalysis(string name, MethodInfo getterInfo, TraceLoggingTypeInfo typeInfo, EventFieldAttribute fieldAttribute);
}
internal class Microsoft.Diagnostics.Tracing.SByteArrayTypeInfo : TraceLoggingTypeInfo`1<SByte[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, SByte[]& value);
}
internal class Microsoft.Diagnostics.Tracing.SByteTypeInfo : TraceLoggingTypeInfo`1<sbyte> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, SByte& value);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Diagnostics.Tracing.SessionMask : ValueType {
    internal static int SHIFT_SESSION_TO_KEYWORD;
    internal static UInt32 MASK;
    internal static UInt32 MAX;
    private UInt32 m_mask;
    public static SessionMask All { get; }
    public bool Item { get; public set; }
    public SessionMask(SessionMask m);
    public SessionMask(UInt32 mask);
    public bool IsEqualOrSupersetOf(SessionMask m);
    public static SessionMask get_All();
    public static SessionMask FromId(int perEventSourceSessionId);
    public ulong ToEventKeywords();
    public static SessionMask FromEventKeywords(ulong m);
    public bool get_Item(int perEventSourceSessionId);
    public void set_Item(int perEventSourceSessionId, bool value);
    public static SessionMask op_BitwiseOr(SessionMask m1, SessionMask m2);
    public static SessionMask op_BitwiseAnd(SessionMask m1, SessionMask m2);
    public static SessionMask op_ExclusiveOr(SessionMask m1, SessionMask m2);
    public static SessionMask op_OnesComplement(SessionMask m);
    public static ulong op_Explicit(SessionMask m);
    public static UInt32 op_Explicit(SessionMask m);
}
internal class Microsoft.Diagnostics.Tracing.SimpleEventTypes`1 : TraceLoggingEventTypes {
    private static SimpleEventTypes`1<T> instance;
    internal TraceLoggingTypeInfo`1<T> typeInfo;
    public static SimpleEventTypes`1<T> Instance { get; }
    private SimpleEventTypes`1(TraceLoggingTypeInfo`1<T> typeInfo);
    public static SimpleEventTypes`1<T> get_Instance();
    private static SimpleEventTypes`1<T> InitInstance();
}
internal class Microsoft.Diagnostics.Tracing.SingleArrayTypeInfo : TraceLoggingTypeInfo`1<Single[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Single[]& value);
}
internal class Microsoft.Diagnostics.Tracing.SingleTypeInfo : TraceLoggingTypeInfo`1<float> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, Single& value);
}
internal static class Microsoft.Diagnostics.Tracing.Statics : object {
    public static byte DefaultLevel;
    public static byte TraceLoggingChannel;
    public static byte InTypeMask;
    public static byte InTypeFixedCountFlag;
    public static byte InTypeVariableCountFlag;
    public static byte InTypeCustomCountFlag;
    public static byte InTypeCountMask;
    public static byte InTypeChainFlag;
    public static byte OutTypeMask;
    public static byte OutTypeChainFlag;
    public static EventTags EventTagsMask;
    public static TraceLoggingDataType IntPtrType;
    public static TraceLoggingDataType UIntPtrType;
    public static TraceLoggingDataType HexIntPtrType;
    private static Statics();
    public static Byte[] MetadataForString(string name, int prefixSize, int suffixSize, int additionalSize);
    public static void EncodeTags(int tags, Int32& pos, Byte[] metadata);
    public static byte Combine(int settingValue, byte defaultValue);
    public static byte Combine(int settingValue1, int settingValue2, byte defaultValue);
    public static int Combine(int settingValue1, int settingValue2);
    public static void CheckName(string name);
    public static bool ShouldOverrideFieldName(string fieldName);
    public static TraceLoggingDataType MakeDataType(TraceLoggingDataType baseType, EventFieldFormat format);
    public static TraceLoggingDataType Format8(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format16(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format32(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format64(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType FormatPtr(EventFieldFormat format, TraceLoggingDataType native);
    public static object CreateInstance(Type type, Object[] parameters);
    public static bool IsValueType(Type type);
    public static bool IsEnum(Type type);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    public static MethodInfo GetGetMethod(PropertyInfo propInfo);
    public static MethodInfo GetDeclaredStaticMethod(Type declaringType, string name);
    public static bool HasCustomAttribute(PropertyInfo propInfo, Type attributeType);
    public static AttributeType GetCustomAttribute(PropertyInfo propInfo);
    public static AttributeType GetCustomAttribute(Type type);
    public static Type[] GetGenericArguments(Type type);
    public static Type FindEnumerableElementType(Type type);
    public static bool IsGenericMatch(Type type, object openType);
    public static Delegate CreateDelegate(Type delegateType, MethodInfo methodInfo);
    public static TraceLoggingTypeInfo GetTypeInfoInstance(Type dataType, List`1<Type> recursionCheck);
    public static TraceLoggingTypeInfo`1<DataType> CreateDefaultTypeInfo(List`1<Type> recursionCheck);
}
internal class Microsoft.Diagnostics.Tracing.StringTypeInfo : TraceLoggingTypeInfo`1<string> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, String& value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.StructPropertyWriter`2 : PropertyAccessor`1<ContainerType> {
    private TraceLoggingTypeInfo`1<ValueType> valueTypeInfo;
    private Getter<ContainerType, ValueType> getter;
    public StructPropertyWriter`2(PropertyAnalysis property);
    public virtual void Write(TraceLoggingDataCollector collector, ContainerType& container);
    public virtual object GetData(ContainerType container);
}
internal class Microsoft.Diagnostics.Tracing.TimeSpanTypeInfo : TraceLoggingTypeInfo`1<TimeSpan> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, TimeSpan& value);
}
[EventSourceAttribute]
internal class Microsoft.Diagnostics.Tracing.TplEtwProvider : EventSource {
    public static TplEtwProvider Log;
    public bool Debug { get; }
    private static TplEtwProvider();
    public bool get_Debug();
    public void DebugFacilityMessage(string Facility, string Message);
    public void DebugFacilityMessage1(string Facility, string Message, string Arg);
    public void SetActivityId(Guid Id);
}
[SecuritySafeCriticalAttribute]
internal class Microsoft.Diagnostics.Tracing.TraceLoggingDataCollector : object {
    internal static TraceLoggingDataCollector Instance;
    private static TraceLoggingDataCollector();
    public int BeginBufferedArray();
    public void EndBufferedArray(int bookmark, int count);
    public TraceLoggingDataCollector AddGroup();
    public void AddScalar(bool value);
    public void AddScalar(sbyte value);
    public void AddScalar(byte value);
    public void AddScalar(short value);
    public void AddScalar(ushort value);
    public void AddScalar(int value);
    public void AddScalar(UInt32 value);
    public void AddScalar(long value);
    public void AddScalar(ulong value);
    public void AddScalar(IntPtr value);
    public void AddScalar(UIntPtr value);
    public void AddScalar(float value);
    public void AddScalar(double value);
    public void AddScalar(char value);
    public void AddScalar(Guid value);
    public void AddBinary(string value);
    public void AddBinary(Byte[] value);
    public void AddArray(Boolean[] value);
    public void AddArray(SByte[] value);
    public void AddArray(Int16[] value);
    public void AddArray(UInt16[] value);
    public void AddArray(Int32[] value);
    public void AddArray(UInt32[] value);
    public void AddArray(Int64[] value);
    public void AddArray(UInt64[] value);
    public void AddArray(IntPtr[] value);
    public void AddArray(UIntPtr[] value);
    public void AddArray(Single[] value);
    public void AddArray(Double[] value);
    public void AddArray(Char[] value);
    public void AddArray(Guid[] value);
    public void AddCustom(Byte[] value);
}
internal enum Microsoft.Diagnostics.Tracing.TraceLoggingDataType : Enum {
    public int value__;
    public static TraceLoggingDataType Nil;
    public static TraceLoggingDataType Utf16String;
    public static TraceLoggingDataType MbcsString;
    public static TraceLoggingDataType Int8;
    public static TraceLoggingDataType UInt8;
    public static TraceLoggingDataType Int16;
    public static TraceLoggingDataType UInt16;
    public static TraceLoggingDataType Int32;
    public static TraceLoggingDataType UInt32;
    public static TraceLoggingDataType Int64;
    public static TraceLoggingDataType UInt64;
    public static TraceLoggingDataType Float;
    public static TraceLoggingDataType Double;
    public static TraceLoggingDataType Boolean32;
    public static TraceLoggingDataType Binary;
    public static TraceLoggingDataType Guid;
    public static TraceLoggingDataType FileTime;
    public static TraceLoggingDataType SystemTime;
    public static TraceLoggingDataType HexInt32;
    public static TraceLoggingDataType HexInt64;
    public static TraceLoggingDataType CountedUtf16String;
    public static TraceLoggingDataType CountedMbcsString;
    public static TraceLoggingDataType Struct;
    public static TraceLoggingDataType Char16;
    public static TraceLoggingDataType Char8;
    public static TraceLoggingDataType Boolean8;
    public static TraceLoggingDataType HexInt8;
    public static TraceLoggingDataType HexInt16;
    public static TraceLoggingDataType Utf16Xml;
    public static TraceLoggingDataType MbcsXml;
    public static TraceLoggingDataType CountedUtf16Xml;
    public static TraceLoggingDataType CountedMbcsXml;
    public static TraceLoggingDataType Utf16Json;
    public static TraceLoggingDataType MbcsJson;
    public static TraceLoggingDataType CountedUtf16Json;
    public static TraceLoggingDataType CountedMbcsJson;
    public static TraceLoggingDataType HResult;
}
internal class Microsoft.Diagnostics.Tracing.TraceLoggingEventTypes : object {
    internal TraceLoggingTypeInfo[] typeInfos;
    internal string name;
    internal EventTags tags;
    internal byte level;
    internal byte opcode;
    internal EventKeywords keywords;
    internal Byte[] typeMetadata;
    internal int scratchSize;
    internal int dataCount;
    internal int pinCount;
    private ConcurrentSet`2<KeyValuePair`2<string, EventTags>, NameInfo> nameInfos;
    internal string Name { get; }
    internal EventLevel Level { get; }
    internal EventOpcode Opcode { get; }
    internal EventKeywords Keywords { get; }
    internal EventTags Tags { get; }
    internal TraceLoggingEventTypes(string name, EventTags tags, Type[] types);
    internal TraceLoggingEventTypes(string name, EventTags tags, TraceLoggingTypeInfo[] typeInfos);
    internal TraceLoggingEventTypes(string name, EventTags tags, ParameterInfo[] paramInfos);
    private TraceLoggingEventTypes(EventTags tags, string defaultName, TraceLoggingTypeInfo[] typeInfos);
    internal string get_Name();
    internal EventLevel get_Level();
    internal EventOpcode get_Opcode();
    internal EventKeywords get_Keywords();
    internal EventTags get_Tags();
    internal NameInfo GetNameInfo(string name, EventTags tags);
    private TraceLoggingTypeInfo[] MakeArray(ParameterInfo[] paramInfos);
    private static TraceLoggingTypeInfo[] MakeArray(Type[] types);
    private static TraceLoggingTypeInfo[] MakeArray(TraceLoggingTypeInfo[] typeInfos);
}
internal class Microsoft.Diagnostics.Tracing.TraceLoggingMetadataCollector : object {
    private Impl impl;
    private FieldMetadata currentGroup;
    private int bufferedArrayFieldCount;
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    internal EventFieldTags Tags { get; internal set; }
    internal int ScratchSize { get; }
    internal int DataCount { get; }
    internal int PinCount { get; }
    private bool BeginningBufferedArray { get; }
    private TraceLoggingMetadataCollector(TraceLoggingMetadataCollector other, FieldMetadata group);
    [CompilerGeneratedAttribute]
internal EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventFieldTags value);
    internal int get_ScratchSize();
    internal int get_DataCount();
    internal int get_PinCount();
    private bool get_BeginningBufferedArray();
    public TraceLoggingMetadataCollector AddGroup(string name);
    public void AddScalar(string name, TraceLoggingDataType type);
    public void AddBinary(string name, TraceLoggingDataType type);
    public void AddArray(string name, TraceLoggingDataType type);
    public void BeginBufferedArray();
    public void EndBufferedArray();
    public void AddCustom(string name, TraceLoggingDataType type, Byte[] metadata);
    internal Byte[] GetMetadata();
    private void AddField(FieldMetadata fieldMetadata);
}
internal abstract class Microsoft.Diagnostics.Tracing.TraceLoggingTypeInfo : object {
    private string name;
    private EventKeywords keywords;
    private EventLevel level;
    private EventOpcode opcode;
    private EventTags tags;
    private Type dataType;
    public string Name { get; }
    public EventLevel Level { get; }
    public EventOpcode Opcode { get; }
    public EventKeywords Keywords { get; }
    public EventTags Tags { get; }
    internal Type DataType { get; }
    internal TraceLoggingTypeInfo(Type dataType);
    internal TraceLoggingTypeInfo(Type dataType, string name, EventLevel level, EventOpcode opcode, EventKeywords keywords, EventTags tags);
    public string get_Name();
    public EventLevel get_Level();
    public EventOpcode get_Opcode();
    public EventKeywords get_Keywords();
    public EventTags get_Tags();
    internal Type get_DataType();
    public abstract virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public abstract virtual void WriteObjectData(TraceLoggingDataCollector collector, object value);
    public virtual object GetData(object value);
}
internal abstract class Microsoft.Diagnostics.Tracing.TraceLoggingTypeInfo`1 : TraceLoggingTypeInfo {
    private static TraceLoggingTypeInfo`1<DataType> instance;
    public static TraceLoggingTypeInfo`1<DataType> Instance { get; }
    protected TraceLoggingTypeInfo`1(string name, EventLevel level, EventOpcode opcode, EventKeywords keywords, EventTags tags);
    public static TraceLoggingTypeInfo`1<DataType> get_Instance();
    public abstract virtual void WriteData(TraceLoggingDataCollector collector, DataType& value);
    public virtual void WriteObjectData(TraceLoggingDataCollector collector, object value);
    internal static TraceLoggingTypeInfo`1<DataType> GetInstance(List`1<Type> recursionCheck);
    private static TraceLoggingTypeInfo`1<DataType> InitInstance();
}
internal class Microsoft.Diagnostics.Tracing.TypeAnalysis : object {
    internal PropertyAnalysis[] properties;
    internal string name;
    internal EventKeywords keywords;
    internal EventLevel level;
    internal EventOpcode opcode;
    internal EventTags tags;
    public TypeAnalysis(Type dataType, EventDataAttribute eventAttrib, List`1<Type> recursionCheck);
}
internal class Microsoft.Diagnostics.Tracing.UInt16ArrayTypeInfo : TraceLoggingTypeInfo`1<UInt16[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, UInt16[]& value);
}
internal class Microsoft.Diagnostics.Tracing.UInt16TypeInfo : TraceLoggingTypeInfo`1<ushort> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, UInt16& value);
}
internal class Microsoft.Diagnostics.Tracing.UInt32ArrayTypeInfo : TraceLoggingTypeInfo`1<UInt32[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, UInt32[]& value);
}
internal class Microsoft.Diagnostics.Tracing.UInt32TypeInfo : TraceLoggingTypeInfo`1<UInt32> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, UInt32& value);
}
internal class Microsoft.Diagnostics.Tracing.UInt64ArrayTypeInfo : TraceLoggingTypeInfo`1<UInt64[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, UInt64[]& value);
}
internal class Microsoft.Diagnostics.Tracing.UInt64TypeInfo : TraceLoggingTypeInfo`1<ulong> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, UInt64& value);
}
internal class Microsoft.Diagnostics.Tracing.UIntPtrArrayTypeInfo : TraceLoggingTypeInfo`1<UIntPtr[]> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, UIntPtr[]& value);
}
internal class Microsoft.Diagnostics.Tracing.UIntPtrTypeInfo : TraceLoggingTypeInfo`1<UIntPtr> {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, UIntPtr& value);
}
[FlagsAttribute]
public enum Microsoft.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Instance;
    public static BindingFlags Static;
    public static BindingFlags Public;
    public static BindingFlags NonPublic;
}
[ExtensionAttribute]
internal static class Microsoft.Reflection.ReflectionExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate1c;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate1f;
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static MethodInfo[] GetMethods(Type type, BindingFlags flags);
    [ExtensionAttribute]
public static FieldInfo[] GetFields(Type type, BindingFlags flags);
    [ExtensionAttribute]
public static Type GetNestedType(Type type, string nestedTypeName);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static object GetRawConstantValue(FieldInfo fi);
    [ExtensionAttribute]
public static bool ReflectionOnly(Assembly assm);
    [CompilerGeneratedAttribute]
private static bool <GetMethods>b__0(MethodInfo mi);
    [CompilerGeneratedAttribute]
private static bool <GetMethods>b__1(MethodInfo mi);
    [CompilerGeneratedAttribute]
private static bool <GetMethods>b__2(MethodInfo mi);
    [CompilerGeneratedAttribute]
private static bool <GetMethods>b__3(MethodInfo mi);
    [CompilerGeneratedAttribute]
private static bool <GetMethods>b__4(MethodInfo mi);
    [CompilerGeneratedAttribute]
private static bool <GetMethods>b__5(MethodInfo mi);
    [CompilerGeneratedAttribute]
private static bool <GetMethods>b__6(MethodInfo mi);
    [CompilerGeneratedAttribute]
private static bool <GetMethods>b__7(MethodInfo mi);
    [CompilerGeneratedAttribute]
private static bool <GetFields>b__10(FieldInfo fi);
    [CompilerGeneratedAttribute]
private static bool <GetFields>b__11(FieldInfo fi);
    [CompilerGeneratedAttribute]
private static bool <GetFields>b__12(FieldInfo fi);
    [CompilerGeneratedAttribute]
private static bool <GetFields>b__13(FieldInfo fi);
    [CompilerGeneratedAttribute]
private static bool <GetFields>b__14(FieldInfo fi);
    [CompilerGeneratedAttribute]
private static bool <GetFields>b__15(FieldInfo fi);
    [CompilerGeneratedAttribute]
private static bool <GetFields>b__16(FieldInfo fi);
    [CompilerGeneratedAttribute]
private static bool <GetFields>b__17(FieldInfo fi);
}
public enum Microsoft.Reflection.TypeCode : Enum {
    public int value__;
    public static TypeCode Empty;
    public static TypeCode Object;
    public static TypeCode DBNull;
    public static TypeCode Boolean;
    public static TypeCode Char;
    public static TypeCode SByte;
    public static TypeCode Byte;
    public static TypeCode Int16;
    public static TypeCode UInt16;
    public static TypeCode Int32;
    public static TypeCode UInt32;
    public static TypeCode Int64;
    public static TypeCode UInt64;
    public static TypeCode Single;
    public static TypeCode Double;
    public static TypeCode Decimal;
    public static TypeCode DateTime;
    public static TypeCode String;
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class Microsoft.Win32.UnsafeNativeMethods : object {
    private static string EventingProviderApiSet;
    private static string EventingControllerApiSet;
}
internal static class Microsoft.Win32.Win32Native : object {
    private static string CoreProcessThreadsApiSet;
    private static string CoreLocalizationApiSet;
    private static int FORMAT_MESSAGE_IGNORE_INSERTS;
    private static int FORMAT_MESSAGE_FROM_SYSTEM;
    private static int FORMAT_MESSAGE_ARGUMENT_ARRAY;
    [SecurityCriticalAttribute]
internal static int FormatMessageW(int dwFlags, IntPtr lpSource, int dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr va_list_arguments);
    [SecuritySafeCriticalAttribute]
internal static string GetMessage(int errorCode);
    [SecurityCriticalAttribute]
internal static UInt32 GetCurrentProcessId();
}
internal class System.Security.Permissions.HostProtectionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <MayLeakOnAbort>k__BackingField;
    public bool MayLeakOnAbort { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_MayLeakOnAbort();
    [CompilerGeneratedAttribute]
public void set_MayLeakOnAbort(bool value);
}
internal class System.Security.Permissions.PermissionSetAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Unrestricted>k__BackingField;
    public bool Unrestricted { get; public set; }
    public PermissionSetAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public bool get_Unrestricted();
    [CompilerGeneratedAttribute]
public void set_Unrestricted(bool value);
}
internal enum System.Security.SecurityAction : Enum {
    public int value__;
    public static SecurityAction Demand;
}
internal class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
