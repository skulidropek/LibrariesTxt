internal class Generator.AttributeDataComparer : object {
    public sealed virtual bool Equals(AttributeData x, AttributeData y);
    public sealed virtual int GetHashCode(AttributeData obj);
}
[IsReadOnlyAttribute]
internal class Generator.BindableCustomProperties : ValueType {
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGlobalNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private EquatableArray`1<TypeInfo> <ClassHierarchy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QualifiedClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private EquatableArray`1<BindableCustomProperty> <Properties>k__BackingField;
    public string Namespace { get; public set; }
    public bool IsGlobalNamespace { get; public set; }
    public string ClassName { get; public set; }
    public EquatableArray`1<TypeInfo> ClassHierarchy { get; public set; }
    public string QualifiedClassName { get; public set; }
    public EquatableArray`1<BindableCustomProperty> Properties { get; public set; }
    public BindableCustomProperties(string Namespace, bool IsGlobalNamespace, string ClassName, EquatableArray`1<TypeInfo> ClassHierarchy, string QualifiedClassName, EquatableArray`1<BindableCustomProperty> Properties);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Namespace(string value);
    [CompilerGeneratedAttribute]
public bool get_IsGlobalNamespace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsGlobalNamespace(bool value);
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ClassName(string value);
    [CompilerGeneratedAttribute]
public EquatableArray`1<TypeInfo> get_ClassHierarchy();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ClassHierarchy(EquatableArray`1<TypeInfo> value);
    [CompilerGeneratedAttribute]
public string get_QualifiedClassName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QualifiedClassName(string value);
    [CompilerGeneratedAttribute]
public EquatableArray`1<BindableCustomProperty> get_Properties();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Properties(EquatableArray`1<BindableCustomProperty> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BindableCustomProperties left, BindableCustomProperties right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BindableCustomProperties left, BindableCustomProperties right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BindableCustomProperties other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Namespace, Boolean& IsGlobalNamespace, String& ClassName, EquatableArray`1& ClassHierarchy, String& QualifiedClassName, EquatableArray`1& Properties);
}
[IsReadOnlyAttribute]
internal class Generator.BindableCustomProperty : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIndexer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexerType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    public string Name { get; public set; }
    public string Type { get; public set; }
    public bool CanRead { get; public set; }
    public bool CanWrite { get; public set; }
    public bool IsIndexer { get; public set; }
    public string IndexerType { get; public set; }
    public bool IsStatic { get; public set; }
    public BindableCustomProperty(string Name, string Type, bool CanRead, bool CanWrite, bool IsIndexer, string IndexerType, bool IsStatic);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Type(string value);
    [CompilerGeneratedAttribute]
public bool get_CanRead();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CanRead(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanWrite();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CanWrite(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsIndexer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsIndexer(bool value);
    [CompilerGeneratedAttribute]
public string get_IndexerType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IndexerType(string value);
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsStatic(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BindableCustomProperty left, BindableCustomProperty right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BindableCustomProperty left, BindableCustomProperty right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BindableCustomProperty other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name, String& Type, Boolean& CanRead, Boolean& CanWrite, Boolean& IsIndexer, String& IndexerType, Boolean& IsStatic);
}
public class Generator.ComponentGenerator : object {
    [CompilerGeneratedAttribute]
private Logger <Logger>k__BackingField;
    private GeneratorExecutionContext context;
    private string tempFolder;
    private TypeMapper mapper;
    private Logger Logger { get; }
    public ComponentGenerator(GeneratorExecutionContext context);
    [CompilerGeneratedAttribute]
private Logger get_Logger();
    private string GetTempFolder(bool clearSourceFilesFromFolder);
    private void GenerateSources();
    private void GenerateWinMD(MetadataBuilder metadataBuilder);
    private bool CatchWinRTDiagnostics();
    public void Generate();
    private static bool ShouldEmitCallToTryGetDependentActivationFactory(GeneratorExecutionContext context);
    public static void GenerateWinRTNativeExports(GeneratorExecutionContext context);
    public static void GenerateWinRTExportsType(GeneratorExecutionContext context);
}
[ExtensionAttribute]
internal static class Generator.GeneratorExecutionContextHelper : object {
    [ExtensionAttribute]
public static string GetAssemblyName(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static string GetAssemblyVersion(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static string GetGeneratedFilesDir(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static string GetCsWinRTExeTFM(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static bool IsCsWinRTComponent(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static bool IsCsWinRTComponent(AnalyzerConfigOptionsProvider provider);
    [ExtensionAttribute]
public static bool IsCsWinRTAotOptimizerEnabled(AnalyzerConfigOptionsProvider provider);
    [ExtensionAttribute]
public static bool GetCsWinRTRcwFactoryFallbackGeneratorForceOptIn(AnalyzerConfigOptionsProvider provider);
    [ExtensionAttribute]
public static bool GetCsWinRTMergeReferencedActivationFactories(AnalyzerConfigOptionsProvider provider);
    [ExtensionAttribute]
public static bool GetCsWinRTRcwFactoryFallbackGeneratorForceOptOut(AnalyzerConfigOptionsProvider provider);
    [ExtensionAttribute]
public static bool IsCsWinRTCcwLookupTableGeneratorEnabled(AnalyzerConfigOptionsProvider provider);
    [ExtensionAttribute]
public static bool GetCsWinRTUseWindowsUIXamlProjections(AnalyzerConfigOptionsProvider provider);
    [ExtensionAttribute]
public static int GetCsWinRTAotWarningLevel(AnalyzerConfigOptionsProvider provider);
    [ExtensionAttribute]
public static bool ShouldGenerateWinMDOnly(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static bool ShouldGenerateWinRTNativeExports(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static string GetCsWinRTExe(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static bool GetKeepGeneratedSources(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static string GetCsWinRTWindowsMetadata(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static string GetCsWinRTDependentMetadata(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static string GetWinmdOutputFile(GeneratorExecutionContext context);
    [ExtensionAttribute]
public static bool GetCsWinRTMergeReferencedActivationFactories(GeneratorExecutionContext context);
}
internal static class Generator.GeneratorHelper : object {
    private static Dictionary`2<string, string> AsyncMethodToTaskAdapter;
    private static GeneratorHelper();
    private static bool IsFundamentalType(ISymbol type);
    public static bool IsOldProjectionAssembly(IAssemblySymbol assemblySymbol);
    public static bool AllowUnsafe(Compilation compilation);
    public static Func`2<ISymbol, bool> IsWinRTClass(Compilation compilation);
    public static bool IsWinRTType(ISymbol type, TypeMapper mapper);
    public static bool IsWinRTType(ISymbol type, Func`3<ISymbol, TypeMapper, bool> isAuthoringWinRTType, TypeMapper mapper);
    public static bool IsWinRTType(ISymbol type, ITypeSymbol winrtRuntimeTypeAttribute, TypeMapper mapper, bool isComponentProject, IAssemblySymbol currentAssembly);
    public static bool IsWinRTTypeOrImplementsWinRTType(ISymbol type, ITypeSymbol winrtRuntimeTypeAttribute, TypeMapper mapper, bool isComponentProject, IAssemblySymbol currentAssembly);
    public static bool IsCustomMappedType(ISymbol type, TypeMapper mapper);
    public static bool IsInternalInterfaceFromReferences(INamedTypeSymbol iface, IAssemblySymbol currentAssembly);
    public static bool HasNonInstantiatedWinRTGeneric(ITypeSymbol symbol, TypeMapper mapper);
    public static bool IsPartial(INamedTypeSymbol symbol);
    public static bool HasPrivateclass(ITypeSymbol symbol);
    public static bool HasWinRTExposedTypeAttribute(ISymbol type);
    public static bool HasWinRTRuntimeClassNameAttribute(ISymbol type, Compilation compilation);
    public static bool IsWinRTType(MemberDeclarationSyntax node);
    public static bool HasBindableCustomPropertyAttribute(MemberDeclarationSyntax node);
    public static bool HasAttributeWithType(ISymbol symbol, ITypeSymbol attributeTypeSymbol);
    public static Func`3<ISymbol, TypeMapper, bool> IsWinRTTypeWithPotentialAuthoringComponentTypesFunc(Compilation compilation);
    private static string GetAbiTypeForFundamentalType(ISymbol type);
    public static bool IsBlittableValueType(ITypeSymbol type, TypeMapper typeMapper);
    public static string GetAbiType(ITypeSymbol type, TypeMapper mapper);
    public static string GetMarshalerClass(string type, string abiType, TypeKind kind, bool isArray, bool useGenericMarshaler);
    public static string GetFromAbiMarshaler(GenericParameter genericParameter, string arg);
    public static string GetFromAbiMarshaler(string type, string abiType, TypeKind kind, string arg);
    public static string GetFromManagedMarshaler(GenericParameter genericParameter, string arg);
    public static string GetFromManagedMarshaler(string type, string abiType, TypeKind kind, string arg);
    public static string GetCopyManagedArrayMarshaler(string type, string abiType, TypeKind kind);
    public static string GetCreateMarshaler(GenericParameter genericParameter, string arg);
    public static string GetCreateMarshaler(string type, string abiType, TypeKind kind, string arg);
    public static string GetDisposeMarshaler(GenericParameter genericParameter, string arg);
    public static string GetDisposeMarshaler(string type, string abiType, TypeKind kind, string arg);
    public static string GetAbiFromMarshaler(GenericParameter genericParameter, string arg);
    public static string GetAbiFromMarshaler(string type, string abiType, TypeKind kind, string arg);
    public static string GetMarshalerDeclaration(GenericParameter genericParameter, string arg);
    public static string GetMarshalerDeclaration(string type, string abiType, TypeKind kind, string arg);
    public static string GetAbiMarshalerType(string type, string abiType, TypeKind kind, bool isArray);
    public static string EscapeTypeNameForIdentifier(string typeName);
    public static string GetTaskAdapterIfAsyncMethod(IMethodSymbol symbol);
    [CompilerGeneratedAttribute]
internal static bool <HasNonInstantiatedWinRTGeneric>g__IsArgumentTypeParameter|10_1(ITypeSymbol argument);
    [CompilerGeneratedAttribute]
internal static bool <HasBindableCustomPropertyAttribute>g__IsBindableCustomPropertyAttribute|16_1(AttributeSyntax attribute);
}
[IsReadOnlyAttribute]
internal class Generator.GenericInterface : ValueType {
    [CompilerGeneratedAttribute]
private string <Interface>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GenericDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private EquatableArray`1<GenericParameter> <GenericParameters>k__BackingField;
    public string Interface { get; public set; }
    public string GenericDefinition { get; public set; }
    public EquatableArray`1<GenericParameter> GenericParameters { get; public set; }
    public GenericInterface(string Interface, string GenericDefinition, EquatableArray`1<GenericParameter> GenericParameters);
    [CompilerGeneratedAttribute]
public string get_Interface();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Interface(string value);
    [CompilerGeneratedAttribute]
public string get_GenericDefinition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GenericDefinition(string value);
    [CompilerGeneratedAttribute]
public EquatableArray`1<GenericParameter> get_GenericParameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GenericParameters(EquatableArray`1<GenericParameter> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GenericInterface left, GenericInterface right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GenericInterface left, GenericInterface right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(GenericInterface other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Interface, String& GenericDefinition, EquatableArray`1& GenericParameters);
}
[IsReadOnlyAttribute]
internal class Generator.GenericParameter : ValueType {
    [CompilerGeneratedAttribute]
private string <ProjectedType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AbiType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeKind <TypeKind>k__BackingField;
    public string ProjectedType { get; public set; }
    public string AbiType { get; public set; }
    public TypeKind TypeKind { get; public set; }
    public GenericParameter(string ProjectedType, string AbiType, TypeKind TypeKind);
    [CompilerGeneratedAttribute]
public string get_ProjectedType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ProjectedType(string value);
    [CompilerGeneratedAttribute]
public string get_AbiType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AbiType(string value);
    [CompilerGeneratedAttribute]
public TypeKind get_TypeKind();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeKind(TypeKind value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GenericParameter left, GenericParameter right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GenericParameter left, GenericParameter right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(GenericParameter other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& ProjectedType, String& AbiType, TypeKind& TypeKind);
}
internal static class Generator.GenericVtableInitializerStrings : object {
    public static string GetInstantiation(string genericInterface, EquatableArray`1<GenericParameter> genericParameters);
    public static ImmutableHashSet`1<GenericInterface> AddDependentGenericInterfaces(ImmutableHashSet`1<GenericInterface> genericInterfaces);
    public static string GetInstantiationInitFunction(string genericInterface, EquatableArray`1<GenericParameter> genericParameters, string escapedAssemblyName);
    private static string GetIEnumerableInstantiation(string genericType, string abiType);
    private static string GetIEnumeratorInstantiation(string genericType, string abiType, TypeKind typeKind);
    private static string GetIListInstantiation(string genericType, string abiType, TypeKind typeKind);
    private static string GetIReadOnlyListInstantiation(string genericType, string abiType, TypeKind typeKind);
    private static string GetIDictionaryInstantiation(string genericKeyType, string abiKeyType, TypeKind keyTypeKind, string genericValueType, string abiValueType, TypeKind valueTypeKind);
    private static string GetIReadOnlyDictionaryInstantiation(string genericKeyType, string abiKeyType, TypeKind keyTypeKind, string genericValueType, string abiValueType, TypeKind valueTypeKind);
    private static string GetKeyValuePairInstantiation(string genericKeyType, string abiKeyType, TypeKind keyTypeKind, string genericValueType, string abiValueType, TypeKind valueTypeKind);
    private static string GetEventHandlerInstantiation(string genericType, string abiType, TypeKind typeKind);
    private static string GetTypedEventHandlerInstantiation(EquatableArray`1<GenericParameter> genericParameters);
    private static string GetCompletedHandlerInstantiation(string completedHandler, string asyncInfoInterface, EquatableArray`1<GenericParameter> genericParameters);
    private static string GetChangedHandlerInstantiation(string changedHandler, string senderInterface, string changedEventArgsInterface, EquatableArray`1<GenericParameter> genericParameters);
    private static string GetProgressHandlerInstantiation(string progressHandler, string asyncInfoInterface, EquatableArray`1<GenericParameter> genericParameters);
    private static string GetIAsyncActionWithProgressInstantiation(EquatableArray`1<GenericParameter> genericParameters);
    private static string GetIAsyncOperationWithProgressInstantiation(EquatableArray`1<GenericParameter> genericParameters);
    private static string GetIAsyncOperationInstantiation(EquatableArray`1<GenericParameter> genericParameters);
    private static string GetIMapChangedEventArgsInstantiation(EquatableArray`1<GenericParameter> genericParameters);
    private static string GetIObservableMapInstantiation(EquatableArray`1<GenericParameter> genericParameters);
    private static string GetIObservableVectorInstantiation(EquatableArray`1<GenericParameter> genericParameters);
    private static string GetGenericParametersAsString(EquatableArray`1<GenericParameter> genericParameters, string separator, bool includeAbiTypes, bool escape);
    [CompilerGeneratedAttribute]
internal static void <AddDependentGenericInterfaces>g__AddReplacedGenericInterface|1_0(GenericInterface genericInterfaceToReplace, string newInterfaceToReplaceWith, <>c__DisplayClass1_0& );
}
public static class Generator.Helper : object {
    public static Guid EncodeGuid(Byte[] data);
}
internal class Generator.Logger : object {
    private TextWriter fileLogger;
    public Logger(GeneratorExecutionContext context);
    public void Log(string text);
    public void Close();
}
[GeneratorAttribute]
public class Generator.MergeReferencedActivationFactoriesGenerator : object {
    public sealed virtual void Initialize(IncrementalGeneratorInitializationContext context);
    [NullableContextAttribute("1")]
internal static bool TryGetDependentAssemblyExportsTypeName(IAssemblySymbol assemblySymbol, Compilation compilation, CancellationToken token, String& name);
}
internal class Generator.Parameter : object {
    public Symbol Type;
    public string Name;
    public ParameterAttributes Attributes;
    public bool ByRef;
    public Parameter(Symbol type, string name, ParameterAttributes attributes);
    public Parameter(Symbol type, string name, ParameterAttributes attributes, bool byRef);
    public Parameter(ITypeSymbol type, string name, ParameterAttributes attributes);
    public Parameter(EntityHandle type, string name, ParameterAttributes attributes);
    public Parameter(IParameterSymbol parameterSymbol);
    public static Parameter[] GetParameters(ParameterListSyntax parameterList, SemanticModel model);
    public static Parameter[] GetParameters(IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[GeneratorAttribute]
public class Generator.RcwReflectionFallbackGenerator : object {
    public sealed virtual void Initialize(IncrementalGeneratorInitializationContext context);
    private static IEnumerable`1<INamedTypeSymbol> VisitNamedTypeSymbolsExceptABI(IAssemblySymbol assemblySymbol);
    private static bool IsDerivedFromType(ITypeSymbol typeSymbol, ITypeSymbol baseTypeSymbol);
    [IteratorStateMachineAttribute("Generator.RcwReflectionFallbackGenerator/<<VisitNamedTypeSymbolsExceptABI>g__Visit|1_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<INamedTypeSymbol> <VisitNamedTypeSymbolsExceptABI>g__Visit|1_0(INamespaceOrTypeSymbol symbol);
}
[GeneratorAttribute]
public class Generator.SourceGenerator : object {
    public sealed virtual void Execute(GeneratorExecutionContext context);
    public sealed virtual void Initialize(GeneratorInitializationContext context);
}
internal class Generator.Symbol : object {
    public ITypeSymbol Type;
    public EntityHandle Handle;
    public int GenericIndex;
    public bool IsArray;
    public Symbol(ITypeSymbol type, bool isArray);
    public Symbol(EntityHandle handle);
    public Symbol(int genericIndex, bool isArray);
    public bool IsHandle();
    public bool IsGeneric();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Generator.SymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsPubliclyAccessible(ITypeSymbol type);
    [ExtensionAttribute]
public static bool IsExplicitInterfaceImplementationOfInternalInterfaces(ISymbol symbol);
    [ExtensionAttribute]
public static bool TryGetAttributeWithType(ISymbol symbol, ITypeSymbol typeSymbol, AttributeData& attributeData);
    [ExtensionAttribute]
public static bool IsAccessibleFromCompilationAssembly(ISymbol symbol, Compilation compilation);
    [CompilerGeneratedAttribute]
internal static bool <IsExplicitInterfaceImplementationOfInternalInterfaces>g__IsAnyContainingTypePublic|1_0(IEnumerable`1<ISymbol> symbols);
}
internal class Generator.TypeDeclaration : object {
    public ISymbol Node;
    public TypeDefinitionHandle Handle;
    public string DefaultInterface;
    public string StaticInterface;
    public bool IsSynthesizedInterface;
    public bool IsComponentType;
    public Dictionary`2<ISymbol, List`1<MethodDefinitionHandle>> MethodDefinitions;
    public Dictionary`2<ISymbol, List`1<EntityHandle>> MethodReferences;
    public Dictionary`2<ISymbol, FieldDefinitionHandle> FieldDefinitions;
    public Dictionary`2<ISymbol, PropertyDefinitionHandle> PropertyDefinitions;
    public Dictionary`2<ISymbol, EventDefinitionHandle> EventDefinitions;
    public Dictionary`2<ISymbol, InterfaceImplementationHandle> InterfaceImplDefinitions;
    public Dictionary`2<string, List`1<ISymbol>> MethodsByName;
    public Dictionary`2<ISymbol, string> OverloadedMethods;
    public List`1<ISymbol> CustomMappedSymbols;
    public HashSet`1<ISymbol> SymbolsWithAttributes;
    public Dictionary`2<ISymbol, ISymbol> ClassInterfaceMemberMapping;
    public TypeDeclaration(ISymbol node, bool isComponentType);
    public virtual string ToString();
    public void AddMethod(ISymbol node, string name, MethodDefinitionHandle handle);
    public void AddMethodReference(ISymbol node, MemberReferenceHandle handle);
    public void AddMethodOverload(ISymbol node, string overloadedMethodName);
    public List`1<MethodDefinitionHandle> GetMethodDefinitions();
    public List`1<EntityHandle> GetMethodReferences();
    public void AddField(ISymbol node, FieldDefinitionHandle handle);
    public List`1<FieldDefinitionHandle> GetFieldDefinitions();
    public void AddProperty(ISymbol node, PropertyDefinitionHandle handle);
    public List`1<PropertyDefinitionHandle> GetPropertyDefinitions();
    public void AddEvent(ISymbol node, EventDefinitionHandle handle);
    public List`1<EventDefinitionHandle> GetEventDefinitions();
    public void AddInterfaceImpl(ISymbol node, InterfaceImplementationHandle handle);
}
internal class Generator.TypeInfo : object {
    [CompilerGeneratedAttribute]
private string <QualifiedName>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRecord>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public string QualifiedName { get; public set; }
    public TypeKind Kind { get; public set; }
    public bool IsRecord { get; public set; }
    public TypeInfo(string QualifiedName, TypeKind Kind, bool IsRecord);
    [CompilerGeneratedAttribute]
private TypeInfo(TypeInfo original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_QualifiedName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QualifiedName(string value);
    [CompilerGeneratedAttribute]
public TypeKind get_Kind();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Kind(TypeKind value);
    [CompilerGeneratedAttribute]
public bool get_IsRecord();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsRecord(bool value);
    public string GetTypeKeyword();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TypeInfo left, TypeInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TypeInfo left, TypeInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TypeInfo other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TypeInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& QualifiedName, TypeKind& Kind, Boolean& IsRecord);
}
internal class Generator.TypeMapper : object {
    private Dictionary`2<string, MappedType> typeMapping;
    public TypeMapper(bool useWindowsUIXamlProjections);
    private static ValueTuple`5<string, string, string, bool, bool> GetSystemTypeCustomMapping(ISymbol containingSymbol);
    public bool HasMappingForType(string typeName);
    public MappedType GetMappedType(string typeName);
}
internal class Generator.VtableAttribute : object {
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGlobalNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private EquatableArray`1<TypeInfo> <ClassHierarchy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VtableLookupClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private EquatableArray`1<string> <Interfaces>k__BackingField;
    [CompilerGeneratedAttribute]
private EquatableArray`1<GenericInterface> <GenericInterfaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeClassName>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public string Namespace { get; public set; }
    public bool IsGlobalNamespace { get; public set; }
    public string ClassName { get; public set; }
    public EquatableArray`1<TypeInfo> ClassHierarchy { get; public set; }
    public string VtableLookupClassName { get; public set; }
    public EquatableArray`1<string> Interfaces { get; public set; }
    public EquatableArray`1<GenericInterface> GenericInterfaces { get; public set; }
    public bool IsArray { get; public set; }
    public bool IsDelegate { get; public set; }
    public bool IsPublic { get; public set; }
    public string RuntimeClassName { get; public set; }
    public VtableAttribute(string Namespace, bool IsGlobalNamespace, string ClassName, EquatableArray`1<TypeInfo> ClassHierarchy, string VtableLookupClassName, EquatableArray`1<string> Interfaces, EquatableArray`1<GenericInterface> GenericInterfaces, bool IsArray, bool IsDelegate, bool IsPublic, string RuntimeClassName);
    [CompilerGeneratedAttribute]
private VtableAttribute(VtableAttribute original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Namespace(string value);
    [CompilerGeneratedAttribute]
public bool get_IsGlobalNamespace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsGlobalNamespace(bool value);
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ClassName(string value);
    [CompilerGeneratedAttribute]
public EquatableArray`1<TypeInfo> get_ClassHierarchy();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ClassHierarchy(EquatableArray`1<TypeInfo> value);
    [CompilerGeneratedAttribute]
public string get_VtableLookupClassName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VtableLookupClassName(string value);
    [CompilerGeneratedAttribute]
public EquatableArray`1<string> get_Interfaces();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Interfaces(EquatableArray`1<string> value);
    [CompilerGeneratedAttribute]
public EquatableArray`1<GenericInterface> get_GenericInterfaces();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GenericInterfaces(EquatableArray`1<GenericInterface> value);
    [CompilerGeneratedAttribute]
public bool get_IsArray();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsArray(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDelegate();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsDelegate(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsPublic(bool value);
    [CompilerGeneratedAttribute]
public string get_RuntimeClassName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RuntimeClassName(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(VtableAttribute left, VtableAttribute right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(VtableAttribute left, VtableAttribute right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(VtableAttribute other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public VtableAttribute <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Namespace, Boolean& IsGlobalNamespace, String& ClassName, EquatableArray`1& ClassHierarchy, String& VtableLookupClassName, EquatableArray`1& Interfaces, EquatableArray`1& GenericInterfaces, Boolean& IsArray, Boolean& IsDelegate, Boolean& IsPublic, String& RuntimeClassName);
}
[GeneratorAttribute]
public class Generator.WinRTAotSourceGenerator : object {
    public sealed virtual void Initialize(IncrementalGeneratorInitializationContext context);
    private static bool NeedVtableAttribute(SyntaxNode node);
    private static bool IsComponentType(SyntaxNode node);
    private static bool NeedCustomPropertyImplementation(SyntaxNode node);
    private static ValueTuple`2<VtableAttribute, EquatableArray`1<VtableAttribute>> GetVtableAttributeToAdd(GeneratorSyntaxContext context, TypeMapper typeMapper, bool checkForComponentTypes);
    private static bool IsAsyncOperationMethodCall(SyntaxNode node);
    private static ValueTuple`2<VtableAttribute, VtableAttribute> GetVtableAttributesForTaskAdapters(GeneratorSyntaxContext context, TypeMapper typeMapper);
    private static BindableCustomProperties GetBindableCustomProperties(GeneratorSyntaxContext context);
    private static string ToFullyQualifiedString(ISymbol symbol);
    private static string ToVtableLookupString(ISymbol symbol);
    private static string ToVtableLookupString(ISymbol symbol, List`1<string> genericArguments, bool ignoreTypeArguments);
    private static string GetRuntimeClassName(INamedTypeSymbol type, Func`3<ISymbol, TypeMapper, bool> isWinRTType, TypeMapper mapper);
    internal static VtableAttribute GetVtableAttributeToAdd(ITypeSymbol symbol, Func`3<ISymbol, TypeMapper, bool> isWinRTType, TypeMapper mapper, Compilation compilation, bool isAuthoring, string authoringDefaultInterface);
    private static bool TryGetCompatibleWindowsRuntimeTypesForVariantType(INamedTypeSymbol type, TypeMapper mapper, Stack`1<INamedTypeSymbol> typeStack, Func`3<ISymbol, TypeMapper, bool> isWinRTType, IList`1& compatibleTypes);
    private static void GenerateVtableAttributes(SourceProductionContext sourceProductionContext, ValueTuple`2<ImmutableArray`1<VtableAttribute>, ValueTuple`2<ValueTuple`3<bool, bool, bool>, string>> value);
    internal static string GenerateVtableEntry(VtableAttribute vtableAttribute, string escapedAssemblyName);
    internal static void GenerateVtableAttributes(Action`2<string, string> addSource, ImmutableArray`1<VtableAttribute> vtableAttributes, bool isCsWinRTComponentFromAotOptimizer, string escapedAssemblyName);
    private static void GenerateCCWForGenericInstantiation(SourceProductionContext sourceProductionContext, ValueTuple`2<ValueTuple`2<ValueTuple`2<ImmutableArray`1<GenericInterface>, ImmutableArray`1<GenericInterface>>, ImmutableArray`1<GenericInterface>>, ValueTuple`2<ValueTuple`3<bool, bool, bool>, string>> value);
    internal static void GenerateCCWForGenericInstantiation(Action`2<string, string> addSource, ImmutableArray`1<GenericInterface> genericInterfaces, string escapedAssemblyName);
    private static bool NeedVtableOnLookupTable(SyntaxNode node);
    private static ValueTuple`2<EquatableArray`1<VtableAttribute>, EquatableArray`1<VtableAttribute>> GetVtableAttributesToAddOnLookupTable(GeneratorSyntaxContext context, TypeMapper typeMapper);
    private static EquatableArray`1<VtableAttribute> GetVtableAttributesToAddOnLookupTable(GeneratorSyntaxContext context, TypeMapper typeMapper, Func`3<ISymbol, TypeMapper, bool> isWinRTType, Func`2<ISymbol, bool> isWinRTClass);
    private static void AddEnumeratorAdapterForType(ITypeSymbol type, TypeMapper mapper, Compilation compilation, Func`3<ISymbol, TypeMapper, bool> isWinRTType, HashSet`1<VtableAttribute> vtableAttributes);
    internal static void AddVtableAdapterTypeForKnownInterface(ITypeSymbol classType, Compilation compilation, Func`3<ISymbol, TypeMapper, bool> isWinRTType, TypeMapper mapper, HashSet`1<VtableAttribute> vtableAttributes);
    private static void GenerateVtableLookupTable(SourceProductionContext sourceProductionContext, ValueTuple`2<ImmutableArray`1<VtableAttribute>, ValueTuple`2<ValueTuple`3<bool, bool, bool>, string>> value);
    internal static void GenerateVtableLookupTable(Action`2<string, string> addSource, ValueTuple`2<ImmutableArray`1<VtableAttribute>, ValueTuple`2<ValueTuple`3<bool, bool, bool>, string>> value, bool isComponentGenerator);
    private static void GenerateBindableCustomProperties(SourceProductionContext sourceProductionContext, ValueTuple`2<ImmutableArray`1<BindableCustomProperties>, ValueTuple`3<bool, bool, bool>> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <GetBindableCustomProperties>g__AddProperty|7_0(ISymbol symbol, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <GetVtableAttributesToAddOnLookupTable>g__AddVtableAttributesForType|21_0(TypeInfo instantiatedType, ITypeSymbol convertedToTypeSymbol, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
internal static void <AddVtableAdapterTypeForKnownInterface>g__LookupAndAddVtableAttributeForGenericType|23_0(string type, ImmutableArray`1<ITypeSymbol> genericArgs, <>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
internal static bool <AddVtableAdapterTypeForKnownInterface>g__IsDerivedFromOrIsObservableCollection|23_1(INamedTypeSymbol namedType);
    [CompilerGeneratedAttribute]
internal static string <GenerateBindableCustomProperties>g__GetBoolAsString|26_0(bool value);
}
public class Generator.WinRTComponentScanner : object {
    private SpecialType[] ValidStructFieldTypes;
    private static HashSet`1<string> nonWindowsRuntimeInterfaces;
    private static HashSet`1<string> NotValidTypes;
    private static HashSet`1<string> WIPNotValidTypes;
    private static HashSet`1<string> InAndOutAttributeNames;
    private static HashSet`1<string> OverloadAttributeNames;
    private static HashSet`1<string> ReadOnlyArrayAttributeNames;
    private static HashSet`1<string> WriteOnlyArrayAttributeNames;
    private static string GeneratedReturnValueName;
    private string _assemblyName;
    private GeneratorExecutionContext _context;
    private bool _flag;
    private TypeMapper _typeMapper;
    public WinRTComponentScanner(GeneratorExecutionContext context, string assemblyName);
    private static WinRTComponentScanner();
    private void Flag();
    private void Report(DiagnosticDescriptor d, Location loc, Object[] args);
    private void ReportDiagnostic(Diagnostic d);
    private SemanticModel GetModel(SyntaxTree t);
    private INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
    private bool SymEq(ISymbol sym1, ISymbol sym2);
    private void ImplementsInvalidInterface(INamedTypeSymbol typeSymbol, TypeDeclarationSyntax typeDeclaration);
    private bool ImplementsInterface(INamedTypeSymbol typeSymbol, string typeToCheck);
    private bool IsPublic(MemberDeclarationSyntax member);
    private bool MatchesAnyAttribute(string attrName, SyntaxList`1<AttributeListSyntax> ls);
    private bool MatchesAnyAttribute(string attrName, ImmutableArray`1<AttributeData> attributes);
    private void ParameterHasAttributeErrors(MethodDeclarationSyntax method);
    private bool ParamHasAttribute(ParameterSyntax param, string attrName);
    private bool ParamHasInOrOutAttribute(ParameterSyntax param);
    private bool ParamHasReadOnlyAttribute(ParameterSyntax param);
    private bool ParamHasWriteOnlyAttribute(ParameterSyntax param);
    private ISymbol GetInterfaceMemberFromClassMember(ISymbol classMember);
    private bool HasDefaultOverloadAttribute(MethodDeclarationSyntax method);
    private void CheckOverloadAttributes(MethodDeclarationSyntax method, Dictionary`2<string, bool> methodHasAttributeMap, Dictionary`2<string, Diagnostic> overloadsWithoutAttributeMap, SyntaxToken classId);
    private string SuggestType(string type);
    private string SimplifySyntaxTypeString(string syntaxType);
    public bool Found();
    public void FindDiagnostics();
    private void CheckNamespaces();
    private void CheckDeclarations();
    private void CheckInterfaces(SemanticModel model, ClassDeclarationSyntax class);
    private bool IsMethodImpl(IMethodSymbol m, IMethodSymbol interfaceMethod);
    private void IgnoreCustomTypeMappings(INamedTypeSymbol typeSymbol, TypeMapper typeMapper, IEnumerable`1& methods, IEnumerable`1& properties);
    private void OverloadsOperator(ClassDeclarationSyntax classDeclaration);
    private void HasMultipleConstructorsOfSameArity(ClassDeclarationSyntax classDeclaration);
    private void HasConflictingParameterName(MethodDeclarationSyntax method);
    private void CheckMethods(IEnumerable`1<MethodDeclarationSyntax> methodDeclarations, SyntaxToken typeId);
    private void CheckProperties(IEnumerable`1<PropertyDeclarationSyntax> props, SyntaxToken typeId);
    private void CheckStructFields(StructDeclarationSyntax struct);
    private bool IsInvalidNamespace(INamespaceSymbol namespace, string assemblyName);
    private void ReportIfInvalidType(ITypeSymbol typeSymbol, Location loc, SyntaxToken memberId, SyntaxToken typeId);
    [CompilerGeneratedAttribute]
internal static bool <ImplementsInvalidInterface>g__AsyncActionCase|6_0(INamedTypeSymbol sym);
    [CompilerGeneratedAttribute]
internal static bool <ParameterHasAttributeErrors>g__HasModifier|11_0(ParameterSyntax param, SyntaxKind kind);
    [CompilerGeneratedAttribute]
internal static string <IgnoreCustomTypeMappings>g__QualifiedName|41_0(INamedTypeSymbol sym);
    [CompilerGeneratedAttribute]
internal static bool <HasConflictingParameterName>g__IsInvalidParameterName|44_0(ParameterSyntax stx);
}
internal class Generator.WinRTSyntaxReceiver : object {
    public List`1<MemberDeclarationSyntax> Declarations;
    public List`1<NamespaceDeclarationSyntax> Namespaces;
    private bool HasSomePublicTypes(SyntaxNode syntaxNode);
    public sealed virtual void OnVisitSyntaxNode(SyntaxNode syntaxNode);
    private bool IsPublic(MemberDeclarationSyntax member);
    private bool IsPublicOrPartial(MemberDeclarationSyntax member);
}
internal class Generator.WinRTTypeWriter : CSharpSyntaxWalker {
    internal static List`1<string> ImplementedInterfacesWithoutMapping;
    public SemanticModel Model;
    private string assembly;
    private string version;
    private Dictionary`2<string, TypeReferenceHandle> typeReferenceMapping;
    private Dictionary`2<string, EntityHandle> assemblyReferenceMapping;
    private MetadataBuilder metadataBuilder;
    private TypeMapper mapper;
    private Dictionary`2<string, TypeDeclaration> typeDefinitionMapping;
    private TypeDeclaration currentTypeDeclaration;
    [CompilerGeneratedAttribute]
private Logger <Logger>k__BackingField;
    private Logger Logger { get; }
    public WinRTTypeWriter(string assembly, string version, MetadataBuilder metadataBuilder, Logger logger, TypeMapper mapper);
    private static WinRTTypeWriter();
    [CompilerGeneratedAttribute]
private Logger get_Logger();
    private void CreteAssembly();
    private bool IsEncodableAsSpecialType(SpecialType specialType);
    private void EncodeSpecialType(SpecialType specialType, SignatureTypeEncoder typeEncoder);
    private BlobHandle GetStrongNameKey(string assembly);
    private EntityHandle GetTypeReference(string namespace, string name, string assembly);
    public string GetAssemblyForWinRTType(ISymbol type);
    private EntityHandle GetTypeReference(ISymbol symbol);
    private EntityHandle GetTypeSpecification(INamedTypeSymbol symbol);
    private void EncodeSymbol(Symbol symbol, SignatureTypeEncoder typeEncoder);
    private void EncodeReturnType(Symbol symbol, ReturnTypeEncoder returnTypeEncoder);
    private void EncodeParameters(Parameter[] parameters, ParametersEncoder parametersEncoder);
    public MethodDefinitionHandle AddMethodDefinition(string name, Parameter[] parameters, Symbol returnSymbol, bool isStatic, bool isInterfaceParent, bool isSpecialMethod, bool isPublic, bool isOverridable);
    public void AddFieldDeclaration(IFieldSymbol field, bool isEnum);
    public void AddPropertyDefinition(string propertyName, Symbol type, ISymbol symbol, bool isStatic, bool hasSetMethod, bool isInterfaceParent, bool isPublic);
    public void AddPropertyDeclaration(IPropertySymbol property, bool isInterfaceParent);
    private TypeDefinitionHandle AddTypeDefinition(TypeAttributes typeAttributes, string namespace, string identifier, EntityHandle baseType);
    private void ProcessCustomMappedInterfaces(INamedTypeSymbol classSymbol);
    private INamedTypeSymbol GetTypeByMetadataName(string metadataName);
    private string GetMappedQualifiedTypeName(ITypeSymbol symbol);
    private void WriteCustomMappedTypeMembers(INamedTypeSymbol symbol, bool isDefinition, bool isPublic);
    private IEnumerable`1<INamedTypeSymbol> GetInterfaces(INamedTypeSymbol symbol, bool includeInterfacesWithoutMappings);
    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual void VisitStructDeclaration(StructDeclarationSyntax node);
    private void EncodeTypedConstant(TypedConstant constant, LiteralEncoder encoder);
    private void EncodeFixedArguments(IList`1<TypedConstant> arguments, FixedArgumentsEncoder argumentsEncoder);
    private void EncodeCustomElementType(ITypeSymbol type, CustomAttributeElementTypeEncoder typeEncoder);
    private void EncodeNamedArgumentType(ITypeSymbol type, NamedArgumentTypeEncoder encoder);
    private ISymbol GetMember(INamedTypeSymbol type, string member);
    private void EncodeNamedArguments(INamedTypeSymbol attributeType, IList`1<KeyValuePair`2<string, TypedConstant>> namedArguments, CustomAttributeNamedArgumentsEncoder argumentsEncoder);
    private void EncodeFixedArguments(IList`1<object> primitiveArguments, FixedArgumentsEncoder argumentsEncoder);
    private void AddDefaultVersionAttribute(EntityHandle parentHandle, int version);
    private void AddActivatableAttribute(EntityHandle parentHandle, UInt32 version, string factoryInterface);
    private void AddExclusiveToAttribute(EntityHandle interfaceHandle, string className);
    private void AddStaticAttribute(EntityHandle parentHandle, UInt32 version, string staticInterface);
    private void AddDefaultInterfaceImplAttribute(EntityHandle interfaceImplHandle);
    private void AddOverloadAttribute(EntityHandle methodHandle, string methodName);
    private void AddOverloadAttributeForInterfaceMethods(TypeDeclaration interfaceTypeDeclaration);
    private void AddGuidAttribute(EntityHandle parentHandle, string name);
    private void AddCustomAttributes(string attributeTypeName, IList`1<ITypeSymbol> primitiveTypes, IList`1<object> primitiveValues, EntityHandle parentHandle);
    private void AddCustomAttributes(IEnumerable`1<AttributeData> attributes, EntityHandle parentHandle);
    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node);
    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public void AddEventDeclaration(string eventName, ITypeSymbol eventType, ISymbol symbol, bool isStatic, bool isInterfaceParent, bool isPublic);
    public void AddEventDeclaration(IEventSymbol event, bool isInterfaceParent);
    private void AddMethodDeclaration(IMethodSymbol method, bool isInterfaceParent);
    private void AddFactoryMethod(INamedTypeSymbol classSymbol, IMethodSymbol method);
    private void AddComponentType(INamedTypeSymbol type, Action visitTypeDeclaration);
    private MemberReferenceHandle AddMethodReference(string name, Parameter[] parameters, Symbol returnSymbol, INamedTypeSymbol parentType, bool isStatic);
    private MemberReferenceHandle AddMethodReference(IMethodSymbol method);
    public void AddPropertyReference(string name, Symbol type, ISymbol symbol, INamedTypeSymbol parent, bool setMethod);
    public void AddPropertyReference(IPropertySymbol property);
    public void AddEventReference(string eventName, ITypeSymbol eventType, ISymbol symbol, INamedTypeSymbol parent);
    public void AddEventReference(IEventSymbol event);
    private void AddProjectedType(INamedTypeSymbol type, string projectedTypeOverride);
    private void AddMappedType(INamedTypeSymbol type);
    private string GetSynthesizedInterfaceName(string className, SynthesizedInterfaceType type);
    private void AddSynthesizedInterfaces(TypeDeclaration classDeclaration);
    private void CheckAndMarkSynthesizedInterfaceSymbolForAttributes(ISymbol symbol, TypeDeclaration classDeclaration);
    private void CheckAndMarkSymbolForAttributes(ISymbol symbol);
    private void AddSynthesizedInterface(TypeDeclaration classDeclaration, SynthesizedInterfaceType interfaceType, HashSet`1<ISymbol> classMembersFromInterfaces);
    private int GetVersion(INamedTypeSymbol type, bool setDefaultIfNotSet);
    private void AddType(INamedTypeSymbol type, bool treatAsProjectedType);
    private void AddCustomAttributes(TypeDeclaration typeDeclaration, string interfaceName);
    public void FinalizeGeneration();
    public void GenerateWinRTExposedClassAttributes(GeneratorExecutionContext context);
    public bool IsPublic(ISymbol symbol);
    public void GetNamespaceAndTypename(string qualifiedName, String& namespace, String& typename);
    public static string QualifiedName(string namespace, string identifier);
    public static string GetGenericName(ISymbol symbol, bool includeGenerics);
    public static string QualifiedName(ISymbol symbol, bool includeGenerics);
    [CompilerGeneratedAttribute]
private bool <ProcessCustomMappedInterfaces>b__30_0(INamedTypeSymbol symbol);
    [CompilerGeneratedAttribute]
private bool <ProcessCustomMappedInterfaces>b__30_1(INamedTypeSymbol symbol);
    [CompilerGeneratedAttribute]
private string <GetMappedQualifiedTypeName>b__32_0(ITypeSymbol type);
    [CompilerGeneratedAttribute]
private void <WriteCustomMappedTypeMembers>g__AddMethod|33_0(string name, Parameter[] parameters, Symbol returnType, <>c__DisplayClass33_0& );
    [CompilerGeneratedAttribute]
private void <WriteCustomMappedTypeMembers>g__AddProperty|33_1(string name, Symbol type, bool setProperty, <>c__DisplayClass33_0& );
    [CompilerGeneratedAttribute]
private void <WriteCustomMappedTypeMembers>g__AddEvent|33_2(string name, Symbol eventType, <>c__DisplayClass33_0& );
    [CompilerGeneratedAttribute]
private Symbol <WriteCustomMappedTypeMembers>g__GetType|33_3(string type, bool isGeneric, int genericIndex, bool isArray, ITypeSymbol[] genericTypes, <>c__DisplayClass33_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0(InterfaceDeclarationSyntax node);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__1(ClassDeclarationSyntax node);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__2(StructDeclarationSyntax node);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__3(EnumDeclarationSyntax node);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[AttributeUsageAttribute("2240")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
private string ToStringFromEnd();
}
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public void set_IsOptional(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.ModuleInitializerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[AttributeUsageAttribute("1774")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.Versioning.RequiresPreviewFeaturesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresPreviewFeaturesAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class WinRT.SourceGenerator.CsWinRTDiagnosticStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArrayMarkedInOrOut_Brief { get; }
    internal static string ArrayMarkedInOrOut_Text1 { get; }
    internal static string ArrayMarkedInOrOut_Text2 { get; }
    internal static string ArrayMarkedInOrOut_Text3 { get; }
    internal static string ArrayOutputParamMarkedRead_Brief { get; }
    internal static string ArrayOutputParamMarkedRead_Text1 { get; }
    internal static string ArrayOutputParamMarkedRead_Text2 { get; }
    internal static string ArrayParamMarkedBoth_Brief { get; }
    internal static string ArrayParamMarkedBoth_Text1 { get; }
    internal static string ArrayParamMarkedBoth_Text2 { get; }
    internal static string ArrayParamNotMarked_Brief { get; }
    internal static string ArrayParamNotMarked_Text1 { get; }
    internal static string ArrayParamNotMarked_Text2 { get; }
    internal static string ClassConstructorRule_Brief { get; }
    internal static string ClassConstructorRule_Text { get; }
    internal static string ClassImplementsOldProjection_Brief { get; }
    internal static string ClassImplementsOldProjection_Text { get; }
    internal static string ClassNotMarkedPartial_Brief { get; }
    internal static string ClassNotMarkedPartial_Text { get; }
    internal static string DisjointNamespaceRule_Brief { get; }
    internal static string DisjointNamespaceRule_Text1 { get; }
    internal static string DisjointNamespaceRule_Text2 { get; }
    internal static string EnableUnsafe_Brief { get; }
    internal static string EnableUnsafe_Text { get; }
    internal static string GenericTypeRule_Brief { get; }
    internal static string GenericTypeRule_Text { get; }
    internal static string JaggedArrayRule_Brief { get; }
    internal static string JaggedArrayRule_Text { get; }
    internal static string MultiDimensionalArrayRule_Brief { get; }
    internal static string MultiDimensionalArrayRule_Text { get; }
    internal static string MultipleDefaultOverloadAttribute_Brief { get; }
    internal static string MultipleDefaultOverloadAttribute_Text1 { get; }
    internal static string MultipleDefaultOverloadAttribute_Text2 { get; }
    internal static string NamespacesDifferByCase_Brief { get; }
    internal static string NamespacesDifferByCase_Text { get; }
    internal static string NeedDefaultOverloadAttribute_Brief { get; }
    internal static string NeedDefaultOverloadAttribute_Text { get; }
    internal static string NonArrayMarked_Brief { get; }
    internal static string NonArrayMarked_Text1 { get; }
    internal static string NonArrayMarked_Text2 { get; }
    internal static string NonArrayMarkedInOrOut_Brief { get; }
    internal static string NonArrayMarkedInOrOut_Text1 { get; }
    internal static string NonArrayMarkedInOrOut_Text2 { get; }
    internal static string NonWinRTInterface_Brief { get; }
    internal static string NonWinRTInterface_Text { get; }
    internal static string NoPublicTypesRule_Brief { get; }
    internal static string NoPublicTypesRule_Text { get; }
    internal static string OperatorOverloadedRule_Brief { get; }
    internal static string OperatorOverloadedRule_Text { get; }
    internal static string ParameterNamedValueRule_Brief { get; }
    internal static string ParameterNamedValueRule_Text { get; }
    internal static string PrivateGetterRule_Brief { get; }
    internal static string PrivateGetterRule_Text { get; }
    internal static string RefParameterFound_Brief { get; }
    internal static string RefParameterFound_Text { get; }
    internal static string StructHasConstFieldRule_Brief { get; }
    internal static string StructHasConstFieldRule_Text { get; }
    internal static string StructHasInvalidFieldRule_Brief { get; }
    internal static string StructHasInvalidFieldRule_Text1 { get; }
    internal static string StructHasInvalidFieldRule_Text2 { get; }
    internal static string StructHasPrivateFieldRule_Brief { get; }
    internal static string StructHasPrivateFieldRule_Text { get; }
    internal static string StructWithNoFieldsRule_Brief { get; }
    internal static string StructWithNoFieldsRule_Text { get; }
    internal static string UnimplementedInterface_Brief { get; }
    internal static string UnimplementedInterface_Text { get; }
    internal static string UnsealedClassRule_Brief { get; }
    internal static string UnsealedClassRule_Text { get; }
    internal static string UnsupportedTypeRule_Brief { get; }
    internal static string UnsupportedTypeRule_Text1 { get; }
    internal static string UnsupportedTypeRule_Text2 { get; }
    internal static string UnsupportedTypeRule_Text3 { get; }
    internal static string UnsupportedTypeRule_Text4 { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArrayMarkedInOrOut_Brief();
    internal static string get_ArrayMarkedInOrOut_Text1();
    internal static string get_ArrayMarkedInOrOut_Text2();
    internal static string get_ArrayMarkedInOrOut_Text3();
    internal static string get_ArrayOutputParamMarkedRead_Brief();
    internal static string get_ArrayOutputParamMarkedRead_Text1();
    internal static string get_ArrayOutputParamMarkedRead_Text2();
    internal static string get_ArrayParamMarkedBoth_Brief();
    internal static string get_ArrayParamMarkedBoth_Text1();
    internal static string get_ArrayParamMarkedBoth_Text2();
    internal static string get_ArrayParamNotMarked_Brief();
    internal static string get_ArrayParamNotMarked_Text1();
    internal static string get_ArrayParamNotMarked_Text2();
    internal static string get_ClassConstructorRule_Brief();
    internal static string get_ClassConstructorRule_Text();
    internal static string get_ClassImplementsOldProjection_Brief();
    internal static string get_ClassImplementsOldProjection_Text();
    internal static string get_ClassNotMarkedPartial_Brief();
    internal static string get_ClassNotMarkedPartial_Text();
    internal static string get_DisjointNamespaceRule_Brief();
    internal static string get_DisjointNamespaceRule_Text1();
    internal static string get_DisjointNamespaceRule_Text2();
    internal static string get_EnableUnsafe_Brief();
    internal static string get_EnableUnsafe_Text();
    internal static string get_GenericTypeRule_Brief();
    internal static string get_GenericTypeRule_Text();
    internal static string get_JaggedArrayRule_Brief();
    internal static string get_JaggedArrayRule_Text();
    internal static string get_MultiDimensionalArrayRule_Brief();
    internal static string get_MultiDimensionalArrayRule_Text();
    internal static string get_MultipleDefaultOverloadAttribute_Brief();
    internal static string get_MultipleDefaultOverloadAttribute_Text1();
    internal static string get_MultipleDefaultOverloadAttribute_Text2();
    internal static string get_NamespacesDifferByCase_Brief();
    internal static string get_NamespacesDifferByCase_Text();
    internal static string get_NeedDefaultOverloadAttribute_Brief();
    internal static string get_NeedDefaultOverloadAttribute_Text();
    internal static string get_NonArrayMarked_Brief();
    internal static string get_NonArrayMarked_Text1();
    internal static string get_NonArrayMarked_Text2();
    internal static string get_NonArrayMarkedInOrOut_Brief();
    internal static string get_NonArrayMarkedInOrOut_Text1();
    internal static string get_NonArrayMarkedInOrOut_Text2();
    internal static string get_NonWinRTInterface_Brief();
    internal static string get_NonWinRTInterface_Text();
    internal static string get_NoPublicTypesRule_Brief();
    internal static string get_NoPublicTypesRule_Text();
    internal static string get_OperatorOverloadedRule_Brief();
    internal static string get_OperatorOverloadedRule_Text();
    internal static string get_ParameterNamedValueRule_Brief();
    internal static string get_ParameterNamedValueRule_Text();
    internal static string get_PrivateGetterRule_Brief();
    internal static string get_PrivateGetterRule_Text();
    internal static string get_RefParameterFound_Brief();
    internal static string get_RefParameterFound_Text();
    internal static string get_StructHasConstFieldRule_Brief();
    internal static string get_StructHasConstFieldRule_Text();
    internal static string get_StructHasInvalidFieldRule_Brief();
    internal static string get_StructHasInvalidFieldRule_Text1();
    internal static string get_StructHasInvalidFieldRule_Text2();
    internal static string get_StructHasPrivateFieldRule_Brief();
    internal static string get_StructHasPrivateFieldRule_Text();
    internal static string get_StructWithNoFieldsRule_Brief();
    internal static string get_StructWithNoFieldsRule_Text();
    internal static string get_UnimplementedInterface_Brief();
    internal static string get_UnimplementedInterface_Text();
    internal static string get_UnsealedClassRule_Brief();
    internal static string get_UnsealedClassRule_Text();
    internal static string get_UnsupportedTypeRule_Brief();
    internal static string get_UnsupportedTypeRule_Text1();
    internal static string get_UnsupportedTypeRule_Text2();
    internal static string get_UnsupportedTypeRule_Text3();
    internal static string get_UnsupportedTypeRule_Text4();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class WinRT.SourceGenerator.EquatableArray`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private T[] array;
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    public bool IsEmpty { get; }
    public EquatableArray`1(ImmutableArray`1<T> array);
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    public bool get_IsEmpty();
    public sealed virtual bool Equals(EquatableArray`1<T> array);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ImmutableArray`1<T> AsImmutableArray();
    public static EquatableArray`1<T> FromImmutableArray(ImmutableArray`1<T> array);
    public ReadOnlySpan`1<T> AsSpan();
    public T[] ToArray();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static EquatableArray`1<T> op_Implicit(ImmutableArray`1<T> array);
    public static ImmutableArray`1<T> op_Implicit(EquatableArray`1<T> array);
    public static bool op_Equality(EquatableArray`1<T> left, EquatableArray`1<T> right);
    public static bool op_Inequality(EquatableArray`1<T> left, EquatableArray`1<T> right);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class WinRT.SourceGenerator.WinRTAotCodeFixer : CodeFixProvider {
    private static string title;
    private static ImmutableArray`1<string> _fixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static WinRTAotCodeFixer();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("WinRT.SourceGenerator.WinRTAotCodeFixer/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("WinRT.SourceGenerator.WinRTAotCodeFixer/<MakeTypePartial>d__5")]
private static Task`1<Document> MakeTypePartial(Document document, ClassDeclarationSyntax class, CancellationToken token);
    public virtual FixAllProvider GetFixAllProvider();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class WinRT.SourceGenerator.WinRTAotDiagnosticAnalyzer : DiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static WinRTAotDiagnosticAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class WinRT.SourceGenerator.WinRTAotEnableUnsafeCodeFixer : CodeFixProvider {
    private static string title;
    private static ImmutableArray`1<string> _fixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static WinRTAotEnableUnsafeCodeFixer();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static void RegisterCodeFixes(CodeFixContext context);
    private static Task`1<Solution> EnableUnsafe(Solution solution, Project project, CancellationToken token);
    public virtual FixAllProvider GetFixAllProvider();
}
public class WinRT.SourceGenerator.WinRTRules : object {
    public static DiagnosticDescriptor PrivateGetterRule;
    public static DiagnosticDescriptor DisjointNamespaceRule;
    public static DiagnosticDescriptor NamespacesDifferByCase;
    public static DiagnosticDescriptor NoPublicTypesRule;
    public static DiagnosticDescriptor GenericTypeRule;
    public static DiagnosticDescriptor UnsealedClassRule;
    public static DiagnosticDescriptor UnsupportedTypeRule;
    public static DiagnosticDescriptor StructWithNoFieldsRule;
    public static DiagnosticDescriptor NonWinRTInterface;
    public static DiagnosticDescriptor ClassConstructorRule;
    public static DiagnosticDescriptor ParameterNamedValueRule;
    public static DiagnosticDescriptor StructHasPrivateFieldRule;
    public static DiagnosticDescriptor StructHasConstFieldRule;
    public static DiagnosticDescriptor StructHasInvalidFieldRule;
    public static DiagnosticDescriptor OperatorOverloadedRule;
    public static DiagnosticDescriptor MultipleDefaultOverloadAttribute;
    public static DiagnosticDescriptor NeedDefaultOverloadAttribute;
    public static DiagnosticDescriptor JaggedArrayRule;
    public static DiagnosticDescriptor MultiDimensionalArrayRule;
    public static DiagnosticDescriptor RefParameterFound;
    public static DiagnosticDescriptor ArrayMarkedInOrOut;
    public static DiagnosticDescriptor NonArrayMarkedInOrOut;
    public static DiagnosticDescriptor ArrayParamMarkedBoth;
    public static DiagnosticDescriptor ArrayOutputParamMarkedRead;
    public static DiagnosticDescriptor ArrayParamNotMarked;
    public static DiagnosticDescriptor NonArrayMarked;
    public static DiagnosticDescriptor UnimplementedInterface;
    public static DiagnosticDescriptor ClassNotAotCompatibleWarning;
    public static DiagnosticDescriptor ClassNotAotCompatibleInfo;
    public static DiagnosticDescriptor ClassNotAotCompatibleOldProjectionWarning;
    public static DiagnosticDescriptor ClassNotAotCompatibleOldProjectionInfo;
    public static DiagnosticDescriptor ClassEnableUnsafeWarning;
    public static DiagnosticDescriptor ClassEnableUnsafeInfo;
    private static WinRTRules();
    private static DiagnosticDescriptor MakeRule(string id, string title, string messageFormat, bool isError, bool isWarning);
}
