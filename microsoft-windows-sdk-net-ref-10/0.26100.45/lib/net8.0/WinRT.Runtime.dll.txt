[GuidAttribute("30DA92C0-23E8-42A0-AE7C-734A0E5D2782")]
internal interface ABI.Microsoft.UI.Xaml.Data.ICustomProperty {
    public static IntPtr AbiToProjectionVftablePtr;
    public static Guid IID { get; }
    private static ICustomProperty();
    public static Guid get_IID();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetValue_2(IntPtr thisPtr, IntPtr target, IntPtr* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_SetValue_3(IntPtr thisPtr, IntPtr target, IntPtr value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetIndexedValue_4(IntPtr thisPtr, IntPtr target, IntPtr index, IntPtr* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_SetIndexedValue_5(IntPtr thisPtr, IntPtr target, IntPtr value, IntPtr index);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_CanRead_7(IntPtr thisPtr, Byte* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_CanWrite_6(IntPtr thisPtr, Byte* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Name_1(IntPtr thisPtr, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Type_0(IntPtr thisPtr, Type* value);
}
internal static class ABI.Microsoft.UI.Xaml.Data.ICustomProperty_Delegates : object {
}
[GuidAttribute("D026DD64-5F26-5F15-A86A-0DEC8A431796")]
internal class ABI.Microsoft.UI.Xaml.Data.IDataErrorsChangedEventArgsVftbl : ValueType {
    internal Vftbl IInspectableVftbl;
    private Void* _get_PropertyName_0;
    private Void* _put_PropertyName_1;
    public method get_PropertyName_0 { get; }
    public method put_PropertyName_1 { get; }
    public method get_get_PropertyName_0();
    public method get_put_PropertyName_1();
}
[WinRTExposedTypeAttribute("ABI.Microsoft.UI.Xaml.Data.ManagedCustomPropertyWinRTTypeDetails")]
internal class ABI.Microsoft.UI.Xaml.Data.ManagedCustomProperty : object {
    private PropertyInfo _property;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public string Name { get; }
    public Type Type { get; }
    public ManagedCustomProperty(PropertyInfo property);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual string get_Name();
    public sealed virtual Type get_Type();
    public sealed virtual object GetIndexedValue(object target, object index);
    public sealed virtual object GetValue(object target);
    public sealed virtual void SetIndexedValue(object target, object value, object index);
    public sealed virtual void SetValue(object target, object value);
}
[GuidAttribute("7C925755-3E48-42B4-8677-76372267033F")]
internal class ABI.Microsoft.UI.Xaml.Data.ManagedCustomPropertyProviderVftbl : ValueType {
    internal Vftbl IInspectableVftbl;
    private Void* GetCustomProperty_0;
    private Void* GetIndexedProperty_1;
    private Void* GetStringRepresentation_2;
    private Void* get_Type_3;
    private static ManagedCustomPropertyProviderVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    private static ManagedCustomPropertyProviderVftbl();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetCustomProperty_0(IntPtr thisPtr, IntPtr name, IntPtr* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetIndexedProperty_1(IntPtr thisPtr, IntPtr name, Type type, IntPtr* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetStringRepresentation_2(IntPtr thisPtr, IntPtr* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Type_3(IntPtr thisPtr, Type* value);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2075")]
internal static void <Do_Abi_GetCustomProperty_0>g__GetCustomPropertyForJit|8_0(object target, string name, IntPtr* result);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2075")]
internal static void <Do_Abi_GetIndexedProperty_1>g__GetCustomPropertyForJit|9_0(object target, string name, Type type, IntPtr* result);
}
internal class ABI.Microsoft.UI.Xaml.Data.ManagedCustomPropertyWinRTTypeDetails : object {
    public sealed virtual ComInterfaceEntry[] GetExposedInterfaces();
}
internal class ABI.Microsoft.UI.Xaml.Data.PropertyChangedEventArgsRuntimeClassFactory : object {
    private IObjectReference _obj;
    public IObjectReference CreateInstance(string name, object baseInterface, IObjectReference& innerInterface);
    public ObjectReferenceValue CreateInstance(string name);
}
[GuidAttribute("62D0BD1E-B85F-5FCC-842A-7CB0DDA37FE5")]
internal class ABI.Microsoft.UI.Xaml.Data.WinRTDataErrorsChangedEventArgsRuntimeClassFactory : object {
    private ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public WinRTDataErrorsChangedEventArgsRuntimeClassFactory(IObjectReference obj);
    public WinRTDataErrorsChangedEventArgsRuntimeClassFactory(ObjectReference`1<Vftbl> obj);
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public IntPtr get_ThisPtr();
    public IObjectReference CreateInstance(string name);
    public ObjectReferenceValue CreateInstanceForMarshaling(string name);
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("036D2C08-DF29-41AF-8AA2-D774BE62BA6F")]
internal interface ABI.Microsoft.UI.Xaml.Interop.IBindableIterable {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("6A1D6C07-076D-49F2-8314-F52C9C9A8331")]
internal interface ABI.Microsoft.UI.Xaml.Interop.IBindableIterator {
    public static IntPtr AbiToProjectionVftablePtr;
    private object global::Microsoft.UI.Xaml.Interop.IBindableIterator.Current { get; }
    private bool global::Microsoft.UI.Xaml.Interop.IBindableIterator.HasCurrent { get; }
    private static IBindableIterator();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_MoveNext_2(IntPtr thisPtr, Byte* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetMany_3(IntPtr thisPtr, int __itemsSize, IntPtr items, UInt32* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Current_0(IntPtr thisPtr, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_HasCurrent_1(IntPtr thisPtr, Byte* value);
    internal static ObjectReference`1<IUnknownVftbl> FromAbi(IntPtr thisPtr);
    private sealed virtual override bool global::Microsoft.UI.Xaml.Interop.IBindableIterator.MoveNext();
    private sealed virtual override UInt32 global::Microsoft.UI.Xaml.Interop.IBindableIterator.GetMany(Object[]& items);
    private sealed virtual override object global::Microsoft.UI.Xaml.Interop.IBindableIterator.get_Current();
    private sealed virtual override bool global::Microsoft.UI.Xaml.Interop.IBindableIterator.get_HasCurrent();
}
[EditorBrowsableAttribute("1")]
internal static class ABI.Microsoft.UI.Xaml.Interop.IBindableIterator_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("346DD6E7-976E-4BC3-815D-ECE243BC0F33")]
internal interface ABI.Microsoft.UI.Xaml.Interop.IBindableVectorView {
    public static IntPtr AbiToProjectionVftablePtr;
    private static ConditionalWeakTable`2<IWinRTObject, FromAbiHelper> _helperTable;
    private UInt32 global::Microsoft.UI.Xaml.Interop.IBindableVectorView.Size { get; }
    private static IBindableVectorView();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetAt_0(IntPtr thisPtr, UInt32 index, IntPtr* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_IndexOf_2(IntPtr thisPtr, IntPtr value, UInt32* index, Byte* returnValue);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Size_1(IntPtr thisPtr, UInt32* value);
    internal static ObjectReference`1<IUnknownVftbl> FromAbi(IntPtr thisPtr);
    private sealed virtual override object global::Microsoft.UI.Xaml.Interop.IBindableVectorView.GetAt(UInt32 index);
    private sealed virtual override bool global::Microsoft.UI.Xaml.Interop.IBindableVectorView.IndexOf(object value, UInt32& index);
    private sealed virtual override UInt32 global::Microsoft.UI.Xaml.Interop.IBindableVectorView.get_Size();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[EditorBrowsableAttribute("1")]
internal static class ABI.Microsoft.UI.Xaml.Interop.IBindableVectorView_Delegates : object {
}
[GuidAttribute("5108EBA4-4892-5A20-8374-A96815E0FD27")]
internal class ABI.Microsoft.UI.Xaml.Interop.WinRTNotifyCollectionChangedEventArgsRuntimeClassFactory : object {
    private IObjectReference _obj;
    public static WinRTNotifyCollectionChangedEventArgsRuntimeClassFactory Instance;
    public IntPtr ThisPtr { get; }
    private static WinRTNotifyCollectionChangedEventArgsRuntimeClassFactory();
    public IntPtr get_ThisPtr();
    public ObjectReferenceValue CreateInstanceWithAllParameters(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newIndex, int oldIndex);
}
internal class ABI.System.Boolean : ValueType {
    public static bool CreateMarshaler(bool value);
    public static byte GetAbi(bool value);
    public static bool FromAbi(byte abi);
    public static void CopyAbi(bool value, IntPtr dest);
    public static byte FromManaged(bool value);
    public static void CopyManaged(bool arg, IntPtr dest);
    public static void DisposeMarshaler(bool m);
    public static void DisposeAbi(byte abi);
}
internal class ABI.System.Char : ValueType {
    public static char CreateMarshaler(char value);
    public static ushort GetAbi(char value);
    public static char FromAbi(ushort abi);
    public static void CopyAbi(char value, IntPtr dest);
    public static ushort FromManaged(char value);
    public static void CopyManaged(char arg, IntPtr dest);
    public static void DisposeMarshaler(char m);
    public static void DisposeAbi(ushort abi);
}
[DefaultMemberAttribute("Item")]
internal class ABI.System.Collections.Generic.ConstantSplittableMap`2 : object {
    private static KeyValuePairComparator<K, V> keyValuePairComparator;
    private KeyValuePair`2[] items;
    private int firstItemIndex;
    private int lastItemIndex;
    public UInt32 Size { get; }
    public IEnumerable`1<K> Keys { get; }
    public IEnumerable`1<V> Values { get; }
    public int Count { get; }
    public V Item { get; }
    internal ConstantSplittableMap`2(IReadOnlyDictionary`2<K, V> data);
    private ConstantSplittableMap`2(KeyValuePair`2[] items, int firstItemIndex, int lastItemIndex);
    private static ConstantSplittableMap`2();
    private KeyValuePair`2[] CreateKeyValueArray(int count, IEnumerator`1<KeyValuePair`2<K, V>> data);
    public sealed virtual UInt32 get_Size();
    public sealed virtual IEnumerable`1<K> get_Keys();
    public sealed virtual IEnumerable`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual V get_Item(K key);
    public sealed virtual V Lookup(K key);
    public sealed virtual bool HasKey(K key);
    public IEnumerator`1<KeyValuePair`2<K, V>> First();
    public sealed virtual void Split(IMapView`2& firstPartition, IMapView`2& secondPartition);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual bool ContainsKey(K key);
    private sealed virtual override IEnumerator`1<IKeyValuePair`2<K, V>> global::Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>>.First();
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
internal class ABI.System.Collections.Generic.ConstantSplittableMapEnumerator`1 : ValueType {
    private T[] _array;
    private int _start;
    private int _end;
    private int _current;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal ConstantSplittableMapEnumerator`1(T[] items, int first, int end);
    public sealed virtual bool MoveNext();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    public sealed virtual void Dispose();
}
internal class ABI.System.Collections.Generic.FromAbiEnumerator`1 : object {
    private IIterator`1<T> _iterator;
    private bool m_hadCurrent;
    private T m_current;
    private bool m_isInitialized;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public FromAbiEnumerator`1(IObjectReference obj);
    internal FromAbiEnumerator`1(IIterator`1<T> iterator);
    public static IEnumerator`1<T> FromAbi(IntPtr abi);
    public static void DisposeAbi(IntPtr abi);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
internal class ABI.System.Collections.Generic.IBindableIteratorTypeDetails : object {
    public sealed virtual ComInterfaceEntry[] GetExposedInterfaces();
}
[DynamicInterfaceCastableImplementationAttribute]
internal interface ABI.System.Collections.Generic.ICollection`1 {
    private int global::System.Collections.Generic.ICollection<T>.Count { get; }
    private bool global::System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private static ICollection`1<T> CreateHelper(RuntimeTypeHandle type, IWinRTObject _this);
    private static ICollection`1<T> GetHelper(IWinRTObject _this);
    private sealed virtual override int global::System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> global::System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
public static class ABI.System.Collections.Generic.IDictionary_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("3C2925FE-8519-45C1-AA79-197B6718C1C1")]
internal interface ABI.System.Collections.Generic.IDictionary`2 {
    public static IntPtr AbiToProjectionVftablePtr;
    private static ConditionalWeakTable`2<IDictionary`2<K, V>, ToAbiHelper<K, V>> _adapterTable;
    public static Guid PIID;
    private ICollection`1<K> global::System.Collections.Generic.IDictionary<K,V>.Keys { get; }
    private ICollection`1<V> global::System.Collections.Generic.IDictionary<K,V>.Values { get; }
    private int global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.Count { get; }
    private bool global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.IsReadOnly { get; }
    private V global::System.Collections.Generic.IDictionary<K,V>.Item { get; private set; }
    private static IDictionary`2();
    public static IObjectReference CreateMarshaler(IDictionary`2<K, V> obj);
    public static ObjectReferenceValue CreateMarshaler2(IDictionary`2<K, V> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IDictionary`2<K, V> FromAbi(IntPtr thisPtr);
    public static IntPtr FromManaged(IDictionary`2<K, V> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    internal static IMap`2<K, V> FindAdapter(IntPtr thisPtr);
    public static ObjectReference`1<IUnknownVftbl> ObjRefFromAbi(IntPtr thisPtr);
    private sealed virtual override ICollection`1<K> global::System.Collections.Generic.IDictionary<K,V>.get_Keys();
    private sealed virtual override ICollection`1<V> global::System.Collections.Generic.IDictionary<K,V>.get_Values();
    private sealed virtual override int global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.get_Count();
    private sealed virtual override bool global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.get_IsReadOnly();
    private sealed virtual override V global::System.Collections.Generic.IDictionary<K,V>.get_Item(K key);
    private sealed virtual override void global::System.Collections.Generic.IDictionary<K,V>.set_Item(K key, V value);
    private sealed virtual override void global::System.Collections.Generic.IDictionary<K,V>.Add(K key, V value);
    private sealed virtual override bool global::System.Collections.Generic.IDictionary<K,V>.ContainsKey(K key);
    private sealed virtual override bool global::System.Collections.Generic.IDictionary<K,V>.Remove(K key);
    private sealed virtual override bool global::System.Collections.Generic.IDictionary<K,V>.TryGetValue(K key, V& value);
    private sealed virtual override void global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.Add(KeyValuePair`2<K, V> item);
    private sealed virtual override bool global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.Contains(KeyValuePair`2<K, V> item);
    private sealed virtual override void global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.Remove(KeyValuePair`2<K, V> item);
    private sealed virtual override void global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.Clear();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> global::System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <.cctor>g__InitFallbackCCWVTableIfNeeded|10_0();
}
public static class ABI.System.Collections.Generic.IDictionaryMethods`2 : object {
    private static IntPtr abiToProjectionVftablePtr;
    internal static Guid PIID;
    public static IntPtr AbiToProjectionVftablePtr { get; }
    public static Guid IID { get; }
    private static IDictionaryMethods`2();
    public static int get_Count(IObjectReference obj);
    public static bool get_IsReadOnly(IObjectReference _);
    public static void Add(IObjectReference obj, KeyValuePair`2<K, V> item);
    public static void Clear(IObjectReference obj);
    public static bool Contains(IObjectReference obj, Dictionary`2<K, ValueTuple`2<IntPtr, V>> __lookupCache, KeyValuePair`2<K, V> item);
    public static void CopyTo(IObjectReference obj, IObjectReference iEnumerableObjRef, KeyValuePair`2[] array, int arrayIndex);
    public static bool Remove(IObjectReference obj, KeyValuePair`2<K, V> item);
    public static V Indexer_Get(IObjectReference obj, Dictionary`2<K, ValueTuple`2<IntPtr, V>> __lookupCache, K key);
    public static void Indexer_Set(IObjectReference obj, K key, V value);
    public static ICollection`1<K> get_Keys(IObjectReference obj);
    public static ICollection`1<V> get_Values(IObjectReference obj);
    public static bool ContainsKey(IObjectReference obj, K key);
    public static void Add(IObjectReference obj, K key, V value);
    public static bool Remove(IObjectReference obj, K key);
    public static bool TryGetValue(IObjectReference obj, Dictionary`2<K, ValueTuple`2<IntPtr, V>> __lookupCache, K key, V& value);
    private static V Lookup(IObjectReference obj, K key);
    private static bool Insert(IObjectReference obj, K key, V value);
    public static IntPtr get_AbiToProjectionVftablePtr();
    internal static bool TryInitCCWVtable(IntPtr ptr);
    public static Guid get_IID();
    public static V Abi_Lookup_0(IntPtr thisPtr, K key);
    public static bool Abi_HasKey_2(IntPtr thisPtr, K key);
    public static IReadOnlyDictionary`2<K, V> Abi_GetView_3(IntPtr thisPtr);
    public static bool Abi_Insert_4(IntPtr thisPtr, K key, V value);
    public static void Abi_Remove_5(IntPtr thisPtr, K key);
    public static void Abi_Clear_6(IntPtr thisPtr);
    public static UInt32 Abi_get_Size_1(IntPtr thisPtr);
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <.cctor>g__InitRcwHelperFallbackIfNeeded|0_0();
}
public static class ABI.System.Collections.Generic.IDictionaryMethods`4 : object {
    internal static method _Lookup;
    internal static method _HasKey;
    internal static method _GetView;
    internal static method _Insert;
    internal static method _Remove;
    private static Delegate[] DelegateCache;
    private static Type _lookup_0_type;
    private static Type _hasKey_2_type;
    private static Type _insert_4_type;
    private static Type _remove_5_type;
    private static Type Lookup_0_Type { get; }
    private static Type HasKey_2_Type { get; }
    private static Type Insert_4_Type { get; }
    private static Type Remove_5_Type { get; }
    public static bool InitRcwHelper(method lookup, method hasKey, method getView, method insert, method remove);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static bool InitRcwHelperFallback();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static V LookupDynamic(IObjectReference obj, K key);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static bool HasKeyDynamic(IObjectReference obj, K key);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static bool InsertDynamic(IObjectReference obj, K key, V value);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static void RemoveDynamic(IObjectReference obj, K key);
    public static bool InitCcw(method lookup, method getSize, method hasKey, method getView, method insert, method remove, method clear);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
internal static void InitFallbackCCWVtable();
    private static int Do_Abi_Lookup_0(Void* thisPtr, KAbi key, VAbi* __return_value__);
    private static int Do_Abi_HasKey_2(Void* thisPtr, KAbi key, Byte* __return_value__);
    private static int Do_Abi_GetView_3(IntPtr thisPtr, IntPtr* __return_value__);
    private static int Do_Abi_Insert_4(Void* thisPtr, KAbi key, VAbi value, Byte* __return_value__);
    private static int Do_Abi_Remove_5(Void* thisPtr, KAbi key);
    private static int Do_Abi_Clear_6(IntPtr thisPtr);
    private static int Do_Abi_get_Size_1(IntPtr thisPtr, UInt32* __return_value__);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type get_Lookup_0_Type();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type MakeLookupType();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type get_HasKey_2_Type();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type MakeHasKeyType();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type get_Insert_4_Type();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type MakeInsertType();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type get_Remove_5_Type();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type MakeRemoveType();
}
public static class ABI.System.Collections.Generic.IEnumerable_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("FAA585EA-6214-4217-AFDA-7F46DE5869B3")]
internal interface ABI.System.Collections.Generic.IEnumerable`1 {
    public static IntPtr AbiToProjectionVftablePtr;
    public static Guid PIID;
    private static IEnumerable`1();
    public static IObjectReference CreateMarshaler(IEnumerable`1<T> obj);
    public static ObjectReferenceValue CreateMarshaler2(IEnumerable`1<T> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr FromManaged(IEnumerable`1<T> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    public static ObjectReference`1<IUnknownVftbl> ObjRefFromAbi(IntPtr thisPtr);
    private sealed virtual override IEnumerator`1<T> global::System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <.cctor>g__InitFallbackCCWVTableIfNeeded|9_0();
}
public static class ABI.System.Collections.Generic.IEnumerableMethods`1 : object {
    private static IntPtr abiToProjectionVftablePtr;
    internal static Guid PIID;
    public static IntPtr AbiToProjectionVftablePtr { get; }
    public static Guid IID { get; }
    private static IEnumerableMethods`1();
    public static IEnumerator`1<T> GetEnumerator(IObjectReference obj);
    public static IntPtr get_AbiToProjectionVftablePtr();
    internal static bool TryInitCCWVtable(IntPtr ptr);
    public static IEnumerator`1<T> Abi_First_0(IntPtr thisPtr);
    public static Guid get_IID();
}
public static class ABI.System.Collections.Generic.IEnumerableMethods`2 : object {
    private static First_0_Abi DelegateCache;
    public static bool InitRcwHelper(method first);
    public static bool InitCcw(method first);
    internal static void InitFallbackCCWVtable();
    private static int Do_Abi_First_0(IntPtr thisPtr, IntPtr* __return_value__);
}
public static class ABI.System.Collections.Generic.IEnumerator_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("6A79E863-4300-459A-9966-CBB660963EE1")]
internal interface ABI.System.Collections.Generic.IEnumerator`1 {
    public static IntPtr AbiToProjectionVftablePtr;
    private static ConditionalWeakTable`2<IEnumerator`1<T>, ToAbiHelper<T>> _adapterTable;
    public static Guid PIID;
    private T global::System.Collections.Generic.IEnumerator<T>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    private static IEnumerator`1();
    public static IObjectReference CreateMarshaler(IEnumerator`1<T> obj);
    public static ObjectReferenceValue CreateMarshaler2(IEnumerator`1<T> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr FromManaged(IEnumerator`1<T> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    internal static ToAbiHelper<T> FindAdapter(IntPtr thisPtr);
    public static ObjectReference`1<IUnknownVftbl> ObjRefFromAbi(IntPtr thisPtr);
    private sealed virtual override T global::System.Collections.Generic.IEnumerator<T>.get_Current();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <.cctor>g__InitFallbackCCWVTableIfNeeded|9_0();
}
public static class ABI.System.Collections.Generic.IEnumeratorMethods`1 : object {
    private static IntPtr abiToProjectionVftablePtr;
    internal static Guid PIID;
    public static IntPtr AbiToProjectionVftablePtr { get; }
    public static Guid IID { get; }
    private static IEnumeratorMethods`1();
    public static T get_Current(IObjectReference obj);
    public static bool MoveNext(IObjectReference obj);
    public static void Reset(IObjectReference obj);
    public static void Dispose(IObjectReference obj);
    public static IntPtr get_AbiToProjectionVftablePtr();
    internal static bool TryInitCCWVtable(IntPtr ptr);
    public static bool Abi_MoveNext_2(IntPtr thisPtr);
    public static UInt32 Abi_GetMany_3(IntPtr thisPtr, T[]& items);
    public static T Abi_get_Current_0(IntPtr thisPtr);
    public static bool Abi_get_HasCurrent_1(IntPtr thisPtr);
    public static Guid get_IID();
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <.cctor>g__InitRcwHelperFallbackIfNeeded|0_0();
}
public static class ABI.System.Collections.Generic.IEnumeratorMethods`2 : object {
    private static Delegate[] DelegateCache;
    public static bool InitRcwHelper(method getCurrent, method getMany);
    private static bool InitRcwHelperFallback();
    private static T get_Current(IObjectReference obj);
    public static bool InitCcw(method getCurrent, method hasCurrent, method moveNext, method getMany);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
internal static void InitFallbackCCWVtable();
    private static int Do_Abi_MoveNext_2(IntPtr thisPtr, Byte* __return_value__);
    private static int Do_Abi_GetMany_3(IntPtr thisPtr, int __itemsSize, IntPtr items, UInt32* __return_value__);
    private static int Do_Abi_get_Current_0(IntPtr thisPtr, TAbi* __return_value__);
    private static int Do_Abi_get_HasCurrent_1(IntPtr thisPtr, Byte* __return_value__);
}
internal static class ABI.System.Collections.Generic.IIteratorMethods`1 : object {
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _GetCurrent;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _GetMany;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _RcwHelperInitialized;
    public static bool MoveNext(IObjectReference obj);
    public static UInt32 GetMany(IObjectReference obj, T[]& items);
    public static T get_Current(IObjectReference obj);
    public static bool get_HasCurrent(IObjectReference obj);
}
public static class ABI.System.Collections.Generic.IList_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("913337E9-11A1-4345-A3A2-4E7F956E222D")]
internal interface ABI.System.Collections.Generic.IList`1 {
    public static IntPtr AbiToProjectionVftablePtr;
    private static ConditionalWeakTable`2<IList`1<T>, ToAbiHelper<T>> _adapterTable;
    public static Guid PIID;
    private UInt32 global::Windows.Foundation.Collections.IVector<T>.Size { get; }
    private int global::System.Collections.Generic.ICollection<T>.Count { get; }
    private bool global::System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T global::System.Collections.Generic.IList<T>.Item { get; private set; }
    private static IList`1();
    public static IObjectReference CreateMarshaler(IList`1<T> obj);
    public static ObjectReferenceValue CreateMarshaler2(IList`1<T> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr FromManaged(IList`1<T> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    internal static IVector`1<T> FindAdapter(IntPtr thisPtr);
    public static ObjectReference`1<IUnknownVftbl> ObjRefFromAbi(IntPtr thisPtr);
    private sealed virtual override T global::Windows.Foundation.Collections.IVector<T>.GetAt(UInt32 index);
    private sealed virtual override IReadOnlyList`1<T> global::Windows.Foundation.Collections.IVector<T>.GetView();
    private sealed virtual override bool global::Windows.Foundation.Collections.IVector<T>.IndexOf(T value, UInt32& index);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.SetAt(UInt32 index, T value);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.InsertAt(UInt32 index, T value);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.RemoveAt(UInt32 index);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.Append(T value);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.RemoveAtEnd();
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>._Clear();
    private sealed virtual override UInt32 global::Windows.Foundation.Collections.IVector<T>.GetMany(UInt32 startIndex, T[]& items);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.ReplaceAll(T[] items);
    private sealed virtual override UInt32 global::Windows.Foundation.Collections.IVector<T>.get_Size();
    private sealed virtual override int global::System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T global::System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void global::System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override int global::System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void global::System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void global::System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> global::System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <.cctor>g__InitFallbackCCWVTableIfNeeded|9_0();
}
public static class ABI.System.Collections.Generic.IListMethods`1 : object {
    private static IntPtr abiToProjectionVftablePtr;
    internal static Guid PIID;
    public static IntPtr AbiToProjectionVftablePtr { get; }
    public static Guid IID { get; }
    private static IListMethods`1();
    public static int get_Count(IObjectReference obj);
    public static bool get_IsReadOnly(IObjectReference obj);
    public static void Add(IObjectReference obj, T item);
    public static void Clear(IObjectReference obj);
    public static bool Contains(IObjectReference obj, T item);
    public static void CopyTo(IObjectReference obj, T[] array, int arrayIndex);
    public static bool Remove(IObjectReference obj, T item);
    public static T Indexer_Get(IObjectReference obj, int index);
    public static void Indexer_Set(IObjectReference obj, int index, T value);
    public static int IndexOf(IObjectReference obj, T item);
    public static void Insert(IObjectReference obj, int index, T item);
    public static void RemoveAt(IObjectReference obj, int index);
    internal static T GetAtHelper(IObjectReference obj, UInt32 index);
    private static void SetAtHelper(IObjectReference obj, UInt32 index, T value);
    private static void InsertAtHelper(IObjectReference obj, UInt32 index, T item);
    internal static void RemoveAtHelper(IObjectReference obj, UInt32 index);
    public static IntPtr get_AbiToProjectionVftablePtr();
    internal static bool TryInitCCWVtable(IntPtr ptr);
    public static T Abi_GetAt_0(IntPtr thisPtr, UInt32 index);
    public static IReadOnlyList`1<T> Abi_GetView_2(IntPtr thisPtr);
    public static bool Abi_IndexOf_3(IntPtr thisPtr, T value, UInt32& index);
    public static void Abi_SetAt_4(IntPtr thisPtr, UInt32 index, T value);
    public static void Abi_InsertAt_5(IntPtr thisPtr, UInt32 index, T value);
    public static void Abi_RemoveAt_6(IntPtr thisPtr, UInt32 index);
    public static void Abi_Append_7(IntPtr thisPtr, T value);
    public static void Abi_RemoveAtEnd_8(IntPtr thisPtr);
    public static void Abi_Clear_9(IntPtr thisPtr);
    public static UInt32 Abi_GetMany_10(IntPtr thisPtr, UInt32 startIndex, T[]& items);
    public static void Abi_ReplaceAll_11(IntPtr thisPtr, T[] items);
    public static UInt32 Abi_get_Size_1(IntPtr thisPtr);
    public static Guid get_IID();
    internal static bool EnsureEnumerableInitialized();
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <.cctor>g__InitRcwHelperFallbackIfNeeded|0_0();
}
public static class ABI.System.Collections.Generic.IListMethods`2 : object {
    private static Delegate[] DelegateCache;
    private static Type _indexOf_3_type;
    private static Type _setAtInsertAt_Type;
    private static Type _append_7_Type;
    private static Type IndexOf_3_Type { get; }
    private static Type SetAtInsertAt_Type { get; }
    private static Type Append_7_Type { get; }
    public static bool InitRcwHelper(method getAt, method getView, method indexOf, method setAt, method insertAt, method append, method getMany, method replaceAll);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static bool InitRcwHelperFallback();
    private static T GetAtDynamic(IObjectReference obj, UInt32 index);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static bool IndexOfDynamic(IObjectReference obj, T value, UInt32& index);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static void SetAtDynamic(IObjectReference obj, UInt32 index, T value);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static void InsertAtDynamic(IObjectReference obj, UInt32 index, T value);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static void AppendDynamic(IObjectReference obj, T value);
    public static bool InitCcw(method getAt, method getSize, method getView, method indexOf, method setAt, method insertAt, method removeAt, method append, method removeAtEnd, method clear, method getMany, method replaceAll);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
internal static void InitFallbackCCWVtable();
    private static int Do_Abi_GetAt_0(Void* thisPtr, UInt32 index, TAbi* __return_value__);
    private static int Do_Abi_GetView_2(IntPtr thisPtr, IntPtr* __return_value__);
    private static int Do_Abi_IndexOf_3(Void* thisPtr, TAbi value, UInt32* index, Byte* __return_value__);
    private static int Do_Abi_SetAt_4(Void* thisPtr, UInt32 index, TAbi value);
    private static int Do_Abi_InsertAt_5(Void* thisPtr, UInt32 index, TAbi value);
    private static int Do_Abi_RemoveAt_6(IntPtr thisPtr, UInt32 index);
    private static int Do_Abi_Append_7(Void* thisPtr, TAbi value);
    private static int Do_Abi_RemoveAtEnd_8(IntPtr thisPtr);
    private static int Do_Abi_Clear_9(IntPtr thisPtr);
    private static int Do_Abi_GetMany_10(IntPtr thisPtr, UInt32 startIndex, int __itemsSize, IntPtr items, UInt32* __return_value__);
    private static int Do_Abi_ReplaceAll_11(IntPtr thisPtr, int __itemsSize, IntPtr items);
    private static int Do_Abi_get_Size_1(IntPtr thisPtr, UInt32* __return_value__);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type get_IndexOf_3_Type();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type MakeIndexOfType();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type get_SetAtInsertAt_Type();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type MakeSetAtInsertAtType();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type get_Append_7_Type();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type MakeAppendType();
}
[DynamicInterfaceCastableImplementationAttribute]
internal interface ABI.System.Collections.Generic.IReadOnlyCollection`1 {
    private int global::System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private static IReadOnlyCollection`1<T> CreateHelper(RuntimeTypeHandle type, IWinRTObject _this);
    private static IReadOnlyCollection`1<T> GetHelper(IWinRTObject _this);
    private sealed virtual override int global::System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> global::System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
public static class ABI.System.Collections.Generic.IReadOnlyDictionary_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("E480CE40-A338-4ADA-ADCF-272272E48CB9")]
internal interface ABI.System.Collections.Generic.IReadOnlyDictionary`2 {
    public static IntPtr AbiToProjectionVftablePtr;
    private static ConditionalWeakTable`2<IReadOnlyDictionary`2<K, V>, ToAbiHelper<K, V>> _adapterTable;
    public static Guid PIID;
    private IEnumerable`1<K> global::System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    private IEnumerable`1<V> global::System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    private int global::System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<K,V>>.Count { get; }
    private V global::System.Collections.Generic.IReadOnlyDictionary<K,V>.Item { get; }
    private static IReadOnlyDictionary`2();
    public static IObjectReference CreateMarshaler(IReadOnlyDictionary`2<K, V> obj);
    public static ObjectReferenceValue CreateMarshaler2(IReadOnlyDictionary`2<K, V> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr FromManaged(IReadOnlyDictionary`2<K, V> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    internal static IMapView`2<K, V> FindAdapter(IntPtr thisPtr);
    public static ObjectReference`1<IUnknownVftbl> ObjRefFromAbi(IntPtr thisPtr);
    private sealed virtual override IEnumerable`1<K> global::System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> global::System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    private sealed virtual override int global::System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<K,V>>.get_Count();
    private sealed virtual override V global::System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Item(K key);
    private sealed virtual override bool global::System.Collections.Generic.IReadOnlyDictionary<K,V>.ContainsKey(K key);
    private sealed virtual override bool global::System.Collections.Generic.IReadOnlyDictionary<K,V>.TryGetValue(K key, V& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> global::System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <.cctor>g__InitFallbackCCWVTableIfNeeded|9_0();
}
public static class ABI.System.Collections.Generic.IReadOnlyDictionaryMethods`2 : object {
    private static IntPtr abiToProjectionVftablePtr;
    internal static Guid PIID;
    public static IntPtr AbiToProjectionVftablePtr { get; }
    public static Guid IID { get; }
    private static IReadOnlyDictionaryMethods`2();
    public static int get_Count(IObjectReference obj);
    public static V Indexer_Get(IObjectReference obj, K key);
    public static IEnumerable`1<K> get_Keys(IObjectReference obj);
    public static IEnumerable`1<V> get_Values(IObjectReference obj);
    public static bool ContainsKey(IObjectReference obj, K key);
    public static bool TryGetValue(IObjectReference obj, K key, V& value);
    public static V Lookup(IObjectReference obj, K key);
    public static IntPtr get_AbiToProjectionVftablePtr();
    internal static bool TryInitCCWVtable(IntPtr ptr);
    public static Guid get_IID();
    public static V Abi_Lookup_0(IntPtr thisPtr, K key);
    public static bool Abi_HasKey_2(IntPtr thisPtr, K key);
    public static void Abi_Split_3(IntPtr thisPtr, IntPtr& first, IntPtr& second);
    public static UInt32 Abi_get_Size_1(IntPtr thisPtr);
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <.cctor>g__InitRcwHelperFallbackIfNeeded|0_0();
}
public static class ABI.System.Collections.Generic.IReadOnlyDictionaryMethods`4 : object {
    private static Delegate[] DelegateCache;
    private static Type _lookup_0_type;
    private static Type _hasKey_2_type;
    private static Type Lookup_0_Type { get; }
    private static Type HasKey_2_Type { get; }
    public static bool InitRcwHelper(method lookup, method hasKey, method _);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static bool InitRcwHelperFallback();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static V LookupDynamic(IObjectReference obj, K key);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static bool HasKeyDynamic(IObjectReference obj, K key);
    public static bool InitCcw(method lookup, method getSize, method hasKey, method split);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
internal static void InitFallbackCCWVtable();
    private static int Do_Abi_Lookup_0(IntPtr thisPtr, KAbi key, VAbi* __return_value__);
    private static int Do_Abi_HasKey_2(IntPtr thisPtr, KAbi key, Byte* __return_value__);
    private static int Do_Abi_Split_3(IntPtr thisPtr, IntPtr* first, IntPtr* second);
    private static int Do_Abi_get_Size_1(IntPtr thisPtr, UInt32* __return_value__);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type get_Lookup_0_Type();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type MakeLookupType();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type get_HasKey_2_Type();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Type MakeHasKeyType();
}
public static class ABI.System.Collections.Generic.IReadOnlyList_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("BBE1FA4C-B0E3-4583-BAEF-1F1B2E483E56")]
internal interface ABI.System.Collections.Generic.IReadOnlyList`1 {
    public static IntPtr AbiToProjectionVftablePtr;
    private static ConditionalWeakTable`2<IReadOnlyList`1<T>, ToAbiHelper<T>> _adapterTable;
    public static Guid PIID;
    private int global::System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private T global::System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private static IReadOnlyList`1();
    public static IObjectReference CreateMarshaler(IReadOnlyList`1<T> obj);
    public static ObjectReferenceValue CreateMarshaler2(IReadOnlyList`1<T> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr FromManaged(IReadOnlyList`1<T> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    internal static ToAbiHelper<T> FindAdapter(IntPtr thisPtr);
    public static ObjectReference`1<IUnknownVftbl> ObjRefFromAbi(IntPtr thisPtr);
    private sealed virtual override int global::System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override T global::System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override IEnumerator`1<T> global::System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <.cctor>g__InitFallbackCCWVTableIfNeeded|9_0();
}
public static class ABI.System.Collections.Generic.IReadOnlyListMethods`1 : object {
    private static IntPtr abiToProjectionVftablePtr;
    internal static Guid PIID;
    public static IntPtr AbiToProjectionVftablePtr { get; }
    public static Guid IID { get; }
    private static IReadOnlyListMethods`1();
    public static int get_Count(IObjectReference obj);
    public static T Indexer_Get(IObjectReference obj, int index);
    public static IntPtr get_AbiToProjectionVftablePtr();
    internal static bool TryInitCCWVtable(IntPtr ptr);
    public static T Abi_GetAt_0(IntPtr thisPtr, UInt32 index);
    public static bool Abi_IndexOf_2(IntPtr thisPtr, T value, UInt32& index);
    public static UInt32 Abi_GetMany_3(IntPtr thisPtr, UInt32 startIndex, T[]& items);
    public static UInt32 Abi_get_Size_1(IntPtr thisPtr);
    public static Guid get_IID();
}
public static class ABI.System.Collections.Generic.IReadOnlyListMethods`2 : object {
    private static Delegate[] DelegateCache;
    public static bool InitRcwHelper(method getAt, method indexOf, method getMany);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static bool InitRcwHelperFallback();
    private static T GetAtDynamic(IObjectReference obj, UInt32 index);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static bool IndexOfDynamic(IObjectReference obj, T value, UInt32& index);
    public static bool InitCcw(method getAt, method getSize, method indexOf, method getMany);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
internal static void InitFallbackCCWVtable();
    private static int Do_Abi_GetAt_0(IntPtr thisPtr, UInt32 index, TAbi* __return_value__);
    private static int Do_Abi_IndexOf_2(IntPtr thisPtr, TAbi value, UInt32* index, Byte* __return_value__);
    private static int Do_Abi_GetMany_3(IntPtr thisPtr, UInt32 startIndex, int __itemsSize, IntPtr items, UInt32* __return_value__);
    private static int Do_Abi_get_Size_1(IntPtr thisPtr, UInt32* __return_value__);
}
internal static class ABI.System.Collections.Generic.IVectorMethods`1 : object {
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _GetAt;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _GetView;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _IndexOf;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _SetAt;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _InsertAt;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _Append;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _GetMany;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _ReplaceAll;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _RcwHelperInitialized;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _EnsureEnumerableInitialized;
    public static UInt32 get_Size(IObjectReference obj);
    public static T GetAt(IObjectReference obj, UInt32 index);
    public static IReadOnlyList`1<T> GetView(IObjectReference obj);
    public static bool IndexOf(IObjectReference obj, T value, UInt32& index);
    public static void SetAt(IObjectReference obj, UInt32 index, T value);
    public static void InsertAt(IObjectReference obj, UInt32 index, T value);
    public static void RemoveAt(IObjectReference obj, UInt32 index);
    public static void Append(IObjectReference obj, T value);
    public static void RemoveAtEnd(IObjectReference obj);
    public static void Clear(IObjectReference obj);
    public static UInt32 GetMany(IObjectReference obj, UInt32 startIndex, T[]& items);
    public static void ReplaceAll(IObjectReference obj, T[] items);
}
[GuidAttribute("02B51929-C1C4-4A7E-8940-0312B5C18500")]
public class ABI.System.Collections.Generic.KeyValuePair`2 : object {
    public static IntPtr AbiToProjectionVftablePtr;
    private static ConditionalWeakTable`2<object, ToIKeyValuePair<K, V>> _adapterTable;
    public static Guid PIID;
    protected ObjectReference`1<IUnknownVftbl> _obj;
    public IObjectReference ObjRef { get; }
    public IntPtr ThisPtr { get; }
    public K Key { get; }
    public V Value { get; }
    private static KeyValuePair`2();
    public KeyValuePair`2(IObjectReference obj);
    public KeyValuePair`2(ObjectReference`1<IUnknownVftbl> obj);
    public static IObjectReference CreateMarshaler(KeyValuePair`2<K, V> obj);
    public static ObjectReferenceValue CreateMarshaler2(KeyValuePair`2<K, V> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static object CreateRcw(IInspectable obj);
    public static KeyValuePair`2<K, V> FromAbi(IntPtr thisPtr);
    public static IntPtr FromManaged(KeyValuePair`2<K, V> obj);
    internal static void CopyManaged(KeyValuePair`2<K, V> o, IntPtr dest);
    internal static MarshalerArray<KeyValuePair`2<K, V>> CreateMarshalerArray(KeyValuePair`2[] array);
    internal static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    internal static KeyValuePair`2[] FromAbiArray(object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(KeyValuePair`2[] array);
    internal static void CopyManagedArray(KeyValuePair`2[] array, IntPtr data);
    public static void CopyAbiArray(KeyValuePair`2[] array, object box);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    internal static ToIKeyValuePair<K, V> FindAdapter(IntPtr thisPtr);
    public static ObjectReference`1<IUnknownVftbl> _FromAbi(IntPtr thisPtr);
    public IObjectReference get_ObjRef();
    public IntPtr get_ThisPtr();
    public sealed virtual K get_Key();
    public sealed virtual V get_Value();
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <.cctor>g__InitFallbackCCWVTableIfNeeded|19_0();
}
public static class ABI.System.Collections.Generic.KeyValuePairMethods`2 : object {
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _GetKey;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _GetValue;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _RcwHelperInitialized;
    internal static Guid PIID;
    private static IntPtr abiToProjectionVftablePtr;
    public static Guid IID { get; }
    public static IntPtr AbiToProjectionVftablePtr { get; }
    private static KeyValuePairMethods`2();
    internal static bool EnsureInitialized();
    internal static K GetKey(IObjectReference obj);
    internal static V GetValue(IObjectReference obj);
    public static Guid get_IID();
    public static IntPtr get_AbiToProjectionVftablePtr();
    internal static bool TryInitCCWVtable(IntPtr ptr);
    public static K Abi_get_Key_0(IntPtr thisPtr);
    public static V Abi_get_Value_1(IntPtr thisPtr);
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <EnsureInitialized>g__InitRcwHelperFallbackIfNeeded|4_0();
}
public static class ABI.System.Collections.Generic.KeyValuePairMethods`4 : object {
    private static Delegate[] DelegateCache;
    public static bool InitRcwHelper(method getKey, method getValue);
    private static bool InitRcwHelperFallback();
    private static K get_Key(IObjectReference obj);
    private static V get_Value(IObjectReference obj);
    public static bool InitCcw(method getKey, method getValue);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
internal static void InitFallbackCCWVtable();
    private static int Do_Abi_get_Key_0(IntPtr thisPtr, KAbi* __return_value__);
    private static int Do_Abi_get_Value_1(IntPtr thisPtr, VAbi* __return_value__);
}
internal class ABI.System.Collections.Generic.ReadOnlyDictionaryKeyCollection`2 : object {
    private IReadOnlyDictionary`2<K, V> dictionary;
    public ReadOnlyDictionaryKeyCollection`2(IReadOnlyDictionary`2<K, V> dictionary);
    public sealed virtual IEnumerator`1<K> GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
internal class ABI.System.Collections.Generic.ReadOnlyDictionaryValueCollection`2 : object {
    private IReadOnlyDictionary`2<K, V> dictionary;
    public ReadOnlyDictionaryValueCollection`2(IReadOnlyDictionary`2<K, V> dictionary);
    public sealed virtual IEnumerator`1<V> GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
public class ABI.System.Collections.Generic.ToAbiEnumeratorAdapter`1 : object {
    internal IEnumerator`1<T> m_enumerator;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal ToAbiEnumeratorAdapter`1(IEnumerator`1<T> enumerator);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[DynamicInterfaceCastableImplementationAttribute]
internal interface ABI.System.Collections.ICollection {
    private int global::System.Collections.ICollection.Count { get; }
    private bool global::System.Collections.ICollection.IsSynchronized { get; }
    private object global::System.Collections.ICollection.SyncRoot { get; }
    private static ICollection CreateHelper(RuntimeTypeHandle type, IWinRTObject _this);
    private static ICollection GetHelper(IWinRTObject _this);
    private sealed virtual override int global::System.Collections.ICollection.get_Count();
    private sealed virtual override bool global::System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object global::System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void global::System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("036D2C08-DF29-41AF-8AA2-D774BE62BA6F")]
internal interface ABI.System.Collections.IEnumerable {
    public static IntPtr AbiToProjectionVftablePtr;
    private static IEnumerable();
    public static string GetGuidSignature();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_First_0(IntPtr thisPtr, IntPtr* result);
    internal static ObjectReference`1<IUnknownVftbl> ObjRefFromAbi(IntPtr thisPtr);
    private static FromAbiHelper _AbiHelper(IWinRTObject _this);
    private sealed virtual override IBindableIterator global::Microsoft.UI.Xaml.Interop.IBindableIterable.First();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
[EditorBrowsableAttribute("1")]
public static class ABI.System.Collections.IEnumerable_Delegates : object {
}
public static class ABI.System.Collections.IEnumerableMethods : object {
    public static Guid IID { get; }
    public static IntPtr AbiToProjectionVftablePtr { get; }
    public static Guid get_IID();
    public static IntPtr get_AbiToProjectionVftablePtr();
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("393DE7DE-6FD0-4C0D-BB71-47244A113E93")]
internal interface ABI.System.Collections.IList {
    public static IntPtr AbiToProjectionVftablePtr;
    private static ConditionalWeakTable`2<IList, ToAbiHelper> _adapterTable;
    private UInt32 global::Microsoft.UI.Xaml.Interop.IBindableVector.Size { get; }
    private object global::System.Collections.IList.Item { get; private set; }
    private bool global::System.Collections.IList.IsFixedSize { get; }
    private bool global::System.Collections.IList.IsReadOnly { get; }
    private int global::System.Collections.ICollection.Count { get; }
    private bool global::System.Collections.ICollection.IsSynchronized { get; }
    private object global::System.Collections.ICollection.SyncRoot { get; }
    private static IList();
    public static string GetGuidSignature();
    private static IBindableVector FindAdapter(IntPtr thisPtr);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetAt_0(IntPtr thisPtr, UInt32 index, IntPtr* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetView_2(IntPtr thisPtr, IntPtr* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_IndexOf_3(IntPtr thisPtr, IntPtr value, UInt32* index, Byte* returnValue);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_SetAt_4(IntPtr thisPtr, UInt32 index, IntPtr value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_InsertAt_5(IntPtr thisPtr, UInt32 index, IntPtr value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_RemoveAt_6(IntPtr thisPtr, UInt32 index);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Append_7(IntPtr thisPtr, IntPtr value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_RemoveAtEnd_8(IntPtr thisPtr);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Clear_9(IntPtr thisPtr);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Size_1(IntPtr thisPtr, UInt32* value);
    internal static ObjectReference`1<IUnknownVftbl> ObjRefFromAbi(IntPtr thisPtr);
    internal static FromAbiHelper _VectorToList(IWinRTObject _this);
    private sealed virtual override object global::Microsoft.UI.Xaml.Interop.IBindableVector.GetAt(UInt32 index);
    private sealed virtual override IBindableVectorView global::Microsoft.UI.Xaml.Interop.IBindableVector.GetView();
    private sealed virtual override bool global::Microsoft.UI.Xaml.Interop.IBindableVector.IndexOf(object value, UInt32& index);
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.SetAt(UInt32 index, object value);
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.InsertAt(UInt32 index, object value);
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.RemoveAt(UInt32 index);
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.Append(object value);
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.RemoveAtEnd();
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.Clear();
    private sealed virtual override UInt32 global::Microsoft.UI.Xaml.Interop.IBindableVector.get_Size();
    private sealed virtual override object global::System.Collections.IList.get_Item(int index);
    private sealed virtual override void global::System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool global::System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool global::System.Collections.IList.get_IsReadOnly();
    private sealed virtual override int global::System.Collections.ICollection.get_Count();
    private sealed virtual override bool global::System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object global::System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override int global::System.Collections.IList.Add(object value);
    private sealed virtual override void global::System.Collections.IList.Clear();
    private sealed virtual override bool global::System.Collections.IList.Contains(object value);
    private sealed virtual override int global::System.Collections.IList.IndexOf(object value);
    private sealed virtual override void global::System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void global::System.Collections.IList.Remove(object value);
    private sealed virtual override void global::System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void global::System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
internal static class ABI.System.Collections.IList_Delegates : object {
}
public static class ABI.System.Collections.IListMethods : object {
    public static Guid IID { get; }
    public static IntPtr AbiToProjectionVftablePtr { get; }
    public static Guid get_IID();
    public static IntPtr get_AbiToProjectionVftablePtr();
}
[DynamicInterfaceCastableImplementationAttribute]
[EditorBrowsableAttribute("1")]
[GuidAttribute("530155E1-28A5-5693-87CE-30724D95A06D")]
[WuxMuxProjectedTypeAttribute]
internal interface ABI.System.Collections.Specialized.INotifyCollectionChanged {
    private static EventSource`1<NotifyCollectionChangedEventHandler> _CollectionChanged(IWinRTObject _this);
    private sealed virtual override void global::System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void global::System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
public static class ABI.System.Collections.Specialized.INotifyCollectionChangedMethods : object {
    private static ConditionalWeakTable`2 modreq(System.Runtime.CompilerServices.IsVolatile) _CollectionChanged;
    private static ConditionalWeakTable`2<object, NotifyCollectionChangedEventHandlerEventSource> CollectionChanged { get; }
    public static Guid IID { get; }
    public static IntPtr AbiToProjectionVftablePtr { get; }
    private static ConditionalWeakTable`2<object, NotifyCollectionChangedEventHandlerEventSource> MakeCollectionChangedTable();
    private static ConditionalWeakTable`2<object, NotifyCollectionChangedEventHandlerEventSource> get_CollectionChanged();
    public static EventSource`1<NotifyCollectionChangedEventHandler> Get_CollectionChanged2(IObjectReference obj, object thisObj);
    public static Guid get_IID();
    public static IntPtr get_AbiToProjectionVftablePtr();
}
internal static class ABI.System.Collections.Specialized.NotifyCollectionChangedAction : object {
    public static string GetGuidSignature();
}
[EditorBrowsableAttribute("1")]
[WuxMuxProjectedTypeAttribute]
public class ABI.System.Collections.Specialized.NotifyCollectionChangedEventArgs : ValueType {
    [IsReadOnlyAttribute]
private static Guid& modreq(System.Runtime.InteropServices.InAttribute) Interface_IID { get; }
    private static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_Interface_IID();
    public static IObjectReference CreateMarshaler(NotifyCollectionChangedEventArgs value);
    public static ObjectReferenceValue CreateMarshaler2(NotifyCollectionChangedEventArgs value);
    public static IntPtr GetAbi(IObjectReference m);
    public static NotifyCollectionChangedEventArgs FromAbi(IntPtr ptr);
    private static NotifyCollectionChangedEventArgs CreateNotifyCollectionChangedEventArgs(IntPtr ptr);
    private static NotifyCollectionChangedEventArgs CreateNotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newStartingIndex, int oldStartingIndex);
    public static void CopyManaged(NotifyCollectionChangedEventArgs o, IntPtr dest);
    public static IntPtr FromManaged(NotifyCollectionChangedEventArgs value);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static MarshalerArray<NotifyCollectionChangedEventArgs> CreateMarshalerArray(NotifyCollectionChangedEventArgs[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static NotifyCollectionChangedEventArgs[] FromAbiArray(object box);
    public static void CopyAbiArray(NotifyCollectionChangedEventArgs[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(NotifyCollectionChangedEventArgs[] array);
    public static void DisposeMarshalerArray(MarshalerArray<NotifyCollectionChangedEventArgs> array);
    public static void DisposeAbiArray(object box);
    public static string GetGuidSignature();
}
[EditorBrowsableAttribute("1")]
[GuidAttribute("8B0909DC-2005-5D93-BF8A-725F017BAA8D")]
[WuxMuxProjectedTypeAttribute]
public static class ABI.System.Collections.Specialized.NotifyCollectionChangedEventHandler : object {
    private static IDelegateVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    [CompilerGeneratedAttribute]
private static Delegate <AbiInvokeDelegate>k__BackingField;
    public static Delegate AbiInvokeDelegate { get; }
    public static Guid IID { get; }
    private static NotifyCollectionChangedEventHandler();
    [CompilerGeneratedAttribute]
public static Delegate get_AbiInvokeDelegate();
    public static Guid get_IID();
    public static IObjectReference CreateMarshaler(NotifyCollectionChangedEventHandler managedDelegate);
    public static ObjectReferenceValue CreateMarshaler2(NotifyCollectionChangedEventHandler managedDelegate);
    public static IntPtr GetAbi(IObjectReference value);
    public static NotifyCollectionChangedEventHandler FromAbi(IntPtr nativeDelegate);
    public static NotifyCollectionChangedEventHandler CreateRcw(IntPtr ptr);
    public static IntPtr FromManaged(NotifyCollectionChangedEventHandler managedDelegate);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeAbi(IntPtr abi);
    public static MarshalerArray<NotifyCollectionChangedEventHandler> CreateMarshalerArray(NotifyCollectionChangedEventHandler[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static NotifyCollectionChangedEventHandler[] FromAbiArray(object box);
    public static void CopyAbiArray(NotifyCollectionChangedEventHandler[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(NotifyCollectionChangedEventHandler[] array);
    public static void DisposeMarshalerArray(MarshalerArray<NotifyCollectionChangedEventHandler> array);
    public static void DisposeAbiArray(object box);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Invoke(IntPtr thisPtr, IntPtr sender, IntPtr e);
    [SkipLocalsInitAttribute]
internal static ComInterfaceEntry[] GetExposedInterfaces();
}
internal class ABI.System.Collections.Specialized.NotifyCollectionChangedEventHandlerEventSource : EventSource`1<NotifyCollectionChangedEventHandler> {
    internal NotifyCollectionChangedEventHandlerEventSource(IObjectReference objectReference, method addHandler, method removeHandler);
    protected virtual ObjectReferenceValue CreateMarshaler(NotifyCollectionChangedEventHandler del);
    protected virtual EventSourceState`1<NotifyCollectionChangedEventHandler> CreateEventSourceState();
}
[EditorBrowsableAttribute("1")]
public class ABI.System.ComponentModel.DataErrorsChangedEventArgs : ValueType {
    private static WinRTDataErrorsChangedEventArgsRuntimeClassFactory Instance;
    private static DataErrorsChangedEventArgs();
    public static IObjectReference CreateMarshaler(DataErrorsChangedEventArgs value);
    public static ObjectReferenceValue CreateMarshaler2(DataErrorsChangedEventArgs value);
    public static IntPtr GetAbi(IObjectReference m);
    public static DataErrorsChangedEventArgs FromAbi(IntPtr ptr);
    public static void CopyManaged(DataErrorsChangedEventArgs o, IntPtr dest);
    public static IntPtr FromManaged(DataErrorsChangedEventArgs value);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static MarshalerArray<DataErrorsChangedEventArgs> CreateMarshalerArray(DataErrorsChangedEventArgs[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static DataErrorsChangedEventArgs[] FromAbiArray(object box);
    public static void CopyAbiArray(DataErrorsChangedEventArgs[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(DataErrorsChangedEventArgs[] array);
    public static void DisposeMarshalerArray(MarshalerArray<DataErrorsChangedEventArgs> array);
    public static void DisposeAbiArray(object box);
    public static string GetGuidSignature();
}
[DynamicInterfaceCastableImplementationAttribute]
[EditorBrowsableAttribute("1")]
[GuidAttribute("0EE6C2CC-273E-567D-BC0A-1DD87EE51EBA")]
internal interface ABI.System.ComponentModel.INotifyDataErrorInfo {
    private bool global::System.ComponentModel.INotifyDataErrorInfo.HasErrors { get; }
    internal static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    private static EventHandlerEventSource`1<DataErrorsChangedEventArgs> _ErrorsChanged(IWinRTObject _this);
    private sealed virtual override IEnumerable global::System.ComponentModel.INotifyDataErrorInfo.GetErrors(string propertyName);
    private sealed virtual override bool global::System.ComponentModel.INotifyDataErrorInfo.get_HasErrors();
    private sealed virtual override void global::System.ComponentModel.INotifyDataErrorInfo.add_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
    private sealed virtual override void global::System.ComponentModel.INotifyDataErrorInfo.remove_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
}
internal static class ABI.System.ComponentModel.INotifyDataErrorInfo_Delegates : object {
}
public static class ABI.System.ComponentModel.INotifyDataErrorInfoMethods : object {
    private static ConditionalWeakTable`2 modreq(System.Runtime.CompilerServices.IsVolatile) _ErrorsChanged;
    public static Guid IID { get; }
    public static IntPtr AbiToProjectionVftablePtr { get; }
    private static ConditionalWeakTable`2<object, EventHandlerEventSource`1<DataErrorsChangedEventArgs>> ErrorsChanged { get; }
    public static Guid get_IID();
    public static IntPtr get_AbiToProjectionVftablePtr();
    public static bool get_HasErrors(IObjectReference obj);
    public static IEnumerable GetErrors(IObjectReference obj, string propertyName);
    private static ConditionalWeakTable`2<object, EventHandlerEventSource`1<DataErrorsChangedEventArgs>> MakeErrorsChangedTable();
    private static ConditionalWeakTable`2<object, EventHandlerEventSource`1<DataErrorsChangedEventArgs>> get_ErrorsChanged();
    public static EventHandlerEventSource`1<DataErrorsChangedEventArgs> Get_ErrorsChanged2(IObjectReference obj, object thisObj);
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("90B17601-B065-586E-83D9-9ADC3A695284")]
[WuxMuxProjectedTypeAttribute]
internal interface ABI.System.ComponentModel.INotifyPropertyChanged {
    private static EventSource`1<PropertyChangedEventHandler> _PropertyChanged(IWinRTObject _this);
    private sealed virtual override void global::System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void global::System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
}
public static class ABI.System.ComponentModel.INotifyPropertyChangedMethods : object {
    private static ConditionalWeakTable`2 modreq(System.Runtime.CompilerServices.IsVolatile) _PropertyChanged;
    public static Guid IID { get; }
    public static IntPtr AbiToProjectionVftablePtr { get; }
    private static ConditionalWeakTable`2<object, PropertyChangedEventSource> PropertyChanged { get; }
    public static Guid get_IID();
    public static IntPtr get_AbiToProjectionVftablePtr();
    private static ConditionalWeakTable`2<object, PropertyChangedEventSource> MakePropertyChangedTable();
    private static ConditionalWeakTable`2<object, PropertyChangedEventSource> get_PropertyChanged();
    public static EventSource`1<PropertyChangedEventHandler> Get_PropertyChanged2(IObjectReference obj, object thisObj);
}
[EditorBrowsableAttribute("1")]
public class ABI.System.ComponentModel.PropertyChangedEventArgs : ValueType {
    private static PropertyChangedEventArgsRuntimeClassFactory Instance;
    private static PropertyChangedEventArgs();
    public static IObjectReference CreateMarshaler(PropertyChangedEventArgs value);
    public static ObjectReferenceValue CreateMarshaler2(PropertyChangedEventArgs value);
    public static IntPtr GetAbi(IObjectReference m);
    public static PropertyChangedEventArgs FromAbi(IntPtr ptr);
    public static void CopyManaged(PropertyChangedEventArgs o, IntPtr dest);
    public static IntPtr FromManaged(PropertyChangedEventArgs value);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static MarshalerArray<PropertyChangedEventArgs> CreateMarshalerArray(PropertyChangedEventArgs[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static PropertyChangedEventArgs[] FromAbiArray(object box);
    public static void CopyAbiArray(PropertyChangedEventArgs[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(PropertyChangedEventArgs[] array);
    public static void DisposeMarshalerArray(MarshalerArray<PropertyChangedEventArgs> array);
    public static void DisposeAbiArray(object box);
    public static string GetGuidSignature();
}
[EditorBrowsableAttribute("1")]
[GuidAttribute("E3DE52F6-1E32-5DA6-BB2D-B5B6096C962D")]
[WuxMuxProjectedTypeAttribute]
public static class ABI.System.ComponentModel.PropertyChangedEventHandler : object {
    private static IDelegateVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    [CompilerGeneratedAttribute]
private static Delegate <AbiInvokeDelegate>k__BackingField;
    public static Delegate AbiInvokeDelegate { get; }
    public static Guid IID { get; }
    private static PropertyChangedEventHandler();
    [CompilerGeneratedAttribute]
public static Delegate get_AbiInvokeDelegate();
    public static Guid get_IID();
    public static IObjectReference CreateMarshaler(PropertyChangedEventHandler managedDelegate);
    public static ObjectReferenceValue CreateMarshaler2(PropertyChangedEventHandler managedDelegate);
    public static IntPtr GetAbi(IObjectReference value);
    public static PropertyChangedEventHandler FromAbi(IntPtr nativeDelegate);
    public static PropertyChangedEventHandler CreateRcw(IntPtr ptr);
    public static IntPtr FromManaged(PropertyChangedEventHandler managedDelegate);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeAbi(IntPtr abi);
    public static MarshalerArray<PropertyChangedEventHandler> CreateMarshalerArray(PropertyChangedEventHandler[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static PropertyChangedEventHandler[] FromAbiArray(object box);
    public static void CopyAbiArray(PropertyChangedEventHandler[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(PropertyChangedEventHandler[] array);
    public static void DisposeMarshalerArray(MarshalerArray<PropertyChangedEventHandler> array);
    public static void DisposeAbiArray(object box);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Invoke(IntPtr thisPtr, IntPtr sender, IntPtr e);
    [SkipLocalsInitAttribute]
internal static ComInterfaceEntry[] GetExposedInterfaces();
}
internal class ABI.System.ComponentModel.PropertyChangedEventSource : EventSource`1<PropertyChangedEventHandler> {
    internal PropertyChangedEventSource(IObjectReference objectReference, method addHandler, method removeHandler);
    protected virtual ObjectReferenceValue CreateMarshaler(PropertyChangedEventHandler del);
    protected virtual EventSourceState`1<PropertyChangedEventHandler> CreateEventSourceState();
}
public class ABI.System.DateTimeOffset : ValueType {
    public long UniversalTime;
    private static long ManagedUtcTicksAtNativeZero;
    public static Marshaler CreateMarshaler(DateTimeOffset value);
    public static DateTimeOffset GetAbi(Marshaler m);
    public static DateTimeOffset FromAbi(DateTimeOffset value);
    public static void CopyAbi(Marshaler arg, IntPtr dest);
    public static DateTimeOffset FromManaged(DateTimeOffset value);
    public static void CopyManaged(DateTimeOffset arg, IntPtr dest);
    public static void DisposeMarshaler(Marshaler m);
    public static void DisposeAbi(DateTimeOffset abi);
    public static string GetGuidSignature();
}
[GuidAttribute("c50898f6-c536-5f47-8583-8b2c2438a13b")]
internal static class ABI.System.EventHandler : object {
    private static IDelegateVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    public static Guid IID { get; }
    private static EventHandler();
    public static Guid get_IID();
    public static IObjectReference CreateMarshaler(EventHandler managedDelegate);
    public static ObjectReferenceValue CreateMarshaler2(EventHandler managedDelegate);
    public static IntPtr GetAbi(IObjectReference value);
    public static EventHandler FromAbi(IntPtr nativeDelegate);
    public static EventHandler CreateRcw(IntPtr ptr);
    public static IntPtr FromManaged(EventHandler managedDelegate);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeAbi(IntPtr abi);
    public static MarshalerArray<EventHandler> CreateMarshalerArray(EventHandler[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static EventHandler[] FromAbiArray(object box);
    public static void CopyAbiArray(EventHandler[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(EventHandler[] array);
    public static void DisposeMarshalerArray(MarshalerArray<EventHandler> array);
    public static void DisposeAbiArray(object box);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Invoke(IntPtr thisPtr, IntPtr sender, IntPtr args);
    [SkipLocalsInitAttribute]
internal static ComInterfaceEntry[] GetExposedInterfaces();
}
[GuidAttribute("9DE1C535-6AE1-11E0-84E1-18A905BCC53F")]
[EditorBrowsableAttribute("1")]
public static class ABI.System.EventHandler`1 : object {
    public static Guid PIID;
    private static Type _abi_invoke_type;
    public static IntPtr AbiToProjectionVftablePtr;
    [CompilerGeneratedAttribute]
private static Delegate <AbiInvokeDelegate>k__BackingField;
    public static Guid IID { get; }
    public static Delegate AbiInvokeDelegate { get; }
    private static EventHandler`1();
    public static Guid get_IID();
    [CompilerGeneratedAttribute]
public static Delegate get_AbiInvokeDelegate();
    public static IObjectReference CreateMarshaler(EventHandler`1<T> managedDelegate);
    public static ObjectReferenceValue CreateMarshaler2(EventHandler`1<T> managedDelegate);
    public static IntPtr GetAbi(IObjectReference value);
    public static EventHandler`1<T> FromAbi(IntPtr nativeDelegate);
    public static EventHandler`1<T> CreateRcw(IntPtr ptr);
    public static IntPtr FromManaged(EventHandler`1<T> managedDelegate);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeAbi(IntPtr abi);
    public static MarshalerArray<EventHandler`1<T>> CreateMarshalerArray(EventHandler`1[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static EventHandler`1[] FromAbiArray(object box);
    public static void CopyAbiArray(EventHandler`1[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(EventHandler`1[] array);
    public static void DisposeMarshalerArray(MarshalerArray<EventHandler`1<T>> array);
    public static void DisposeAbiArray(object box);
    private static int Do_Abi_Invoke(Void* thisPtr, IntPtr sender, TAbi args);
}
internal static class ABI.System.EventHandlerMethods`1 : object {
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _Invoke;
    private static IntPtr abiToProjectionVftablePtr;
    internal static IntPtr AbiToProjectionVftablePtr { get; }
    internal static IntPtr get_AbiToProjectionVftablePtr();
    internal static bool TryInitCCWVtable(IntPtr ptr);
}
public static class ABI.System.EventHandlerMethods`2 : object {
    public static bool InitRcwHelper(method invoke);
    public static bool InitCcw(method invoke);
    public static void Abi_Invoke(IntPtr thisPtr, object sender, T args);
}
public class ABI.System.Exception : ValueType {
    public int hr;
    public static Marshaler CreateMarshaler(Exception value);
    public static Exception GetAbi(Marshaler m);
    public static Exception FromAbi(Exception value);
    public static void CopyAbi(Marshaler arg, IntPtr dest);
    public static Exception FromManaged(Exception value);
    public static void CopyManaged(Exception arg, IntPtr dest);
    public static void DisposeMarshaler(Marshaler m);
    public static void DisposeAbi(Exception abi);
    public static string GetGuidSignature();
}
internal class ABI.System.FakeMetadataType : TypeInfo {
    private static ConcurrentDictionary`2<string, FakeMetadataType> fakeMetadataTypeCache;
    private string fullName;
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public string Namespace { get; }
    public Type UnderlyingSystemType { get; }
    public string Name { get; }
    private FakeMetadataType(string fullName);
    private static FakeMetadataType();
    internal static FakeMetadataType GetFakeMetadataType(string name);
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual string get_FullName();
    public virtual Guid get_GUID();
    public virtual Module get_Module();
    public virtual string get_Namespace();
    public virtual Type get_UnderlyingSystemType();
    public virtual string get_Name();
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetElementType();
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2093")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual Type GetInterface(string name, bool ignoreCase);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual Type[] GetInterfaces();
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2094")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual bool Equals(Type o);
    public virtual int GetHashCode();
}
[DynamicInterfaceCastableImplementationAttribute]
[EditorBrowsableAttribute("1")]
[GuidAttribute("30D5A829-7FA4-4026-83BB-D75BAE4EA99E")]
internal interface ABI.System.IDisposable {
    public static IntPtr AbiToProjectionVftablePtr;
    private static IDisposable();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Close_0(IntPtr thisPtr);
    private sealed virtual override void global::System.IDisposable.Dispose();
}
public static class ABI.System.IDisposableMethods : object {
    public static Guid IID { get; }
    public static IntPtr AbiToProjectionVftablePtr { get; }
    public static Guid get_IID();
    public static IntPtr get_AbiToProjectionVftablePtr();
    public static void Dispose(IObjectReference obj);
}
internal static class ABI.System.IReferenceSignatures : object {
    public static string Point;
    public static string Size;
    public static string Rect;
    public static string Matrix3x2;
    public static string Matrix4x4;
    public static string Plane;
    public static string Quaternion;
    public static string Vector2;
    public static string Vector3;
    public static string Vector4;
}
[EditorBrowsableAttribute("1")]
[GuidAttribute("68B3A2DF-8173-539F-B524-C8A2348F5AFB")]
[DynamicInterfaceCastableImplementationAttribute]
internal interface ABI.System.IServiceProvider {
    public static IntPtr AbiToProjectionVftablePtr;
    private static IServiceProvider();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetService_0(IntPtr thisPtr, Type type, IntPtr* result);
    private sealed virtual override object global::System.IServiceProvider.GetService(Type type);
}
public static class ABI.System.IServiceProviderMethods : object {
    public static Guid IID { get; }
    public static IntPtr AbiToProjectionVftablePtr { get; }
    public static Guid get_IID();
    public static IntPtr get_AbiToProjectionVftablePtr();
    public static object GetService(IObjectReference obj, Type type);
}
internal static class ABI.System.IXamlServiceProvider_Delegates : object {
}
internal static class ABI.System.NonBlittableMarshallingStubs : object {
    public static Action`1<object> NoOpFunc;
    private static NonBlittableMarshallingStubs();
    public static object Boolean_CreateMarshaler(bool value);
    public static object Boolean_GetAbi(object value);
    public static bool Boolean_FromAbi(object abi);
    public static void Boolean_CopyAbi(object value, IntPtr dest);
    public static object Boolean_FromManaged(bool value);
    public static object Char_CreateMarshaler(char value);
    public static object Char_GetAbi(object value);
    public static char Char_FromAbi(object abi);
    public static void Char_CopyAbi(object value, IntPtr dest);
    public static object Char_FromManaged(char value);
    public static object TimeSpan_CreateMarshaler(TimeSpan value);
    public static object TimeSpan_GetAbi(object value);
    public static TimeSpan TimeSpan_FromAbi(object abi);
    public static void TimeSpan_CopyAbi(object value, IntPtr dest);
    public static object TimeSpan_FromManaged(TimeSpan value);
    public static object DateTimeOffset_CreateMarshaler(DateTimeOffset value);
    public static object DateTimeOffset_GetAbi(object value);
    public static DateTimeOffset DateTimeOffset_FromAbi(object abi);
    public static void DateTimeOffset_CopyAbi(object value, IntPtr dest);
    public static object DateTimeOffset_FromManaged(DateTimeOffset value);
    public static object Type_CreateMarshalerArray(Type[] value);
    public static object Exception_CreateMarshalerArray(Exception[] value);
    private static void NoOp(object obj);
}
internal class ABI.System.Nullable : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public Nullable(object boxedObject);
    [CompilerGeneratedAttribute]
public object get_Value();
}
[GuidAttribute("3c00fd60-2950-5939-a21a-2d12c5a01b8a")]
internal static class ABI.System.Nullable_bool : object {
    public static string GetGuidSignature();
}
[GuidAttribute("e5198cc8-2873-55f5-b0a1-84ff9e4aad62")]
internal static class ABI.System.Nullable_byte : object {
    public static string GetGuidSignature();
}
[GuidAttribute("fb393ef3-bbac-5bd5-9144-84f23576f415")]
internal static class ABI.System.Nullable_char : object {
    public static string GetGuidSignature();
}
[GuidAttribute("5541d8a7-497c-5aa4-86fc-7713adbf2a2c")]
internal static class ABI.System.Nullable_DateTimeOffset : object {
    public static string GetGuidSignature();
    public static object GetValue(IInspectable inspectable);
}
[GuidAttribute("61C17706-2D65-11E0-9AE8-D48564015472")]
internal static class ABI.System.Nullable_Delegate`1 : object {
    public static IntPtr AbiToProjectionVftablePtr;
    private static GetValueDelegate _Get_Value_0;
    public static Guid PIID;
    private static Nullable_Delegate`1();
    public static string GetGuidSignature();
    private static int Do_Abi_get_Value_0(IntPtr thisPtr, IntPtr* __return_value__);
    public static Nullable GetValue(IInspectable inspectable);
}
internal static class ABI.System.Nullable_Delegates : object {
}
[GuidAttribute("2f2d6c29-5473-5f3e-92e7-96572bb990e2")]
internal static class ABI.System.Nullable_double : object {
    public static string GetGuidSignature();
}
[GuidAttribute("25230F05-B49C-57EE-8961-5373D98E1AB1")]
internal static class ABI.System.Nullable_EventHandler : object {
    public static IntPtr AbiToProjectionVftablePtr;
    private static Nullable_EventHandler();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Value_0(IntPtr thisPtr, IntPtr* __return_value__);
    public static Nullable GetValue(IInspectable inspectable);
}
[GuidAttribute("6ff27a1e-4b6a-59b7-b2c3-d1f2ee474593")]
internal static class ABI.System.Nullable_Exception : object {
    public static string GetGuidSignature();
    public static Nullable GetValue(IInspectable inspectable);
}
internal static class ABI.System.Nullable_FlagsEnum : object {
    public static IntPtr AbiToProjectionVftablePtr;
    private static Nullable_FlagsEnum();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Value_0(IntPtr thisPtr, UInt32* __return_value__);
    internal static Guid GetIID(Type enumType);
    internal static object GetValue(Type enumType, IInspectable inspectable);
}
[GuidAttribute("719cc2ba-3e76-5def-9f1a-38d85a145ea8")]
internal static class ABI.System.Nullable_float : object {
    public static string GetGuidSignature();
}
[GuidAttribute("7d50f649-632c-51f9-849a-ee49428933ea")]
internal static class ABI.System.Nullable_guid : object {
    public static string GetGuidSignature();
}
[GuidAttribute("548cefbd-bc8a-5fa0-8df2-957440fc8bf4")]
internal static class ABI.System.Nullable_int : object {
    public static string GetGuidSignature();
}
internal static class ABI.System.Nullable_IntEnum : object {
    public static IntPtr AbiToProjectionVftablePtr;
    private static Nullable_IntEnum();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Value_0(IntPtr thisPtr, Int32* __return_value__);
    internal static Guid GetIID(Type enumType);
    internal static object GetValue(Type enumType, IInspectable inspectable);
}
[GuidAttribute("4dda9e24-e69f-5c6a-a0a6-93427365af2a")]
internal static class ABI.System.Nullable_long : object {
    public static string GetGuidSignature();
}
[GuidAttribute("779d5a21-0e7d-5476-bb90-27fa3b4b8de5")]
internal static class ABI.System.Nullable_NotifyCollectionChangedEventHandler : object {
    public static IntPtr AbiToProjectionVftablePtr;
    public static Guid IID { get; }
    private static Nullable_NotifyCollectionChangedEventHandler();
    public static Guid get_IID();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Value_0(IntPtr thisPtr, IntPtr* __return_value__);
    public static Nullable GetValue(IInspectable inspectable);
}
[GuidAttribute("06dccc90-a058-5c88-87b7-6f3360a2fc16")]
internal static class ABI.System.Nullable_Object : object {
    public static string GetGuidSignature();
}
[GuidAttribute("1eeae0cb-8f57-5c37-a087-a55d46e2fe3f")]
internal static class ABI.System.Nullable_PropertyChangedEventHandler : object {
    public static IntPtr AbiToProjectionVftablePtr;
    public static Guid IID { get; }
    private static Nullable_PropertyChangedEventHandler();
    public static Guid get_IID();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Value_0(IntPtr thisPtr, IntPtr* __return_value__);
    public static Nullable GetValue(IInspectable inspectable);
}
[GuidAttribute("95500129-fbf6-5afc-89df-70642d741990")]
internal static class ABI.System.Nullable_sbyte : object {
    public static string GetGuidSignature();
}
[GuidAttribute("6ec9e41b-6709-5647-9918-a1270110fc4e")]
internal static class ABI.System.Nullable_short : object {
    public static string GetGuidSignature();
}
[GuidAttribute("fd416dfb-2a07-52eb-aae3-dfce14116c05")]
internal static class ABI.System.Nullable_string : object {
    public static string GetGuidSignature();
    public static Nullable GetValue(IInspectable inspectable);
}
[GuidAttribute("604d0c4c-91de-5c2a-935f-362f13eaf800")]
internal static class ABI.System.Nullable_TimeSpan : object {
    public static string GetGuidSignature();
    public static object GetValue(IInspectable inspectable);
}
[GuidAttribute("3830ad99-d8da-53f3-989b-fc92ad222778")]
internal static class ABI.System.Nullable_Type : object {
    public static string GetGuidSignature();
    public static Nullable GetValue(IInspectable inspectable);
}
[GuidAttribute("513ef3af-e784-5325-a91e-97c2b8111cf3")]
internal static class ABI.System.Nullable_uint : object {
    public static string GetGuidSignature();
}
[GuidAttribute("6755e376-53bb-568b-a11d-17239868309e")]
internal static class ABI.System.Nullable_ulong : object {
    public static string GetGuidSignature();
}
[GuidAttribute("5ab7d2c3-6b62-5e71-a4b6-2d49c4f238fd")]
internal static class ABI.System.Nullable_ushort : object {
    public static string GetGuidSignature();
}
[GuidAttribute("61C17706-2D65-11E0-9AE8-D48564015472")]
public class ABI.System.Nullable`1 : object {
    public static Guid PIID;
    protected ObjectReference`1<Vftbl<T>> _obj;
    public IntPtr ThisPtr { get; }
    public T Value { get; }
    public Nullable`1(IObjectReference obj);
    public Nullable`1(ObjectReference`1<Vftbl<T>> obj);
    private static Nullable`1();
    public static IObjectReference CreateMarshaler(object value);
    public static ObjectReferenceValue CreateMarshaler2(object value);
    public static IntPtr GetAbi(IObjectReference m);
    public static object FromAbi(IntPtr ptr);
    public static void CopyManaged(object o, IntPtr dest);
    public static IntPtr FromManaged(object value);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    private static string CreateGuidSignature();
    public IntPtr get_ThisPtr();
    public static T GetValue(IInspectable inspectable);
    public T get_Value();
    private static T GetValueFromAbi(IntPtr thisPtr, Delegate marshallingDelegate);
}
internal static class ABI.System.NullableBlittable`1 : object {
    private static Guid IID;
    private static NullableBlittable`1();
    public static object GetValue(IInspectable inspectable);
}
internal static class ABI.System.NullableType : object {
    internal static Guid GetIID();
    public static Func`2<IInspectable, object> GetValueFactory(Type type);
    private static Func`2<IInspectable, object> GetValueFactoryInternal(Type type);
    public static Type GetTypeAsNullableType(Type type);
}
public class ABI.System.Numerics.Matrix3x2 : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Matrix4x4 : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Plane : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Quaternion : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Vector2 : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Vector3 : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Vector4 : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.TimeSpan : ValueType {
    public long Duration;
    public static Marshaler CreateMarshaler(TimeSpan value);
    public static TimeSpan GetAbi(Marshaler m);
    public static TimeSpan FromAbi(TimeSpan value);
    public static void CopyAbi(Marshaler arg, IntPtr dest);
    public static TimeSpan FromManaged(TimeSpan value);
    public static void CopyManaged(TimeSpan arg, IntPtr dest);
    public static void DisposeMarshaler(Marshaler m);
    public static void DisposeAbi(TimeSpan abi);
    public static string GetGuidSignature();
}
public class ABI.System.Type : ValueType {
    private IntPtr Name;
    private TypeKind Kind;
    private static ConcurrentDictionary`2<Type, string> typeNameCache;
    private static Type();
    internal static MarshalerArray CreateMarshalerArray(Type[] array);
    internal static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    internal static Type[] FromAbiArray(object box);
    internal static ValueTuple`2<int, IntPtr> FromManagedArray(Type[] array);
    internal static void CopyManagedArray(Type[] array, IntPtr data);
    internal static void DisposeMarshalerArray(object box);
    internal static void DisposeAbiArray(object box);
    private static void DisposeAbiArrayElements(ValueTuple`2<int, IntPtr> abi);
    private static ValueTuple`2<string, TypeKind> ToAbi(Type value);
    private static string GetNameForTypeCached(Type value, bool customKind);
    public static Marshaler CreateMarshaler(Type value);
    public static Type GetAbi(Pinnable& p);
    public static Type GetAbi(Marshaler m);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2057")]
public static Type FromAbi(Type value);
    public static void CopyAbi(Marshaler arg, IntPtr dest);
    public static Type FromManaged(Type value);
    public static void CopyManaged(Type arg, IntPtr dest);
    public static void DisposeMarshaler(Marshaler m);
    public static void DisposeAbi(Type abi);
    public static string GetGuidSignature();
}
[WindowsRuntimeTypeAttribute("Windows.Foundation.UniversalApiContract")]
internal enum ABI.System.TypeKind : Enum {
    public int value__;
    public static TypeKind Primitive;
    public static TypeKind Metadata;
    public static TypeKind Custom;
}
public class ABI.System.Uri : ValueType {
    private static WinRTUriRuntimeClassFactory Instance;
    private static Uri();
    public static IObjectReference CreateMarshaler(Uri value);
    public static ObjectReferenceValue CreateMarshaler2(Uri value);
    public static IntPtr GetAbi(IObjectReference m);
    public static Uri FromAbi(IntPtr ptr);
    public static Uri[] FromAbiArray(object box);
    public static void CopyManaged(Uri o, IntPtr dest);
    public static IntPtr FromManaged(Uri value);
    public static MarshalerArray<Uri> CreateMarshalerArray(Uri[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static void CopyAbiArray(Uri[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(Uri[] array);
    public static void DisposeMarshalerArray(MarshalerArray<Uri> array);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static void DisposeAbiArray(object box);
    public static string GetGuidSignature();
}
[EditorBrowsableAttribute("1")]
[GuidAttribute("E5AF3542-CA67-4081-995B-709DD13792DF")]
[DynamicInterfaceCastableImplementationAttribute]
internal interface ABI.System.Windows.Input.ICommand {
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    private static EventHandlerEventSource _CanExecuteChanged(IWinRTObject _this);
    private sealed virtual override bool global::System.Windows.Input.ICommand.CanExecute(object parameter);
    private sealed virtual override void global::System.Windows.Input.ICommand.Execute(object parameter);
    private sealed virtual override void global::System.Windows.Input.ICommand.add_CanExecuteChanged(EventHandler value);
    private sealed virtual override void global::System.Windows.Input.ICommand.remove_CanExecuteChanged(EventHandler value);
}
[EditorBrowsableAttribute("1")]
public static class ABI.System.Windows.Input.ICommand_Delegates : object {
}
public static class ABI.System.Windows.Input.ICommandMethods : object {
    private static ConditionalWeakTable`2 modreq(System.Runtime.CompilerServices.IsVolatile) _CanExecuteChanged;
    public static Guid IID { get; }
    public static IntPtr AbiToProjectionVftablePtr { get; }
    private static ConditionalWeakTable`2<object, EventHandlerEventSource> CanExecuteChanged { get; }
    public static Guid get_IID();
    public static IntPtr get_AbiToProjectionVftablePtr();
    public static bool CanExecute(IObjectReference obj, object parameter);
    public static void Execute(IObjectReference obj, object parameter);
    private static ConditionalWeakTable`2<object, EventHandlerEventSource> MakeCanExecuteChangedTable();
    private static ConditionalWeakTable`2<object, EventHandlerEventSource> get_CanExecuteChanged();
    public static EventHandlerEventSource Get_CanExecuteChanged2(IObjectReference obj, object thisObj);
}
[GuidAttribute("44A9796F-723E-4FDF-A218-033E75B0C084")]
internal class ABI.System.WinRTUriRuntimeClassFactory : object {
    private ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public WinRTUriRuntimeClassFactory(IObjectReference obj);
    public WinRTUriRuntimeClassFactory(ObjectReference`1<Vftbl> obj);
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public IntPtr get_ThisPtr();
    public IObjectReference CreateUri(string uri);
    public ObjectReferenceValue CreateUriForMarshaling(string uri);
}
internal static class ABI.Windows.Foundation.BoxedArrayIReferenceArrayImpl`1 : object {
    public static IntPtr AbiToProjectionVftablePtr;
    private static get_Value_0 DelegateCache;
    private static BoxedArrayIReferenceArrayImpl`1();
    private static int Do_Abi_get_Value_0(IntPtr thisPtr, Int32* ____return_value__Size, IntPtr* __return_value__);
}
internal static class ABI.Windows.Foundation.BoxedValueIReferenceImpl`1 : object {
    private static Vftbl<T> AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026:RequiresUnreferencedCode")]
private static BoxedValueIReferenceImpl`1();
    private static int Do_Abi_get_Value_0_Blittable(Void* thisPtr, Void* result);
    private static int Do_Abi_get_Value_0_DateTimeOffset(Void* thisPtr, DateTimeOffset* result);
    private static int Do_Abi_get_Value_0(Void* thisPtr, TAbi& __return_value__);
    internal static Delegate GetValueDelegateForAbi(IntPtr& nativePtr);
}
internal static class ABI.Windows.Foundation.BoxedValueIReferenceImpl`2 : object {
    public static IntPtr AbiToProjectionVftablePtr;
    private static GetValueDelegateAbi GetValue;
    private static BoxedValueIReferenceImpl`2();
    private static int Do_Abi_get_Value_0(Void* thisPtr, Void* __return_value__);
    private static int Do_Abi_get_Value_0_Blittable(Void* thisPtr, Void* __return_value__);
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("FAA585EA-6214-4217-AFDA-7F46DE5869B3")]
internal interface ABI.Windows.Foundation.Collections.IIterable`1 {
    public static Guid PIID;
    private static IIterable`1();
}
internal static class ABI.Windows.Foundation.Collections.IIterableMethods`1 : object {
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _First;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _RcwHelperInitialized;
    public static IEnumerator`1<T> First(IObjectReference obj);
}
internal static class ABI.Windows.Foundation.Collections.IMapMethods`2 : object {
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _Lookup;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _HasKey;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _GetView;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _Insert;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _Remove;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _RcwHelperInitialized;
    public static V Lookup(IObjectReference obj, K key);
    public static bool HasKey(IObjectReference obj, K key);
    public static IReadOnlyDictionary`2<K, V> GetView(IObjectReference obj);
    public static bool Insert(IObjectReference obj, K key, V value);
    public static void Remove(IObjectReference obj, K key);
    public static void Clear(IObjectReference obj);
    private static void _ClearHelper(IObjectReference obj);
    public static UInt32 get_Size(IObjectReference obj);
}
internal static class ABI.Windows.Foundation.Collections.IMapViewMethods`2 : object {
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _Lookup;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _HasKey;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _Split;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _RcwHelperInitialized;
    public static V Lookup(IObjectReference obj, K key);
    public static bool HasKey(IObjectReference obj, K key);
    public static void Split(IObjectReference obj, IMapView`2& first, IMapView`2& second);
    public static UInt32 get_Size(IObjectReference obj);
}
internal static class ABI.Windows.Foundation.Collections.IVectorViewMethods`1 : object {
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _GetAt;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _IndexOf;
    internal static method modreq(System.Runtime.CompilerServices.IsVolatile) _GetMany;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _RcwHelperInitialized;
    internal static bool EnsureInitialized();
    public static T GetAt(IObjectReference obj, UInt32 index);
    public static UInt32 get_Size(IObjectReference obj);
    public static bool IndexOf(IObjectReference obj, T value, UInt32& index);
    public static UInt32 GetMany(IObjectReference obj, UInt32 startIndex, T[]& items);
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2080")]
internal static void <EnsureInitialized>g__InitRcwHelperFallbackIfNeeded|4_0();
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("4BD682DD-7554-40E9-9A9B-82654EDE7E62")]
internal interface ABI.Windows.Foundation.IPropertyValue {
    private bool global::Windows.Foundation.IPropertyValue.IsNumericScalar { get; }
    private PropertyType global::Windows.Foundation.IPropertyValue.Type { get; }
    private sealed virtual override byte global::Windows.Foundation.IPropertyValue.GetUInt8();
    private sealed virtual override short global::Windows.Foundation.IPropertyValue.GetInt16();
    private sealed virtual override ushort global::Windows.Foundation.IPropertyValue.GetUInt16();
    private sealed virtual override int global::Windows.Foundation.IPropertyValue.GetInt32();
    private sealed virtual override UInt32 global::Windows.Foundation.IPropertyValue.GetUInt32();
    private sealed virtual override long global::Windows.Foundation.IPropertyValue.GetInt64();
    private sealed virtual override ulong global::Windows.Foundation.IPropertyValue.GetUInt64();
    private sealed virtual override float global::Windows.Foundation.IPropertyValue.GetSingle();
    private sealed virtual override double global::Windows.Foundation.IPropertyValue.GetDouble();
    private sealed virtual override char global::Windows.Foundation.IPropertyValue.GetChar16();
    private sealed virtual override bool global::Windows.Foundation.IPropertyValue.GetBoolean();
    private sealed virtual override string global::Windows.Foundation.IPropertyValue.GetString();
    private sealed virtual override Guid global::Windows.Foundation.IPropertyValue.GetGuid();
    private sealed virtual override DateTimeOffset global::Windows.Foundation.IPropertyValue.GetDateTime();
    private sealed virtual override TimeSpan global::Windows.Foundation.IPropertyValue.GetTimeSpan();
    private sealed virtual override Point global::Windows.Foundation.IPropertyValue.GetPoint();
    private sealed virtual override Size global::Windows.Foundation.IPropertyValue.GetSize();
    private sealed virtual override Rect global::Windows.Foundation.IPropertyValue.GetRect();
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetUInt8Array(Byte[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetInt16Array(Int16[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetUInt16Array(UInt16[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetInt32Array(Int32[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetUInt32Array(UInt32[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetInt64Array(Int64[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetUInt64Array(UInt64[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetSingleArray(Single[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetDoubleArray(Double[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetChar16Array(Char[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetBooleanArray(Boolean[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetStringArray(String[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetInspectableArray(Object[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetGuidArray(Guid[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetDateTimeArray(DateTimeOffset[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetTimeSpanArray(TimeSpan[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetPointArray(Point[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetSizeArray(Size[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetRectArray(Rect[]& value);
    private sealed virtual override bool global::Windows.Foundation.IPropertyValue.get_IsNumericScalar();
    private sealed virtual override PropertyType global::Windows.Foundation.IPropertyValue.get_Type();
}
internal static class ABI.Windows.Foundation.IPropertyValue_Delegates : object {
}
internal static class ABI.Windows.Foundation.IReferenceArray_Delegates : object {
}
[GuidAttribute("61C17707-2D65-11E0-9AE8-D48564015472")]
internal class ABI.Windows.Foundation.IReferenceArray`1 : object {
    public static Guid PIID;
    private ObjectReference`1<IUnknownVftbl> _obj;
    public IntPtr ThisPtr { get; }
    public T[] Value { get; }
    public IReferenceArray`1(ObjectReference`1<IUnknownVftbl> obj);
    private static IReferenceArray`1();
    public static IObjectReference CreateMarshaler(object value);
    public static ObjectReferenceValue CreateMarshaler2(object value);
    public static IntPtr GetAbi(IObjectReference m);
    public static object FromAbi(IntPtr ptr);
    public static object GetValue(IInspectable inspectable);
    public static void CopyManaged(object o, IntPtr dest);
    public static IntPtr FromManaged(object value);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    public IntPtr get_ThisPtr();
    public sealed virtual T[] get_Value();
}
[GuidAttribute("9E365E57-48B2-4160-956F-C7385120BBFC")]
internal class ABI.Windows.Foundation.IUriRuntimeClassVftbl : ValueType {
    internal Vftbl IInspectableVftbl;
    public IntPtr get_AbsoluteUri_0;
    public IntPtr get_DisplayUri_1;
    public IntPtr get_Domain_2;
    public IntPtr get_Extension_3;
    public IntPtr get_Fragment_4;
    public IntPtr get_Host_5;
    public IntPtr get_Password_6;
    public IntPtr get_Path_7;
    public IntPtr get_Query_8;
    public IntPtr get_QueryParsed_9;
    public Void* _get_RawUri_10;
    public IntPtr get_SchemeName_11;
    public IntPtr get_UserName_12;
    public IntPtr get_Port_13;
    public IntPtr get_Suspicious_14;
    public IntPtr Equals_15;
    public IntPtr CombineUri_16;
    public method get_RawUri_10 { get; }
    public method get_get_RawUri_10();
}
internal static class ABI.Windows.Foundation.ManagedIPropertyValueImpl : object {
    private static int TYPE_E_TYPEMISMATCH;
    private static int DISP_E_OVERFLOW;
    private static Vftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_numericScalarTypes;
    private static Dictionary`2<Type, PropertyType> NumericScalarTypes { get; }
    private static ManagedIPropertyValueImpl();
    private static Dictionary`2<Type, PropertyType> get_NumericScalarTypes();
    private static T UnboxValue(object value);
    private static T[] UnboxArray(object value);
    private static bool IsCoercable(object value);
    private static T CoerceValue(object value);
    private static T[] CoerceArray(object value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt8_2(IntPtr thisPtr, Byte* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt16_3(IntPtr thisPtr, Int16* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt16_4(IntPtr thisPtr, UInt16* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt32_5(IntPtr thisPtr, Int32* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt32_6(IntPtr thisPtr, UInt32* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt64_7(IntPtr thisPtr, Int64* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt64_8(IntPtr thisPtr, UInt64* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetSingle_9(IntPtr thisPtr, Single* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetDouble_10(IntPtr thisPtr, Double* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetChar16_11(IntPtr thisPtr, UInt16* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetBoolean_12(IntPtr thisPtr, Byte* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetString_13(IntPtr thisPtr, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetGuid_14(IntPtr thisPtr, Guid* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetDateTime_15(IntPtr thisPtr, DateTimeOffset* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetTimeSpan_16(IntPtr thisPtr, TimeSpan* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetPoint_17(IntPtr thisPtr, Point* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetSize_18(IntPtr thisPtr, Size* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetRect_19(IntPtr thisPtr, Rect* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt8Array_20(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt16Array_21(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt16Array_22(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt32Array_23(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt32Array_24(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt64Array_25(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt64Array_26(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetSingleArray_27(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetDoubleArray_28(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetChar16Array_29(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetBooleanArray_30(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetStringArray_31(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInspectableArray_32(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetGuidArray_33(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetDateTimeArray_34(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetTimeSpanArray_35(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetPointArray_36(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetSizeArray_37(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetRectArray_38(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_IsNumericScalar_1(IntPtr thisPtr, Byte* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Type_0(IntPtr thisPtr, PropertyType* value);
    private static PropertyType GetPropertyTypeOfObject(object obj);
}
[GuidAttribute("96369F54-8EB6-48F0-ABCE-C1B211E627C3")]
internal class ABI.Windows.Foundation.ManagedIStringableVftbl : ValueType {
    internal Vftbl IInspectableVftbl;
    private Void* _ToString_0;
    private static ManagedIStringableVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    private method ToString_0 { get; private set; }
    private static ManagedIStringableVftbl();
    private method get_ToString_0();
    private void set_ToString_0(method value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_ToString_0(IntPtr thisPtr, IntPtr* value);
}
public static class ABI.Windows.Foundation.Point : object {
    public static string GetGuidSignature();
}
public static class ABI.Windows.Foundation.Rect : object {
    public static string GetGuidSignature();
}
public static class ABI.Windows.Foundation.Size : object {
    public static string GetGuidSignature();
}
internal static class ABI.WinRT.EventRegistrationToken : object {
    public static string GetGuidSignature();
}
internal class ABI.WinRT.Interop.CallbackData : ValueType {
    public method Callback;
    public object State;
}
internal class ABI.WinRT.Interop.ComCallData : ValueType {
    public int dwDispid;
    public int dwReserved;
    public IntPtr pUserDefined;
}
[EditorBrowsableAttribute("1")]
public class ABI.WinRT.Interop.EventHandlerEventSource : EventSource`1<EventHandler> {
    public EventHandlerEventSource(IObjectReference objectReference, method addHandler, method removeHandler);
    protected virtual ObjectReferenceValue CreateMarshaler(EventHandler del);
    protected virtual EventSourceState`1<EventHandler> CreateEventSourceState();
}
[EditorBrowsableAttribute("1")]
public class ABI.WinRT.Interop.EventHandlerEventSource`1 : EventSource`1<EventHandler`1<T>> {
    public EventHandlerEventSource`1(IObjectReference objectReference, method addHandler, method removeHandler, int index);
    protected virtual ObjectReferenceValue CreateMarshaler(EventHandler`1<T> del);
    protected virtual EventSourceState`1<EventHandler`1<T>> CreateEventSourceState();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public abstract class ABI.WinRT.Interop.EventSource`1 : object {
    private IObjectReference _objectReference;
    private int _index;
    [NullableAttribute("0")]
private method _addHandler;
    [NullableAttribute("0")]
private method _removeHandler;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakReference`1<object> _state;
    protected IObjectReference ObjectReference { get; }
    protected int Index { get; }
    [NullableContextAttribute("0")]
protected EventSource`1(IObjectReference objectReference, method addHandler, method removeHandler, int index);
    protected IObjectReference get_ObjectReference();
    protected int get_Index();
    protected abstract virtual ObjectReferenceValue CreateMarshaler(TDelegate handler);
    protected abstract virtual EventSourceState`1<TDelegate> CreateEventSourceState();
    public void Subscribe(TDelegate handler);
    public void Unsubscribe(TDelegate handler);
    private void UnsubscribeFromNative(EventSourceState`1<TDelegate> state);
    [MemberNotNullWhenAttribute("True", "_state")]
private bool TryGetStateUnsafe(EventSourceState`1& state);
}
internal class ABI.WinRT.Interop.EventSourceCache : object {
    private static ReaderWriterLockSlim cachesLock;
    private static ConcurrentDictionary`2<IntPtr, EventSourceCache> caches;
    private ConcurrentDictionary`2<int, WeakReference`1<object>> states;
    private IWeakReference target;
    private EventSourceCache(IWeakReference target, int index, WeakReference`1<object> state);
    private static EventSourceCache();
    private EventSourceCache Update(IWeakReference target, int index, WeakReference`1<object> state);
    private WeakReference`1<object> GetState(int index);
    private void SetState(int index, WeakReference`1<object> state);
    public static void Create(IObjectReference obj, int index, WeakReference`1<object> state);
    public static WeakReference`1<object> GetState(IObjectReference obj, int index);
    public static void Remove(IntPtr thisPtr, int index, WeakReference`1<object> state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public abstract class ABI.WinRT.Interop.EventSourceState`1 : object {
    private bool disposedValue;
    private IntPtr obj;
    private int index;
    private WeakReference`1<object> cacheEntry;
    private IntPtr eventInvokePtr;
    private IntPtr referenceTrackerTargetPtr;
    internal EventRegistrationToken token;
    [NullableAttribute("2")]
internal TDelegate targetDelegate;
    internal TDelegate eventInvoke;
    [NullableAttribute("2")]
protected TDelegate TargetDelegate { get; }
    protected EventSourceState`1(IntPtr thisPtr, int index);
    protected virtual override void Finalize();
    [NullableContextAttribute("2")]
protected TDelegate get_TargetDelegate();
    protected abstract virtual TDelegate GetEventInvoke();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    internal WeakReference`1<object> GetWeakReferenceForCache();
    internal void InitalizeReferenceTracking(IntPtr ptr);
    internal bool HasComReferences();
}
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
public class ABI.WinRT.Interop.IActivationFactory : object {
    protected ObjectReference`1<IUnknownVftbl> _obj;
    public IObjectReference ObjRef { get; }
    public IntPtr ThisPtr { get; }
    public IActivationFactory(IObjectReference obj);
    public IObjectReference get_ObjRef();
    public IntPtr get_ThisPtr();
    public sealed virtual IntPtr ActivateInstance();
}
public static class ABI.WinRT.Interop.IActivationFactoryMethods : object {
    public static Guid IID { get; }
    public static IntPtr AbiToProjectionVftablePtr { get; }
    public static Guid get_IID();
    public static IntPtr get_AbiToProjectionVftablePtr();
    [EditorBrowsableAttribute("1")]
public static IObjectReference ActivateInstanceUnsafe(IObjectReference objectReference, Guid iid);
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("94ea2b94-e9cc-49e0-c0ff-ee64ca8f5b90")]
internal interface ABI.WinRT.Interop.IAgileObject {
    public static IntPtr AbiToProjectionVftablePtr;
    private static IAgileObject();
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("C03F6A43-65A4-9818-987E-E0B810D2A6F2")]
internal interface ABI.WinRT.Interop.IAgileReference {
    public static IntPtr AbiToProjectionVftablePtr;
    private static IAgileReference();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Resolve(IntPtr thisPtr, Guid* riid, IntPtr* objectReference);
    private sealed virtual override IObjectReference global::WinRT.Interop.IAgileReference.Resolve(Guid riid);
}
internal static class ABI.WinRT.Interop.IAgileReferenceMethods : object {
    public static IObjectReference Resolve(IObjectReference _obj, Guid riid);
    public static ObjectReference`1<T> Resolve(IObjectReference _obj, Guid riid);
}
internal class ABI.WinRT.Interop.IContextCallbackVftbl : ValueType {
    private IUnknownVftbl IUnknownVftbl;
    private method ContextCallback_4;
    public static void ContextCallback(IntPtr contextCallbackPtr, method callback, method onFailCallback, object state);
    [CompilerGeneratedAttribute]
[UnmanagedCallersOnlyAttribute]
internal static int <ContextCallback>g__InvokeCallback|2_0(ComCallData* comCallData);
}
internal class ABI.WinRT.Interop.IErrorInfoVftbl : ValueType {
    public IUnknownVftbl IUnknownVftbl;
    public method GetGuid_0;
    public method GetSource_1;
    public method GetDescription_2;
    public method GetHelpFile_3;
    public method GetHelpFileContent_4;
    public static IErrorInfoVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    private static IErrorInfoVftbl();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetGuid_0(IntPtr thisPtr, Guid* guid);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetSource_1(IntPtr thisPtr, IntPtr* source);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetDescription_2(IntPtr thisPtr, IntPtr* description);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetHelpFile_3(IntPtr thisPtr, IntPtr* helpFile);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetHelpFileContent_4(IntPtr thisPtr, IntPtr* helpFileContent);
}
[GuidAttribute("00000146-0000-0000-C000-000000000046")]
internal class ABI.WinRT.Interop.IGlobalInterfaceTable : object {
    private ObjectReference`1<IUnknownVftbl> _obj;
    public IntPtr ThisPtr { get; }
    public IGlobalInterfaceTable(IntPtr thisPtr);
    public static ObjectReference`1<IUnknownVftbl> FromAbi(IntPtr thisPtr);
    public IntPtr get_ThisPtr();
    public IntPtr RegisterInterfaceInGlobal(IntPtr ptr, Guid riid);
    public void TryRevokeInterfaceFromGlobal(IntPtr cookie);
    public IObjectReference GetInterfaceFromGlobal(IntPtr cookie, Guid riid);
}
internal static class ABI.WinRT.Interop.ILanguageExceptionErrorInfo : object {
    public static IObjectReference GetLanguageException(ObjectReference`1<IUnknownVftbl> obj);
}
[GuidAttribute("00000003-0000-0000-c000-000000000046")]
internal class ABI.WinRT.Interop.IMarshal : object {
    private static string NotImplemented_NativeRoutineNotFound;
    private static object _IID_InProcFreeThreadedMarshalerLock;
    internal static Object modreq(System.Runtime.CompilerServices.IsVolatile) _IID_InProcFreeThreadedMarshaler;
    private ObjectReference`1<IUnknownVftbl> _obj;
    internal static Guid IID_InProcFreeThreadedMarshaler { get; }
    public IObjectReference ObjRef { get; }
    public IntPtr ThisPtr { get; }
    public IMarshal(IObjectReference obj);
    private static IMarshal();
    internal static Guid get_IID_InProcFreeThreadedMarshaler();
    public IObjectReference get_ObjRef();
    public IntPtr get_ThisPtr();
    public void GetUnmarshalClass(Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlFlags, Guid* pCid);
    public void GetMarshalSizeMax(Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags, UInt32* pSize);
    public void MarshalInterface(IntPtr pStm, Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);
    public void UnmarshalInterface(IntPtr pStm, Guid* riid, IntPtr* ppv);
    public void ReleaseMarshalData(IntPtr pStm);
    public void DisconnectObject(UInt32 dwReserved);
    [CompilerGeneratedAttribute]
internal static Guid <get_IID_InProcFreeThreadedMarshaler>g__IID_InProcFreeThreadedMarshaler_Slow|4_0();
}
internal class ABI.WinRT.Interop.IRestrictedErrorInfo : object {
    protected ObjectReference`1<IUnknownVftbl> _obj;
    public IRestrictedErrorInfo(ObjectReference`1<IUnknownVftbl> obj);
    public void GetErrorDetails(String& description, Int32& error, String& restrictedDescription, String& capabilitySid);
    public string GetReference();
}
internal class ABI.WinRT.Interop.ISupportErrorInfoVftbl : ValueType {
    public IUnknownVftbl IUnknownVftbl;
    public method InterfaceSupportsErrorInfo_0;
    public static ISupportErrorInfoVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    private static ISupportErrorInfoVftbl();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_InterfaceSupportsErrorInfo_0(IntPtr thisPtr, Guid* guid);
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("00000037-0000-0000-C000-000000000046")]
internal interface ABI.WinRT.Interop.IWeakReference {
    public static IntPtr AbiToProjectionVftablePtr;
    private static IWeakReference();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Resolve(IntPtr thisPtr, Guid* riid, IntPtr* objectReference);
    private sealed virtual override IObjectReference global::WinRT.Interop.IWeakReference.Resolve(Guid riid);
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("00000038-0000-0000-C000-000000000046")]
internal interface ABI.WinRT.Interop.IWeakReferenceSource {
    public static IntPtr AbiToProjectionVftablePtr;
    private static IWeakReferenceSource();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetWeakReference(IntPtr thisPtr, IntPtr* weakReference);
    private sealed virtual override IWeakReference global::WinRT.Interop.IWeakReferenceSource.GetWeakReference();
}
public static class ABI.WinRT.Interop.IWeakReferenceSourceMethods : object {
    public static IWeakReference GetWeakReference(IObjectReference _obj);
}
public class Microsoft.UI.Xaml.Automation.ElementNotAvailableException : Exception {
    public ElementNotAvailableException(string message);
    public ElementNotAvailableException(string message, Exception innerException);
}
public class Microsoft.UI.Xaml.Automation.ElementNotEnabledException : Exception {
    public ElementNotEnabledException(string message);
    public ElementNotEnabledException(string message, Exception innerException);
}
[WinRTExposedTypeAttribute("ABI.Microsoft.UI.Xaml.Data.ManagedCustomPropertyWinRTTypeDetails")]
public class Microsoft.UI.Xaml.Data.BindableCustomProperty : object {
    private bool _canRead;
    private bool _canWrite;
    private string _name;
    private Type _type;
    private Func`2<object, object> _getValue;
    private Action`2<object, object> _setValue;
    private Func`3<object, object, object> _getIndexedValue;
    private Action`3<object, object, object> _setIndexedValue;
    private bool Microsoft.UI.Xaml.Data.ICustomProperty.CanRead { get; }
    private bool Microsoft.UI.Xaml.Data.ICustomProperty.CanWrite { get; }
    private string Microsoft.UI.Xaml.Data.ICustomProperty.Name { get; }
    private Type Microsoft.UI.Xaml.Data.ICustomProperty.Type { get; }
    public BindableCustomProperty(bool canRead, bool canWrite, string name, Type type, Func`2<object, object> getValue, Action`2<object, object> setValue, Func`3<object, object, object> getIndexedValue, Action`3<object, object, object> setIndexedValue);
    private sealed virtual override bool Microsoft.UI.Xaml.Data.ICustomProperty.get_CanRead();
    private sealed virtual override bool Microsoft.UI.Xaml.Data.ICustomProperty.get_CanWrite();
    private sealed virtual override string Microsoft.UI.Xaml.Data.ICustomProperty.get_Name();
    private sealed virtual override Type Microsoft.UI.Xaml.Data.ICustomProperty.get_Type();
    private sealed virtual override object Microsoft.UI.Xaml.Data.ICustomProperty.GetIndexedValue(object target, object index);
    private sealed virtual override object Microsoft.UI.Xaml.Data.ICustomProperty.GetValue(object target);
    private sealed virtual override void Microsoft.UI.Xaml.Data.ICustomProperty.SetIndexedValue(object target, object value, object index);
    private sealed virtual override void Microsoft.UI.Xaml.Data.ICustomProperty.SetValue(object target, object value);
}
public interface Microsoft.UI.Xaml.Data.IBindableCustomPropertyImplementation {
    public abstract virtual BindableCustomProperty GetProperty(string name);
    public abstract virtual BindableCustomProperty GetProperty(Type indexParameterType);
}
[WindowsRuntimeTypeAttribute("")]
[WindowsRuntimeHelperTypeAttribute("ABI.Microsoft.UI.Xaml.Data.ICustomProperty")]
[GuidAttribute("30DA92C0-23E8-42A0-AE7C-734A0E5D2782")]
internal interface Microsoft.UI.Xaml.Data.ICustomProperty {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public string Name { get; }
    public Type Type { get; }
    public abstract virtual object GetValue(object target);
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetIndexedValue(object target, object index);
    public abstract virtual void SetIndexedValue(object target, object value, object index);
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("036D2C08-DF29-41AF-8AA2-D774BE62BA6F")]
[WindowsRuntimeHelperTypeAttribute("ABI.Microsoft.UI.Xaml.Interop.IBindableIterable")]
internal interface Microsoft.UI.Xaml.Interop.IBindableIterable {
    public abstract virtual IBindableIterator First();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("6A1D6C07-076D-49F2-8314-F52C9C9A8331")]
[WindowsRuntimeHelperTypeAttribute("ABI.Microsoft.UI.Xaml.Interop.IBindableIterator")]
internal interface Microsoft.UI.Xaml.Interop.IBindableIterator {
    public object Current { get; }
    public bool HasCurrent { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual UInt32 GetMany(Object[]& items);
    public abstract virtual object get_Current();
    public abstract virtual bool get_HasCurrent();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("393DE7DE-6FD0-4C0D-BB71-47244A113E93")]
internal interface Microsoft.UI.Xaml.Interop.IBindableVector {
    public UInt32 Size { get; }
    public abstract virtual object GetAt(UInt32 index);
    public abstract virtual IBindableVectorView GetView();
    public abstract virtual bool IndexOf(object value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, object value);
    public abstract virtual void InsertAt(UInt32 index, object value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(object value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void Clear();
    public abstract virtual UInt32 get_Size();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("346DD6E7-976E-4BC3-815D-ECE243BC0F33")]
[WindowsRuntimeHelperTypeAttribute("ABI.Microsoft.UI.Xaml.Interop.IBindableVectorView")]
internal interface Microsoft.UI.Xaml.Interop.IBindableVectorView {
    public UInt32 Size { get; }
    public abstract virtual object GetAt(UInt32 index);
    public abstract virtual bool IndexOf(object value, UInt32& index);
    public abstract virtual UInt32 get_Size();
}
public class Microsoft.UI.Xaml.LayoutCycleException : Exception {
    public LayoutCycleException(string message);
    public LayoutCycleException(string message, Exception innerException);
}
public class Microsoft.UI.Xaml.Markup.XamlParseException : Exception {
    public XamlParseException(string message);
    public XamlParseException(string message, Exception innerException);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.IDictionaryImpl`2 : object {
    private IObjectReference _inner;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iDictionaryObjRef;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iEnumerableObjRef;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference iDictionaryObjRef { get; }
    private IObjectReference iEnumerableObjRef { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    public V Item { get; public set; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal IDictionaryImpl`2(IObjectReference _inner);
    public static IDictionaryImpl`2<K, V> CreateRcw(IInspectable obj);
    private IObjectReference Make_IDictionaryObjRef();
    private IObjectReference get_iDictionaryObjRef();
    private IObjectReference Make_IEnumerableObjRef();
    private IObjectReference get_iEnumerableObjRef();
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(K key, V value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    public sealed virtual bool Remove(K key);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual bool TryGetValue(K key, V& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Collections.Generic.IEnumerableImpl`1 : object {
    private IObjectReference _inner;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iEnumerableObjRef;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference iEnumerableObjRef { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    internal IEnumerableImpl`1(IObjectReference _inner);
    public static IEnumerableImpl`1<T> CreateRcw(IInspectable obj);
    private IObjectReference Make_IEnumerableObjRef();
    private IObjectReference get_iEnumerableObjRef();
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Collections.Generic.IEnumeratorImpl`1 : object {
    private IObjectReference _inner;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iEnumeratorObjRef;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference iEnumeratorObjRef { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    private T Windows.Foundation.Collections.IIterator<T>._Current { get; }
    private bool Windows.Foundation.Collections.IIterator<T>.HasCurrent { get; }
    internal IEnumeratorImpl`1(IObjectReference _inner);
    public static IEnumeratorImpl`1<T> CreateRcw(IInspectable obj);
    private IObjectReference Make_IEnumeratorObjRef();
    private IObjectReference get_iEnumeratorObjRef();
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override bool Windows.Foundation.Collections.IIterator<T>._MoveNext();
    private sealed virtual override UInt32 Windows.Foundation.Collections.IIterator<T>.GetMany(T[]& items);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override T Windows.Foundation.Collections.IIterator<T>.get__Current();
    private sealed virtual override bool Windows.Foundation.Collections.IIterator<T>.get_HasCurrent();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.IListImpl`1 : object {
    private IObjectReference _inner;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iListObjRef;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iEnumerableObjRef;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference iListObjRef { get; }
    private IObjectReference iEnumerableObjRef { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    internal IListImpl`1(IObjectReference _inner);
    private IObjectReference Make_IListObjRef();
    private IObjectReference get_iListObjRef();
    private IObjectReference Make_IEnumerableObjRef();
    private IObjectReference get_iEnumerableObjRef();
    public static IListImpl`1<T> CreateRcw(IInspectable obj);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.IReadOnlyDictionaryImpl`2 : object {
    private IObjectReference _inner;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iReadOnlyDictionaryObjRef;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iEnumerableObjRef;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference iReadOnlyDictionaryObjRef { get; }
    private IObjectReference iEnumerableObjRef { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    public V Item { get; }
    public IEnumerable`1<K> Keys { get; }
    public IEnumerable`1<V> Values { get; }
    public int Count { get; }
    internal IReadOnlyDictionaryImpl`2(IObjectReference _inner);
    public static IReadOnlyDictionaryImpl`2<K, V> CreateRcw(IInspectable obj);
    private IObjectReference Make_IDictionaryObjRef();
    private IObjectReference get_iReadOnlyDictionaryObjRef();
    private IObjectReference Make_IEnumerableObjRef();
    private IObjectReference get_iEnumerableObjRef();
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    public sealed virtual V get_Item(K key);
    public sealed virtual IEnumerable`1<K> get_Keys();
    public sealed virtual IEnumerable`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    public sealed virtual bool TryGetValue(K key, V& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.IReadOnlyListImpl`1 : object {
    private IObjectReference _inner;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iReadOnlyListObjRef;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iEnumerableObjRef;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference iReadOnlyListObjRef { get; }
    private IObjectReference iEnumerableObjRef { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    public T Item { get; }
    public int Count { get; }
    internal IReadOnlyListImpl`1(IObjectReference _inner);
    private IObjectReference Make_IListObjRef();
    private IObjectReference get_iReadOnlyListObjRef();
    private IObjectReference Make_IEnumerableObjRef();
    private IObjectReference get_iEnumerableObjRef();
    public static IReadOnlyListImpl`1<T> CreateRcw(IInspectable obj);
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    public sealed virtual T get_Item(int index);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class System.Numerics.VectorExtensions : object {
    [ExtensionAttribute]
public static Point ToPoint(Vector2 vector);
    [ExtensionAttribute]
public static Size ToSize(Vector2 vector);
    [ExtensionAttribute]
public static Vector2 ToVector2(Point point);
    [ExtensionAttribute]
public static Vector2 ToVector2(Size size);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyArrayAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.WriteOnlyArrayAttribute : Attribute {
}
[GuidAttribute("FAA585EA-6214-4217-AFDA-7F46DE5869B3")]
internal interface Windows.Foundation.Collections.IIterable`1 {
    public abstract virtual IEnumerator`1<T> First();
}
[GuidAttribute("6A79E863-4300-459A-9966-CBB660963EE1")]
internal interface Windows.Foundation.Collections.IIterator`1 {
    public T _Current { get; }
    public bool HasCurrent { get; }
    public abstract virtual bool _MoveNext();
    public abstract virtual UInt32 GetMany(T[]& items);
    public abstract virtual T get__Current();
    public abstract virtual bool get_HasCurrent();
}
[GuidAttribute("02B51929-C1C4-4A7E-8940-0312B5C18500")]
internal interface Windows.Foundation.Collections.IKeyValuePair`2 {
    public K Key { get; }
    public V Value { get; }
    public abstract virtual K get_Key();
    public abstract virtual V get_Value();
}
[GuidAttribute("3C2925FE-8519-45C1-AA79-197B6718C1C1")]
internal interface Windows.Foundation.Collections.IMap`2 {
    public UInt32 Size { get; }
    public abstract virtual V Lookup(K key);
    public abstract virtual bool HasKey(K key);
    public abstract virtual IReadOnlyDictionary`2<K, V> GetView();
    public abstract virtual bool Insert(K key, V value);
    public abstract virtual void _Remove(K key);
    public abstract virtual void Clear();
    public abstract virtual UInt32 get_Size();
}
[GuidAttribute("E480CE40-A338-4ADA-ADCF-272272E48CB9")]
internal interface Windows.Foundation.Collections.IMapView`2 {
    public UInt32 Size { get; }
    public abstract virtual V Lookup(K key);
    public abstract virtual bool HasKey(K key);
    public abstract virtual void Split(IMapView`2& first, IMapView`2& second);
    public abstract virtual UInt32 get_Size();
}
[GuidAttribute("913337E9-11A1-4345-A3A2-4E7F956E222D")]
internal interface Windows.Foundation.Collections.IVector`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual IReadOnlyList`1<T> GetView();
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, T value);
    public abstract virtual void InsertAt(UInt32 index, T value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(T value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void _Clear();
    public abstract virtual UInt32 GetMany(UInt32 startIndex, T[]& items);
    public abstract virtual void ReplaceAll(T[] items);
    public abstract virtual UInt32 get_Size();
}
[GuidAttribute("BBE1FA4C-B0E3-4583-BAEF-1F1B2E483E56")]
internal interface Windows.Foundation.Collections.IVectorView`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual UInt32 GetMany(UInt32 startIndex, T[]& items);
    public abstract virtual UInt32 get_Size();
}
internal static class Windows.Foundation.GSR : object {
    public static string ArgumentOutOfRange_NeedNonNegNum;
    private static GSR();
}
[GuidAttribute("4BD682DD-7554-40E9-9A9B-82654EDE7E62")]
internal interface Windows.Foundation.IPropertyValue {
    public bool IsNumericScalar { get; }
    public PropertyType Type { get; }
    public abstract virtual byte GetUInt8();
    public abstract virtual short GetInt16();
    public abstract virtual ushort GetUInt16();
    public abstract virtual int GetInt32();
    public abstract virtual UInt32 GetUInt32();
    public abstract virtual long GetInt64();
    public abstract virtual ulong GetUInt64();
    public abstract virtual float GetSingle();
    public abstract virtual double GetDouble();
    public abstract virtual char GetChar16();
    public abstract virtual bool GetBoolean();
    public abstract virtual string GetString();
    public abstract virtual Guid GetGuid();
    public abstract virtual DateTimeOffset GetDateTime();
    public abstract virtual TimeSpan GetTimeSpan();
    public abstract virtual Point GetPoint();
    public abstract virtual Size GetSize();
    public abstract virtual Rect GetRect();
    public abstract virtual void GetUInt8Array(Byte[]& value);
    public abstract virtual void GetInt16Array(Int16[]& value);
    public abstract virtual void GetUInt16Array(UInt16[]& value);
    public abstract virtual void GetInt32Array(Int32[]& value);
    public abstract virtual void GetUInt32Array(UInt32[]& value);
    public abstract virtual void GetInt64Array(Int64[]& value);
    public abstract virtual void GetUInt64Array(UInt64[]& value);
    public abstract virtual void GetSingleArray(Single[]& value);
    public abstract virtual void GetDoubleArray(Double[]& value);
    public abstract virtual void GetChar16Array(Char[]& value);
    public abstract virtual void GetBooleanArray(Boolean[]& value);
    public abstract virtual void GetStringArray(String[]& value);
    public abstract virtual void GetInspectableArray(Object[]& value);
    public abstract virtual void GetGuidArray(Guid[]& value);
    public abstract virtual void GetDateTimeArray(DateTimeOffset[]& value);
    public abstract virtual void GetTimeSpanArray(TimeSpan[]& value);
    public abstract virtual void GetPointArray(Point[]& value);
    public abstract virtual void GetSizeArray(Size[]& value);
    public abstract virtual void GetRectArray(Rect[]& value);
    public abstract virtual bool get_IsNumericScalar();
    public abstract virtual PropertyType get_Type();
}
[GuidAttribute("61C17707-2D65-11E0-9AE8-D48564015472")]
[WindowsRuntimeHelperTypeAttribute("ABI.Windows.Foundation.IReferenceArray`1")]
internal interface Windows.Foundation.IReferenceArray`1 {
    public T[] Value { get; }
    public abstract virtual T[] get_Value();
}
[WindowsRuntimeTypeAttribute("Windows.Foundation.FoundationContract")]
[WindowsRuntimeHelperTypeAttribute("ABI.Windows.Foundation.Point")]
[WinRTExposedTypeAttribute("WinRT.StructTypeDetails`2<Windows.Foundation.Point,Windows.Foundation.Point>")]
public class Windows.Foundation.Point : ValueType {
    public float _x;
    public float _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Point(float x, float y);
    public Point(double x, double y);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ConvertToString(string format, IFormatProvider provider);
    private static char GetNumericListSeparator(IFormatProvider provider);
    public static bool op_Equality(Point point1, Point point2);
    public static bool op_Inequality(Point point1, Point point2);
    public virtual bool Equals(object o);
    public bool Equals(Point value);
    public virtual int GetHashCode();
}
internal enum Windows.Foundation.PropertyType : Enum {
    public UInt32 value__;
    public static PropertyType Empty;
    public static PropertyType UInt8;
    public static PropertyType Int16;
    public static PropertyType UInt16;
    public static PropertyType Int32;
    public static PropertyType UInt32;
    public static PropertyType Int64;
    public static PropertyType UInt64;
    public static PropertyType Single;
    public static PropertyType Double;
    public static PropertyType Char16;
    public static PropertyType Boolean;
    public static PropertyType String;
    public static PropertyType Inspectable;
    public static PropertyType DateTime;
    public static PropertyType TimeSpan;
    public static PropertyType Guid;
    public static PropertyType Point;
    public static PropertyType Size;
    public static PropertyType Rect;
    public static PropertyType OtherType;
    public static PropertyType UInt8Array;
    public static PropertyType Int16Array;
    public static PropertyType UInt16Array;
    public static PropertyType Int32Array;
    public static PropertyType UInt32Array;
    public static PropertyType Int64Array;
    public static PropertyType UInt64Array;
    public static PropertyType SingleArray;
    public static PropertyType DoubleArray;
    public static PropertyType Char16Array;
    public static PropertyType BooleanArray;
    public static PropertyType StringArray;
    public static PropertyType InspectableArray;
    public static PropertyType DateTimeArray;
    public static PropertyType TimeSpanArray;
    public static PropertyType GuidArray;
    public static PropertyType PointArray;
    public static PropertyType SizeArray;
    public static PropertyType RectArray;
    public static PropertyType OtherTypeArray;
}
[WindowsRuntimeTypeAttribute("Windows.Foundation.FoundationContract")]
[WindowsRuntimeHelperTypeAttribute("ABI.Windows.Foundation.Rect")]
[WinRTExposedTypeAttribute("WinRT.StructTypeDetails`2<Windows.Foundation.Rect,Windows.Foundation.Rect>")]
public class Windows.Foundation.Rect : ValueType {
    public float _x;
    public float _y;
    public float _width;
    public float _height;
    private static double EmptyX;
    private static double EmptyY;
    private static double EmptyWidth;
    private static double EmptyHeight;
    private static Rect s_empty;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public static Rect Empty { get; }
    public bool IsEmpty { get; }
    public Rect(float x, float y, float width, float height);
    public Rect(double x, double y, double width, double height);
    public Rect(Point point1, Point point2);
    public Rect(Point location, Size size);
    private static Rect();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public static Rect get_Empty();
    public bool get_IsEmpty();
    public bool Contains(Point point);
    public void Intersect(Rect rect);
    public void Union(Rect rect);
    public void Union(Point point);
    private bool ContainsInternal(float x, float y);
    internal bool IntersectsWith(Rect rect);
    private static Rect CreateEmptyRect();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public bool Equals(Rect value);
    public static bool op_Equality(Rect rect1, Rect rect2);
    public static bool op_Inequality(Rect rect1, Rect rect2);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[WindowsRuntimeTypeAttribute("Windows.Foundation.FoundationContract")]
[WindowsRuntimeHelperTypeAttribute("ABI.Windows.Foundation.Size")]
[WinRTExposedTypeAttribute("WinRT.StructTypeDetails`2<Windows.Foundation.Size,Windows.Foundation.Size>")]
public class Windows.Foundation.Size : ValueType {
    public float _width;
    public float _height;
    private static Size s_empty;
    public double Width { get; public set; }
    public double Height { get; public set; }
    public static Size Empty { get; }
    public bool IsEmpty { get; }
    public Size(float width, float height);
    public Size(double width, double height);
    private static Size();
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public static Size get_Empty();
    public bool get_IsEmpty();
    private static Size CreateEmptySize();
    public static bool op_Equality(Size size1, Size size2);
    public static bool op_Inequality(Size size1, Size size2);
    public virtual bool Equals(object o);
    public bool Equals(Size value);
    public virtual int GetHashCode();
    private static bool Equals(Size size1, Size size2);
    public virtual string ToString();
}
public static class Windows.Foundation.TokenizerHelper : object {
    public static char GetNumericListSeparator(IFormatProvider provider);
}
public class Windows.UI.Xaml.Automation.ElementNotAvailableException : Exception {
    public ElementNotAvailableException(string message);
    public ElementNotAvailableException(string message, Exception innerException);
}
public class Windows.UI.Xaml.Automation.ElementNotEnabledException : Exception {
    public ElementNotEnabledException(string message);
    public ElementNotEnabledException(string message, Exception innerException);
}
public class Windows.UI.Xaml.LayoutCycleException : Exception {
    public LayoutCycleException(string message);
    public LayoutCycleException(string message, Exception innerException);
}
public class Windows.UI.Xaml.Markup.XamlParseException : Exception {
    public XamlParseException(string message);
    public XamlParseException(string message, Exception innerException);
}
public static class WinRT.ActivationFactory : object {
    [CompilerGeneratedAttribute]
private static Func`3<string, Guid, IntPtr> <ActivationHandler>k__BackingField;
    public static Func`3<string, Guid, IntPtr> ActivationHandler { get; public set; }
    [CompilerGeneratedAttribute]
public static Func`3<string, Guid, IntPtr> get_ActivationHandler();
    [CompilerGeneratedAttribute]
public static void set_ActivationHandler(Func`3<string, Guid, IntPtr> value);
    public static IObjectReference Get(string typeName);
    public static IObjectReference Get(string typeName, Guid iid);
    private static IObjectReference GetFromActivationHandler(string typeName, Guid iid);
}
public class WinRT.AgileReference : object {
    private static Guid CLSID_StdGlobalInterfaceTable;
    private static object _lock;
    private static IGlobalInterfaceTable modreq(System.Runtime.CompilerServices.IsVolatile) _git;
    private IObjectReference _agileReference;
    private IntPtr _cookie;
    private bool disposed;
    internal static IGlobalInterfaceTable Git { get; }
    public AgileReference(IObjectReference instance);
    internal AgileReference(ObjectReferenceValue& instance);
    internal AgileReference(IntPtr thisPtr);
    private static AgileReference();
    internal static IGlobalInterfaceTable get_Git();
    public IObjectReference Get();
    internal ObjectReference`1<T> Get(Guid iid);
    protected virtual void Dispose(bool disposing);
    private static IGlobalInterfaceTable GetGitTable();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static IGlobalInterfaceTable <get_Git>g__Git_Slow|4_0();
}
public class WinRT.AgileReference`1 : AgileReference {
    public AgileReference`1(IObjectReference instance);
    internal AgileReference`1(ObjectReferenceValue& instance);
    public T Get();
}
internal static class WinRT.AttributeMessages : object {
    public static string GenericDeprecatedMessage;
    public static string GenericRequiresUnreferencedCodeMessage;
    public static string MarshallingOrGenericInstantiationsRequiresDynamicCode;
    public static string AbiTypesNeverHaveConstructors;
}
[ExtensionAttribute]
public static class WinRT.CastExtensions : object {
    [ExtensionAttribute]
public static TInterface As(object value);
    [ExtensionAttribute]
public static AgileReference`1<T> AsAgile(T value);
    private static bool TryGetRefForObject(object value, bool allowComposed, IObjectReference& reference);
    private static IObjectReference GetRefForObject(object value);
    private static bool TryGetComposedRefForQI(object value, IObjectReference& objRef);
}
public class WinRT.ComWrappersHelper : object {
    public static void Init(bool isAggregation, object thisInstance, IntPtr newInstance, IntPtr inner, IObjectReference& objRef);
    public static void Init(bool isAggregation, object thisInstance, IntPtr newInstance, IntPtr inner, Guid iidForNewInstance, IObjectReference& objRef);
    public static void Init(IObjectReference objRef, bool addRefFromTrackerSource);
}
public static class WinRT.ComWrappersSupport : object {
    internal static int GC_PRESSURE_BASE;
    private static ConcurrentDictionary`2<Type, Func`2<IInspectable, object>> TypedObjectFactoryCacheForType;
    private static ConcurrentDictionary`2<Type, Func`2<IntPtr, object>> DelegateFactoryCache;
    internal static ConditionalWeakTable`2<object, IInspectable> BoxedValueReferenceCache;
    private static DefaultComWrappers _instance;
    internal static ConditionalWeakTable`2<Type, InspectableInfo> InspectableInfoTable;
    [ThreadStaticAttribute]
internal static Type CreateRCWType;
    private static ComWrappers _comWrappers;
    private static object _comWrappersLock;
    private static List`1<Func`2<Type, ComInterfaceEntry[]>> ComInterfaceEntriesLookup;
    private static List`1<Func`2<Type, string>> RuntimeClassNameForNonWinRTTypeLookup;
    private static ConcurrentDictionary`2<Type, ComInterfaceEntry[]> ComInterfaceEntriesForType;
    private static ComInterfaceEntry IPropertyValueEntry { get; }
    private static DefaultComWrappers DefaultComWrappersInstance { get; }
    private static ComWrappers ComWrappers { get; private set; }
    public static IUnknownVftbl IUnknownVftbl { get; }
    public static IntPtr IUnknownVftblPtr { get; }
    private static ComWrappersSupport();
    public static TReturn MarshalDelegateInvoke(IntPtr thisPtr, Func`2<TDelegate, TReturn> invoke);
    public static void MarshalDelegateInvoke(IntPtr thisPtr, Action`1<T> invoke);
    internal static bool IsFreeThreaded(IntPtr iUnknown);
    internal static bool IsFreeThreaded(IObjectReference objRef);
    public static IObjectReference GetObjectReferenceForInterface(IntPtr externalComObject);
    [RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
public static ObjectReference`1<T> GetObjectReferenceForInterface(IntPtr externalComObject);
    public static ObjectReference`1<T> GetObjectReferenceForInterface(IntPtr externalComObject, Guid iid);
    public static IObjectReference GetObjectReferenceForInterface(IntPtr externalComObject, Guid iid, bool requireQI);
    internal static ObjectReference`1<T> GetObjectReferenceForInterface(IntPtr externalComObject, Guid iid, bool requireQI);
    public static void RegisterProjectionAssembly(Assembly assembly);
    public static void RegisterProjectionTypeBaseTypeMapping(IDictionary`2<string, string> typeNameToBaseTypeNameMapping);
    public static void RegisterAuthoringMetadataTypeLookup(Func`2<Type, Type> authoringMetadataTypeLookup);
    public static void RegisterHelperType(Type type, Type helperType);
    internal static List`1<ComInterfaceEntry> GetInterfaceTableEntries(Type type);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026:RequiresUnreferencedCode")]
internal static ValueTuple`2<InspectableInfo, List`1<ComInterfaceEntry>> PregenerateNativeTypeInformation(Type type);
    private static Func`2<IInspectable, object> CreateKeyValuePairFactory(Type type);
    internal static Func`2<IntPtr, object> GetOrCreateDelegateFactory(Type type);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2067")]
private static Func`2<IntPtr, object> CreateDelegateFactory(Type type);
    public static bool RegisterDelegateFactory(Type implementationType, Func`2<IntPtr, object> delegateFactory);
    internal static Func`2<IInspectable, object> CreateNullableTFactory(Type implementationType);
    internal static Func`2<IInspectable, object> CreateAbiNullableTFactory(Type implementationType);
    private static Func`2<IInspectable, object> CreateArrayFactory(Type implementationType);
    internal static Func`2<IInspectable, object> CreateReferenceCachingFactory(Func`2<IInspectable, object> internalFactory);
    private static Func`2<IInspectable, object> CreateCustomTypeMappingFactory(Type customTypeHelperType);
    internal static Func`2<IInspectable, object> CreateTypedRcwFactory(Type implementationType);
    internal static Func`2<IInspectable, object> CreateTypedRcwFactory(Type implementationType, string runtimeClassName);
    internal static Type GetRuntimeClassForTypeCreation(IInspectable inspectable, Type staticallyDeterminedType);
    private static ComInterfaceEntry get_IPropertyValueEntry();
    private static ComInterfaceEntry ProvideIReference(Type type);
    private static ComInterfaceEntry ProvideIReferenceArray(Type arrayType);
    internal static ObjectReference`1<T> CreateCCWForObject(object obj, Guid iid);
    internal static ObjectReferenceValue CreateCCWForObjectForMarshaling(object obj, Guid iid);
    private static DefaultComWrappers get_DefaultComWrappersInstance();
    private static ComWrappers get_ComWrappers();
    private static void set_ComWrappers(ComWrappers value);
    internal static InspectableInfo GetInspectableInfo(IntPtr pThis);
    public static T CreateRcwForComObject(IntPtr ptr);
    private static T CreateRcwForComObject(IntPtr ptr, bool tryUseCache);
    public static bool TryUnwrapObject(object o, IObjectReference& objRef);
    public static void RegisterObjectForInterface(object obj, IntPtr thisPtr, CreateObjectFlags createObjectFlags);
    internal static void RegisterObjectForInterface(object obj, IntPtr thisPtr, IntPtr inner, CreateObjectFlags createObjectFlags);
    public static void RegisterObjectForInterface(object obj, IntPtr thisPtr);
    public static object TryRegisterObjectForInterface(object obj, IntPtr thisPtr);
    public static IObjectReference CreateCCWForObject(object obj);
    internal static IntPtr CreateCCWForObjectForABI(object obj, Guid iid);
    public static T FindObject(IntPtr ptr);
    public static IUnknownVftbl get_IUnknownVftbl();
    public static IntPtr get_IUnknownVftblPtr();
    public static IntPtr AllocateVtableMemory(Type vtableType, int size);
    public static void InitializeComWrappers(ComWrappers wrappers);
    internal static Func`2<IInspectable, object> GetTypedRcwFactory(Type implementationType);
    public static bool RegisterTypedRcwFactory(Type implementationType, Func`2<IInspectable, object> rcwFactory);
    private static Func`2<IInspectable, object> CreateFactoryForImplementationType(string runtimeClassName, Type implementationType);
    public static void RegisterTypeComInterfaceEntriesLookup(Func`2<Type, ComInterfaceEntry[]> comInterfaceEntriesLookup);
    internal static ComInterfaceEntry[] GetComInterfaceEntriesForTypeFromLookupTable(Type type);
    public static void RegisterTypeRuntimeClassNameLookup(Func`2<Type, string> runtimeClassNameLookup);
    internal static string GetRuntimeClassNameForNonWinRTTypeFromLookupTable(Type type);
    public static void RegisterComInterfaceEntries(Type implementationType, ComInterfaceEntry[] comInterfaceEntries);
    [CompilerGeneratedAttribute]
internal static bool <GetInterfaceTableEntries>g__GetHasCustomIMarshalInterface|16_0(List`1<ComInterfaceEntry> entries);
    [CompilerGeneratedAttribute]
internal static void <GetInterfaceTableEntries>g__AddInterfaceToVtable|16_1(Type iface, List`1<ComInterfaceEntry> entries, bool hasCustomIMarshalInterface);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2067")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2070")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2075")]
internal static void <GetInterfaceTableEntries>g__GetInterfaceTableEntriesForJitEnvironment|16_2(Type type, List`1<ComInterfaceEntry> entries, bool hasCustomIMarshalInterface);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2070")]
internal static Func`2<IInspectable, object> <CreateFactoryForImplementationType>g__CreateRcwFallback|67_1(Type implementationType);
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
internal static Type <CreateFactoryForImplementationType>g__GetGenericImplType|67_2(Type implementationType);
}
internal static class WinRT.Context : object {
    public static IntPtr GetContextToken();
    public static IntPtr GetContextCallback();
    public static void CallInContext(IntPtr contextCallbackPtr, IntPtr contextToken, method callback, method onFailCallback, object state);
    public static void DisposeContextCallback(IntPtr contextCallbackPtr);
}
public class WinRT.DefaultComWrappers : ComWrappers {
    private static ConditionalWeakTable`2<Type, VtableEntries> TypeVtableEntryTable;
    [CompilerGeneratedAttribute]
private static IntPtr <IUnknownVftblPtr>k__BackingField;
    public static IUnknownVftbl IUnknownVftbl { get; }
    internal static IntPtr IUnknownVftblPtr { get; }
    private static DefaultComWrappers();
    public static IUnknownVftbl get_IUnknownVftbl();
    [CompilerGeneratedAttribute]
internal static IntPtr get_IUnknownVftblPtr();
    protected virtual ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, Int32& count);
    private static bool IsRuntimeImplementedRCW(Type objType);
    private static object CreateObject(IntPtr externalComObject);
    protected virtual object CreateObject(IntPtr externalComObject, CreateObjectFlags flags);
    protected virtual void ReleaseObjects(IEnumerable objects);
}
[ExtensionAttribute]
internal static class WinRT.DelegateExtensions : object {
    [ExtensionAttribute]
public static void DynamicInvokeAbi(Delegate del, Object[] invoke_params);
    [ExtensionAttribute]
public static Func`2<object, object> WithMarshaler2Support(Func`2<IObjectReference, IntPtr> function);
    [ExtensionAttribute]
public static Action`1<object> WithMarshaler2Support(Action`1<IObjectReference> action);
    [ExtensionAttribute]
public static Action`2<T, IntPtr> WithTypedT1(Action`2<object, IntPtr> action);
    [ExtensionAttribute]
public static Func`2<object, TResult> WithObjectT(Func`2<T, TResult> function);
    [ExtensionAttribute]
public static Func`2<T, object> WithObjectTResult(Func`2<T, TResult> function);
    [ExtensionAttribute]
public static Action`1<object> WithObjectParams(Action`1<T> action);
    [ExtensionAttribute]
private static object InvokeWithMarshaler2Support(Func`2<IObjectReference, IntPtr> func, object arg);
    [ExtensionAttribute]
private static void InvokeWithMarshaler2Support(Action`1<IObjectReference> action, object arg);
    [ExtensionAttribute]
private static object InvokeWithObjectTResult(Func`2<T, TResult> func, T arg);
    [ExtensionAttribute]
private static TResult InvokeWithObjectT(Func`2<T, TResult> func, object arg);
    [ExtensionAttribute]
private static void InvokeWithObjectParams(Action`1<T> func, object arg);
    [ExtensionAttribute]
private static void InvokeWithTypedT1(Action`2<object, IntPtr> action, T arg1, IntPtr arg2);
    [ExtensionAttribute]
public static object InvokeWithBoxedValueReferenceCacheInsertion(Func`2<IInspectable, object> factory, IInspectable inspectable);
}
public abstract class WinRT.DelegateTypeDetails`1 : object {
    private static Guid PIID;
    private static DelegateTypeDetails`1();
    public sealed virtual ComInterfaceEntry[] GetExposedInterfaces();
    public static ComInterfaceEntry[] GetExposedInterfaces(ComInterfaceEntry delegateInterface);
    public abstract virtual ComInterfaceEntry GetDelegateInterface();
    private sealed virtual override object WinRT.IWinRTNullableTypeDetails.GetNullableValue(IInspectable inspectable);
    private sealed virtual override Type WinRT.IWinRTNullableTypeDetails.GetNullableType();
}
[EditorBrowsableAttribute("1")]
public class WinRT.DerivedComposed : object {
    public static DerivedComposed Instance;
    private static DerivedComposed();
}
internal class WinRT.DllModule : object {
    private static string _currentModuleDirectory;
    private static Dictionary`2<string, DllModule> _cache;
    private string _fileName;
    private IntPtr _moduleHandle;
    private method _GetActivationFactory;
    private method _CanUnloadNow;
    private DllModule(string fileName, IntPtr moduleHandle, Void* getActivationFactory);
    private static DllModule();
    public static bool TryLoad(string fileName, DllModule& module);
    private static bool TryCreate(string fileName, DllModule& module);
    public ValueTuple`2<ObjectReference`1<IUnknownVftbl>, int> GetActivationFactory(string runtimeClassId);
    protected virtual override void Finalize();
}
public class WinRT.EnumTypeDetails`1 : object {
    [SkipLocalsInitAttribute]
public sealed virtual ComInterfaceEntry[] GetExposedInterfaces();
    private sealed virtual override Type WinRT.IWinRTNullableTypeDetails.GetNullableType();
    private sealed virtual override object WinRT.IWinRTNullableTypeDetails.GetNullableValue(IInspectable inspectable);
}
[WindowsRuntimeTypeAttribute("Windows.Foundation.FoundationContract")]
[WindowsRuntimeHelperTypeAttribute("ABI.WinRT.EventRegistrationToken")]
[WinRTExposedTypeAttribute("WinRT.StructTypeDetails`2<WinRT.EventRegistrationToken,WinRT.EventRegistrationToken>")]
public class WinRT.EventRegistrationToken : ValueType {
    public long Value;
    public EventRegistrationToken(long _Value);
    public static bool op_Equality(EventRegistrationToken x, EventRegistrationToken y);
    public static bool op_Inequality(EventRegistrationToken x, EventRegistrationToken y);
    public sealed virtual bool Equals(EventRegistrationToken other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class WinRT.EventRegistrationTokenTable`1 : object {
    private static int TypeOfTHashCode;
    private Dictionary`2<int, object> m_tokens;
    private int m_low32Bits;
    private static EventRegistrationTokenTable`1();
    private static int GetTypeOfTHashCode();
    public EventRegistrationToken AddEventHandler(T handler);
    [NullableContextAttribute("2")]
public bool RemoveEventHandler(EventRegistrationToken token, T& handler);
}
[ExtensionAttribute]
public static class WinRT.ExceptionExtensions : object {
    [ExtensionAttribute]
public static void SetHResult(Exception ex, int value);
    [ExtensionAttribute]
internal static Exception GetExceptionForHR(Exception innerException, int hresult, string messageResource);
}
[ExtensionAttribute]
public static class WinRT.ExceptionHelpers : object {
    private static int COR_E_OBJECTDISPOSED;
    private static int COR_E_OPERATIONCANCELED;
    private static int COR_E_ARGUMENTOUTOFRANGE;
    private static int COR_E_INDEXOUTOFRANGE;
    private static int COR_E_TIMEOUT;
    private static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int E_CHANGED_STATE;
    private static int E_ILLEGAL_STATE_CHANGE;
    private static int E_ILLEGAL_METHOD_CALL;
    private static int E_ILLEGAL_DELEGATE_ASSIGNMENT;
    private static int APPMODEL_ERROR_NO_PACKAGE;
    internal static int E_XAMLPARSEFAILED;
    internal static int E_LAYOUTCYCLE;
    internal static int E_ELEMENTNOTENABLED;
    internal static int E_ELEMENTNOTAVAILABLE;
    internal static int ERROR_INVALID_WINDOW_HANDLE;
    private static int E_POINTER;
    private static int E_NOTIMPL;
    private static int E_ACCESSDENIED;
    internal static int E_INVALIDARG;
    private static int E_NOINTERFACE;
    private static int E_OUTOFMEMORY;
    private static int ERROR_ARITHMETIC_OVERFLOW;
    private static int ERROR_FILENAME_EXCED_RANGE;
    private static int ERROR_FILE_NOT_FOUND;
    private static int ERROR_HANDLE_EOF;
    private static int ERROR_PATH_NOT_FOUND;
    private static int ERROR_STACK_OVERFLOW;
    private static int ERROR_BAD_FORMAT;
    private static int ERROR_CANCELLED;
    private static int ERROR_TIMEOUT;
    private static method getRestrictedErrorInfo;
    private static method setRestrictedErrorInfo;
    private static method roOriginateLanguageException;
    private static method roReportUnhandledError;
    private static bool initialized;
    private static ExceptionHelpers();
    private static bool Initialize();
    public static void ThrowExceptionForHR(int hr);
    private static ObjectReference`1<IUnknownVftbl> BorrowRestrictedErrorInfo();
    public static Exception GetExceptionForHR(int hr);
    private static Exception GetExceptionForHR(int hr, bool useGlobalErrorState, Boolean& restoredExceptionFromGlobalState);
    public static void SetErrorInfo(Exception ex);
    public static void ReportUnhandledError(Exception ex);
    public static int GetHRForException(Exception ex);
    [ExtensionAttribute]
internal static void AddExceptionDataForRestrictedErrorInfo(Exception ex, string description, string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, ObjectReference`1<IUnknownVftbl> restrictedErrorObject, bool hasRestrictedLanguageErrorObject);
    [ExtensionAttribute]
internal static bool TryGetRestrictedLanguageErrorObject(Exception ex, ObjectReference`1& restrictedErrorObject);
    public static Exception AttachRestrictedErrorInfo(Exception e);
    [CompilerGeneratedAttribute]
internal static void <ThrowExceptionForHR>g__Throw|38_0(int hr);
}
internal static class WinRT.FeatureSwitches : object {
    private static string EnableDynamicObjectsSupportPropertyName;
    private static string UseExceptionResourceKeysPropertyName;
    private static string EnableDefaultCustomTypeMappingsPropertyName;
    private static string EnableICustomPropertyProviderSupportPropertyName;
    private static string EnableIReferenceSupportPropertyName;
    private static string EnableIDynamicInterfaceCastableSupportPropertyName;
    private static string UseWindowsUIXamlProjectionsPropertyName;
    private static int _enableDynamicObjectsSupport;
    private static int _useExceptionResourceKeys;
    private static int _enableDefaultCustomTypeMappings;
    private static int _enableICustomPropertyProviderSupport;
    private static int _enableIReferenceSupport;
    private static int _enableIDynamicInterfaceCastableSupport;
    private static int _useWindowsUIXamlProjections;
    public static bool EnableDynamicObjectsSupport { get; }
    public static bool UseExceptionResourceKeys { get; }
    public static bool EnableDefaultCustomTypeMappings { get; }
    public static bool EnableICustomPropertyProviderSupport { get; }
    public static bool EnableIReferenceSupport { get; }
    public static bool EnableIDynamicInterfaceCastableSupport { get; }
    public static bool UseWindowsUIXamlProjections { get; }
    public static bool get_EnableDynamicObjectsSupport();
    public static bool get_UseExceptionResourceKeys();
    public static bool get_EnableDefaultCustomTypeMappings();
    public static bool get_EnableICustomPropertyProviderSupport();
    public static bool get_EnableIReferenceSupport();
    public static bool get_EnableIDynamicInterfaceCastableSupport();
    public static bool get_UseWindowsUIXamlProjections();
    private static bool GetConfigurationValue(string propertyName, Int32& cachedResult, bool defaultValue);
}
[AttributeUsageAttribute("4")]
public class WinRT.GeneratedBindableCustomPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <PropertyNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <IndexerPropertyTypes>k__BackingField;
    internal String[] PropertyNames { get; }
    internal Type[] IndexerPropertyTypes { get; }
    public GeneratedBindableCustomPropertyAttribute(String[] propertyNames, Type[] indexerPropertyTypes);
    [CompilerGeneratedAttribute]
internal String[] get_PropertyNames();
    [CompilerGeneratedAttribute]
internal Type[] get_IndexerPropertyTypes();
}
internal static class WinRT.GenericDelegateHelper : object {
    internal static ConditionalWeakTable`2<IObjectReference, object> DelegateTable;
    private static GenericDelegateHelper();
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
internal static Delegate CreateDelegate(IntPtr ptr, Delegate& delegateRef, Type delegateType, int offset);
}
public static class WinRT.GuidGenerator : object {
    private static Guid wrt_pinterface_namespace;
    private static GuidGenerator();
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2067")]
public static Guid GetGUID(Type type);
    public static Guid GetIID(Type type);
    internal static bool TryGetWindowsUIXamlIID(Type type, Guid& iid);
    public static string GetSignature(Type type);
    private static Guid encode_guid(Span`1<byte> data);
    public static Guid CreateIID(Type type);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2067")]
internal static Guid CreateIIDUnsafe(Type type);
    internal static Guid CreateIIDForGenericType(string signature);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2062")]
internal static String[] <GetSignature>g__SelectSignaturesForTypes|3_1(Type[] types);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2072")]
internal static String[] <GetSignature>g__SelectSignaturesForFields|3_2(FieldInfo[] fields);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2067")]
internal static bool <GetSignature>g__TryGetSignatureFromDefaultInterfaceTypeForRuntimeClassType|3_0(Type type, String& signature);
}
internal class WinRT.HelperTypeMetadataNotAvailableOnAot : object {
}
[GuidAttribute("AF86E2E0-B12D-4c6a-9C5A-D7AA65101E90")]
public class WinRT.IInspectable : object {
    private ObjectReference`1<IUnknownVftbl> _obj;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    public IntPtr ThisPtr { get; }
    public IObjectReference ObjRef { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    public IInspectable(IObjectReference obj);
    [ObsoleteAttribute("This method is deprecated and will be removed in a future release.")]
[EditorBrowsableAttribute("1")]
public IInspectable(ObjectReference`1<Vftbl> obj);
    internal IInspectable(ObjectReference`1<IUnknownVftbl> obj);
    public static IInspectable FromAbi(IntPtr thisPtr);
    public IntPtr get_ThisPtr();
    [RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
[ObsoleteAttribute("This method is deprecated and will be removed in a future release.")]
[EditorBrowsableAttribute("1")]
public ObjectReference`1<I> As();
    public IObjectReference get_ObjRef();
    public string GetRuntimeClassName(bool noThrow);
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._add_EventHandler : MulticastDelegate {
    public _add_EventHandler(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr handler, EventRegistrationToken& token);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr handler, EventRegistrationToken& token, AsyncCallback callback, object object);
    public virtual int EndInvoke(EventRegistrationToken& token, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsBoolean : MulticastDelegate {
    public _get_PropertyAsBoolean(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Byte& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Byte& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Byte& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
internal class WinRT.Interop._get_PropertyAsBoolean_Abi : MulticastDelegate {
    public _get_PropertyAsBoolean_Abi(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Byte* value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Byte* value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsByte : MulticastDelegate {
    public _get_PropertyAsByte(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Byte& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Byte& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Byte& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsChar : MulticastDelegate {
    public _get_PropertyAsChar(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, UInt16& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, UInt16& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(UInt16& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsDouble : MulticastDelegate {
    public _get_PropertyAsDouble(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Double& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Double& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Double& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsFloat : MulticastDelegate {
    public _get_PropertyAsFloat(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Single& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Single& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Single& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsGuid : MulticastDelegate {
    public _get_PropertyAsGuid(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Guid& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Guid& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Guid& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsInt16 : MulticastDelegate {
    public _get_PropertyAsInt16(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Int16& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Int16& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Int16& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsInt32 : MulticastDelegate {
    public _get_PropertyAsInt32(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Int32& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Int32& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Int32& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsInt64 : MulticastDelegate {
    public _get_PropertyAsInt64(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Int64& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Int64& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Int64& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsObject : MulticastDelegate {
    public _get_PropertyAsObject(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IntPtr& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsSByte : MulticastDelegate {
    public _get_PropertyAsSByte(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, SByte& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, SByte& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(SByte& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsString : MulticastDelegate {
    public _get_PropertyAsString(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IntPtr& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsUInt16 : MulticastDelegate {
    public _get_PropertyAsUInt16(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, UInt16& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, UInt16& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(UInt16& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsUInt32 : MulticastDelegate {
    public _get_PropertyAsUInt32(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, UInt32& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, UInt32& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(UInt32& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
internal class WinRT.Interop._get_PropertyAsUInt32_Abi : MulticastDelegate {
    public _get_PropertyAsUInt32_Abi(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, UInt32* value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, UInt32* value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsUInt64 : MulticastDelegate {
    public _get_PropertyAsUInt64(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, UInt64& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, UInt64& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(UInt64& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsBoolean : MulticastDelegate {
    public _put_PropertyAsBoolean(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, byte value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, byte value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsByte : MulticastDelegate {
    public _put_PropertyAsByte(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, byte value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, byte value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsChar : MulticastDelegate {
    public _put_PropertyAsChar(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, ushort value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, ushort value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsDouble : MulticastDelegate {
    public _put_PropertyAsDouble(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, double value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, double value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsFloat : MulticastDelegate {
    public _put_PropertyAsFloat(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, float value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, float value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsGuid : MulticastDelegate {
    public _put_PropertyAsGuid(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Guid value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Guid value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsInt16 : MulticastDelegate {
    public _put_PropertyAsInt16(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, short value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, short value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsInt32 : MulticastDelegate {
    public _put_PropertyAsInt32(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, int value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, int value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsInt64 : MulticastDelegate {
    public _put_PropertyAsInt64(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, long value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, long value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsObject : MulticastDelegate {
    public _put_PropertyAsObject(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsSByte : MulticastDelegate {
    public _put_PropertyAsSByte(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, sbyte value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, sbyte value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsString : MulticastDelegate {
    public _put_PropertyAsString(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsUInt16 : MulticastDelegate {
    public _put_PropertyAsUInt16(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, ushort value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, ushort value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsUInt32 : MulticastDelegate {
    public _put_PropertyAsUInt32(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, UInt32 value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, UInt32 value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsUInt64 : MulticastDelegate {
    public _put_PropertyAsUInt64(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, ulong value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, ulong value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._remove_EventHandler : MulticastDelegate {
    public _remove_EventHandler(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, EventRegistrationToken token);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, EventRegistrationToken token, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
[WindowsRuntimeHelperTypeAttribute("ABI.WinRT.Interop.IActivationFactory")]
public interface WinRT.Interop.IActivationFactory {
    public abstract virtual IntPtr ActivateInstance();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("94ea2b94-e9cc-49e0-c0ff-ee64ca8f5b90")]
[WindowsRuntimeHelperTypeAttribute("ABI.WinRT.Interop.IAgileObject")]
public interface WinRT.Interop.IAgileObject {
    public static Guid IID;
    private static IAgileObject();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("C03F6A43-65A4-9818-987E-E0B810D2A6F2")]
[WindowsRuntimeHelperTypeAttribute("ABI.WinRT.Interop.IAgileReference")]
internal interface WinRT.Interop.IAgileReference {
    public abstract virtual IObjectReference Resolve(Guid riid);
}
internal class WinRT.Interop.IDelegateVftbl : ValueType {
    public IUnknownVftbl IUnknownVftbl;
    public IntPtr Invoke;
}
public static class WinRT.Interop.IID : object {
    [IsReadOnlyAttribute]
public static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IUnknown { get; }
    [IsReadOnlyAttribute]
public static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IInspectable { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IWeakReference { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IWeakReferenceSource { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceTracker { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceTrackerTarget { get; }
    [IsReadOnlyAttribute]
public static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IActivationFactory { get; }
    [IsReadOnlyAttribute]
public static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IAgileObject { get; }
    [IsReadOnlyAttribute]
public static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IMarshal { get; }
    [IsReadOnlyAttribute]
public static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IBuffer { get; }
    [IsReadOnlyAttribute]
public static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IBufferByteAccess { get; }
    [IsReadOnlyAttribute]
public static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IMemoryBufferByteAccess { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IContextCallback { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_ICallbackWithNoReentrancyToApplicationSTA { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IErrorInfo { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_ISupportErrorInfo { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_ILanguageExceptionErrorInfo { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IRestrictedErrorInfo { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_MUX_INotifyPropertyChanged { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_WUX_INotifyPropertyChanged { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_MUX_INotifyCollectionChanged { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_WUX_INotifyCollectionChanged { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_MUX_INotifyCollectionChangedEventArgsFactory { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_WUX_INotifyCollectionChangedEventArgsFactory { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_MUX_INotifyCollectionChangedEventArgs { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_WUX_INotifyCollectionChangedEventArgs { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_MUX_NotifyCollectionChangedEventHandler { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_WUX_NotifyCollectionChangedEventHandler { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_MUX_PropertyChangedEventArgsRuntimeClassFactory { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_WUX_PropertyChangedEventArgsRuntimeClassFactory { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_MUX_PropertyChangedEventHandler { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_WUX_PropertyChangedEventHandler { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_DataErrorsChangedEventArgsRuntimeClassFactory { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_UriRuntimeClassFactory { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_INotifyDataErrorInfo { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_ICommand { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IGlobalInterfaceTable { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_EventHandler { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IBindableVectorView { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IEnumerable { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IList { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_ICustomProperty { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_ICustomPropertyProvider { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IPropertyValue { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IDisposable { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IStringable { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IServiceProvider { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceOfPoint { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceOfSize { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceOfRect { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceMatrix3x2 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceMatrix4x4 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferencePlane { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceQuaternion { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceVector2 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceVector3 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceVector4 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfInt32 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfString { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfByte { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfInt16 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfUInt16 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfUInt32 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfInt64 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfUInt64 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfSingle { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfDouble { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfChar { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfBoolean { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfGuid { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfDateTimeOffset { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfTimeSpan { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfObject { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfType { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfMatrix3x2 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfMatrix4x4 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfPlane { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfQuaternion { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfVector2 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfVector3 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfVector4 { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_IReferenceArrayOfException { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableByte { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableSByte { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableShort { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableUShort { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableInt { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableUInt { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableLong { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableULong { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableFloat { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableDouble { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableChar { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableBool { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableGuid { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableDateTimeOffset { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableTimeSpan { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableObject { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableType { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableException { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableEventHandler { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_NullableString { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_MUX_NullablePropertyChangedEventHandler { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_WUX_NullablePropertyChangedEventHandler { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_MUX_NullableNotifyCollectionChangedEventHandler { get; }
    [IsReadOnlyAttribute]
internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) IID_WUX_NullableNotifyCollectionChangedEventHandler { get; }
    public static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IUnknown();
    public static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IInspectable();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IWeakReference();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IWeakReferenceSource();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceTracker();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceTrackerTarget();
    public static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IActivationFactory();
    public static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IAgileObject();
    public static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IMarshal();
    public static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IBuffer();
    public static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IBufferByteAccess();
    public static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IMemoryBufferByteAccess();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IContextCallback();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_ICallbackWithNoReentrancyToApplicationSTA();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IErrorInfo();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_ISupportErrorInfo();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_ILanguageExceptionErrorInfo();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IRestrictedErrorInfo();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_MUX_INotifyPropertyChanged();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_WUX_INotifyPropertyChanged();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_MUX_INotifyCollectionChanged();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_WUX_INotifyCollectionChanged();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_MUX_INotifyCollectionChangedEventArgsFactory();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_WUX_INotifyCollectionChangedEventArgsFactory();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_MUX_INotifyCollectionChangedEventArgs();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_WUX_INotifyCollectionChangedEventArgs();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_MUX_NotifyCollectionChangedEventHandler();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_WUX_NotifyCollectionChangedEventHandler();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_MUX_PropertyChangedEventArgsRuntimeClassFactory();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_WUX_PropertyChangedEventArgsRuntimeClassFactory();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_MUX_PropertyChangedEventHandler();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_WUX_PropertyChangedEventHandler();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_DataErrorsChangedEventArgsRuntimeClassFactory();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_UriRuntimeClassFactory();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_INotifyDataErrorInfo();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_ICommand();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IGlobalInterfaceTable();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_EventHandler();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IBindableVectorView();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IEnumerable();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IList();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_ICustomProperty();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_ICustomPropertyProvider();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IPropertyValue();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IDisposable();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IStringable();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IServiceProvider();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceOfPoint();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceOfSize();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceOfRect();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceMatrix3x2();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceMatrix4x4();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferencePlane();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceQuaternion();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceVector2();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceVector3();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceVector4();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfInt32();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfString();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfByte();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfInt16();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfUInt16();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfUInt32();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfInt64();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfUInt64();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfSingle();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfDouble();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfChar();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfBoolean();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfGuid();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfDateTimeOffset();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfTimeSpan();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfObject();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfType();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfMatrix3x2();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfMatrix4x4();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfPlane();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfQuaternion();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfVector2();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfVector3();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfVector4();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_IReferenceArrayOfException();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableByte();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableSByte();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableShort();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableUShort();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableInt();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableUInt();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableLong();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableULong();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableFloat();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableDouble();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableChar();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableBool();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableGuid();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableDateTimeOffset();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableTimeSpan();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableObject();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableType();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableException();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableEventHandler();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_NullableString();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_MUX_NullablePropertyChangedEventHandler();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_WUX_NullablePropertyChangedEventHandler();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_MUX_NullableNotifyCollectionChangedEventHandler();
    internal static Guid& modreq(System.Runtime.InteropServices.InAttribute) get_IID_WUX_NullableNotifyCollectionChangedEventHandler();
}
[GuidAttribute("11D3B13A-180E-4789-A8BE-7712882893E6")]
internal class WinRT.Interop.IReferenceTrackerVftbl : ValueType {
    public IUnknownVftbl IUnknownVftbl;
    private Void* _ConnectFromTrackerSource_0;
    private Void* _DisconnectFromTrackerSource_1;
    private Void* _FindTrackerTargets_2;
    private Void* _GetReferenceTrackerManager_3;
    private Void* _AddRefFromTrackerSource_4;
    private Void* _ReleaseFromTrackerSource_5;
    private Void* _PegFromTrackerSource_6;
    public method AddRefFromTrackerSource { get; public set; }
    public method ReleaseFromTrackerSource { get; public set; }
    public method get_AddRefFromTrackerSource();
    public void set_AddRefFromTrackerSource(method value);
    public method get_ReleaseFromTrackerSource();
    public void set_ReleaseFromTrackerSource(method value);
}
[GuidAttribute("00000000-0000-0000-C000-000000000046")]
public class WinRT.Interop.IUnknownVftbl : ValueType {
    private Void* _QueryInterface;
    private Void* _AddRef;
    private Void* _Release;
    public method QueryInterface { get; public set; }
    public method AddRef { get; public set; }
    public method Release { get; public set; }
    public static IUnknownVftbl AbiToProjectionVftbl { get; }
    public static IntPtr AbiToProjectionVftblPtr { get; }
    public method get_QueryInterface();
    public void set_QueryInterface(method value);
    public method get_AddRef();
    public void set_AddRef(method value);
    public method get_Release();
    public void set_Release(method value);
    public static IUnknownVftbl get_AbiToProjectionVftbl();
    public static IntPtr get_AbiToProjectionVftblPtr();
    internal bool Equals(IUnknownVftbl other);
    internal static bool IsReferenceToManagedObject(IntPtr ptr);
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("00000037-0000-0000-C000-000000000046")]
[WindowsRuntimeHelperTypeAttribute("ABI.WinRT.Interop.IWeakReference")]
public interface WinRT.Interop.IWeakReference {
    public abstract virtual IObjectReference Resolve(Guid riid);
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("00000038-0000-0000-C000-000000000046")]
[WindowsRuntimeHelperTypeAttribute("ABI.WinRT.Interop.IWeakReferenceSource")]
public interface WinRT.Interop.IWeakReferenceSource {
    public abstract virtual IWeakReference GetWeakReference();
}
internal static class WinRT.Interop.LibraryImportStubs : object {
    public static bool FreeLibrary(IntPtr moduleHandle);
    public static IntPtr GetProcAddress(IntPtr moduleHandle, SByte* functionName);
    public static IntPtr LoadLibraryExW(UInt16* fileName, IntPtr fileHandle, UInt32 flags);
    [CompilerGeneratedAttribute]
internal static int <FreeLibrary>g__PInvoke|0_0(IntPtr nativeModuleHandle);
    [CompilerGeneratedAttribute]
internal static IntPtr <GetProcAddress>g__PInvoke|1_0(IntPtr nativeModuleHandle, SByte* nativeFunctionName);
    [CompilerGeneratedAttribute]
internal static IntPtr <LoadLibraryExW>g__PInvoke|2_0(UInt16* nativeFileName, IntPtr nativeFileHandle, UInt32 nativeFlags);
}
[WinRTExposedTypeAttribute("WinRT.Interop.ManagedExceptionErrorInfoTypeDetails")]
internal class WinRT.Interop.ManagedExceptionErrorInfo : object {
    private Exception _exception;
    public ManagedExceptionErrorInfo(Exception ex);
    public bool InterfaceSupportsErrorInfo(Guid riid);
    public Guid GetGuid();
    public string GetSource();
    public string GetDescription();
    public string GetHelpFile();
    public string GetHelpFileContent();
}
internal class WinRT.Interop.ManagedExceptionErrorInfoTypeDetails : object {
    public sealed virtual ComInterfaceEntry[] GetExposedInterfaces();
}
[WinRTExposedTypeAttribute("WinRT.Interop.ManagedWeakReferenceTypeDetails")]
internal class WinRT.Interop.ManagedWeakReference : object {
    private WeakReference`1<object> _ref;
    public ManagedWeakReference(object obj);
    public sealed virtual IObjectReference Resolve(Guid riid);
    public IntPtr ResolveForABI(Guid riid);
}
internal class WinRT.Interop.ManagedWeakReferenceTypeDetails : object {
    public sealed virtual ComInterfaceEntry[] GetExposedInterfaces();
}
internal enum WinRT.Interop.MSHCTX : Enum {
    public int value__;
    public static MSHCTX Local;
    public static MSHCTX NoSharedMem;
    public static MSHCTX DifferentMachine;
    public static MSHCTX InProc;
    public static MSHCTX CrossCtx;
}
internal enum WinRT.Interop.MSHLFLAGS : Enum {
    public int value__;
    public static MSHLFLAGS Normal;
    public static MSHLFLAGS TableStrong;
    public static MSHLFLAGS TableWeak;
    public static MSHLFLAGS NoPing;
}
internal static class WinRT.Interop.Platform : object {
    public static int CoCreateInstance(Guid* clsid, IntPtr outer, UInt32 clsContext, Guid* iid, IntPtr* instance);
    public static int CoDecrementMTAUsage(IntPtr cookie);
    public static int CoIncrementMTAUsage(IntPtr* cookie);
    public static int RoGetActivationFactory(IntPtr runtimeClassId, Guid* iid, IntPtr* factory);
    public static int WindowsCreateString(UInt16* sourceString, int length, IntPtr* hstring);
    public static int WindowsCreateStringReference(UInt16* sourceString, int length, IntPtr* hstring_header, IntPtr* hstring);
    public static int WindowsDeleteString(IntPtr hstring);
    public static Char* WindowsGetStringRawBuffer(IntPtr hstring, UInt32* length);
    public static int RoGetAgileReference(UInt32 options, Guid* iid, IntPtr unknown, IntPtr* agileReference);
    public static int CoGetContextToken(IntPtr* contextToken);
    public static int CoGetObjectContext(Guid* riid, IntPtr* ppv);
    public static int SetErrorInfo(UInt32 dwReserved, IntPtr perrinfo);
    public static int CoCreateFreeThreadedMarshaler(IntPtr outer, IntPtr* marshalerPtr);
    public static bool FreeLibrary(IntPtr moduleHandle);
    public static IntPtr TryGetProcAddress(IntPtr moduleHandle, ReadOnlySpan`1<byte> functionName);
    public static IntPtr GetProcAddress(IntPtr moduleHandle, ReadOnlySpan`1<byte> functionName);
    public static IntPtr LoadLibraryExW(string fileName, IntPtr fileHandle, UInt32 flags);
}
[AttributeUsageAttribute("1036")]
internal class WinRT.Interop.WuxMuxProjectedTypeAttribute : Attribute {
}
public abstract class WinRT.IObjectReference : object {
    private static int NOT_DISPOSED;
    private static int DISPOSE_PENDING;
    private static int DISPOSE_COMPLETED;
    private IntPtr _thisPtr;
    private IntPtr _referenceTrackerPtr;
    private int _disposedFlags;
    [CompilerGeneratedAttribute]
private bool <IsAggregated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreventReleaseOnDispose>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreventReleaseFromTrackerSourceOnDispose>k__BackingField;
    public IntPtr ThisPtr { get; }
    public bool IsFreeThreaded { get; }
    public bool IsInCurrentContext { get; }
    private protected IntPtr ThisPtrFromOriginalContext { get; }
    internal bool IsAggregated { get; internal set; }
    internal bool PreventReleaseOnDispose { get; internal set; }
    internal bool PreventReleaseFromTrackerSourceOnDispose { get; internal set; }
    internal IntPtr ReferenceTrackerPtr { get; internal set; }
    internal IReferenceTrackerVftbl ReferenceTracker { get; }
    protected IUnknownVftbl VftblIUnknown { get; }
    private protected IUnknownVftbl VftblIUnknownFromOriginalContext { get; }
    internal bool IsReferenceToManagedObject { get; }
    protected IObjectReference(IntPtr thisPtr);
    public IntPtr get_ThisPtr();
    public bool get_IsFreeThreaded();
    public bool get_IsInCurrentContext();
    private protected IntPtr get_ThisPtrFromOriginalContext();
    [CompilerGeneratedAttribute]
internal bool get_IsAggregated();
    [CompilerGeneratedAttribute]
internal void set_IsAggregated(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PreventReleaseOnDispose();
    [CompilerGeneratedAttribute]
internal void set_PreventReleaseOnDispose(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PreventReleaseFromTrackerSourceOnDispose();
    [CompilerGeneratedAttribute]
internal void set_PreventReleaseFromTrackerSourceOnDispose(bool value);
    internal IntPtr get_ReferenceTrackerPtr();
    internal void set_ReferenceTrackerPtr(IntPtr value);
    internal IReferenceTrackerVftbl get_ReferenceTracker();
    protected IUnknownVftbl get_VftblIUnknown();
    private protected IUnknownVftbl get_VftblIUnknownFromOriginalContext();
    protected virtual override void Finalize();
    [RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
[ObsoleteAttribute("This method is deprecated and will be removed in a future release.")]
[EditorBrowsableAttribute("1")]
public ObjectReference`1<T> As();
    public ObjectReference`1<T> As(Guid iid);
    public TInterface AsInterface();
    [RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
[ObsoleteAttribute("This method is deprecated and will be removed in a future release.")]
[EditorBrowsableAttribute("1")]
public int TryAs(ObjectReference`1& objRef);
    public int TryAs(Guid iid, ObjectReference`1& objRef);
    public virtual ObjectReference`1<IUnknownVftbl> AsKnownPtr(IntPtr ptr);
    public virtual int TryAs(Guid iid, IntPtr& ppv);
    public IObjectReference As(Guid iid);
    [ObsoleteAttribute("This method is deprecated and will be removed in a future release.")]
[EditorBrowsableAttribute("1")]
public T AsType();
    public IntPtr GetRef();
    protected void ThrowIfDisposed();
    public sealed virtual void Dispose();
    protected virtual void AddRef(bool refFromTrackerSource);
    protected virtual void AddRef();
    protected virtual void Release();
    private protected void ReleaseWithoutContext();
    internal bool get_IsReferenceToManagedObject();
    internal void AddRefFromTrackerSource();
    internal void ReleaseFromTrackerSource();
    private void DisposeTrackerSource();
    private protected virtual IntPtr GetThisPtrForCurrentContext();
    private protected virtual IntPtr GetContextToken();
    public ObjectReferenceValue AsValue();
    public ObjectReferenceValue AsValue(Guid iid);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2090")]
internal static bool <AsType>g__TryCreateRcwFallback|45_0(IObjectReference objectReference, Object& rcwInstance);
    [CompilerGeneratedAttribute]
internal static void <ThrowIfDisposed>g__ThrowObjectDisposedException|47_0();
}
internal interface WinRT.IObjectReferenceWithContext {
}
public interface WinRT.IWinRTExposedTypeDetails {
    public abstract virtual ComInterfaceEntry[] GetExposedInterfaces();
}
internal interface WinRT.IWinRTNullableTypeDetails {
    public abstract virtual object GetNullableValue(IInspectable inspectable);
    public abstract virtual Type GetNullableType();
}
public interface WinRT.IWinRTObject {
    public IObjectReference NativeObject { get; }
    public bool HasUnwrappableNativeObject { get; }
    protected ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> QueryInterfaceCache { get; }
    public ConcurrentDictionary`2<RuntimeTypeHandle, object> AdditionalTypeData { get; }
    private sealed virtual override bool System.Runtime.InteropServices.IDynamicInterfaceCastable.IsInterfaceImplemented(RuntimeTypeHandle interfaceType, bool throwIfNotImplemented);
    internal bool IsInterfaceImplementedFallback(RuntimeTypeHandle interfaceType, bool throwIfNotImplemented);
    internal bool LookupGeneratedVTableInfo(RuntimeTypeHandle interfaceType, Nullable`1& result, Int32& qiResult);
    private sealed virtual override RuntimeTypeHandle System.Runtime.InteropServices.IDynamicInterfaceCastable.GetInterfaceImplementation(RuntimeTypeHandle interfaceType);
    private sealed virtual override VirtualMethodTableInfo System.Runtime.InteropServices.Marshalling.IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableInfoForKey(Type type);
    public abstract virtual IObjectReference get_NativeObject();
    public abstract virtual bool get_HasUnwrappableNativeObject();
    protected abstract virtual ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> get_QueryInterfaceCache();
    public virtual IObjectReference GetObjectReferenceForType(RuntimeTypeHandle type);
    internal IObjectReference GetObjectReferenceForTypeFallback(RuntimeTypeHandle type);
    public abstract virtual ConcurrentDictionary`2<RuntimeTypeHandle, object> get_AdditionalTypeData();
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
internal static IObjectReference <IsInterfaceImplementedFallback>g__GetObjectReferenceViaVftbl|1_1(IObjectReference objRef, Type vftblType);
}
internal static class WinRT.KeyValuePairHelper : object {
    internal static ConcurrentDictionary`2<Type, ComInterfaceEntry> KeyValuePairCCW;
    private static KeyValuePairHelper();
    internal static void TryAddKeyValuePairCCW(Type keyValuePairType, Guid iid, IntPtr abiToProjectionVftablePtr);
}
public class WinRT.MarshalBlittable`1 : ValueType {
    public static MarshalerArray<T> CreateMarshalerArray(Array array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static T[] FromAbiArray(object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(Array array);
    public static void CopyManagedArray(Array array, IntPtr data);
    public static void DisposeMarshalerArray(object box);
    public static void DisposeAbiArray(object box);
}
public static class WinRT.MarshalDelegate : object {
    public static IObjectReference CreateMarshaler(object o, Guid delegateIID, bool unwrapObject);
    public static ObjectReferenceValue CreateMarshaler2(object o, Guid delegateIID, bool unwrapObject);
    public static T FromAbi(IntPtr nativeDelegate);
}
internal static class WinRT.Marshaler : object {
    internal static Func`2<object, object> ReturnParameterFunc;
    internal static Action`2<object, IntPtr> CopyIntEnumFunc;
    internal static Action`2<object, IntPtr> CopyIntEnumDirectFunc;
    internal static Action`2<object, IntPtr> CopyUIntEnumFunc;
    internal static Action`2<object, IntPtr> CopyUIntEnumDirectFunc;
    private static Marshaler();
    private static object ReturnParameter(object arg);
    private static void CopyIntEnum(object value, IntPtr dest);
    private static void CopyIntEnumDirect(object value, IntPtr dest);
    private static void CopyUIntEnum(object value, IntPtr dest);
    private static void CopyUIntEnumDirect(object value, IntPtr dest);
}
public class WinRT.Marshaler`1 : object {
    public static Type AbiType;
    [ObsoleteAttribute("This method is deprecated and will be removed in a future release.")]
public static Type RefAbiType;
    public static Func`2<T, object> CreateMarshaler;
    internal static Func`2<T, object> CreateMarshaler2;
    public static Func`2<object, object> GetAbi;
    public static Action`2<object, IntPtr> CopyAbi;
    public static Func`2<object, T> FromAbi;
    public static Func`2<T, object> FromManaged;
    public static Action`2<T, IntPtr> CopyManaged;
    public static Action`1<object> DisposeMarshaler;
    public static Action`1<object> DisposeAbi;
    public static Func`2<T[], object> CreateMarshalerArray;
    public static Func`2<object, ValueTuple`2<int, IntPtr>> GetAbiArray;
    public static Func`2<object, T[]> FromAbiArray;
    public static Func`2<T[], ValueTuple`2<int, IntPtr>> FromManagedArray;
    public static Action`2<T[], IntPtr> CopyManagedArray;
    public static Action`1<object> DisposeMarshalerArray;
    public static Action`1<object> DisposeAbiArray;
    private static Marshaler`1();
}
[ExtensionAttribute]
internal static class WinRT.MarshalExtensions : object {
    [ExtensionAttribute]
public static void Dispose(GCHandle handle);
    [NullableContextAttribute("1")]
public static MethodInvoker TryGetMethodInvoker(Type helperType, string methodName);
}
public class WinRT.MarshalGeneric`1 : object {
    [DynamicallyAccessedMembersAttribute("8")]
protected static Type HelperType;
    protected static Type AbiType;
    protected static Type MarshalerType;
    internal static bool MarshalByObjectReferenceValueSupported;
    public static Func`2<T, object> CreateMarshaler;
    public static Func`2<object, object> GetAbi;
    public static Action`2<object, IntPtr> CopyAbi;
    public static Func`2<object, T> FromAbi;
    public static Func`2<T, object> FromManaged;
    public static Action`2<T, IntPtr> CopyManaged;
    public static Action`1<object> DisposeMarshaler;
    internal static Func`2<T, object> CreateMarshaler2;
    internal static Action`1<object> DisposeAbi;
    internal static Func`2<T[], object> CreateMarshalerArray;
    internal static Func`2<object, ValueTuple`2<int, IntPtr>> GetAbiArray;
    internal static Func`2<object, T[]> FromAbiArray;
    internal static Func`2<T[], ValueTuple`2<int, IntPtr>> FromManagedArray;
    internal static Action`1<object> DisposeMarshalerArray;
    internal static Action`1<object> DisposeAbiArray;
    private static MarshalGeneric`1();
}
internal class WinRT.MarshalGenericFallback`1 : object {
    private MethodInvoker _createMarshaler;
    private MethodInvoker _getAbi;
    private MethodInvoker _copyAbi;
    private MethodInvoker _fromAbi;
    private MethodInvoker _fromManaged;
    private MethodInvoker _copyManaged;
    private MethodInvoker _disposeMarshaler;
    private MethodInvoker _createMarshaler2;
    private MethodInvoker _disposeAbi;
    private MethodInvoker _createMarshalerArray;
    private MethodInvoker _getAbiArray;
    private MethodInvoker _fromAbiArray;
    private MethodInvoker _fromManagedArray;
    private MethodInvoker _disposeMarshalerArray;
    private MethodInvoker _disposeAbiArray;
    public MarshalGenericFallback`1(Type helperType);
    public object CreateMarshaler(T arg);
    public object CreateMarshaler2(T arg);
    public object GetAbi(object arg);
    public void CopyAbi(object arg, IntPtr dest);
    public T FromAbi(object arg);
    public object FromManaged(T arg);
    public void CopyManaged(T arg, IntPtr dest);
    public void DisposeMarshaler(object arg);
    public void DisposeAbi(object arg);
    public object CreateMarshalerArray(T[] arg);
    public ValueTuple`2<int, IntPtr> GetAbiArray(object arg);
    public T[] FromAbiArray(object arg);
    public ValueTuple`2<int, IntPtr> FromManagedArray(T[] arg);
    public void DisposeMarshalerArray(object arg);
    public void DisposeAbiArray(object arg);
}
internal static class WinRT.MarshalGenericHelper`1 : object {
    private static void CopyManagedFallback(T value, IntPtr dest);
    internal static void CopyManagedArray(T[] array, IntPtr data);
}
public static class WinRT.MarshalInspectable`1 : object {
    public static IObjectReference CreateMarshaler(T o, Guid iid, bool unwrapObject);
    public static IObjectReference CreateMarshaler(T o, bool unwrapObject);
    public static ObjectReferenceValue CreateMarshaler2(T o, Guid iid, bool unwrapObject);
    public static ObjectReferenceValue CreateMarshaler2(T o, bool unwrapObject);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr GetAbi(ObjectReferenceValue value);
    public static T FromAbi(IntPtr ptr);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeMarshaler(ObjectReferenceValue value);
    internal static void DisposeMarshaler(object value);
    public static void DisposeAbi(IntPtr ptr);
    public static IntPtr FromManaged(T o, bool unwrapObject);
    public static void CopyManaged(T o, IntPtr dest, bool unwrapObject);
    public static MarshalerArray<T> CreateMarshalerArray(T[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(T box);
    internal static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static T[] FromAbiArray(T box);
    internal static T[] FromAbiArray(object box);
    public static void CopyAbiArray(T[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(T[] array);
    public static void CopyManagedArray(T[] array, IntPtr data);
    public static void DisposeMarshalerArray(T box);
    public static void DisposeAbiArray(T box);
    internal static void DisposeMarshalerArray(object box);
    internal static void DisposeAbiArray(object box);
}
public class WinRT.MarshalInterface`1 : ValueType {
    [DynamicallyAccessedMembersAttribute("40")]
private static Type _HelperType;
    private static object _CreateMarshaler;
    private static object _Iid;
    [DynamicallyAccessedMembersAttribute("40")]
private static Type HelperType { get; }
    private static Guid IID { get; }
    private static Type get_HelperType();
    private static Guid get_IID();
    private static Guid GetIID();
    public static T FromAbi(IntPtr ptr);
    public static IObjectReference CreateMarshaler(T value);
    public static ObjectReferenceValue CreateMarshaler2(T value, Guid iid);
    public static IntPtr GetAbi(IObjectReference value);
    public static IntPtr GetAbi(ObjectReferenceValue value);
    public static void DisposeAbi(IntPtr thisPtr);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeMarshaler(ObjectReferenceValue value);
    internal static void DisposeMarshaler(object value);
    public static IntPtr FromManaged(T value);
    public static void CopyManaged(T value, IntPtr dest);
    public static MarshalerArray<T> CreateMarshalerArray(T[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static T[] FromAbiArray(object box);
    public static void CopyAbiArray(T[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(T[] array);
    public static void CopyManagedArray(T[] array, IntPtr data);
    public static void DisposeMarshalerArray(object box);
    public static void DisposeAbiArray(object box);
    private static IObjectReference CreateMarshalerCore(T value);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
private static Func`2<T, IObjectReference> BindCreateMarshaler();
}
public class WinRT.MarshalInterfaceHelper`1 : object {
    private static MarshalerArray<T> CreateMarshalerArray(T[] array, Func`2<T, IObjectReference> createMarshaler, Func`2<T, ObjectReferenceValue> createMarshaler2);
    public static MarshalerArray<T> CreateMarshalerArray(T[] array, Func`2<T, IObjectReference> createMarshaler);
    public static MarshalerArray<T> CreateMarshalerArray2(T[] array, Func`2<T, ObjectReferenceValue> createMarshaler);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static T[] FromAbiArray(object box, Func`2<IntPtr, T> fromAbi);
    public static void CopyAbiArray(T[] array, object box, Func`2<IntPtr, T> fromAbi);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(T[] array, Func`2<T, IntPtr> fromManaged);
    public static void CopyManagedArray(T[] array, IntPtr data, Action`2<T, IntPtr> copyManaged);
    public static void DisposeMarshalerArray(object box);
    public static void DisposeAbiArrayElements(ValueTuple`2<int, IntPtr> abi);
    public static void DisposeAbiArray(object box);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr GetAbi(ObjectReferenceValue value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeMarshaler(ObjectReferenceValue value);
    public static void DisposeAbi(IntPtr ptr);
}
public class WinRT.MarshalNonBlittable`1 : MarshalGeneric`1<T> {
    private static Type AbiType;
    private static MarshalNonBlittable`1();
    private static Type GetAbiType();
    public static MarshalerArray<T> CreateMarshalerArray(T[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static T[] FromAbiArray(object box);
    public static void CopyAbiArray(T[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(T[] array);
    public static void CopyManagedArray(T[] array, IntPtr data);
    public static void DisposeMarshalerArray(object box);
    public static void DisposeAbiArrayElements(ValueTuple`2<int, IntPtr> abi);
    public static void DisposeAbiArray(object box);
}
public class WinRT.MarshalString : object {
    private IntPtr _header;
    private GCHandle _gchandle;
    public MarshalString(string value);
    public static Pinnable CreatePinnable(string value);
    public static IntPtr GetAbi(Pinnable& p);
    public void Dispose();
    public static MarshalString CreateMarshaler(string value);
    public IntPtr GetAbi();
    public static IntPtr GetAbi(MarshalString m);
    public static IntPtr GetAbi(object box);
    public static void DisposeMarshaler(MarshalString m);
    public static void DisposeMarshaler(object box);
    public static void DisposeAbi(IntPtr hstring);
    public static void DisposeAbi(object abi);
    public static string FromAbi(IntPtr value);
    public static ReadOnlySpan`1<char> FromAbiUnsafe(IntPtr value);
    public static IntPtr FromManaged(string value);
    public static MarshalerArray CreateMarshalerArray(String[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static String[] FromAbiArray(object box);
    public static void CopyAbiArray(String[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(String[] array);
    public static void CopyManagedArray(String[] array, IntPtr data);
    public static void DisposeMarshalerArray(object box);
    public static void DisposeAbiArrayElements(ValueTuple`2<int, IntPtr> abi);
    public static void DisposeAbiArray(object box);
}
internal static class WinRT.Mono : object {
    private static Lazy`1<bool> _usingMono;
    private static Mono();
    private static IntPtr mono_thread_current();
    private static bool mono_thread_is_foreign(IntPtr threadPtr);
    private static void mono_unity_thread_fast_attach(IntPtr domainPtr);
    private static void mono_unity_thread_fast_detach();
    private static void mono_thread_pop_appdomain_ref();
    private static IntPtr mono_domain_get();
}
public class WinRT.ObjectReference`1 : IObjectReference {
    private T _vftbl;
    public T Vftbl { get; }
    private protected ObjectReference`1(IntPtr thisPtr, T vftblT);
    private protected ObjectReference`1(IntPtr thisPtr);
    public T get_Vftbl();
    [RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
[ObsoleteAttribute("This method is deprecated and will be removed in a future release.")]
[EditorBrowsableAttribute("1")]
public static ObjectReference`1<T> Attach(IntPtr& thisPtr);
    public static ObjectReference`1<T> Attach(IntPtr& thisPtr, Guid iid);
    [RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
[ObsoleteAttribute("This method is deprecated and will be removed in a future release.")]
[EditorBrowsableAttribute("1")]
public static ObjectReference`1<T> FromAbi(IntPtr thisPtr, T vftblT);
    public static ObjectReference`1<T> FromAbi(IntPtr thisPtr, T vftblT, Guid iid);
    [RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
[ObsoleteAttribute("This method is deprecated and will be removed in a future release.")]
[EditorBrowsableAttribute("1")]
public static ObjectReference`1<T> FromAbi(IntPtr thisPtr);
    public static ObjectReference`1<T> FromAbi(IntPtr thisPtr, Guid iid);
    private static T GetVtable(IntPtr thisPtr);
    private protected virtual T GetVftblForCurrentContext();
    internal static int TryAs(IObjectReference sourceRef, Guid iid, ObjectReference`1& objRef);
}
[IsReadOnlyAttribute]
public class WinRT.ObjectReferenceValue : ValueType {
    internal IntPtr ptr;
    internal IntPtr referenceTracker;
    internal bool preventReleaseOnDispose;
    internal IObjectReference objRef;
    internal ObjectReferenceValue(IntPtr ptr);
    internal ObjectReferenceValue(IntPtr ptr, IntPtr referenceTracker, bool preventReleaseOnDispose, IObjectReference objRef);
    public static ObjectReferenceValue Attach(IntPtr& thisPtr);
    public IntPtr GetAbi();
    public IntPtr Detach();
    public void Dispose();
}
internal class WinRT.ObjectReferenceWithContext`1 : ObjectReference`1<T> {
    private IntPtr _contextCallbackPtr;
    private IntPtr _contextToken;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) __cachedContext;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isAgileReferenceSet;
    private AgileReference modreq(System.Runtime.CompilerServices.IsVolatile) __agileReference;
    private Guid _iid;
    private ConcurrentDictionary`2<IntPtr, IObjectReference> CachedContext { get; }
    private AgileReference AgileReference { get; }
    [RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
[ObsoleteAttribute("This method is deprecated and will be removed in a future release.")]
[EditorBrowsableAttribute("1")]
internal ObjectReferenceWithContext`1(IntPtr thisPtr, IntPtr contextCallbackPtr, IntPtr contextToken);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
internal ObjectReferenceWithContext`1(IntPtr thisPtr, IntPtr contextCallbackPtr, IntPtr contextToken, Guid iid);
    [RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
[ObsoleteAttribute("This method is deprecated and will be removed in a future release.")]
[EditorBrowsableAttribute("1")]
internal ObjectReferenceWithContext`1(IntPtr thisPtr, T vftblT, IntPtr contextCallbackPtr, IntPtr contextToken);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
internal ObjectReferenceWithContext`1(IntPtr thisPtr, T vftblT, IntPtr contextCallbackPtr, IntPtr contextToken, Guid iid);
    private ConcurrentDictionary`2<IntPtr, IObjectReference> get_CachedContext();
    private ConcurrentDictionary`2<IntPtr, IObjectReference> Make_CachedContext();
    private AgileReference get_AgileReference();
    private AgileReference Make_AgileReference();
    private protected virtual IntPtr GetThisPtrForCurrentContext();
    private protected virtual IntPtr GetContextToken();
    private protected virtual T GetVftblForCurrentContext();
    private ObjectReference`1<T> GetCurrentContext();
    protected virtual void Release();
    private void ReleaseFromBase();
    public virtual ObjectReference`1<IUnknownVftbl> AsKnownPtr(IntPtr ptr);
    internal static int TryAs(IObjectReference sourceRef, Guid iid, ObjectReference`1& objRef);
    [CompilerGeneratedAttribute]
internal static void <Make_AgileReference>g__InitAgileReference|10_0(object state);
    [CompilerGeneratedAttribute]
internal static void <Release>g__Release|21_0(object state);
    [CompilerGeneratedAttribute]
internal static void <Release>g__ReleaseWithoutContext|21_1(object state);
}
internal static class WinRT.ObjectReferenceWithContextHelper : object {
    public static void ThrowArgumentExceptionForEmptyIid();
}
[ObsoleteAttribute("This attribute is only used for the .NET Standard 2.0 projections.")]
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("4")]
public class WinRT.ObjectReferenceWrapperAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ObjectReferenceField>k__BackingField;
    public string ObjectReferenceField { get; }
    public ObjectReferenceWrapperAttribute(string objectReferenceField);
    [CompilerGeneratedAttribute]
public string get_ObjectReferenceField();
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("4")]
public class WinRT.ProjectedRuntimeClassAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DefaultInterfaceProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DefaultInterface>k__BackingField;
    public string DefaultInterfaceProperty { get; }
    public Type DefaultInterface { get; }
    public ProjectedRuntimeClassAttribute(string defaultInterfaceProp);
    public ProjectedRuntimeClassAttribute(Type defaultInterface);
    [CompilerGeneratedAttribute]
public string get_DefaultInterfaceProperty();
    [CompilerGeneratedAttribute]
public Type get_DefaultInterface();
}
internal static class WinRT.ProjectionInitializer : object {
    [ModuleInitializerAttribute]
public static void InitalizeProjection();
}
public static class WinRT.Projections : object {
    private static ReaderWriterLockSlim rwlock;
    private static Dictionary`2<Type, Type> CustomTypeToHelperTypeMappings;
    private static Dictionary`2<Type, Type> CustomAbiTypeToTypeMappings;
    private static Dictionary`2<string, Type> CustomAbiTypeNameToTypeMappings;
    private static Dictionary`2<Type, string> CustomTypeToAbiTypeNameMappings;
    private static HashSet`1<string> ProjectedRuntimeClassNames;
    private static HashSet`1<Type> ProjectedCustomTypeRuntimeClasses;
    private static ConcurrentDictionary`2<Type, bool> IsTypeWindowsRuntimeTypeCache;
    private static ConcurrentDictionary`2<Type, Type> DefaultInterfaceTypeCache;
    private static int _EventHandler;
    private static int _NotifyCollectionChangedEventHandler;
    private static int _PropertyChangedEventHandler;
    [NullableAttribute("2")]
private static ComInterfaceEntry[] _AbiEventHandlerExposedInterfaces;
    [NullableAttribute("2")]
private static ComInterfaceEntry[] _AbiNotifyCollectionChangedEventHandlerExposedInterfaces;
    [NullableAttribute("2")]
private static ComInterfaceEntry[] _AbiPropertyChangedEventHandlerExposedInterfaces;
    private static int _EventRegistrationToken;
    private static int _Nullable__;
    private static int _int_;
    private static int _byte_;
    private static int _sbyte_;
    private static int _short_;
    private static int _ushort_;
    private static int _uint_;
    private static int _long_;
    private static int _ulong_;
    private static int _float_;
    private static int _double_;
    private static int _char_;
    private static int _bool_;
    private static int _Guid_;
    private static int _DateTimeOffset_;
    private static int _TimeSpan_;
    private static int _DateTimeOffset;
    private static int _Exception;
    private static int _TimeSpan;
    private static int _Uri;
    private static int _DataErrorsChangedEventArgs;
    private static int _PropertyChangedEventArgs;
    private static int _INotifyDataErrorInfo;
    private static int _INotifyPropertyChanged;
    private static int _ICommand;
    private static int _IServiceProvider;
    private static int _EventHandler__;
    private static int _KeyValuePair___;
    private static int _IEnumerable__;
    private static int _IEnumerator__;
    private static int _IList__;
    private static int _IReadOnlyList__;
    private static int _IDictionary___;
    private static int _IReadOnlyDictionary___;
    private static int _IDisposable;
    private static int _IEnumerable;
    private static int _IList;
    private static int _INotifyCollectionChanged;
    private static int _NotifyCollectionChangedAction;
    private static int _NotifyCollectionChangedEventArgs;
    private static int _Matrix3x2;
    private static int _Matrix4x4;
    private static int _Plane;
    private static int _Quaternion;
    private static int _Vector2;
    private static int _Vector3;
    private static int _Vector4;
    private static int _IMap___;
    private static int _IVector__;
    private static int _IMapView___;
    private static int _IVectorView__;
    private static int _IBindableVector;
    private static int _ICollection__;
    private static int _IReadOnlyCollection__;
    private static int _ICollection;
    private static Projections();
    private static void RegisterCustomAbiTypeMapping(Type publicType, Type abiType, string winrtTypeName, bool isRuntimeClass);
    private static void RegisterCustomTypeToHelperTypeMapping(Type publicType, Type helperType);
    private static void RegisterCustomTypeToHelperTypeMappingNoLock(Type publicType, Type helperType);
    private static void RegisterCustomAbiTypeMappingNoLock(Type publicType, Type abiType, string winrtTypeName, bool isRuntimeClass);
    private static void RegisterCustomAbiTypeMapping(Type publicType, Type abiType);
    private static void RegisterCustomAbiTypeMappingNoLock(Type publicType, Type abiType);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2055")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2068")]
public static Type FindCustomHelperTypeMapping(Type publicType, bool filterToRuntimeClass);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2055")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2068")]
internal static Type FindCustomHelperTypeMapping(Type publicType, bool filterToRuntimeClass, bool returnMarkerTypeIfNotAotCompatible);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2055")]
public static Type FindCustomPublicTypeForAbiType(Type abiType);
    public static Type FindCustomTypeForAbiTypeName(string abiTypeName);
    public static string FindCustomAbiTypeNameForType(Type type);
    public static bool IsTypeWindowsRuntimeType(Type type);
    private static bool IsTypeWindowsRuntimeTypeNoArray(Type type);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2055")]
public static bool TryGetCompatibleWindowsRuntimeTypeForVariantType(Type type, Type& compatibleType);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
private static HashSet`1<Type> GetCompatibleTypes(Type type, Stack`1<Type> typeStack);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
internal static IEnumerable`1<Type> GetAllPossibleTypeCombinations(IEnumerable`1<IEnumerable`1<Type>> compatibleTypesPerGeneric, Type definition);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
internal static bool TryGetCompatibleWindowsRuntimeTypesForVariantType(Type type, Stack`1<Type> typeStack, IEnumerable`1& compatibleTypes);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2070")]
internal static bool TryGetDefaultInterfaceTypeForRuntimeClassType(Type runtimeClass, Type& defaultInterface);
    internal static Type GetDefaultInterfaceTypeForRuntimeClassType(Type runtimeClass);
    [RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
internal static Type GetAbiDelegateType(Type[] typeArgs);
    public static void RegisterEventHandlerMapping();
    [NullableContextAttribute("1")]
internal static ComInterfaceEntry[] GetAbiEventHandlerExposedInterfaces();
    public static void RegisterNotifyCollectionChangedEventHandlerMapping();
    [NullableContextAttribute("1")]
internal static ComInterfaceEntry[] GetAbiNotifyCollectionChangedEventHandlerExposedInterfaces();
    public static void RegisterPropertyChangedEventHandlerMapping();
    [NullableContextAttribute("1")]
internal static ComInterfaceEntry[] GetAbiPropertyChangedEventHandlerExposedInterfaces();
    public static void RegisterEventRegistrationTokenMapping();
    public static void RegisterNullableOpenGenericMapping();
    public static void RegisterNullableIntMapping();
    public static void RegisterNullableByteMapping();
    public static void RegisterNullableSByteMapping();
    public static void RegisterNullableShortMapping();
    public static void RegisterNullableUShortMapping();
    public static void RegisterNullableUIntMapping();
    public static void RegisterNullableLongMapping();
    public static void RegisterNullableULongMapping();
    public static void RegisterNullableFloatMapping();
    public static void RegisterNullableDoubleMapping();
    public static void RegisterNullableCharMapping();
    public static void RegisterNullableBoolMapping();
    public static void RegisterNullableGuidMapping();
    public static void RegisterNullableDateTimeOffsetMapping();
    public static void RegisterNullableTimeSpanMapping();
    public static void RegisterDateTimeOffsetMapping();
    public static void RegisterExceptionMapping();
    public static void RegisterTimeSpanMapping();
    public static void RegisterUriMapping();
    public static void RegisterDataErrorsChangedEventArgsMapping();
    public static void RegisterPropertyChangedEventArgsMapping();
    public static void RegisterINotifyDataErrorInfoMapping();
    public static void RegisterINotifyPropertyChangedMapping();
    public static void RegisterICommandMapping();
    public static void RegisterIServiceProviderMapping();
    public static void RegisterEventHandlerOpenGenericMapping();
    public static void RegisterKeyValuePairOpenGenericMapping();
    public static void RegisterIEnumerableOpenGenericMapping();
    public static void RegisterIEnumeratorOpenGenericMapping();
    public static void RegisterIListOpenGenericMapping();
    public static void RegisterIReadOnlyListOpenGenericMapping();
    public static void RegisterIDictionaryOpenGenericMapping();
    public static void RegisterIReadOnlyDictionaryOpenGenericMapping();
    public static void RegisterIDisposableMapping();
    public static void RegisterIEnumerableMapping();
    public static void RegisterIListMapping();
    public static void RegisterINotifyCollectionChangedMapping();
    public static void RegisterNotifyCollectionChangedActionMapping();
    public static void RegisterNotifyCollectionChangedEventArgsMapping();
    public static void RegisterMatrix3x2Mapping();
    public static void RegisterMatrix4x4Mapping();
    public static void RegisterPlaneMapping();
    public static void RegisterQuaternionMapping();
    public static void RegisterVector2Mapping();
    public static void RegisterVector3Mapping();
    public static void RegisterVector4Mapping();
    public static void RegisterIMapOpenGenericMapping();
    public static void RegisterIVectorOpenGenericMapping();
    public static void RegisterIMapViewOpenGenericMapping();
    public static void RegisterIVectorViewOpenGenericMapping();
    public static void RegisterIBindableVectorMapping();
    public static void RegisterICollectionOpenGenericMapping();
    public static void RegisterIReadOnlyCollectionOpenGenericMapping();
    public static void RegisterICollectionMapping();
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2055")]
internal static void <GetAllPossibleTypeCombinations>g__GetAllPossibleTypeCombinationsCore|24_0(List`1<Type> accum, Stack`1<Type> stack, IEnumerable`1[] compatibleTypes, int index, <>c__DisplayClass24_0& );
}
public class WinRT.SingleInterfaceOptimizedObject : object {
    private Type _type;
    private IObjectReference _obj;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    public SingleInterfaceOptimizedObject(Type type, IObjectReference objRef);
    internal SingleInterfaceOptimizedObject(Type type, IObjectReference objRef, bool requireQI);
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    private sealed virtual override bool System.Runtime.InteropServices.IDynamicInterfaceCastable.IsInterfaceImplemented(RuntimeTypeHandle interfaceType, bool throwIfNotImplemented);
    private sealed virtual override IObjectReference WinRT.IWinRTObject.GetObjectReferenceForType(RuntimeTypeHandle interfaceType);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
internal static IObjectReference <.ctor>g__TryGetObjectReferenceViaVftbl|3_0(IObjectReference objRef, Type helperType);
}
public class WinRT.StructTypeDetails`2 : object {
    private static Guid PIID;
    private static StructTypeDetails`2();
    [SkipLocalsInitAttribute]
public sealed virtual ComInterfaceEntry[] GetExposedInterfaces();
    private sealed virtual override object WinRT.IWinRTNullableTypeDetails.GetNullableValue(IInspectable inspectable);
    private sealed virtual override Type WinRT.IWinRTNullableTypeDetails.GetNullableType();
}
public enum WinRT.TrustLevel : Enum {
    public int value__;
    public static TrustLevel BaseTrust;
    public static TrustLevel PartialTrust;
    public static TrustLevel FullTrust;
}
[ExtensionAttribute]
public static class WinRT.TypeExtensions : object {
    internal static ConcurrentDictionary`2<Type, Type> HelperTypeCache;
    private static ConcurrentDictionary`2<Type, Type> AuthoringMetadataTypeCache;
    private static List`1<Func`2<Type, Type>> AuthoringMetadaTypeLookup;
    private static TypeExtensions();
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2073")]
public static Type FindHelperType(Type type);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2073")]
internal static Type FindHelperType(Type type, bool throwIfNotAotSupported);
    [ExtensionAttribute]
public static Type GetHelperType(Type type);
    [ExtensionAttribute]
public static Type GetGuidType(Type type);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("AOT", "IL3050")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
public static Type FindVftblType(Type helperType);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2075")]
internal static IntPtr GetAbiToProjectionVftblPtr(Type helperType);
    [ExtensionAttribute]
public static Type GetAbiType(Type type);
    [ExtensionAttribute]
public static Type GetMarshalerType(Type type);
    [ExtensionAttribute]
internal static Type GetMarshaler2Type(Type type);
    [ExtensionAttribute]
internal static Type GetMarshalerArrayType(Type type);
    [ExtensionAttribute]
public static bool IsDelegate(Type type);
    [ExtensionAttribute]
internal static bool IsNullableT(Type type);
    [ExtensionAttribute]
internal static bool IsAbiNullableDelegate(Type type);
    [ExtensionAttribute]
internal static bool IsIReferenceArray(Type type);
    [ExtensionAttribute]
internal static bool ShouldProvideIReference(Type type);
    [ExtensionAttribute]
internal static bool IsTypeOfType(Type type);
    [ExtensionAttribute]
internal static bool IsTypeOfException(Type type);
    [ExtensionAttribute]
public static Type GetRuntimeClassCCWType(Type type);
    [ExtensionAttribute]
internal static Type GetCCWType(Type type);
    internal static void RegisterAuthoringMetadataTypeLookup(Func`2<Type, Type> authoringMetadataTypeLookup);
    [ExtensionAttribute]
internal static Type GetAuthoringMetadataType(Type type);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026:RequiresUnreferencedCode")]
private static Type GetAuthoringMetadataTypeFallback(Type type);
    [CompilerGeneratedAttribute]
internal static Type <FindHelperType>g__FindHelperTypeNoCache|2_0(Type type);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2055")]
internal static Type <FindHelperType>g__GetHelperTypeFromAttribute|2_1(WindowsRuntimeHelperTypeAttribute helperTypeAtribute, Type type);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2057")]
internal static Type <FindHelperType>g__FindHelperTypeFallback|2_2(Type type);
    [CompilerGeneratedAttribute]
[RequiresDynamicCodeAttribute("The necessary marshalling code or generic instantiations might not be available.")]
[DynamicDependencyAttribute("-1", "ABI.Windows.Foundation.IAsyncActionWithProgress`1+Vftbl", "Microsoft.Windows.SDK.NET")]
[DynamicDependencyAttribute("-1", "ABI.Windows.Foundation.IAsyncOperationWithProgress`2+Vftbl", "Microsoft.Windows.SDK.NET")]
[DynamicDependencyAttribute("-1", "ABI.Windows.Foundation.IAsyncOperation`1+Vftbl", "Microsoft.Windows.SDK.NET")]
[DynamicDependencyAttribute("-1", "ABI.Windows.Foundation.Collections.IMapChangedEventArgs`1+Vftbl", "Microsoft.Windows.SDK.NET")]
[DynamicDependencyAttribute("-1", "ABI.Windows.Foundation.Collections.IObservableMap`2+Vftbl", "Microsoft.Windows.SDK.NET")]
[DynamicDependencyAttribute("-1", "ABI.Windows.Foundation.Collections.IObservableVector`1+Vftbl", "Microsoft.Windows.SDK.NET")]
[DynamicDependencyAttribute("-1", "ABI.System.EventHandler`1+Vftbl", "WinRT.Runtime")]
[DynamicDependencyAttribute("-1", "ABI.System.Collections.Generic.KeyValuePair`2+Vftbl", "WinRT.Runtime")]
[DynamicDependencyAttribute("-1", "ABI.System.Collections.Generic.IEnumerable`1+Vftbl", "WinRT.Runtime")]
[DynamicDependencyAttribute("-1", "ABI.System.Collections.Generic.IEnumerator`1+Vftbl", "WinRT.Runtime")]
[DynamicDependencyAttribute("-1", "ABI.System.Collections.Generic.IList`1+Vftbl", "WinRT.Runtime")]
[DynamicDependencyAttribute("-1", "ABI.System.Collections.Generic.IReadOnlyList`1+Vftbl", "WinRT.Runtime")]
[DynamicDependencyAttribute("-1", "ABI.System.Collections.Generic.IDictionary`2+Vftbl", "WinRT.Runtime")]
[DynamicDependencyAttribute("-1", "ABI.System.Collections.Generic.IReadOnlyDictionary`2+Vftbl", "WinRT.Runtime")]
[RequiresUnreferencedCodeAttribute("This method is not trim-safe, and is only supported for use when not using trimming (or AOT).")]
internal static Type <FindVftblType>g__FindVftblTypeFallback|5_0(Type helperType);
}
[FlagsAttribute]
internal enum WinRT.TypeNameGenerationFlags : Enum {
    public int value__;
    public static TypeNameGenerationFlags None;
    public static TypeNameGenerationFlags GenerateBoxedName;
    public static TypeNameGenerationFlags ForGetRuntimeClassName;
}
internal static class WinRT.TypeNameSupport : object {
    private static List`1<Assembly> projectionAssemblies;
    private static List`1<IDictionary`2<string, string>> projectionTypeNameToBaseTypeNameMappings;
    private static ConcurrentDictionary`2<string, Type> typeNameCache;
    private static ConcurrentDictionary`2<string, Type> baseRcwTypeCache;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static Stack`1<VisitedType> visitedTypesInstance;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static StringBuilder nameForTypeBuilderInstance;
    private static TypeNameSupport();
    public static void RegisterProjectionAssembly(Assembly assembly);
    public static void RegisterProjectionTypeBaseTypeMapping(IDictionary`2<string, string> typeNameToBaseTypeNameMapping);
    public static Type FindRcwTypeByNameCached(string runtimeClassName);
    public static Type FindTypeByNameCached(string runtimeClassName);
    private static Exception GetExceptionForUnsupportedIReferenceType(ReadOnlySpan`1<char> runtimeClassName);
    public static ValueTuple`2<Type, int> FindTypeByName(ReadOnlySpan`1<char> runtimeClassName);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
private static Type FindTypeByNameCore(string runtimeClassName, Type[] genericTypes);
    public static Type ResolvePrimitiveType(string primitiveTypeName);
    private static ValueTuple`3<string, Type[], int> ParseGenericTypeName(ReadOnlySpan`1<char> partialTypeName);
    [NullableContextAttribute("1")]
public static string GetNameForType(Type type, TypeNameGenerationFlags flags);
    private static bool TryAppendSimpleTypeName(Type type, StringBuilder builder, TypeNameGenerationFlags flags);
    private static bool TryAppendWinRTInterfaceNameForType(Type type, StringBuilder builder, TypeNameGenerationFlags flags);
    private static bool TryAppendTypeName(Type type, StringBuilder builder, TypeNameGenerationFlags flags);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2055")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3050")]
internal static Type <FindTypeByNameCore>g__ResolveGenericType|10_0(Type resolvedType, Type[] genericTypes, string runtimeClassName);
    [CompilerGeneratedAttribute]
internal static bool <TryAppendWinRTInterfaceNameForType>g__HasAnyVisitedTypes|18_0(Stack`1<VisitedType> visitedTypes, Type type);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2070")]
internal static bool <TryAppendWinRTInterfaceNameForType>g__TryAppendWinRTInterfaceNameForTypeJit|18_1(Type type, StringBuilder builder, TypeNameGenerationFlags flags);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("5148")]
public class WinRT.WindowsRuntimeHelperTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <HelperType>k__BackingField;
    [DynamicallyAccessedMembersAttribute("40")]
public Type HelperType { get; }
    public WindowsRuntimeHelperTypeAttribute(Type helperType);
    [CompilerGeneratedAttribute]
public Type get_HelperType();
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("5148")]
public class WinRT.WindowsRuntimeTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <SourceMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GuidSignature>k__BackingField;
    public string SourceMetadata { get; }
    public string GuidSignature { get; }
    public WindowsRuntimeTypeAttribute(string sourceMetadata);
    public WindowsRuntimeTypeAttribute(string sourceMetadata, string guidSignature);
    [CompilerGeneratedAttribute]
public string get_SourceMetadata();
    [CompilerGeneratedAttribute]
public string get_GuidSignature();
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("1")]
public class WinRT.WinRTAssemblyExportsTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public WinRTAssemblyExportsTypeAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("5148")]
public class WinRT.WinRTExposedTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <WinRTExposedTypeDetails>k__BackingField;
    [DynamicallyAccessedMembersAttribute("1")]
internal Type WinRTExposedTypeDetails { get; }
    public WinRTExposedTypeAttribute(Type winrtExposedTypeDetails);
    public ComInterfaceEntry[] GetExposedInterfaces();
    [CompilerGeneratedAttribute]
internal Type get_WinRTExposedTypeDetails();
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("4")]
public abstract class WinRT.WinRTImplementationTypeRcwFactoryAttribute : Attribute {
    public abstract virtual object CreateInstance(IInspectable inspectable);
}
internal class WinRT.WinRTModule : object {
    private static WinRTModule modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    private IntPtr _mtaCookie;
    public static WinRTModule Instance { get; }
    private static WinRTModule MakeWinRTModule();
    public static WinRTModule get_Instance();
    public static ValueTuple`2<ObjectReference`1<I>, int> GetActivationFactory(string runtimeClassId, Guid iid);
    protected virtual override void Finalize();
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("4")]
public class WinRT.WinRTRuntimeClassNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <RuntimeClassName>k__BackingField;
    public string RuntimeClassName { get; }
    public WinRTRuntimeClassNameAttribute(string runtimeClassName);
    [CompilerGeneratedAttribute]
public string get_RuntimeClassName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class WinRT.WinRTRuntimeErrorStrings : object {
    [NullableAttribute("2")]
private static ResourceManager s_resourceManager;
    private static ResourceManager ResourceManager { get; }
    internal static string Arg_IndexOutOfRangeException { get; }
    internal static string Arg_KeyNotFound { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_AddingDuplicateWithKey { get; }
    internal static string Argument_IndexOutOfArrayBounds { get; }
    internal static string Argument_InsufficientSpaceToCopyCollection { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_IndexLargerThanMaxValue { get; }
    internal static string InvalidOperation_CannotRemoveLastFromEmptyCollection { get; }
    internal static string InvalidOperation_CollectionBackingDictionaryTooLarge { get; }
    internal static string InvalidOperation_CollectionBackingListTooLarge { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    private static ResourceManager get_ResourceManager();
    internal static string get_Arg_IndexOutOfRangeException();
    internal static string get_Arg_KeyNotFound();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_AddingDuplicateWithKey();
    internal static string get_Argument_IndexOutOfArrayBounds();
    internal static string get_Argument_InsufficientSpaceToCopyCollection();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_IndexLargerThanMaxValue();
    internal static string get_InvalidOperation_CannotRemoveLastFromEmptyCollection();
    internal static string get_InvalidOperation_CollectionBackingDictionaryTooLarge();
    internal static string get_InvalidOperation_CollectionBackingListTooLarge();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_ValueCollectionSet();
    private static string GetResourceString(string resourceKey);
}
