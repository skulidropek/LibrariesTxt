public class Antlr4.Runtime.AntlrFileStream : AntlrInputStream {
    protected internal string fileName;
    public string SourceName { get; }
    public AntlrFileStream(string fileName);
    public AntlrFileStream(string fileName, Encoding encoding);
    public virtual void Load(string fileName, Encoding encoding);
    public virtual string get_SourceName();
}
public class Antlr4.Runtime.AntlrInputStream : object {
    public static int ReadBufferSize;
    public static int InitialBufferSize;
    protected internal Char[] data;
    protected internal int n;
    protected internal int p;
    public string name;
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public AntlrInputStream(string input);
    public AntlrInputStream(Char[] data, int numberOfActualCharsInArray);
    public AntlrInputStream(TextReader r);
    public AntlrInputStream(TextReader r, int initialSize);
    public AntlrInputStream(TextReader r, int initialSize, int readChunkSize);
    public AntlrInputStream(Stream input);
    public AntlrInputStream(Stream input, int initialSize);
    public AntlrInputStream(Stream input, int initialSize, int readChunkSize);
    public virtual void Load(TextReader r, int size, int readChunkSize);
    public virtual void Reset();
    public virtual void Consume();
    public virtual int La(int i);
    public virtual int Lt(int i);
    public virtual int get_Index();
    public virtual int get_Size();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Seek(int index);
    public virtual string GetText(Interval interval);
    public virtual string get_SourceName();
    public virtual string ToString();
}
public abstract class Antlr4.Runtime.Atn.AbstractPredicateTransition : Transition {
    public AbstractPredicateTransition(ATNState target);
}
public class Antlr4.Runtime.Atn.ActionTransition : Transition {
    public int ruleIndex;
    public int actionIndex;
    public bool isCtxDependent;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public ActionTransition(ATNState target, int ruleIndex);
    public ActionTransition(ATNState target, int ruleIndex, int actionIndex, bool isCtxDependent);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.AmbiguityInfo : DecisionEventInfo {
    public AmbiguityInfo(int decision, SimulatorState state, ITokenStream input, int startIndex, int stopIndex);
}
public class Antlr4.Runtime.Atn.ArrayPredictionContext : PredictionContext {
    [NotNullAttribute]
public PredictionContext[] parents;
    [NotNullAttribute]
public Int32[] returnStates;
    public int Size { get; }
    public bool IsEmpty { get; }
    public bool HasEmpty { get; }
    internal ArrayPredictionContext(PredictionContext[] parents, Int32[] returnStates);
    internal ArrayPredictionContext(PredictionContext[] parents, Int32[] returnStates, int hashCode);
    public virtual PredictionContext GetParent(int index);
    public virtual int GetReturnState(int index);
    public virtual int FindReturnState(int returnState);
    public virtual int get_Size();
    public virtual bool get_IsEmpty();
    public virtual bool get_HasEmpty();
    protected internal virtual PredictionContext AddEmptyContext();
    protected internal virtual PredictionContext RemoveEmptyContext();
    public virtual PredictionContext AppendContext(PredictionContext suffix, PredictionContextCache contextCache);
    private static PredictionContext AppendContext(PredictionContext context, PredictionContext suffix, IdentityHashMap visited);
    public virtual bool Equals(object o);
    private bool Equals(ArrayPredictionContext other, HashSet`1<IdentityCommutativePredictionContextOperands> visited);
}
public class Antlr4.Runtime.Atn.ATN : object {
    public static int InvalidAltNumber;
    [NotNullAttribute]
public IList`1<ATNState> states;
    [NotNullAttribute]
public IList`1<DecisionState> decisionToState;
    public RuleStartState[] ruleToStartState;
    public RuleStopState[] ruleToStopState;
    [NotNullAttribute]
public IDictionary`2<string, TokensStartState> modeNameToStartState;
    public ATNType grammarType;
    public int maxTokenType;
    public Int32[] ruleToTokenType;
    public ILexerAction[] lexerActions;
    [NotNullAttribute]
public IList`1<TokensStartState> modeToStartState;
    private ConcurrentDictionary`2<PredictionContext, PredictionContext> contextCache;
    [NotNullAttribute]
public DFA[] decisionToDFA;
    [NotNullAttribute]
public DFA[] modeToDFA;
    protected internal ConcurrentDictionary`2<int, int> LL1Table;
    public int ContextCacheSize { get; }
    public int NumberOfDecisions { get; }
    public ATN(ATNType grammarType, int maxTokenType);
    public void ClearDFA();
    public virtual int get_ContextCacheSize();
    public virtual PredictionContext GetCachedContext(PredictionContext context);
    public virtual IntervalSet NextTokens(ATNState s, PredictionContext ctx);
    public virtual IntervalSet NextTokens(ATNState s);
    public virtual void AddState(ATNState state);
    public virtual void RemoveState(ATNState state);
    public virtual void DefineMode(string name, TokensStartState s);
    public virtual int DefineDecisionState(DecisionState s);
    public virtual DecisionState GetDecisionState(int decision);
    public virtual int get_NumberOfDecisions();
    public virtual IntervalSet GetExpectedTokens(int stateNumber, RuleContext context);
}
public class Antlr4.Runtime.Atn.ATNConfig : object {
    private static int SuppressPrecedenceFilter;
    [NotNullAttribute]
private ATNState state;
    private int altAndOuterContextDepth;
    [NotNullAttribute]
private PredictionContext context;
    public ATNState State { get; }
    public int Alt { get; }
    public PredictionContext Context { get; public set; }
    public bool ReachesIntoOuterContext { get; }
    public int OuterContextDepth { get; public set; }
    public LexerActionExecutor ActionExecutor { get; }
    public SemanticContext SemanticContext { get; }
    public bool PassedThroughNonGreedyDecision { get; }
    public bool PrecedenceFilterSuppressed { get; public set; }
    protected internal ATNConfig(ATNState state, int alt, PredictionContext context);
    protected internal ATNConfig(ATNConfig c, ATNState state, PredictionContext context);
    public static ATNConfig Create(ATNState state, int alt, PredictionContext context);
    public static ATNConfig Create(ATNState state, int alt, PredictionContext context, SemanticContext semanticContext);
    public static ATNConfig Create(ATNState state, int alt, PredictionContext context, SemanticContext semanticContext, LexerActionExecutor lexerActionExecutor);
    public ATNState get_State();
    public int get_Alt();
    public virtual PredictionContext get_Context();
    public virtual void set_Context(PredictionContext value);
    public bool get_ReachesIntoOuterContext();
    public virtual int get_OuterContextDepth();
    public virtual void set_OuterContextDepth(int value);
    public virtual LexerActionExecutor get_ActionExecutor();
    public virtual SemanticContext get_SemanticContext();
    public virtual bool get_PassedThroughNonGreedyDecision();
    public ATNConfig Clone();
    public ATNConfig Transform(ATNState state, bool checkNonGreedy);
    public ATNConfig Transform(ATNState state, SemanticContext semanticContext, bool checkNonGreedy);
    public ATNConfig Transform(ATNState state, PredictionContext context, bool checkNonGreedy);
    public ATNConfig Transform(ATNState state, LexerActionExecutor lexerActionExecutor, bool checkNonGreedy);
    private ATNConfig Transform(ATNState state, PredictionContext context, SemanticContext semanticContext, bool checkNonGreedy, LexerActionExecutor lexerActionExecutor);
    private static bool CheckNonGreedyDecision(ATNConfig source, ATNState target);
    public virtual ATNConfig AppendContext(int context, PredictionContextCache contextCache);
    public virtual ATNConfig AppendContext(PredictionContext context, PredictionContextCache contextCache);
    public virtual bool Contains(ATNConfig subconfig);
    public bool get_PrecedenceFilterSuppressed();
    public void set_PrecedenceFilterSuppressed(bool value);
    public virtual bool Equals(object o);
    public virtual bool Equals(ATNConfig other);
    public virtual int GetHashCode();
    public virtual string ToDotString();
    public virtual string ToString();
    public virtual string ToString(IRecognizer recog, bool showAlt);
    public virtual string ToString(IRecognizer recog, bool showAlt, bool showContext);
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Atn.ATNConfigSet : object {
    private Dictionary`2<long, ATNConfig> mergedConfigs;
    private List`1<ATNConfig> unmerged;
    private List`1<ATNConfig> configs;
    private int uniqueAlt;
    private ConflictInfo conflictInfo;
    private bool hasSemanticContext;
    private bool dipsIntoOuterContext;
    private bool outermostConfigSet;
    private int cachedHashCode;
    [NotNullAttribute]
public BitSet RepresentedAlternatives { get; }
    public bool IsReadOnly { get; }
    public bool IsOutermostConfigSet { get; public set; }
    public HashSet`1<ATNState> States { get; }
    public int Count { get; }
    public int UniqueAlt { get; }
    public bool HasSemanticContext { get; }
    public ConflictInfo ConflictInformation { get; public set; }
    public BitSet ConflictingAlts { get; }
    public bool IsExactConflict { get; }
    public bool DipsIntoOuterContext { get; }
    public ATNConfig Item { get; }
    protected internal ATNConfigSet(ATNConfigSet set, bool readonly);
    public virtual BitSet get_RepresentedAlternatives();
    public bool get_IsReadOnly();
    public virtual bool get_IsOutermostConfigSet();
    public virtual void set_IsOutermostConfigSet(bool value);
    public virtual HashSet`1<ATNState> get_States();
    public virtual void OptimizeConfigs(ATNSimulator interpreter);
    public virtual ATNConfigSet Clone(bool readonly);
    public virtual int get_Count();
    public virtual bool IsEmpty();
    public virtual bool Contains(object o);
    public virtual IEnumerator`1<ATNConfig> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual Object[] ToArray();
    public virtual bool Add(ATNConfig e);
    public virtual bool Add(ATNConfig e, PredictionContextCache contextCache);
    private void UpdatePropertiesForMergedConfig(ATNConfig config);
    private void UpdatePropertiesForAddedConfig(ATNConfig config);
    protected internal virtual bool CanMerge(ATNConfig left, long leftKey, ATNConfig right);
    protected internal virtual long GetKey(ATNConfig e);
    public virtual bool Remove(object o);
    public virtual bool ContainsAll(IEnumerable`1<ATNConfig> c);
    public virtual bool AddAll(IEnumerable`1<ATNConfig> c);
    public virtual bool AddAll(IEnumerable`1<ATNConfig> c, PredictionContextCache contextCache);
    public virtual bool RetainAll(ICollection`1<_T0> c);
    public virtual bool RemoveAll(ICollection`1<_T0> c);
    public virtual void Clear();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string ToString(bool showContext);
    public virtual int get_UniqueAlt();
    public virtual bool get_HasSemanticContext();
    public virtual void ClearExplicitSemanticContext();
    public virtual void MarkExplicitSemanticContext();
    public virtual ConflictInfo get_ConflictInformation();
    public virtual void set_ConflictInformation(ConflictInfo value);
    public virtual BitSet get_ConflictingAlts();
    public virtual bool get_IsExactConflict();
    public virtual bool get_DipsIntoOuterContext();
    public virtual ATNConfig get_Item(int index);
    public virtual void Remove(int index);
    protected internal void EnsureWritable();
}
public class Antlr4.Runtime.Atn.ATNDeserializationOptions : object {
    private static ATNDeserializationOptions defaultOptions;
    private bool readOnly;
    private bool verifyATN;
    private bool generateRuleBypassTransitions;
    private bool optimize;
    [NotNullAttribute]
public static ATNDeserializationOptions Default { get; }
    public bool IsReadOnly { get; }
    public bool VerifyAtn { get; public set; }
    public bool GenerateRuleBypassTransitions { get; public set; }
    public bool Optimize { get; public set; }
    private static ATNDeserializationOptions();
    public ATNDeserializationOptions(ATNDeserializationOptions options);
    public static ATNDeserializationOptions get_Default();
    public bool get_IsReadOnly();
    public void MakeReadOnly();
    public bool get_VerifyAtn();
    public void set_VerifyAtn(bool value);
    public bool get_GenerateRuleBypassTransitions();
    public void set_GenerateRuleBypassTransitions(bool value);
    public bool get_Optimize();
    public void set_Optimize(bool value);
    protected internal virtual void ThrowIfReadOnly();
}
public class Antlr4.Runtime.Atn.ATNDeserializer : object {
    public static int SerializedVersion;
    private static Guid BaseSerializedUuid;
    private static IList`1<Guid> SupportedUuids;
    public static Guid SerializedUuid;
    [NotNullAttribute]
private ATNDeserializationOptions deserializationOptions;
    private Char[] data;
    private int p;
    private static ATNDeserializer();
    public ATNDeserializer(ATNDeserializationOptions deserializationOptions);
    protected internal virtual bool IsFeatureSupported(Guid feature, Guid actualUuid);
    public virtual ATN Deserialize(Char[] data);
    protected internal virtual void OptimizeATN(ATN atn);
    protected internal virtual void GenerateRuleBypassTransitions(ATN atn);
    protected internal virtual void ReadLexerActions(ATN atn);
    protected internal virtual void ReadDecisions(ATN atn);
    protected internal virtual void ReadEdges(ATN atn, IList`1<IntervalSet> sets);
    protected internal virtual IList`1<IntervalSet> ReadSets(ATN atn);
    protected internal virtual void ReadModes(ATN atn);
    protected internal virtual void ReadRules(ATN atn);
    protected internal virtual void ReadStates(ATN atn);
    protected internal virtual ATN ReadATN();
    protected internal virtual void CheckUUID();
    protected internal virtual void CheckVersion();
    protected internal virtual void Reset(Char[] data);
    protected internal virtual void MarkPrecedenceDecisions(ATN atn);
    protected internal virtual void VerifyATN(ATN atn);
    protected internal virtual void CheckCondition(bool condition);
    protected internal virtual void CheckCondition(bool condition, string message);
    private static int InlineSetRules(ATN atn);
    private static int CombineChainedEpsilons(ATN atn);
    private static int OptimizeSets(ATN atn, bool preserveOrder);
    private static void IdentifyTailCalls(ATN atn);
    private static bool TestTailCall(ATN atn, RuleTransition transition, bool optimizedPath);
    protected internal int ReadInt();
    protected internal int ReadInt32();
    protected internal long ReadLong();
    protected internal Guid ReadUUID();
    protected internal virtual Transition EdgeFactory(ATN atn, TransitionType type, int src, int trg, int arg1, int arg2, int arg3, IList`1<IntervalSet> sets);
    protected internal virtual ATNState StateFactory(StateType type, int ruleIndex);
    protected internal virtual ILexerAction LexerActionFactory(LexerActionType type, int data1, int data2);
}
public abstract class Antlr4.Runtime.Atn.ATNSimulator : object {
    [ObsoleteAttribute("Use ATNDeserializer.SerializedVersion instead.")]
public static int SerializedVersion;
    [ObsoleteAttribute("Use ATNDeserializer.CheckCondition(bool) instead.")]
public static Guid SerializedUuid;
    public static char RuleVariantDelimiter;
    public static string RuleLfVariantMarker;
    public static string RuleNolfVariantMarker;
    [NotNullAttribute]
public static DFAState Error;
    [NotNullAttribute]
public ATN atn;
    public ATNSimulator(ATN atn);
    private static ATNSimulator();
    public abstract virtual void Reset();
    public virtual void ClearDFA();
    [ObsoleteAttribute("Use ATNDeserializer.Deserialize(char[]) instead.")]
public static ATN Deserialize(Char[] data);
    [ObsoleteAttribute("Use ATNDeserializer.EdgeFactory(ATN, TransitionType, int, int, int, int, int, System.Collections.Generic.IList{E}) instead.")]
public static Transition EdgeFactory(ATN atn, TransitionType type, int src, int trg, int arg1, int arg2, int arg3, IList`1<IntervalSet> sets);
    [ObsoleteAttribute("Use ATNDeserializer.StateFactory(StateType, int) instead.")]
public static ATNState StateFactory(StateType type, int ruleIndex);
}
public abstract class Antlr4.Runtime.Atn.ATNState : object {
    public static int InitialNumTransitions;
    public static ReadOnlyCollection`1<string> serializationNames;
    public static int InvalidStateNumber;
    public ATN atn;
    public int stateNumber;
    public int ruleIndex;
    public bool epsilonOnlyTransitions;
    protected internal List`1<Transition> transitions;
    protected internal List`1<Transition> optimizedTransitions;
    public IntervalSet nextTokenWithinRule;
    public int NonStopStateNumber { get; }
    public bool IsNonGreedyExitState { get; }
    public Transition[] TransitionsArray { get; }
    public int NumberOfTransitions { get; }
    public StateType StateType { get; }
    public bool OnlyHasEpsilonTransitions { get; }
    public bool IsOptimized { get; }
    public int NumberOfOptimizedTransitions { get; }
    private static ATNState();
    public virtual int get_NonStopStateNumber();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual bool get_IsNonGreedyExitState();
    public virtual string ToString();
    public virtual Transition[] get_TransitionsArray();
    public virtual int get_NumberOfTransitions();
    public virtual void AddTransition(Transition e);
    public virtual void AddTransition(int index, Transition e);
    public virtual Transition Transition(int i);
    public virtual void SetTransition(int i, Transition e);
    public virtual void RemoveTransition(int index);
    public abstract virtual StateType get_StateType();
    public bool get_OnlyHasEpsilonTransitions();
    public virtual void SetRuleIndex(int ruleIndex);
    public virtual bool get_IsOptimized();
    public virtual int get_NumberOfOptimizedTransitions();
    public virtual Transition GetOptimizedTransition(int i);
    public virtual void AddOptimizedTransition(Transition e);
    public virtual void SetOptimizedTransition(int i, Transition e);
    public virtual void RemoveOptimizedTransition(int i);
}
public enum Antlr4.Runtime.Atn.ATNType : Enum {
    public int value__;
    public static ATNType Lexer;
    public static ATNType Parser;
}
public class Antlr4.Runtime.Atn.AtomTransition : Transition {
    public int token;
    public TransitionType TransitionType { get; }
    public IntervalSet Label { get; }
    public AtomTransition(ATNState target, int token);
    public virtual TransitionType get_TransitionType();
    public virtual IntervalSet get_Label();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.BasicBlockStartState : BlockStartState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.BasicState : ATNState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.BlockEndState : ATNState {
    public BlockStartState startState;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public abstract class Antlr4.Runtime.Atn.BlockStartState : DecisionState {
    public BlockEndState endState;
}
public class Antlr4.Runtime.Atn.ConflictInfo : object {
    private BitSet conflictedAlts;
    private bool exact;
    public BitSet ConflictedAlts { get; }
    public bool IsExact { get; }
    public ConflictInfo(BitSet conflictedAlts, bool exact);
    public BitSet get_ConflictedAlts();
    public bool get_IsExact();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Antlr4.Runtime.Atn.ContextSensitivityInfo : DecisionEventInfo {
    public ContextSensitivityInfo(int decision, SimulatorState state, ITokenStream input, int startIndex, int stopIndex);
}
public class Antlr4.Runtime.Atn.DecisionEventInfo : object {
    public int decision;
    [NullableAttribute]
public SimulatorState state;
    [NotNullAttribute]
public ITokenStream input;
    public int startIndex;
    public int stopIndex;
    public bool fullCtx;
    public DecisionEventInfo(int decision, SimulatorState state, ITokenStream input, int startIndex, int stopIndex, bool fullCtx);
}
public class Antlr4.Runtime.Atn.DecisionInfo : object {
    public int decision;
    public long invocations;
    public long SLL_TotalLook;
    public long SLL_MinLook;
    public long SLL_MaxLook;
    public LookaheadEventInfo SLL_MaxLookEvent;
    public long LL_TotalLook;
    public long LL_MinLook;
    public long LL_MaxLook;
    public LookaheadEventInfo LL_MaxLookEvent;
    public IList`1<ContextSensitivityInfo> contextSensitivities;
    public IList`1<ErrorInfo> errors;
    public IList`1<AmbiguityInfo> ambiguities;
    public IList`1<PredicateEvalInfo> predicateEvals;
    public long SLL_ATNTransitions;
    public long SLL_DFATransitions;
    public long LL_Fallback;
    public long LL_ATNTransitions;
    public long LL_DFATransitions;
    public DecisionInfo(int decision);
    public virtual string ToString();
}
public abstract class Antlr4.Runtime.Atn.DecisionState : ATNState {
    public int decision;
    public bool nonGreedy;
}
public class Antlr4.Runtime.Atn.EmptyPredictionContext : PredictionContext {
    public static EmptyPredictionContext LocalContext;
    public static EmptyPredictionContext FullContext;
    private bool fullContext;
    public bool IsFullContext { get; }
    public int Size { get; }
    public bool IsEmpty { get; }
    public bool HasEmpty { get; }
    private EmptyPredictionContext(bool fullContext);
    private static EmptyPredictionContext();
    public bool get_IsFullContext();
    protected internal virtual PredictionContext AddEmptyContext();
    protected internal virtual PredictionContext RemoveEmptyContext();
    public virtual PredictionContext GetParent(int index);
    public virtual int GetReturnState(int index);
    public virtual int FindReturnState(int returnState);
    public virtual int get_Size();
    public virtual PredictionContext AppendContext(int returnContext, PredictionContextCache contextCache);
    public virtual PredictionContext AppendContext(PredictionContext suffix, PredictionContextCache contextCache);
    public virtual bool get_IsEmpty();
    public virtual bool get_HasEmpty();
    public virtual bool Equals(object o);
    public virtual String[] ToStrings(IRecognizer recognizer, int currentState);
    public virtual String[] ToStrings(IRecognizer recognizer, PredictionContext stop, int currentState);
}
public class Antlr4.Runtime.Atn.EpsilonTransition : Transition {
    private int outermostPrecedenceReturn;
    public int OutermostPrecedenceReturn { get; }
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public EpsilonTransition(ATNState target);
    public EpsilonTransition(ATNState target, int outermostPrecedenceReturn);
    public int get_OutermostPrecedenceReturn();
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.ErrorInfo : DecisionEventInfo {
    public ErrorInfo(int decision, SimulatorState state, ITokenStream input, int startIndex, int stopIndex);
}
public interface Antlr4.Runtime.Atn.ILexerAction {
    [NotNullAttribute]
public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public abstract virtual LexerActionType get_ActionType();
    public abstract virtual bool get_IsPositionDependent();
    public abstract virtual void Execute(Lexer lexer);
}
public class Antlr4.Runtime.Atn.LexerActionExecutor : object {
    [NotNullAttribute]
private ILexerAction[] lexerActions;
    private int hashCode;
    [NotNullAttribute]
public ILexerAction[] LexerActions { get; }
    public LexerActionExecutor(ILexerAction[] lexerActions);
    public static LexerActionExecutor Append(LexerActionExecutor lexerActionExecutor, ILexerAction lexerAction);
    public virtual LexerActionExecutor FixOffsetBeforeMatch(int offset);
    public virtual ILexerAction[] get_LexerActions();
    public virtual void Execute(Lexer lexer, ICharStream input, int startIndex);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public enum Antlr4.Runtime.Atn.LexerActionType : Enum {
    public int value__;
    public static LexerActionType Channel;
    public static LexerActionType Custom;
    public static LexerActionType Mode;
    public static LexerActionType More;
    public static LexerActionType PopMode;
    public static LexerActionType PushMode;
    public static LexerActionType Skip;
    public static LexerActionType Type;
}
public class Antlr4.Runtime.Atn.LexerATNSimulator : ATNSimulator {
    public static bool debug;
    public static bool dfa_debug;
    public static int MinDfaEdge;
    public static int MaxDfaEdge;
    public bool optimize_tail_calls;
    [NullableAttribute]
protected internal Lexer recog;
    protected internal int startIndex;
    private int _line;
    protected internal int charPositionInLine;
    protected internal int mode;
    [NotNullAttribute]
protected internal SimState prevAccept;
    public static int match_calls;
    public int Line { get; public set; }
    public int Column { get; public set; }
    public LexerATNSimulator(ATN atn);
    public LexerATNSimulator(Lexer recog, ATN atn);
    public virtual void CopyState(LexerATNSimulator simulator);
    public virtual int Match(ICharStream input, int mode);
    public virtual void Reset();
    protected internal virtual int MatchATN(ICharStream input);
    protected internal virtual int ExecATN(ICharStream input, DFAState ds0);
    protected internal virtual DFAState GetExistingTargetState(DFAState s, int t);
    protected internal virtual DFAState ComputeTargetState(ICharStream input, DFAState s, int t);
    protected internal virtual int FailOrAccept(SimState prevAccept, ICharStream input, ATNConfigSet reach, int t);
    protected internal virtual void GetReachableConfigSet(ICharStream input, ATNConfigSet closure, ATNConfigSet reach, int t);
    protected internal virtual void Accept(ICharStream input, LexerActionExecutor lexerActionExecutor, int startIndex, int index, int line, int charPos);
    protected internal virtual ATNState GetReachableTarget(Transition trans, int t);
    protected internal virtual ATNConfigSet ComputeStartState(ICharStream input, ATNState p);
    protected internal virtual bool Closure(ICharStream input, ATNConfig config, ATNConfigSet configs, bool currentAltReachedAcceptState, bool speculative, bool treatEofAsEpsilon);
    protected internal virtual ATNConfig GetEpsilonTarget(ICharStream input, ATNConfig config, Transition t, ATNConfigSet configs, bool speculative, bool treatEofAsEpsilon);
    protected internal virtual bool EvaluatePredicate(ICharStream input, int ruleIndex, int predIndex, bool speculative);
    protected internal virtual void CaptureSimState(SimState settings, ICharStream input, DFAState dfaState);
    protected internal virtual DFAState AddDFAEdge(DFAState from, int t, ATNConfigSet q);
    protected internal virtual void AddDFAEdge(DFAState p, int t, DFAState q);
    protected internal virtual DFAState AddDFAState(ATNConfigSet configs);
    public DFA GetDFA(int mode);
    public virtual string GetText(ICharStream input);
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual int get_Column();
    public virtual void set_Column(int value);
    public virtual void Consume(ICharStream input);
    public virtual string GetTokenName(int t);
}
public class Antlr4.Runtime.Atn.LexerChannelAction : object {
    private int channel;
    public int Channel { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerChannelAction(int channel);
    public int get_Channel();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerCustomAction : object {
    private int ruleIndex;
    private int actionIndex;
    public int RuleIndex { get; }
    public int ActionIndex { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerCustomAction(int ruleIndex, int actionIndex);
    public int get_RuleIndex();
    public int get_ActionIndex();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Antlr4.Runtime.Atn.LexerIndexedCustomAction : object {
    private int offset;
    private ILexerAction action;
    public int Offset { get; }
    [NotNullAttribute]
public ILexerAction Action { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerIndexedCustomAction(int offset, ILexerAction action);
    public int get_Offset();
    public ILexerAction get_Action();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Antlr4.Runtime.Atn.LexerModeAction : object {
    private int mode;
    public int Mode { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerModeAction(int mode);
    public int get_Mode();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerMoreAction : object {
    public static LexerMoreAction Instance;
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    private static LexerMoreAction();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerPopModeAction : object {
    public static LexerPopModeAction Instance;
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    private static LexerPopModeAction();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerPushModeAction : object {
    private int mode;
    public int Mode { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerPushModeAction(int mode);
    public int get_Mode();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerSkipAction : object {
    public static LexerSkipAction Instance;
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    private static LexerSkipAction();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerTypeAction : object {
    private int type;
    public int Type { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerTypeAction(int type);
    public virtual int get_Type();
    public virtual LexerActionType get_ActionType();
    public virtual bool get_IsPositionDependent();
    public virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LL1Analyzer : object {
    public static int HitPred;
    [NotNullAttribute]
public ATN atn;
    public LL1Analyzer(ATN atn);
    public virtual IntervalSet[] GetDecisionLookahead(ATNState s);
    public virtual IntervalSet Look(ATNState s, PredictionContext ctx);
    public virtual IntervalSet Look(ATNState s, ATNState stopState, PredictionContext ctx);
    protected internal virtual void Look(ATNState s, ATNState stopState, PredictionContext ctx, IntervalSet look, HashSet`1<ATNConfig> lookBusy, BitSet calledRuleStack, bool seeThruPreds, bool addEOF);
}
public class Antlr4.Runtime.Atn.LookaheadEventInfo : DecisionEventInfo {
    public LookaheadEventInfo(int decision, SimulatorState state, ITokenStream input, int startIndex, int stopIndex, bool fullCtx);
}
public class Antlr4.Runtime.Atn.LoopEndState : ATNState {
    public ATNState loopBackState;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.NotSetTransition : SetTransition {
    public TransitionType TransitionType { get; }
    public NotSetTransition(ATNState target, IntervalSet set);
    public virtual TransitionType get_TransitionType();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.OrderedATNConfigSet : ATNConfigSet {
    public OrderedATNConfigSet(ATNConfigSet set, bool readonly);
    public virtual ATNConfigSet Clone(bool readonly);
    protected internal virtual long GetKey(ATNConfig e);
    protected internal virtual bool CanMerge(ATNConfig left, long leftKey, ATNConfig right);
}
public class Antlr4.Runtime.Atn.ParseInfo : object {
    protected internal ProfilingATNSimulator atnSimulator;
    [NotNullAttribute]
public DecisionInfo[] DecisionInfo { get; }
    public ParseInfo(ProfilingATNSimulator atnSimulator);
    public virtual DecisionInfo[] get_DecisionInfo();
    public virtual IList`1<int> GetLLDecisions();
    public virtual long GetTotalSLLLookaheadOps();
    public virtual long GetTotalLLLookaheadOps();
    public virtual long GetTotalSLLATNLookaheadOps();
    public virtual long GetTotalLLATNLookaheadOps();
    public virtual long GetTotalATNLookaheadOps();
    public virtual int GetDFASize();
    public virtual int GetDFASize(int decision);
}
public class Antlr4.Runtime.Atn.ParserATNSimulator : ATNSimulator {
    public static bool debug;
    public static bool dfa_debug;
    public static bool retry_debug;
    [NotNullAttribute]
private PredictionMode predictionMode;
    public bool force_global_context;
    public bool always_try_local_context;
    public bool enable_global_context_dfa;
    public bool optimize_unique_closure;
    public bool optimize_ll1;
    [ObsoleteAttribute("This flag is not currently used by the ATN simulator.")]
public bool optimize_hidden_conflicted_configs;
    public bool optimize_tail_calls;
    public bool tail_call_preserves_sll;
    public bool treat_sllk1_conflict_as_ambiguity;
    [NullableAttribute]
private Parser _parser;
    public bool reportAmbiguities;
    protected internal bool userWantsCtxSensitive;
    private DFA dfa;
    private static IComparer`1<ATNConfig> StateAltSortComparator;
    public PredictionMode PredictionMode { get; public set; }
    public Parser Parser { get; }
    public ParserATNSimulator(ATN atn);
    public ParserATNSimulator(Parser parser, ATN atn);
    private static ParserATNSimulator();
    public PredictionMode get_PredictionMode();
    public void set_PredictionMode(PredictionMode value);
    public virtual void Reset();
    public virtual int AdaptivePredict(ITokenStream input, int decision, ParserRuleContext outerContext);
    public virtual int AdaptivePredict(ITokenStream input, int decision, ParserRuleContext outerContext, bool useContext);
    protected internal virtual SimulatorState GetStartState(DFA dfa, ITokenStream input, ParserRuleContext outerContext, bool useContext);
    protected internal virtual int ExecDFA(DFA dfa, ITokenStream input, int startIndex, SimulatorState state);
    protected internal virtual bool IsAcceptState(DFAState state, bool useContext);
    protected internal virtual int ExecATN(DFA dfa, ITokenStream input, int startIndex, SimulatorState initialState);
    protected internal virtual int HandleNoViableAlt(ITokenStream input, int startIndex, SimulatorState previous);
    protected internal virtual SimulatorState ComputeReachSet(DFA dfa, SimulatorState previous, int t, PredictionContextCache contextCache);
    protected internal virtual DFAState GetExistingTargetState(DFAState s, int t);
    protected internal virtual Tuple`2<DFAState, ParserRuleContext> ComputeTargetState(DFA dfa, DFAState s, ParserRuleContext remainingGlobalContext, int t, bool useContext, PredictionContextCache contextCache);
    protected internal virtual ATNConfigSet RemoveAllConfigsNotInRuleStopState(ATNConfigSet configs, PredictionContextCache contextCache);
    protected internal virtual SimulatorState ComputeStartState(DFA dfa, ParserRuleContext globalContext, bool useContext);
    protected internal virtual ATNConfigSet ApplyPrecedenceFilter(ATNConfigSet configs, ParserRuleContext globalContext, PredictionContextCache contextCache);
    protected internal virtual ATNState GetReachableTarget(ATNConfig source, Transition trans, int ttype);
    protected internal virtual PredPrediction[] PredicateDFAState(DFAState D, ATNConfigSet configs, int nalts);
    protected internal virtual SemanticContext[] GetPredsForAmbigAlts(BitSet ambigAlts, ATNConfigSet configs, int nalts);
    protected internal virtual PredPrediction[] GetPredicatePredictions(BitSet ambigAlts, SemanticContext[] altToPred);
    protected internal virtual BitSet EvalSemanticContext(PredPrediction[] predPredictions, ParserRuleContext outerContext, bool complete);
    protected internal virtual bool EvalSemanticContext(SemanticContext pred, ParserRuleContext parserCallStack, int alt);
    protected internal virtual void Closure(ATNConfigSet sourceConfigs, ATNConfigSet configs, bool collectPredicates, bool hasMoreContext, PredictionContextCache contextCache, bool treatEofAsEpsilon);
    protected internal virtual void Closure(ATNConfig config, ATNConfigSet configs, ATNConfigSet intermediate, HashSet`1<ATNConfig> closureBusy, bool collectPredicates, bool hasMoreContexts, PredictionContextCache contextCache, int depth, bool treatEofAsEpsilon);
    public virtual string GetRuleName(int index);
    protected internal virtual ATNConfig GetEpsilonTarget(ATNConfig config, Transition t, bool collectPredicates, bool inContext, PredictionContextCache contextCache, bool treatEofAsEpsilon);
    protected internal virtual ATNConfig ActionTransition(ATNConfig config, ActionTransition t);
    protected internal virtual ATNConfig PrecedenceTransition(ATNConfig config, PrecedencePredicateTransition pt, bool collectPredicates, bool inContext);
    protected internal virtual ATNConfig PredTransition(ATNConfig config, PredicateTransition pt, bool collectPredicates, bool inContext);
    protected internal virtual ATNConfig RuleTransition(ATNConfig config, RuleTransition t, PredictionContextCache contextCache);
    private ConflictInfo IsConflicted(ATNConfigSet configset, PredictionContextCache contextCache);
    protected internal virtual BitSet GetConflictingAltsFromConfigSet(ATNConfigSet configs);
    public virtual string GetTokenName(int t);
    public virtual string GetLookaheadName(ITokenStream input);
    public virtual void DumpDeadEndConfigs(NoViableAltException nvae);
    protected internal virtual NoViableAltException NoViableAlt(ITokenStream input, ParserRuleContext outerContext, ATNConfigSet configs, int startIndex);
    protected internal virtual int GetUniqueAlt(IEnumerable`1<ATNConfig> configs);
    protected internal virtual bool ConfigWithAltAtStopState(IEnumerable`1<ATNConfig> configs, int alt);
    protected internal virtual DFAState AddDFAEdge(DFA dfa, DFAState fromState, int t, List`1<int> contextTransitions, ATNConfigSet toConfigs, PredictionContextCache contextCache);
    protected internal virtual void AddDFAEdge(DFAState p, int t, DFAState q);
    protected internal virtual DFAState AddDFAContextState(DFA dfa, ATNConfigSet configs, int returnContext, PredictionContextCache contextCache);
    protected internal virtual DFAState AddDFAState(DFA dfa, ATNConfigSet configs, PredictionContextCache contextCache);
    protected internal virtual DFAState CreateDFAState(DFA dfa, ATNConfigSet configs);
    protected internal virtual void ReportAttemptingFullContext(DFA dfa, BitSet conflictingAlts, SimulatorState conflictState, int startIndex, int stopIndex);
    protected internal virtual void ReportContextSensitivity(DFA dfa, int prediction, SimulatorState acceptState, int startIndex, int stopIndex);
    protected internal virtual void ReportAmbiguity(DFA dfa, DFAState D, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    protected internal int GetReturnState(RuleContext context);
    protected internal ParserRuleContext SkipTailCalls(ParserRuleContext context);
    public virtual Parser get_Parser();
}
public class Antlr4.Runtime.Atn.PlusBlockStartState : BlockStartState {
    public PlusLoopbackState loopBackState;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.PlusLoopbackState : DecisionState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.PrecedencePredicateTransition : AbstractPredicateTransition {
    public int precedence;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public PrecedencePredicate Predicate { get; }
    public PrecedencePredicateTransition(ATNState target, int precedence);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public PrecedencePredicate get_Predicate();
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.PredicateEvalInfo : DecisionEventInfo {
    public SemanticContext semctx;
    public int predictedAlt;
    public bool evalResult;
    public PredicateEvalInfo(SimulatorState state, int decision, ITokenStream input, int startIndex, int stopIndex, SemanticContext semctx, bool evalResult, int predictedAlt);
}
public class Antlr4.Runtime.Atn.PredicateTransition : AbstractPredicateTransition {
    public int ruleIndex;
    public int predIndex;
    public bool isCtxDependent;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public Predicate Predicate { get; }
    public PredicateTransition(ATNState target, int ruleIndex, int predIndex, bool isCtxDependent);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public Predicate get_Predicate();
    public virtual string ToString();
}
public abstract class Antlr4.Runtime.Atn.PredictionContext : object {
    [NotNullAttribute]
public static PredictionContext EmptyLocal;
    [NotNullAttribute]
public static PredictionContext EmptyFull;
    public static int EmptyLocalStateKey;
    public static int EmptyFullStateKey;
    private static int InitialHash;
    private int cachedHashCode;
    public int Size { get; }
    public bool IsEmpty { get; }
    public bool HasEmpty { get; }
    protected internal PredictionContext(int cachedHashCode);
    private static PredictionContext();
    protected internal static int CalculateEmptyHashCode();
    protected internal static int CalculateHashCode(PredictionContext parent, int returnState);
    protected internal static int CalculateHashCode(PredictionContext[] parents, Int32[] returnStates);
    public abstract virtual int get_Size();
    public abstract virtual int GetReturnState(int index);
    public abstract virtual int FindReturnState(int returnState);
    public abstract virtual PredictionContext GetParent(int index);
    protected internal abstract virtual PredictionContext AddEmptyContext();
    protected internal abstract virtual PredictionContext RemoveEmptyContext();
    public static PredictionContext FromRuleContext(ATN atn, RuleContext outerContext);
    public static PredictionContext FromRuleContext(ATN atn, RuleContext outerContext, bool fullContext);
    private static PredictionContext AddEmptyContext(PredictionContext context);
    private static PredictionContext RemoveEmptyContext(PredictionContext context);
    public static PredictionContext Join(PredictionContext context0, PredictionContext context1);
    internal static PredictionContext Join(PredictionContext context0, PredictionContext context1, PredictionContextCache contextCache);
    public static bool IsEmptyLocal(PredictionContext context);
    public static PredictionContext GetCachedContext(PredictionContext context, ConcurrentDictionary`2<PredictionContext, PredictionContext> contextCache, IdentityHashMap visited);
    public virtual PredictionContext AppendContext(int returnContext, PredictionContextCache contextCache);
    public abstract virtual PredictionContext AppendContext(PredictionContext suffix, PredictionContextCache contextCache);
    public virtual PredictionContext GetChild(int returnState);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_HasEmpty();
    public sealed virtual int GetHashCode();
    public abstract virtual bool Equals(object o);
    public virtual String[] ToStrings(IRecognizer recognizer, int currentState);
    public virtual String[] ToStrings(IRecognizer recognizer, PredictionContext stop, int currentState);
}
public class Antlr4.Runtime.Atn.PredictionContextCache : object {
    public static PredictionContextCache Uncached;
    private IDictionary`2<PredictionContext, PredictionContext> contexts;
    private IDictionary`2<PredictionContextAndInt, PredictionContext> childContexts;
    private IDictionary`2<IdentityCommutativePredictionContextOperands, PredictionContext> joinContexts;
    private bool enableCache;
    private PredictionContextCache(bool enableCache);
    private static PredictionContextCache();
    public virtual PredictionContext GetAsCached(PredictionContext context);
    public virtual PredictionContext GetChild(PredictionContext context, int invokingState);
    public virtual PredictionContext Join(PredictionContext x, PredictionContext y);
}
public class Antlr4.Runtime.Atn.PredictionMode : object {
    public static PredictionMode Sll;
    public static PredictionMode Ll;
    public static PredictionMode LlExactAmbigDetection;
    private static PredictionMode();
    public static bool HasSLLConflictTerminatingPrediction(PredictionMode mode, ATNConfigSet configs);
    public static bool HasConfigInRuleStopState(IEnumerable`1<ATNConfig> configs);
    public static bool AllConfigsInRuleStopStates(IEnumerable`1<ATNConfig> configs);
    public static int ResolvesToJustOneViableAlt(IEnumerable`1<BitSet> altsets);
    public static bool AllSubsetsConflict(IEnumerable`1<BitSet> altsets);
    public static bool HasNonConflictingAltSet(IEnumerable`1<BitSet> altsets);
    public static bool HasConflictingAltSet(IEnumerable`1<BitSet> altsets);
    public static bool AllSubsetsEqual(IEnumerable`1<BitSet> altsets);
    public static int GetUniqueAlt(IEnumerable`1<BitSet> altsets);
    public static BitSet GetAlts(IEnumerable`1<BitSet> altsets);
    public static ICollection`1<BitSet> GetConflictingAltSubsets(IEnumerable`1<ATNConfig> configs);
    public static IDictionary`2<ATNState, BitSet> GetStateToAltMap(IEnumerable`1<ATNConfig> configs);
    public static bool HasStateAssociatedWithOneAlt(IEnumerable`1<ATNConfig> configs);
    public static int GetSingleViableAlt(IEnumerable`1<BitSet> altsets);
}
public class Antlr4.Runtime.Atn.ProfilingATNSimulator : ParserATNSimulator {
    protected internal DecisionInfo[] decisions;
    protected internal int numDecisions;
    private ITokenStream _input;
    private int _startIndex;
    private int _sllStopIndex;
    private int _llStopIndex;
    protected internal int currentDecision;
    protected internal SimulatorState currentState;
    protected internal int conflictingAltResolvedBySLL;
    public DecisionInfo[] DecisionInfo { get; }
    public ProfilingATNSimulator(Parser parser);
    public virtual int AdaptivePredict(ITokenStream input, int decision, ParserRuleContext outerContext);
    protected internal virtual SimulatorState GetStartState(DFA dfa, ITokenStream input, ParserRuleContext outerContext, bool useContext);
    protected internal virtual SimulatorState ComputeStartState(DFA dfa, ParserRuleContext globalContext, bool useContext);
    protected internal virtual SimulatorState ComputeReachSet(DFA dfa, SimulatorState previous, int t, PredictionContextCache contextCache);
    protected internal virtual DFAState GetExistingTargetState(DFAState previousD, int t);
    protected internal virtual Tuple`2<DFAState, ParserRuleContext> ComputeTargetState(DFA dfa, DFAState s, ParserRuleContext remainingGlobalContext, int t, bool useContext, PredictionContextCache contextCache);
    protected internal virtual bool EvalSemanticContext(SemanticContext pred, ParserRuleContext parserCallStack, int alt);
    protected internal virtual void ReportContextSensitivity(DFA dfa, int prediction, SimulatorState acceptState, int startIndex, int stopIndex);
    protected internal virtual void ReportAttemptingFullContext(DFA dfa, BitSet conflictingAlts, SimulatorState conflictState, int startIndex, int stopIndex);
    protected internal virtual void ReportAmbiguity(DFA dfa, DFAState D, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public virtual DecisionInfo[] get_DecisionInfo();
}
public class Antlr4.Runtime.Atn.RangeTransition : Transition {
    public int from;
    public int to;
    public TransitionType TransitionType { get; }
    public IntervalSet Label { get; }
    public RangeTransition(ATNState target, int from, int to);
    public virtual TransitionType get_TransitionType();
    public virtual IntervalSet get_Label();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.RuleStartState : ATNState {
    public RuleStopState stopState;
    public bool isPrecedenceRule;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.RuleStopState : ATNState {
    public int NonStopStateNumber { get; }
    public StateType StateType { get; }
    public virtual int get_NonStopStateNumber();
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.RuleTransition : Transition {
    public int ruleIndex;
    public int precedence;
    [NotNullAttribute]
public ATNState followState;
    public bool tailCall;
    public bool optimizedTailCall;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    [ObsoleteAttribute("UseRuleTransition(RuleStartState, int, int, ATNState) instead.")]
public RuleTransition(RuleStartState ruleStart, int ruleIndex, ATNState followState);
    public RuleTransition(RuleStartState ruleStart, int ruleIndex, int precedence, ATNState followState);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
}
public abstract class Antlr4.Runtime.Atn.SemanticContext : object {
    public static SemanticContext None;
    private static SemanticContext();
    public abstract virtual bool Eval(Recognizer`2<Symbol, ATNInterpreter> parser, RuleContext parserCallStack);
    public virtual SemanticContext EvalPrecedence(Recognizer`2<Symbol, ATNInterpreter> parser, RuleContext parserCallStack);
    public static SemanticContext AndOp(SemanticContext a, SemanticContext b);
    public static SemanticContext OrOp(SemanticContext a, SemanticContext b);
    private static IList`1<PrecedencePredicate> FilterPrecedencePredicates(HashSet`1<SemanticContext> collection);
}
public class Antlr4.Runtime.Atn.SetTransition : Transition {
    [NotNullAttribute]
public IntervalSet set;
    public TransitionType TransitionType { get; }
    public IntervalSet Label { get; }
    public SetTransition(ATNState target, IntervalSet set);
    public virtual TransitionType get_TransitionType();
    public virtual IntervalSet get_Label();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.SimulatorState : object {
    public ParserRuleContext outerContext;
    public DFAState s0;
    public bool useContext;
    public ParserRuleContext remainingOuterContext;
    public SimulatorState(ParserRuleContext outerContext, DFAState s0, bool useContext, ParserRuleContext remainingOuterContext);
}
public class Antlr4.Runtime.Atn.SingletonPredictionContext : PredictionContext {
    [NotNullAttribute]
public PredictionContext parent;
    public int returnState;
    public int Size { get; }
    public bool IsEmpty { get; }
    public bool HasEmpty { get; }
    internal SingletonPredictionContext(PredictionContext parent, int returnState);
    public virtual PredictionContext GetParent(int index);
    public virtual int GetReturnState(int index);
    public virtual int FindReturnState(int returnState);
    public virtual int get_Size();
    public virtual bool get_IsEmpty();
    public virtual bool get_HasEmpty();
    public virtual PredictionContext AppendContext(PredictionContext suffix, PredictionContextCache contextCache);
    protected internal virtual PredictionContext AddEmptyContext();
    protected internal virtual PredictionContext RemoveEmptyContext();
    public virtual bool Equals(object o);
}
public class Antlr4.Runtime.Atn.StarBlockStartState : BlockStartState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.StarLoopbackState : ATNState {
    public StarLoopEntryState LoopEntryState { get; }
    public StateType StateType { get; }
    public StarLoopEntryState get_LoopEntryState();
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.StarLoopEntryState : DecisionState {
    public StarLoopbackState loopBackState;
    public bool precedenceRuleDecision;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public enum Antlr4.Runtime.Atn.StateType : Enum {
    public int value__;
    public static StateType InvalidType;
    public static StateType Basic;
    public static StateType RuleStart;
    public static StateType BlockStart;
    public static StateType PlusBlockStart;
    public static StateType StarBlockStart;
    public static StateType TokenStart;
    public static StateType RuleStop;
    public static StateType BlockEnd;
    public static StateType StarLoopBack;
    public static StateType StarLoopEntry;
    public static StateType PlusLoopBack;
    public static StateType LoopEnd;
}
public class Antlr4.Runtime.Atn.TokensStartState : DecisionState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public abstract class Antlr4.Runtime.Atn.Transition : object {
    public static ReadOnlyCollection`1<string> serializationNames;
    [NotNullAttribute]
public ATNState target;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public IntervalSet Label { get; }
    protected internal Transition(ATNState target);
    private static Transition();
    public abstract virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual IntervalSet get_Label();
    public abstract virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
}
public enum Antlr4.Runtime.Atn.TransitionType : Enum {
    public int value__;
    public static TransitionType Invalid;
    public static TransitionType Epsilon;
    public static TransitionType Range;
    public static TransitionType Rule;
    public static TransitionType Predicate;
    public static TransitionType Atom;
    public static TransitionType Action;
    public static TransitionType Set;
    public static TransitionType NotSet;
    public static TransitionType Wildcard;
    public static TransitionType Precedence;
}
public class Antlr4.Runtime.Atn.WildcardTransition : Transition {
    public TransitionType TransitionType { get; }
    public WildcardTransition(ATNState target);
    public virtual TransitionType get_TransitionType();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.BailErrorStrategy : DefaultErrorStrategy {
    public virtual void Recover(Parser recognizer, RecognitionException e);
    public virtual IToken RecoverInline(Parser recognizer);
    public virtual void Sync(Parser recognizer);
}
public class Antlr4.Runtime.BaseErrorListener : object {
    public virtual void SyntaxError(IRecognizer recognizer, IToken offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
    public virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, SimulatorState conflictState);
    public virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, SimulatorState acceptState);
}
public class Antlr4.Runtime.BufferedTokenStream : object {
    [NotNullAttribute]
private ITokenSource _tokenSource;
    protected internal IList`1<IToken> tokens;
    protected internal int p;
    protected internal bool fetchedEOF;
    public ITokenSource TokenSource { get; }
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public BufferedTokenStream(ITokenSource tokenSource);
    public virtual ITokenSource get_TokenSource();
    public virtual int get_Index();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Reset();
    public virtual void Seek(int index);
    public virtual int get_Size();
    public virtual void Consume();
    protected internal virtual bool Sync(int i);
    protected internal virtual int Fetch(int n);
    public virtual IToken Get(int i);
    public virtual IList`1<IToken> Get(int start, int stop);
    public virtual int La(int i);
    protected internal virtual IToken Lb(int k);
    public virtual IToken Lt(int k);
    protected internal virtual int AdjustSeekIndex(int i);
    protected internal void LazyInit();
    protected internal virtual void Setup();
    public virtual void SetTokenSource(ITokenSource tokenSource);
    public virtual IList`1<IToken> GetTokens();
    public virtual IList`1<IToken> GetTokens(int start, int stop);
    public virtual IList`1<IToken> GetTokens(int start, int stop, BitSet types);
    public virtual IList`1<IToken> GetTokens(int start, int stop, int ttype);
    protected internal virtual int NextTokenOnChannel(int i, int channel);
    protected internal virtual int PreviousTokenOnChannel(int i, int channel);
    public virtual IList`1<IToken> GetHiddenTokensToRight(int tokenIndex, int channel);
    public virtual IList`1<IToken> GetHiddenTokensToRight(int tokenIndex);
    public virtual IList`1<IToken> GetHiddenTokensToLeft(int tokenIndex, int channel);
    public virtual IList`1<IToken> GetHiddenTokensToLeft(int tokenIndex);
    protected internal virtual IList`1<IToken> FilterForChannel(int from, int to, int channel);
    public virtual string get_SourceName();
    public virtual string GetText();
    public virtual string GetText(Interval interval);
    public virtual string GetText(RuleContext ctx);
    public virtual string GetText(IToken start, IToken stop);
    public virtual void Fill();
}
public class Antlr4.Runtime.CommonToken : object {
    private static long serialVersionUID;
    protected internal static Tuple`2<ITokenSource, ICharStream> EmptySource;
    private int _type;
    private int _line;
    protected internal int charPositionInLine;
    private int _channel;
    [NotNullAttribute]
protected internal Tuple`2<ITokenSource, ICharStream> source;
    private string _text;
    protected internal int index;
    protected internal int start;
    protected internal int stop;
    public int Type { get; public set; }
    public int Line { get; public set; }
    public string Text { get; public set; }
    public int Column { get; public set; }
    public int Channel { get; public set; }
    public int StartIndex { get; public set; }
    public int StopIndex { get; public set; }
    public int TokenIndex { get; public set; }
    public ITokenSource TokenSource { get; }
    public ICharStream InputStream { get; }
    public CommonToken(int type);
    public CommonToken(Tuple`2<ITokenSource, ICharStream> source, int type, int channel, int start, int stop);
    public CommonToken(int type, string text);
    public CommonToken(IToken oldToken);
    private static CommonToken();
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual int get_Column();
    public virtual void set_Column(int value);
    public virtual int get_Channel();
    public virtual void set_Channel(int value);
    public virtual int get_StartIndex();
    public virtual void set_StartIndex(int value);
    public virtual int get_StopIndex();
    public virtual void set_StopIndex(int value);
    public virtual int get_TokenIndex();
    public virtual void set_TokenIndex(int value);
    public virtual ITokenSource get_TokenSource();
    public virtual ICharStream get_InputStream();
    public virtual string ToString();
}
public class Antlr4.Runtime.CommonTokenFactory : object {
    public static ITokenFactory Default;
    protected internal bool copyText;
    public CommonTokenFactory(bool copyText);
    private static CommonTokenFactory();
    public virtual CommonToken Create(Tuple`2<ITokenSource, ICharStream> source, int type, string text, int channel, int start, int stop, int line, int charPositionInLine);
    private sealed virtual override IToken Antlr4.Runtime.ITokenFactory.Create(Tuple`2<ITokenSource, ICharStream> source, int type, string text, int channel, int start, int stop, int line, int charPositionInLine);
    public virtual CommonToken Create(int type, string text);
    private sealed virtual override IToken Antlr4.Runtime.ITokenFactory.Create(int type, string text);
}
public class Antlr4.Runtime.CommonTokenStream : BufferedTokenStream {
    protected internal int channel;
    public CommonTokenStream(ITokenSource tokenSource);
    public CommonTokenStream(ITokenSource tokenSource, int channel);
    protected internal virtual int AdjustSeekIndex(int i);
    protected internal virtual IToken Lb(int k);
    public virtual IToken Lt(int k);
    public virtual int GetNumberOfOnChannelTokens();
}
public class Antlr4.Runtime.ConsoleErrorListener`1 : object {
    public static ConsoleErrorListener`1<Symbol> Instance;
    private static ConsoleErrorListener`1();
    public virtual void SyntaxError(IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public class Antlr4.Runtime.DefaultErrorStrategy : object {
    protected internal bool errorRecoveryMode;
    protected internal int lastErrorIndex;
    protected internal IntervalSet lastErrorStates;
    public virtual void Reset(Parser recognizer);
    protected internal virtual void BeginErrorCondition(Parser recognizer);
    public virtual bool InErrorRecoveryMode(Parser recognizer);
    protected internal virtual void EndErrorCondition(Parser recognizer);
    public virtual void ReportMatch(Parser recognizer);
    public virtual void ReportError(Parser recognizer, RecognitionException e);
    protected internal virtual void NotifyErrorListeners(Parser recognizer, string message, RecognitionException e);
    public virtual void Recover(Parser recognizer, RecognitionException e);
    public virtual void Sync(Parser recognizer);
    protected internal virtual void ReportNoViableAlternative(Parser recognizer, NoViableAltException e);
    protected internal virtual void ReportInputMismatch(Parser recognizer, InputMismatchException e);
    protected internal virtual void ReportFailedPredicate(Parser recognizer, FailedPredicateException e);
    protected internal virtual void ReportUnwantedToken(Parser recognizer);
    protected internal virtual void ReportMissingToken(Parser recognizer);
    public virtual IToken RecoverInline(Parser recognizer);
    protected internal virtual bool SingleTokenInsertion(Parser recognizer);
    protected internal virtual IToken SingleTokenDeletion(Parser recognizer);
    protected internal virtual IToken GetMissingSymbol(Parser recognizer);
    protected internal virtual IToken ConstructToken(ITokenSource tokenSource, int expectedTokenType, string tokenText, IToken current);
    protected internal virtual IntervalSet GetExpectedTokens(Parser recognizer);
    protected internal virtual string GetTokenErrorDisplay(IToken t);
    protected internal virtual string GetSymbolText(IToken symbol);
    protected internal virtual int GetSymbolType(IToken symbol);
    protected internal virtual string EscapeWSAndQuote(string s);
    protected internal virtual IntervalSet GetErrorRecoverySet(Parser recognizer);
    protected internal virtual void ConsumeUntil(Parser recognizer, IntervalSet set);
}
[FlagsAttribute]
public enum Antlr4.Runtime.Dependents : Enum {
    public int value__;
    public static Dependents None;
    public static Dependents Self;
    public static Dependents Parents;
    public static Dependents Children;
    public static Dependents Ancestors;
    public static Dependents Descendants;
    public static Dependents Siblings;
    public static Dependents PreceedingSiblings;
    public static Dependents FollowingSiblings;
    public static Dependents Preceeding;
    public static Dependents Following;
}
[DefaultMemberAttribute("Item")]
public abstract class Antlr4.Runtime.Dfa.AbstractEdgeMap`1 : object {
    protected internal int minIndex;
    protected internal int maxIndex;
    public T Item { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    protected AbstractEdgeMap`1(int minIndex, int maxIndex);
    public abstract virtual AbstractEdgeMap`1<T> Put(int key, T value);
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> PutAll(IEdgeMap`1<T> m);
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.PutAll(IEdgeMap`1<T> m);
    public abstract virtual AbstractEdgeMap`1<T> Clear();
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.Clear();
    public abstract virtual AbstractEdgeMap`1<T> Remove(int key);
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.Remove(int key);
    public abstract virtual bool ContainsKey(int arg1);
    public abstract virtual T get_Item(int arg1);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual IDictionary`2<int, T> ToMap();
    public virtual IEnumerator`1<KeyValuePair`2<int, T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Antlr4.Runtime.Dfa.AcceptStateInfo : object {
    private int prediction;
    private LexerActionExecutor lexerActionExecutor;
    public int Prediction { get; }
    public LexerActionExecutor LexerActionExecutor { get; }
    public AcceptStateInfo(int prediction);
    public AcceptStateInfo(int prediction, LexerActionExecutor lexerActionExecutor);
    public virtual int get_Prediction();
    public virtual LexerActionExecutor get_LexerActionExecutor();
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.ArrayEdgeMap`1 : AbstractEdgeMap`1<T> {
    private T[] arrayData;
    private int size;
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public ArrayEdgeMap`1(int minIndex, int maxIndex);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual AbstractEdgeMap`1<T> PutAll(IEdgeMap`1<T> m);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual IDictionary`2<int, T> ToMap();
}
public class Antlr4.Runtime.Dfa.DFA : object {
    [NotNullAttribute]
public ConcurrentDictionary`2<DFAState, DFAState> states;
    [NotNullAttribute]
public AtomicReference`1<DFAState> s0;
    [NotNullAttribute]
public AtomicReference`1<DFAState> s0full;
    public int decision;
    [NotNullAttribute]
public ATNState atnStartState;
    private int nextStateNumber;
    private int minDfaEdge;
    private int maxDfaEdge;
    [NotNullAttribute]
private static EmptyEdgeMap`1<DFAState> emptyPrecedenceEdges;
    [NotNullAttribute]
private EmptyEdgeMap`1<DFAState> emptyEdgeMap;
    [NotNullAttribute]
private EmptyEdgeMap`1<DFAState> emptyContextEdgeMap;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) precedenceDfa;
    public int MinDfaEdge { get; }
    public int MaxDfaEdge { get; }
    public EmptyEdgeMap`1<DFAState> EmptyEdgeMap { get; }
    public EmptyEdgeMap`1<DFAState> EmptyContextEdgeMap { get; }
    public bool IsPrecedenceDfa { get; public set; }
    public bool IsEmpty { get; }
    public bool IsContextSensitive { get; }
    public DFA(ATNState atnStartState);
    public DFA(ATNState atnStartState, int decision);
    private static DFA();
    public int get_MinDfaEdge();
    public int get_MaxDfaEdge();
    public virtual EmptyEdgeMap`1<DFAState> get_EmptyEdgeMap();
    public virtual EmptyEdgeMap`1<DFAState> get_EmptyContextEdgeMap();
    public bool get_IsPrecedenceDfa();
    public void set_IsPrecedenceDfa(bool value);
    public DFAState GetPrecedenceStartState(int precedence, bool fullContext);
    public void SetPrecedenceStartState(int precedence, bool fullContext, DFAState startState);
    public virtual bool get_IsEmpty();
    public virtual bool get_IsContextSensitive();
    public virtual DFAState AddState(DFAState state);
    public virtual string ToString();
    public virtual string ToString(IVocabulary vocabulary);
    public virtual string ToString(IVocabulary vocabulary, String[] ruleNames);
    public virtual string ToLexerString();
}
public class Antlr4.Runtime.Dfa.DFASerializer : object {
    [NotNullAttribute]
private DFA dfa;
    [NotNullAttribute]
private IVocabulary vocabulary;
    [NullableAttribute]
internal String[] ruleNames;
    [NullableAttribute]
internal ATN atn;
    public DFASerializer(DFA dfa, IVocabulary vocabulary);
    public DFASerializer(DFA dfa, IRecognizer parser);
    public DFASerializer(DFA dfa, IVocabulary vocabulary, String[] ruleNames, ATN atn);
    public virtual string ToString();
    protected internal virtual string GetContextLabel(int i);
    protected internal virtual string GetEdgeLabel(int i);
    internal virtual string GetStateString(DFAState s);
}
public class Antlr4.Runtime.Dfa.DFAState : object {
    public int stateNumber;
    [NotNullAttribute]
public ATNConfigSet configs;
    [NotNullAttribute]
private AbstractEdgeMap`1 modreq(System.Runtime.CompilerServices.IsVolatile) edges;
    private AcceptStateInfo acceptStateInfo;
    [NotNullAttribute]
private AbstractEdgeMap`1 modreq(System.Runtime.CompilerServices.IsVolatile) contextEdges;
    [NullableAttribute]
private BitSet contextSymbols;
    [NullableAttribute]
public PredPrediction[] predicates;
    public bool IsContextSensitive { get; }
    public AcceptStateInfo AcceptStateInfo { get; public set; }
    public bool IsAcceptState { get; }
    public int Prediction { get; }
    public LexerActionExecutor LexerActionExecutor { get; }
    public IDictionary`2<int, DFAState> EdgeMap { get; }
    public IDictionary`2<int, DFAState> ContextEdgeMap { get; }
    public DFAState(DFA dfa, ATNConfigSet configs);
    public DFAState(EmptyEdgeMap`1<DFAState> emptyEdges, EmptyEdgeMap`1<DFAState> emptyContextEdges, ATNConfigSet configs);
    public bool get_IsContextSensitive();
    public bool IsContextSymbol(int symbol);
    public void SetContextSymbol(int symbol);
    public virtual void SetContextSensitive(ATN atn);
    public AcceptStateInfo get_AcceptStateInfo();
    public void set_AcceptStateInfo(AcceptStateInfo value);
    public bool get_IsAcceptState();
    public int get_Prediction();
    public LexerActionExecutor get_LexerActionExecutor();
    public virtual DFAState GetTarget(int symbol);
    public virtual void SetTarget(int symbol, DFAState target);
    public virtual IDictionary`2<int, DFAState> get_EdgeMap();
    public virtual DFAState GetContextTarget(int invokingState);
    public virtual void SetContextTarget(int invokingState, DFAState target);
    public virtual IDictionary`2<int, DFAState> get_ContextEdgeMap();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.EmptyEdgeMap`1 : AbstractEdgeMap`1<T> {
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public EmptyEdgeMap`1(int minIndex, int maxIndex);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual IDictionary`2<int, T> ToMap();
}
[DefaultMemberAttribute("Item")]
public interface Antlr4.Runtime.Dfa.IEdgeMap`1 {
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool ContainsKey(int key);
    public abstract virtual T get_Item(int key);
    public abstract virtual IEdgeMap`1<T> Put(int key, T value);
    public abstract virtual IEdgeMap`1<T> Remove(int key);
    public abstract virtual IEdgeMap`1<T> PutAll(IEdgeMap`1<T> m);
    public abstract virtual IEdgeMap`1<T> Clear();
    public abstract virtual IDictionary`2<int, T> ToMap();
}
public class Antlr4.Runtime.Dfa.LexerDFASerializer : DFASerializer {
    public LexerDFASerializer(DFA dfa);
    protected internal virtual string GetEdgeLabel(int i);
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.SingletonEdgeMap`1 : AbstractEdgeMap`1<T> {
    private int key;
    private T value;
    public int Key { get; }
    public T Value { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public SingletonEdgeMap`1(int minIndex, int maxIndex, int key, T value);
    public int get_Key();
    public T get_Value();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual IDictionary`2<int, T> ToMap();
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.SparseEdgeMap`1 : AbstractEdgeMap`1<T> {
    private static int DefaultMaxSize;
    private Int32[] keys;
    private List`1<T> values;
    public Int32[] Keys { get; }
    public IList`1<T> Values { get; }
    public int MaxSparseSize { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public SparseEdgeMap`1(int minIndex, int maxIndex);
    public SparseEdgeMap`1(int minIndex, int maxIndex, int maxSparseSize);
    private SparseEdgeMap`1(SparseEdgeMap`1<T> map, int maxSparseSize);
    public Int32[] get_Keys();
    public IList`1<T> get_Values();
    public int get_MaxSparseSize();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual IDictionary`2<int, T> ToMap();
}
public class Antlr4.Runtime.DiagnosticErrorListener : BaseErrorListener {
    protected internal bool exactOnly;
    public DiagnosticErrorListener(bool exactOnly);
    public virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, SimulatorState conflictState);
    public virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, SimulatorState acceptState);
    protected internal virtual string GetDecisionDescription(Parser recognizer, DFA dfa);
    protected internal virtual BitSet GetConflictingAlts(BitSet reportedAlts, ATNConfigSet configs);
}
public class Antlr4.Runtime.FailedPredicateException : RecognitionException {
    private static long serialVersionUID;
    private int ruleIndex;
    private int predicateIndex;
    private string predicate;
    public int RuleIndex { get; }
    public int PredIndex { get; }
    [NullableAttribute]
public string Predicate { get; }
    public FailedPredicateException(Parser recognizer);
    public FailedPredicateException(Parser recognizer, string predicate);
    public FailedPredicateException(Parser recognizer, string predicate, string message);
    public virtual int get_RuleIndex();
    public virtual int get_PredIndex();
    public virtual string get_Predicate();
    private static string FormatMessage(string predicate, string message);
}
public interface Antlr4.Runtime.IAntlrErrorListener`1 {
    public abstract virtual void SyntaxError(IRecognizer recognizer, TSymbol offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public interface Antlr4.Runtime.IAntlrErrorStrategy {
    public abstract virtual void Reset(Parser recognizer);
    public abstract virtual IToken RecoverInline(Parser recognizer);
    public abstract virtual void Recover(Parser recognizer, RecognitionException e);
    public abstract virtual void Sync(Parser recognizer);
    public abstract virtual bool InErrorRecoveryMode(Parser recognizer);
    public abstract virtual void ReportMatch(Parser recognizer);
    public abstract virtual void ReportError(Parser recognizer, RecognitionException e);
}
public interface Antlr4.Runtime.ICharStream {
    public abstract virtual string GetText(Interval interval);
}
public interface Antlr4.Runtime.IIntStream {
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public abstract virtual void Consume();
    public abstract virtual int La(int i);
    public abstract virtual int Mark();
    public abstract virtual void Release(int marker);
    public abstract virtual int get_Index();
    public abstract virtual void Seek(int index);
    public abstract virtual int get_Size();
    public abstract virtual string get_SourceName();
}
public class Antlr4.Runtime.InputMismatchException : RecognitionException {
    private static long serialVersionUID;
    public InputMismatchException(Parser recognizer);
}
public class Antlr4.Runtime.InterpreterRuleContext : ParserRuleContext {
    private int ruleIndex;
    public int RuleIndex { get; }
    public InterpreterRuleContext(ParserRuleContext parent, int invokingStateNumber, int ruleIndex);
    public virtual int get_RuleIndex();
}
public static class Antlr4.Runtime.IntStreamConstants : object {
    public static int Eof;
    public static string UnknownSourceName;
}
public interface Antlr4.Runtime.IParserErrorListener {
    public abstract virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public abstract virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, SimulatorState conflictState);
    public abstract virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, SimulatorState acceptState);
}
public interface Antlr4.Runtime.IRecognizer {
    public IVocabulary Vocabulary { get; }
    public String[] RuleNames { get; }
    public string GrammarFileName { get; }
    public ATN Atn { get; }
    public int State { get; }
    public IIntStream InputStream { get; }
    public abstract virtual IVocabulary get_Vocabulary();
    public abstract virtual String[] get_RuleNames();
    public abstract virtual string get_GrammarFileName();
    public abstract virtual ATN get_Atn();
    public abstract virtual int get_State();
    public abstract virtual IIntStream get_InputStream();
}
public interface Antlr4.Runtime.IToken {
    public string Text { get; }
    public int Type { get; }
    public int Line { get; }
    public int Column { get; }
    public int Channel { get; }
    public int TokenIndex { get; }
    public int StartIndex { get; }
    public int StopIndex { get; }
    public ITokenSource TokenSource { get; }
    public ICharStream InputStream { get; }
    public abstract virtual string get_Text();
    public abstract virtual int get_Type();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public abstract virtual int get_Channel();
    public abstract virtual int get_TokenIndex();
    public abstract virtual int get_StartIndex();
    public abstract virtual int get_StopIndex();
    public abstract virtual ITokenSource get_TokenSource();
    public abstract virtual ICharStream get_InputStream();
}
public interface Antlr4.Runtime.ITokenFactory {
    public abstract virtual IToken Create(Tuple`2<ITokenSource, ICharStream> source, int type, string text, int channel, int start, int stop, int line, int charPositionInLine);
    public abstract virtual IToken Create(int type, string text);
}
public interface Antlr4.Runtime.ITokenSource {
    public int Line { get; }
    public int Column { get; }
    public ICharStream InputStream { get; }
    public string SourceName { get; }
    public ITokenFactory TokenFactory { get; public set; }
    public abstract virtual IToken NextToken();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public abstract virtual ICharStream get_InputStream();
    public abstract virtual string get_SourceName();
    public abstract virtual ITokenFactory get_TokenFactory();
    public abstract virtual void set_TokenFactory(ITokenFactory value);
}
public interface Antlr4.Runtime.ITokenStream {
    public ITokenSource TokenSource { get; }
    public abstract virtual IToken Lt(int k);
    public abstract virtual IToken Get(int i);
    public abstract virtual ITokenSource get_TokenSource();
    public abstract virtual string GetText(Interval interval);
    public abstract virtual string GetText();
    public abstract virtual string GetText(RuleContext ctx);
    public abstract virtual string GetText(IToken start, IToken stop);
}
public interface Antlr4.Runtime.IVocabulary {
    public abstract virtual string GetLiteralName(int tokenType);
    public abstract virtual string GetSymbolicName(int tokenType);
    public abstract virtual string GetDisplayName(int tokenType);
}
public interface Antlr4.Runtime.IWritableToken {
    unknown string Text {public set; }
    unknown int Type {public set; }
    unknown int Line {public set; }
    unknown int Column {public set; }
    unknown int Channel {public set; }
    unknown int TokenIndex {public set; }
    public abstract virtual void set_Text(string value);
    public abstract virtual void set_Type(int value);
    public abstract virtual void set_Line(int value);
    public abstract virtual void set_Column(int value);
    public abstract virtual void set_Channel(int value);
    public abstract virtual void set_TokenIndex(int value);
}
public abstract class Antlr4.Runtime.Lexer : Recognizer`2<int, LexerATNSimulator> {
    public static int DefaultMode;
    public static int DefaultTokenChannel;
    public static int Hidden;
    public static int MinCharValue;
    public static int MaxCharValue;
    private ICharStream _input;
    private Tuple`2<ITokenSource, ICharStream> _tokenFactorySourcePair;
    private ITokenFactory _factory;
    private IToken _token;
    private int _tokenStartCharIndex;
    private int _tokenStartLine;
    private int _tokenStartColumn;
    private bool _hitEOF;
    private int _channel;
    private int _type;
    private Stack`1<int> _modeStack;
    private int _mode;
    private string _text;
    public ITokenFactory TokenFactory { get; public set; }
    public string SourceName { get; }
    public IIntStream InputStream { get; }
    private ICharStream Antlr4.Runtime.ITokenSource.InputStream { get; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public int CharIndex { get; }
    public int TokenStartCharIndex { get; }
    public int TokenStartLine { get; }
    public int TokenStartColumn { get; }
    public string Text { get; public set; }
    public IToken Token { get; public set; }
    public int Type { get; public set; }
    public int Channel { get; public set; }
    public Stack`1<int> ModeStack { get; }
    public int CurrentMode { get; public set; }
    public bool HitEOF { get; public set; }
    public String[] ModeNames { get; }
    public Lexer(ICharStream input);
    public virtual void Reset();
    public virtual IToken NextToken();
    public virtual void Skip();
    public virtual void More();
    public virtual void Mode(int m);
    public virtual void PushMode(int m);
    public virtual int PopMode();
    public virtual ITokenFactory get_TokenFactory();
    public virtual void set_TokenFactory(ITokenFactory value);
    public virtual void SetInputStream(ICharStream input);
    public virtual string get_SourceName();
    public virtual IIntStream get_InputStream();
    private sealed virtual override ICharStream Antlr4.Runtime.ITokenSource.get_InputStream();
    public virtual void Emit(IToken token);
    public virtual IToken Emit();
    public virtual IToken EmitEOF();
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual int get_Column();
    public virtual void set_Column(int value);
    public virtual int get_CharIndex();
    public virtual int get_TokenStartCharIndex();
    public virtual int get_TokenStartLine();
    public virtual int get_TokenStartColumn();
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual IToken get_Token();
    public virtual void set_Token(IToken value);
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual int get_Channel();
    public virtual void set_Channel(int value);
    public virtual Stack`1<int> get_ModeStack();
    public virtual int get_CurrentMode();
    public virtual void set_CurrentMode(int value);
    public virtual bool get_HitEOF();
    public virtual void set_HitEOF(bool value);
    public virtual String[] get_ModeNames();
    public virtual IList`1<IToken> GetAllTokens();
    public virtual void Recover(LexerNoViableAltException e);
    public virtual void NotifyListeners(LexerNoViableAltException e);
    public virtual string GetErrorDisplay(string s);
    public virtual string GetErrorDisplay(int c);
    public virtual string GetCharErrorDisplay(int c);
    public virtual void Recover(RecognitionException re);
}
public class Antlr4.Runtime.LexerInterpreter : Lexer {
    private string grammarFileName;
    private ATN atn;
    private String[] ruleNames;
    private String[] modeNames;
    [NotNullAttribute]
private IVocabulary vocabulary;
    public ATN Atn { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public String[] ModeNames { get; }
    public IVocabulary Vocabulary { get; }
    public LexerInterpreter(string grammarFileName, IVocabulary vocabulary, IEnumerable`1<string> ruleNames, IEnumerable`1<string> modeNames, ATN atn, ICharStream input);
    public virtual ATN get_Atn();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual String[] get_ModeNames();
    public virtual IVocabulary get_Vocabulary();
}
public class Antlr4.Runtime.LexerNoViableAltException : RecognitionException {
    private static long serialVersionUID;
    private int startIndex;
    [NullableAttribute]
private ATNConfigSet deadEndConfigs;
    public int StartIndex { get; }
    [NullableAttribute]
public ATNConfigSet DeadEndConfigs { get; }
    public IIntStream InputStream { get; }
    public LexerNoViableAltException(Lexer lexer, ICharStream input, int startIndex, ATNConfigSet deadEndConfigs);
    public virtual int get_StartIndex();
    public virtual ATNConfigSet get_DeadEndConfigs();
    public virtual IIntStream get_InputStream();
    public virtual string ToString();
}
public class Antlr4.Runtime.ListTokenSource : object {
    protected internal IList`1<IToken> tokens;
    private string sourceName;
    protected internal int i;
    protected internal IToken eofToken;
    private ITokenFactory _factory;
    public int Column { get; }
    public int Line { get; }
    public ICharStream InputStream { get; }
    public string SourceName { get; }
    public ITokenFactory TokenFactory { get; public set; }
    public ListTokenSource(IList`1<IToken> tokens);
    public ListTokenSource(IList`1<IToken> tokens, string sourceName);
    public virtual int get_Column();
    public virtual IToken NextToken();
    public virtual int get_Line();
    public virtual ICharStream get_InputStream();
    public virtual string get_SourceName();
    public virtual ITokenFactory get_TokenFactory();
    public virtual void set_TokenFactory(ITokenFactory value);
}
public static class Antlr4.Runtime.Misc.Args : object {
    public static void NotNull(string parameterName, object value);
}
public interface Antlr4.Runtime.Misc.IIntSet {
    public int Count { get; }
    public bool IsNil { get; }
    public int SingleElement { get; }
    public abstract virtual void Add(int el);
    public abstract virtual IIntSet AddAll(IIntSet set);
    public abstract virtual IIntSet And(IIntSet a);
    public abstract virtual IIntSet Complement(IIntSet elements);
    public abstract virtual IIntSet Or(IIntSet a);
    public abstract virtual IIntSet Subtract(IIntSet a);
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsNil();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int get_SingleElement();
    public abstract virtual bool Contains(int el);
    public abstract virtual void Remove(int el);
    public abstract virtual IList`1<int> ToList();
    public abstract virtual string ToString();
}
public class Antlr4.Runtime.Misc.Interval : ValueType {
    public static Interval Invalid;
    public int a;
    public int b;
    public int Length { get; }
    public Interval(int a, int b);
    private static Interval();
    public static Interval Of(int a, int b);
    public int get_Length();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public bool StartsBeforeDisjoint(Interval other);
    public bool StartsBeforeNonDisjoint(Interval other);
    public bool StartsAfter(Interval other);
    public bool StartsAfterDisjoint(Interval other);
    public bool StartsAfterNonDisjoint(Interval other);
    public bool Disjoint(Interval other);
    public bool Adjacent(Interval other);
    public bool ProperlyContains(Interval other);
    public Interval Union(Interval other);
    public Interval Intersection(Interval other);
    public Nullable`1<Interval> DifferenceNotProperlyContained(Interval other);
    public virtual string ToString();
}
public class Antlr4.Runtime.Misc.IntervalSet : object {
    public static IntervalSet CompleteCharSet;
    public static IntervalSet EmptySet;
    protected internal IList`1<Interval> intervals;
    protected internal bool readonly;
    public bool IsNil { get; }
    public int SingleElement { get; }
    public int MaxElement { get; }
    public int MinElement { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private static IntervalSet();
    public IntervalSet(IList`1<Interval> intervals);
    public IntervalSet(IntervalSet set);
    public IntervalSet(Int32[] els);
    public static IntervalSet Of(int a);
    public static IntervalSet Of(int a, int b);
    public virtual void Clear();
    public virtual void Add(int el);
    public virtual void Add(int a, int b);
    protected internal virtual void Add(Interval addition);
    public static IntervalSet Or(IntervalSet[] sets);
    public virtual IntervalSet AddAll(IIntSet set);
    public virtual IntervalSet Complement(int minElement, int maxElement);
    public virtual IntervalSet Complement(IIntSet vocabulary);
    public virtual IntervalSet Subtract(IIntSet a);
    public static IntervalSet Subtract(IntervalSet left, IntervalSet right);
    public virtual IntervalSet Or(IIntSet a);
    public virtual IntervalSet And(IIntSet other);
    public virtual bool Contains(int el);
    public virtual bool get_IsNil();
    public virtual int get_SingleElement();
    public virtual int get_MaxElement();
    public virtual int get_MinElement();
    public virtual IList`1<Interval> GetIntervals();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual string ToString(bool elemAreChar);
    public virtual string ToString(IVocabulary vocabulary);
    protected internal virtual string ElementName(IVocabulary vocabulary, int a);
    public virtual int get_Count();
    public virtual List`1<int> ToIntegerList();
    public virtual IList`1<int> ToList();
    public virtual HashSet`1<int> ToSet();
    public virtual Int32[] ToArray();
    public virtual void Remove(int el);
    public virtual bool get_IsReadOnly();
    public virtual void SetReadonly(bool readonly);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.AddAll(IIntSet set);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.And(IIntSet a);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.Complement(IIntSet elements);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.Or(IIntSet a);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.Subtract(IIntSet a);
}
public class Antlr4.Runtime.Misc.MultiMap`2 : Dictionary`2<K, IList`1<V>> {
    private static long serialVersionUID;
    public virtual void Map(K key, V value);
    public virtual IList`1<Tuple`2<K, V>> GetPairs();
}
public class Antlr4.Runtime.Misc.MurmurHash : object {
    private static int DefaultSeed;
    public static int Initialize();
    public static int Initialize(int seed);
    public static int Update(int hash, int value);
    public static int Update(int hash, object value);
    public static int Finish(int hash, int numberOfWords);
    public static int HashCode(T[] data, int seed);
}
[AttributeUsageAttribute("10624")]
public class Antlr4.Runtime.Misc.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10624")]
public class Antlr4.Runtime.Misc.NullableAttribute : Attribute {
}
public class Antlr4.Runtime.Misc.ParseCanceledException : OperationCanceledException {
    public ParseCanceledException(string message);
    public ParseCanceledException(Exception cause);
    public ParseCanceledException(string message, Exception cause);
}
public class Antlr4.Runtime.Misc.RuleDependencyChecker : object {
    private static BindingFlags AllDeclaredStaticMembers;
    private static BindingFlags AllDeclaredMembers;
    private static HashSet`1<string> checkedAssemblies;
    private static Dependents ImplementedDependents;
    private static RuleDependencyChecker();
    public static void CheckDependencies(Assembly assembly);
    private static IList`1<Type> GetTypesToCheck(Assembly assembly);
    private static bool IsChecked(Assembly assembly);
    private static void MarkChecked(Assembly assembly);
    private static void CheckDependencies(IList`1<Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider>> dependencies, Type recognizerType);
    private static void ReportUnimplementedDependents(StringBuilder errors, Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider> dependency, Dependents dependents);
    private static int CheckDependencyVersion(StringBuilder errors, Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider> dependency, String[] ruleNames, Int32[] ruleVersions, int relatedRule, string relation);
    private static Int32[] GetRuleVersions(Type recognizerClass, String[] ruleNames);
    private static MethodInfo GetRuleMethod(Type recognizerClass, string name);
    private static String[] GetRuleNames(Type recognizerClass);
    public static IList`1<Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider>> GetDependencies(Type clazz);
    private static void GetElementDependencies(ICustomAttributeProvider annotatedElement, IList`1<Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider>> result);
    private static RuleRelations ExtractRuleRelations(Type recognizer);
    private static string GetSerializedATN(Type recognizerClass);
    protected static ICustomAttributeProvider AsCustomAttributeProvider(ICustomAttributeProvider obj);
}
public class Antlr4.Runtime.Misc.Utils : object {
    public static string Join(string separator, IEnumerable`1<T> items);
    public static int NumNonnull(Object[] data);
    public static void RemoveAllElements(ICollection`1<T> data, T value);
    public static string EscapeWhitespace(string s, bool escapeSpaces);
    public static void RemoveAll(IList`1<T> list, Predicate`1<T> predicate);
    public static IDictionary`2<string, int> ToMap(String[] keys);
    public static Char[] ToCharArray(List`1<int> data);
}
public class Antlr4.Runtime.NoViableAltException : RecognitionException {
    private static long serialVersionUID;
    [NullableAttribute]
private ATNConfigSet deadEndConfigs;
    [NotNullAttribute]
private IToken startToken;
    public IToken StartToken { get; }
    [NullableAttribute]
public ATNConfigSet DeadEndConfigs { get; }
    public NoViableAltException(Parser recognizer);
    public NoViableAltException(IRecognizer recognizer, ITokenStream input, IToken startToken, IToken offendingToken, ATNConfigSet deadEndConfigs, ParserRuleContext ctx);
    public virtual IToken get_StartToken();
    public virtual ATNConfigSet get_DeadEndConfigs();
}
public abstract class Antlr4.Runtime.Parser : Recognizer`2<IToken, ParserATNSimulator> {
    private static IDictionary`2<string, ATN> bypassAltsAtnCache;
    [NotNullAttribute]
private IAntlrErrorStrategy _errHandler;
    private ITokenStream _input;
    private List`1<int> _precedenceStack;
    private ParserRuleContext _ctx;
    private bool _buildParseTrees;
    private TraceListener _tracer;
    [NullableAttribute]
private IList`1<IParseTreeListener> _parseListeners;
    private int _syntaxErrors;
    public bool BuildParseTree { get; public set; }
    public bool TrimParseTree { get; public set; }
    public IList`1<IParseTreeListener> ParseListeners { get; }
    public int NumberOfSyntaxErrors { get; }
    public ITokenFactory TokenFactory { get; }
    public IAntlrErrorStrategy ErrorHandler { get; public set; }
    public IIntStream InputStream { get; }
    public ITokenStream TokenStream { get; public set; }
    public IToken CurrentToken { get; }
    public int Precedence { get; }
    public ParserRuleContext Context { get; public set; }
    public IAntlrErrorListener`1<IToken> ErrorListenerDispatch { get; }
    public ParserRuleContext RuleContext { get; }
    public string SourceName { get; }
    public ParseInfo ParseInfo { get; }
    unknown bool Profile {public set; }
    public bool Trace { get; public set; }
    public Parser(ITokenStream input);
    private static Parser();
    public virtual void Reset();
    public virtual IToken Match(int ttype);
    public virtual IToken MatchWildcard();
    public virtual bool get_BuildParseTree();
    public virtual void set_BuildParseTree(bool value);
    public virtual bool get_TrimParseTree();
    public virtual void set_TrimParseTree(bool value);
    public virtual IList`1<IParseTreeListener> get_ParseListeners();
    public virtual void AddParseListener(IParseTreeListener listener);
    public virtual void RemoveParseListener(IParseTreeListener listener);
    public virtual void RemoveParseListeners();
    protected internal virtual void TriggerEnterRuleEvent();
    protected internal virtual void TriggerExitRuleEvent();
    public virtual int get_NumberOfSyntaxErrors();
    public virtual ITokenFactory get_TokenFactory();
    public virtual ATN GetATNWithBypassAlts();
    public virtual ParseTreePattern CompileParseTreePattern(string pattern, int patternRuleIndex);
    public virtual ParseTreePattern CompileParseTreePattern(string pattern, int patternRuleIndex, Lexer lexer);
    public virtual IAntlrErrorStrategy get_ErrorHandler();
    public virtual void set_ErrorHandler(IAntlrErrorStrategy value);
    public virtual IIntStream get_InputStream();
    public ITokenStream get_TokenStream();
    public void set_TokenStream(ITokenStream value);
    public virtual IToken get_CurrentToken();
    public void NotifyErrorListeners(string msg);
    public virtual void NotifyErrorListeners(IToken offendingToken, string msg, RecognitionException e);
    public virtual IToken Consume();
    protected internal virtual void AddContextToParseTree();
    public virtual void EnterRule(ParserRuleContext localctx, int state, int ruleIndex);
    public virtual void EnterLeftFactoredRule(ParserRuleContext localctx, int state, int ruleIndex);
    public virtual void ExitRule();
    public virtual void EnterOuterAlt(ParserRuleContext localctx, int altNum);
    public int get_Precedence();
    [ObsoleteAttribute("UseEnterRecursionRule(ParserRuleContext, int, int, int) instead.")]
public virtual void EnterRecursionRule(ParserRuleContext localctx, int ruleIndex);
    public virtual void EnterRecursionRule(ParserRuleContext localctx, int state, int ruleIndex, int precedence);
    public virtual void PushNewRecursionContext(ParserRuleContext localctx, int state, int ruleIndex);
    public virtual void UnrollRecursionContexts(ParserRuleContext _parentctx);
    public virtual ParserRuleContext GetInvokingContext(int ruleIndex);
    public virtual ParserRuleContext get_Context();
    public virtual void set_Context(ParserRuleContext value);
    public virtual bool Precpred(RuleContext localctx, int precedence);
    public virtual IAntlrErrorListener`1<IToken> get_ErrorListenerDispatch();
    public virtual bool InContext(string context);
    public virtual bool IsExpectedToken(int symbol);
    public virtual IntervalSet GetExpectedTokens();
    public virtual IntervalSet GetExpectedTokensWithinCurrentRule();
    public virtual int GetRuleIndex(string ruleName);
    public virtual ParserRuleContext get_RuleContext();
    public virtual IList`1<string> GetRuleInvocationStack();
    public virtual string GetRuleInvocationStackAsString();
    public virtual IList`1<string> GetRuleInvocationStack(RuleContext p);
    public virtual IList`1<string> GetDFAStrings();
    public virtual void DumpDFA();
    public virtual string get_SourceName();
    public virtual ParseInfo get_ParseInfo();
    public virtual void set_Profile(bool value);
    public virtual bool get_Trace();
    public virtual void set_Trace(bool value);
}
public class Antlr4.Runtime.ParserInterpreter : Parser {
    private string _grammarFileName;
    private ATN _atn;
    protected internal BitSet pushRecursionContextStates;
    private String[] _ruleNames;
    [NotNullAttribute]
private IVocabulary vocabulary;
    private Stack`1<Tuple`2<ParserRuleContext, int>> _parentContextStack;
    public ATN Atn { get; }
    public IVocabulary Vocabulary { get; }
    public String[] RuleNames { get; }
    public string GrammarFileName { get; }
    protected internal ATNState AtnState { get; }
    public ParserInterpreter(string grammarFileName, IVocabulary vocabulary, IEnumerable`1<string> ruleNames, ATN atn, ITokenStream input);
    public virtual ATN get_Atn();
    public virtual IVocabulary get_Vocabulary();
    public virtual String[] get_RuleNames();
    public virtual string get_GrammarFileName();
    public virtual ParserRuleContext Parse(int startRuleIndex);
    public virtual void EnterRecursionRule(ParserRuleContext localctx, int state, int ruleIndex, int precedence);
    protected internal virtual ATNState get_AtnState();
    protected internal virtual void VisitState(ATNState p);
    protected internal virtual void VisitRuleStopState(ATNState p);
}
public class Antlr4.Runtime.ParserRuleContext : RuleContext {
    private static ParserRuleContext Empty;
    public IList`1<IParseTree> children;
    private IToken _start;
    private IToken _stop;
    public RecognitionException exception;
    public static ParserRuleContext EmptyContext { get; }
    public int ChildCount { get; }
    public Interval SourceInterval { get; }
    public IToken Start { get; public set; }
    public IToken Stop { get; public set; }
    public ParserRuleContext(ParserRuleContext parent, int invokingStateNumber);
    private static ParserRuleContext();
    public static ParserRuleContext get_EmptyContext();
    public virtual void CopyFrom(ParserRuleContext ctx);
    public virtual void EnterRule(IParseTreeListener listener);
    public virtual void ExitRule(IParseTreeListener listener);
    public virtual void AddChild(ITerminalNode t);
    public virtual void AddChild(RuleContext ruleInvocation);
    public virtual void RemoveLastChild();
    public virtual ITerminalNode AddChild(IToken matchedToken);
    public virtual IErrorNode AddErrorNode(IToken badToken);
    public virtual IParseTree GetChild(int i);
    public virtual T GetChild(int i);
    public virtual ITerminalNode GetToken(int ttype, int i);
    public virtual ITerminalNode[] GetTokens(int ttype);
    public virtual T GetRuleContext(int i);
    public virtual T[] GetRuleContexts();
    public virtual int get_ChildCount();
    public virtual Interval get_SourceInterval();
    public virtual IToken get_Start();
    public virtual void set_Start(IToken value);
    public virtual IToken get_Stop();
    public virtual void set_Stop(IToken value);
    public virtual string ToInfoString(Parser recognizer);
}
public class Antlr4.Runtime.ProxyErrorListener`1 : object {
    private IEnumerable`1<IAntlrErrorListener`1<Symbol>> delegates;
    protected internal IEnumerable`1<IAntlrErrorListener`1<Symbol>> Delegates { get; }
    public ProxyErrorListener`1(IEnumerable`1<IAntlrErrorListener`1<Symbol>> delegates);
    protected internal virtual IEnumerable`1<IAntlrErrorListener`1<Symbol>> get_Delegates();
    public virtual void SyntaxError(IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public class Antlr4.Runtime.ProxyParserErrorListener : ProxyErrorListener`1<IToken> {
    public ProxyParserErrorListener(ICollection`1<IAntlrErrorListener`1<IToken>> delegates);
    public virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, SimulatorState conflictState);
    public virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, SimulatorState acceptState);
}
public class Antlr4.Runtime.RecognitionException : Exception {
    private static long serialVersionUID;
    [NullableAttribute]
private IRecognizer recognizer;
    [NullableAttribute]
private RuleContext ctx;
    [NullableAttribute]
private IIntStream input;
    private IToken offendingToken;
    private int offendingState;
    public int OffendingState { get; protected set; }
    public RuleContext Context { get; }
    public IIntStream InputStream { get; }
    public IToken OffendingToken { get; protected set; }
    public IRecognizer Recognizer { get; }
    public RecognitionException(Lexer lexer, ICharStream input);
    public RecognitionException(IRecognizer recognizer, IIntStream input, ParserRuleContext ctx);
    public RecognitionException(string message, IRecognizer recognizer, IIntStream input, ParserRuleContext ctx);
    public int get_OffendingState();
    protected void set_OffendingState(int value);
    public virtual IntervalSet GetExpectedTokens();
    public virtual RuleContext get_Context();
    public virtual IIntStream get_InputStream();
    public IToken get_OffendingToken();
    protected void set_OffendingToken(IToken value);
    public virtual IRecognizer get_Recognizer();
}
public abstract class Antlr4.Runtime.Recognizer`2 : object {
    public static int Eof;
    private static ConditionalWeakTable`2<IVocabulary, IDictionary`2<string, int>> tokenTypeMapCache;
    private static ConditionalWeakTable`2<String[], IDictionary`2<string, int>> ruleIndexMapCache;
    [NotNullAttribute]
private IAntlrErrorListener`1[] _listeners;
    private ATNInterpreter _interp;
    private int _stateNumber;
    public String[] RuleNames { get; }
    public IVocabulary Vocabulary { get; }
    [NotNullAttribute]
public IDictionary`2<string, int> TokenTypeMap { get; }
    [NotNullAttribute]
public IDictionary`2<string, int> RuleIndexMap { get; }
    public string SerializedAtn { get; }
    public string GrammarFileName { get; }
    public ATN Atn { get; }
    public ATNInterpreter Interpreter { get; protected set; }
    public ParseInfo ParseInfo { get; }
    [NotNullAttribute]
public IList`1<IAntlrErrorListener`1<Symbol>> ErrorListeners { get; }
    public IAntlrErrorListener`1<Symbol> ErrorListenerDispatch { get; }
    public int State { get; public set; }
    public IIntStream InputStream { get; }
    private static Recognizer`2();
    public abstract virtual String[] get_RuleNames();
    public abstract virtual IVocabulary get_Vocabulary();
    public virtual IDictionary`2<string, int> get_TokenTypeMap();
    protected virtual IDictionary`2<string, int> CreateTokenTypeMap(IVocabulary vocabulary);
    public virtual IDictionary`2<string, int> get_RuleIndexMap();
    public virtual int GetTokenType(string tokenName);
    public virtual string get_SerializedAtn();
    public abstract virtual string get_GrammarFileName();
    public virtual ATN get_Atn();
    public virtual ATNInterpreter get_Interpreter();
    protected virtual void set_Interpreter(ATNInterpreter value);
    public virtual ParseInfo get_ParseInfo();
    public virtual string GetErrorHeader(RecognitionException e);
    [ObsoleteAttribute("This method is not called by the ANTLR 4 Runtime. Specific implementations of IAntlrErrorStrategy may provide a similar feature when necessary. For example, see DefaultErrorStrategy.GetTokenErrorDisplay(IToken).")]
public virtual string GetTokenErrorDisplay(IToken t);
    public virtual void AddErrorListener(IAntlrErrorListener`1<Symbol> listener);
    public virtual void RemoveErrorListener(IAntlrErrorListener`1<Symbol> listener);
    public virtual void RemoveErrorListeners();
    public virtual IList`1<IAntlrErrorListener`1<Symbol>> get_ErrorListeners();
    public virtual IAntlrErrorListener`1<Symbol> get_ErrorListenerDispatch();
    public virtual bool Sempred(RuleContext _localctx, int ruleIndex, int actionIndex);
    public virtual bool Precpred(RuleContext localctx, int precedence);
    public virtual void Action(RuleContext _localctx, int ruleIndex, int actionIndex);
    public sealed virtual int get_State();
    public void set_State(int value);
    public abstract virtual IIntStream get_InputStream();
}
public class Antlr4.Runtime.RuleContext : object {
    private RuleContext _parent;
    public int invokingState;
    public bool IsEmpty { get; }
    public Interval SourceInterval { get; }
    private RuleContext Antlr4.Runtime.Tree.IRuleNode.RuleContext { get; }
    public RuleContext Parent { get; public set; }
    private IRuleNode Antlr4.Runtime.Tree.IRuleNode.Parent { get; }
    private IParseTree Antlr4.Runtime.Tree.IParseTree.Parent { get; }
    private ITree Antlr4.Runtime.Tree.ITree.Parent { get; }
    public RuleContext Payload { get; }
    private object Antlr4.Runtime.Tree.ITree.Payload { get; }
    public int RuleIndex { get; }
    public int ChildCount { get; }
    public RuleContext(RuleContext parent, int invokingState);
    public static RuleContext GetChildContext(RuleContext parent, int invokingState);
    public virtual int Depth();
    public virtual bool get_IsEmpty();
    public virtual Interval get_SourceInterval();
    private sealed virtual override RuleContext Antlr4.Runtime.Tree.IRuleNode.get_RuleContext();
    public virtual RuleContext get_Parent();
    public virtual void set_Parent(RuleContext value);
    private sealed virtual override IRuleNode Antlr4.Runtime.Tree.IRuleNode.get_Parent();
    private sealed virtual override IParseTree Antlr4.Runtime.Tree.IParseTree.get_Parent();
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.get_Parent();
    public virtual RuleContext get_Payload();
    private sealed virtual override object Antlr4.Runtime.Tree.ITree.get_Payload();
    public virtual string GetText();
    public virtual int get_RuleIndex();
    public virtual IParseTree GetChild(int i);
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.GetChild(int i);
    public virtual int get_ChildCount();
    public virtual T Accept(IParseTreeVisitor`1<T> visitor);
    public virtual string ToStringTree(Parser recog);
    public virtual string ToStringTree(IList`1<string> ruleNames);
    public virtual string ToStringTree();
    public virtual string ToString();
    public string ToString(IRecognizer recog);
    public string ToString(IList`1<string> ruleNames);
    public virtual string ToString(IRecognizer recog, RuleContext stop);
    public virtual string ToString(IList`1<string> ruleNames, RuleContext stop);
}
[AttributeUsageAttribute("32767")]
public class Antlr4.Runtime.RuleDependencyAttribute : Attribute {
    private Type _recognizer;
    private int _rule;
    private int _version;
    private Dependents _dependents;
    public Type Recognizer { get; }
    public int Rule { get; }
    public int Version { get; }
    public Dependents Dependents { get; }
    public RuleDependencyAttribute(Type recognizer, int rule, int version);
    public RuleDependencyAttribute(Type recognizer, int rule, int version, Dependents dependents);
    public Type get_Recognizer();
    public int get_Rule();
    public int get_Version();
    public Dependents get_Dependents();
}
[AttributeUsageAttribute("64")]
public class Antlr4.Runtime.RuleVersionAttribute : Attribute {
    private int _version;
    public int Version { get; }
    public RuleVersionAttribute(int version);
    public int get_Version();
}
internal static class Antlr4.Runtime.Sharpen.Arrays : object {
    public static T[] CopyOf(T[] array, int newSize);
    public static IList`1<T> AsList(T[] array);
    public static void Fill(T[] array, T value);
    public static int HashCode(T[] array);
    public static bool Equals(T[] left, T[] right);
    public static string ToString(T[] array);
}
public class Antlr4.Runtime.Sharpen.AtomicReference`1 : object {
    private T modreq(System.Runtime.CompilerServices.IsVolatile) _value;
    public AtomicReference`1(T value);
    public T Get();
    public void Set(T value);
    public bool CompareAndSet(T expect, T update);
    public T GetAndSet(T value);
}
public class Antlr4.Runtime.Sharpen.BitSet : object {
    private static UInt64[] EmptyBits;
    private static int BitsPerElement;
    private UInt64[] _data;
    private static Int32[] index64;
    public BitSet(int nbits);
    private static BitSet();
    private static int GetBitCount(UInt64[] value);
    private static int BitScanForward(ulong value);
    public BitSet Clone();
    public void Clear(int index);
    public bool Get(int index);
    public void Set(int index);
    public bool IsEmpty();
    public int Cardinality();
    public int NextSetBit(int fromIndex);
    public void And(BitSet set);
    public void Or(BitSet set);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class Antlr4.Runtime.Sharpen.Collections : object {
    public static T[] EmptyList();
    public static IDictionary`2<TKey, TValue> EmptyMap();
    public static ReadOnlyCollection`1<T> SingletonList(T item);
    public static IDictionary`2<TKey, TValue> SingletonMap(TKey key, TValue value);
}
[ExtensionAttribute]
internal static class Antlr4.Runtime.Sharpen.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue Get(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue Put(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
}
public class Antlr4.Runtime.Sharpen.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class Antlr4.Runtime.Sharpen.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class Antlr4.Runtime.Sharpen.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class Antlr4.Runtime.Sharpen.ListExtensions : object {
    [ExtensionAttribute]
public static T Set(IList`1<T> list, int index, T value);
}
internal static class Antlr4.Runtime.Sharpen.Runtime : object {
    public static string Substring(string str, int beginOffset, int endOffset);
}
internal class Antlr4.Runtime.Sharpen.SequenceEqualityComparer`1 : EqualityComparer`1<IEnumerable`1<T>> {
    private static SequenceEqualityComparer`1<T> _default;
    private IEqualityComparer`1<T> _elementEqualityComparer;
    public static SequenceEqualityComparer`1<T> Default { get; }
    public SequenceEqualityComparer`1(IEqualityComparer`1<T> elementComparer);
    private static SequenceEqualityComparer`1();
    public static SequenceEqualityComparer`1<T> get_Default();
    public virtual bool Equals(IEnumerable`1<T> x, IEnumerable`1<T> y);
    public virtual int GetHashCode(IEnumerable`1<T> obj);
}
public static class Antlr4.Runtime.TokenConstants : object {
    public static int InvalidType;
    public static int Epsilon;
    public static int MinUserTokenType;
    public static int Eof;
    public static int DefaultChannel;
    public static int HiddenChannel;
    public static int MinUserChannelValue;
}
public class Antlr4.Runtime.TokenStreamRewriter : object {
    public static string DefaultProgramName;
    public static int ProgramInitSize;
    public static int MinTokenIndex;
    protected internal ITokenStream tokens;
    protected internal IDictionary`2<string, IList`1<RewriteOperation>> programs;
    protected internal IDictionary`2<string, int> lastRewriteTokenIndexes;
    public ITokenStream TokenStream { get; }
    public int LastRewriteTokenIndex { get; }
    public TokenStreamRewriter(ITokenStream tokens);
    public ITokenStream get_TokenStream();
    public virtual void Rollback(int instructionIndex);
    public virtual void Rollback(string programName, int instructionIndex);
    public virtual void DeleteProgram();
    public virtual void DeleteProgram(string programName);
    public virtual void InsertAfter(IToken t, object text);
    public virtual void InsertAfter(int index, object text);
    public virtual void InsertAfter(string programName, IToken t, object text);
    public virtual void InsertAfter(string programName, int index, object text);
    public virtual void InsertBefore(IToken t, object text);
    public virtual void InsertBefore(int index, object text);
    public virtual void InsertBefore(string programName, IToken t, object text);
    public virtual void InsertBefore(string programName, int index, object text);
    public virtual void Replace(int index, object text);
    public virtual void Replace(int from, int to, object text);
    public virtual void Replace(IToken indexT, object text);
    public virtual void Replace(IToken from, IToken to, object text);
    public virtual void Replace(string programName, int from, int to, object text);
    public virtual void Replace(string programName, IToken from, IToken to, object text);
    public virtual void Delete(int index);
    public virtual void Delete(int from, int to);
    public virtual void Delete(IToken indexT);
    public virtual void Delete(IToken from, IToken to);
    public virtual void Delete(string programName, int from, int to);
    public virtual void Delete(string programName, IToken from, IToken to);
    public virtual int get_LastRewriteTokenIndex();
    protected internal virtual int GetLastRewriteTokenIndex(string programName);
    protected internal virtual void SetLastRewriteTokenIndex(string programName, int i);
    protected internal virtual IList`1<RewriteOperation> GetProgram(string name);
    private IList`1<RewriteOperation> InitializeProgram(string name);
    public virtual string GetText();
    public virtual string GetText(Interval interval);
    public virtual string GetText(string programName, Interval interval);
    protected internal virtual IDictionary`2<int, RewriteOperation> ReduceToSingleOperationPerIndex(IList`1<RewriteOperation> rewrites);
    protected internal virtual string CatOpText(object a, object b);
    protected internal virtual IList`1<T> GetKindOfOps(IList`1<RewriteOperation> rewrites, int before);
}
public static class Antlr4.Runtime.TokenTypes : object {
    public static int More;
    public static int Skip;
}
public abstract class Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1 : object {
    protected internal Result DefaultResult { get; }
    public virtual Result Visit(IParseTree tree);
    public virtual Result VisitChildren(IRuleNode node);
    public virtual Result VisitTerminal(ITerminalNode node);
    public virtual Result VisitErrorNode(IErrorNode node);
    protected internal virtual Result get_DefaultResult();
    protected internal virtual Result AggregateResult(Result aggregate, Result nextResult);
    protected internal virtual bool ShouldVisitNextChild(IRuleNode node, Result currentResult);
}
public class Antlr4.Runtime.Tree.ErrorNodeImpl : TerminalNodeImpl {
    public ErrorNodeImpl(IToken token);
    public virtual T Accept(IParseTreeVisitor`1<T> visitor);
}
public interface Antlr4.Runtime.Tree.IErrorNode {
}
public interface Antlr4.Runtime.Tree.IParseTree {
    public IParseTree Parent { get; }
    public abstract virtual IParseTree get_Parent();
    public abstract virtual IParseTree GetChild(int i);
    public abstract virtual T Accept(IParseTreeVisitor`1<T> visitor);
    public abstract virtual string GetText();
    public abstract virtual string ToStringTree(Parser parser);
}
public interface Antlr4.Runtime.Tree.IParseTreeListener {
    public abstract virtual void VisitTerminal(ITerminalNode node);
    public abstract virtual void VisitErrorNode(IErrorNode node);
    public abstract virtual void EnterEveryRule(ParserRuleContext ctx);
    public abstract virtual void ExitEveryRule(ParserRuleContext ctx);
}
public interface Antlr4.Runtime.Tree.IParseTreeVisitor`1 {
    public abstract virtual Result Visit(IParseTree tree);
    public abstract virtual Result VisitChildren(IRuleNode node);
    public abstract virtual Result VisitTerminal(ITerminalNode node);
    public abstract virtual Result VisitErrorNode(IErrorNode node);
}
public interface Antlr4.Runtime.Tree.IRuleNode {
    public RuleContext RuleContext { get; }
    public IRuleNode Parent { get; }
    public abstract virtual RuleContext get_RuleContext();
    public abstract virtual IRuleNode get_Parent();
}
public interface Antlr4.Runtime.Tree.ISyntaxTree {
    public Interval SourceInterval { get; }
    public abstract virtual Interval get_SourceInterval();
}
public interface Antlr4.Runtime.Tree.ITerminalNode {
    public IToken Symbol { get; }
    public IRuleNode Parent { get; }
    public abstract virtual IToken get_Symbol();
    public abstract virtual IRuleNode get_Parent();
}
public interface Antlr4.Runtime.Tree.ITree {
    public ITree Parent { get; }
    public object Payload { get; }
    public int ChildCount { get; }
    public abstract virtual ITree get_Parent();
    public abstract virtual object get_Payload();
    public abstract virtual ITree GetChild(int i);
    public abstract virtual int get_ChildCount();
    public abstract virtual string ToStringTree();
}
public class Antlr4.Runtime.Tree.ParseTreeProperty`1 : object {
    protected internal ConcurrentDictionary`2<IParseTree, V> annotations;
    public virtual V Get(IParseTree node);
    public virtual void Put(IParseTree node, V value);
    public virtual V RemoveFrom(IParseTree node);
}
public class Antlr4.Runtime.Tree.ParseTreeWalker : object {
    public static ParseTreeWalker Default;
    private static ParseTreeWalker();
    public virtual void Walk(IParseTreeListener listener, IParseTree t);
    protected internal virtual void EnterRule(IParseTreeListener listener, IRuleNode r);
    protected internal virtual void ExitRule(IParseTreeListener listener, IRuleNode r);
}
internal abstract class Antlr4.Runtime.Tree.Pattern.Chunk : object {
}
public class Antlr4.Runtime.Tree.Pattern.ParseTreeMatch : object {
    private IParseTree tree;
    private ParseTreePattern pattern;
    private MultiMap`2<string, IParseTree> labels;
    private IParseTree mismatchedNode;
    [NotNullAttribute]
public MultiMap`2<string, IParseTree> Labels { get; }
    [NullableAttribute]
public IParseTree MismatchedNode { get; }
    public bool Succeeded { get; }
    [NotNullAttribute]
public ParseTreePattern Pattern { get; }
    [NotNullAttribute]
public IParseTree Tree { get; }
    public ParseTreeMatch(IParseTree tree, ParseTreePattern pattern, MultiMap`2<string, IParseTree> labels, IParseTree mismatchedNode);
    public virtual IParseTree Get(string label);
    public virtual IList`1<IParseTree> GetAll(string label);
    public virtual MultiMap`2<string, IParseTree> get_Labels();
    public virtual IParseTree get_MismatchedNode();
    public virtual bool get_Succeeded();
    public virtual ParseTreePattern get_Pattern();
    public virtual IParseTree get_Tree();
    public virtual string ToString();
}
public class Antlr4.Runtime.Tree.Pattern.ParseTreePattern : object {
    private int patternRuleIndex;
    [NotNullAttribute]
private string pattern;
    [NotNullAttribute]
private IParseTree patternTree;
    [NotNullAttribute]
private ParseTreePatternMatcher matcher;
    [NotNullAttribute]
public ParseTreePatternMatcher Matcher { get; }
    [NotNullAttribute]
public string Pattern { get; }
    public int PatternRuleIndex { get; }
    [NotNullAttribute]
public IParseTree PatternTree { get; }
    public ParseTreePattern(ParseTreePatternMatcher matcher, string pattern, int patternRuleIndex, IParseTree patternTree);
    public virtual ParseTreeMatch Match(IParseTree tree);
    public virtual bool Matches(IParseTree tree);
    public virtual IList`1<ParseTreeMatch> FindAll(IParseTree tree, string xpath);
    public virtual ParseTreePatternMatcher get_Matcher();
    public virtual string get_Pattern();
    public virtual int get_PatternRuleIndex();
    public virtual IParseTree get_PatternTree();
}
public class Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher : object {
    private Lexer lexer;
    private Parser parser;
    protected internal string start;
    protected internal string stop;
    protected internal string escape;
    [NotNullAttribute]
public Lexer Lexer { get; }
    [NotNullAttribute]
public Parser Parser { get; }
    public ParseTreePatternMatcher(Lexer lexer, Parser parser);
    public virtual void SetDelimiters(string start, string stop, string escapeLeft);
    public virtual bool Matches(IParseTree tree, string pattern, int patternRuleIndex);
    public virtual bool Matches(IParseTree tree, ParseTreePattern pattern);
    public virtual ParseTreeMatch Match(IParseTree tree, string pattern, int patternRuleIndex);
    public virtual ParseTreeMatch Match(IParseTree tree, ParseTreePattern pattern);
    public virtual ParseTreePattern Compile(string pattern, int patternRuleIndex);
    public virtual Lexer get_Lexer();
    public virtual Parser get_Parser();
    protected internal virtual IParseTree MatchImpl(IParseTree tree, IParseTree patternTree, MultiMap`2<string, IParseTree> labels);
    protected internal virtual RuleTagToken GetRuleTagToken(IParseTree t);
    public virtual IList`1<IToken> Tokenize(string pattern);
    internal virtual IList`1<Chunk> Split(string pattern);
}
public class Antlr4.Runtime.Tree.Pattern.RuleTagToken : object {
    private string ruleName;
    private int bypassTokenType;
    private string label;
    [NotNullAttribute]
public string RuleName { get; }
    [NullableAttribute]
public string Label { get; }
    public int Channel { get; }
    public string Text { get; }
    public int Type { get; }
    public int Line { get; }
    public int Column { get; }
    public int TokenIndex { get; }
    public int StartIndex { get; }
    public int StopIndex { get; }
    public ITokenSource TokenSource { get; }
    public ICharStream InputStream { get; }
    public RuleTagToken(string ruleName, int bypassTokenType);
    public RuleTagToken(string ruleName, int bypassTokenType, string label);
    public string get_RuleName();
    public string get_Label();
    public virtual int get_Channel();
    public virtual string get_Text();
    public virtual int get_Type();
    public virtual int get_Line();
    public virtual int get_Column();
    public virtual int get_TokenIndex();
    public virtual int get_StartIndex();
    public virtual int get_StopIndex();
    public virtual ITokenSource get_TokenSource();
    public virtual ICharStream get_InputStream();
    public virtual string ToString();
}
internal class Antlr4.Runtime.Tree.Pattern.TagChunk : Chunk {
    private string tag;
    private string label;
    [NotNullAttribute]
public string Tag { get; }
    [NullableAttribute]
public string Label { get; }
    public TagChunk(string tag);
    public TagChunk(string label, string tag);
    public string get_Tag();
    public string get_Label();
    public virtual string ToString();
}
internal class Antlr4.Runtime.Tree.Pattern.TextChunk : Chunk {
    [NotNullAttribute]
private string text;
    [NotNullAttribute]
public string Text { get; }
    public TextChunk(string text);
    public string get_Text();
    public virtual string ToString();
}
public class Antlr4.Runtime.Tree.Pattern.TokenTagToken : CommonToken {
    [NotNullAttribute]
private string tokenName;
    [NullableAttribute]
private string label;
    [NotNullAttribute]
public string TokenName { get; }
    [NullableAttribute]
public string Label { get; }
    public string Text { get; }
    public TokenTagToken(string tokenName, int type);
    public TokenTagToken(string tokenName, int type, string label);
    public string get_TokenName();
    public string get_Label();
    public virtual string get_Text();
    public virtual string ToString();
}
public class Antlr4.Runtime.Tree.TerminalNodeImpl : object {
    private IToken _symbol;
    private IRuleNode _parent;
    public IToken Symbol { get; }
    public IRuleNode Parent { get; public set; }
    private IParseTree Antlr4.Runtime.Tree.IParseTree.Parent { get; }
    private ITree Antlr4.Runtime.Tree.ITree.Parent { get; }
    public IToken Payload { get; }
    private object Antlr4.Runtime.Tree.ITree.Payload { get; }
    public Interval SourceInterval { get; }
    public int ChildCount { get; }
    public TerminalNodeImpl(IToken symbol);
    public virtual IParseTree GetChild(int i);
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.GetChild(int i);
    public virtual IToken get_Symbol();
    public virtual IRuleNode get_Parent();
    public virtual void set_Parent(IRuleNode value);
    private sealed virtual override IParseTree Antlr4.Runtime.Tree.IParseTree.get_Parent();
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.get_Parent();
    public virtual IToken get_Payload();
    private sealed virtual override object Antlr4.Runtime.Tree.ITree.get_Payload();
    public virtual Interval get_SourceInterval();
    public virtual int get_ChildCount();
    public virtual T Accept(IParseTreeVisitor`1<T> visitor);
    public virtual string GetText();
    public virtual string ToStringTree(Parser parser);
    public virtual string ToString();
    public virtual string ToStringTree();
}
public class Antlr4.Runtime.Tree.Trees : object {
    public static string ToStringTree(ITree t);
    public static string ToStringTree(ITree t, Parser recog);
    public static string ToStringTree(ITree t, IList`1<string> ruleNames);
    public static string GetNodeText(ITree t, Parser recog);
    public static string GetNodeText(ITree t, IList`1<string> ruleNames);
    public static IList`1<ITree> GetChildren(ITree t);
    public static IList`1<ITree> GetAncestors(ITree t);
    public static ICollection`1<IParseTree> FindAllTokenNodes(IParseTree t, int ttype);
    public static ICollection`1<IParseTree> FindAllRuleNodes(IParseTree t, int ruleIndex);
    public static IList`1<IParseTree> FindAllNodes(IParseTree t, int index, bool findTokens);
    private static void _findAllNodes(IParseTree t, int index, bool findTokens, IList`1<IParseTree> nodes);
    public static IList`1<IParseTree> Descendants(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPath : object {
    public static string Wildcard;
    public static string Not;
    protected internal string path;
    protected internal XPathElement[] elements;
    protected internal Parser parser;
    public XPath(Parser parser, string path);
    public virtual XPathElement[] Split(string path);
    protected internal virtual XPathElement GetXPathElement(IToken wordToken, bool anywhere);
    public static ICollection`1<IParseTree> FindAll(IParseTree tree, string xpath, Parser parser);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public abstract class Antlr4.Runtime.Tree.Xpath.XPathElement : object {
    protected internal string nodeName;
    protected internal bool invert;
    public XPathElement(string nodeName);
    public abstract virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
    public virtual string ToString();
}
public class Antlr4.Runtime.Tree.Xpath.XPathLexerErrorListener : object {
    public virtual void SyntaxError(IRecognizer recognizer, int offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public class Antlr4.Runtime.Tree.Xpath.XPathRuleAnywhereElement : XPathElement {
    protected internal int ruleIndex;
    public XPathRuleAnywhereElement(string ruleName, int ruleIndex);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathRuleElement : XPathElement {
    protected internal int ruleIndex;
    public XPathRuleElement(string ruleName, int ruleIndex);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathTokenAnywhereElement : XPathElement {
    protected internal int tokenType;
    public XPathTokenAnywhereElement(string tokenName, int tokenType);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathTokenElement : XPathElement {
    protected internal int tokenType;
    public XPathTokenElement(string tokenName, int tokenType);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathWildcardAnywhereElement : XPathElement {
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathWildcardElement : XPathElement {
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.UnbufferedCharStream : object {
    protected internal Char[] data;
    protected internal int n;
    protected internal int p;
    protected internal int numMarkers;
    protected internal int lastChar;
    protected internal int lastCharBufferStart;
    protected internal int currentCharIndex;
    protected internal TextReader input;
    public string name;
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    protected internal int BufferStartIndex { get; }
    public UnbufferedCharStream(int bufferSize);
    public UnbufferedCharStream(Stream input);
    public UnbufferedCharStream(TextReader input);
    public UnbufferedCharStream(Stream input, int bufferSize);
    public UnbufferedCharStream(TextReader input, int bufferSize);
    public virtual void Consume();
    protected internal virtual void Sync(int want);
    protected internal virtual int Fill(int n);
    protected internal virtual int NextChar();
    protected internal virtual void Add(int c);
    public virtual int La(int i);
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual int get_Index();
    public virtual void Seek(int index);
    public virtual int get_Size();
    public virtual string get_SourceName();
    public virtual string GetText(Interval interval);
    protected internal int get_BufferStartIndex();
}
public class Antlr4.Runtime.UnbufferedTokenStream : object {
    private ITokenSource _tokenSource;
    protected internal IToken[] tokens;
    protected internal int n;
    protected internal int p;
    protected internal int numMarkers;
    protected internal IToken lastToken;
    protected internal IToken lastTokenBufferStart;
    protected internal int currentTokenIndex;
    public ITokenSource TokenSource { get; public set; }
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public UnbufferedTokenStream(ITokenSource tokenSource);
    public UnbufferedTokenStream(ITokenSource tokenSource, int bufferSize);
    public virtual IToken Get(int i);
    public virtual IToken Lt(int i);
    public virtual int La(int i);
    public virtual ITokenSource get_TokenSource();
    public virtual void set_TokenSource(ITokenSource value);
    public virtual string GetText();
    public virtual string GetText(RuleContext ctx);
    public virtual string GetText(IToken start, IToken stop);
    public virtual void Consume();
    protected internal virtual void Sync(int want);
    protected internal virtual int Fill(int n);
    protected internal virtual void Add(IToken t);
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual int get_Index();
    public virtual void Seek(int index);
    public virtual int get_Size();
    public virtual string get_SourceName();
    public virtual string GetText(Interval interval);
    protected internal int GetBufferStartIndex();
}
public class Antlr4.Runtime.Vocabulary : object {
    private static String[] EmptyNames;
    [NotNullAttribute]
public static Vocabulary EmptyVocabulary;
    [NotNullAttribute]
private String[] literalNames;
    [NotNullAttribute]
private String[] symbolicNames;
    [NotNullAttribute]
private String[] displayNames;
    public Vocabulary(String[] literalNames, String[] symbolicNames);
    public Vocabulary(String[] literalNames, String[] symbolicNames, String[] displayNames);
    private static Vocabulary();
    public virtual string GetLiteralName(int tokenType);
    public virtual string GetSymbolicName(int tokenType);
    public virtual string GetDisplayName(int tokenType);
}
[GeneratedCodeAttribute("ANTLR", "4.5.1")]
[CLSCompliantAttribute("False")]
public class BindingPathBaseListener : object {
    public virtual void EnterProgram(ProgramContext context);
    public virtual void ExitProgram(ProgramContext context);
    public virtual void EnterDecimal_value(Decimal_valueContext context);
    public virtual void ExitDecimal_value(Decimal_valueContext context);
    public virtual void EnterBoolean_value(Boolean_valueContext context);
    public virtual void ExitBoolean_value(Boolean_valueContext context);
    public virtual void EnterNamespace_qualifier(Namespace_qualifierContext context);
    public virtual void ExitNamespace_qualifier(Namespace_qualifierContext context);
    public virtual void EnterStatic_type(Static_typeContext context);
    public virtual void ExitStatic_type(Static_typeContext context);
    public virtual void EnterAttached_expr(Attached_exprContext context);
    public virtual void ExitAttached_expr(Attached_exprContext context);
    public virtual void EnterCast_expr(Cast_exprContext context);
    public virtual void ExitCast_expr(Cast_exprContext context);
    public virtual void EnterFunction(FunctionContext context);
    public virtual void ExitFunction(FunctionContext context);
    public virtual void EnterPathStaticFuction(PathStaticFuctionContext context);
    public virtual void ExitPathStaticFuction(PathStaticFuctionContext context);
    public virtual void EnterPathCast(PathCastContext context);
    public virtual void ExitPathCast(PathCastContext context);
    public virtual void EnterPathPathToFunction(PathPathToFunctionContext context);
    public virtual void ExitPathPathToFunction(PathPathToFunctionContext context);
    public virtual void EnterPathIndexer(PathIndexerContext context);
    public virtual void ExitPathIndexer(PathIndexerContext context);
    public virtual void EnterPathCastInvalid(PathCastInvalidContext context);
    public virtual void ExitPathCastInvalid(PathCastInvalidContext context);
    public virtual void EnterPathCastPathParen(PathCastPathParenContext context);
    public virtual void ExitPathCastPathParen(PathCastPathParenContext context);
    public virtual void EnterPathFunction(PathFunctionContext context);
    public virtual void ExitPathFunction(PathFunctionContext context);
    public virtual void EnterPathStringIndexer(PathStringIndexerContext context);
    public virtual void ExitPathStringIndexer(PathStringIndexerContext context);
    public virtual void EnterPathIdentifier(PathIdentifierContext context);
    public virtual void ExitPathIdentifier(PathIdentifierContext context);
    public virtual void EnterPathCastPath(PathCastPathContext context);
    public virtual void ExitPathCastPath(PathCastPathContext context);
    public virtual void EnterPathStaticIdentifier(PathStaticIdentifierContext context);
    public virtual void ExitPathStaticIdentifier(PathStaticIdentifierContext context);
    public virtual void EnterPathDotIdentifier(PathDotIdentifierContext context);
    public virtual void ExitPathDotIdentifier(PathDotIdentifierContext context);
    public virtual void EnterPathDotAttached(PathDotAttachedContext context);
    public virtual void ExitPathDotAttached(PathDotAttachedContext context);
    public virtual void EnterFunctionParameterInvalid(FunctionParameterInvalidContext context);
    public virtual void ExitFunctionParameterInvalid(FunctionParameterInvalidContext context);
    public virtual void EnterFunctionParamPath(FunctionParamPathContext context);
    public virtual void ExitFunctionParamPath(FunctionParamPathContext context);
    public virtual void EnterFunctionParamBool(FunctionParamBoolContext context);
    public virtual void ExitFunctionParamBool(FunctionParamBoolContext context);
    public virtual void EnterFunctionParamNumber(FunctionParamNumberContext context);
    public virtual void ExitFunctionParamNumber(FunctionParamNumberContext context);
    public virtual void EnterFunctionParamString(FunctionParamStringContext context);
    public virtual void ExitFunctionParamString(FunctionParamStringContext context);
    public virtual void EnterFunctionParamNullValue(FunctionParamNullValueContext context);
    public virtual void ExitFunctionParamNullValue(FunctionParamNullValueContext context);
    public virtual void EnterEveryRule(ParserRuleContext context);
    public virtual void ExitEveryRule(ParserRuleContext context);
    public virtual void VisitTerminal(ITerminalNode node);
    public virtual void VisitErrorNode(IErrorNode node);
}
[GeneratedCodeAttribute("ANTLR", "4.5.1")]
[CLSCompliantAttribute("False")]
public class BindingPathLexer : Lexer {
    public static int T__0;
    public static int T__1;
    public static int T__2;
    public static int T__3;
    public static int T__4;
    public static int T__5;
    public static int T__6;
    public static int T__7;
    public static int WS;
    public static int ESCAPEDQUOTE;
    public static int QUOTE;
    public static int DOUBLE_QUOTE;
    public static int TRUE;
    public static int FALSE;
    public static int NULL;
    public static int Digits;
    public static int QuotedString;
    public static int IDENTIFIER;
    public static String[] modeNames;
    public static String[] ruleNames;
    private static String[] _LiteralNames;
    private static String[] _SymbolicNames;
    public static IVocabulary DefaultVocabulary;
    public static string _serializedATN;
    public static ATN _ATN;
    [NotNullAttribute]
public IVocabulary Vocabulary { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public String[] ModeNames { get; }
    public string SerializedAtn { get; }
    public BindingPathLexer(ICharStream input);
    private static BindingPathLexer();
    public virtual IVocabulary get_Vocabulary();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual String[] get_ModeNames();
    public virtual string get_SerializedAtn();
}
[GeneratedCodeAttribute("ANTLR", "4.5.1")]
[CLSCompliantAttribute("False")]
public class BindingPathParser : Parser {
    public static int T__0;
    public static int T__1;
    public static int T__2;
    public static int T__3;
    public static int T__4;
    public static int T__5;
    public static int T__6;
    public static int T__7;
    public static int WS;
    public static int ESCAPEDQUOTE;
    public static int QUOTE;
    public static int DOUBLE_QUOTE;
    public static int TRUE;
    public static int FALSE;
    public static int NULL;
    public static int Digits;
    public static int QuotedString;
    public static int IDENTIFIER;
    public static int RULE_program;
    public static int RULE_decimal_value;
    public static int RULE_boolean_value;
    public static int RULE_namespace_qualifier;
    public static int RULE_static_type;
    public static int RULE_attached_expr;
    public static int RULE_cast_expr;
    public static int RULE_function;
    public static int RULE_path;
    public static int RULE_function_param;
    public static String[] ruleNames;
    private static String[] _LiteralNames;
    private static String[] _SymbolicNames;
    public static IVocabulary DefaultVocabulary;
    public static string _serializedATN;
    public static ATN _ATN;
    [NotNullAttribute]
public IVocabulary Vocabulary { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public string SerializedAtn { get; }
    public BindingPathParser(ITokenStream input);
    private static BindingPathParser();
    public virtual IVocabulary get_Vocabulary();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual string get_SerializedAtn();
    [RuleVersionAttribute("0")]
public ProgramContext program();
    [RuleVersionAttribute("0")]
public Decimal_valueContext decimal_value();
    [RuleVersionAttribute("0")]
public Boolean_valueContext boolean_value();
    [RuleVersionAttribute("0")]
public Namespace_qualifierContext namespace_qualifier();
    [RuleVersionAttribute("0")]
public Static_typeContext static_type();
    [RuleVersionAttribute("0")]
public Attached_exprContext attached_expr();
    [RuleVersionAttribute("0")]
public Cast_exprContext cast_expr();
    [RuleVersionAttribute("0")]
public FunctionContext function();
    [RuleVersionAttribute("0")]
public PathContext path();
    private PathContext path(int _p);
    [RuleVersionAttribute("0")]
public Function_paramContext function_param();
    public virtual bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex);
    private bool path_sempred(PathContext _localctx, int predIndex);
}
[GeneratedCodeAttribute("ANTLR", "4.5.3")]
[CLSCompliantAttribute("False")]
public class ConditionalNamespaceBaseListener : object {
    public virtual void EnterProgram(ProgramContext context);
    public virtual void ExitProgram(ProgramContext context);
    public virtual void EnterExpression(ExpressionContext context);
    public virtual void ExitExpression(ExpressionContext context);
    public virtual void EnterUri(UriContext context);
    public virtual void ExitUri(UriContext context);
    public virtual void EnterUnquoted_namespace(Unquoted_namespaceContext context);
    public virtual void ExitUnquoted_namespace(Unquoted_namespaceContext context);
    public virtual void EnterApi_information(Api_informationContext context);
    public virtual void ExitApi_information(Api_informationContext context);
    public virtual void EnterFunction_param(Function_paramContext context);
    public virtual void ExitFunction_param(Function_paramContext context);
    public virtual void EnterTarget_platform_value(Target_platform_valueContext context);
    public virtual void ExitTarget_platform_value(Target_platform_valueContext context);
    public virtual void EnterQuery_string(Query_stringContext context);
    public virtual void ExitQuery_string(Query_stringContext context);
    public virtual void EnterQueryStringTargetPlatform(QueryStringTargetPlatformContext context);
    public virtual void ExitQueryStringTargetPlatform(QueryStringTargetPlatformContext context);
    public virtual void EnterQueryStringApiInformation(QueryStringApiInformationContext context);
    public virtual void ExitQueryStringApiInformation(QueryStringApiInformationContext context);
    public virtual void EnterTarget_platform_func(Target_platform_funcContext context);
    public virtual void ExitTarget_platform_func(Target_platform_funcContext context);
    public virtual void EnterEveryRule(ParserRuleContext context);
    public virtual void ExitEveryRule(ParserRuleContext context);
    public virtual void VisitTerminal(ITerminalNode node);
    public virtual void VisitErrorNode(IErrorNode node);
}
[GeneratedCodeAttribute("ANTLR", "4.5.3")]
[CLSCompliantAttribute("False")]
public class ConditionalNamespaceLexer : Lexer {
    public static int T__0;
    public static int T__1;
    public static int T__2;
    public static int T__3;
    public static int T__4;
    public static int T__5;
    public static int T__6;
    public static int T__7;
    public static int T__8;
    public static int WS;
    public static int ESCAPEDQUOTE;
    public static int QUOTE;
    public static int DOUBLE_QUOTE;
    public static int TargetPlatformString;
    public static int PlatformUWP;
    public static int PlatformiOS;
    public static int PlatformAndroid;
    public static int Digits;
    public static int QuotedString;
    public static int IDENTIFIER;
    public static String[] modeNames;
    public static String[] ruleNames;
    private static String[] _LiteralNames;
    private static String[] _SymbolicNames;
    public static IVocabulary DefaultVocabulary;
    private static string _serializedATN;
    public static ATN _ATN;
    [NotNullAttribute]
public IVocabulary Vocabulary { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public String[] ModeNames { get; }
    public string SerializedAtn { get; }
    public ConditionalNamespaceLexer(ICharStream input);
    private static ConditionalNamespaceLexer();
    public virtual IVocabulary get_Vocabulary();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual String[] get_ModeNames();
    public virtual string get_SerializedAtn();
    private static string _serializeATN();
}
[GeneratedCodeAttribute("ANTLR", "4.5.3")]
[CLSCompliantAttribute("False")]
public class ConditionalNamespaceParser : Parser {
    public static int T__0;
    public static int T__1;
    public static int T__2;
    public static int T__3;
    public static int T__4;
    public static int T__5;
    public static int T__6;
    public static int T__7;
    public static int T__8;
    public static int WS;
    public static int ESCAPEDQUOTE;
    public static int QUOTE;
    public static int DOUBLE_QUOTE;
    public static int TargetPlatformString;
    public static int PlatformUWP;
    public static int PlatformiOS;
    public static int PlatformAndroid;
    public static int Digits;
    public static int QuotedString;
    public static int IDENTIFIER;
    public static int RULE_program;
    public static int RULE_expression;
    public static int RULE_uri;
    public static int RULE_unquoted_namespace;
    public static int RULE_api_information;
    public static int RULE_function_param;
    public static int RULE_target_platform_value;
    public static int RULE_query_string;
    public static int RULE_query_string_component;
    public static int RULE_target_platform_func;
    public static String[] ruleNames;
    private static String[] _LiteralNames;
    private static String[] _SymbolicNames;
    public static IVocabulary DefaultVocabulary;
    private static string _serializedATN;
    public static ATN _ATN;
    [NotNullAttribute]
public IVocabulary Vocabulary { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public string SerializedAtn { get; }
    public ConditionalNamespaceParser(ITokenStream input);
    private static ConditionalNamespaceParser();
    public virtual IVocabulary get_Vocabulary();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual string get_SerializedAtn();
    [RuleVersionAttribute("0")]
public ProgramContext program();
    [RuleVersionAttribute("0")]
public ExpressionContext expression();
    [RuleVersionAttribute("0")]
public UriContext uri();
    [RuleVersionAttribute("0")]
public Unquoted_namespaceContext unquoted_namespace();
    [RuleVersionAttribute("0")]
public Api_informationContext api_information();
    [RuleVersionAttribute("0")]
public Function_paramContext function_param();
    [RuleVersionAttribute("0")]
public Target_platform_valueContext target_platform_value();
    [RuleVersionAttribute("0")]
public Query_stringContext query_string();
    [RuleVersionAttribute("0")]
public Query_string_componentContext query_string_component();
    [RuleVersionAttribute("0")]
public Target_platform_funcContext target_platform_func();
    private static string _serializeATN();
}
[FlagsAttribute]
public enum DeferLoadStrategy : Enum {
    public int value__;
    public static DeferLoadStrategy None;
    public static DeferLoadStrategy Lazy;
}
[GeneratedCodeAttribute("ANTLR", "4.5.1")]
[CLSCompliantAttribute("False")]
public interface IBindingPathListener {
    public abstract virtual void EnterProgram(ProgramContext context);
    public abstract virtual void ExitProgram(ProgramContext context);
    public abstract virtual void EnterDecimal_value(Decimal_valueContext context);
    public abstract virtual void ExitDecimal_value(Decimal_valueContext context);
    public abstract virtual void EnterBoolean_value(Boolean_valueContext context);
    public abstract virtual void ExitBoolean_value(Boolean_valueContext context);
    public abstract virtual void EnterNamespace_qualifier(Namespace_qualifierContext context);
    public abstract virtual void ExitNamespace_qualifier(Namespace_qualifierContext context);
    public abstract virtual void EnterStatic_type(Static_typeContext context);
    public abstract virtual void ExitStatic_type(Static_typeContext context);
    public abstract virtual void EnterAttached_expr(Attached_exprContext context);
    public abstract virtual void ExitAttached_expr(Attached_exprContext context);
    public abstract virtual void EnterCast_expr(Cast_exprContext context);
    public abstract virtual void ExitCast_expr(Cast_exprContext context);
    public abstract virtual void EnterFunction(FunctionContext context);
    public abstract virtual void ExitFunction(FunctionContext context);
    public abstract virtual void EnterPathStaticFuction(PathStaticFuctionContext context);
    public abstract virtual void ExitPathStaticFuction(PathStaticFuctionContext context);
    public abstract virtual void EnterPathCast(PathCastContext context);
    public abstract virtual void ExitPathCast(PathCastContext context);
    public abstract virtual void EnterPathPathToFunction(PathPathToFunctionContext context);
    public abstract virtual void ExitPathPathToFunction(PathPathToFunctionContext context);
    public abstract virtual void EnterPathIndexer(PathIndexerContext context);
    public abstract virtual void ExitPathIndexer(PathIndexerContext context);
    public abstract virtual void EnterPathCastInvalid(PathCastInvalidContext context);
    public abstract virtual void ExitPathCastInvalid(PathCastInvalidContext context);
    public abstract virtual void EnterPathCastPathParen(PathCastPathParenContext context);
    public abstract virtual void ExitPathCastPathParen(PathCastPathParenContext context);
    public abstract virtual void EnterPathFunction(PathFunctionContext context);
    public abstract virtual void ExitPathFunction(PathFunctionContext context);
    public abstract virtual void EnterPathStringIndexer(PathStringIndexerContext context);
    public abstract virtual void ExitPathStringIndexer(PathStringIndexerContext context);
    public abstract virtual void EnterPathIdentifier(PathIdentifierContext context);
    public abstract virtual void ExitPathIdentifier(PathIdentifierContext context);
    public abstract virtual void EnterPathCastPath(PathCastPathContext context);
    public abstract virtual void ExitPathCastPath(PathCastPathContext context);
    public abstract virtual void EnterPathStaticIdentifier(PathStaticIdentifierContext context);
    public abstract virtual void ExitPathStaticIdentifier(PathStaticIdentifierContext context);
    public abstract virtual void EnterPathDotIdentifier(PathDotIdentifierContext context);
    public abstract virtual void ExitPathDotIdentifier(PathDotIdentifierContext context);
    public abstract virtual void EnterPathDotAttached(PathDotAttachedContext context);
    public abstract virtual void ExitPathDotAttached(PathDotAttachedContext context);
    public abstract virtual void EnterFunctionParameterInvalid(FunctionParameterInvalidContext context);
    public abstract virtual void ExitFunctionParameterInvalid(FunctionParameterInvalidContext context);
    public abstract virtual void EnterFunctionParamPath(FunctionParamPathContext context);
    public abstract virtual void ExitFunctionParamPath(FunctionParamPathContext context);
    public abstract virtual void EnterFunctionParamBool(FunctionParamBoolContext context);
    public abstract virtual void ExitFunctionParamBool(FunctionParamBoolContext context);
    public abstract virtual void EnterFunctionParamNumber(FunctionParamNumberContext context);
    public abstract virtual void ExitFunctionParamNumber(FunctionParamNumberContext context);
    public abstract virtual void EnterFunctionParamString(FunctionParamStringContext context);
    public abstract virtual void ExitFunctionParamString(FunctionParamStringContext context);
    public abstract virtual void EnterFunctionParamNullValue(FunctionParamNullValueContext context);
    public abstract virtual void ExitFunctionParamNullValue(FunctionParamNullValueContext context);
}
[GeneratedCodeAttribute("ANTLR", "4.5.3")]
[CLSCompliantAttribute("False")]
public interface IConditionalNamespaceListener {
    public abstract virtual void EnterProgram(ProgramContext context);
    public abstract virtual void ExitProgram(ProgramContext context);
    public abstract virtual void EnterExpression(ExpressionContext context);
    public abstract virtual void ExitExpression(ExpressionContext context);
    public abstract virtual void EnterUri(UriContext context);
    public abstract virtual void ExitUri(UriContext context);
    public abstract virtual void EnterUnquoted_namespace(Unquoted_namespaceContext context);
    public abstract virtual void ExitUnquoted_namespace(Unquoted_namespaceContext context);
    public abstract virtual void EnterApi_information(Api_informationContext context);
    public abstract virtual void ExitApi_information(Api_informationContext context);
    public abstract virtual void EnterFunction_param(Function_paramContext context);
    public abstract virtual void ExitFunction_param(Function_paramContext context);
    public abstract virtual void EnterTarget_platform_value(Target_platform_valueContext context);
    public abstract virtual void ExitTarget_platform_value(Target_platform_valueContext context);
    public abstract virtual void EnterQuery_string(Query_stringContext context);
    public abstract virtual void ExitQuery_string(Query_stringContext context);
    public abstract virtual void EnterQueryStringTargetPlatform(QueryStringTargetPlatformContext context);
    public abstract virtual void ExitQueryStringTargetPlatform(QueryStringTargetPlatformContext context);
    public abstract virtual void EnterQueryStringApiInformation(QueryStringApiInformationContext context);
    public abstract virtual void ExitQueryStringApiInformation(QueryStringApiInformationContext context);
    public abstract virtual void EnterTarget_platform_func(Target_platform_funcContext context);
    public abstract virtual void ExitTarget_platform_func(Target_platform_funcContext context);
}
[GeneratedCodeAttribute("ANTLR", "4.5.1")]
[CLSCompliantAttribute("False")]
public interface ISuccinctCollectionSyntaxListener {
    public abstract virtual void EnterProgram(ProgramContext context);
    public abstract virtual void ExitProgram(ProgramContext context);
    public abstract virtual void EnterItems(ItemsContext context);
    public abstract virtual void ExitItems(ItemsContext context);
    public abstract virtual void EnterZ(ZContext context);
    public abstract virtual void ExitZ(ZContext context);
    public abstract virtual void EnterItem(ItemContext context);
    public abstract virtual void ExitItem(ItemContext context);
    public abstract virtual void EnterText(TextContext context);
    public abstract virtual void ExitText(TextContext context);
    public abstract virtual void EnterLiteral_text(Literal_textContext context);
    public abstract virtual void ExitLiteral_text(Literal_textContext context);
    public abstract virtual void EnterSequence(SequenceContext context);
    public abstract virtual void ExitSequence(SequenceContext context);
}
public class Microsoft.UI.Xaml.Markup.Compiler.ApiInformation : object {
    private static IReadOnlyDictionary`2<string, ApiInformationMethod> SupportedApiInformation;
    private static IReadOnlyDictionary`2<string, List`1<ApiInformationParameter>> SupportedApiInformationParameters;
    [CompilerGeneratedAttribute]
private ApiInformationMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ApiInformationParameter> <Parameters>k__BackingField;
    public ApiInformationMethod Method { get; }
    public IEnumerable`1<ApiInformationParameter> Parameters { get; private set; }
    public string MemberFriendlyName { get; }
    public string UniqueName { get; }
    public ApiInformation(string methodName);
    private static ApiInformation();
    [CompilerGeneratedAttribute]
public ApiInformationMethod get_Method();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ApiInformationParameter> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IEnumerable`1<ApiInformationParameter> value);
    internal void SetParameters(List`1<ApiInformationParameter> parameters);
    public string get_MemberFriendlyName();
    public string get_UniqueName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.UI.Xaml.Markup.Compiler.ApiInformationMethod : object {
    [CompilerGeneratedAttribute]
private bool <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public bool Condition { get; }
    public string MethodName { get; }
    public string UniqueName { get; }
    public ApiInformationMethod(string methodName, bool condition);
    [CompilerGeneratedAttribute]
public bool get_Condition();
    [CompilerGeneratedAttribute]
public string get_MethodName();
    public string get_UniqueName();
}
public class Microsoft.UI.Xaml.Markup.Compiler.ApiInformationParameter : object {
    [CompilerGeneratedAttribute]
private string <ParameterValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    public string ParameterValue { get; }
    public Type ParameterType { get; public set; }
    public string UniqueName { get; }
    public ApiInformationParameter(string value);
    public ApiInformationParameter(Type type);
    [CompilerGeneratedAttribute]
public string get_ParameterValue();
    [CompilerGeneratedAttribute]
public Type get_ParameterType();
    [CompilerGeneratedAttribute]
public void set_ParameterType(Type value);
    public string get_UniqueName();
}
public class Microsoft.UI.Xaml.Markup.Compiler.ArrayIndexStep : BindPathStep {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; }
    public string UniqueName { get; }
    public ArrayIndexStep(int index, XamlType valueType, BindPathStep parent, ApiInformation apiInformation);
    [CompilerGeneratedAttribute]
public int get_Index();
    public virtual string get_UniqueName();
}
public class Microsoft.UI.Xaml.Markup.Compiler.AttachedPropertyStep : DependencyPropertyStep {
    public string UniqueName { get; }
    public bool IsValueRequired { get; }
    public AttachedPropertyStep(string propertyName, XamlType valueType, XamlType ownerType, BindPathStep parent, ApiInformation apiInformation);
    public virtual string get_UniqueName();
    public virtual bool get_IsValueRequired();
}
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.BindAssignment : BindAssignmentBase {
    private XamlDomMember fallbackMember;
    [CompilerGeneratedAttribute]
private BindPathStep <BindBackStep>k__BackingField;
    [CompilerGeneratedAttribute]
private BindStatus <BindStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BindBackPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetNullValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConverterParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConverterLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private UpdateSourceTrigger <UpdateSourceTrigger>k__BackingField;
    public BindPathStep BindBackStep { get; private set; }
    public BindStatus BindStatus { get; public set; }
    public string BindBackPath { get; }
    public string TargetNullValue { get; }
    public string Converter { get; }
    public string ConverterParameter { get; }
    public string ConverterLanguage { get; }
    public UpdateSourceTrigger UpdateSourceTrigger { get; }
    public string CodeName { get; }
    public int ComputedPhase { get; }
    public bool IsTrackingSource { get; }
    public bool IsTrackingTarget { get; }
    public LanguageSpecificString FallbackValueExpression { get; }
    internal LanguageSpecificString TargetNullValueExpression { get; }
    public XamlType ValueType { get; }
    public bool NeedsBox { get; }
    public bool NeedsLostFocusForTwoWay { get; }
    public XamlType MemberTargetType { get; }
    public string DisableFlagName { get; }
    public LanguageSpecificString ReverseAssignmentExpression { get; }
    protected BindAssignment(XamlDomMember bindMember, BindUniverse bindUniverse, ConnectionIdElement connectionIdElement);
    public static BindAssignment Create(XamlDomMember bindMember, BindUniverse bindUniverse, ConnectionIdElement connectionIdElement);
    [CompilerGeneratedAttribute]
public BindPathStep get_BindBackStep();
    [CompilerGeneratedAttribute]
private void set_BindBackStep(BindPathStep value);
    [CompilerGeneratedAttribute]
public sealed virtual BindStatus get_BindStatus();
    [CompilerGeneratedAttribute]
public void set_BindStatus(BindStatus value);
    [CompilerGeneratedAttribute]
public string get_BindBackPath();
    [CompilerGeneratedAttribute]
public string get_TargetNullValue();
    [CompilerGeneratedAttribute]
public string get_Converter();
    [CompilerGeneratedAttribute]
public string get_ConverterParameter();
    [CompilerGeneratedAttribute]
public string get_ConverterLanguage();
    [CompilerGeneratedAttribute]
public UpdateSourceTrigger get_UpdateSourceTrigger();
    public string get_CodeName();
    public sealed virtual int get_ComputedPhase();
    public sealed virtual bool get_IsTrackingSource();
    public sealed virtual bool get_IsTrackingTarget();
    public LanguageSpecificString get_FallbackValueExpression();
    internal LanguageSpecificString get_TargetNullValueExpression();
    public XamlType get_ValueType();
    public bool get_NeedsBox();
    public bool get_NeedsLostFocusForTwoWay();
    public XamlType get_MemberTargetType();
    public string get_DisableFlagName();
    public LanguageSpecificString GetConverterExpression(LanguageSpecificString objectExpression, bool convertBack);
    public LanguageSpecificString DirectAssignmentExpression(string expression);
    public LanguageSpecificString get_ReverseAssignmentExpression();
    private LanguageSpecificString GetAssignmentExpression(XamlType source, XamlType target, LanguageSpecificString expression, bool convertBack);
    public IEnumerable`1<XamlCompileErrorBase> ParsePath();
    private bool ValidateConverter(IList`1<XamlCompileErrorBase> issues);
    private bool ValidatePathAssignment(IList`1<XamlCompileErrorBase> issues);
    private bool ValidateBindBackAssignment(IList`1<XamlCompileErrorBase> issues);
    private void ApplySpecialCaseCasting();
    private bool ValidateTypeCasting(IList`1<XamlCompileErrorBase> issues);
    private bool ValidateApiInformation(IList`1<XamlCompileErrorBase> issues);
    private bool ValidateUpdateSourceTrigger(IList`1<XamlCompileErrorBase> issues);
    private bool ValidateMode(IList`1<XamlCompileErrorBase> issues);
    private bool ValidateFallbackValue(IList`1<XamlCompileErrorBase> issues);
    [CompilerGeneratedAttribute]
private string <get_TargetNullValueExpression>b__40_4();
    [CompilerGeneratedAttribute]
private string <get_TargetNullValueExpression>b__40_5();
    [CompilerGeneratedAttribute]
private string <get_TargetNullValueExpression>b__40_6();
    [CompilerGeneratedAttribute]
private string <get_TargetNullValueExpression>b__40_7();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.BindAssignmentBase : object {
    protected XamlDomObject bindItem;
    protected XamlDomMember bindMember;
    [CompilerGeneratedAttribute]
private ApiInformation <ApiInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private BindUniverse <BindUniverse>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionIdElement <ConnectionIdElement>k__BackingField;
    [CompilerGeneratedAttribute]
private BindPathStep <PathStep>k__BackingField;
    [CompilerGeneratedAttribute]
private LineNumberInfo <LineNumberInfo>k__BackingField;
    public ApiInformation ApiInformation { get; }
    public BindUniverse BindUniverse { get; }
    public ConnectionIdElement ConnectionIdElement { get; }
    public BindPathStep PathStep { get; protected set; }
    public LineNumberInfo LineNumberInfo { get; }
    public LanguageSpecificString ObjectDeferredAssignmentCodeName { get; }
    public string MemberName { get; }
    public string MemberFullName { get; }
    public XamlType MemberType { get; }
    public XamlType MemberDeclaringType { get; }
    public bool IsAttachable { get; }
    public bool IsInputPropertyAssignment { get; }
    public bool HasSetValueHelper { get; }
    public bool HasDeferredValueProxy { get; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public BindAssignmentBase(XamlDomMember domMember, BindUniverse bindUniverse, ConnectionIdElement connectionIdElement);
    [CompilerGeneratedAttribute]
public ApiInformation get_ApiInformation();
    [CompilerGeneratedAttribute]
public BindUniverse get_BindUniverse();
    [CompilerGeneratedAttribute]
public ConnectionIdElement get_ConnectionIdElement();
    [CompilerGeneratedAttribute]
public BindPathStep get_PathStep();
    [CompilerGeneratedAttribute]
protected void set_PathStep(BindPathStep value);
    [CompilerGeneratedAttribute]
public sealed virtual LineNumberInfo get_LineNumberInfo();
    public sealed virtual XamlCompileError GetAttributeProcessingError();
    public virtual LanguageSpecificString get_ObjectDeferredAssignmentCodeName();
    public string get_MemberName();
    public virtual string get_MemberFullName();
    public virtual XamlType get_MemberType();
    public virtual XamlType get_MemberDeclaringType();
    public virtual bool get_IsAttachable();
    public virtual bool get_IsInputPropertyAssignment();
    public virtual bool get_HasSetValueHelper();
    public virtual bool get_HasDeferredValueProxy();
    public virtual int get_LineNumber();
    public virtual int get_ColumnNumber();
    public BindPathStep ParseBindPath(IList`1<string> warnings);
    public BindPathStep ParseBindPath(string path, IList`1<string> warnings);
    protected static string GetBindingPath(XamlDomObject bindItem);
    private static string GetImplicitPath(XamlDomObject bindItem);
    public sealed virtual XamlType ResolveXmlName(string name);
    public sealed virtual XamlType ResolveType(Type type);
    public sealed virtual bool CanAssignDirectlyTo(XamlType source, XamlType destination);
    public sealed virtual bool CanInlineConvert(XamlType source, XamlType destination);
    [CompilerGeneratedAttribute]
private string <get_ObjectDeferredAssignmentCodeName>b__21_0();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.BindAssignmentValidationError : XamlCompileError {
    public BindAssignmentValidationError(IXamlDomNode node, string message);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.BindAssignmentValidationWarning : XamlCompileWarning {
    public BindAssignmentValidationWarning(IXamlDomNode node, ErrorCode errorCode, string message);
}
public abstract class Microsoft.UI.Xaml.Markup.Compiler.BindPathStep : object {
    private BindStatus bindStatus;
    private List`1<IBindAssignment> bindAssignments;
    private Dictionary`2<string, BindPathStep> children;
    private List`1<int> distinctPhases;
    private Dictionary`2<string, BindPathStep> dependents;
    private Dictionary`2<string, BindPathStep> dependencies;
    [CompilerGeneratedAttribute]
private XamlType <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private BindPathStep <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private ApiInformation <ApiInformation>k__BackingField;
    public string UniqueName { get; }
    public XamlType ValueType { get; }
    public BindPathStep Parent { get; }
    public IEnumerable`1<BindPathStep> Parents { get; }
    public ApiInformation ApiInformation { get; }
    public bool UpdateNeedsBindingsVariable { get; }
    public string CodeName { get; }
    public BindStatus BindStatus { get; private set; }
    public IEnumerable`1<IBindAssignment> BindAssignments { get; }
    public bool RequiresChildNotification { get; }
    public bool NeedsUpdateChildListeners { get; }
    public bool HasTrackingDPs { get; }
    public bool IsTrackingSource { get; }
    public IEnumerable`1<BindPathStep> Children { get; }
    public IEnumerable`1<BindPathStep> TrackingSteps { get; }
    public IEnumerable`1<BindPathStep> Dependents { get; }
    public IEnumerable`1<BindPathStep> Dependencies { get; }
    internal IList`1<BindPathStep> ParentsAndSelf { get; }
    public List`1<int> DistinctPhases { get; }
    public bool ValueTypeIsConditional { get; }
    public IEnumerable`1<IBindAssignment> AssociatedBindAssignments { get; }
    public bool IsValueRequired { get; }
    public bool ImplementsINPC { get; }
    public bool ImplementsINCC { get; }
    public bool ImplementsINDEI { get; }
    public bool ImplementsIObservableVector { get; }
    public bool ImplementsIObservableMap { get; }
    public bool IsIncludedInUpdate { get; }
    public string PhaseList { get; }
    public bool NeedsCheckForNull { get; }
    public string TryGetValueCodeName { get; }
    public BindPathStep(XamlType valueType, BindPathStep parent, ApiInformation apiInformation);
    public abstract virtual string get_UniqueName();
    [CompilerGeneratedAttribute]
public virtual XamlType get_ValueType();
    [CompilerGeneratedAttribute]
public BindPathStep get_Parent();
    public IEnumerable`1<BindPathStep> get_Parents();
    [CompilerGeneratedAttribute]
public ApiInformation get_ApiInformation();
    public bool get_UpdateNeedsBindingsVariable();
    public string get_CodeName();
    public BindStatus get_BindStatus();
    private void set_BindStatus(BindStatus value);
    public IEnumerable`1<IBindAssignment> get_BindAssignments();
    public bool get_RequiresChildNotification();
    public bool get_NeedsUpdateChildListeners();
    public bool get_HasTrackingDPs();
    public bool get_IsTrackingSource();
    public IEnumerable`1<BindPathStep> get_Children();
    public IEnumerable`1<BindPathStep> get_TrackingSteps();
    public IEnumerable`1<BindPathStep> get_Dependents();
    public IEnumerable`1<BindPathStep> get_Dependencies();
    internal IList`1<BindPathStep> get_ParentsAndSelf();
    public List`1<int> get_DistinctPhases();
    public virtual bool get_ValueTypeIsConditional();
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.BindPathStep/<get_AssociatedBindAssignments>d__52")]
public virtual IEnumerable`1<IBindAssignment> get_AssociatedBindAssignments();
    public virtual bool get_IsValueRequired();
    public bool get_ImplementsINPC();
    public bool get_ImplementsINCC();
    public bool get_ImplementsINDEI();
    public bool get_ImplementsIObservableVector();
    public bool get_ImplementsIObservableMap();
    public virtual bool get_IsIncludedInUpdate();
    public string get_PhaseList();
    public virtual bool get_NeedsCheckForNull();
    public void AddBindAssignment(IBindAssignment bindAssignment);
    public void AddChild(BindPathStep step);
    public void AddDependent(BindPathStep dependent);
    public string get_TryGetValueCodeName();
    public static BindPathStep Parse(string bindPath, ApiInformation apiInformation, IBindUniverse bindUniverse, IXamlTypeResolver resolver, IList`1<string> warnings);
}
[FlagsAttribute]
public enum Microsoft.UI.Xaml.Markup.Compiler.BindStatus : Enum {
    public int value__;
    public static BindStatus None;
    public static BindStatus HasBinding;
    public static BindStatus TracksSource;
    public static BindStatus TracksTarget;
    public static BindStatus HasFallbackValue;
    public static BindStatus HasTargetNullValue;
    public static BindStatus HasConverter;
    public static BindStatus HasEventBinding;
}
internal class Microsoft.UI.Xaml.Markup.Compiler.BindUniverse : object {
    private IEnumerable`1<string> distinctConvertersUsed;
    private string parentClassShortName;
    public IList`1<BindUniverse> Children;
    public BindUniverse Parent;
    public Dictionary`2<string, BindPathStep> BindPathSteps;
    [CompilerGeneratedAttribute]
private BindPathStep <RootStep>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConnectionIdElement> <NamedElements>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionIdElement <RootElement>k__BackingField;
    internal List`1<BindAssignment> BindAssignments;
    internal List`1<BoundEventAssignment> BoundEventAssignments;
    internal List`1<ConnectionIdElement> BoundElements;
    internal List`1<ConnectionIdElement> OuterScopeBoundElements;
    internal IList`1<ConnectionIdElement> UnloadableBindingSourceElements;
    private IList`1<ConnectionIdElement> directParentsOfUnloadables;
    internal Dictionary`2<int, List`1<PhaseAssignment>> PhaseAssignments;
    public bool NeededForOuterScopeElement;
    [CompilerGeneratedAttribute]
private bool <IsFileRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <DataRootType>k__BackingField;
    private IEnumerable`1<FieldDefinition> rootFieldDefinitions;
    [CompilerGeneratedAttribute]
private BindPathStep <ElementRootStep>k__BackingField;
    public BindPathStep RootStep { get; private set; }
    public IList`1<ConnectionIdElement> NamedElements { get; }
    internal ConnectionIdElement RootElement { get; private set; }
    internal bool IsFileRoot { get; private set; }
    internal XamlType DataRootType { get; private set; }
    public BindPathStep ElementRootStep { get; private set; }
    public string BindingsClassName { get; }
    public string BindingsTrackingClassName { get; }
    public bool HasBindings { get; }
    public bool HasBindAssignments { get; }
    public bool HasBoundEventAssignments { get; }
    public bool HasFunctionBindings { get; }
    internal bool NeedsIDataTemplateExtension { get; }
    internal bool NeedsIDataTemplateComponent { get; }
    internal IEnumerable`1<string> DistinctConvertersUsed { get; }
    public IEnumerable`1<BindPathStep> TryGetValueSteps { get; }
    internal IEnumerable`1<ConnectionIdElement> ElementsWithDisconnectCase { get; }
    internal IEnumerable`1<ConnectionIdElement> ElementsWithBoundLoadAssignments { get; }
    public IEnumerable`1<ConnectionIdElement> ElementsWithConnectCase { get; }
    public IEnumerable`1<ConnectionIdElement> ElementsWithConnectCaseInLocalScope { get; }
    internal bool NeedsCompleteUpdate { get; }
    public bool NeedsCppBindingTrackingClass { get; }
    public bool NeedsBindingsTracking { get; }
    public IEnumerable`1<BindPathStep> INDEIPathSteps { get; }
    internal BindUniverse(ConnectionIdElement rootElement, XamlType dataRootType, bool isFileRoot, string classShortName);
    [CompilerGeneratedAttribute]
public sealed virtual BindPathStep get_RootStep();
    [CompilerGeneratedAttribute]
private void set_RootStep(BindPathStep value);
    [CompilerGeneratedAttribute]
public IList`1<ConnectionIdElement> get_NamedElements();
    [CompilerGeneratedAttribute]
internal ConnectionIdElement get_RootElement();
    [CompilerGeneratedAttribute]
private void set_RootElement(ConnectionIdElement value);
    [CompilerGeneratedAttribute]
internal bool get_IsFileRoot();
    [CompilerGeneratedAttribute]
private void set_IsFileRoot(bool value);
    [CompilerGeneratedAttribute]
internal XamlType get_DataRootType();
    [CompilerGeneratedAttribute]
private void set_DataRootType(XamlType value);
    [CompilerGeneratedAttribute]
public BindPathStep get_ElementRootStep();
    [CompilerGeneratedAttribute]
private void set_ElementRootStep(BindPathStep value);
    public sealed virtual BindPathStep MakeOrGetRootStepOutOfScope();
    private void ProcessRootNamedElementSteps(Version targetPlatformMinVersion, List`1<XamlCompileErrorBase> issues);
    internal IEnumerable`1<XamlCompileErrorBase> Parse(XamlClassCodeInfo classCodeInfo, Version targetPlatformMinVersion);
    internal void AddPhase(PhaseAssignment phase);
    internal int GetNextPhase(int currentPhase);
    public sealed virtual BindPathStep EnsureUniquePathStep(BindPathStep step);
    public string get_BindingsClassName();
    public string get_BindingsTrackingClassName();
    public bool get_HasBindings();
    public bool get_HasBindAssignments();
    public bool get_HasBoundEventAssignments();
    public bool get_HasFunctionBindings();
    internal bool get_NeedsIDataTemplateExtension();
    internal bool get_NeedsIDataTemplateComponent();
    internal IEnumerable`1<string> get_DistinctConvertersUsed();
    public IEnumerable`1<BindPathStep> get_TryGetValueSteps();
    private void AddTryGetValueStep(Dictionary`2<string, BindPathStep> steps, BindPathStep step);
    internal IEnumerable`1<ConnectionIdElement> get_ElementsWithDisconnectCase();
    internal IEnumerable`1<ConnectionIdElement> get_ElementsWithBoundLoadAssignments();
    public IEnumerable`1<ConnectionIdElement> get_ElementsWithConnectCase();
    public IEnumerable`1<ConnectionIdElement> get_ElementsWithConnectCaseInLocalScope();
    internal bool get_NeedsCompleteUpdate();
    public bool get_NeedsCppBindingTrackingClass();
    public bool get_NeedsBindingsTracking();
    public IEnumerable`1<BindPathStep> get_INDEIPathSteps();
    public sealed virtual XamlType GetNamedElementType(string name, String& objectCodeName);
    public sealed virtual XamlType GetNamedFieldType(string name);
    [CompilerGeneratedAttribute]
private bool <Parse>b__40_0(ConnectionIdElement c);
    [CompilerGeneratedAttribute]
private bool <get_ElementsWithConnectCaseInLocalScope>b__72_0(ConnectionIdElement ele);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.BoundEventAssignment : BindAssignmentBase {
    private IEnumerable`1<Parameter> parameters;
    public IEnumerable`1<Parameter> Parameters { get; }
    public string EventHandlerCodeName { get; }
    public BoundEventAssignment(XamlDomMember bindMember, BindUniverse bindUniverse, ConnectionIdElement connectionIdElement);
    public IEnumerable`1<Parameter> get_Parameters();
    public string get_EventHandlerCodeName();
    public IEnumerable`1<XamlCompileErrorBase> ParsePath();
    private bool ValidateEvent(IList`1<XamlCompileErrorBase> issues, BindPathStep leafStep);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.BoundLoadAssignment : BindAssignment {
    public XamlType MemberType { get; }
    public XamlType MemberDeclaringType { get; }
    public bool IsAttachable { get; }
    public bool HasSetValueHelper { get; }
    public bool HasDeferredValueProxy { get; }
    public BoundLoadAssignment(XamlDomMember bindMember, BindUniverse bindUniverse, ConnectionIdElement connectionIdElement);
    public virtual XamlType get_MemberType();
    public virtual XamlType get_MemberDeclaringType();
    public virtual bool get_IsAttachable();
    public virtual bool get_HasSetValueHelper();
    public virtual bool get_HasDeferredValueProxy();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.BoundPropertyAssignment : BindAssignment {
    public BoundPropertyAssignment(XamlDomMember bindMember, BindUniverse bindUniverse, ConnectionIdElement connectionIdElement);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.BuildTaskFileService : object {
    private string langExtension;
    public bool HasIdeHost { get; }
    public bool IsRealBuild { get; }
    public BuildTaskFileService(string languageExtension);
    public virtual bool get_HasIdeHost();
    public virtual TextReader GetFileContents(string srcFile);
    public virtual DateTime GetLastChangeTime(string srcFile);
    public bool FileExists(string srcFile);
    public virtual void DeleteFile(string srcFile);
    public void WriteFile(string fileContents, string destinationFile);
    public virtual bool get_IsRealBuild();
}
public class Microsoft.UI.Xaml.Markup.Compiler.CastStep : BindPathStep {
    public string UniqueName { get; }
    public CastStep(XamlType valueType, BindPathStep parent, ApiInformation apiInformation);
    public virtual string get_UniqueName();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.ClassName : object {
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    public string Namespace { get; }
    public string ShortName { get; }
    public string FullName { get; }
    public ClassName(string fullName);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public string get_ShortName();
    public string get_FullName();
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.ClrNamespaceParser : object {
    internal static bool TryParseUri(string uriInput, String& clrNs, String& assemblyName, String& error, bool returnErrors);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.ApiInformationCodeGenerator : CodeGeneratorBase`1<ApiInformation> {
    public ICodeGenOutput CallExpression { get; }
    public sealed virtual ICodeGenOutput get_CallExpression();
}
[ExtensionAttribute]
internal static class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.ApiInformationCodeGenExtensions : object {
    private static Dictionary`2<ApiInformation, IApiInformationCodeGen> apiInformationCache;
    private static Dictionary`2<ApiInformationMethod, IApiInformationCodeGen> apiInformationMethodCache;
    private static Dictionary`2<ApiInformationParameter, IApiInformationCodeGen> apiInformationParameterCache;
    private static ApiInformationCodeGenExtensions();
    [ExtensionAttribute]
public static IApiInformationCodeGen CodeGen(ApiInformation instance);
    [ExtensionAttribute]
public static IApiInformationCodeGen CodeGen(ApiInformationMethod instance);
    [ExtensionAttribute]
public static IApiInformationCodeGen CodeGen(ApiInformationParameter instance);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.ApiInformationMethodCodeGenerator : CodeGeneratorBase`1<ApiInformationMethod> {
    public ICodeGenOutput CallExpression { get; }
    public sealed virtual ICodeGenOutput get_CallExpression();
    [CompilerGeneratedAttribute]
private string <get_CallExpression>b__1_0();
    [CompilerGeneratedAttribute]
private string <get_CallExpression>b__1_1();
    [CompilerGeneratedAttribute]
private string <get_CallExpression>b__1_2();
    [CompilerGeneratedAttribute]
private string <get_CallExpression>b__1_3();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.ApiInformationParameterCodeGenerator : CodeGeneratorBase`1<ApiInformationParameter> {
    public ICodeGenOutput CallExpression { get; }
    public sealed virtual ICodeGenOutput get_CallExpression();
    [CompilerGeneratedAttribute]
private string <get_CallExpression>b__1_0();
    [CompilerGeneratedAttribute]
private string <get_CallExpression>b__1_1();
    [CompilerGeneratedAttribute]
private string <get_CallExpression>b__1_2();
    [CompilerGeneratedAttribute]
private string <get_CallExpression>b__1_3();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.ArrayIndexStepCodeGenerator : BindPathStepCodeGenerator`1<ArrayIndexStep> {
    public ICodeGenOutput PathExpression { get; }
    public ICodeGenOutput UpdateCallParam { get; }
    public virtual ICodeGenOutput get_PathExpression();
    public virtual ICodeGenOutput PathSetExpression(ICodeGenOutput value);
    public virtual ICodeGenOutput get_UpdateCallParam();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_0();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_1();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_2();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_3();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.AttachedPropertyStepCodeGenerator : DependencyPropertyStepCodeGenerator`1<AttachedPropertyStep> {
    public ICodeGenOutput PathExpression { get; }
    public ICodeGenOutput UpdateCallParam { get; }
    public virtual ICodeGenOutput get_PathExpression();
    public virtual ICodeGenOutput PathSetExpression(ICodeGenOutput value);
    public virtual ICodeGenOutput get_UpdateCallParam();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_0();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_1();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_2();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_3();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.BindingInfoDefinition : Definition {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, XamlType> <ObservableVectorTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, XamlType> <ObservableMapTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, XamlMember> <BindingSetters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EventBindingUsed>k__BackingField;
    internal Dictionary`2<string, XamlType> ObservableVectorTypes { get; internal set; }
    internal Dictionary`2<string, XamlType> ObservableMapTypes { get; internal set; }
    internal Dictionary`2<string, XamlMember> BindingSetters { get; internal set; }
    internal bool EventBindingUsed { get; internal set; }
    public BindingInfoDefinition(XamlProjectInfo projectInfo, XamlSchemaCodeInfo schemaInfo);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, XamlType> get_ObservableVectorTypes();
    [CompilerGeneratedAttribute]
internal void set_ObservableVectorTypes(Dictionary`2<string, XamlType> value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, XamlType> get_ObservableMapTypes();
    [CompilerGeneratedAttribute]
internal void set_ObservableMapTypes(Dictionary`2<string, XamlType> value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, XamlMember> get_BindingSetters();
    [CompilerGeneratedAttribute]
internal void set_BindingSetters(Dictionary`2<string, XamlMember> value);
    [CompilerGeneratedAttribute]
internal bool get_EventBindingUsed();
    [CompilerGeneratedAttribute]
internal void set_EventBindingUsed(bool value);
}
[ExtensionAttribute]
internal static class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.BindPathParameterCodeGenExtensions : object {
    public static Dictionary`2<Parameter, IBindPathParameterCodeGen> generatorCache;
    private static BindPathParameterCodeGenExtensions();
    [ExtensionAttribute]
public static IBindPathParameterCodeGen CodeGen(Parameter instance);
}
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.BindPathStepCodeGenerator`1 : CodeGeneratorBase`1<T> {
    public ICodeGenOutput MemberAccessOperator { get; }
    public ICodeGenOutput PathExpression { get; }
    public ICodeGenOutput UpdateCallParam { get; }
    public virtual ICodeGenOutput get_MemberAccessOperator();
    public abstract virtual ICodeGenOutput get_PathExpression();
    public virtual ICodeGenOutput PathSetExpression(ICodeGenOutput value);
    public virtual ICodeGenOutput get_UpdateCallParam();
    [CompilerGeneratedAttribute]
private string <get_MemberAccessOperator>b__1_0();
}
[ExtensionAttribute]
internal static class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.BindPathStepCodeGenExtensions : object {
    public static Dictionary`2<BindPathStep, IBindPathStepCodeGen> generatorCache;
    private static BindPathStepCodeGenExtensions();
    [ExtensionAttribute]
public static IBindPathStepCodeGen CodeGen(BindPathStep instance);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CastStepCodeGenerator : BindPathStepCodeGenerator`1<CastStep> {
    public ICodeGenOutput PathExpression { get; }
    public ICodeGenOutput UpdateCallParam { get; }
    public virtual ICodeGenOutput get_PathExpression();
    public virtual ICodeGenOutput get_UpdateCallParam();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.ClassCodeGenFile : object {
    private string _classFullName;
    private List`1<TaskItemFilename> _xamlTaskItems;
    [CompilerGeneratedAttribute]
private string <TargetFolderFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseFileName>k__BackingField;
    public string TargetFolderFullPath { get; public set; }
    public string BaseFileName { get; public set; }
    public ReadOnlyCollection`1<TaskItemFilename> XamlTaskItems { get; }
    public ClassCodeGenFile(string classFullName);
    [CompilerGeneratedAttribute]
public string get_TargetFolderFullPath();
    [CompilerGeneratedAttribute]
public void set_TargetFolderFullPath(string value);
    [CompilerGeneratedAttribute]
public string get_BaseFileName();
    [CompilerGeneratedAttribute]
public void set_BaseFileName(string value);
    private void EnsureXamlTaskItems();
    private void RecalculateBaseFileNameWithTif(TaskItemFilename tif);
    private void ResetBaseFileName();
    public void AddTaskItem(TaskItemFilename tif);
    public void RemoveTaskItem(TaskItemFilename tif);
    public ReadOnlyCollection`1<TaskItemFilename> get_XamlTaskItems();
}
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CodeGenerator`1 : T4Base`1<T> {
    protected virtual string GetPhaseCondition(BindPathStep bindStep);
    public virtual string GetDirectPhaseCondition(int phase, bool isTracking);
}
public class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CodeGeneratorBase`1 : object {
    [CompilerGeneratedAttribute]
private T <Instance>k__BackingField;
    public T Instance { get; public set; }
    [CompilerGeneratedAttribute]
public void set_Instance(T value);
    [CompilerGeneratedAttribute]
public T get_Instance();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppCX_CodeGenerator`1 : NativeCodeGenerator`1<T> {
    public virtual string ToStringWithCulture(ICodeGenOutput codegenOutput);
    public virtual string ToStringWithCulture(XamlType type);
    public static string Colonize(string typeName);
    internal static string ColonizeRef(EventAssignment ev);
    internal static string ColonizeRef(BoundEventAssignment ev);
    public static string Projection(string typeName);
    protected string GetBindingFullClassName(BindUniverse bindUniverse, XamlClassCodeInfo codeInfo);
    protected string GetBindingTrackingFullClassName(BindUniverse bindUniverse, XamlClassCodeInfo codeInfo);
    public void OutputNamespaceBegin(string name);
    public void OutputNamespaceEnd(string name);
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_AppPass1 : CppWinRT_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_AppPass2 : CppWinRT_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_BindingInfoPass1 : CppWinRT_CodeGenerator`1<BindingInfoDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_BindingInfoPass2 : CppWinRT_CodeGenerator`1<BindingInfoDefinition> {
    public virtual string TransformText();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_CodeGenerator`1 : NativeCodeGenerator`1<T> {
    public virtual string ToStringWithCulture(ICodeGenOutput codegenOutput);
    public virtual string ToStringWithCulture(XamlType type);
    public static string Projection(string typeName);
    protected string GetBindingTrackingClassName(BindUniverse bindUniverse, XamlClassCodeInfo codeInfo);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_CodeGenerator`1/<GetCacheDeclarations>d__4")]
public IEnumerable`1<string> GetCacheDeclarations(BindUniverse bindUniverse);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_CodeGenerator`1/<GetTokenDeclarations>d__5")]
public IEnumerable`1<string> GetTokenDeclarations(BindUniverse bindUniverse);
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_MetadataDelegates : CppWinRT_CodeGenerator`1<TypeGenInfo> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PageBinding : CppWinRT_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
    private void Output_ConnectionId_Case(ConnectionIdElement element);
    private void Output_Listener_Tracking_Fields(BindUniverse bindUniverse);
    private void Output_Connect_TwoWayBinding(BindAssignment ba);
    private void Output_NullCheckedAssignment(BindPathStep step, LanguageSpecificString value);
    private void Output_NullCheckedEventAssignment(BoundEventAssignment evt);
    private void Output_UpdateChildListeners_Call(BindPathStep step, string parameter);
    private void Output_Binding_Phased_SetValue(int phase, bool isTracking, BindPathStep bindStep, bool isFunctionResult);
    private void Output_Binding_Phased_Fallback_SetValue(int phase, bool isTracking, BindPathStep bindStep);
    private void Output_Binding_SetValue(BindAssignment bindAssignment, bool isFunctionResult);
    private void Output_Binding_SetValue_Non_Function_Call(BindAssignment ba, string value, bool includeDeferredSet);
    private void Output_Update_DataChanged_Step(BindPathStep step);
    private void Output_Update_Steps(bool checkForNull, IEnumerable`1<BindPathStep> steps, bool checkPhaseCondition, string phaseParam);
    private void Output_Custom_Update_Call(BindPathStep step, string firstArgument, string phaseParam);
    private void Output_UpdateCall(BindPathStep step, string phaseParam);
    private void Output_CompleteUpdate(BindUniverse bindUniverse);
    private void Output_FunctionBindings(BindUniverse bindUniverse);
    private void Output_TryGetValueFunctions(BindUniverse bindUniverse);
    private void Output_BindingSetValueFunction(BindAssignment ba);
    private string GetCacheArgumentStatement(BindPathStep step, string prefix, BindPathStep child);
    private void Output_BindingSetters(BindUniverse bu);
    private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent);
    private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent);
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PageBindingTracking : CppWinRT_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PagePass1 : CppWinRT_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PagePass2 : CppWinRT_CodeGenerator`1<PageDefinition> {
    private HashSet`1<XamlType> staticAssertTypes;
    public virtual string TransformText();
    private void Output_InitializeComponent();
    private void Output_ConnectMethod();
    private void Output_EmptyUnloadMethods();
    private void Output_UnloadMethods();
    private void Output_ConnectionId_Case(ConnectionIdElement element);
    private void Output_EmptyGetBindingConnectorMethod();
    private void Output_GetBindingConnectorMethod();
    private void Output_PushDeprecated(bool isDeprecated);
    private void Output_PopDeprecated(bool isDeprecated);
    private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent);
    private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent);
    private void Output_StaticAssertTypeIsComplete(XamlType type, Indent indent);
    [CompilerGeneratedAttribute]
private bool <TransformText>b__0_4(TypeGenInfo t);
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TemplatedMetadataDelegates : CppWinRT_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TypeInfoPass1 : CppWinRT_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TypeInfoPass1Impl : CppWinRT_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TypeInfoPass2 : CppWinRT_CodeGenerator`1<TypeInfoDefinition> {
    private HashSet`1<TypeGenInfo> staticAssertTypes;
    public virtual string TransformText();
    private void Output_StaticAssertTypeIsComplete(TypeGenInfo typeInfo, Indent indent);
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_XamlMetaDataProviderPass1 : CppWinRT_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_XamlMetaDataProviderPass2 : CppWinRT_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharp_CodeGenerator`1 : ManagedCodeGenerator`1<T> {
    public string GeneratedCodeAttribute { get; }
    public string DebuggerNonUserCodeAttribute { get; }
    public string OverloadAttribute { get; }
    public string NotCLSCompliantAttribute { get; }
    public virtual string ToStringWithCulture(ICodeGenOutput codegenOutput);
    public virtual string ToStringWithCulture(XamlType type);
    public string Globalize(string fullType);
    public string get_GeneratedCodeAttribute();
    public string get_DebuggerNonUserCodeAttribute();
    public string get_OverloadAttribute();
    public string PrependNamespace(string objectType);
    public string ObjectCast(string destinationType, string sourceName);
    public string get_NotCLSCompliantAttribute();
    public string INPCInterfaceName(BindPathStep step);
    public string PropertyChangedEventArgName(BindPathStep step);
    public string INDEIInterfaceName(BindPathStep step);
    public string DataErrorsEventArgName(BindPathStep step);
    public string INCCInterfaceName(BindPathStep step);
    public string NotifyCollectionChangedEventArgName(BindPathStep step);
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpAppPass1 : CSharp_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpPagePass1 : CSharp_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
    private void Output_InitializeComponent();
    private void Output_FieldDefinitions();
    private void Output_BindingsHeader();
    private void Output_xProperties();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpPagePass2 : CSharp_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
    private void Output_InitializeXProperties();
    private void Output_ConnectMethod();
    private void Output_UnloadObjectMethod();
    private void Output_GetBindingConnectorCaseBindingPropertiesSet(ConnectionIdElement element, bool isPageRoot);
    private void Output_GetBindingConnectorCase(ConnectionIdElement element, bool isPageRoot);
    private void Output_GetBindingConnectorMethod();
    private void Output_PushDeprecated(bool isDeprecated);
    private void Output_PopDeprecated(bool isDeprecated);
    private void Output_BindingsClasses();
    private void Output_UpdateChildListeners(BindPathStep step, BindUniverse bindUniverse);
    private void Output_RegisterTwoWayListeners(ConnectionIdElement element);
    private void Output_UpdateTwoWay(BindAssignment ba);
    private void Output_NullCheckedAssignment(BindPathStep step, LanguageSpecificString value);
    private void Output_NullCheckedEventAssignment(BoundEventAssignment evt);
    private void Output_UpdateErrors(BindUniverse bindUniverse);
    private void Output_UpdateErrorsCall(PropertyStep step);
    private void Output_Binding_SetValue_Function(BindAssignment ba);
    private void Output_Binding_Phased_SetValue(int phase, bool isTracking, BindPathStep bindStep, bool isFunctionResult);
    private void Output_Binding_Phased_Fallback_SetValue(int phase, bool isTracking, BindPathStep bindStep);
    private void Output_Binding_SetValue(BindAssignment bindAssignment, bool isFunctionResult);
    private void Output_Binding_SetValue_Non_Function_Call(BindAssignment bindAssignment, string value, bool includeDeferredSet);
    private void Output_Update_DataChanged_Step(string context, BindPathStep step);
    private void Output_Update_Steps(bool checkForNull, string context, IEnumerable`1<BindPathStep> steps, bool checkPhaseCondition, string phaseParam);
    private string GetUpdateParams(BindPathStep bindStep);
    private void Output_Custom_Update_Call(string context, BindPathStep step, string firstArgument, string phaseParam);
    private void Output_UpdateCall(string context, BindPathStep step, string phaseParam);
    private void Output_CompleteUpdate(BindUniverse bindUniverse);
    private void Output_FunctionBindings(BindUniverse bindUniverse);
    private void Output_TryGetValueFunctions(BindUniverse bindUniverse);
    private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent);
    private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent);
    private void Output_ApiInformationDeclarations();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpTypeInfoPass2 : CSharp_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
    private void Output_CheckOtherMetadataProviders();
    private void Output_TypeTables();
    private void Output_CreateXamlType();
    private void Output_Activators();
    private void Output_StaticInitializers();
    private void Output_ListAndMapMethods();
    private void Output_CreateXamlMember();
    private void Output_SettersAndGetters();
    private void Output_AppMetadataProvider();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CXMetadataDelegates : CppCX_CodeGenerator`1<TypeGenInfo> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CXTemplatedMetadataDelegates : CppCX_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.Definition : object {
    private IEnumerable`1<TypeGenInfo> _typeInfos;
    [CompilerGeneratedAttribute]
private XamlProjectInfo <ProjectInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlSchemaCodeInfo <SchemaInfo>k__BackingField;
    public XamlProjectInfo ProjectInfo { get; }
    public XamlSchemaCodeInfo SchemaInfo { get; }
    public IEnumerable`1<TypeGenInfo> TypeInfos { get; }
    public Definition(XamlProjectInfo projectInfo, XamlSchemaCodeInfo schemaInfo);
    [CompilerGeneratedAttribute]
public XamlProjectInfo get_ProjectInfo();
    [CompilerGeneratedAttribute]
public XamlSchemaCodeInfo get_SchemaInfo();
    public IEnumerable`1<TypeGenInfo> get_TypeInfos();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.DependencyPropertyStepCodeGenerator`1 : PropertyStepCodeGenerator`1<T> {
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.EnumGenInfo : object {
    [CompilerGeneratedAttribute]
private TypeGenInfo <TypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValueName>k__BackingField;
    public TypeGenInfo TypeInfo { get; private set; }
    public string ValueName { get; private set; }
    public EnumGenInfo(TypeGenInfo typeInfo, string valueName);
    [CompilerGeneratedAttribute]
public TypeGenInfo get_TypeInfo();
    [CompilerGeneratedAttribute]
private void set_TypeInfo(TypeGenInfo value);
    [CompilerGeneratedAttribute]
public string get_ValueName();
    [CompilerGeneratedAttribute]
private void set_ValueName(string value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.FieldStepCodeGenerator : PropertyStepCodeGenerator`1<FieldStep> {
    public ICodeGenOutput PathExpression { get; }
    public ICodeGenOutput UpdateCallParam { get; }
    public virtual ICodeGenOutput get_PathExpression();
    public virtual ICodeGenOutput get_UpdateCallParam();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.FunctionBoolParamCodeGenerator : ParameterCodeGenerator`1<FunctionBoolParam> {
    public ICodeGenOutput PathExpression { get; }
    public virtual ICodeGenOutput get_PathExpression();
    [CompilerGeneratedAttribute]
private string <get_PathExpression>b__1_0();
    [CompilerGeneratedAttribute]
private string <get_PathExpression>b__1_1();
    [CompilerGeneratedAttribute]
private string <get_PathExpression>b__1_2();
    [CompilerGeneratedAttribute]
private string <get_PathExpression>b__1_3();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.FunctionNullValueParamCodeGenerator : ParameterCodeGenerator`1<FunctionNullValueParam> {
    public ICodeGenOutput PathExpression { get; }
    public virtual ICodeGenOutput get_PathExpression();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.FunctionNumberParamCodeGenerator : ParameterCodeGenerator`1<FunctionNumberParam> {
    public ICodeGenOutput PathExpression { get; }
    public virtual ICodeGenOutput get_PathExpression();
    [CompilerGeneratedAttribute]
private string <get_PathExpression>b__1_0();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.FunctionPathParamCodeGenerator : ParameterCodeGenerator`1<FunctionPathParam> {
    public ICodeGenOutput PathExpression { get; }
    public virtual ICodeGenOutput get_PathExpression();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.FunctionStepCodeGenerator : BindPathStepCodeGenerator`1<FunctionStep> {
    public ICodeGenOutput PathExpression { get; }
    public ICodeGenOutput UpdateCallParam { get; }
    public virtual ICodeGenOutput get_PathExpression();
    public virtual ICodeGenOutput get_UpdateCallParam();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.FunctionStringParamCodeGenerator : ParameterCodeGenerator`1<FunctionStringParam> {
    public ICodeGenOutput PathExpression { get; }
    public virtual ICodeGenOutput get_PathExpression();
    [CompilerGeneratedAttribute]
private string <get_PathExpression>b__1_0();
    [CompilerGeneratedAttribute]
private string <get_PathExpression>b__1_1();
    [CompilerGeneratedAttribute]
private string <get_PathExpression>b__1_2();
    [CompilerGeneratedAttribute]
private string <get_PathExpression>b__1_3();
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.CodeGen.IApiInformationCodeGen {
    public ICodeGenOutput CallExpression { get; }
    public abstract virtual ICodeGenOutput get_CallExpression();
}
public interface Microsoft.UI.Xaml.Markup.Compiler.CodeGen.IBindPathParameterCodeGen {
    public ICodeGenOutput PathExpression { get; }
    public abstract virtual ICodeGenOutput get_PathExpression();
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.CodeGen.IBindPathStepCodeGen {
    public ICodeGenOutput PathExpression { get; }
    public ICodeGenOutput UpdateCallParam { get; }
    public ICodeGenOutput MemberAccessOperator { get; }
    public abstract virtual ICodeGenOutput get_PathExpression();
    public abstract virtual ICodeGenOutput get_UpdateCallParam();
    public abstract virtual ICodeGenOutput PathSetExpression(ICodeGenOutput input);
    public abstract virtual ICodeGenOutput get_MemberAccessOperator();
}
internal enum Microsoft.UI.Xaml.Markup.Compiler.CodeGen.Indent : Enum {
    public int value__;
    public static Indent None;
    public static Indent OneTab;
    public static Indent TwoTabs;
    public static Indent ThreeTabs;
    public static Indent FourTabs;
    public static Indent FiveTabs;
    public static Indent SixTabs;
    public static Indent SevenTabs;
}
[DebuggerDisplayAttribute("{StandardName} Sys={IsSystemType}")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.InternalTypeEntry : object {
    private string _name;
    private int _typeIndex;
    private TypeForCodeGen _type;
    [CompilerGeneratedAttribute]
private InternalXamlUserTypeInfo <UserTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHandledByOtherProviders>k__BackingField;
    public Type UnderlyingType { get; }
    public string SystemName { get; }
    public string StandardName { get; }
    public LanguageSpecificString FullName { get; }
    public string MemberFriendlyName { get; }
    public InternalXamlUserTypeInfo UserTypeInfo { get; public set; }
    public bool IsSystemType { get; }
    public int TypeIndex { get; public set; }
    public bool IsValueType { get; public set; }
    public string RefHat { get; }
    public string Name { get; }
    public bool IsDeprecated { get; }
    public bool IsHandledByOtherProviders { get; public set; }
    public InternalTypeEntry(XamlType xamlType);
    public Type get_UnderlyingType();
    public string get_SystemName();
    public string get_StandardName();
    public LanguageSpecificString get_FullName();
    public string get_MemberFriendlyName();
    [CompilerGeneratedAttribute]
public void set_UserTypeInfo(InternalXamlUserTypeInfo value);
    [CompilerGeneratedAttribute]
public InternalXamlUserTypeInfo get_UserTypeInfo();
    public bool get_IsSystemType();
    public int get_TypeIndex();
    public void set_TypeIndex(int value);
    [CompilerGeneratedAttribute]
public bool get_IsValueType();
    [CompilerGeneratedAttribute]
public void set_IsValueType(bool value);
    public string get_RefHat();
    public string get_Name();
    public bool get_IsDeprecated();
    [CompilerGeneratedAttribute]
public bool get_IsHandledByOtherProviders();
    [CompilerGeneratedAttribute]
public void set_IsHandledByOtherProviders(bool value);
}
[DebuggerDisplayAttribute("{Type.Name}  {DeclaringType.Name}.{Name}")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.InternalXamlUserMemberInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private InternalTypeEntry <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSignedChar>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInvalidType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecated>k__BackingField;
    [CompilerGeneratedAttribute]
private InternalTypeEntry <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDependencyProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPublicSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPublicGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAttachable>k__BackingField;
    [CompilerGeneratedAttribute]
private InternalTypeEntry <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEvent>k__BackingField;
    public string Name { get; public set; }
    public InternalTypeEntry Type { get; public set; }
    public bool IsValueType { get; public set; }
    public bool IsString { get; public set; }
    public bool IsSignedChar { get; public set; }
    public bool IsInvalidType { get; public set; }
    public bool IsEnum { get; public set; }
    public bool IsDeprecated { get; public set; }
    public InternalTypeEntry DeclaringType { get; public set; }
    public bool IsDependencyProperty { get; public set; }
    public bool HasPublicSetter { get; public set; }
    public bool HasPublicGetter { get; public set; }
    public bool IsAttachable { get; public set; }
    public InternalTypeEntry TargetType { get; public set; }
    public bool IsEvent { get; public set; }
    public void Init(XamlMember xamlMember, XamlSchemaCodeInfo schemaInfo);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public InternalTypeEntry get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(InternalTypeEntry value);
    [CompilerGeneratedAttribute]
public bool get_IsValueType();
    [CompilerGeneratedAttribute]
public void set_IsValueType(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsString();
    [CompilerGeneratedAttribute]
public void set_IsString(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSignedChar();
    [CompilerGeneratedAttribute]
public void set_IsSignedChar(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInvalidType();
    [CompilerGeneratedAttribute]
public void set_IsInvalidType(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEnum();
    [CompilerGeneratedAttribute]
public void set_IsEnum(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDeprecated();
    [CompilerGeneratedAttribute]
public void set_IsDeprecated(bool value);
    [CompilerGeneratedAttribute]
public InternalTypeEntry get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(InternalTypeEntry value);
    [CompilerGeneratedAttribute]
public bool get_IsDependencyProperty();
    [CompilerGeneratedAttribute]
public void set_IsDependencyProperty(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasPublicSetter();
    [CompilerGeneratedAttribute]
public void set_HasPublicSetter(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasPublicGetter();
    [CompilerGeneratedAttribute]
public void set_HasPublicGetter(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAttachable();
    [CompilerGeneratedAttribute]
public void set_IsAttachable(bool value);
    [CompilerGeneratedAttribute]
public InternalTypeEntry get_TargetType();
    [CompilerGeneratedAttribute]
public void set_TargetType(InternalTypeEntry value);
    [CompilerGeneratedAttribute]
public bool get_IsEvent();
    [CompilerGeneratedAttribute]
public void set_IsEvent(bool value);
}
[DebuggerDisplayAttribute("{StandardName}")]
[ContentPropertyAttribute("Members")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.InternalXamlUserTypeInfo : object {
    private List`1<InternalXamlUserMemberInfo> _members;
    private List`1<string> _enumValues;
    private XamlSchemaCodeInfo _schemaInfo;
    private InternalTypeEntry _simpleTypeEntry;
    [CompilerGeneratedAttribute]
private InternalTypeEntry <BaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private InternalTypeEntry <BoxedType>k__BackingField;
    [CompilerGeneratedAttribute]
private InternalXamlUserMemberInfo <ContentProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReturnTypeStub>k__BackingField;
    [CompilerGeneratedAttribute]
private CreateFromStringMethod <CreateFromStringMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCreateFromStringMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConstructible>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMarkupExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBindable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLocalType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecated>k__BackingField;
    [CompilerGeneratedAttribute]
private InternalTypeEntry <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private InternalTypeEntry <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AddMethodName>k__BackingField;
    public InternalTypeEntry BaseType { get; public set; }
    public InternalTypeEntry BoxedType { get; public set; }
    public InternalXamlUserMemberInfo ContentProperty { get; public set; }
    public InternalTypeEntry TypeEntry { get; }
    public string Name { get; }
    public int TypeIndex { get; }
    public bool IsReturnTypeStub { get; public set; }
    public string SystemName { get; }
    public string StandardName { get; }
    public LanguageSpecificString FullName { get; }
    public string MemberFriendlyName { get; }
    public CreateFromStringMethod CreateFromStringMethod { get; public set; }
    public bool HasCreateFromStringMethod { get; public set; }
    public bool IsArray { get; public set; }
    public bool IsCollection { get; public set; }
    public bool IsConstructible { get; public set; }
    public bool IsDictionary { get; public set; }
    public bool IsMarkupExtension { get; public set; }
    public bool IsBindable { get; public set; }
    public bool IsLocalType { get; public set; }
    public bool IsDeprecated { get; public set; }
    public InternalTypeEntry ItemType { get; public set; }
    public InternalTypeEntry KeyType { get; public set; }
    public string AddMethodName { get; public set; }
    public List`1<InternalXamlUserMemberInfo> Members { get; }
    public bool HasMembers { get; }
    public List`1<string> EnumValues { get; }
    public bool HasEnumValues { get; }
    public InternalXamlUserTypeInfo(InternalTypeEntry entry, XamlSchemaCodeInfo schemaInfo);
    public void Init(XamlType xamlType);
    [CompilerGeneratedAttribute]
public InternalTypeEntry get_BaseType();
    [CompilerGeneratedAttribute]
public void set_BaseType(InternalTypeEntry value);
    [CompilerGeneratedAttribute]
public InternalTypeEntry get_BoxedType();
    [CompilerGeneratedAttribute]
public void set_BoxedType(InternalTypeEntry value);
    [CompilerGeneratedAttribute]
public InternalXamlUserMemberInfo get_ContentProperty();
    [CompilerGeneratedAttribute]
public void set_ContentProperty(InternalXamlUserMemberInfo value);
    public InternalTypeEntry get_TypeEntry();
    public string get_Name();
    public int get_TypeIndex();
    [CompilerGeneratedAttribute]
public bool get_IsReturnTypeStub();
    [CompilerGeneratedAttribute]
public void set_IsReturnTypeStub(bool value);
    public string get_SystemName();
    public string get_StandardName();
    public LanguageSpecificString get_FullName();
    public string get_MemberFriendlyName();
    [CompilerGeneratedAttribute]
public CreateFromStringMethod get_CreateFromStringMethod();
    [CompilerGeneratedAttribute]
public void set_CreateFromStringMethod(CreateFromStringMethod value);
    [CompilerGeneratedAttribute]
public bool get_HasCreateFromStringMethod();
    [CompilerGeneratedAttribute]
public void set_HasCreateFromStringMethod(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsArray();
    [CompilerGeneratedAttribute]
public void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCollection();
    [CompilerGeneratedAttribute]
public void set_IsCollection(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsConstructible();
    [CompilerGeneratedAttribute]
public void set_IsConstructible(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDictionary();
    [CompilerGeneratedAttribute]
public void set_IsDictionary(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMarkupExtension();
    [CompilerGeneratedAttribute]
public void set_IsMarkupExtension(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsBindable();
    [CompilerGeneratedAttribute]
public void set_IsBindable(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLocalType();
    [CompilerGeneratedAttribute]
public void set_IsLocalType(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDeprecated();
    [CompilerGeneratedAttribute]
public void set_IsDeprecated(bool value);
    [CompilerGeneratedAttribute]
public InternalTypeEntry get_ItemType();
    [CompilerGeneratedAttribute]
public void set_ItemType(InternalTypeEntry value);
    [CompilerGeneratedAttribute]
public InternalTypeEntry get_KeyType();
    [CompilerGeneratedAttribute]
public void set_KeyType(InternalTypeEntry value);
    [CompilerGeneratedAttribute]
public string get_AddMethodName();
    [CompilerGeneratedAttribute]
public void set_AddMethodName(string value);
    public List`1<InternalXamlUserMemberInfo> get_Members();
    public void AddMember(InternalXamlUserMemberInfo userMember, InternalTypeEntry declaringType, XamlSchemaCodeInfo schemaInfo);
    public bool get_HasMembers();
    public List`1<string> get_EnumValues();
    public bool get_HasEnumValues();
    private bool TryFindIndexOfMember(string name, InternalTypeEntry declaringType, Int32& idx);
    private bool TryFindMember(string name, InternalTypeEntry declaringType, InternalXamlUserMemberInfo& member);
}
public class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.LanguageSpecificString : object {
    [CompilerGeneratedAttribute]
private CodeGenDelegate <CppCXName>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGenDelegate <CppWinRTName>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGenDelegate <CSharpName>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGenDelegate <VBName>k__BackingField;
    public static LanguageSpecificString Null;
    public CodeGenDelegate CppCXName { get; }
    public CodeGenDelegate CppWinRTName { get; }
    public CodeGenDelegate CSharpName { get; }
    public CodeGenDelegate VBName { get; }
    public LanguageSpecificString(CodeGenDelegate cppCX, CodeGenDelegate cppWinRT, CodeGenDelegate cs, CodeGenDelegate vb);
    public LanguageSpecificString(CodeGenDelegate all);
    private static LanguageSpecificString();
    [CompilerGeneratedAttribute]
public sealed virtual CodeGenDelegate get_CppCXName();
    [CompilerGeneratedAttribute]
public sealed virtual CodeGenDelegate get_CppWinRTName();
    [CompilerGeneratedAttribute]
public sealed virtual CodeGenDelegate get_CSharpName();
    [CompilerGeneratedAttribute]
public sealed virtual CodeGenDelegate get_VBName();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public static bool op_Equality(LanguageSpecificString left, LanguageSpecificString right);
    public static bool op_Inequality(LanguageSpecificString left, LanguageSpecificString right);
}
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.ManagedCodeGenerator`1 : CodeGenerator`1<T> {
    private static string xamlCompilerVersion;
    public static string XamlCompilerVersion { get; }
    public string WeakReferenceTypeName { get; }
    public static string get_XamlCompilerVersion();
    public string get_WeakReferenceTypeName();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MapIndexStepCodeGenerator : BindPathStepCodeGenerator`1<MapIndexStep> {
    public ICodeGenOutput PathExpression { get; }
    public ICodeGenOutput UpdateCallParam { get; }
    public virtual ICodeGenOutput get_PathExpression();
    public virtual ICodeGenOutput PathSetExpression(ICodeGenOutput value);
    public virtual ICodeGenOutput get_UpdateCallParam();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_0();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_1();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_2();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__4_3();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MemberGenInfo : object {
    private TypeGenInfo typeInfo;
    private InternalXamlUserMemberInfo memberInfo;
    public bool IsAttachable { get; }
    public bool IsDeprecated { get; }
    public bool IsDependencyProperty { get; }
    public bool IsValueType { get; }
    public bool IsEnum { get; }
    public string Name { get; }
    public bool HasPublicGetter { get; }
    public bool HasPublicSetter { get; }
    public InternalTypeEntry DeclaringType { get; }
    public InternalTypeEntry TargetType { get; }
    public InternalTypeEntry Type { get; }
    public bool HasGetAttachableMember { get; }
    public LanguageSpecificString GetAttachableMemberName { get; }
    public bool HasGetValueTypeMember { get; }
    public LanguageSpecificString GetValueTypeMemberName { get; }
    public bool HasGetReferenceTypeMember { get; }
    public LanguageSpecificString GetReferenceTypeMemberName { get; }
    public bool HasSetAttachableMember { get; }
    public LanguageSpecificString SetAttachableMemberName { get; }
    public bool HasSetValueTypeMember { get; }
    public LanguageSpecificString SetValueTypeMemberName { get; }
    public bool HasSetEnumMember { get; }
    public LanguageSpecificString SetEnumMemberName { get; }
    public bool HasSetReferenceTypeMember { get; }
    public LanguageSpecificString SetReferenceTypeMemberName { get; }
    public MemberGenInfo(TypeGenInfo typeInfo, InternalXamlUserMemberInfo memberInfo);
    public bool get_IsAttachable();
    public bool get_IsDeprecated();
    public bool get_IsDependencyProperty();
    public bool get_IsValueType();
    public bool get_IsEnum();
    public string get_Name();
    public bool get_HasPublicGetter();
    public bool get_HasPublicSetter();
    public InternalTypeEntry get_DeclaringType();
    public InternalTypeEntry get_TargetType();
    public InternalTypeEntry get_Type();
    public bool get_HasGetAttachableMember();
    public LanguageSpecificString get_GetAttachableMemberName();
    public bool get_HasGetValueTypeMember();
    public LanguageSpecificString get_GetValueTypeMemberName();
    public bool get_HasGetReferenceTypeMember();
    public LanguageSpecificString get_GetReferenceTypeMemberName();
    public bool get_HasSetAttachableMember();
    public LanguageSpecificString get_SetAttachableMemberName();
    public bool get_HasSetValueTypeMember();
    public LanguageSpecificString get_SetValueTypeMemberName();
    public bool get_HasSetEnumMember();
    public LanguageSpecificString get_SetEnumMemberName();
    public bool get_HasSetReferenceTypeMember();
    public LanguageSpecificString get_SetReferenceTypeMemberName();
    [CompilerGeneratedAttribute]
private string <get_GetAttachableMemberName>b__28_0();
    [CompilerGeneratedAttribute]
private string <get_GetAttachableMemberName>b__28_1();
    [CompilerGeneratedAttribute]
private string <get_GetAttachableMemberName>b__28_2();
    [CompilerGeneratedAttribute]
private string <get_GetValueTypeMemberName>b__32_0();
    [CompilerGeneratedAttribute]
private string <get_GetValueTypeMemberName>b__32_1();
    [CompilerGeneratedAttribute]
private string <get_GetValueTypeMemberName>b__32_2();
    [CompilerGeneratedAttribute]
private string <get_SetValueTypeMemberName>b__44_0();
    [CompilerGeneratedAttribute]
private string <get_SetValueTypeMemberName>b__44_1();
    [CompilerGeneratedAttribute]
private string <get_SetValueTypeMemberName>b__44_2();
    [CompilerGeneratedAttribute]
private string <get_SetEnumMemberName>b__48_0();
    [CompilerGeneratedAttribute]
private string <get_SetEnumMemberName>b__48_1();
    [CompilerGeneratedAttribute]
private string <get_SetEnumMemberName>b__48_2();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MethodStepCodeGenerator : BindPathStepCodeGenerator`1<MethodStep> {
    public ICodeGenOutput PathExpression { get; }
    public virtual ICodeGenOutput get_PathExpression();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppAppPass1 : CppCX_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppAppPass2 : CppCX_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
    private void Output_IncludeFiles_CPP();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppBindingInfoPass1 : CppCX_CodeGenerator`1<BindingInfoDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppBindingInfoPass2 : CppCX_CodeGenerator`1<BindingInfoDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppPagePass1 : CppCX_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
    private void Output_ForwardDeclarations();
    private void Output_Cpp_FieldDefinitions();
    private void Output_xProperties();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppPagePass2 : CppCX_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
    private void Output_InitializeComponent();
    private void Output_InitializeXProperties();
    private void Output_ConnectMethod();
    private void Output_UnloadObjectMethod();
    private void Output_ConnectionId_Case(ConnectionIdElement element);
    private void Output_GetBindingConnectorCaseBindingPropertiesSet(ConnectionIdElement element, bool isPageRoot);
    private void Output_GetBindingConnectorCase(ConnectionIdElement element, bool isPageRoot);
    private void Output_GetBindingConnectorMethod();
    private void Output_PushDeprecated(bool isDeprecated);
    private void Output_PopDeprecated(bool isDeprecated);
    private void Output_BindingsClasses();
    private string GetCacheArgumentStatement(BindPathStep step, string prefix, BindPathStep child);
    private string GetCacheResolveStatement(BindPathStep step, string prefix, BindPathStep child);
    private void Output_Listener_Tracking_Fields(BindUniverse bindUniverse);
    private void Output_Connect_TwoWayBinding(BindAssignment ba);
    private void Output_NullCheckedAssignment(BindPathStep step, LanguageSpecificString value);
    private void Output_UpdateChildListeners_Call(BindPathStep step, string parameter);
    private void Output_Binding_Phased_SetValue(int phase, bool isTracking, BindPathStep bindStep, bool isFunctionResult);
    private void Output_Binding_Phased_Fallback_SetValue(int phase, bool isTracking, BindPathStep bindStep);
    private void Output_Binding_SetValue(BindAssignment bindAssignment, bool isFunctionResult);
    private void Output_Binding_SetValue_Non_Function_Call(BindAssignment bindAssignment, string value, bool includeDeferredSet);
    private void Output_Update_DataChanged_Step(BindPathStep step);
    private void Output_Update_Steps(bool checkForNull, IEnumerable`1<BindPathStep> steps, bool checkPhaseCondition, string phaseParam);
    private void Output_Custom_Update_Call(BindPathStep step, string firstArgument, string phaseParam);
    private void Output_UpdateCall(BindPathStep step, string phaseParam);
    private string GetMemberAccessOperator(BindPathStep bindStep);
    private string GetUpdateParams(BindPathStep bindStep);
    private void Output_CompleteUpdate(BindUniverse bindUniverse);
    private void Output_FunctionBindings(BindUniverse bindUniverse);
    private void Output_TryGetValueFunctions(BindUniverse bindUniverse);
    private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent);
    private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent);
    private void Output_ApiInformationDeclarations();
    private void Output_ApiInformationInit();
    private void Output_BindingSetValueFunction(BindAssignment ba);
    private void Output_BindingSetters(BindUniverse bu);
    private void Output_BindingTrackingClass(BindUniverse bu);
    [CompilerGeneratedAttribute]
private bool <TransformText>b__0_0(TypeGenInfo t);
    [CompilerGeneratedAttribute]
private void <Output_BindingsClasses>g__Output_UpdateErrorsCall|11_1(PropertyStep step);
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass1 : CppCX_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass1b : CppCX_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass1Impl : CppCX_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass2 : CppCX_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
    private void Output_GetTypeInfo();
}
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.NativeCodeGenerator`1 : CodeGenerator`1<T> {
    public static string Colonize(string typeName);
    public static string Globalize(string fullType);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.PageDefinition : Definition {
    private List`1<ConnectionIdElement> _allConnectionIdElements;
    private List`1<ForwardDeclaringNamespace> _forwardDeclarations;
    private HashSet`1<string> _neededLocalXamlHeaderFiles;
    private List`1<string> _neededCppWinRTProjectionHeaderFiles;
    private bool _neededXamlHeaderFilesCalculated;
    private string _checksumAlgorithmGuid;
    private IEnumerable`1<ApiInformation> _allApiInformations;
    private List`1<FileNameAndChecksumPair> _XamlFileFullPathAndCheckSums;
    private List`1<xProperty> _xProperties;
    [CompilerGeneratedAttribute]
private XamlClassCodeInfo <CodeInfo>k__BackingField;
    public XamlClassCodeInfo CodeInfo { get; public set; }
    public string ChecksumAlgorithmGuid { get; }
    public IEnumerable`1<xProperty> XProperties { get; }
    public IEnumerable`1<FileNameAndChecksumPair> XamlFileFullPathAndCheckSums { get; }
    public IEnumerable`1<string> NeededLocalXamlHeaderFiles { get; }
    public IEnumerable`1<string> NeededCppWinRTProjectionHeaderFiles { get; }
    public IEnumerable`1<ForwardDeclaringNamespace> ForwardDeclarations { get; }
    public IEnumerable`1<ConnectionIdElement> AllConnectionIdElements { get; }
    public IEnumerable`1<ConnectionIdElement> ConnectableElements { get; }
    public IEnumerable`1<ConnectionIdElement> UnloadableFields { get; }
    public IEnumerable`1<ConnectionIdElement> DeferrableElements { get; }
    public IEnumerable`1<ApiInformation> ApiInformationDeclarations { get; }
    public PageDefinition(XamlProjectInfo projectInfo, XamlSchemaCodeInfo schemaInfo);
    [CompilerGeneratedAttribute]
public XamlClassCodeInfo get_CodeInfo();
    [CompilerGeneratedAttribute]
public void set_CodeInfo(XamlClassCodeInfo value);
    public string get_ChecksumAlgorithmGuid();
    public IEnumerable`1<xProperty> get_XProperties();
    public IEnumerable`1<FileNameAndChecksumPair> get_XamlFileFullPathAndCheckSums();
    public IEnumerable`1<string> get_NeededLocalXamlHeaderFiles();
    public IEnumerable`1<string> get_NeededCppWinRTProjectionHeaderFiles();
    public IEnumerable`1<ForwardDeclaringNamespace> get_ForwardDeclarations();
    public IEnumerable`1<ConnectionIdElement> get_AllConnectionIdElements();
    public IEnumerable`1<ConnectionIdElement> get_ConnectableElements();
    public IEnumerable`1<ConnectionIdElement> get_UnloadableFields();
    public IEnumerable`1<ConnectionIdElement> get_DeferrableElements();
    public IEnumerable`1<ApiInformation> get_ApiInformationDeclarations();
    public string GetLoadComponentUri(string priIndexName, string xamlRelativePath);
    private void EnsureNeededXamlHeaderFilesCalculated();
    private List`1<FileNameAndChecksumPair> LookupXamlFileFullPathAndCheckSums();
    private List`1<ForwardDeclaringNamespace> LookupForwardDeclarations();
    [CompilerGeneratedAttribute]
internal static void <EnsureNeededXamlHeaderFilesCalculated>g__addCppWinRTHeaderForTypeIfNecessary|37_0(Type type, <>c__DisplayClass37_0& );
}
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.ParameterCodeGenerator`1 : CodeGeneratorBase`1<T> {
    [CompilerGeneratedAttribute]
private ICodeGenOutput <PathExpression>k__BackingField;
    public ICodeGenOutput PathExpression { get; }
    [CompilerGeneratedAttribute]
public virtual ICodeGenOutput get_PathExpression();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.PropertyStepCodeGenerator`1 : BindPathStepCodeGenerator`1<T> {
    public ICodeGenOutput PathExpression { get; }
    public ICodeGenOutput UpdateCallParam { get; }
    public virtual ICodeGenOutput get_PathExpression();
    public virtual ICodeGenOutput get_UpdateCallParam();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.RootNamedElementStepCodeGenerator : BindPathStepCodeGenerator`1<RootNamedElementStep> {
    public ICodeGenOutput PathExpression { get; }
    public ICodeGenOutput UpdateCallParam { get; }
    public virtual ICodeGenOutput get_PathExpression();
    public virtual ICodeGenOutput get_UpdateCallParam();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__3_0();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__3_1();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__3_2();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__3_3();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__3_4();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__3_5();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__3_6();
    [CompilerGeneratedAttribute]
private string <get_UpdateCallParam>b__3_7();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.RootStepCodeGenerator : BindPathStepCodeGenerator`1<RootStep> {
    public ICodeGenOutput PathExpression { get; }
    public virtual ICodeGenOutput get_PathExpression();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.StaticRootStepCodeGenerator : BindPathStepCodeGenerator`1<StaticRootStep> {
    public ICodeGenOutput MemberAccessOperator { get; }
    public ICodeGenOutput PathExpression { get; }
    public virtual ICodeGenOutput get_MemberAccessOperator();
    public virtual ICodeGenOutput get_PathExpression();
}
[ExtensionAttribute]
internal static class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.StringExtensions : object {
    [ExtensionAttribute]
internal static string AsNamespaceDeclarationBegin(string instance);
    [ExtensionAttribute]
internal static string AsNamespaceDeclarationEnd(string instance);
    [ExtensionAttribute]
internal static string Quotenate(string value);
    [ExtensionAttribute]
internal static string ToTitleCase(string value);
    [ExtensionAttribute]
internal static string ToLocalCppWinRTTypeName(string fullName);
    [ExtensionAttribute]
internal static string ToCommaSeparatedValues(IEnumerable`1<object> list);
}
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base : object {
    [CompilerGeneratedAttribute]
private XamlProjectInfo <ProjectInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlSchemaCodeInfo <SchemaInfo>k__BackingField;
    private static String[] Indents;
    private StringBuilder generationEnvironmentField;
    private CompilerErrorCollection errorsField;
    private List`1<int> indentLengthsField;
    private string currentIndentField;
    private bool endsWithNewline;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public XamlProjectInfo ProjectInfo { get; protected set; }
    public XamlSchemaCodeInfo SchemaInfo { get; protected set; }
    public Object[] Arguments { get; public set; }
    protected StringBuilder GenerationEnvironment { get; protected set; }
    public CompilerErrorCollection Errors { get; }
    private List`1<int> indentLengths { get; }
    public T4Base ToStringHelper { get; }
    private static T4Base();
    [CompilerGeneratedAttribute]
public XamlProjectInfo get_ProjectInfo();
    [CompilerGeneratedAttribute]
protected void set_ProjectInfo(XamlProjectInfo value);
    [CompilerGeneratedAttribute]
public XamlSchemaCodeInfo get_SchemaInfo();
    [CompilerGeneratedAttribute]
protected void set_SchemaInfo(XamlSchemaCodeInfo value);
    public virtual string TransformText();
    protected string IncludeTemplate();
    protected string IncludeTemplate(object model, Object[] args);
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(Object[] value);
    public abstract virtual void SetModel(XamlProjectInfo projectInfo, XamlSchemaCodeInfo schemaInfo, object model);
    protected Indent GetCurrentIndent();
    protected StringBuilder get_GenerationEnvironment();
    protected void set_GenerationEnvironment(StringBuilder value);
    public CompilerErrorCollection get_Errors();
    private List`1<int> get_indentLengths();
    public void Write(string textToAppend);
    public void WriteLine(string textToAppend);
    public void Write(string format, Object[] args);
    public void WriteLine(string format, Object[] args);
    public void Error(string message);
    public void Warning(string message);
    public void PushIndent(Indent tabs);
    public string PopIndent();
    public void ClearIndent();
    public abstract virtual string ToStringWithCulture(ICodeGenOutput codegenOutput);
    public virtual string ToStringWithCulture(bool value);
    public abstract virtual string ToStringWithCulture(XamlType type);
    public string ToStringWithCulture(string objectToConvert);
    public string ToStringWithCulture(int objectToConvert);
    public T4Base get_ToStringHelper();
}
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base`1 : T4Base {
    [CompilerGeneratedAttribute]
private TModel <Model>k__BackingField;
    public TModel Model { get; public set; }
    [CompilerGeneratedAttribute]
public TModel get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(TModel value);
    public virtual void SetModel(XamlProjectInfo projectInfo, XamlSchemaCodeInfo schemaInfo, object model);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.TypeForCodeGen : object {
    private DirectUIXamlType _xamlType;
    private string _standardName;
    private string _systemName;
    private string _memberFriendlyName;
    private LanguageSpecificString _languageSpecificString;
    public Type UnderlyingType { get; }
    public string StandardName { get; }
    public string SystemName { get; }
    public LanguageSpecificString FullName { get; }
    public string MemberFriendlyName { get; }
    public TypeForCodeGen(XamlType xamlType);
    public Type get_UnderlyingType();
    public string get_StandardName();
    public string get_SystemName();
    public LanguageSpecificString get_FullName();
    public string get_MemberFriendlyName();
    [CompilerGeneratedAttribute]
private string <get_FullName>b__13_0();
    [CompilerGeneratedAttribute]
private string <get_FullName>b__13_1();
    [CompilerGeneratedAttribute]
private string <get_FullName>b__13_2();
    [CompilerGeneratedAttribute]
private string <get_FullName>b__13_3();
}
[ExtensionAttribute]
public static class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.TypeForCodeGenExtensionMethods : object {
    private static Dictionary`2<XamlType, TypeForCodeGen> cache;
    private static TypeForCodeGenExtensionMethods();
    [ExtensionAttribute]
private static TypeForCodeGen GetTypeForCodeGen(XamlType type);
    [ExtensionAttribute]
public static string CSharpName(XamlType type);
    [ExtensionAttribute]
public static string CppCXName(XamlType type, bool IncludeHatIfApplicable);
    [ExtensionAttribute]
public static string CppWinRTName(XamlType type);
    [ExtensionAttribute]
public static string MemberFriendlyName(XamlType type);
    [ExtensionAttribute]
public static string VBName(XamlType type);
    [ExtensionAttribute]
public static IEnumerable`1<Parameter> TryGetInvokeParameters(Type multicastDelegate);
    [ExtensionAttribute]
public static IEnumerable`1<Parameter> GetInvokeParameters(Type multicastDelegate, bool throwOnError);
    [ExtensionAttribute]
public static string ForCall(IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static LanguageSpecificString Declaration(IEnumerable`1<Parameter> parameters);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.TypeGenInfo : object {
    [CompilerGeneratedAttribute]
private InternalTypeEntry <TypeEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncrementalTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private InternalXamlUserTypeInfo <UserTypeInfo>k__BackingField;
    public InternalTypeEntry TypeEntry { get; protected set; }
    public bool IncrementalTypeInfo { get; }
    protected InternalXamlUserTypeInfo UserTypeInfo { get; public set; }
    public bool IsSystemType { get; }
    public string StandardName { get; }
    public string BaseTypeStandardName { get; }
    public string BoxedTypeStandardName { get; }
    public bool IsLocalType { get; }
    public bool IsBindable { get; }
    public bool IsMarkupExtension { get; }
    public bool HasCreateFromStringMethod { get; }
    public CreateFromStringMethod CreateFromStringMethod { get; }
    public bool IsReturnTypeStub { get; }
    public bool IsConstructible { get; }
    public bool IsCollection { get; }
    public bool IsDictionary { get; }
    public bool IsDeprecated { get; }
    public bool HasEnumValues { get; }
    public bool HasMembers { get; }
    public LanguageSpecificString FullName { get; }
    public string ContentPropertyName { get; }
    public InternalTypeEntry KeyType { get; }
    public InternalTypeEntry ItemType { get; }
    public IEnumerable`1<MemberGenInfo> Members { get; }
    public List`1<string> EnumValues { get; }
    public bool HasActivator { get; }
    public LanguageSpecificString ActivatorName { get; }
    public LanguageSpecificString CollectionAddName { get; }
    public LanguageSpecificString DictionaryAddName { get; }
    public LanguageSpecificString FromStringConverterName { get; }
    public TypeGenInfo(InternalTypeEntry typeEntry, bool incrementalTypeInfo);
    [CompilerGeneratedAttribute]
public InternalTypeEntry get_TypeEntry();
    [CompilerGeneratedAttribute]
protected void set_TypeEntry(InternalTypeEntry value);
    [CompilerGeneratedAttribute]
public bool get_IncrementalTypeInfo();
    [CompilerGeneratedAttribute]
protected InternalXamlUserTypeInfo get_UserTypeInfo();
    [CompilerGeneratedAttribute]
public void set_UserTypeInfo(InternalXamlUserTypeInfo value);
    public bool get_IsSystemType();
    public string get_StandardName();
    public string get_BaseTypeStandardName();
    public string get_BoxedTypeStandardName();
    public bool get_IsLocalType();
    public bool get_IsBindable();
    public bool get_IsMarkupExtension();
    public bool get_HasCreateFromStringMethod();
    public CreateFromStringMethod get_CreateFromStringMethod();
    public bool get_IsReturnTypeStub();
    public bool get_IsConstructible();
    public bool get_IsCollection();
    public bool get_IsDictionary();
    public bool get_IsDeprecated();
    public bool get_HasEnumValues();
    public bool get_HasMembers();
    public LanguageSpecificString get_FullName();
    public string get_ContentPropertyName();
    public InternalTypeEntry get_KeyType();
    public InternalTypeEntry get_ItemType();
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.CodeGen.TypeGenInfo/<get_Members>d__53")]
public IEnumerable`1<MemberGenInfo> get_Members();
    public List`1<string> get_EnumValues();
    public bool get_HasActivator();
    public LanguageSpecificString get_ActivatorName();
    public LanguageSpecificString get_CollectionAddName();
    public LanguageSpecificString get_DictionaryAddName();
    public LanguageSpecificString get_FromStringConverterName();
    [CompilerGeneratedAttribute]
private string <get_ActivatorName>b__59_0();
    [CompilerGeneratedAttribute]
private string <get_ActivatorName>b__59_1();
    [CompilerGeneratedAttribute]
private string <get_ActivatorName>b__59_2();
    [CompilerGeneratedAttribute]
private string <get_CollectionAddName>b__61_0();
    [CompilerGeneratedAttribute]
private string <get_CollectionAddName>b__61_1();
    [CompilerGeneratedAttribute]
private string <get_CollectionAddName>b__61_2();
    [CompilerGeneratedAttribute]
private string <get_DictionaryAddName>b__63_0();
    [CompilerGeneratedAttribute]
private string <get_DictionaryAddName>b__63_1();
    [CompilerGeneratedAttribute]
private string <get_DictionaryAddName>b__63_2();
    [CompilerGeneratedAttribute]
private string <get_FromStringConverterName>b__65_0();
    [CompilerGeneratedAttribute]
private string <get_FromStringConverterName>b__65_1();
    [CompilerGeneratedAttribute]
private string <get_FromStringConverterName>b__65_2();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.TypeInfoDefinition : Definition {
    private List`1<MemberGenInfo> _memberInfos;
    private Dictionary`2<string, int> _typeInfoIndexes;
    private UInt32[] _typeInfoLookup;
    private List`1<EnumGenInfo> _enumValues;
    private List`1<string> _neededCppWinRTProjectionHeaderFiles;
    [CompilerGeneratedAttribute]
private ClassName <AppXamlInfo>k__BackingField;
    internal ClassName AppXamlInfo { get; internal set; }
    public bool GenerateTypeInfo { get; }
    public IEnumerable`1<string> AllLocalXamlHeaderFiles { get; }
    public IEnumerable`1<string> AllLocalHppGeneratedFiles { get; }
    public string AppMetadataProviderNamespace { get; }
    public Dictionary`2<string, int> TypeInfoIndexes { get; }
    public IEnumerable`1<UInt32> TypeInfoLookup { get; }
    public IEnumerable`1<MemberGenInfo> MemberInfos { get; }
    public IEnumerable`1<EnumGenInfo> EnumValues { get; }
    public IEnumerable`1<string> AttachableMemberGetterUniqueNames { get; }
    public IEnumerable`1<string> ValueTypeMemberGetterUniqueNames { get; }
    public IEnumerable`1<string> StringGetterUniqueNames { get; }
    public IEnumerable`1<string> ReferenceTypeMemberGetterUniqueNamesNoStrings { get; }
    public IEnumerable`1<string> ReferenceTypeMemberGetterUniqueNames { get; }
    public IEnumerable`1<string> AttachableMemberSetterUniqueNames { get; }
    public IEnumerable`1<string> EnumTypeMemberSetterUniqueNames { get; }
    public IEnumerable`1<string> ValueTypeMemberSetterUniqueNames { get; }
    public IEnumerable`1<string> StringSetterUniqueNames { get; }
    public IEnumerable`1<string> ReferenceTypeMemberSetterUniqueNames { get; }
    public IEnumerable`1<string> ReferenceTypeMemberSetterUniqueNamesNoStrings { get; }
    public IEnumerable`1<string> NeededCppWinRTProjectionHeaderFiles { get; }
    public TypeInfoDefinition(XamlProjectInfo projectInfo, XamlSchemaCodeInfo schemaInfo);
    [CompilerGeneratedAttribute]
internal ClassName get_AppXamlInfo();
    [CompilerGeneratedAttribute]
internal void set_AppXamlInfo(ClassName value);
    public bool get_GenerateTypeInfo();
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.CodeGen.TypeInfoDefinition/<get_AllLocalXamlHeaderFiles>d__13")]
public IEnumerable`1<string> get_AllLocalXamlHeaderFiles();
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.CodeGen.TypeInfoDefinition/<get_AllLocalHppGeneratedFiles>d__15")]
public IEnumerable`1<string> get_AllLocalHppGeneratedFiles();
    public string get_AppMetadataProviderNamespace();
    public Dictionary`2<string, int> get_TypeInfoIndexes();
    public IEnumerable`1<UInt32> get_TypeInfoLookup();
    public IEnumerable`1<MemberGenInfo> get_MemberInfos();
    public void TrackTypeMembers(TypeGenInfo entry, Int32& startIndex);
    public IEnumerable`1<EnumGenInfo> get_EnumValues();
    public void TrackTypeEnumValues(TypeGenInfo entry, Int32& startIndex);
    public IEnumerable`1<string> get_AttachableMemberGetterUniqueNames();
    public IEnumerable`1<string> get_ValueTypeMemberGetterUniqueNames();
    public IEnumerable`1<string> get_StringGetterUniqueNames();
    public IEnumerable`1<string> get_ReferenceTypeMemberGetterUniqueNamesNoStrings();
    public IEnumerable`1<string> get_ReferenceTypeMemberGetterUniqueNames();
    public IEnumerable`1<string> get_AttachableMemberSetterUniqueNames();
    public IEnumerable`1<string> get_EnumTypeMemberSetterUniqueNames();
    public IEnumerable`1<string> get_ValueTypeMemberSetterUniqueNames();
    public IEnumerable`1<string> get_StringSetterUniqueNames();
    public IEnumerable`1<string> get_ReferenceTypeMemberSetterUniqueNames();
    public IEnumerable`1<string> get_ReferenceTypeMemberSetterUniqueNamesNoStrings();
    public IEnumerable`1<string> get_NeededCppWinRTProjectionHeaderFiles();
    private List`1<string> LookupNeededCppWinRTProjectionHeaderFiles();
    public string GetterName(int i);
    public string SetterName(int i);
    public string ActivatorName(InternalXamlUserTypeInfo entry);
    public string StaticInitializerName(InternalXamlUserTypeInfo entry);
    public string VectorAddName(InternalXamlUserTypeInfo entry);
    public string MapAddName(InternalXamlUserTypeInfo entry);
    [CompilerGeneratedAttribute]
internal static void <LookupNeededCppWinRTProjectionHeaderFiles>g__addCppWinRTHeaderForTypeIfNecessary|52_0(Type type, <>c__DisplayClass52_0& );
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VB_CodeGenerator`1 : ManagedCodeGenerator`1<T> {
    public string GeneratedCodeAttribute { get; }
    public string DebuggerNonUserCodeAttribute { get; }
    public string NotCLSCompliantAttribute { get; }
    public virtual string ToStringWithCulture(ICodeGenOutput codegenOutput);
    public virtual string ToStringWithCulture(XamlType type);
    public virtual string ToStringWithCulture(bool value);
    public string Globalize(string fullType);
    public string PropertyChangedEventArgName(BindPathStep step);
    public string INPCInterfaceName(BindPathStep step);
    public string DataErrorsEventArgName(BindPathStep step);
    public string INDEIInterfaceName(BindPathStep step);
    public string NotifyCollectionChangedEventArgName(BindPathStep step);
    public string INCCInterfaceName(BindPathStep step);
    public string get_GeneratedCodeAttribute();
    public string get_DebuggerNonUserCodeAttribute();
    public string get_NotCLSCompliantAttribute();
    protected virtual string GetPhaseCondition(BindPathStep bindStep);
    public virtual string GetDirectPhaseCondition(int phase, bool isTracking);
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicAppPass1 : VB_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicPagePass1 : VB_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
    private void Output_InitializeComponent();
    private void Output_FieldDefinitions();
    private void Output_BindingsHeader();
    private void Output_xProperties();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicPagePass2 : VB_CodeGenerator`1<PageDefinition> {
    public virtual string TransformText();
    private void Output_InitializeXProperties();
    private void Output_ConnectMethod();
    private void Output_UnloadObjectMethod();
    private void Output_GetBindingConnectorCaseBindingPropertiesSet(ConnectionIdElement element, bool isPageRoot);
    private void Output_GetBindingConnectorCase(ConnectionIdElement element, bool isPageRoot);
    private void Output_GetBindingConnectorMethod();
    private void Output_PushDeprecated(bool isDeprecated);
    private void Output_PopDeprecated(bool isDeprecated);
    private void Output_BindingsClasses();
    private void Output_UpdateChildListeners(BindPathStep step, BindUniverse bindUniverse);
    private void Output_RegisterTwoWayListeners(ConnectionIdElement element);
    private void Output_UpdateTwoWay(BindAssignment ba);
    private void Output_NullCheckedAssignment(BindPathStep step, LanguageSpecificString value);
    private void Output_UpdateErrors(BindUniverse bindUniverse);
    private void Output_UpdateErrorsCall(PropertyStep step);
    private void Output_Binding_SetValue_Function(BindAssignment ba);
    private void Output_Binding_Phased_SetValue(int phase, bool isTracking, BindPathStep bindStep, bool isFunctionResult);
    private void Output_Binding_Phased_Fallback_SetValue(int phase, bool isTracking, BindPathStep bindStep);
    private void Output_Binding_SetValue(BindAssignment bindAssignment, bool isFunctionResult);
    private void Output_Binding_SetValue_Non_Function_Call(BindAssignment bindAssignment, string value, bool includeDeferredSet);
    private void Output_Update_DataChanged_Step(string context, BindPathStep step);
    private void Output_Update_Steps(bool checkForNull, string context, IEnumerable`1<BindPathStep> steps, bool checkPhaseCondition, string phaseParam);
    private string GetUpdateParams(BindPathStep bindStep);
    private void Output_Custom_Update_Call(string context, BindPathStep step, string firstArgument, string phaseParam);
    private void Output_UpdateCall(string context, BindPathStep step, string phaseParam);
    private void Output_CompleteUpdate(BindUniverse bindUniverse);
    private void Output_FunctionBindings(BindUniverse bindUniverse);
    private void Output_TryGetValueFunctions(BindUniverse bindUniverse);
    private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent);
    private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent);
    private void Output_ApiInformationDeclarations();
}
[GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicTypeInfoPass2 : VB_CodeGenerator`1<TypeInfoDefinition> {
    public virtual string TransformText();
    private void Output_CheckOtherMetadataProviders();
    private void Output_TypeTables();
    private void Output_CreateXamlType();
    private void Output_Activators();
    private void Output_ListAndMapMethods();
    private void Output_CreateXamlMember();
    private void Output_SettersAndGetters();
    private void Output_AppMetadataProvider();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGen.XamlCodeGenerator : object {
    private Language _language;
    private bool _isPass1;
    private XamlProjectInfo _projectInfo;
    private XamlSchemaCodeInfo _schemaInfo;
    public XamlCodeGenerator(Language language, bool isPass1, XamlProjectInfo projectInfo, XamlSchemaCodeInfo schemaInfo);
    public List`1<FileNameAndContentPair> GenerateCodeBehind(XamlClassCodeInfo codeInfo, IEnumerable`1& xamlFilesChecksumPairs);
    public List`1<FileNameAndContentPair> GenerateTypeInfo(ClassName appXamlInfo);
    public List`1<FileNameAndContentPair> GenerateBindingInfo(Dictionary`2<string, XamlType> observableVectorTypes, Dictionary`2<string, XamlType> observableMapTypes, Dictionary`2<string, XamlMember> bindingSetters, bool eventBindingUsed);
    private string GenerateTypeInfoCode(CodeGeneratorDelegate codeGenDelegate, ClassName appXamlInfo);
}
[FlagsAttribute]
internal enum Microsoft.UI.Xaml.Markup.Compiler.CodeGenCtrlFlags : Enum {
    public int value__;
    public static CodeGenCtrlFlags Nothing;
    public static CodeGenCtrlFlags NoPageCodeGen;
    public static CodeGenCtrlFlags NoTypeInfoCodeGen;
    public static CodeGenCtrlFlags IncrementalTypeInfoCodeGen;
    public static CodeGenCtrlFlags DoNotGenerateOtherProviders;
    public static CodeGenCtrlFlags FullXamlMetadataProvider;
    public static CodeGenCtrlFlags DoNotGenerateCppWinRTStaticAsserts;
}
public class Microsoft.UI.Xaml.Markup.Compiler.CodeGenDelegate : MulticastDelegate {
    public CodeGenDelegate(object object, IntPtr method);
    public virtual string Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeGeneratorDelegate : MulticastDelegate {
    public CodeGeneratorDelegate(object object, IntPtr method);
    public virtual T4Base Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T4Base EndInvoke(IAsyncResult result);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CodeInfoAndTaskItemPair : object {
    [CompilerGeneratedAttribute]
private XamlClassCodeInfo <ClassCodeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskItemFilename <TaskItem>k__BackingField;
    public XamlClassCodeInfo ClassCodeInfo { get; private set; }
    public TaskItemFilename TaskItem { get; private set; }
    public CodeInfoAndTaskItemPair(XamlClassCodeInfo classCodeInfo, TaskItemFilename taskItem);
    [CompilerGeneratedAttribute]
public XamlClassCodeInfo get_ClassCodeInfo();
    [CompilerGeneratedAttribute]
private void set_ClassCodeInfo(XamlClassCodeInfo value);
    [CompilerGeneratedAttribute]
public TaskItemFilename get_TaskItem();
    [CompilerGeneratedAttribute]
private void set_TaskItem(TaskItemFilename value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CompiledBindingException : Exception {
    [CompilerGeneratedAttribute]
private int <StartCharacterPosition>k__BackingField;
    public int StartCharacterPosition { get; }
    public CompiledBindingException(string exceptionMessage, int startCharacterPosition);
    [CompilerGeneratedAttribute]
public int get_StartCharacterPosition();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CompiledBindingParseException : CompiledBindingException {
    [CompilerGeneratedAttribute]
private string <ExpressionBeingParsed>k__BackingField;
    public string ExpressionBeingParsed { get; }
    public CompiledBindingParseException(string expressionBeingParsed, string exceptionMessage, int startCharacterPosition);
    [CompilerGeneratedAttribute]
public string get_ExpressionBeingParsed();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CompileXamlInternal : object {
    private static Char[] _separator;
    private List`1<IXbfFileNameInfo> _newlyGeneratedXamlFiles;
    private List`1<Assembly> _loadedAssemblies;
    private List`1<Assembly> _loadedSystemAssemblies;
    private List`1<Assembly> _loadedNonSystemAssemblies;
    private List`1<string> _systemExtraReferenceItems;
    private SourceFileManager _SourceFileManager;
    private string _projectFolderFullpath;
    private List`1<string> _includeFolderList;
    private Assembly _localAssembly;
    private string _localAssemblyName;
    private DirectUISchemaContext _schemaContext;
    private IXbfMetadataProvider _xamlMetadataProvider;
    private TypeInfoCollector _typeInfoCollector;
    private XamlProjectInfo _projectInfo;
    private static XamlTypeUniverse s_typeUniverse;
    private static TypeResolver s_typeResolver;
    private Dictionary`2<string, XamlClassCodeInfo> _classCodeInfos;
    private List`1<string> _suppressedWarnings;
    private string _xamlPlatformString;
    private XamlCodeGenerator _codeGenerator;
    internal IList`1<string> _generatedCodeFiles;
    internal IList`1<string> _generatedXamlFiles;
    internal IList`1<string> _generatedXbfFiles;
    internal IList`1<string> _generatedXamlPagesFiles;
    [CompilerGeneratedAttribute]
private bool <DisableXbfGeneration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Fingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseVCMetaManaged>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FingerprintIgnorePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VCInstallDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VCInstallPath32>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VCInstallPath64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WindowsSdkPath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SuppressWarnings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootsLog>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformMinVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Language <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageSourceExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAssemblyItem> <ReferenceAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ReferenceAssemblyPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CIncludeDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IFileItem> <ClIncludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IFileItem> <XamlApplications>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IFileItem> <XamlPages>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IFileItem> <SdkXamlPages>k__BackingField;
    [CompilerGeneratedAttribute]
private IAssemblyItem <LocalAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPass1>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDesignTimeBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PriIndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGenCtrlFlags <CodeGenerationControlFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private FeatureCtrlFlags <FeatureControlFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ILog <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <XbfGenerationFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlResourceMapName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlComponentResourceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GenXbfPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrecompiledHeaderFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableXBindDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableTypeInfoReflection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDefaultValidationContextGeneration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableWin32Codegen>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsingCSWinRT>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSpecifiedTargetPlatformMinVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SavedStateManager <SaveState>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildTaskFileService <TaskFileService>k__BackingField;
    public bool DisableXbfGeneration { get; public set; }
    public bool Fingerprint { get; public set; }
    public bool UseVCMetaManaged { get; public set; }
    public String[] FingerprintIgnorePaths { get; public set; }
    public string VCInstallDir { get; public set; }
    public string VCInstallPath32 { get; public set; }
    public string VCInstallPath64 { get; public set; }
    public string WindowsSdkPath { get; public set; }
    public String[] SuppressWarnings { get; public set; }
    public string ProjectPath { get; public set; }
    public string RootsLog { get; public set; }
    public string TargetPlatformMinVersion { get; public set; }
    public Language Language { get; public set; }
    public string LanguageSourceExtension { get; public set; }
    public string OutputPath { get; public set; }
    public IList`1<IAssemblyItem> ReferenceAssemblies { get; public set; }
    public String[] ReferenceAssemblyPaths { get; public set; }
    public String[] CIncludeDirectories { get; public set; }
    public IList`1<IFileItem> ClIncludeFiles { get; public set; }
    public IList`1<IFileItem> XamlApplications { get; public set; }
    public IList`1<IFileItem> XamlPages { get; public set; }
    public IList`1<IFileItem> SdkXamlPages { get; public set; }
    public IAssemblyItem LocalAssembly { get; public set; }
    public string ProjectName { get; public set; }
    public bool IsPass1 { get; public set; }
    public bool IsDesignTimeBuild { get; public set; }
    public string RootNamespace { get; public set; }
    public string OutputType { get; public set; }
    public string PriIndexName { get; public set; }
    public CodeGenCtrlFlags CodeGenerationControlFlags { get; public set; }
    public FeatureCtrlFlags FeatureControlFlags { get; public set; }
    public ILog Log { get; public set; }
    public UInt32 XbfGenerationFlags { get; public set; }
    public string XamlResourceMapName { get; public set; }
    public string XamlComponentResourceLocation { get; public set; }
    public string GenXbfPath { get; public set; }
    public string PrecompiledHeaderFile { get; public set; }
    public string XamlPlatformString { get; public set; }
    public Platform XamlPlatform { get; }
    public bool EnableXBindDiagnostics { get; private set; }
    public bool EnableTypeInfoReflection { get; private set; }
    public bool EnableDefaultValidationContextGeneration { get; private set; }
    public bool EnableWin32Codegen { get; private set; }
    public bool UsingCSWinRT { get; private set; }
    public bool IgnoreSpecifiedTargetPlatformMinVersion { get; public set; }
    public IList`1<string> GeneratedCodeFiles { get; }
    public IList`1<string> GeneratedXamlFiles { get; }
    public IList`1<string> GeneratedXbfFiles { get; }
    public IList`1<string> GeneratedXamlPagesFiles { get; }
    internal SavedStateManager SaveState { get; internal set; }
    internal string ProjectFolderFullpath { get; }
    internal List`1<string> IncludeFolderList { get; }
    internal string GeneratedExtension { get; }
    internal string OutputFolderFullpath { get; }
    private SourceFileManager SourceFileManager { get; }
    private bool IsOutputTypeLibrary { get; }
    private bool IsOutputTypeWinMd { get; }
    internal BuildTaskFileService TaskFileService { get; internal set; }
    private static CompileXamlInternal();
    [CompilerGeneratedAttribute]
public bool get_DisableXbfGeneration();
    [CompilerGeneratedAttribute]
public void set_DisableXbfGeneration(bool value);
    [CompilerGeneratedAttribute]
public bool get_Fingerprint();
    [CompilerGeneratedAttribute]
public void set_Fingerprint(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseVCMetaManaged();
    [CompilerGeneratedAttribute]
public void set_UseVCMetaManaged(bool value);
    [CompilerGeneratedAttribute]
public String[] get_FingerprintIgnorePaths();
    [CompilerGeneratedAttribute]
public void set_FingerprintIgnorePaths(String[] value);
    [CompilerGeneratedAttribute]
public string get_VCInstallDir();
    [CompilerGeneratedAttribute]
public void set_VCInstallDir(string value);
    [CompilerGeneratedAttribute]
public string get_VCInstallPath32();
    [CompilerGeneratedAttribute]
public void set_VCInstallPath32(string value);
    [CompilerGeneratedAttribute]
public string get_VCInstallPath64();
    [CompilerGeneratedAttribute]
public void set_VCInstallPath64(string value);
    [CompilerGeneratedAttribute]
public string get_WindowsSdkPath();
    [CompilerGeneratedAttribute]
public void set_WindowsSdkPath(string value);
    [CompilerGeneratedAttribute]
public String[] get_SuppressWarnings();
    [CompilerGeneratedAttribute]
public void set_SuppressWarnings(String[] value);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public string get_RootsLog();
    [CompilerGeneratedAttribute]
public void set_RootsLog(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformMinVersion();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformMinVersion(string value);
    [CompilerGeneratedAttribute]
public Language get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(Language value);
    [CompilerGeneratedAttribute]
public string get_LanguageSourceExtension();
    [CompilerGeneratedAttribute]
public void set_LanguageSourceExtension(string value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public IList`1<IAssemblyItem> get_ReferenceAssemblies();
    [CompilerGeneratedAttribute]
public void set_ReferenceAssemblies(IList`1<IAssemblyItem> value);
    [CompilerGeneratedAttribute]
public String[] get_ReferenceAssemblyPaths();
    [CompilerGeneratedAttribute]
public void set_ReferenceAssemblyPaths(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_CIncludeDirectories();
    [CompilerGeneratedAttribute]
public void set_CIncludeDirectories(String[] value);
    [CompilerGeneratedAttribute]
public IList`1<IFileItem> get_ClIncludeFiles();
    [CompilerGeneratedAttribute]
public void set_ClIncludeFiles(IList`1<IFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<IFileItem> get_XamlApplications();
    [CompilerGeneratedAttribute]
public void set_XamlApplications(IList`1<IFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<IFileItem> get_XamlPages();
    [CompilerGeneratedAttribute]
public void set_XamlPages(IList`1<IFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<IFileItem> get_SdkXamlPages();
    [CompilerGeneratedAttribute]
public void set_SdkXamlPages(IList`1<IFileItem> value);
    [CompilerGeneratedAttribute]
public IAssemblyItem get_LocalAssembly();
    [CompilerGeneratedAttribute]
public void set_LocalAssembly(IAssemblyItem value);
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public void set_ProjectName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPass1();
    [CompilerGeneratedAttribute]
public void set_IsPass1(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDesignTimeBuild();
    [CompilerGeneratedAttribute]
public void set_IsDesignTimeBuild(bool value);
    [CompilerGeneratedAttribute]
public string get_RootNamespace();
    [CompilerGeneratedAttribute]
public void set_RootNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_OutputType();
    [CompilerGeneratedAttribute]
public void set_OutputType(string value);
    [CompilerGeneratedAttribute]
public string get_PriIndexName();
    [CompilerGeneratedAttribute]
public void set_PriIndexName(string value);
    [CompilerGeneratedAttribute]
public CodeGenCtrlFlags get_CodeGenerationControlFlags();
    [CompilerGeneratedAttribute]
public void set_CodeGenerationControlFlags(CodeGenCtrlFlags value);
    [CompilerGeneratedAttribute]
public FeatureCtrlFlags get_FeatureControlFlags();
    [CompilerGeneratedAttribute]
public void set_FeatureControlFlags(FeatureCtrlFlags value);
    [CompilerGeneratedAttribute]
public ILog get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(ILog value);
    [CompilerGeneratedAttribute]
public UInt32 get_XbfGenerationFlags();
    [CompilerGeneratedAttribute]
public void set_XbfGenerationFlags(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_XamlResourceMapName();
    [CompilerGeneratedAttribute]
public void set_XamlResourceMapName(string value);
    [CompilerGeneratedAttribute]
public string get_XamlComponentResourceLocation();
    [CompilerGeneratedAttribute]
public void set_XamlComponentResourceLocation(string value);
    [CompilerGeneratedAttribute]
public string get_GenXbfPath();
    [CompilerGeneratedAttribute]
public void set_GenXbfPath(string value);
    [CompilerGeneratedAttribute]
public string get_PrecompiledHeaderFile();
    [CompilerGeneratedAttribute]
public void set_PrecompiledHeaderFile(string value);
    public string get_XamlPlatformString();
    public void set_XamlPlatformString(string value);
    public Platform get_XamlPlatform();
    [CompilerGeneratedAttribute]
public bool get_EnableXBindDiagnostics();
    [CompilerGeneratedAttribute]
private void set_EnableXBindDiagnostics(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableTypeInfoReflection();
    [CompilerGeneratedAttribute]
private void set_EnableTypeInfoReflection(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableDefaultValidationContextGeneration();
    [CompilerGeneratedAttribute]
private void set_EnableDefaultValidationContextGeneration(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableWin32Codegen();
    [CompilerGeneratedAttribute]
private void set_EnableWin32Codegen(bool value);
    [CompilerGeneratedAttribute]
public bool get_UsingCSWinRT();
    [CompilerGeneratedAttribute]
private void set_UsingCSWinRT(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSpecifiedTargetPlatformMinVersion();
    [CompilerGeneratedAttribute]
public void set_IgnoreSpecifiedTargetPlatformMinVersion(bool value);
    public IList`1<string> get_GeneratedCodeFiles();
    public IList`1<string> get_GeneratedXamlFiles();
    public IList`1<string> get_GeneratedXbfFiles();
    public IList`1<string> get_GeneratedXamlPagesFiles();
    [CompilerGeneratedAttribute]
internal SavedStateManager get_SaveState();
    [CompilerGeneratedAttribute]
internal void set_SaveState(SavedStateManager value);
    internal string get_ProjectFolderFullpath();
    internal List`1<string> get_IncludeFolderList();
    internal string get_GeneratedExtension();
    internal string get_OutputFolderFullpath();
    public void PopulateFromCompilerInputs(CompilerInputs i);
    private IList`1<IFileItem> GetFileItems(List`1<MSBuildItem> list);
    private IList`1<IAssemblyItem> GetAssemblyItems(List`1<MSBuildItem> list);
    internal static String[] GetStringsFromItems(List`1<MSBuildItem> items);
    private CodeGenCtrlFlags TryParseCodeGenFlags(string flags);
    private FeatureCtrlFlags TryParseFeatureFlags(string flags);
    private void CleanUpSavedState();
    internal bool DidAssembliesChange();
    public bool DidXAMLFilesChange();
    private bool DidFeatureControlFlagsChange();
    private bool IsXAMLTypeInfoNeeded();
    private void ReportExistingGeneratedXamlFiles(TaskItemFilename tif);
    internal void ReportExistingGeneratedCodeFile(string targetFolder, string codeFileName);
    internal bool ShortcutBackupRestoreGeneratedPass2Files_WhenNothingExternalHasChanged();
    internal bool ShortcutBackupRestoreXamlTypeInfoFile_WhenNothingExternalHasChanged();
    internal void UpdateGeneratedFilesLists();
    public bool VerifyWorkDone();
    private SourceFileManager get_SourceFileManager();
    public void SaveStateBeforeFinishing();
    public bool DoExecute();
    private void DetermineGenXbfPath(XamlProjectInfo projectInfo);
    private bool CheckTaskArgumentsValid();
    private List`1<Assembly> LoadAssemblyItems(List`1<string> referenceAssemblies, bool isSystemAssembly);
    private Assembly LoadAssemblyItem(string item, bool isSystemAssembly);
    public Assembly LoadAssembly(string reference);
    public static Assembly TryLoadAssembly(string reference);
    internal Assembly LoadAssemblyFromReferencePath(string fileName);
    internal Assembly LoadAssemblyFromSystemExtraReferences(string fileName);
    internal bool DoesMscorlibNeedToBeLoaded(Assembly& mscorlib);
    protected void SetupLmrAssemblyResolveHandler();
    protected void RemoveLmrAssemblyResolveHandler();
    private void universe_OnResolveEvent(object sender, ResolveAssemblyNameEventArgs e);
    public void UnloadReferences();
    private DirectUISchemaContext LoadSchemaContext();
    protected void WriteOutputFilesToDisk(List`1<FileNameAndContentPair> generatedFiles, string targetFolder, bool updateOnlyIfContentNew);
    private bool WriteOnlyIfContentsAreNew(string outputFilename, string fileContents);
    protected void WriteXamlTypeInfoFilesToDisk(List`1<FileNameAndContentPair> codeFiles);
    private bool WriteRootsFile(Roots roots, string filename);
    private bool AreGeneratedCodeStringsTheSame(string oldString, string newString);
    private bool GenerateTypeInfo();
    private void GenerateBindingInfo();
    private Type GetIXamlType(List`1<Assembly> loadedAssemblies);
    private Type GetType(string typeName, List`1<Assembly> loadedAssemblies);
    private bool TypeExists(string typeName, List`1<Assembly> loadedAssemblies);
    private bool ReportSchemaErrors(string xamlFile);
    private bool ReportXbfErrors(XbfGenerator xbfGenerator);
    private XamlProjectInfo GetProjectInfo();
    private bool ProcessXamlFile_XamlTypeInfo(TaskItemFilename tif, XamlDomObject& xamlDomRoot);
    private bool ProcessXamlFile_PerPageInfo(TaskItemFilename tif, XamlDomObject& xamlDomRoot);
    private bool GenerateClasslessXamlOutputFile(string sourceXamlFullPath, string givenXamlPath, string targetFolder, string codeFileName, string xamlOutputFileName);
    private void PruneBindUniverses(XamlClassCodeInfo classCodeInfo);
    private bool GeneratePageOutputFiles(XamlClassCodeInfo classCodeInfo);
    private void CreateDirectoryIfNecessary(DirectoryInfo directoryInfo);
    private void CreateFileIfNecessary(string filename);
    private bool GenerateEditedXamlFile(List`1& generatedSources, XamlClassCodeInfo classCodeInfo, XamlFileCodeInfo fileCodeInfo);
    private bool GenerateXbfFiles(IEnumerable`1<IXbfFileNameInfo> xamlList);
    private bool GenerateSdkXbfFiles();
    private void AddGeneratedXbfFile(string filename);
    private void AddToGeneratedXbfFiles(IEnumerable`1<IXbfFileNameInfo> xamlXbfInfoList);
    private bool ProcessXProperty(XamlDomObject domRoot, XamlDomItem domItem, string xamlApparentRelativeName, String[] xamlLines);
    private bool PreprocessxProperties(XamlDomObject domRoot, string xamlFileName, string xamlApparentRelativeName);
    private bool LoadAndValidateXamlDom(string xamlFileName, string xamlApparentRelativeName, XamlDomObject& xamlDomRoot);
    private XamlDomObject LoadXamlDom(string xamlPath);
    private bool ValidateXaml(XamlDomObject domRoot, string xamlRelativePath);
    private bool ValidateXamlTypeInfo();
    private bool get_IsOutputTypeLibrary();
    private bool get_IsOutputTypeWinMd();
    private string GetComponentResourceLocation(string xamlComponentResourceLocation);
    private void SortReferenceAssemblies(List`1& systemItems, List`1& nonSystemItems, List`1& systemExtraItems);
    private IEnumerable`1<IFileItem> GetAdditionalXamlTypeInfoIncludes();
    private Dictionary`2<string, string> GetClassToHeaderFileMap();
    private bool BuildWarningSuppressionList();
    internal static string GetDefaultXamlLinkMetadata(string fileFullpath, string fileItemSpec, string projectFolderFullpath, IEnumerable`1<string> includeFullpathList);
    internal static bool IsFilePathInOrUnderFolderPath(string file, string folder, String& relativePath);
    internal static string GetBestSubPath(string fullpath, IEnumerable`1<string> folderList);
    internal static bool PathContainsComponent(string path, string component);
    private bool ShouldSuppressTypeInfoCodeGen();
    private bool ShouldSuppressPageCodeGen();
    [CompilerGeneratedAttribute]
internal BuildTaskFileService get_TaskFileService();
    [CompilerGeneratedAttribute]
internal void set_TaskFileService(BuildTaskFileService value);
    private void LogWarning(XamlCompileWarning warning, string xamlFile);
    private void LogWarningAsInfo(XamlCompileWarning warning);
    private void LogWarning(XamlCompileWarning warning);
    private void LogError(XamlCompileError error);
    public void LogError(string subcategory, ErrorCode code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message);
    private void LogError_ClassIsNotFoundInAssembly(string className, string localAssemblyName, string xamlFile);
    public void LogError_BadCodeGenFlags(string flag);
    private void LogError_EventsInAppXaml(string fileName);
    private void LogError_CannotResolveAssembly(string name);
    private void LogError_CannotResolveWinUIMetadata();
    private void LogError_ClassDoesntMatchWinmdName(string className, string winmdName, string xamlFile);
    private void LogError_XamlFileMustEndInDotXaml(string xamlFile);
    private void LogError_BadSuppressWarningsString(string warn);
    private void LogError_MoreThanOneApplicationXaml();
    private void LogError_XamlFilesWithSameApparentPath(string xamlFile1, string xamlFile2, string commonApparentPath);
    private void LogError_XamlXMLParsingError(Exception e, string file);
    internal void LogError_XamlInternalError(Exception e, string file);
    internal void LogUnhandledException(string subcategory, ErrorCode code, Exception e, string file);
    [CompilerGeneratedAttribute]
private string <ShortcutBackupRestoreGeneratedPass2Files_WhenNothingExternalHasChanged>b__235_0(ClassCodeGenFile cgf);
    [CompilerGeneratedAttribute]
private string <ShortcutBackupRestoreGeneratedPass2Files_WhenNothingExternalHasChanged>b__235_1(ClassCodeGenFile cgf);
}
public class Microsoft.UI.Xaml.Markup.Compiler.ConditionalNamespace : object {
    [CompilerGeneratedAttribute]
private string <UnconditionalNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ApiInformation <ApiInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Platform <PlatConditional>k__BackingField;
    private static Dictionary`2<string, ConditionalNamespace> cache;
    public string UnconditionalNamespace { get; }
    public ApiInformation ApiInfo { get; }
    public Platform PlatConditional { get; }
    public ConditionalNamespace(string unconditionalNamespace, ApiInformation apiInfo, Platform targetPlat);
    private static ConditionalNamespace();
    [CompilerGeneratedAttribute]
public string get_UnconditionalNamespace();
    [CompilerGeneratedAttribute]
public ApiInformation get_ApiInfo();
    [CompilerGeneratedAttribute]
public Platform get_PlatConditional();
    public static ConditionalNamespace Parse(string namespaceFullName);
}
[ContentPropertyAttribute("FieldDefinition")]
internal class Microsoft.UI.Xaml.Markup.Compiler.ConnectionIdElement : object {
    private List`1<EventAssignment> eventAssignments;
    private List`1<BindAssignment> bindAssignments;
    private List`1<BoundEventAssignment> boundEventAssignments;
    [CompilerGeneratedAttribute]
private ApiInformation <ApiInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private PhaseAssignment <PhaseAssignment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUsedByOtherScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private LineNumberInfo <LineNumberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlFileCodeInfo <ParentFileCodeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldDefinition <FieldDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private RootNamedElementStep <RootNamedElementStep>k__BackingField;
    [CompilerGeneratedAttribute]
private BindUniverse <BindUniverse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeInstantiatedLater>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnloadableRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultBindMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConnectionIdElement> <Children>k__BackingField;
    public ApiInformation ApiInformation { get; }
    public PhaseAssignment PhaseAssignment { get; }
    public bool IsBoundNamedTemplateElement { get; }
    public bool IsUsedByOtherScopes { get; public set; }
    public bool HasRewritableAttributes { get; }
    public LineNumberInfo LineNumberInfo { get; public set; }
    public XamlFileCodeInfo ParentFileCodeInfo { get; private set; }
    public XamlType Type { get; public set; }
    public int ConnectionId { get; }
    public string ElementName { get; }
    public FieldDefinition FieldDefinition { get; public set; }
    public bool HasFieldDefinition { get; }
    public RootNamedElementStep RootNamedElementStep { get; public set; }
    public bool HasRootNamedElementStep { get; }
    public BindUniverse BindUniverse { get; public set; }
    public bool HasEventAssignments { get; }
    public bool CanBeInstantiatedLater { get; private set; }
    public bool IsUnloadableRoot { get; private set; }
    public string DefaultBindMode { get; private set; }
    public IList`1<ConnectionIdElement> Children { get; }
    public List`1<EventAssignment> EventAssignments { get; }
    public IEnumerable`1<BindAssignment> InputPropertyBindAssignments { get; }
    public bool IsValueRequired { get; }
    public bool HasBindAssignments { get; }
    public IList`1<BindAssignment> BindAssignments { get; }
    public IEnumerable`1<BindAssignment> TwoWayBindAssignments { get; }
    public bool IsBindingRoot { get; }
    public bool IsBindingFileRoot { get; }
    public bool IsTemplateChild { get; }
    public bool NeedsConnectCase { get; }
    public bool HasPhase { get; }
    public bool HasBoundEventAssignments { get; }
    public List`1<BoundEventAssignment> BoundEventAssignments { get; }
    public bool IsWeakRef { get; }
    public bool NeedsNullCheckBeforeSetValue { get; }
    public string ObjectCodeName { get; }
    public string ElementCodeName { get; }
    public string ElementTemplatedParentCodeName { get; }
    public XamlType TemplatedParentType { get; }
    public LanguageSpecificString ReferenceExpression { get; }
    internal string LineNumberAndXamlFile { get; }
    public IEnumerable`1<ConnectionIdElement> ElementAndAllChildren { get; }
    public IEnumerable`1<ConnectionIdElement> AllChildren { get; }
    private ConnectionIdElement(XamlDomObject domObject, BindUniverse bindUniverse, XamlFileCodeInfo fileCodeInfo, XamlClassCodeInfo classCodeInfo, XamlType dataRootType);
    public ConnectionIdElement(XamlDomObject domObject, BindUniverse bindUniverse, XamlFileCodeInfo fileCodeInfo, XamlClassCodeInfo classCodeInfo, XamlType dataRootType, bool skipFieldDefinition);
    public ConnectionIdElement(XamlDomObject domObject, BindUniverse bindUniverse, XamlFileCodeInfo fileCodeInfo, XamlClassCodeInfo classCodeInfo, XamlType dataRootType, bool skipFieldDefinition, string clrPath);
    [CompilerGeneratedAttribute]
public ApiInformation get_ApiInformation();
    [CompilerGeneratedAttribute]
public PhaseAssignment get_PhaseAssignment();
    public bool get_IsBoundNamedTemplateElement();
    [CompilerGeneratedAttribute]
public bool get_IsUsedByOtherScopes();
    [CompilerGeneratedAttribute]
public void set_IsUsedByOtherScopes(bool value);
    public bool get_HasRewritableAttributes();
    [CompilerGeneratedAttribute]
public LineNumberInfo get_LineNumberInfo();
    [CompilerGeneratedAttribute]
public void set_LineNumberInfo(LineNumberInfo value);
    [CompilerGeneratedAttribute]
public XamlFileCodeInfo get_ParentFileCodeInfo();
    [CompilerGeneratedAttribute]
private void set_ParentFileCodeInfo(XamlFileCodeInfo value);
    [CompilerGeneratedAttribute]
public XamlType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(XamlType value);
    [CompilerGeneratedAttribute]
public int get_ConnectionId();
    [CompilerGeneratedAttribute]
public string get_ElementName();
    [CompilerGeneratedAttribute]
public FieldDefinition get_FieldDefinition();
    [CompilerGeneratedAttribute]
public void set_FieldDefinition(FieldDefinition value);
    public bool get_HasFieldDefinition();
    [CompilerGeneratedAttribute]
public RootNamedElementStep get_RootNamedElementStep();
    [CompilerGeneratedAttribute]
public void set_RootNamedElementStep(RootNamedElementStep value);
    public bool get_HasRootNamedElementStep();
    [CompilerGeneratedAttribute]
public BindUniverse get_BindUniverse();
    [CompilerGeneratedAttribute]
public void set_BindUniverse(BindUniverse value);
    public bool get_HasEventAssignments();
    [CompilerGeneratedAttribute]
public bool get_CanBeInstantiatedLater();
    [CompilerGeneratedAttribute]
private void set_CanBeInstantiatedLater(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsUnloadableRoot();
    [CompilerGeneratedAttribute]
private void set_IsUnloadableRoot(bool value);
    [CompilerGeneratedAttribute]
public string get_DefaultBindMode();
    [CompilerGeneratedAttribute]
private void set_DefaultBindMode(string value);
    [CompilerGeneratedAttribute]
public IList`1<ConnectionIdElement> get_Children();
    public List`1<EventAssignment> get_EventAssignments();
    public IEnumerable`1<BindAssignment> get_InputPropertyBindAssignments();
    public bool get_IsValueRequired();
    public bool TryGetValidationContextStep(PropertyStep& bindStep);
    public bool get_HasBindAssignments();
    public IList`1<BindAssignment> get_BindAssignments();
    public IEnumerable`1<BindAssignment> get_TwoWayBindAssignments();
    public bool get_IsBindingRoot();
    public bool get_IsBindingFileRoot();
    public bool get_IsTemplateChild();
    public bool get_NeedsConnectCase();
    public bool get_HasPhase();
    public bool get_HasBoundEventAssignments();
    public List`1<BoundEventAssignment> get_BoundEventAssignments();
    public bool get_IsWeakRef();
    public bool get_NeedsNullCheckBeforeSetValue();
    public string get_ObjectCodeName();
    public string get_ElementCodeName();
    public string get_ElementTemplatedParentCodeName();
    public XamlType get_TemplatedParentType();
    public LanguageSpecificString get_ReferenceExpression();
    public LanguageSpecificString GetMemberGetExpression(BindAssignmentBase bindAssignment);
    internal string get_LineNumberAndXamlFile();
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.ConnectionIdElement/<get_ElementAndAllChildren>d__116")]
public IEnumerable`1<ConnectionIdElement> get_ElementAndAllChildren();
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.ConnectionIdElement/<get_AllChildren>d__118")]
public IEnumerable`1<ConnectionIdElement> get_AllChildren();
    [CompilerGeneratedAttribute]
private string <get_ReferenceExpression>b__111_0();
    [CompilerGeneratedAttribute]
private string <get_ReferenceExpression>b__111_1();
    [CompilerGeneratedAttribute]
private string <get_ReferenceExpression>b__111_2();
    [CompilerGeneratedAttribute]
private string <get_ReferenceExpression>b__111_3();
    [CompilerGeneratedAttribute]
private string <get_ReferenceExpression>b__111_4();
    [CompilerGeneratedAttribute]
private string <get_ReferenceExpression>b__111_5();
    [CompilerGeneratedAttribute]
private string <get_ReferenceExpression>b__111_6();
    [CompilerGeneratedAttribute]
private string <get_ReferenceExpression>b__111_7();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.ContractVersion : object {
    public static Version ToVersion(UInt32 contractVersion);
}
public class Microsoft.UI.Xaml.Markup.Compiler.Core.InstanceCache`2 : Dictionary`2<TKey, TValue> {
    public InstanceCache`2(Action clearAction);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0_0();
}
public class Microsoft.UI.Xaml.Markup.Compiler.Core.InstanceCacheManager : object {
    private static List`1<Action> clearActions;
    private static InstanceCacheManager();
    public static void Register(Action action);
    public static void ClearCache();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Core.XamlCompilerReflectionHelper : object {
    private static string testSourceFile;
    private static XamlCompilerReflectionHelper();
    public XamlDomObject CreateCompilerDomRoot(XamlReader xamlReader);
    public XamlDomObject CreateDomRoot(string xamlString, XamlSchemaContext schema, Assembly localAssembly);
    public static IEnumerable`1<IXbfFileNameInfo> CreateXbfFilenameInfoArray(String[] filenames);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.CreateFromStringMethod : object {
    private string fullName;
    private string localName;
    private XamlType declaringType;
    [CompilerGeneratedAttribute]
private MethodInfo <MethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Resolved>k__BackingField;
    public MethodInfo MethodInfo { get; private set; }
    public XamlType DeclaringType { get; }
    public bool Resolved { get; private set; }
    public bool Exists { get; }
    public string UnresolvedName { get; }
    public LanguageSpecificString ResolvedName { get; }
    public CreateFromStringMethod(string fullName);
    public CreateFromStringMethod(XamlType declaringType, string localName);
    [CompilerGeneratedAttribute]
public MethodInfo get_MethodInfo();
    [CompilerGeneratedAttribute]
private void set_MethodInfo(MethodInfo value);
    public XamlType get_DeclaringType();
    [CompilerGeneratedAttribute]
public bool get_Resolved();
    [CompilerGeneratedAttribute]
private void set_Resolved(bool value);
    public bool get_Exists();
    public string get_UnresolvedName();
    public void SetResolved(XamlType declaringType, string methodName, MethodInfo methodInfo);
    public LanguageSpecificString get_ResolvedName();
    [CompilerGeneratedAttribute]
private string <get_ResolvedName>b__22_0();
    [CompilerGeneratedAttribute]
private string <get_ResolvedName>b__22_1();
    [CompilerGeneratedAttribute]
private string <get_ResolvedName>b__22_2();
    [CompilerGeneratedAttribute]
private string <get_ResolvedName>b__22_3();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DataTypeAssignment : object {
    [CompilerGeneratedAttribute]
private LineNumberInfo <LineNumberInfo>k__BackingField;
    public LineNumberInfo LineNumberInfo { get; public set; }
    public DataTypeAssignment(XamlDomMember dataTypeMember);
    [CompilerGeneratedAttribute]
public sealed virtual LineNumberInfo get_LineNumberInfo();
    [CompilerGeneratedAttribute]
public void set_LineNumberInfo(LineNumberInfo value);
    public sealed virtual XamlCompileError GetAttributeProcessingError();
}
[FlagsAttribute]
internal enum Microsoft.UI.Xaml.Markup.Compiler.DefaultBindMode : Enum {
    public int value__;
    public static DefaultBindMode OneTime;
    public static DefaultBindMode OneWay;
    public static DefaultBindMode TwoWay;
}
public class Microsoft.UI.Xaml.Markup.Compiler.DependencyPropertyStep : PropertyStep {
    [CompilerGeneratedAttribute]
private XamlType <OwnerType>k__BackingField;
    public XamlType OwnerType { get; }
    public string UniqueName { get; }
    public DependencyPropertyStep(string name, XamlType valueType, BindPathStep parent, ApiInformation apiInformation);
    public DependencyPropertyStep(string name, XamlType valueType, XamlType ownerType, BindPathStep parent, ApiInformation apiInformation);
    [CompilerGeneratedAttribute]
public XamlType get_OwnerType();
    public virtual string get_UniqueName();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.DirectUIAssembly : Assembly {
    private Assembly _assembly;
    private AssemblyName _assemblyName;
    public Assembly WrappedAssembly { get; }
    public bool IsWinmd { get; }
    public string BaseName { get; }
    public bool ReflectionOnly { get; }
    public string FullName { get; }
    public string Location { get; }
    private DirectUIAssembly(Assembly assembly);
    public static DirectUIAssembly Wrap(Assembly assembly);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.DirectUI.DirectUIAssembly/<Wrap>d__4")]
public static IEnumerable`1<DirectUIAssembly> Wrap(IEnumerable`1<Assembly> assemblies);
    public Assembly get_WrappedAssembly();
    public bool get_IsWinmd();
    public string get_BaseName();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual AssemblyName GetName();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool get_ReflectionOnly();
    public virtual Type GetType(string name);
    public virtual Type[] GetTypes();
    public virtual string get_FullName();
    public virtual string get_Location();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.DirectUINativeTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.DirectUISchemaContext : XamlSchemaContext {
    internal static List`1<string> DirectUI2010Paths;
    private static ReadOnlyCollection`1<string> DirectUIXamlNamespaces;
    private Assembly localAssembly;
    private DirectUISystem directUISystem;
    private IDirectUIXamlLanguage directUIXamlLanguage;
    private List`1<string> systemExtraReferenceItems;
    private IEnumerable`1<DirectUIAssembly> systemExtraAssemblies;
    private ISet`1<string> staticLibraryAssemblies;
    private Dictionary`2<string, Dictionary`2<string, ProxyDirectUIXamlType>> proxyTypes;
    private List`1<Assembly> managedProjectionAssemblies;
    private Dictionary`2<Type, XamlType> masterTypeTable;
    private Dictionary`2<string, XamlType> uiXamlCache;
    private Dictionary`2<string, List`1<string>> usingNamespaces;
    private Dictionary`2<string, XamlType> masterTypeTableByFullName;
    private Dictionary`2<string, XamlType> domFullTypeNameCache;
    private Lazy`1<List`1<XamlCompileWarning>> warningMessages;
    private Lazy`1<List`1<XamlCompileError>> errorMessages;
    private string windowsSdkPath;
    [CompilerGeneratedAttribute]
private TypeResolver <TypeResolver>k__BackingField;
    internal List`1<XamlCompileWarning> SchemaWarnings { get; }
    internal List`1<XamlCompileError> SchemaErrors { get; }
    internal TypeResolver TypeResolver { get; internal set; }
    internal DirectUISystem DirectUISystem { get; }
    internal IDirectUIXamlLanguage DirectUIXamlLanguage { get; }
    internal Dictionary`2<string, Dictionary`2<string, ProxyDirectUIXamlType>> ProxyTypes { get; }
    public DirectUISchemaContext(IEnumerable`1<Assembly> referenceAssemblies, List`1<string> systemExtraReferenceItems, Assembly localAssembly, ISet`1<string> staticLibraryAssemblies, string sdkPath, bool isStringNullable);
    private static DirectUISchemaContext();
    internal List`1<XamlCompileWarning> get_SchemaWarnings();
    internal List`1<XamlCompileError> get_SchemaErrors();
    [CompilerGeneratedAttribute]
internal TypeResolver get_TypeResolver();
    [CompilerGeneratedAttribute]
internal void set_TypeResolver(TypeResolver value);
    internal DirectUISystem get_DirectUISystem();
    internal IDirectUIXamlLanguage get_DirectUIXamlLanguage();
    internal Dictionary`2<string, Dictionary`2<string, ProxyDirectUIXamlType>> get_ProxyTypes();
    public virtual XamlType GetXamlType(Type type);
    public virtual ICollection`1<XamlType> GetAllXamlTypes(string xamlNamespace);
    public bool IsLocalAssembly(DirectUIAssembly asm);
    public virtual XamlDirective GetXamlDirective(string xamlNamespace, string name);
    internal XamlType GetXamlType(string fullName);
    internal XamlType GetProxyType(string xamlNamespace, string name);
    protected internal virtual XamlType GetXamlType(string xamlNamespace, string name, XamlType[] typeArguments);
    private ICollection`1<XamlType> LookupAllXamlTypes(string xamlNamespace);
    private Type EnsureIsLmrType(Type type);
    private XamlType GetXamlTypeFromUsing(string xamlNamespace, string name, XamlType[] typeArguments);
    private XamlType GetDirectUIXamlType(string name);
    private XamlType GetXamlTypeFromAssembliesAndPaths(IEnumerable`1<Assembly> asmList, IEnumerable`1<string> pathList, string name);
    private XamlType GetXamlTypeFromAssembliesAndPath(IEnumerable`1<Assembly> asmList, string path, string name);
    private XamlType GetXamlTypeFromAsmAndPath(Assembly asm, string path, string name);
    private static string GetTypeExtensionName(string typeName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.DirectUISystem : object {
    private List`1<DirectUIAssembly> systemAssemblies;
    private List`1<XamlTypeUniverse> xamlTypeUniverses;
    private List`1<DirectUIAssembly> platformAssemblies;
    private Lazy`1<Type> _Void;
    private Lazy`1<Type> _Object;
    private Lazy`1<Type> _String;
    private Lazy`1<Type> _Double;
    private Lazy`1<Type> _Int32;
    private Lazy`1<Type> _Boolean;
    private Lazy`1<Type> _Nullable;
    private Lazy`1<Type> _IReference;
    private Lazy`1<Type> _Type;
    private Lazy`1<Type> _frameworkTemplate;
    private Lazy`1<Type> _dataTemplate;
    private Lazy`1<Type> _controlTemplate;
    private Lazy`1<Type> _dependencyObject;
    private Lazy`1<Type> _dependencyProperty;
    private Lazy`1<Type> _frameworkElement;
    private Lazy`1<Type> _style;
    private Lazy`1<Type> _IComponentConnector;
    private Lazy`1<Type> _setter;
    private Lazy`1<Type> _binding;
    private Lazy`1<Type> _propertyPath;
    private Lazy`1<Type> _relativeSource;
    private Lazy`1<Type> _contentPropertyAttribute;
    private Lazy`1<Type> _inlineCollection;
    private Lazy`1<Type> _inline;
    private Lazy`1<Type> _lineBreak;
    private Lazy`1<Type> _uiElement;
    private Lazy`1<Type> _resourceDictionary;
    private Lazy`1<Type> _Deprecated;
    private Lazy`1<Type> _Delegate;
    private Lazy`1<Type> _flyoutBase;
    private Lazy`1<Type> _markupExtension;
    private Lazy`1<Type> _textBox;
    private Lazy`1<Type> _validationCommand;
    private Lazy`1<Type> _window;
    internal Type Void { get; }
    internal Type Object { get; }
    internal Type String { get; }
    internal Type Double { get; }
    internal Type Int32 { get; }
    internal Type Boolean { get; }
    internal Type Nullable { get; }
    internal Type IReference { get; }
    internal Type Type { get; }
    internal Type FrameworkTemplate { get; }
    internal Type DataTemplate { get; }
    internal Type ControlTemplate { get; }
    internal Type DependencyObject { get; }
    internal Type DependencyProperty { get; }
    internal Type FrameworkElement { get; }
    internal Type Style { get; }
    internal Type IComponentConnector { get; }
    internal Type Setter { get; }
    internal Type Binding { get; }
    internal Type PropertyPath { get; }
    internal Type RelativeSource { get; }
    internal Type ContentPropertyAttribute { get; }
    internal Type InlineCollection { get; }
    internal Type Inline { get; }
    internal Type LineBreak { get; }
    internal Type UIElement { get; }
    internal Type ResourceDictionary { get; }
    internal Type Deprecated { get; }
    internal Type Delegate { get; }
    internal Type FlyoutBase { get; }
    internal Type MarkupExtension { get; }
    internal Type TextBox { get; }
    internal Type ValidationCommand { get; }
    internal Type Window { get; }
    internal List`1<DirectUIAssembly> DirectUIBaseAssemblies { get; }
    internal List`1<DirectUIAssembly> PlatformAssemblies { get; }
    internal List`1<XamlTypeUniverse> XamlTypeUniverses { get; }
    public DirectUISystem(IList`1<Assembly> referenceAssemblies);
    internal Type get_Void();
    internal Type get_Object();
    internal Type get_String();
    internal Type get_Double();
    internal Type get_Int32();
    internal Type get_Boolean();
    internal Type get_Nullable();
    internal Type get_IReference();
    internal Type get_Type();
    internal Type get_FrameworkTemplate();
    internal Type get_DataTemplate();
    internal Type get_ControlTemplate();
    internal Type get_DependencyObject();
    internal Type get_DependencyProperty();
    internal Type get_FrameworkElement();
    internal Type get_Style();
    internal Type get_IComponentConnector();
    internal Type get_Setter();
    internal Type get_Binding();
    internal Type get_PropertyPath();
    internal Type get_RelativeSource();
    internal Type get_ContentPropertyAttribute();
    internal Type get_InlineCollection();
    internal Type get_Inline();
    internal Type get_LineBreak();
    internal Type get_UIElement();
    internal Type get_ResourceDictionary();
    internal Type get_Deprecated();
    internal Type get_Delegate();
    internal Type get_FlyoutBase();
    internal Type get_MarkupExtension();
    internal Type get_TextBox();
    internal Type get_ValidationCommand();
    internal Type get_Window();
    internal List`1<DirectUIAssembly> get_DirectUIBaseAssemblies();
    internal List`1<DirectUIAssembly> get_PlatformAssemblies();
    internal List`1<XamlTypeUniverse> get_XamlTypeUniverses();
    internal Type DirectUISystemGetType(string typeName, bool mustExist);
    private void LoadCoreDirectUIAssemblies(IList`1<Assembly> referenceAssemblies);
    private DirectUIAssembly GetSystemAssembly(string assemblyName);
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_0();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_1();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_2();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_3();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_4();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_5();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_6();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_7();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_8();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_9();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_10();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_11();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_12();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_13();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_14();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_15();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_16();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_17();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_18();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_19();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_20();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_21();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_22();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_23();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_24();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_25();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_26();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_27();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_28();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_29();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_30();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_31();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_32();
    [CompilerGeneratedAttribute]
private Type <.ctor>b__37_33();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.DirectUIXamlLanguage : object {
    private DirectUISchemaContext schema;
    private Lazy`1<XamlType> objectXamlType;
    private Lazy`1<XamlType> stringXamlType;
    private Lazy`1<XamlType> doubleXamlType;
    private Lazy`1<XamlType> int32XamlType;
    private Lazy`1<XamlType> booleanXamlType;
    private Lazy`1<XamlType> uiElementXamlType;
    private Lazy`1<XamlType> nullExtensionXamlType;
    private Lazy`1<XamlType> staticResourceExtensionXamlType;
    private Lazy`1<XamlType> customResourceExtensionXamlType;
    private Lazy`1<XamlType> bindExtensionXamlType;
    private Lazy`1<XamlType> propertiesXamlType;
    private Lazy`1<XamlType> propertyXamlType;
    [CompilerGeneratedAttribute]
private bool <IsStringNullable>k__BackingField;
    public XamlType Object { get; }
    public XamlType String { get; }
    public XamlType Double { get; }
    public XamlType Int32 { get; }
    public XamlType Boolean { get; }
    public XamlType NullExtension { get; }
    public XamlType StaticResourceExtension { get; }
    public XamlType CustomResourceExtension { get; }
    public XamlType BindExtension { get; }
    public XamlType UIElement { get; }
    public XamlType Properties { get; }
    public XamlType Property { get; }
    public bool IsStringNullable { get; }
    public DirectUIXamlLanguage(DirectUISchemaContext schema, bool isStringNullable);
    public sealed virtual XamlType get_Object();
    public sealed virtual XamlType get_String();
    public sealed virtual XamlType get_Double();
    public sealed virtual XamlType get_Int32();
    public sealed virtual XamlType get_Boolean();
    public sealed virtual XamlType get_NullExtension();
    public sealed virtual XamlType get_StaticResourceExtension();
    public sealed virtual XamlType get_CustomResourceExtension();
    public sealed virtual XamlType get_BindExtension();
    public sealed virtual XamlType get_UIElement();
    public sealed virtual XamlType get_Properties();
    public sealed virtual XamlType get_Property();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStringNullable();
    public sealed virtual XamlType LookupXamlObjects(string name);
    private XamlType GetDirectUIXamlType(Type type);
    private XamlType GetDirectUIProxyXamlType(string name);
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_0();
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_1();
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_2();
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_3();
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_4();
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_5();
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_6();
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_7();
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_8();
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_9();
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_10();
    [CompilerGeneratedAttribute]
private XamlType <.ctor>b__13_11();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.DirectUIXamlMember : XamlMember {
    private XamlType _eventArgType;
    private Nullable`1<bool> _isDependencyProperty;
    private Nullable`1<bool> _isIndexer;
    private Nullable`1<bool> _hasPublicGetter;
    private Nullable`1<bool> _hasPublicSetter;
    private Nullable`1<bool> _isDeprecated;
    private Nullable`1<bool> _isTemplate;
    private bool _isHardDeprecated;
    private string _deprecatedMessage;
    private Nullable`1<bool> isExperimental;
    private MethodInfo _attachablePropertySetter;
    private MethodInfo _attachablePropertyGetter;
    [CompilerGeneratedAttribute]
private ApiInformation <ApiInformation>k__BackingField;
    public ApiInformation ApiInformation { get; public set; }
    public bool IsDependencyProperty { get; }
    public bool IsDeprecated { get; }
    public bool IsHardDeprecated { get; }
    public string DeprecatedMessage { get; }
    public bool IsExperimental { get; }
    public XamlType EventArgumentType { get; }
    public bool IsTemplate { get; }
    public bool IsIndexer { get; }
    public bool HasPublicGetter { get; }
    public bool HasPublicSetter { get; }
    public DirectUIXamlMember(PropertyInfo propertyInfo, DirectUISchemaContext schemaContext, ApiInformation apiInformation);
    public DirectUIXamlMember(EventInfo eventInfo, DirectUISchemaContext schemaContext, ApiInformation apiInformation);
    public DirectUIXamlMember(string name, DirectUIXamlType declaringType, bool isAttachable, ApiInformation apiInformation);
    public DirectUIXamlMember(string name, DirectUIXamlType declaringType);
    public DirectUIXamlMember(string attachablePropertyName, XamlMemberInvoker invoker, XamlSchemaContext schemaContext, ApiInformation apiInformation);
    [CompilerGeneratedAttribute]
public ApiInformation get_ApiInformation();
    [CompilerGeneratedAttribute]
public void set_ApiInformation(ApiInformation value);
    public sealed virtual bool get_IsDependencyProperty();
    public bool get_IsDeprecated();
    public bool get_IsHardDeprecated();
    public string get_DeprecatedMessage();
    public bool get_IsExperimental();
    public XamlType get_EventArgumentType();
    public bool get_IsTemplate();
    public bool get_IsIndexer();
    public bool get_HasPublicGetter();
    public bool get_HasPublicSetter();
    protected virtual bool LookupIsTemplate();
    protected virtual bool LookupIsIndexer();
    protected virtual bool LookupIsDependencyProperty();
    private CustomAttributeData GetAttribute(string attrName);
    private bool CheckDeprecationAttribute(string attrName, string defaultMessage);
    protected virtual bool LookupIsDeprecated();
    protected virtual bool LookupIsExperimental();
    protected virtual XamlType LookupEventArgType();
    protected virtual bool LookupHasPublicGetter();
    protected virtual bool LookupHasPublicSetter();
    protected virtual XamlType LookupType();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.DirectUIXamlType : XamlType {
    private List`1<XamlType> inlineCollectionAllowedContentTypes;
    private Nullable`1<bool> isValueType;
    private Nullable`1<bool> isCodeGenType;
    private Nullable`1<bool> hasWinUIContract;
    private Nullable`1<bool> isSignedChar;
    private Nullable`1<bool> isEnumBaseType;
    private Nullable`1<bool> isEnum;
    private Nullable`1<bool> isTemplateType;
    private List`1<string> enumNamesList;
    private Nullable`1<bool> isNullableGeneric;
    private Type nullableGenericInnerType;
    private Nullable`1<bool> isDeprecated;
    private bool isHardDeprecated;
    private string deprecatedMessage;
    private Nullable`1<bool> isExperimental;
    private MethodInfo addMethod;
    private MemberProxyMetadata frameworkTemplateProxyMetadata;
    private Nullable`1<bool> _hasValueConverter;
    private Nullable`1<bool> _hasMetadataProvider;
    private Nullable`1<bool> _isStyle;
    private Nullable`1<bool> _isBinding;
    private Nullable`1<bool> _isPropertyPath;
    private CreateFromStringMethod _createFromStringMethod;
    private Nullable`1<bool> _hasINotifyPropertyChanged;
    private Nullable`1<bool> _hasINotifyCollectionChanged;
    private Nullable`1<bool> _hasINotifyDataErrorInfo;
    private Nullable`1<bool> _hasObservableVector;
    private Nullable`1<bool> _hasObservableMap;
    private Nullable`1<bool> _isDelegate;
    private Nullable`1<bool> _isDerivedFromFrameworkTemplate;
    private Nullable`1<bool> _isDerivedFromValidationCommand;
    private Nullable`1<bool> _isDerivedFromResourceDictionary;
    private Nullable`1<bool> _isDerivedFromUIElement;
    private Nullable`1<bool> _isDerivedFromFlyoutBase;
    private Nullable`1<bool> _isDerivedFromMarkupExtension;
    private Nullable`1<bool> _isDerivedFromTextBox;
    [CompilerGeneratedAttribute]
private ApiInformation <ApiInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Platform <TargetPlatform>k__BackingField;
    internal static List`1<string> WindowsFoundationSystemTypes;
    private static List`1<string> PrimitiveSystemTypes;
    private static List`1<string> _namesOfTypesWithConverters;
    public ApiInformation ApiInformation { get; }
    public bool HasApiInformation { get; }
    public Platform TargetPlatform { get; }
    public bool IsValueType { get; }
    public bool IsCodeGenType { get; }
    public bool HasWinUIContract { get; }
    public bool IsSignedChar { get; }
    public bool IsEnumBaseType { get; }
    public bool IsTemplateType { get; }
    public bool IsEnum { get; }
    public List`1<string> EnumNames { get; }
    public bool IsInvalidType { get; }
    public bool IsDeprecated { get; }
    public bool IsHardDeprecated { get; }
    public string DeprecatedMessage { get; }
    public bool IsExperimental { get; }
    public string AddMethodName { get; }
    public bool IsValueConverter { get; }
    public bool IsMetadataProvider { get; }
    public bool IsAssignableToStyle { get; }
    public bool IsAssignableToBinding { get; }
    public bool IsAssignableToPropertyPath { get; }
    public bool ImplementsINotifyPropertyChanged { get; }
    public bool ImplementsINotifyDataErrorInfo { get; }
    public bool ImplementsINotifyCollectionChanged { get; }
    public bool ImplementsIObservableVector { get; }
    public bool ImplementsIObservableMap { get; }
    public bool IsDelegate { get; }
    public bool IsDerivedFromFrameworkTemplate { get; }
    public bool IsDerivedFromValidationCommand { get; }
    public bool IsDerivedFromResourceDictionary { get; }
    public bool IsDerivedFromUIElement { get; }
    public bool IsDerivedFromFlyoutBase { get; }
    public bool IsDerivedFromMarkupExtension { get; }
    public bool IsDerivedFromTextBox { get; }
    private IDirectUIXamlLanguage DirectUIXamlLanguage { get; }
    private DirectUISystem DirectUISystem { get; }
    private MemberProxyMetadata FrameworkTemplateProxyMetadata { get; }
    public CreateFromStringMethod CreateFromStringMethod { get; }
    public DirectUIXamlType(Type underlyingType, XamlSchemaContext schemaContext);
    public DirectUIXamlType(Type underlyingType, XamlSchemaContext schemaContext, ApiInformation apiInformation, Platform targetPlatform);
    public DirectUIXamlType(string name, IList`1<XamlType> typeArgs, XamlSchemaContext schemaContext);
    private static DirectUIXamlType();
    [CompilerGeneratedAttribute]
public ApiInformation get_ApiInformation();
    public sealed virtual bool get_HasApiInformation();
    [CompilerGeneratedAttribute]
public Platform get_TargetPlatform();
    public bool get_IsValueType();
    public bool get_IsCodeGenType();
    public bool get_HasWinUIContract();
    public bool get_IsSignedChar();
    public bool get_IsEnumBaseType();
    public bool get_IsTemplateType();
    public bool get_IsEnum();
    public List`1<string> get_EnumNames();
    public bool get_IsInvalidType();
    public bool get_IsDeprecated();
    public bool get_IsHardDeprecated();
    public string get_DeprecatedMessage();
    public bool get_IsExperimental();
    public string get_AddMethodName();
    public bool get_IsValueConverter();
    public bool get_IsMetadataProvider();
    public bool get_IsAssignableToStyle();
    public bool get_IsAssignableToBinding();
    public bool get_IsAssignableToPropertyPath();
    public bool HasInterface(string fullName);
    public sealed virtual bool get_ImplementsINotifyPropertyChanged();
    public sealed virtual bool get_ImplementsINotifyDataErrorInfo();
    public sealed virtual bool get_ImplementsINotifyCollectionChanged();
    public sealed virtual bool get_ImplementsIObservableVector();
    public sealed virtual bool get_ImplementsIObservableMap();
    public bool get_IsDelegate();
    public bool get_IsDerivedFromFrameworkTemplate();
    public bool get_IsDerivedFromValidationCommand();
    public bool get_IsDerivedFromResourceDictionary();
    public bool get_IsDerivedFromUIElement();
    public bool get_IsDerivedFromFlyoutBase();
    public bool get_IsDerivedFromMarkupExtension();
    public bool get_IsDerivedFromTextBox();
    public XamlMember LookupMember_SkipReadOnlyCheck(string propertyName);
    public bool IsNullableGeneric(Type& innerType);
    protected virtual bool LookupIsSignedChar();
    protected virtual bool LookupIsEnumBaseType();
    protected virtual bool LookupIsValueType();
    private CustomAttributeData GetDirectAttribute(string name);
    private CustomAttributeData GetAttribute(string attrName, bool inherited);
    private static CustomAttributeData GetAttribute(Type type, string attrName, bool inherited);
    private bool CheckDeprecationAttribute(string attrName, string defaultMessage);
    protected virtual bool LookupIsDeprecated();
    protected virtual bool LookupIsExperimental();
    protected virtual bool LookupIsTemplateType();
    protected virtual bool LookupIsCodeGenType();
    protected bool LookupIsEnum();
    protected List`1<string> LookupEnumNames();
    protected virtual XamlType LookupBaseType();
    protected virtual XamlCollectionKind LookupCollectionKind();
    protected virtual XamlType LookupItemType();
    protected virtual XamlType LookupKeyType();
    protected virtual bool LookupIsConstructible();
    protected virtual XamlMember LookupAttachableMember(string name);
    protected virtual IEnumerable`1<XamlMember> LookupAllAttachableMembers();
    protected virtual XamlMember LookupMember(string propertyName, bool skipReadOnlyCheck);
    protected virtual IEnumerable`1<XamlMember> LookupAllMembers();
    protected virtual XamlMember LookupContentProperty();
    protected virtual IList`1<XamlType> LookupAllowedContentTypes();
    protected virtual XamlType LookupMarkupExtensionReturnType();
    private IDirectUIXamlLanguage get_DirectUIXamlLanguage();
    private DirectUISystem get_DirectUISystem();
    protected virtual bool LookupIsMarkupExtension();
    protected virtual bool LookupIsNameScope();
    protected virtual bool LookupIsXData();
    protected virtual bool LookupTrimSurroundingWhitespace();
    protected virtual bool LookupIsWhitespaceSignificantCollection();
    protected virtual XamlMember LookupAliasedProperty(XamlDirective directive);
    protected virtual XamlValueConverter`1<TypeConverter> LookupTypeConverter();
    protected XamlValueConverter`1<TypeConverter> FindTypeConverter(Type underlyingType);
    protected virtual bool LookupIsNullable();
    protected virtual bool LookupIsNullableGeneric(Type& innerType);
    private bool IsFrameworkTemplateProperty(string propertyName);
    private MemberProxyMetadata get_FrameworkTemplateProxyMetadata();
    private Type GetCollectionReleventInterface();
    private bool GetCollectionKind(Type type, XamlCollectionKind& collectionKind);
    private MethodInfo GetMethodWithNParameters(Type type, string methodName, int paramCount, Boolean& hasMoreThanOne);
    private bool IsAttachablePropertyGetter(MethodInfo methodInfo, String& name);
    private bool IsAttachablePropertySetter(MethodInfo methodInfo, String& name);
    private XamlMember GetPropertyOrUnknown(string propertyName, bool skipReadOnlyCheck);
    public CreateFromStringMethod get_CreateFromStringMethod();
    private string LookupCreateFromStringMethod();
    internal static bool LookupHasWinUIContract(Type type);
    private bool LookupHasWinUIContract();
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.DirectUI.IDirectUIXamlLanguage {
    public XamlType BindExtension { get; }
    public XamlType Boolean { get; }
    public XamlType CustomResourceExtension { get; }
    public XamlType Double { get; }
    public XamlType Int32 { get; }
    public XamlType NullExtension { get; }
    public XamlType Object { get; }
    public XamlType StaticResourceExtension { get; }
    public XamlType String { get; }
    public XamlType UIElement { get; }
    public XamlType Properties { get; }
    public XamlType Property { get; }
    public bool IsStringNullable { get; }
    public abstract virtual XamlType get_BindExtension();
    public abstract virtual XamlType get_Boolean();
    public abstract virtual XamlType get_CustomResourceExtension();
    public abstract virtual XamlType get_Double();
    public abstract virtual XamlType get_Int32();
    public abstract virtual XamlType get_NullExtension();
    public abstract virtual XamlType get_Object();
    public abstract virtual XamlType get_StaticResourceExtension();
    public abstract virtual XamlType get_String();
    public abstract virtual XamlType get_UIElement();
    public abstract virtual XamlType get_Properties();
    public abstract virtual XamlType get_Property();
    public abstract virtual bool get_IsStringNullable();
    public abstract virtual XamlType LookupXamlObjects(string name);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.MemberProxyMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlMemberInvoker <Invoker>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlValueConverter`1<XamlDeferringLoader> <DeferringLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlValueConverter`1<TypeConverter> <TypeConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlValueConverter`1<ValueSerializer> <ValueSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<XamlMember> <DependsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAmbient>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnknown>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWriteOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWritePublic>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <XamlNamespaces>k__BackingField;
    public string Name { get; private set; }
    public XamlMemberInvoker Invoker { get; private set; }
    public XamlValueConverter`1<XamlDeferringLoader> DeferringLoader { get; internal set; }
    public XamlValueConverter`1<TypeConverter> TypeConverter { get; private set; }
    public XamlValueConverter`1<ValueSerializer> ValueSerializer { get; private set; }
    public IList`1<XamlMember> DependsOn { get; private set; }
    public bool IsAmbient { get; private set; }
    public bool IsEvent { get; private set; }
    public bool IsReadPublic { get; private set; }
    public bool IsReadOnly { get; private set; }
    public bool IsUnknown { get; private set; }
    public bool IsWriteOnly { get; private set; }
    public bool IsWritePublic { get; private set; }
    public XamlType TargetType { get; private set; }
    public XamlType Type { get; private set; }
    public IList`1<string> XamlNamespaces { get; private set; }
    public MemberProxyMetadata(string name, XamlType type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public XamlMemberInvoker get_Invoker();
    [CompilerGeneratedAttribute]
private void set_Invoker(XamlMemberInvoker value);
    [CompilerGeneratedAttribute]
public XamlValueConverter`1<XamlDeferringLoader> get_DeferringLoader();
    [CompilerGeneratedAttribute]
internal void set_DeferringLoader(XamlValueConverter`1<XamlDeferringLoader> value);
    [CompilerGeneratedAttribute]
public XamlValueConverter`1<TypeConverter> get_TypeConverter();
    [CompilerGeneratedAttribute]
private void set_TypeConverter(XamlValueConverter`1<TypeConverter> value);
    [CompilerGeneratedAttribute]
public XamlValueConverter`1<ValueSerializer> get_ValueSerializer();
    [CompilerGeneratedAttribute]
private void set_ValueSerializer(XamlValueConverter`1<ValueSerializer> value);
    [CompilerGeneratedAttribute]
public IList`1<XamlMember> get_DependsOn();
    [CompilerGeneratedAttribute]
private void set_DependsOn(IList`1<XamlMember> value);
    [CompilerGeneratedAttribute]
public bool get_IsAmbient();
    [CompilerGeneratedAttribute]
private void set_IsAmbient(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEvent();
    [CompilerGeneratedAttribute]
private void set_IsEvent(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReadPublic();
    [CompilerGeneratedAttribute]
private void set_IsReadPublic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
private void set_IsReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsUnknown();
    [CompilerGeneratedAttribute]
private void set_IsUnknown(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsWriteOnly();
    [CompilerGeneratedAttribute]
private void set_IsWriteOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsWritePublic();
    [CompilerGeneratedAttribute]
private void set_IsWritePublic(bool value);
    [CompilerGeneratedAttribute]
public XamlType get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(XamlType value);
    [CompilerGeneratedAttribute]
public XamlType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(XamlType value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_XamlNamespaces();
    [CompilerGeneratedAttribute]
private void set_XamlNamespaces(IList`1<string> value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ProxyDirectUIXamlMember : DirectUIXamlMember {
    private MemberProxyMetadata metadata;
    public ProxyDirectUIXamlMember(MemberProxyMetadata metadata, DirectUIXamlType declaringType);
    protected virtual XamlMemberInvoker LookupInvoker();
    protected virtual XamlValueConverter`1<XamlDeferringLoader> LookupDeferringLoader();
    protected virtual IList`1<XamlMember> LookupDependsOn();
    protected virtual bool LookupIsAmbient();
    protected virtual bool LookupIsEvent();
    protected virtual bool LookupIsReadPublic();
    protected virtual bool LookupIsReadOnly();
    protected virtual bool LookupIsUnknown();
    protected virtual bool LookupIsWriteOnly();
    protected virtual bool LookupIsWritePublic();
    protected virtual XamlType LookupTargetType();
    protected virtual XamlValueConverter`1<TypeConverter> LookupTypeConverter();
    protected virtual XamlValueConverter`1<ValueSerializer> LookupValueSerializer();
    protected virtual XamlType LookupType();
    protected virtual MethodInfo LookupUnderlyingGetter();
    protected virtual MethodInfo LookupUnderlyingSetter();
    protected virtual MemberInfo LookupUnderlyingMember();
    public virtual IList`1<string> GetXamlNamespaces();
    protected virtual IReadOnlyDictionary`2<char, char> LookupMarkupExtensionBracketCharacters();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ProxyDirectUIXamlType : DirectUIXamlType {
    private TypeProxyMetadata _metadata;
    public ProxyDirectUIXamlType(TypeProxyMetadata metadata, DirectUISchemaContext schemaContext);
    protected virtual XamlMember LookupAliasedProperty(XamlDirective directive);
    protected virtual IList`1<XamlType> LookupAllowedContentTypes();
    protected virtual XamlType LookupBaseType();
    protected virtual XamlCollectionKind LookupCollectionKind();
    protected virtual bool LookupConstructionRequiresArguments();
    protected virtual XamlMember LookupContentProperty();
    protected virtual IList`1<XamlType> LookupContentWrappers();
    protected virtual XamlValueConverter`1<XamlDeferringLoader> LookupDeferringLoader();
    protected virtual bool LookupIsConstructible();
    protected virtual XamlTypeInvoker LookupInvoker();
    protected virtual bool LookupIsMarkupExtension();
    protected virtual bool LookupIsNameScope();
    protected virtual bool LookupIsNullable();
    protected virtual bool LookupIsUnknown();
    protected virtual bool LookupIsWhitespaceSignificantCollection();
    protected virtual XamlType LookupKeyType();
    protected virtual XamlType LookupItemType();
    protected virtual XamlType LookupMarkupExtensionReturnType();
    protected virtual IEnumerable`1<XamlMember> LookupAllAttachableMembers();
    protected virtual IEnumerable`1<XamlMember> LookupAllMembers();
    protected virtual XamlMember LookupMember(string name, bool skipReadOnlyCheck);
    protected virtual XamlMember LookupAttachableMember(string name);
    protected virtual IList`1<XamlType> LookupPositionalParameters(int parameterCount);
    protected virtual Type LookupUnderlyingType();
    protected virtual bool LookupIsPublic();
    protected virtual bool LookupIsXData();
    protected virtual bool LookupIsAmbient();
    protected virtual XamlValueConverter`1<TypeConverter> LookupTypeConverter();
    protected virtual XamlValueConverter`1<ValueSerializer> LookupValueSerializer();
    private Type GetProxyType(string typeName);
}
public class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ProxyTypes.BindExtension : MarkupExtension {
    public BindExtension(string path);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
public class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ProxyTypes.CustomResourceExtension : MarkupExtension {
    [CompilerGeneratedAttribute]
private object <ResourceKey>k__BackingField;
    public object ResourceKey { get; public set; }
    public CustomResourceExtension(object resourceKey);
    [CompilerGeneratedAttribute]
public object get_ResourceKey();
    [CompilerGeneratedAttribute]
public void set_ResourceKey(object value);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
public abstract class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ProxyTypes.MarkupExtension : object {
    public abstract virtual object ProvideValue(IServiceProvider serviceProvider);
}
public class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ProxyTypes.NullExtension : MarkupExtension {
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
public class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ProxyTypes.Properties : object {
}
public class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ProxyTypes.Property : object {
}
public class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ProxyTypes.StaticResourceExtension : MarkupExtension {
    [CompilerGeneratedAttribute]
private object <ResourceKey>k__BackingField;
    public object ResourceKey { get; public set; }
    public StaticResourceExtension(object resourceKey);
    [CompilerGeneratedAttribute]
public object get_ResourceKey();
    [CompilerGeneratedAttribute]
public void set_ResourceKey(object value);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
public class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ProxyTypes.TemplateBindingExtension : MarkupExtension {
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
public class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ProxyTypes.ThemeResourceExtension : MarkupExtension {
    [CompilerGeneratedAttribute]
private object <ResourceKey>k__BackingField;
    public object ResourceKey { get; public set; }
    public ThemeResourceExtension(object resourceKey);
    [CompilerGeneratedAttribute]
public object get_ResourceKey();
    [CompilerGeneratedAttribute]
public void set_ResourceKey(object value);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ReflectionHelper : object {
    private static ConcurrentDictionary`2<string, IList`1<CustomAttributeData>> _typeAttrs;
    private static ReflectionHelper();
    internal static void Release();
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ReflectionHelper/<GetCustomAttributeData>d__2")]
internal static IEnumerable`1<CustomAttributeData> GetCustomAttributeData(Type type, bool inherit, string attributeTypeFullName);
    internal static CustomAttributeData FindAttributeByTypeName(Type type, bool inherit, string attributeTypeFullName);
    internal static CustomAttributeData FindAttributeByTypeName(MethodInfo mi, string attributeTypeFullName);
    internal static CustomAttributeData FindAttributeByTypeName(PropertyInfo pi, string attributeTypeFullName);
    internal static CustomAttributeData FindAttributeByShortTypeName(MemberInfo memberInfo, string attributeTypeShortName);
    internal static IList`1<CustomAttributeData> GetCustomAttributeData(MethodInfo mi);
    internal static IList`1<CustomAttributeData> GetCustomAttributeData(PropertyInfo pi);
    internal static IList`1<CustomAttributeData> GetCustomAttributeData(MemberInfo memberInfo);
    internal static IList`1<CustomAttributeData> GetCustomAttributeData(Type type);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.DirectUI.ReflectionHelper/<GetCustomAttributeData>d__11")]
internal static IEnumerable`1<CustomAttributeData> GetCustomAttributeData(Type type, bool inherit);
    internal static CustomAttributeData FindAttributeByTypeName(IEnumerable`1<CustomAttributeData> attrData, string attributeTypeFullName);
    internal static CustomAttributeData FindAttributeByShortTypeName(IEnumerable`1<CustomAttributeData> attrData, string attributeTypeShortName);
    internal static object GetAttributeConstructorArgument(CustomAttributeData customAttr, int idx, string name);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.TypeProxyMetadata : object {
    public string Name;
    public XamlCollectionKind CollectionKind;
    public bool ConstructionRequiresArguments;
    public string UnderlyingTypeName;
    public string BaseTypeName;
    public bool IsConstructible;
    public bool IsMarkupExtension;
    public bool IsNameScope;
    public bool IsNullable;
    public bool IsUnknown;
    public bool IsWhitespaceSignificantCollection;
    public bool IsPublic;
    public bool IsXData;
    public bool IsAmbient;
    public Dictionary`2<string, XamlTypeName> MemberNamesAndMetadata;
    public static TypeProxyMetadata TemplateBindingExtension;
    public static TypeProxyMetadata StaticResourceExtension;
    public static TypeProxyMetadata ThemeResourceExtension;
    public static TypeProxyMetadata NullExtension;
    public static TypeProxyMetadata CustomResourceExtension;
    public static TypeProxyMetadata BindExtension;
    public static TypeProxyMetadata Properties;
    public static TypeProxyMetadata Property;
    private static TypeProxyMetadata();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.DirectUI.TypeResolver : object {
    private HashSet`1<string> knownAssemblies;
    private Dictionary`2<string, string> fullNameToAsmQName;
    private Dictionary`2<string, string> directUiToAsmQName;
    private XamlTypeUniverse typeUniverse;
    public bool IsInitialized { get; }
    public TypeResolver(XamlTypeUniverse typeUniverse);
    public bool get_IsInitialized();
    public void InitializeTypeNameMap();
    public void AddLocalAssemblyToTypeNameMap(Assembly localAssembly);
    public Type GetTypeByFullName(string fullName);
    public Type GetDirectUIType(string name);
    private void AddClrAssemblies(IEnumerable`1<Assembly> clrAssemblies);
    private void AddWinmdAssemblies(IEnumerable`1<Assembly> winmdAssemblies);
    private void AddWinmdAssembly(Assembly winmdAsm, bool isLocalAssembly);
    private bool IsDirectUIType(string fullName, String& name);
    private void GetSortedReferenceAssemblies(List`1& clrAssemblies, List`1& winmdAssemblies);
    private Type ResolveTypeByReflectionFromAssemblyQualifiedName(string assemblyQualifiedTypeName);
    private Type GetTypeFromUniverse(string name);
    private static bool IsClrImplementationOfWinRTType(Type type);
}
internal enum Microsoft.UI.Xaml.Markup.Compiler.ErrorCode : Enum {
    public int value__;
    public static ErrorCode WMC0001;
    public static ErrorCode WMC0003;
    public static ErrorCode WMC0005;
    public static ErrorCode WMC0010;
    public static ErrorCode WMC0011;
    public static ErrorCode WMC0015;
    public static ErrorCode WMC0020;
    public static ErrorCode WMC0021;
    public static ErrorCode WMC0025;
    public static ErrorCode WMC0026;
    public static ErrorCode WMC0027;
    public static ErrorCode WMC0030;
    public static ErrorCode WMC0035;
    public static ErrorCode WMC0040;
    public static ErrorCode WMC0045;
    public static ErrorCode WMC0046;
    public static ErrorCode WMC0047;
    public static ErrorCode WMC0050;
    public static ErrorCode WMC0055;
    public static ErrorCode WMC0056;
    public static ErrorCode WMC0060;
    public static ErrorCode WMC0065;
    public static ErrorCode WMC0070;
    public static ErrorCode WMC0075;
    public static ErrorCode WMC0080;
    public static ErrorCode WMC0085;
    public static ErrorCode WMC0086;
    public static ErrorCode WMC0090;
    public static ErrorCode WMC0091;
    public static ErrorCode WMC0095;
    public static ErrorCode WMC0100;
    public static ErrorCode WMC0105;
    public static ErrorCode WMC0110;
    public static ErrorCode WMC0115;
    public static ErrorCode WMC0120;
    public static ErrorCode WMC0121;
    public static ErrorCode WMC0125;
    public static ErrorCode WMC0130;
    public static ErrorCode WMC0131;
    public static ErrorCode WMC0132;
    public static ErrorCode WMC0140;
    public static ErrorCode WMC0141;
    public static ErrorCode WMC0142;
    public static ErrorCode WMC0145;
    public static ErrorCode WMC0150;
    public static ErrorCode WMC0153;
    public static ErrorCode WMC0154;
    public static ErrorCode WMC0155;
    public static ErrorCode WMC0500;
    public static ErrorCode WMC0501;
    public static ErrorCode WMC0502;
    public static ErrorCode WMC0503;
    public static ErrorCode WMC0504;
    public static ErrorCode WMC0505;
    public static ErrorCode WMC0600;
    public static ErrorCode WMC0601;
    public static ErrorCode WMC0605;
    public static ErrorCode WMC0610;
    public static ErrorCode WMC0612;
    public static ErrorCode WMC0615;
    public static ErrorCode WMC0620;
    public static ErrorCode WMC0621;
    public static ErrorCode WMC0800;
    public static ErrorCode WMC0805;
    public static ErrorCode WMC0806;
    public static ErrorCode WMC0810;
    public static ErrorCode WMC0815;
    public static ErrorCode WMC0820;
    public static ErrorCode WMC0821;
    public static ErrorCode WMC0822;
    public static ErrorCode WMC0901;
    public static ErrorCode WMC0902;
    public static ErrorCode WMC0903;
    public static ErrorCode WMC0905;
    public static ErrorCode WMC0906;
    public static ErrorCode WMC0907;
    public static ErrorCode WMC0908;
    public static ErrorCode WMC0909;
    public static ErrorCode WMC0910;
    public static ErrorCode WMC0911;
    public static ErrorCode WMC0912;
    public static ErrorCode WMC0913;
    public static ErrorCode WMC0914;
    public static ErrorCode WMC0915;
    public static ErrorCode WMC0916;
    public static ErrorCode WMC0917;
    public static ErrorCode WMC0918;
    public static ErrorCode WMC0919;
    public static ErrorCode WMC1002;
    public static ErrorCode WMC1003;
    public static ErrorCode WMC1005;
    public static ErrorCode WMC1006;
    public static ErrorCode WMC1007;
    public static ErrorCode WMC1008;
    public static ErrorCode WMC1009;
    public static ErrorCode WMC1010;
    public static ErrorCode WMC1011;
    public static ErrorCode WMC1012;
    public static ErrorCode WMC1013;
    public static ErrorCode WMC1110;
    public static ErrorCode WMC1111;
    public static ErrorCode WMC1112;
    public static ErrorCode WMC1113;
    public static ErrorCode WMC1114;
    public static ErrorCode WMC1115;
    public static ErrorCode WMC1116;
    public static ErrorCode WMC1117;
    public static ErrorCode WMC1118;
    public static ErrorCode WMC1119;
    public static ErrorCode WMC1120;
    public static ErrorCode WMC1121;
    public static ErrorCode WMC1122;
    public static ErrorCode WMC1123;
    public static ErrorCode WMC1124;
    public static ErrorCode WMC1125;
    public static ErrorCode WMC0151;
    public static ErrorCode WMC0152;
    public static ErrorCode WMC1001;
    public static ErrorCode WMC1004;
    public static ErrorCode WMC1014;
    public static ErrorCode WMC1500;
    public static ErrorCode WMC1501;
    public static ErrorCode WMC1502;
    public static ErrorCode WMC1503;
    public static ErrorCode WMC1504;
    public static ErrorCode WMC1505;
    public static ErrorCode WMC1506;
    public static ErrorCode WMC1507;
    public static ErrorCode WMC1508;
    public static ErrorCode WMC1509;
    public static ErrorCode WMC9997;
    public static ErrorCode WMC9998;
    public static ErrorCode WMC9999;
}
[ExtensionAttribute]
internal static class Microsoft.UI.Xaml.Markup.Compiler.ErrorCodeExtension : object {
    [ExtensionAttribute]
public static string AsErrorCode(ErrorCode code);
    [ExtensionAttribute]
public static string AsErrorCode(int code);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CastCannotStartWithAttachedProperty { get; }
    internal static string ExpectingDigit { get; }
    internal static string ExpectingMethod { get; }
    internal static string ExpectingStaticFunction { get; }
    internal static string ExpectingStaticProperty { get; }
    internal static string FunctionAsParameter { get; }
    internal static string FunctionNotLeaf { get; }
    internal static string InvalidCast { get; }
    internal static string InvalidParameter { get; }
    internal static string MissmatchedParameterCount { get; }
    internal static string MultipleNamespaceConditionalStatements { get; }
    internal static string MultipleTargetPlatforms { get; }
    internal static string NoMatchingOverload { get; }
    internal static string PropertyNotFound { get; }
    internal static string PropertyWithoutGet { get; }
    internal static string SyntaxError { get; }
    internal static string TypeNotFound { get; }
    internal static string UnbindableMemberConflict { get; }
    internal static string UnexpectedArrayIndexer { get; }
    internal static string UnmatchedApiInformationParameters { get; }
    internal static string UnrecognizedApiInformation { get; }
    internal static string UnsuportedOutParameter { get; }
    internal static string UsingNamedElement { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CastCannotStartWithAttachedProperty();
    internal static string get_ExpectingDigit();
    internal static string get_ExpectingMethod();
    internal static string get_ExpectingStaticFunction();
    internal static string get_ExpectingStaticProperty();
    internal static string get_FunctionAsParameter();
    internal static string get_FunctionNotLeaf();
    internal static string get_InvalidCast();
    internal static string get_InvalidParameter();
    internal static string get_MissmatchedParameterCount();
    internal static string get_MultipleNamespaceConditionalStatements();
    internal static string get_MultipleTargetPlatforms();
    internal static string get_NoMatchingOverload();
    internal static string get_PropertyNotFound();
    internal static string get_PropertyWithoutGet();
    internal static string get_SyntaxError();
    internal static string get_TypeNotFound();
    internal static string get_UnbindableMemberConflict();
    internal static string get_UnexpectedArrayIndexer();
    internal static string get_UnmatchedApiInformationParameters();
    internal static string get_UnrecognizedApiInformation();
    internal static string get_UnsuportedOutParameter();
    internal static string get_UsingNamedElement();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.ErrorXPropertyUsageNotSupported : XamlCompileError {
    public ErrorXPropertyUsageNotSupported(XamlDomObject domObject, Language language);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.EventAssignment : object {
    private IEnumerable`1<Parameter> parameters;
    [CompilerGeneratedAttribute]
private ApiInformation <ApiInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeForCodeGen <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeForCodeGen <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HandlerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventParamsForCppSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectUIXamlMember <Event>k__BackingField;
    [CompilerGeneratedAttribute]
private LineNumberInfo <LineNumberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    public ApiInformation ApiInformation { get; }
    public TypeForCodeGen EventType { get; public set; }
    public TypeForCodeGen DeclaringType { get; public set; }
    public string HandlerName { get; public set; }
    public string EventParamsForCppSignature { get; public set; }
    public DirectUIXamlMember Event { get; public set; }
    public LineNumberInfo LineNumberInfo { get; public set; }
    public string EventName { get; public set; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public EventAssignment(XamlDomMember domMember);
    [CompilerGeneratedAttribute]
public ApiInformation get_ApiInformation();
    [CompilerGeneratedAttribute]
public TypeForCodeGen get_EventType();
    [CompilerGeneratedAttribute]
public void set_EventType(TypeForCodeGen value);
    [CompilerGeneratedAttribute]
public TypeForCodeGen get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(TypeForCodeGen value);
    [CompilerGeneratedAttribute]
public string get_HandlerName();
    [CompilerGeneratedAttribute]
public void set_HandlerName(string value);
    [CompilerGeneratedAttribute]
public string get_EventParamsForCppSignature();
    [CompilerGeneratedAttribute]
public void set_EventParamsForCppSignature(string value);
    [CompilerGeneratedAttribute]
public DirectUIXamlMember get_Event();
    [CompilerGeneratedAttribute]
public void set_Event(DirectUIXamlMember value);
    [CompilerGeneratedAttribute]
public sealed virtual LineNumberInfo get_LineNumberInfo();
    [CompilerGeneratedAttribute]
public void set_LineNumberInfo(LineNumberInfo value);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public void set_EventName(string value);
    internal string LookupEventParamsForCppSignature();
    public sealed virtual XamlCompileError GetAttributeProcessingError();
    public IEnumerable`1<Parameter> get_Parameters();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.ExperimentalFeatures : object {
    private static string RegistryKey_ExperimentalFeatures;
    private static int GetIntValue(string key, int defaultValue);
    private static object GetValue(string keyName);
}
[FlagsAttribute]
internal enum Microsoft.UI.Xaml.Markup.Compiler.FeatureCtrlFlags : Enum {
    public int value__;
    public static FeatureCtrlFlags Nothing;
    public static FeatureCtrlFlags EnableTypeInfoReflection;
    public static FeatureCtrlFlags EnableXBindDiagnostics;
    public static FeatureCtrlFlags EnableDefaultValidationContextGeneration;
    public static FeatureCtrlFlags EnableWin32Codegen;
    public static FeatureCtrlFlags UsingCSWinRT;
}
internal class Microsoft.UI.Xaml.Markup.Compiler.FieldDefinition : object {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldTypePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldTypeShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeForCodeGen <FieldType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecated>k__BackingField;
    public LanguageSpecificString _fieldModifier;
    private XamlType _xamlType;
    public string FieldName { get; public set; }
    public string FieldTypePath { get; private set; }
    public string FieldTypeShortName { get; private set; }
    public string FieldTypeName { get; }
    public XamlType FieldXamlType { get; }
    public TypeForCodeGen FieldType { get; public set; }
    public bool IsValueType { get; private set; }
    public bool IsDeprecated { get; private set; }
    public LanguageSpecificString FieldModifier { get; public set; }
    private IDirectUIXamlLanguage DirectUIXamlLanguage { get; }
    public FieldDefinition(XamlDomObject namedObject);
    public FieldDefinition(XamlDomObject namedObject, string clrPath);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public string get_FieldTypePath();
    [CompilerGeneratedAttribute]
private void set_FieldTypePath(string value);
    [CompilerGeneratedAttribute]
public string get_FieldTypeShortName();
    [CompilerGeneratedAttribute]
private void set_FieldTypeShortName(string value);
    public string get_FieldTypeName();
    public XamlType get_FieldXamlType();
    [CompilerGeneratedAttribute]
public TypeForCodeGen get_FieldType();
    [CompilerGeneratedAttribute]
public void set_FieldType(TypeForCodeGen value);
    [CompilerGeneratedAttribute]
public bool get_IsValueType();
    [CompilerGeneratedAttribute]
private void set_IsValueType(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDeprecated();
    [CompilerGeneratedAttribute]
private void set_IsDeprecated(bool value);
    private void InitFromType(DirectUIXamlType xamlType);
    public LanguageSpecificString get_FieldModifier();
    public void set_FieldModifier(LanguageSpecificString value);
    public bool HasSameAttributes(FieldDefinition that);
    public bool CanBeMerged(FieldDefinition that);
    public static FieldDefinition CreateMerged(FieldDefinition a, FieldDefinition b);
    private IDirectUIXamlLanguage get_DirectUIXamlLanguage();
    private static XamlType FindCommonBaseClass(XamlType a, XamlType b);
}
public class Microsoft.UI.Xaml.Markup.Compiler.FieldStep : PropertyStep {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    public string FieldName { get; }
    public string UniqueName { get; }
    public FieldStep(string name, XamlType valueType, BindPathStep parent, ApiInformation apiInformation);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    public virtual string get_UniqueName();
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.FileIO.IXamlStream {
    public StreamType StreamType { get; }
    public abstract virtual StreamType get_StreamType();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.FileIO.StreamImpl : object {
    private bool disposedValue;
    protected Stream _underlyingStream;
    public void Close();
    public sealed virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public sealed virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public sealed virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public sealed virtual void SetSize(long libNewSize);
    public sealed virtual void Dispose();
    public sealed virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public sealed virtual void Clone(IStream& ppstm);
    public sealed virtual void Commit(int grfCommitFlags);
    public sealed virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public sealed virtual void Revert();
    public sealed virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public sealed virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    protected virtual void Dispose(bool disposing);
}
internal enum Microsoft.UI.Xaml.Markup.Compiler.FileIO.StreamType : Enum {
    public int value__;
    public static StreamType Input;
    public static StreamType Output;
}
internal class Microsoft.UI.Xaml.Markup.Compiler.FileIO.StreamXamlInput : StreamImpl {
    public StreamType StreamType { get; }
    public StreamXamlInput(string filePath);
    public sealed virtual StreamType get_StreamType();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.FileIO.StreamXbfOutput : StreamImpl {
    private string _filePath;
    private MemoryStream _memoryStream;
    public StreamType StreamType { get; }
    public StreamXbfOutput(string filePath);
    private bool ContentChanged();
    protected virtual void Dispose(bool disposing);
    public sealed virtual StreamType get_StreamType();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.FileNameAndChecksumPair : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Checksum>k__BackingField;
    public string FileName { get; private set; }
    public string Checksum { get; private set; }
    public FileNameAndChecksumPair(string fileName, string contents);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
public string get_Checksum();
    [CompilerGeneratedAttribute]
private void set_Checksum(string value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.FileNameAndContentPair : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Contents>k__BackingField;
    public string FileName { get; private set; }
    public string Contents { get; private set; }
    public FileNameAndContentPair(string fileName, string contents);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
public string get_Contents();
    [CompilerGeneratedAttribute]
private void set_Contents(string value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.FingerPrinter : object {
    private static bool s_VcMetaIsLoaded;
    private String[] _ignorePathsList;
    private string _localAssemblyPath;
    private String[] _nonSystemReferenceAssemblies;
    private bool _useVcMetaManaged;
    public string LocalAssemblyPath { get; }
    public String[] ReferenceAssemblyPaths { get; }
    public String[] IgnorePathsList { get; private set; }
    public FingerPrinter(IAssemblyItem localAssembly, IEnumerable`1<IAssemblyItem> referenceAssemblies, String[] ignorePaths, string vcInstallDir, string vcInstallPath32, string vcInstallPath64, bool useVCMetaManaged);
    public string get_LocalAssemblyPath();
    public void SetLocalAssembly(IAssemblyItem localAssembly);
    public String[] get_ReferenceAssemblyPaths();
    public void SetReferenceAssemblies(IEnumerable`1<IAssemblyItem> referenceAssemblies, String[] ignoreList);
    public String[] get_IgnorePathsList();
    private void set_IgnorePathsList(String[] value);
    public bool HasAssemblyFileListChanged(HashSet`1<string> asmFileNames);
    public bool HasLocalAssemblyHashChanged(Dictionary`2<string, Guid> dictionaryOfGuidHashs);
    public bool HaveReferenceAssembliesHashesChanged(Dictionary`2<string, Guid> dictionaryOfGuidHashs);
    private string ToLowerFullFilePath(string filename);
    private bool HasAssemblyChanged(string asmPath, Dictionary`2<string, Guid> dictionaryOfGuidHashs);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.FixedSourceInfo : object {
    public SourcePos StartOpeningTag;
    public SourcePos StartClosingTag;
    public SourcePos EndOpeningTag;
    public SourcePos EndClosingTag;
    public bool SelfClosing;
    public string UnprocessedType;
}
internal class Microsoft.UI.Xaml.Markup.Compiler.ForwardDeclaringNamespace : object {
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ShortNameTypes>k__BackingField;
    public string Namespace { get; private set; }
    public List`1<string> ShortNameTypes { get; private set; }
    public ForwardDeclaringNamespace(string typePath, List`1<string> typeNames);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
private void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ShortNameTypes();
    [CompilerGeneratedAttribute]
private void set_ShortNameTypes(List`1<string> value);
}
public class Microsoft.UI.Xaml.Markup.Compiler.FunctionBoolParam : FunctionParam {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public string UniqueName { get; }
    public FunctionBoolParam(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    protected virtual void ValidateParameter(Parameter paramInfo);
    public virtual string get_UniqueName();
}
public class Microsoft.UI.Xaml.Markup.Compiler.FunctionNullValueParam : FunctionParam {
    public string UniqueName { get; }
    protected virtual void ValidateParameter(Parameter paramInfo);
    public virtual string get_UniqueName();
}
public class Microsoft.UI.Xaml.Markup.Compiler.FunctionNumberParam : FunctionParam {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public string UniqueName { get; }
    public FunctionNumberParam(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    protected virtual void ValidateParameter(Parameter paramInfo);
    public virtual string get_UniqueName();
}
public abstract class Microsoft.UI.Xaml.Markup.Compiler.FunctionParam : Parameter {
    [CompilerGeneratedAttribute]
private XamlType <ValueType>k__BackingField;
    public XamlType ValueType { get; private set; }
    public string UniqueName { get; }
    public bool HasTryGetValue { get; }
    public string TryGetValueCodeName { get; }
    public string CodeName { get; }
    public XamlType AssignmentType { get; }
    [CompilerGeneratedAttribute]
public XamlType get_ValueType();
    [CompilerGeneratedAttribute]
private void set_ValueType(XamlType value);
    public abstract virtual string get_UniqueName();
    protected abstract virtual void ValidateParameter(Parameter paramInfo);
    public void SetParameterInfo(Parameter paramInfo, XamlType valueType);
    public virtual bool get_HasTryGetValue();
    public virtual string get_TryGetValueCodeName();
    public virtual string get_CodeName();
    public virtual XamlType get_AssignmentType();
}
public class Microsoft.UI.Xaml.Markup.Compiler.FunctionPathParam : FunctionParam {
    [CompilerGeneratedAttribute]
private BindPathStep <Path>k__BackingField;
    public BindPathStep Path { get; }
    public string UniqueName { get; }
    public string CodeName { get; }
    public bool HasTryGetValue { get; }
    public string TryGetValueCodeName { get; }
    public XamlType AssignmentType { get; }
    public FunctionPathParam(BindPathStep value);
    [CompilerGeneratedAttribute]
public BindPathStep get_Path();
    protected virtual void ValidateParameter(Parameter paramInfo);
    public virtual string get_UniqueName();
    public virtual string get_CodeName();
    public virtual bool get_HasTryGetValue();
    public virtual string get_TryGetValueCodeName();
    public virtual XamlType get_AssignmentType();
}
public class Microsoft.UI.Xaml.Markup.Compiler.FunctionStep : BindPathStep {
    private string paramsHashCode;
    [CompilerGeneratedAttribute]
private List`1<FunctionParam> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodStep <Method>k__BackingField;
    public List`1<FunctionParam> Parameters { get; }
    public MethodStep Method { get; }
    public string UniqueName { get; }
    public bool RequiresSafeParameterRetrieval { get; }
    public bool ValueTypeIsConditional { get; }
    public bool IsValueRequired { get; }
    public FunctionStep(MethodStep method, ApiInformation apiInformation);
    public FunctionStep(MethodStep method, IEnumerable`1<FunctionParam> parameters, ApiInformation apiInformation);
    [CompilerGeneratedAttribute]
public List`1<FunctionParam> get_Parameters();
    [CompilerGeneratedAttribute]
public MethodStep get_Method();
    public virtual string get_UniqueName();
    public bool get_RequiresSafeParameterRetrieval();
    public virtual bool get_ValueTypeIsConditional();
    public virtual bool get_IsValueRequired();
}
public class Microsoft.UI.Xaml.Markup.Compiler.FunctionStringParam : FunctionParam {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public string UniqueName { get; }
    public FunctionStringParam(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    protected virtual void ValidateParameter(Parameter paramInfo);
    public virtual string get_UniqueName();
}
public interface Microsoft.UI.Xaml.Markup.Compiler.IBindAssignment {
    public BindStatus BindStatus { get; }
    public int ComputedPhase { get; }
    public bool HasSetValueHelper { get; }
    public bool IsTrackingSource { get; }
    public bool IsTrackingTarget { get; }
    public abstract virtual BindStatus get_BindStatus();
    public abstract virtual int get_ComputedPhase();
    public abstract virtual bool get_HasSetValueHelper();
    public abstract virtual bool get_IsTrackingSource();
    public abstract virtual bool get_IsTrackingTarget();
}
public interface Microsoft.UI.Xaml.Markup.Compiler.IBindUniverse {
    public BindPathStep RootStep { get; }
    public abstract virtual BindPathStep get_RootStep();
    public abstract virtual BindPathStep EnsureUniquePathStep(BindPathStep step);
    public abstract virtual XamlType GetNamedElementType(string name, String& objectCodeName);
    public abstract virtual XamlType GetNamedFieldType(string name);
    public abstract virtual BindPathStep MakeOrGetRootStepOutOfScope();
}
public interface Microsoft.UI.Xaml.Markup.Compiler.ICodeGenerator {
    public abstract virtual void SetModel(object model);
}
public interface Microsoft.UI.Xaml.Markup.Compiler.ICodeGenOutput {
    public CodeGenDelegate CppCXName { get; }
    public CodeGenDelegate CppWinRTName { get; }
    public CodeGenDelegate CSharpName { get; }
    public CodeGenDelegate VBName { get; }
    public abstract virtual CodeGenDelegate get_CppCXName();
    public abstract virtual CodeGenDelegate get_CppWinRTName();
    public abstract virtual CodeGenDelegate get_CSharpName();
    public abstract virtual CodeGenDelegate get_VBName();
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.ILineNumberAndErrorInfo {
    public LineNumberInfo LineNumberInfo { get; }
    public abstract virtual LineNumberInfo get_LineNumberInfo();
    public abstract virtual XamlCompileError GetAttributeProcessingError();
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.ILog {
    public abstract virtual void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message);
    public abstract virtual void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message);
    public abstract virtual void LogDiagnosticMessage(string message);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.InternalErrorException : Exception {
    internal InternalErrorException(string message);
    internal InternalErrorException(string message, bool showAssert);
    internal InternalErrorException(string message, Exception innerException);
    private InternalErrorException(SerializationInfo info, StreamingContext context);
    private void ShowAssertDialog(bool showAssert);
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.IXamlClassCodeInfo {
    public string BaseFileName { get; }
    public XamlType BaseType { get; public set; }
    public string BaseTypeName { get; public set; }
    public BindStatus BindStatus { get; }
    public List`1<BindUniverse> BindUniverses { get; }
    public ClassName ClassName { get; }
    public TypeForCodeGen ClassType { get; public set; }
    public XamlType ClassXamlType { get; public set; }
    public IEnumerable`1<FieldDefinition> FieldDeclarations { get; }
    public bool HasEventAssignments { get; }
    public bool HasFieldDefinitions { get; }
    public bool IsApplication { get; }
    public bool IsResourceDictionary { get; }
    public List`1<XamlFileCodeInfo> PerXamlFileInfo { get; }
    public string PriIndexName { get; public set; }
    public string RootNamespace { get; public set; }
    public string TargetFolder { get; public set; }
    public abstract virtual string get_BaseFileName();
    public abstract virtual XamlType get_BaseType();
    public abstract virtual void set_BaseType(XamlType value);
    public abstract virtual string get_BaseTypeName();
    public abstract virtual void set_BaseTypeName(string value);
    public abstract virtual BindStatus get_BindStatus();
    public abstract virtual List`1<BindUniverse> get_BindUniverses();
    public abstract virtual ClassName get_ClassName();
    public abstract virtual TypeForCodeGen get_ClassType();
    public abstract virtual void set_ClassType(TypeForCodeGen value);
    public abstract virtual XamlType get_ClassXamlType();
    public abstract virtual void set_ClassXamlType(XamlType value);
    public abstract virtual IEnumerable`1<FieldDefinition> get_FieldDeclarations();
    public abstract virtual bool get_HasEventAssignments();
    public abstract virtual bool get_HasFieldDefinitions();
    public abstract virtual bool get_IsApplication();
    public abstract virtual bool get_IsResourceDictionary();
    public abstract virtual List`1<XamlFileCodeInfo> get_PerXamlFileInfo();
    public abstract virtual string get_PriIndexName();
    public abstract virtual void set_PriIndexName(string value);
    public abstract virtual string get_RootNamespace();
    public abstract virtual void set_RootNamespace(string value);
    public abstract virtual string get_TargetFolder();
    public abstract virtual void set_TargetFolder(string value);
    public abstract virtual void AddXamlFileInfo(XamlFileCodeInfo fileCodeInfo);
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.IXamlFileCodeInfo {
    public string ApparentRelativePath { get; public set; }
    public BindStatus BindStatus { get; public set; }
    public List`1<ConnectionIdElement> ConnectionIdElements { get; }
    public string FullPathToXamlFile { get; public set; }
    public bool HasEventAssignments { get; public set; }
    public string RelativePathFromGeneratedCodeToXamlFile { get; public set; }
    public string SourceXamlGivenPath { get; public set; }
    public List`1<DataTypeAssignment> DataTypeAssignments { get; }
    public bool HasPhaseAssignments { get; public set; }
    public List`1<StrippableMember> StrippableMembers { get; }
    public List`1<StrippableObject> StrippableObjects { get; }
    public List`1<StrippableNamespace> StrippableNamespaces { get; }
    public xPropertyInfo XPropertyInfo { get; public set; }
    public abstract virtual string get_ApparentRelativePath();
    public abstract virtual void set_ApparentRelativePath(string value);
    public abstract virtual BindStatus get_BindStatus();
    public abstract virtual void set_BindStatus(BindStatus value);
    public abstract virtual List`1<ConnectionIdElement> get_ConnectionIdElements();
    public abstract virtual string get_FullPathToXamlFile();
    public abstract virtual void set_FullPathToXamlFile(string value);
    public abstract virtual bool get_HasEventAssignments();
    public abstract virtual void set_HasEventAssignments(bool value);
    public abstract virtual string get_RelativePathFromGeneratedCodeToXamlFile();
    public abstract virtual void set_RelativePathFromGeneratedCodeToXamlFile(string value);
    public abstract virtual string get_SourceXamlGivenPath();
    public abstract virtual void set_SourceXamlGivenPath(string value);
    public abstract virtual List`1<DataTypeAssignment> get_DataTypeAssignments();
    public abstract virtual bool get_HasPhaseAssignments();
    public abstract virtual void set_HasPhaseAssignments(bool value);
    public abstract virtual List`1<StrippableMember> get_StrippableMembers();
    public abstract virtual List`1<StrippableObject> get_StrippableObjects();
    public abstract virtual List`1<StrippableNamespace> get_StrippableNamespaces();
    public abstract virtual xPropertyInfo get_XPropertyInfo();
    public abstract virtual void set_XPropertyInfo(xPropertyInfo value);
}
public interface Microsoft.UI.Xaml.Markup.Compiler.IXamlMemberMeta {
    public bool IsDependencyProperty { get; }
    public abstract virtual bool get_IsDependencyProperty();
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.IXamlTypeMeta {
    public bool ImplementsINotifyPropertyChanged { get; }
    public bool ImplementsINotifyCollectionChanged { get; }
    public bool ImplementsIObservableVector { get; }
    public bool ImplementsIObservableMap { get; }
    public bool ImplementsINotifyDataErrorInfo { get; }
    public bool HasApiInformation { get; }
    public abstract virtual bool get_ImplementsINotifyPropertyChanged();
    public abstract virtual bool get_ImplementsINotifyCollectionChanged();
    public abstract virtual bool get_ImplementsIObservableVector();
    public abstract virtual bool get_ImplementsIObservableMap();
    public abstract virtual bool get_ImplementsINotifyDataErrorInfo();
    public abstract virtual bool get_HasApiInformation();
}
public interface Microsoft.UI.Xaml.Markup.Compiler.IXamlTypeResolver {
    public abstract virtual XamlType ResolveType(Type type);
    public abstract virtual XamlType ResolveXmlName(string name);
    public abstract virtual bool CanAssignDirectlyTo(XamlType source, XamlType destination);
    public abstract virtual bool CanInlineConvert(XamlType source, XamlType destination);
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.KnownMembers : object {
    public static string Property;
    public static string Invoke;
    public static string Append;
    public static string Insert;
    public static string Add;
    public static string Template;
    public static string TargetType;
    public static string Language;
    public static string Name;
    public static string Text;
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.KnownNamespaces : object {
    public static string DirectUI;
    public static string ProxyTypes;
    public static string SystemPrefix;
    public static string WindowsFoundation;
    public static string WindowsFoundationPrefix;
    public static string WindowsFoundationCollections;
    public static string WindowsUI;
    public static string Text;
    public static string Xaml;
    public static string XamlAutomation;
    public static string XamlAutomationPeers;
    public static string XamlAutomationProvider;
    public static string XamlAutomationText;
    public static string XamlControls;
    public static string XamlControlsPrimitives;
    public static string WindowsXamlData;
    public static string XamlData;
    public static string XamlDocuments;
    public static string XamlInput;
    public static string WindowsXamlInterop;
    public static string XamlInterop;
    public static string XamlMarkup;
    public static string XamlMedia;
    public static string XamlMediaAnimation;
    public static string XamlMediaImaging;
    public static string XamlMediaMedia3D;
    public static string XamlNavigation;
    public static string XamlResources;
    public static string XamlShapes;
    public static string XamlThreading;
    public static string XamlXamlTypeInfo;
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.KnownNamespaceUris : object {
    public static string Wpf2006;
    public static string DirectUI2010;
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.KnownStrings : object {
    public static string UriClrNamespace;
    public static string UriAssembly;
    public static string DefaultHeaderExtension;
    public static string GeneratedHppExtension;
    public static string XamlExtension;
    public static string XbfExtension;
    public static string FrameworkTemplate;
    public static string ResourceDictionary;
    public static string Source;
    public static string Library;
    public static string WinMdObj;
    public static string XAMLBuildTaskAsmName;
    public static string BackupSuffix;
    public static string XamlBindingInfo;
    public static string XamlTypeInfo;
    public static string Get;
    public static string Set;
    public static string Debug;
    public static string Converter;
    public static string ConverterLanguage;
    public static string ConverterParameter;
    public static string FallbackValue;
    public static string LostFocus;
    public static string Mode;
    public static string OneTime;
    public static string OneWay;
    public static string TwoWay;
    public static string TargetNullValue;
    public static string BindBack;
    public static string Path;
    public static string UpdateSourceTrigger;
    public static string XColon;
    public static string op_Implicit;
    public static string op_Explicit;
    public static string UpdateParamName;
    public static string UpdateParamBindingsName;
    public static string DataChanged;
    public static string NotPhased;
    public static string DirectCast;
    public static string CType;
    public static string Platforms;
    public static string UAP;
    public static string UsingPrefix;
    public static string ClrNamespaceColon;
    public static string SemiColonAssemblyEquals;
    public static string DeprecatedAttributeDefaultMessage;
    public static string ObsoleteAttributeDefaultMessage;
    public static string PlatformAssemblySentinelType;
    public static string WinUIAssemblySentinelType;
    public static string MsCorLib;
    public static string Colonize(string name);
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.KnownTypes : object {
    public static string RequiredAttribute;
    public static string MulticastDelegate;
    public static string Nullable;
    public static string ObsoleteAttribute;
    public static string Uri;
    public static string IList;
    public static string ICollection;
    public static string IDictionary;
    public static string INotifyPropertyChanged;
    public static string INotifyDataErrorInfo;
    public static string INotifyCollectionChanged;
    public static string IReference;
    public static string IObservableVector;
    public static string IObservableMap;
    public static string IVector;
    public static string IMap;
    public static string ActivatableAttribute;
    public static string CreateFromStringAttribute;
    public static string ContractVersionAttribute;
    public static string DeprecatedAttribute;
    public static string ExperimentalAttribute;
    public static string ThreadingAttribute;
    public static string Application;
    public static string FrameworkElement;
    public static string FrameworkTemplate;
    public static string DataContextChangedEventArgs;
    public static string DataTemplate;
    public static string DependencyObject;
    public static string DependencyProperty;
    public static string IDataTemplateExtension;
    public static string PropertyPath;
    public static string ResourceDictionary;
    public static string Style;
    public static string Setter;
    public static string UIElement;
    public static string Visibility;
    public static string VisibilityColonized;
    public static string WinUIContract;
    public static string Window;
    public static string ContainerContentChangingEventArgs;
    public static string Control;
    public static string ControlTemplate;
    public static string TextBox;
    public static string InputPropertyAttribute;
    public static string IInputValidationControl;
    public static string InputValidationContext;
    public static string InputValidationCommand;
    public static string InputValidationError;
    public static string XamlControlsXamlMetaDataProvider;
    public static string ComponentResourceLocation;
    public static string FlyoutBase;
    public static string XamlINotifyDataErrorInfo;
    public static string XamlINotifyPropertyChanged;
    public static string WindowsBindableAttribute;
    public static string BindableAttribute;
    public static string Binding;
    public static string ICustomPropertyProvider;
    public static string IValueConverter;
    public static string RelativeSource;
    public static string Inline;
    public static string InlineCollection;
    public static string LineBreak;
    public static string XamlINotifyCollectionChanged;
    public static string ContentPropertyAttribute;
    public static string IComponentConnector;
    public static string IDataTemplateComponent;
    public static string IXamlBindScopeDiagnostics;
    public static string IXamlMember;
    public static string IXamlMetadataProvider;
    public static string IXamlType;
    public static string FullXamlMetadataProviderAttribute;
    public static string MarkupExtension;
    public static string XamlBindingHelper;
    public static string XamlBindingHelperColonized;
    public static string XamlMarkupHelper;
    public static string XamlReader;
    public static string XmlnsDefinition;
    private static KnownTypes();
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.KS : object {
    public static bool Eq(string a, string b);
    public static bool EqIgnoreCase(string a, string b);
    public static int IndexOf(string src, string chars);
    public static bool StartsWith(string src, string target);
    public static bool StartsWithIgnoreCase(string src, string target);
    public static bool ContainsString(IList`1<string> list, string s);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Language : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExperimental>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsManaged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNative>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStringNullable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pass1Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pass2Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGeneratorDelegate <AppPass1CodeGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGeneratorDelegate <AppPass2CodeGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGeneratorDelegate <PagePass1CodeGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGeneratorDelegate <PagePass2CodeGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGeneratorDelegate <XamlMetaDataProviderPass1>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGeneratorDelegate <XamlMetaDataProviderPass2>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGeneratorDelegate <TypeInfoPass1CodeGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGeneratorDelegate <TypeInfoPass1ImplCodeGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGeneratorDelegate <TypeInfoPass2CodeGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGeneratorDelegate <BindingInfoPass1CodeGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGeneratorDelegate <BindingInfoPass2CodeGenerator>k__BackingField;
    private static Language[] languages;
    public string Name { get; }
    public bool IsExperimental { get; }
    public bool IsManaged { get; }
    public bool IsNative { get; }
    public bool IsStringNullable { get; }
    public string Pass1Extension { get; }
    public string Pass2Extension { get; }
    public CodeGeneratorDelegate AppPass1CodeGenerator { get; }
    public CodeGeneratorDelegate AppPass2CodeGenerator { get; }
    public CodeGeneratorDelegate PagePass1CodeGenerator { get; }
    public CodeGeneratorDelegate PagePass2CodeGenerator { get; }
    public CodeGeneratorDelegate XamlMetaDataProviderPass1 { get; }
    public CodeGeneratorDelegate XamlMetaDataProviderPass2 { get; }
    public CodeGeneratorDelegate TypeInfoPass1CodeGenerator { get; }
    public CodeGeneratorDelegate TypeInfoPass1ImplCodeGenerator { get; }
    public CodeGeneratorDelegate TypeInfoPass2CodeGenerator { get; }
    public CodeGeneratorDelegate BindingInfoPass1CodeGenerator { get; }
    public CodeGeneratorDelegate BindingInfoPass2CodeGenerator { get; }
    private Language(string name, string pass1Extension, string pass2Extension, bool isManaged, bool isStringNullable, bool isExperimental, CodeGeneratorDelegate appPass1CodeGenerator, CodeGeneratorDelegate appPass2CodeGenerator, CodeGeneratorDelegate pagePass1CodeGenerator, CodeGeneratorDelegate pagePass2CodeGenerator, CodeGeneratorDelegate xamlMetaDataProviderPass1, CodeGeneratorDelegate xamlMetaDataProviderPass2, CodeGeneratorDelegate typeInfoPass1CodeGenerator, CodeGeneratorDelegate typeInfoPass1ImplCodeGenerator, CodeGeneratorDelegate typeInfoPass2CodeGenerator, CodeGeneratorDelegate bindingInfoPass1CodeGenerator, CodeGeneratorDelegate bindingInfoPass2CodeGenerator);
    private static Language();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IsExperimental();
    [CompilerGeneratedAttribute]
public bool get_IsManaged();
    [CompilerGeneratedAttribute]
public bool get_IsNative();
    [CompilerGeneratedAttribute]
public bool get_IsStringNullable();
    [CompilerGeneratedAttribute]
public string get_Pass1Extension();
    [CompilerGeneratedAttribute]
public string get_Pass2Extension();
    [CompilerGeneratedAttribute]
public CodeGeneratorDelegate get_AppPass1CodeGenerator();
    [CompilerGeneratedAttribute]
public CodeGeneratorDelegate get_AppPass2CodeGenerator();
    [CompilerGeneratedAttribute]
public CodeGeneratorDelegate get_PagePass1CodeGenerator();
    [CompilerGeneratedAttribute]
public CodeGeneratorDelegate get_PagePass2CodeGenerator();
    [CompilerGeneratedAttribute]
public CodeGeneratorDelegate get_XamlMetaDataProviderPass1();
    [CompilerGeneratedAttribute]
public CodeGeneratorDelegate get_XamlMetaDataProviderPass2();
    [CompilerGeneratedAttribute]
public CodeGeneratorDelegate get_TypeInfoPass1CodeGenerator();
    [CompilerGeneratedAttribute]
public CodeGeneratorDelegate get_TypeInfoPass1ImplCodeGenerator();
    [CompilerGeneratedAttribute]
public CodeGeneratorDelegate get_TypeInfoPass2CodeGenerator();
    [CompilerGeneratedAttribute]
public CodeGeneratorDelegate get_BindingInfoPass1CodeGenerator();
    [CompilerGeneratedAttribute]
public CodeGeneratorDelegate get_BindingInfoPass2CodeGenerator();
    public static Language Parse(string name);
}
[TypeConverterAttribute("Microsoft.UI.Xaml.Markup.Compiler.LineNumberInfoTypeConverter")]
internal class Microsoft.UI.Xaml.Markup.Compiler.LineNumberInfo : object {
    [CompilerGeneratedAttribute]
private int <StartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLinePosition>k__BackingField;
    public int StartLineNumber { get; public set; }
    public int StartLinePosition { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndLinePosition { get; public set; }
    public LineNumberInfo(IXamlDomNode domNode);
    [CompilerGeneratedAttribute]
public int get_StartLineNumber();
    [CompilerGeneratedAttribute]
public void set_StartLineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_StartLinePosition();
    [CompilerGeneratedAttribute]
public void set_StartLinePosition(int value);
    [CompilerGeneratedAttribute]
public int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_EndLinePosition();
    [CompilerGeneratedAttribute]
public void set_EndLinePosition(int value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.LineNumberInfoTypeConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedAddressMethodInfo : ArrayFabricatedMethodInfo {
    public string Name { get; }
    public Type ReturnType { get; }
    public ArrayFabricatedAddressMethodInfo(Type arrayType);
    public virtual string get_Name();
    public virtual ParameterInfo[] GetParameters();
    public virtual Type get_ReturnType();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedConstructorInfo : MetadataOnlyConstructorInfo {
    private int m_numParams;
    public ArrayFabricatedConstructorInfo(Type arrayType, int numParams);
    private static MethodInfo MakeMethodInfo(Type arrayType, int numParams);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedGetMethodInfo : ArrayFabricatedMethodInfo {
    public string Name { get; }
    public Type ReturnType { get; }
    public ArrayFabricatedGetMethodInfo(Type arrayType);
    public virtual string get_Name();
    public virtual ParameterInfo[] GetParameters();
    public virtual Type get_ReturnType();
}
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedMethodInfo : MethodInfo {
    private Type m_arrayType;
    protected ITypeUniverse Universe { get; }
    protected int Rank { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public ParameterInfo ReturnParameter { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    protected ArrayFabricatedMethodInfo(Type arrayType);
    protected ITypeUniverse get_Universe();
    protected int get_Rank();
    protected Type GetElementType();
    protected ParameterInfo[] MakeParameterHelper(int extra);
    protected ParameterInfo MakeParameterInfo(Type t, int position);
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodInfo MakeGenericMethod(Type[] types);
    public virtual bool get_IsGenericMethodDefinition();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBody GetMethodBody();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedSetMethodInfo : ArrayFabricatedMethodInfo {
    public string Name { get; }
    public Type ReturnType { get; }
    public ArrayFabricatedSetMethodInfo(Type arrayType);
    public virtual string get_Name();
    public virtual ParameterInfo[] GetParameters();
    public virtual Type get_ReturnType();
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyFactory : object {
    public static Assembly CreateAssembly(MetadataOnlyModule manifestModule, string manifestFile);
    public static Assembly CreateAssembly(ITypeUniverse typeUniverse, MetadataFile metadataImport, string manifestFile);
    public static Assembly CreateAssembly(ITypeUniverse typeUniverse, MetadataFile metadataImport, IReflectionFactory factory, string manifestFile);
    public static Assembly CreateAssembly(ITypeUniverse typeUniverse, MetadataFile manifestModuleImport, MetadataFile[] netModuleImports, string manifestFile, String[] netModuleFiles);
    public static Assembly CreateAssembly(ITypeUniverse typeUniverse, MetadataFile manifestModuleImport, MetadataFile[] netModuleImports, IReflectionFactory factory, string manifestFile, String[] netModuleFiles);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyMetaData : ValueType {
    public ushort majorVersion;
    public ushort minorVersion;
    public ushort buildNumber;
    public ushort revisionNumber;
    public UnmanagedStringMemoryHandle szLocale;
    public UInt32 cbLocale;
    public UnusedIntPtr rdwProcessor;
    public UInt32 ulProcessor;
    public UnusedIntPtr rOS;
    public UInt32 ulOS;
    public Version Version { get; }
    public string LocaleString { get; }
    public CultureInfo Locale { get; }
    public void Init();
    public Version get_Version();
    public string get_LocaleString();
    public CultureInfo get_Locale();
    public sealed virtual void Dispose();
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyNameHelper : object {
    private static int ProcessorArchitectureMask;
    private static int ReferenceAssembly;
    private static InstanceCache`2<Tuple`3<Token, MetadataFile, IMetadataAssemblyImport>, AssemblyName> _assemblyNameCache;
    private static AssemblyNameHelper();
    public static AssemblyName GetAssemblyName(MetadataOnlyModule module);
    public static bool HasV1Metadata(MetadataOnlyModule module);
    public static AssemblyName GetAssemblyNameFromRef(Token assemblyRefToken, MetadataOnlyModule module, IMetadataAssemblyImport assemblyImport);
    private static ProcessorArchitecture CalculateProcArchIndex(PortableExecutableKinds pek, ImageFileMachine ifm, AssemblyNameFlags flags);
}
[DebuggerDisplayAttribute("AssemblyRef: {m_name}")]
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyRef : AssemblyProxy {
    private AssemblyName m_name;
    public AssemblyRef(AssemblyName name, ITypeUniverse universe);
    protected virtual Assembly GetResolvedAssemblyWorker();
    protected virtual AssemblyName GetNameWithNoResolution();
    public virtual AssemblyName GetName();
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Lmr.CommonIdeHelper : object {
    public static AssemblyName GetNameFromPath(string path);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.ConstructorInfoRef : ConstructorInfoProxy {
    private Type m_declaringType;
    private Token m_token;
    private MetadataOnlyModule m_scope;
    public Type DeclaringType { get; }
    public ConstructorInfoRef(Type declaringType, MetadataOnlyModule scope, Token token);
    protected virtual ConstructorInfo GetResolvedWorker();
    public virtual Type get_DeclaringType();
    public ParameterInfo[] GetSignatureParameters();
}
internal enum Microsoft.UI.Xaml.Markup.Compiler.Lmr.CorCallingConvention : Enum {
    public int value__;
    public static CorCallingConvention Default;
    public static CorCallingConvention VarArg;
    public static CorCallingConvention Field;
    public static CorCallingConvention LocalSig;
    public static CorCallingConvention Property;
    public static CorCallingConvention Unmanaged;
    public static CorCallingConvention GenericInst;
    public static CorCallingConvention NativeVarArg;
    public static CorCallingConvention Mask;
    public static CorCallingConvention HasThis;
    public static CorCallingConvention ExplicitThis;
    public static CorCallingConvention Generic;
}
[FlagsAttribute]
internal enum Microsoft.UI.Xaml.Markup.Compiler.Lmr.CorFileFlags : Enum {
    public int value__;
    public static CorFileFlags ContainsMetaData;
    public static CorFileFlags ContainsNoMetaData;
}
[FlagsAttribute]
internal enum Microsoft.UI.Xaml.Markup.Compiler.Lmr.CorManifestResourceFlags : Enum {
    public int value__;
    public static CorManifestResourceFlags mrVisibilityMask;
    public static CorManifestResourceFlags mrPublic;
    public static CorManifestResourceFlags mrPrivate;
}
[FlagsAttribute]
internal enum Microsoft.UI.Xaml.Markup.Compiler.Lmr.CorTypeAttr : Enum {
    public int value__;
    public static CorTypeAttr tdVisibilityMask;
    public static CorTypeAttr tdNotPublic;
    public static CorTypeAttr tdPublic;
    public static CorTypeAttr tdNestedPublic;
    public static CorTypeAttr tdNestedPrivate;
    public static CorTypeAttr tdNestedFamily;
    public static CorTypeAttr tdNestedAssembly;
    public static CorTypeAttr tdNestedFamANDAssem;
    public static CorTypeAttr tdNestedFamORAssem;
    public static CorTypeAttr tdLayoutMask;
    public static CorTypeAttr tdAutoLayout;
    public static CorTypeAttr tdSequentialLayout;
    public static CorTypeAttr tdExplicitLayout;
    public static CorTypeAttr tdClassSemanticsMask;
    public static CorTypeAttr tdClass;
    public static CorTypeAttr tdInterface;
    public static CorTypeAttr tdAbstract;
    public static CorTypeAttr tdSealed;
    public static CorTypeAttr tdSpecialName;
    public static CorTypeAttr tdImport;
    public static CorTypeAttr tdSerializable;
    public static CorTypeAttr tdStringFormatMask;
    public static CorTypeAttr tdAnsiClass;
    public static CorTypeAttr tdUnicodeClass;
    public static CorTypeAttr tdAutoClass;
    public static CorTypeAttr tdCustomFormatClass;
    public static CorTypeAttr tdCustomFormatMask;
    public static CorTypeAttr tdBeforeFieldInit;
    public static CorTypeAttr tdForwarder;
    public static CorTypeAttr tdReservedMask;
    public static CorTypeAttr tdRTSpecialName;
    public static CorTypeAttr tdHasSecurity;
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.CustomModifiers : object {
    private List`1<Type> m_optional;
    private List`1<Type> m_required;
    public Type[] OptionalCustomModifiers { get; }
    public Type[] RequiredCustomModifiers { get; }
    public CustomModifiers(List`1<Type> optModifiers, List`1<Type> reqModifiers);
    public Type[] get_OptionalCustomModifiers();
    public Type[] get_RequiredCustomModifiers();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.DefaultFactory : object {
    public virtual MetadataOnlyCommonType CreateSimpleType(MetadataOnlyModule scope, Token tokenTypeDef);
    public virtual MetadataOnlyCommonType CreateGenericType(MetadataOnlyModule scope, Token tokenTypeDef, Type[] typeArgs);
    public virtual MetadataOnlyCommonType CreateArrayType(MetadataOnlyCommonType elementType, int rank);
    public virtual MetadataOnlyCommonType CreateVectorType(MetadataOnlyCommonType elementType);
    public virtual MetadataOnlyCommonType CreateByRefType(MetadataOnlyCommonType type);
    public virtual MetadataOnlyCommonType CreatePointerType(MetadataOnlyCommonType type);
    public virtual MetadataOnlyTypeVariable CreateTypeVariable(MetadataOnlyModule resolver, Token typeVariableToken);
    public virtual MetadataOnlyFieldInfo CreateField(MetadataOnlyModule resolver, Token fieldDefToken, Type[] typeArgs, Type[] methodArgs);
    public virtual MetadataOnlyPropertyInfo CreatePropertyInfo(MetadataOnlyModule resolver, Token propToken, Type[] typeArgs, Type[] methodArgs);
    public virtual MetadataOnlyEventInfo CreateEventInfo(MetadataOnlyModule resolver, Token eventToken, Type[] typeArgs, Type[] methodArgs);
    public virtual MetadataOnlyConstructorInfo CreateConstructorInfo(MethodBase method);
    public virtual MetadataOnlyMethodInfo CreateMethodInfo(MetadataOnlyMethodInfo method);
    public virtual MethodBase CreateMethodOrConstructor(MetadataOnlyModule resolver, Token methodDef, Type[] typeArgs, Type[] methodArgs);
    private static bool IsRawConstructor(MethodInfo m);
    public virtual bool TryCreateMethodBody(MetadataOnlyMethodInfo method, MethodBody& body);
    public virtual Type CreateTypeRef(MetadataOnlyModule scope, Token tokenTypeRef);
    public virtual Type CreateSignatureTypeRef(MetadataOnlyModule scope, Token tokenTypeRef, CorElementType elemType);
    public virtual Type CreateTypeSpec(MetadataOnlyModule scope, Token tokenTypeSpec, Type[] typeArgs, Type[] methodArgs);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.DefaultUniverse : SimpleUniverse {
    private Loader m_loader;
    public Loader Loader { get; }
    public virtual Module ResolveModule(Assembly containingAssembly, string moduleName);
    public Loader get_Loader();
    internal Assembly LoadAssemblyFromFile(string manifestFileName, String[] netModuleFileNames);
    internal Assembly LoadAssemblyFromFile(string manifestFileName);
    internal MetadataOnlyModule LoadModuleFromFile(string netModulePath);
    internal Assembly LoadAssemblyFromByteArray(Byte[] data);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext : object {
    [CompilerGeneratedAttribute]
private Type[] <TypeArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <MethodArgs>k__BackingField;
    public Type[] TypeArgs { get; protected set; }
    public Type[] MethodArgs { get; protected set; }
    public GenericContext(Type[] typeArgs, Type[] methodArgs);
    public GenericContext(MethodBase methodTypeContext);
    [CompilerGeneratedAttribute]
public Type[] get_TypeArgs();
    [CompilerGeneratedAttribute]
protected void set_TypeArgs(Type[] value);
    [CompilerGeneratedAttribute]
public Type[] get_MethodArgs();
    [CompilerGeneratedAttribute]
protected void set_MethodArgs(Type[] value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual GenericContext VerifyAndUpdateMethodArguments(int expectedNumberOfMethodArgs);
    private static int GetArrayHashCode(T[] a);
    private static bool IsArrayEqual(T[] a1, T[] a2);
    private static string ArrayToString(T[] a);
    public virtual string ToString();
    public GenericContext DeleteMethodArgs();
    public static bool IsNullOrEmptyMethodArgs(GenericContext context);
    public static bool IsNullOrEmptyTypeArgs(GenericContext context);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.HCORENUM : ValueType {
    private IntPtr hEnum;
    public void Close(IMetadataImport import);
    public void Close(IMetadataImport2 import);
    public void Close(IMetadataAssemblyImport import);
}
[GuidAttribute("EE62470B-E94B-424e-9B7C-2F00C9249F93")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataAssemblyImport {
    public abstract virtual void GetAssemblyProps(Token assemblyToken, EmbeddedBlobPointer& pPublicKey, Int32& cbPublicKey, Int32& hashAlgId, StringBuilder szName, int cchName, Int32& pchName, AssemblyMetaData& pMetaData, AssemblyNameFlags& flags);
    public abstract virtual void GetAssemblyRefProps(Token token, EmbeddedBlobPointer& pPublicKey, Int32& cbPublicKey, StringBuilder szName, int cchName, Int32& pchName, AssemblyMetaData& pMetaData, UnusedIntPtr& ppbHashValue, UInt32& pcbHashValue, AssemblyNameFlags& dwAssemblyRefFlags);
    public abstract virtual void GetFileProps(int token, StringBuilder szName, int cchName, Int32& pchName, UnusedIntPtr& ppbHashValue, UInt32& pcbHashValue, CorFileFlags& dwFileFlags);
    public abstract virtual void GetExportedTypeProps(int mdct, StringBuilder szName, int cchName, Int32& pchName, Int32& ptkImplementation, Int32& ptkTypeDef, CorTypeAttr& pdwExportedTypeFlags);
    public abstract virtual void GetManifestResourceProps(int mdmr, StringBuilder szName, int cchName, Int32& pchName, Int32& ptkImplementation, UInt32& pdwOffset, CorManifestResourceFlags& pdwResourceFlags);
    public abstract virtual int EnumAssemblyRefs(HCORENUM& phEnum, Token& assemblyRefs, int cMax, Int32& cTokens);
    public abstract virtual void EnumFiles(HCORENUM& phEnum, Int32& files, int cMax, Int32& cTokens);
    public abstract virtual void EnumExportedTypes(HCORENUM& phEnum, Int32& rExportedTypes, int cMax, UInt32& cTokens);
    public abstract virtual void EnumManifestResources(HCORENUM& phEnum, Int32& rManifestResources, int cMax, Int32& cTokens);
    public abstract virtual int GetAssemblyFromScope(Int32& assemblyToken);
    public abstract virtual void FindExportedTypeByName_();
    public abstract virtual int FindManifestResourceByName(string szName, Int32& ptkManifestResource);
    public abstract virtual int CloseEnum(IntPtr hEnum);
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataExtensionsPolicy {
    public abstract virtual Type[] GetExtraArrayInterfaces(Type elementType);
    public abstract virtual MethodInfo[] GetExtraArrayMethods(Type arrayType);
    public abstract virtual ConstructorInfo[] GetExtraArrayConstructors(Type arrayType);
    public abstract virtual ParameterInfo GetFakeParameterInfo(MemberInfo member, Type paramType, int position);
    public abstract virtual IEnumerable`1<CustomAttributeData> GetPseudoCustomAttributes(MetadataOnlyModule module, Token token);
    public abstract virtual Type TryTypeForwardResolution(MetadataOnlyAssembly assembly, string fullname, bool ignoreCase);
}
[GuidAttribute("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataImport {
    public abstract virtual void CloseEnum(IntPtr hEnum);
    public abstract virtual void CountEnum(HCORENUM hEnum, Int32& pulCount);
    public abstract virtual void ResetEnum(HCORENUM hEnum, int ulPos);
    public abstract virtual void EnumTypeDefs(HCORENUM& phEnum, Int32& rTypeDefs, UInt32 cMax, UInt32& pcTypeDefs);
    public abstract virtual void EnumInterfaceImpls(HCORENUM& phEnum, int td, Int32& rImpls, int cMax, Int32& pcImpls);
    public abstract virtual void EnumTypeRefs_();
    public abstract virtual int FindTypeDefByName(string szTypeDef, int tkEnclosingClass, Int32& token);
    public abstract virtual void GetScopeProps(StringBuilder szName, int cchName, Int32& pchName, Guid& mvid);
    public abstract virtual void GetModuleFromScope(Int32& mdModule);
    public abstract virtual void GetTypeDefProps(int td, StringBuilder szTypeDef, int cchTypeDef, Int32& pchTypeDef, TypeAttributes& pdwTypeDefFlags, Int32& ptkExtends);
    public abstract virtual void GetInterfaceImplProps(int iiImpl, Int32& pClass, Int32& ptkIface);
    public abstract virtual void GetTypeRefProps(int tr, Int32& ptkResolutionScope, StringBuilder szName, int cchName, Int32& pchName);
    public abstract virtual void ResolveTypeRef_();
    public abstract virtual void EnumMembers_();
    public abstract virtual void EnumMembersWithName_();
    public abstract virtual void EnumMethods(HCORENUM& phEnum, int cl, Int32& mdMethodDef, int cMax, Int32& pcTokens);
    public abstract virtual void EnumMethodsWithName(HCORENUM& phEnum, int cl, string szName, Int32& mdMethodDef, int cMax, Int32& pcTokens);
    public abstract virtual void EnumFields(HCORENUM& phEnum, int cl, Int32& mdFieldDef, int cMax, UInt32& pcTokens);
    public abstract virtual void EnumFieldsWithName_();
    public abstract virtual int EnumParams(HCORENUM& phEnum, int mdMethodDef, Int32[] rParams, int cMax, UInt32& pcTokens);
    public abstract virtual void EnumMemberRefs_();
    public abstract virtual void EnumMethodImpls(HCORENUM& hEnum, Token typeDef, Token& methodBody, Token& methodDecl, int cMax, Int32& cTokens);
    public abstract virtual void EnumPermissionSets_();
    public abstract virtual void FindMember(int typeDefToken, string szName, Byte[] pvSigBlob, int cbSigBlob, Int32& memberDefToken);
    public abstract virtual void FindMethod(int typeDef, string szName, EmbeddedBlobPointer pvSigBlob, int cbSigBlob, Int32& methodDef);
    public abstract virtual void FindField(int typeDef, string szName, Byte[] pvSigBlob, int cbSigBlob, Int32& fieldDef);
    public abstract virtual void FindMemberRef(int typeRef, string szName, Byte[] pvSigBlob, int cbSigBlob, Int32& result);
    public abstract virtual void GetMethodProps(UInt32 md, Int32& pClass, StringBuilder szMethod, int cchMethod, UInt32& pchMethod, MethodAttributes& pdwAttr, EmbeddedBlobPointer& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags);
    public abstract virtual void GetMemberRefProps(Token mr, Token& ptk, StringBuilder szMember, int cchMember, UInt32& pchMember, EmbeddedBlobPointer& ppvSigBlob, UInt32& pbSig);
    public abstract virtual void EnumProperties(HCORENUM& phEnum, int td, Int32& mdFieldDef, int cMax, UInt32& pcTokens);
    public abstract virtual void EnumEvents(HCORENUM& phEnum, int td, Int32& mdFieldDef, int cMax, UInt32& pcEvents);
    public abstract virtual void GetEventProps(int ev, Int32& pClass, StringBuilder szEvent, int cchEvent, Int32& pchEvent, Int32& pdwEventFlags, Int32& ptkEventType, Int32& pmdAddOn, Int32& pmdRemoveOn, Int32& pmdFire, Int32& rmdOtherMethod, UInt32 cMax, UInt32& pcOtherMethod);
    public abstract virtual void EnumMethodSemantics_();
    public abstract virtual void GetMethodSemantics_();
    public abstract virtual UInt32 GetClassLayout(int typeDef, UInt32& dwPackSize, UnusedIntPtr zeroPtr, UInt32 zeroCount, UnusedIntPtr zeroPtr2, UInt32& ulClassSize);
    public abstract virtual void GetFieldMarshal(int token, EmbeddedBlobPointer& pNativeType, Int32& cbNativeType);
    public abstract virtual void GetRVA(int token, UInt32& rva, UInt32& flags);
    public abstract virtual void GetPermissionSetProps_();
    public abstract virtual void GetSigFromToken(int token, EmbeddedBlobPointer& pSig, Int32& cbSig);
    public abstract virtual void GetModuleRefProps(int mur, StringBuilder szName, int cchName, Int32& pchName);
    public abstract virtual void EnumModuleRefs(HCORENUM& phEnum, Int32& mdModuleRef, int cMax, UInt32& pcModuleRefs);
    public abstract virtual int GetTypeSpecFromToken(Token typeSpec, EmbeddedBlobPointer& pSig, Int32& cbSig);
    public abstract virtual void GetNameFromToken_();
    public abstract virtual void EnumUnresolvedMethods_();
    public abstract virtual void GetUserString(int stk, Char[] szString, int cchString, Int32& pchString);
    public abstract virtual void GetPinvokeMap_();
    public abstract virtual void EnumSignatures(HCORENUM& hEnum, Int32& rSignature, UInt32 cMax, UInt32& pcSignatures);
    public abstract virtual void EnumTypeSpecs_();
    public abstract virtual void EnumUserStrings_();
    public abstract virtual void GetParamForMethodIndex_();
    public abstract virtual void EnumCustomAttributes(HCORENUM& phEnum, int tk, int tkType, Token& mdCustomAttribute, UInt32 cMax, UInt32& pcTokens);
    public abstract virtual void GetCustomAttributeProps(Token cv, Token& tkObj, Token& tkType, EmbeddedBlobPointer& blob, Int32& cbSize);
    public abstract virtual void FindTypeRef(int tkResolutionScope, string szName, Int32& typeRef);
    public abstract virtual void GetMemberProps_();
    public abstract virtual void GetFieldProps(int mb, Int32& mdTypeDef, StringBuilder szField, int cchField, Int32& pchField, FieldAttributes& pdwAttr, EmbeddedBlobPointer& ppvSigBlob, Int32& pcbSigBlob, Int32& pdwCPlusTypeFlab, IntPtr& ppValue, Int32& pcchValue);
    public abstract virtual void GetPropertyProps(Token prop, Token& pClass, StringBuilder szProperty, int cchProperty, Int32& pchProperty, PropertyAttributes& pdwPropFlags, EmbeddedBlobPointer& ppvSig, Int32& pbSig, Int32& pdwCPlusTypeFlag, UnusedIntPtr& ppDefaultValue, Int32& pcchDefaultValue, Token& pmdSetter, Token& pmdGetter, Token& rmdOtherMethod, UInt32 cMax, UInt32& pcOtherMethod);
    public abstract virtual void GetParamProps(int tk, Int32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, UnusedIntPtr& ppValue, UInt32& pcchValue);
    public abstract virtual int GetCustomAttributeByName(int tkObj, string szName, EmbeddedBlobPointer& ppData, UInt32& pcbData);
    public abstract virtual bool IsValidToken(UInt32 tk);
    public abstract virtual int GetNestedClassProps(int tdNestedClass, Int32& tdEnclosingClass);
    public abstract virtual void GetNativeCallConvFromSig_();
    public abstract virtual void IsGlobal_();
}
[GuidAttribute("FCE5EFA0-8BBA-4f8e-A036-8F2022B08466")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataImport2 {
    public abstract virtual void CloseEnum(IntPtr hEnum);
    public abstract virtual void CountEnum(HCORENUM hEnum, Int32& pulCount);
    public abstract virtual void ResetEnum(HCORENUM hEnum, int ulPos);
    public abstract virtual void EnumTypeDefs(HCORENUM& phEnum, Int32& rTypeDefs, UInt32 cMax, UInt32& pcTypeDefs);
    public abstract virtual void EnumInterfaceImpls(HCORENUM& phEnum, int td, Int32& rImpls, int cMax, Int32& pcImpls);
    public abstract virtual void EnumTypeRefs_();
    public abstract virtual void FindTypeDefByName(string szTypeDef, int tkEnclosingClass, Int32& token);
    public abstract virtual void GetScopeProps(StringBuilder szName, int cchName, Int32& pchName, Guid& mvid);
    public abstract virtual void GetModuleFromScope(Int32& mdModule);
    public abstract virtual void GetTypeDefProps(int td, StringBuilder szTypeDef, int cchTypeDef, Int32& pchTypeDef, TypeAttributes& pdwTypeDefFlags, Int32& ptkExtends);
    public abstract virtual void GetInterfaceImplProps(int iiImpl, Int32& pClass, Int32& ptkIface);
    public abstract virtual void GetTypeRefProps(int tr, Int32& ptkResolutionScope, StringBuilder szName, int cchName, Int32& pchName);
    public abstract virtual void ResolveTypeRef_();
    public abstract virtual void EnumMembers_();
    public abstract virtual void EnumMembersWithName_();
    public abstract virtual void EnumMethods(HCORENUM& phEnum, int cl, Int32& mdMethodDef, int cMax, Int32& pcTokens);
    public abstract virtual void EnumMethodsWithName(HCORENUM& phEnum, int cl, string szName, Int32& mdMethodDef, int cMax, Int32& pcTokens);
    public abstract virtual void EnumFields(HCORENUM& phEnum, int cl, Int32& mdFieldDef, int cMax, UInt32& pcTokens);
    public abstract virtual void EnumFieldsWithName_();
    public abstract virtual int EnumParams(HCORENUM& phEnum, int mdMethodDef, Int32[] rParams, int cMax, UInt32& pcTokens);
    public abstract virtual void EnumMemberRefs_();
    public abstract virtual void EnumMethodImpls(HCORENUM& hEnum, Token typeDef, Token& methodBody, Token& methodDecl, int cMax, Int32& cTokens);
    public abstract virtual void EnumPermissionSets_();
    public abstract virtual void FindMember(int typeDefToken, string szName, Byte[] pvSigBlob, int cbSigBlob, Int32& memberDefToken);
    public abstract virtual void FindMethod(int typeDef, string szName, EmbeddedBlobPointer pvSigBlob, int cbSigBlob, Int32& methodDef);
    public abstract virtual void FindField(int typeDef, string szName, Byte[] pvSigBlob, int cbSigBlob, Int32& fieldDef);
    public abstract virtual void FindMemberRef(int typeRef, string szName, Byte[] pvSigBlob, int cbSigBlob, Int32& result);
    public abstract virtual void GetMethodProps(UInt32 md, Int32& pClass, StringBuilder szMethod, int cchMethod, UInt32& pchMethod, MethodAttributes& pdwAttr, EmbeddedBlobPointer& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags);
    public abstract virtual void GetMemberRefProps(Token mr, Token& ptk, StringBuilder szMember, int cchMember, UInt32& pchMember, EmbeddedBlobPointer& ppvSigBlob, UInt32& pbSig);
    public abstract virtual void EnumProperties(HCORENUM& phEnum, int td, Int32& mdFieldDef, int cMax, UInt32& pcTokens);
    public abstract virtual void EnumEvents(HCORENUM& phEnum, int td, Int32& mdFieldDef, int cMax, UInt32& pcEvents);
    public abstract virtual void GetEventProps(int ev, Int32& pClass, StringBuilder szEvent, int cchEvent, Int32& pchEvent, Int32& pdwEventFlags, Int32& ptkEventType, Int32& pmdAddOn, Int32& pmdRemoveOn, Int32& pmdFire, Int32& rmdOtherMethod, UInt32 cMax, UInt32& pcOtherMethod);
    public abstract virtual void EnumMethodSemantics_();
    public abstract virtual void GetMethodSemantics_();
    public abstract virtual UInt32 GetClassLayout(int typeDef, UInt32& dwPackSize, UnusedIntPtr zeroPtr, UInt32 zeroCount, UnusedIntPtr zeroPtr2, UInt32& ulClassSize);
    public abstract virtual void GetFieldMarshal(int token, EmbeddedBlobPointer& pNativeType, Int32& cbNativeType);
    public abstract virtual void GetRVA(int token, UInt32& rva, UInt32& flags);
    public abstract virtual void GetPermissionSetProps_();
    public abstract virtual void GetSigFromToken(int token, EmbeddedBlobPointer& pSig, Int32& cbSig);
    public abstract virtual void GetModuleRefProps(int mur, StringBuilder szName, int cchName, Int32& pchName);
    public abstract virtual void EnumModuleRefs(HCORENUM& phEnum, Int32& mdModuleRef, int cMax, UInt32& pcModuleRefs);
    public abstract virtual int GetTypeSpecFromToken(Token typeSpec, EmbeddedBlobPointer& pSig, Int32& cbSig);
    public abstract virtual void GetNameFromToken_();
    public abstract virtual void EnumUnresolvedMethods_();
    public abstract virtual void GetUserString(int stk, Char[] szString, int cchString, Int32& pchString);
    public abstract virtual void GetPinvokeMap_();
    public abstract virtual void EnumSignatures(HCORENUM& hEnum, Int32& rSignature, UInt32 cMax, UInt32& pcSignatures);
    public abstract virtual void EnumTypeSpecs_();
    public abstract virtual void EnumUserStrings_();
    public abstract virtual void GetParamForMethodIndex_();
    public abstract virtual void EnumCustomAttributes(HCORENUM& phEnum, int tk, int tkType, Token& mdCustomAttribute, UInt32 cMax, UInt32& pcTokens);
    public abstract virtual void GetCustomAttributeProps(Token cv, Token& tkObj, Token& tkType, EmbeddedBlobPointer& blob, Int32& cbSize);
    public abstract virtual void FindTypeRef(int tkResolutionScope, string szName, Int32& typeRef);
    public abstract virtual void GetMemberProps_();
    public abstract virtual void GetFieldProps(int mb, Int32& mdTypeDef, StringBuilder szField, int cchField, Int32& pchField, FieldAttributes& pdwAttr, EmbeddedBlobPointer& ppvSigBlob, Int32& pcbSigBlob, Int32& pdwCPlusTypeFlab, IntPtr& ppValue, Int32& pcchValue);
    public abstract virtual void GetPropertyProps(Token prop, Token& pClass, StringBuilder szProperty, int cchProperty, Int32& pchProperty, PropertyAttributes& pdwPropFlags, EmbeddedBlobPointer& ppvSig, Int32& pbSig, Int32& pdwCPlusTypeFlag, UnusedIntPtr& ppDefaultValue, Int32& pcchDefaultValue, Token& pmdSetter, Token& pmdGetter, Token& rmdOtherMethod, UInt32 cMax, UInt32& pcOtherMethod);
    public abstract virtual void GetParamProps(int tk, Int32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, UnusedIntPtr& ppValue, UInt32& pcchValue);
    public abstract virtual int GetCustomAttributeByName(int tkObj, string szName, EmbeddedBlobPointer& ppData, UInt32& pcbData);
    public abstract virtual bool IsValidToken(UInt32 tk);
    public abstract virtual void GetNestedClassProps(int tdNestedClass, Int32& tdEnclosingClass);
    public abstract virtual void GetNativeCallConvFromSig_();
    public abstract virtual void IsGlobal_();
    public abstract virtual void EnumGenericParams(HCORENUM& hEnum, int tk, Int32& rGenericParams, UInt32 cMax, UInt32& pcGenericParams);
    public abstract virtual void GetGenericParamProps(int gp, UInt32& pulParamSeq, Int32& pdwParamFlags, Int32& ptOwner, Int32& ptkKind, StringBuilder wzName, UInt32 cchName, UInt32& pchName);
    public abstract virtual void GetMethodSpecProps(Token mi, Token& tkParent, EmbeddedBlobPointer& ppvSigBlob, Int32& pcbSigBlob);
    public abstract virtual void EnumGenericParamConstraints(HCORENUM& hEnum, int tk, Int32& rGenericParamConstraints, UInt32 cMax, UInt32& pcGenericParams);
    public abstract virtual void GetGenericParamConstraintProps(int gpc, Int32& ptGenericParam, Int32& ptkConstraintType);
    public abstract virtual void GetPEKind(PortableExecutableKinds& dwPEKind, ImageFileMachine& pdwMachine);
    public abstract virtual void GetVersionString(StringBuilder szName, int cchName, Int32& pchName);
    public abstract virtual void EnumMethodSpecs(HCORENUM& hEnum, int tk, Int32& rMethodSpec, UInt32 cMax, UInt32& pcMethodSpecs);
}
[GuidAttribute("D8F579AB-402D-4b8e-82D9-5D63B1065C68")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataTables {
    public abstract virtual void GetStringHeapSize(UInt32& countBytesStrings);
    public abstract virtual void GetBlobHeapSize(UInt32& countBytesBlobs);
    public abstract virtual void GetGuidHeapSize(UInt32& countBytesGuids);
    public abstract virtual void GetUserStringHeapSize(UInt32& countByteBlobs);
    public abstract virtual void GetNumTables(UInt32& countTables);
    public abstract virtual void GetTableIndex(UInt32 token, UInt32& tableIndex);
    public abstract virtual void GetTableInfo(MetadataTable tableIndex, Int32& countByteRows, Int32& countRows, Int32& countColumns, Int32& columnPrimaryKey, UnusedIntPtr& name);
    public abstract virtual void GetColumnInfo_();
    public abstract virtual void GetCodedTokenInfo_();
    public abstract virtual void GetRow_();
    public abstract virtual void GetColumn_();
    public abstract virtual void GetString_();
    public abstract virtual void GetBlob_();
    public abstract virtual void GetGuid_();
    public abstract virtual void GetUserString_();
    public abstract virtual void GetNextString_();
    public abstract virtual void GetNextBlob_();
    public abstract virtual void GetNextGuid_();
    public abstract virtual void GetNextUserString_();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.Internal.Debug : object {
    private static int MessageBoxA(int h, string m, string c, int type);
    private static MessageBoxResult MessageBox(string message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool f);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool f, string message);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message);
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.Lmr.IReflectionFactory {
    public abstract virtual MetadataOnlyCommonType CreateSimpleType(MetadataOnlyModule scope, Token tokenTypeDef);
    public abstract virtual MetadataOnlyCommonType CreateGenericType(MetadataOnlyModule scope, Token tokenTypeDef, Type[] typeArgs);
    public abstract virtual MetadataOnlyCommonType CreateArrayType(MetadataOnlyCommonType elementType, int rank);
    public abstract virtual MetadataOnlyCommonType CreateVectorType(MetadataOnlyCommonType elementType);
    public abstract virtual MetadataOnlyCommonType CreateByRefType(MetadataOnlyCommonType type);
    public abstract virtual MetadataOnlyCommonType CreatePointerType(MetadataOnlyCommonType type);
    public abstract virtual MetadataOnlyTypeVariable CreateTypeVariable(MetadataOnlyModule resolver, Token typeVariableToken);
    public abstract virtual MetadataOnlyFieldInfo CreateField(MetadataOnlyModule resolver, Token fieldDefToken, Type[] typeArgs, Type[] methodArgs);
    public abstract virtual MetadataOnlyPropertyInfo CreatePropertyInfo(MetadataOnlyModule resolver, Token propToken, Type[] typeArgs, Type[] methodArgs);
    public abstract virtual MetadataOnlyEventInfo CreateEventInfo(MetadataOnlyModule resolver, Token eventToken, Type[] typeArgs, Type[] methodArgs);
    public abstract virtual MethodBase CreateMethodOrConstructor(MetadataOnlyModule resolver, Token methodToken, Type[] typeArgs, Type[] methodArgs);
    public abstract virtual bool TryCreateMethodBody(MetadataOnlyMethodInfo method, MethodBody& body);
    public abstract virtual Type CreateTypeRef(MetadataOnlyModule scope, Token tokenTypeRef);
    public abstract virtual Type CreateSignatureTypeRef(MetadataOnlyModule scope, Token tokenTypeRef, CorElementType elementType);
    public abstract virtual Type CreateTypeSpec(MetadataOnlyModule scope, Token tokenTypeRef, Type[] typeArgs, Type[] methodArgs);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.Loader : object {
    private IMutableTypeUniverse m_universe;
    private MetadataDispenser m_dispenser;
    private IReflectionFactory m_factory;
    public CorOpenFlags OpenFlags { get; public set; }
    public IReflectionFactory Factory { get; public set; }
    public Loader(IMutableTypeUniverse universe);
    public CorOpenFlags get_OpenFlags();
    public void set_OpenFlags(CorOpenFlags value);
    public IReflectionFactory get_Factory();
    public void set_Factory(IReflectionFactory value);
    private MetadataFile OpenMetadataFile(string filename);
    public Assembly LoadAssemblyFromFile(string file);
    public Assembly ReadAssemblyFromFile(string file);
    public Assembly LoadAssemblyFromFile(string manifestFile, String[] netModuleFiles);
    public Assembly LoadAssemblyFromByteArray(Byte[] data);
    public MetadataOnlyModule LoadModuleFromFile(string moduleFileName);
    public Module ResolveModule(Assembly containingAssembly, string moduleName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataExtensionsPolicy20 : object {
    protected ITypeUniverse m_universe;
    public MetadataExtensionsPolicy20(ITypeUniverse u);
    public virtual Type[] GetExtraArrayInterfaces(Type elementType);
    public virtual MethodInfo[] GetExtraArrayMethods(Type arrayType);
    public virtual ConstructorInfo[] GetExtraArrayConstructors(Type arrayType);
    public virtual ParameterInfo GetFakeParameterInfo(MemberInfo member, Type paramType, int position);
    public virtual IEnumerable`1<CustomAttributeData> GetPseudoCustomAttributes(MetadataOnlyModule module, Token token);
    public virtual Type TryTypeForwardResolution(MetadataOnlyAssembly assembly, string fullname, bool ignoreCase);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyArrayType : MetadataOnlyCommonArrayType {
    private int m_rank;
    public string FullName { get; }
    public string Name { get; }
    public MetadataOnlyArrayType(MetadataOnlyCommonType elementType, int rank);
    public virtual string get_FullName();
    private static string GetDimensionString(int rank);
    public virtual int GetArrayRank();
    public virtual bool Equals(Type t);
    public virtual bool IsAssignableFrom(Type c);
    public virtual string get_Name();
    public virtual string ToString();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly : Assembly {
    private Module[] m_modules;
    private MetadataOnlyModule m_manifestModule;
    private string m_manifestFile;
    private AssemblyName m_name;
    private string _assemblyFullName;
    private Dictionary`2<string, Type> _typeCache;
    private IList`1<CustomAttributeData> _customAttributeDataCache;
    public string FullName { get; }
    public string Location { get; }
    public bool ReflectionOnly { get; }
    public Module ManifestModule { get; }
    internal MetadataOnlyModule ManifestModuleInternal { get; }
    public string CodeBase { get; }
    public MethodInfo EntryPoint { get; }
    public string ImageRuntimeVersion { get; }
    public ITypeUniverse TypeUniverse { get; }
    internal MetadataOnlyAssembly(MetadataOnlyModule manifestModule, string manifestFile);
    internal MetadataOnlyAssembly(MetadataOnlyModule[] modules, string manifestFile);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static void VerifyModules(MetadataOnlyModule[] modules);
    private static List`1<string> GetFileNamesFromFilesTable(MetadataOnlyModule manifestModule, bool getResources);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual String[] GetManifestResourceNames();
    public virtual AssemblyName GetName();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual string get_FullName();
    public virtual string get_Location();
    public virtual bool get_ReflectionOnly();
    public virtual Type[] GetExportedTypes();
    public virtual Type GetType(string name);
    public virtual Type GetType(string name, bool throwOnError);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Type[] GetTypes();
    public virtual Module GetModule(string name);
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual Module get_ManifestModule();
    internal MetadataOnlyModule get_ManifestModuleInternal();
    public virtual string get_CodeBase();
    internal static string GetCodeBaseFromManifestModule(MetadataOnlyModule manifestModule);
    public virtual MethodInfo get_EntryPoint();
    public virtual string get_ImageRuntimeVersion();
    internal static Token GetAssemblyToken(MetadataOnlyModule module);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual FileStream GetFile(string name);
    private static FileStream[] ConvertFileNamesToStreams(String[] filenames);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual AssemblyName[] GetReferencedAssemblies();
    public sealed virtual ITypeUniverse get_TypeUniverse();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonArrayType : MetadataOnlyCommonType {
    private MetadataOnlyCommonType m_elementType;
    private Type m_baseType;
    public string Namespace { get; }
    internal MetadataOnlyModule Resolver { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public int MetadataToken { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Assembly Assembly { get; }
    public Guid GUID { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public string FullName { get; }
    public string Name { get; }
    public MetadataOnlyCommonArrayType(MetadataOnlyCommonType elementType);
    public virtual string get_Namespace();
    internal virtual MetadataOnlyModule get_Resolver();
    public virtual Type get_BaseType();
    protected virtual bool IsArrayImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Type GetElementType();
    public virtual int GetHashCode();
    public virtual int get_MetadataToken();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    internal virtual IEnumerable`1<MethodBase> GetDeclaredMethods();
    internal virtual IEnumerable`1<MethodBase> GetDeclaredConstructors();
    public virtual FieldInfo[] GetFields(BindingFlags flags);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags flags);
    public virtual EventInfo GetEvent(string name, BindingFlags flags);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type[] GetInterfaces();
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type MakeGenericType(Type[] argTypes);
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Assembly get_Assembly();
    public virtual Guid get_GUID();
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    protected virtual TypeCode GetTypeCodeImpl();
    public virtual string get_FullName();
    public virtual string get_Name();
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool Equals(Type o);
}
[DebuggerDisplayAttribute("\{Name = {Name} FullName = {FullName}\}")]
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType : Type {
    private Dictionary`2<BindingFlags, MemberInfo[]> _membersCache;
    internal MetadataOnlyModule Resolver { get; }
    internal GenericContext GenericContext { get; }
    public Module Module { get; }
    public bool ContainsGenericParameters { get; }
    public string AssemblyQualifiedName { get; }
    public bool IsSerializable { get; }
    public Type ReflectedType { get; }
    public bool IsEnum { get; }
    public bool IsGenericType { get; }
    public bool IsGenericParameter { get; }
    public MethodBase DeclaringMethod { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    internal abstract virtual MetadataOnlyModule get_Resolver();
    internal virtual GenericContext get_GenericContext();
    internal virtual IEnumerable`1<MethodBase> GetDeclaredMethods();
    internal virtual IEnumerable`1<MethodBase> GetDeclaredConstructors();
    internal virtual IEnumerable`1<PropertyInfo> GetDeclaredProperties();
    public virtual PropertyInfo[] GetProperties(BindingFlags flags);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags flags);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Module get_Module();
    public virtual bool Equals(object objOther);
    public virtual int GetHashCode();
    public virtual bool get_ContainsGenericParameters();
    private Type GetRootElementType();
    public virtual bool IsSubclassOf(Type c);
    protected virtual bool IsContextfulImpl();
    protected virtual bool IsMarshalByRefImpl();
    public virtual MemberInfo[] GetDefaultMembers();
    public virtual bool IsInstanceOfType(object o);
    public virtual string get_AssemblyQualifiedName();
    public virtual bool get_IsSerializable();
    private bool QuickSerializationCastCheck();
    public virtual Type get_ReflectedType();
    public virtual bool get_IsEnum();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual MethodBase get_DeclaringMethod();
    protected virtual bool IsCOMObjectImpl();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public virtual int GetArrayRank();
    public virtual Type MakeGenericType(Type[] argTypes);
    public virtual Type MakeByRefType();
    public virtual Type MakePointerType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    private Type MakeArrayTypeHelper(int rank);
    internal static string TypeSigToString(Type pThis);
    internal static void TypeSigToString(Type pThis, StringBuilder sb);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyConstructorInfo : ConstructorInfo {
    private MethodBase m_method;
    public int MetadataToken { get; }
    public Module Module { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public MemberTypes MemberType { get; }
    public bool IsGenericMethodDefinition { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MetadataOnlyConstructorInfo(MethodBase method);
    public virtual int get_MetadataToken();
    public virtual string ToString();
    public virtual Module get_Module();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReflectedType();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MemberTypes get_MemberType();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual MethodBody GetMethodBody();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCustomAttributeData : CustomAttributeData {
    private ConstructorInfo m_ctor;
    private MetadataOnlyModule m_module;
    private Token m_token;
    private IList`1<CustomAttributeTypedArgument> m_typedArguments;
    private IList`1<CustomAttributeNamedArgument> m_namedArguments;
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    public MetadataOnlyCustomAttributeData(MetadataOnlyModule module, Token token, ConstructorInfo ctor);
    public MetadataOnlyCustomAttributeData(ConstructorInfo ctor, IList`1<CustomAttributeTypedArgument> typedArguments, IList`1<CustomAttributeNamedArgument> namedArguments);
    public virtual ConstructorInfo get_Constructor();
    private void InitArgumentData();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyEventInfo : EventInfo {
    private MetadataOnlyModule m_resolver;
    private int m_eventToken;
    private EventAttributes m_attrib;
    private int m_declaringClassToken;
    private int m_eventHandlerTypeToken;
    private GenericContext m_context;
    private string m_name;
    private int m_nameLength;
    private Token m_addMethodToken;
    private Token m_removeMethodToken;
    private Token m_raiseMethodToken;
    public EventAttributes Attributes { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public Type EventHandlerType { get; }
    public Type DeclaringType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public MetadataOnlyEventInfo(MetadataOnlyModule resolver, Token eventToken, Type[] typeArgs, Type[] methodArgs);
    public virtual string ToString();
    private void InitializeName();
    public virtual EventAttributes get_Attributes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReflectedType();
    public virtual Type get_EventHandlerType();
    public virtual Type get_DeclaringType();
    public virtual int get_MetadataToken();
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual Module get_Module();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyFieldInfo : FieldInfo {
    private MetadataOnlyModule m_resolver;
    private int m_fieldDefToken;
    private FieldAttributes m_attrib;
    private int m_declaringClassToken;
    private Type m_fieldType;
    private GenericContext m_context;
    private string m_name;
    private int m_nameLength;
    private CustomModifiers m_customModifiers;
    private bool m_initialized;
    public FieldAttributes Attributes { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public Type FieldType { get; }
    public Type DeclaringType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public MetadataOnlyFieldInfo(MetadataOnlyModule resolver, Token fieldDefToken, Type[] typeArgs, Type[] methodArgs);
    private void InitializeName();
    private void Initialize();
    public virtual string ToString();
    private object ParseDefaultValue();
    public virtual FieldAttributes get_Attributes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReflectedType();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type get_FieldType();
    public virtual Type get_DeclaringType();
    public virtual object GetValue(object obj);
    public virtual Byte[] GetRvaField();
    public virtual object GetRawConstantValue();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyLocalVariableInfo : LocalVariableInfo {
    private Type m_type;
    private int m_index;
    private bool m_fPinned;
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public Type LocalType { get; }
    public MetadataOnlyLocalVariableInfo(int index, Type type, bool fPinned);
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
    public virtual Type get_LocalType();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBody : MethodBody {
    private MetadataOnlyMethodInfo m_method;
    protected MetadataOnlyMethodInfo Method { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public bool InitLocals { get; }
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    protected MetadataOnlyMethodBody(MetadataOnlyMethodInfo method);
    internal static MethodBody TryCreate(MetadataOnlyMethodInfo method);
    protected MetadataOnlyMethodInfo get_Method();
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
    public virtual bool get_InitLocals();
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual Byte[] GetILAsByteArray();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker : MetadataOnlyMethodBody {
    private static Byte[] s_EmptyByteArray;
    private IMethodHeader m_header;
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public int MaxStackSize { get; }
    public bool InitLocals { get; }
    public int LocalSignatureMetadataToken { get; }
    public MetadataOnlyMethodBodyWorker(MetadataOnlyMethodInfo method, IMethodHeader header);
    private static MetadataOnlyMethodBodyWorker();
    internal static MethodBody Create(MetadataOnlyMethodInfo method);
    public static IMethodHeader GetMethodHeader(UInt32 rva, MetadataOnlyModule scope);
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
    public virtual int get_MaxStackSize();
    public virtual Byte[] GetILAsByteArray();
    public virtual bool get_InitLocals();
    public virtual int get_LocalSignatureMetadataToken();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo : MethodInfo {
    private Token m_methodDef;
    private string m_name;
    private UInt32 m_nameLength;
    private Type m_tOwner;
    private MethodSignatureDescriptor m_descriptor;
    private ParameterInfo m_returnParameter;
    private MethodBody m_methodBody;
    private MethodAttributes m_attrs;
    private Type[] m_typeArgs;
    private Type[] m_methodArgs;
    private GenericContext m_context;
    private MetadataOnlyModule m_resolver;
    private Token m_declaringTypeDef;
    private SignatureBlob m_sigBlob;
    private bool m_fullyInitialized;
    public int MetadataToken { get; }
    internal MetadataOnlyModule Resolver { get; }
    public Module Module { get; }
    public Type ReturnType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ParameterInfo ReturnParameter { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public MemberTypes MemberType { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsGenericMethod { get; }
    public bool ContainsGenericParameters { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public MetadataOnlyMethodInfo(MetadataOnlyMethodInfo method);
    public MetadataOnlyMethodInfo(MetadataOnlyModule resolver, Token methodDef, Type[] typeArgs, Type[] methodArgs);
    internal static MethodBase Create(MetadataOnlyModule resolver, Token methodDef, GenericContext context);
    private void InitializeName();
    private void Initialize();
    private void GetOwnerTypeAndTypeArgs(Type& ownerType, Type[]& typeArgs);
    private Type[] GetGenericMethodArgs();
    public virtual int get_MetadataToken();
    internal MetadataOnlyModule get_Resolver();
    public virtual Module get_Module();
    public virtual Type get_ReturnType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static string CommonToString(MethodInfo m);
    private static void ConstructMethodString(MethodInfo m, StringBuilder sb);
    private static void ConstructParameters(StringBuilder sb, ParameterInfo[] parameters, CallingConventions callingConvention);
    private static void ConstructParameters(StringBuilder sb, Type[] parameters, CallingConventions callingConvention);
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReflectedType();
    public virtual ParameterInfo[] GetParameters();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MemberTypes get_MemberType();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual MethodInfo MakeGenericMethod(Type[] types);
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBody GetMethodBody();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodInfo GetBaseDefinition();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModifiedType : MetadataOnlyCommonType {
    private MetadataOnlyCommonType m_type;
    private string m_mod;
    public string FullName { get; }
    internal MetadataOnlyModule Resolver { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public Guid GUID { get; }
    public int MetadataToken { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    public Type ReflectedType { get; }
    public string Namespace { get; }
    public MetadataOnlyModifiedType(MetadataOnlyCommonType type, string mod);
    public virtual string get_FullName();
    internal virtual MetadataOnlyModule get_Resolver();
    public virtual Type get_BaseType();
    public virtual bool Equals(Type t);
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    public virtual bool IsAssignableFrom(Type c);
    public virtual Type get_UnderlyingSystemType();
    public virtual Type GetElementType();
    public virtual MethodInfo[] GetMethods(BindingFlags flags);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags flags);
    public virtual PropertyInfo[] GetProperties(BindingFlags flags);
    public virtual EventInfo[] GetEvents(BindingFlags flags);
    public virtual EventInfo GetEvent(string name, BindingFlags flags);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual Type[] GetInterfaces();
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual Guid get_GUID();
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual string ToString();
    public virtual int get_MetadataToken();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReflectedType();
    public virtual string get_Namespace();
    protected virtual TypeCode GetTypeCodeImpl();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule : Module {
    private IMetadataExtensionsPolicy m_policy;
    private IReflectionFactory m_factory;
    private string m_modulePath;
    private MetadataFile m_metadata;
    private IMetadataImport m_cachedThreadAffinityImporter;
    private string m_scopeName;
    private Token[] m_typeCodeMapping;
    private ITypeUniverse m_assemblyResolver;
    private NestedTypeCache m_nestedTypeInfo;
    private Assembly m_assembly;
    private Dictionary`2<string, Type> _typeCache;
    private static BindingFlags DefaultLookup;
    private static BindingFlags MembersDeclaredOnTypeOnly;
    private bool disposed;
    public string FullyQualifiedName { get; }
    internal IMetadataExtensionsPolicy Policy { get; }
    internal IReflectionFactory Factory { get; }
    public ITypeUniverse AssemblyResolver { get; }
    internal MetadataFile RawMetadata { get; }
    internal IMetadataImport RawImport { get; }
    public string ScopeName { get; }
    public Guid ModuleVersionId { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    public int MetadataToken { get; }
    public int MDStreamVersion { get; }
    public MetadataOnlyModule(ITypeUniverse universe, MetadataFile import, string modulePath);
    public MetadataOnlyModule(ITypeUniverse universe, MetadataFile import, IReflectionFactory factory, string modulePath);
    public virtual string get_FullyQualifiedName();
    internal IMetadataExtensionsPolicy get_Policy();
    internal IReflectionFactory get_Factory();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ITypeUniverse get_AssemblyResolver();
    internal bool IsValidToken(int token);
    internal bool IsValidToken(Token token);
    public Byte[] ReadEmbeddedBlob(EmbeddedBlobPointer pointer, int countBytes);
    internal MetadataFile get_RawMetadata();
    internal IMetadataImport get_RawImport();
    private IMetadataImport GetThreadSafeImporter();
    public virtual string get_ScopeName();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_Name();
    internal MetadataOnlyCommonType ResolveTypeDefToken(Token token);
    private void EnsureValidToken(Token token);
    internal Type ResolveTypeTokenInternal(Token token, GenericContext context);
    internal Type ResolveTypeTokenInternal(Token token, CorElementType elementType, GenericContext context);
    internal Type GetGenericType(Token token, GenericContext context);
    private MethodBase ResolveMethodTokenInternal(Token methodToken, GenericContext context);
    private MethodInfo ResolveMethodSpec(Token methodToken, GenericContext context);
    private MethodBase ResolveMethodDef(Token methodToken);
    internal MethodInfo GetGenericMethodInfo(Token methodToken, GenericContext genericContext);
    internal MethodBase GetGenericMethodBase(Token methodToken, GenericContext genericContext);
    internal MethodBase ResolveMethodRef(Token memberRef, GenericContext context, Type[] genericMethodParameters);
    internal FieldInfo ResolveFieldRef(Token memberRef, GenericContext context);
    internal FieldInfo ResolveFieldTokenInternal(Token fieldToken, GenericContext context);
    public virtual string ResolveString(int metadataToken);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    internal Type ResolveTypeRef(ITypeReference typeReference);
    internal Module ResolveModuleRef(Token moduleRefToken);
    internal Token LookupTypeToken(string className);
    internal Token FindTypeDefByName(Type outerType, string className, bool fThrow);
    internal Token FindTypeDefByName(Token outerTypeDefToken, string className, bool fThrow);
    internal void GetMemberRefData(Token token, Token& declaringTypeToken, String& nameMember, SignatureBlob& sig);
    internal UInt32 GetMethodRva(int methodDef);
    internal MethodImplAttributes GetMethodImplFlags(int methodToken);
    internal void GetMethodAttrs(Token methodDef, Token& declaringTypeDef, MethodAttributes& attrs, UInt32& nameLength);
    internal void GetMethodSig(Token methodDef, SignatureBlob& signature);
    internal void GetMethodName(Token methodDef, UInt32 nameLength, String& name);
    internal CorElementType GetEnumUnderlyingType(Token tokenTypeDef);
    internal void GetTypeAttributes(Token tokenTypeDef, Token& tokenExtends, TypeAttributes& attr, Int32& nameLength);
    internal void GetTypeName(Token tokenTypeDef, int nameLength, String& name);
    internal static ConstructorInfo[] GetConstructorsOnType(MetadataOnlyCommonType type, BindingFlags flags);
    internal static ConstructorInfo GetConstructorOnType(MetadataOnlyCommonType type, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    private static void CheckBinderAndModifiersforLMR(Binder binder, ParameterModifier[] modifiers);
    internal static MethodInfo GetMethodImplHelper(Type type, string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    private static MethodInfo FilterMethod(MethodInfo[] methods, string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types);
    internal static MethodInfo[] GetMethodsOnType(MetadataOnlyCommonType type, BindingFlags flags);
    private static bool WalkInheritanceChain(BindingFlags flags);
    private static IList`1<PropertyInfo> FilterInheritedProperties(IList`1<PropertyInfo> inheritedProperties, IList`1<PropertyInfo> properties, BindingFlags flags);
    private static IList`1<EventInfo> FilterInheritedEvents(IList`1<EventInfo> inheritedEvents, IList`1<EventInfo> events);
    private static bool IncludeInheritedMethod(MethodInfo inheritedMethod, IEnumerable`1<MethodInfo> methods, BindingFlags flags);
    private static bool IncludeInheritedAccessor(MethodInfo inheritedMethod, IEnumerable`1<MethodInfo> methods, BindingFlags flags);
    private static bool IncludeInheritedField(FieldInfo inheritedField, BindingFlags flags);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule/<GetMethodBasesOnDeclaredTypeOnly>d__77")]
internal IEnumerable`1<MethodBase> GetMethodBasesOnDeclaredTypeOnly(Token tokenTypeDef, GenericContext context, EMethodKind kind);
    private List`1<Type> GetTypeParameters(int token);
    private static bool MatchSignatures(MethodBase m1, MethodBase methodCandidate);
    private static bool IsOverride(IEnumerable`1<MethodInfo> methods, MethodInfo m);
    private static bool IsOverride(MethodInfo m1, MethodInfo m2);
    internal static FieldInfo[] GetFieldsOnType(MetadataOnlyCommonType type, BindingFlags flags);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule/<GetFieldsOnDeclaredTypeOnly>d__83")]
private IEnumerable`1<FieldInfo> GetFieldsOnDeclaredTypeOnly(Token typeDefToken, GenericContext context);
    internal static PropertyInfo[] GetPropertiesOnType(MetadataOnlyCommonType type, BindingFlags flags);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule/<GetPropertiesOnDeclaredTypeOnly>d__85")]
internal IEnumerable`1<PropertyInfo> GetPropertiesOnDeclaredTypeOnly(Token tokenTypeDef, GenericContext context);
    internal static EventInfo[] GetEventsOnType(MetadataOnlyCommonType type, BindingFlags flags);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule/<GetEventsOnDeclaredTypeOnly>d__87")]
private IEnumerable`1<EventInfo> GetEventsOnDeclaredTypeOnly(Token tokenTypeDef, GenericContext context);
    internal IEnumerable`1<Type> GetNestedTypesOnType(MetadataOnlyCommonType type, BindingFlags flags);
    private void EnsureNestedTypeCacheExists();
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule/<GetNestedTypesOnType>d__92")]
internal IEnumerable`1<Type> GetNestedTypesOnType(Token tokenTypeDef, BindingFlags flags);
    public IList`1<CustomAttributeData> GetCustomAttributeData(int memberTokenValue);
    private ConstructorInfo ResolveCustomAttributeConstructor(Token customAttributeConstructorTokenValue);
    internal void LazyAttributeParse(Token token, ConstructorInfo constructorInfo, IList`1& constructorArguments, IList`1& namedArguments);
    private IList`1<CustomAttributeTypedArgument> GetConstructorArguments(ConstructorInfo constructorInfo, Byte[] customAttributeBlob, Int32& index);
    private IList`1<CustomAttributeNamedArgument> GetNamedArguments(ConstructorInfo constructorInfo, Byte[] customAttributeBlob, Int32& index);
    private object GetCustomAttributeArgumentValue(CorElementType typeId, Type type, Byte[] customAttributeBlob, Int32& index);
    internal static Type GetUnderlyingType(Type enumType);
    internal Type GetEnclosingType(Token tokenTypeDef);
    public sealed virtual AssemblyName GetAssemblyNameFromAssemblyRef(Token assemblyRefToken);
    internal Token GetNestedClassProps(Token tokenTypeDef);
    internal int CountGenericParams(Token token);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule/<GetGenericParameterTokens>d__104")]
internal IEnumerable`1<int> GetGenericParameterTokens(int typeOrMethodToken);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule/<GetConstraintTypes>d__105")]
internal IEnumerable`1<Type> GetConstraintTypes(int gpToken);
    internal void GetGenericParameterProps(int mdGenericParam, Int32& ownerTypeToken, Int32& ownerMethodToken, String& name, GenericParameterAttributes& attributes, UInt32& genIndex);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule/<GetInterfacesOnType>d__107")]
internal IEnumerable`1<Type> GetInterfacesOnType(Type type);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule/<EnumerateInterfaceImplsOnType>d__108")]
internal IEnumerable`1<Token> EnumerateInterfaceImplsOnType(Type type);
    internal Type GetInterfaceTypeFromInterfaceImpl(Type type, Token tImpl);
    public static Type GetInterfaceHelper(Type[] interfaces, string name, bool ignoreCase);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule/<GetTypeList>d__111")]
public IEnumerable`1<Type> GetTypeList();
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule/<GetTypeTokenList>d__112")]
private IEnumerable`1<int> GetTypeTokenList();
    private static void CheckBindingFlagsInMethod(BindingFlags flags, string methodName);
    private static void CheckIsStaticAndIsPublicOnProperty(PropertyInfo propertyInfo, Boolean& isStatic, Boolean& isPublic);
    private static void CheckIsStaticAndIsPublicOnEvent(EventInfo eventInfo, Boolean& isStatic, Boolean& isPublic);
    private static void CheckIsStaticAndIsPublic(MethodInfo methodInfo, Boolean& isStatic, Boolean& isPublic);
    internal void SetContainingAssembly(Assembly assembly);
    public virtual Assembly get_Assembly();
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual Type[] GetTypes();
    public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual int get_MetadataToken();
    public virtual bool IsResource();
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    internal bool IsSystemModule();
    internal static bool IsWindowsRuntime(Module module);
    internal TypeCode GetTypeCode(Type type);
    private Token[] CreateTypeCodeMapping();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual int RowCount(MetadataTable metadataTableIndex);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual int get_MDStreamVersion();
    public string GetRuntimeVersion();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyParameterInfo : ParameterInfo {
    private MetadataOnlyModule m_resolver;
    private int m_parameterToken;
    private ParameterAttributes m_attrib;
    private Type m_paramType;
    private CustomModifiers m_customModifiers;
    private string m_name;
    private UInt32 m_nameLength;
    private int m_position;
    private int m_parentMemberToken;
    public ParameterAttributes Attributes { get; }
    public string Name { get; }
    public MemberInfo Member { get; }
    public int Position { get; }
    public Type ParameterType { get; }
    public int MetadataToken { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    internal MetadataOnlyParameterInfo(MetadataOnlyModule resolver, Token parameterToken, Type paramType, CustomModifiers customModifiers);
    private void InitializeName();
    public virtual ParameterAttributes get_Attributes();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual string get_Name();
    public virtual MemberInfo get_Member();
    public virtual int get_Position();
    public virtual Type get_ParameterType();
    public virtual int get_MetadataToken();
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual string ToString();
    public MarshalAsAttribute GetMarshalInfo();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyPropertyInfo : PropertyInfo {
    private MetadataOnlyModule m_resolver;
    private Token m_PropertyToken;
    private PropertyAttributes m_attrib;
    private Token m_declaringClassToken;
    private Type m_propertyType;
    private GenericContext m_context;
    private string m_name;
    private int m_nameLength;
    private Token m_setterToken;
    private Token m_getterToken;
    public PropertyAttributes Attributes { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public Type PropertyType { get; }
    public Type DeclaringType { get; }
    public int MetadataToken { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Module Module { get; }
    public MetadataOnlyPropertyInfo(MetadataOnlyModule resolver, Token propToken, Type[] typeArgs, Type[] methodArgs);
    private void InitializeName();
    public virtual string ToString();
    public virtual PropertyAttributes get_Attributes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReflectedType();
    public virtual Type get_PropertyType();
    public virtual Type get_DeclaringType();
    public virtual object GetConstantValue();
    public virtual int get_MetadataToken();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual Module get_Module();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
[DebuggerDisplayAttribute("\{Name = {Name} FullName = {FullName} ElementType = {m_elemType} {m_typeRef}\}")]
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlySignatureTypeReference : MetadataOnlyTypeReference {
    private CorElementType m_elemType;
    public MetadataOnlySignatureTypeReference(MetadataOnlyModule resolver, Token typeRef, CorElementType elemType);
    protected virtual bool IsValueTypeImpl();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef : MetadataOnlyCommonType {
    private MetadataOnlyModule m_resolver;
    private Token m_tokenTypeDef;
    private Type[] m_typeParameters;
    private Token m_tokenExtends;
    private string m_fullName;
    private int m_nameLength;
    private TypeAttributes m_typeAttributes;
    private Type m_baseType;
    private TriState m_fIsValueType;
    private static String[] PrimitiveTypeNames;
    private Type[] _interfacesCache;
    private string LocalFullName { get; }
    internal MetadataOnlyModule Resolver { get; }
    public int MetadataToken { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsEnum { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public Guid GUID { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public MetadataOnlyTypeDef(MetadataOnlyModule scope, Token tokenTypeDef);
    public MetadataOnlyTypeDef(MetadataOnlyModule scope, Token tokenTypeDef, Type[] typeParameters);
    private static MetadataOnlyTypeDef();
    private static void ValidateConstructorArguments(MetadataOnlyModule scope, Token tokenTypeDef);
    private string get_LocalFullName();
    internal virtual MetadataOnlyModule get_Resolver();
    public virtual int get_MetadataToken();
    public virtual string get_FullName();
    private void GetSimpleName(StringBuilder sb);
    public virtual string get_Namespace();
    public virtual string ToString();
    public virtual Type get_BaseType();
    public virtual bool Equals(Type other);
    public virtual Type MakeGenericType(Type[] argTypes);
    public virtual bool get_IsEnum();
    public virtual bool IsAssignableFrom(Type c);
    internal static bool IsAssignableFromHelper(Type current, Type target);
    public virtual Type get_UnderlyingSystemType();
    protected virtual bool IsValueTypeImpl();
    private bool IsValueTypeHelper();
    protected virtual bool IsPrimitiveImpl();
    public virtual bool get_IsGenericType();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual Type GetElementType();
    public virtual FieldInfo[] GetFields(BindingFlags flags);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    internal static PropertyInfo GetPropertyImplHelper(MetadataOnlyCommonType type, string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual Type[] GetInterfaces();
    internal static Type[] GetAllInterfacesHelper(MetadataOnlyCommonType type);
    public virtual Type GetInterface(string name, bool ignoreCase);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef/<GetInterfaceImpls>d__53")]
public IEnumerable`1<InterfaceImpl> GetInterfaceImpls();
    private static bool PropertyParamTypesMatch(PropertyInfo p, Type[] types);
    public virtual EventInfo[] GetEvents(BindingFlags flags);
    public virtual EventInfo GetEvent(string name, BindingFlags flags);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    internal static MemberInfo[] GetMembersHelper(Type type, BindingFlags bindingAttr);
    public virtual Guid get_GUID();
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsCOMObjectImpl();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    protected virtual TypeCode GetTypeCodeImpl();
    internal virtual IEnumerable`1<PropertyInfo> GetDeclaredProperties();
    internal virtual IEnumerable`1<MethodBase> GetDeclaredMethods();
    internal virtual IEnumerable`1<MethodBase> GetDeclaredConstructors();
}
[DebuggerDisplayAttribute("\{Name = {Name} FullName = {FullName} {m_typeRef}\}")]
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeReference : TypeProxy {
    private Token m_typeRef;
    public Module DeclaringScope { get; }
    public Token TypeRefToken { get; }
    public Token ResolutionScope { get; }
    public string RawName { get; }
    public string Namespace { get; }
    public string Name { get; }
    public string FullName { get; }
    private AssemblyName RequestedAssemblyName { get; }
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public bool IsGenericParameter { get; }
    public Type DeclaringType { get; }
    public MetadataOnlyTypeReference(MetadataOnlyModule resolver, Token typeRef);
    protected virtual Type GetResolvedTypeWorker();
    public sealed virtual Module get_DeclaringScope();
    public sealed virtual Token get_TypeRefToken();
    public sealed virtual Token get_ResolutionScope();
    public virtual string get_RawName();
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual string get_FullName();
    private AssemblyName get_RequestedAssemblyName();
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsArrayImpl();
    public virtual bool get_IsGenericParameter();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    public virtual Type get_DeclaringType();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeVariable : MetadataOnlyCommonType {
    private int m_ownerMethodToken;
    private int m_ownerTypeToken;
    private string m_name;
    private UInt32 m_position;
    private MetadataOnlyModule m_resolver;
    private int m_Token;
    private GenericParameterAttributes m_gpAttributes;
    public string FullName { get; }
    internal MetadataOnlyModule Resolver { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public int MetadataToken { get; }
    public bool IsGenericParameter { get; }
    public Guid GUID { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Assembly Assembly { get; }
    public Type ReflectedType { get; }
    internal MetadataOnlyTypeVariable(MetadataOnlyModule resolver, Token token);
    public virtual string get_FullName();
    internal virtual MetadataOnlyModule get_Resolver();
    public virtual Type get_BaseType();
    public virtual bool Equals(Type txOther);
    public virtual bool IsAssignableFrom(Type c);
    public virtual Type get_UnderlyingSystemType();
    public virtual Type GetElementType();
    public virtual int get_MetadataToken();
    public virtual MethodInfo[] GetMethods(BindingFlags flags);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags flags);
    public virtual FieldInfo GetField(string name, BindingFlags flags);
    public virtual PropertyInfo[] GetProperties(BindingFlags flags);
    public virtual EventInfo[] GetEvents(BindingFlags flags);
    public virtual EventInfo GetEvent(string name, BindingFlags flags);
    public virtual Type MakeGenericType(Type[] argTypes);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual bool get_IsGenericParameter();
    public virtual Type[] GetGenericArguments();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual Type GetGenericTypeDefinition();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual Type[] GetInterfaces();
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual Guid get_GUID();
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual MethodBase get_DeclaringMethod();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Assembly get_Assembly();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReflectedType();
    public virtual string ToString();
    protected virtual TypeCode GetTypeCodeImpl();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeVariableRef : MetadataOnlyCommonType {
    private MetadataOnlyModule m_resolver;
    private Token m_ownerToken;
    private int m_position;
    private bool IsMethodVar { get; }
    public string FullName { get; }
    internal MetadataOnlyModule Resolver { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public int MetadataToken { get; }
    public bool IsGenericParameter { get; }
    public Guid GUID { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Assembly Assembly { get; }
    public Type ReflectedType { get; }
    internal MetadataOnlyTypeVariableRef(MetadataOnlyModule resolver, Token ownerToken, int position);
    private bool get_IsMethodVar();
    public virtual string get_FullName();
    internal virtual MetadataOnlyModule get_Resolver();
    public virtual Type get_BaseType();
    public virtual bool Equals(Type other);
    public virtual bool IsAssignableFrom(Type c);
    public virtual Type get_UnderlyingSystemType();
    public virtual Type GetElementType();
    public virtual int get_MetadataToken();
    public virtual MethodInfo[] GetMethods(BindingFlags flags);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags flags);
    public virtual FieldInfo GetField(string name, BindingFlags flags);
    public virtual PropertyInfo[] GetProperties(BindingFlags flags);
    public virtual EventInfo[] GetEvents(BindingFlags flags);
    public virtual EventInfo GetEvent(string name, BindingFlags flags);
    public virtual Type MakeGenericType(Type[] argTypes);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual bool get_IsGenericParameter();
    public virtual Type[] GetGenericArguments();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual Type GetGenericTypeDefinition();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual Type[] GetInterfaces();
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual Guid get_GUID();
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual MethodBase get_DeclaringMethod();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Assembly get_Assembly();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReflectedType();
    public virtual string ToString();
    protected virtual TypeCode GetTypeCodeImpl();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyVectorType : MetadataOnlyCommonArrayType {
    public string FullName { get; }
    public string Name { get; }
    public MetadataOnlyVectorType(MetadataOnlyCommonType elementType);
    public virtual string get_FullName();
    public virtual int GetArrayRank();
    protected virtual bool IsArrayImpl();
    public virtual bool Equals(Type t);
    public virtual bool IsAssignableFrom(Type c);
    public virtual string get_Name();
    public virtual string ToString();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodFilter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GenericParameterCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParameterCount>k__BackingField;
    [CompilerGeneratedAttribute]
private CorCallingConvention <CallingConvention>k__BackingField;
    public string Name { get; public set; }
    public int GenericParameterCount { get; public set; }
    public int ParameterCount { get; public set; }
    public CorCallingConvention CallingConvention { get; public set; }
    public MethodFilter(string name, int genericParameterCount, int parameterCount, CorCallingConvention callingConvention);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_GenericParameterCount();
    [CompilerGeneratedAttribute]
public void set_GenericParameterCount(int value);
    [CompilerGeneratedAttribute]
public int get_ParameterCount();
    [CompilerGeneratedAttribute]
public void set_ParameterCount(int value);
    [CompilerGeneratedAttribute]
public CorCallingConvention get_CallingConvention();
    [CompilerGeneratedAttribute]
public void set_CallingConvention(CorCallingConvention value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodSignatureDescriptor : object {
    [CompilerGeneratedAttribute]
private CorCallingConvention <CallingConvention>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GenericParameterCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeSignatureDescriptor <ReturnParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeSignatureDescriptor[] <Parameters>k__BackingField;
    public CorCallingConvention CallingConvention { get; public set; }
    public int GenericParameterCount { get; public set; }
    public TypeSignatureDescriptor ReturnParameter { get; public set; }
    public TypeSignatureDescriptor[] Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public CorCallingConvention get_CallingConvention();
    [CompilerGeneratedAttribute]
public void set_CallingConvention(CorCallingConvention value);
    [CompilerGeneratedAttribute]
public int get_GenericParameterCount();
    [CompilerGeneratedAttribute]
public void set_GenericParameterCount(int value);
    [CompilerGeneratedAttribute]
public TypeSignatureDescriptor get_ReturnParameter();
    [CompilerGeneratedAttribute]
public void set_ReturnParameter(TypeSignatureDescriptor value);
    [CompilerGeneratedAttribute]
public TypeSignatureDescriptor[] get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(TypeSignatureDescriptor[] value);
}
internal enum Microsoft.UI.Xaml.Markup.Compiler.Lmr.NamedArgumentType : Enum {
    public int value__;
    public static NamedArgumentType Field;
    public static NamedArgumentType Property;
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.OpenGenericContext : GenericContext {
    private MetadataOnlyModule m_resolver;
    private Token m_ownerMethod;
    public OpenGenericContext(Type[] typeArgs, Type[] methodArgs);
    public OpenGenericContext(MetadataOnlyModule resolver, Type ownerType, Token ownerMethod);
    public virtual GenericContext VerifyAndUpdateMethodArguments(int expectedNumberOfMethodArgs);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.ProxyGenericType : TypeProxy {
    private TypeProxy m_rawType;
    private Type[] m_args;
    public string Name { get; }
    public string Namespace { get; }
    public Type DeclaringType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsEnum { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public ProxyGenericType(TypeProxy rawType, Type[] args);
    protected virtual Type GetResolvedTypeWorker();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual string get_Name();
    public virtual string get_Namespace();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    public virtual Type get_DeclaringType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsEnum();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsPrimitiveImpl();
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes : object {
    public static string TypeForwardedToAttributeName;
    public static string SerializableAttributeName;
    public static IEnumerable`1<CustomAttributeData> GetTypeForwardedToAttributes(MetadataOnlyAssembly assembly);
    public static IEnumerable`1<CustomAttributeData> GetTypeForwardedToAttributes(MetadataOnlyModule manifestModule, Token token);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes/<GetTypeForwardedToAttributes>d__4")]
public static IEnumerable`1<CustomAttributeData> GetTypeForwardedToAttributes(MetadataOnlyModule manifestModule);
    internal static IEnumerable`1<UnresolvedTypeName> GetRawTypeForwardedToAttributes(MetadataOnlyAssembly assembly);
    internal static bool GetNextExportedType(HCORENUM& hEnum, IMetadataAssemblyImport assemblyImport, StringBuilder typeName, Token& implementationToken);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes/<GetRawTypeForwardedToAttributes>d__7")]
internal static IEnumerable`1<UnresolvedTypeName> GetRawTypeForwardedToAttributes(MetadataOnlyModule manifestModule);
    internal static UnresolvedTypeName GetRawTypeForwardedToAttribute(MetadataOnlyAssembly assembly, string fullname, bool ignoreCase);
    internal static UnresolvedTypeName GetRawTypeForwardedToAttribute(MetadataOnlyModule manifestModule, string fullname, bool ignoreCase);
    public static Type GetTypeFromTypeForwardToAttribute(CustomAttributeData data);
    public static CustomAttributeData GetSerializableAttribute(MetadataOnlyModule module, Token token);
    internal static CustomAttributeData GetSerializableAttribute(MetadataOnlyModule module, bool isRequired);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureBlob : object {
    private Byte[] m_signature;
    private SignatureBlob(Byte[] data);
    public static SignatureBlob ReadSignature(MetadataFile storage, EmbeddedBlobPointer pointer, int countBytes);
    public Byte[] GetSignatureAsByteArray();
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureComparer : object {
    private static BindingFlags MembersDeclaredOnTypeOnly;
    public static IEnumerable`1<MethodBase> FilterMethods(MethodFilter filter, MethodInfo[] allMethods);
    public static IEnumerable`1<MethodBase> FilterConstructors(MethodFilter filter, ConstructorInfo[] allConstructors);
    internal static bool IsParametersTypeMatch(MethodBase templateMethod, TypeSignatureDescriptor[] parameters);
    public static MethodBase FindMatchingMethod(string methodName, Type typeToInspect, MethodSignatureDescriptor expectedSignature, GenericContext context);
    private static MethodBase GetTemplateMethod(Type typeToInspect, int methodToken);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureParameterInfo : SimpleParameterInfo {
    private CustomModifiers m_modifiers;
    public SignatureParameterInfo(MemberInfo member, Type paramType, int position, CustomModifiers modifiers);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil : object {
    private static UInt32[] s_tkCorEncodeToken;
    private static byte FieldId;
    private static byte PropertyId;
    private static CorElementType BoxedValue;
    private static SignatureUtil();
    internal static CorElementType ExtractElementType(Byte[] sig, Int32& index);
    internal static UnmanagedType ExtractUnmanagedType(Byte[] sig, Int32& index);
    internal static CorCallingConvention ExtractCallingConvention(Byte[] sig, Int32& index);
    internal static CustomModifiers ExtractCustomModifiers(Byte[] sig, Int32& index, MetadataOnlyModule resolver, GenericContext context);
    internal static Type ExtractType(Byte[] sig, Int32& index, MetadataOnlyModule resolver, GenericContext context);
    internal static TypeSignatureDescriptor ExtractType(Byte[] sig, Int32& index, MetadataOnlyModule resolver, GenericContext context, bool fAllowPinned);
    internal static void ExtractCustomAttributeArgumentType(ITypeUniverse universe, Module module, Byte[] customAttributeBlob, Int32& index, CorElementType& argumentTypeId, Type& argumentType);
    internal static bool IsVarArg(CorCallingConvention conv);
    internal static int ExtractInt(Byte[] sig, Int32& index);
    internal static Token ExtractToken(Byte[] sig, Int32& index);
    internal static CorElementType GetTypeId(Type type);
    internal static string ExtractStringValue(Byte[] blob, Int32& index);
    internal static UInt32 ExtractUIntValue(Byte[] blob, Int32& index);
    internal static Type ExtractTypeValue(ITypeUniverse universe, Module module, Byte[] blob, Int32& index);
    internal static object ExtractValue(CorElementType typeId, Byte[] blob, Int32& index);
    internal static IList`1<CustomAttributeTypedArgument> ExtractListOfValues(Type elementType, ITypeUniverse universe, Module module, UInt32 size, Byte[] blob, Int32& index);
    internal static bool IsValidCustomAttributeElementType(CorElementType elementType);
    internal static void VerifyElementType(CorElementType elementType);
    internal static NamedArgumentType ExtractNamedArgumentType(Byte[] customAttributeBlob, Int32& index);
    internal static MethodSignatureDescriptor ExtractMethodSignature(SignatureBlob methodSignatureBlob, MetadataOnlyModule resolver, GenericContext context);
    internal static CallingConventions GetReflectionCallingConvention(CorCallingConvention callConvention);
    internal static bool IsCallingConventionMatch(MethodBase method, CallingConventions callConvention);
    internal static bool IsGenericParametersCountMatch(MethodInfo method, int expectedGenericParameterCount);
    internal static bool IsParametersTypeMatch(MethodBase method, Type[] parameterTypes);
    private static UInt32 TokenFromRid(UInt32 rid, UInt32 tkType);
    internal static StringComparison GetStringComparison(BindingFlags flags);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.SimpleParameterInfo : ParameterInfo {
    private MemberInfo m_member;
    private Type m_paramType;
    private int m_position;
    public int Position { get; }
    public Type ParameterType { get; }
    public MemberInfo Member { get; }
    public int MetadataToken { get; }
    public ParameterAttributes Attributes { get; }
    public string Name { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    internal SimpleParameterInfo(MemberInfo member, Type paramType, int position);
    public virtual string ToString();
    public virtual int get_Position();
    public virtual Type get_ParameterType();
    public virtual MemberInfo get_Member();
    public virtual int get_MetadataToken();
    public virtual ParameterAttributes get_Attributes();
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Lmr.StringBuilderPool : object {
    private static int DefaultCapacity;
    private static int MaxListSize;
    private static int MaxCapacity;
    private static StringBuilder[] s_pool;
    private static object s_synclock;
    private static StringBuilderPool();
    public static StringBuilder Get();
    public static StringBuilder Get(int capacity);
    public static void Release(StringBuilder& builder);
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeNameQuoter : object {
    private static Char[] specialCharacters;
    private static TypeNameQuoter();
    internal static string GetQuotedTypeName(string name);
    private static bool Contains(Char[] This, char ch);
}
[DebuggerDisplayAttribute("TypeProxy")]
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeProxy : MetadataOnlyCommonType {
    protected MetadataOnlyModule m_resolver;
    private Type m_cachedResolvedType;
    internal MetadataOnlyModule Resolver { get; }
    public ITypeUniverse TypeUniverse { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string Name { get; }
    public string AssemblyQualifiedName { get; }
    public Module Module { get; }
    public Type BaseType { get; }
    public bool IsEnum { get; }
    public int MetadataToken { get; }
    public bool ContainsGenericParameters { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public Guid GUID { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public MethodBase DeclaringMethod { get; }
    public int GenericParameterPosition { get; }
    public bool IsSerializable { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Assembly Assembly { get; }
    public Type ReflectedType { get; }
    protected TypeProxy(MetadataOnlyModule resolver);
    internal virtual MetadataOnlyModule get_Resolver();
    public sealed virtual ITypeUniverse get_TypeUniverse();
    public virtual Type GetResolvedType();
    protected abstract virtual Type GetResolvedTypeWorker();
    public virtual string ToString();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual string get_AssemblyQualifiedName();
    public virtual int GetHashCode();
    public virtual bool Equals(object objOther);
    public virtual bool Equals(Type t);
    public virtual Type MakeByRefType();
    public virtual Type MakePointerType();
    public virtual int GetArrayRank();
    public virtual Type MakeGenericType(Type[] args);
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Module get_Module();
    public virtual Type get_BaseType();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    public virtual bool get_IsEnum();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsPrimitiveImpl();
    public virtual Type GetElementType();
    public virtual int get_MetadataToken();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo[] GetMethods(BindingFlags flags);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual bool IsAssignableFrom(Type c);
    protected virtual bool IsContextfulImpl();
    protected virtual bool IsMarshalByRefImpl();
    public virtual bool IsSubclassOf(Type c);
    public virtual Type get_UnderlyingSystemType();
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual FieldInfo[] GetFields(BindingFlags flags);
    public virtual PropertyInfo[] GetProperties(BindingFlags flags);
    public virtual EventInfo[] GetEvents(BindingFlags flags);
    public virtual EventInfo GetEvent(string name, BindingFlags flags);
    public virtual FieldInfo GetField(string name, BindingFlags flags);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual bool IsInstanceOfType(object o);
    public virtual Type[] GetInterfaces();
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual Guid get_GUID();
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsCOMObjectImpl();
    public virtual MemberInfo[] GetDefaultMembers();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual MethodBase get_DeclaringMethod();
    public virtual int get_GenericParameterPosition();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public virtual bool get_IsSerializable();
    public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual Assembly get_Assembly();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReflectedType();
    protected virtual TypeCode GetTypeCodeImpl();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeSignatureDescriptor : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private CustomModifiers <CustomModifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPinned>k__BackingField;
    public Type Type { get; public set; }
    public CustomModifiers CustomModifiers { get; public set; }
    public bool IsPinned { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public CustomModifiers get_CustomModifiers();
    [CompilerGeneratedAttribute]
public void set_CustomModifiers(CustomModifiers value);
    [CompilerGeneratedAttribute]
public bool get_IsPinned();
    [CompilerGeneratedAttribute]
public void set_IsPinned(bool value);
}
[DebuggerDisplayAttribute("{m_typeSpecToken}")]
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeSpec : TypeProxy {
    private Token m_typeSpecToken;
    private GenericContext m_context;
    public Token TypeSpecToken { get; }
    public Byte[] Blob { get; }
    public Module DeclaringScope { get; }
    public TypeSpec(MetadataOnlyModule module, Token typeSpecToken, Type[] typeArgs, Type[] methodArgs);
    public sealed virtual Token get_TypeSpecToken();
    public sealed virtual Byte[] get_Blob();
    public sealed virtual Module get_DeclaringScope();
    protected virtual Type GetResolvedTypeWorker();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.UnmanagedStringMemoryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal UnmanagedStringMemoryHandle(int countBytes);
    protected virtual bool ReleaseHandle();
    public string GetAsString(int countCharsNoNull);
}
[DebuggerDisplayAttribute("{m_TypeName},{m_AssemblyName}")]
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.UnresolvedTypeName : object {
    private string m_TypeName;
    private AssemblyName m_AssemblyName;
    private static InstanceCache`2<AssemblyName, string> _assemblyNameCache;
    public string TypeName { get; }
    public UnresolvedTypeName(string typeName, AssemblyName assemblyName);
    private static UnresolvedTypeName();
    public Type ConvertToType(ITypeUniverse universe, Module moduleContext);
    public string get_TypeName();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.UnusedIntPtr : ValueType {
    private IntPtr zeroPtr;
    public static UnusedIntPtr Zero { get; }
    public static UnusedIntPtr get_Zero();
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Lmr.Utility : object {
    public static bool Compare(string string1, string string2, bool ignoreCase);
    public static bool IsBindingFlagsMatching(MethodBase method, bool isInherited, BindingFlags bindingFlags);
    public static bool IsBindingFlagsMatching(FieldInfo fieldInfo, bool isInherited, BindingFlags bindingFlags);
    public static bool IsBindingFlagsMatching(MemberInfo memberInfo, bool isStatic, bool isPublic, bool isInherited, BindingFlags bindingFlags);
    internal static string GetNamespaceHelper(string fullName);
    internal static string GetTypeNameFromFullNameHelper(string fullName, bool isNested);
    internal static void VerifyNotByRef(MetadataOnlyCommonType type);
    internal static bool IsValidPath(string modulePath);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.XamlLmrAssemblyProxy : AssemblyProxy {
    private Assembly _assembly;
    private AssemblyName _asmName;
    public XamlLmrAssemblyProxy(ITypeUniverse universe, Assembly assembly);
    protected virtual Assembly GetResolvedAssemblyWorker();
    protected virtual AssemblyName GetNameWithNoResolution();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.XamlReflectionFactory : DefaultFactory {
    private Dictionary`2<string, Dictionary`2<int, MetadataOnlyCommonType>> _scopeCache;
    public virtual MetadataOnlyCommonType CreateSimpleType(MetadataOnlyModule scope, Token tokenTypeDef);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Lmr.XamlTypeUniverse : SimpleUniverse {
    private Dictionary`2<string, Assembly> _asmNameCache;
    private Dictionary`2<string, Type> _resolvedTypes;
    private Loader _loader;
    private Assembly _systemAssembly;
    private Assembly _systemRuntimeAssembly;
    private Assembly _xamlProxyAssembly;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ReferenceAssemblyPaths>k__BackingField;
    public string ProjectPath { get; public set; }
    public String[] ReferenceAssemblyPaths { get; public set; }
    public bool IsSystemAssemblyLoaded { get; }
    private Loader Loader { get; }
    private Assembly SystemAssembly { get; }
    public XamlTypeUniverse(bool useManagedProjections);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public String[] get_ReferenceAssemblyPaths();
    [CompilerGeneratedAttribute]
public void set_ReferenceAssemblyPaths(String[] value);
    public bool get_IsSystemAssemblyLoaded();
    private Loader get_Loader();
    private Assembly get_SystemAssembly();
    public virtual Module ResolveModule(Assembly containingAssembly, string moduleName);
    public Assembly LoadAssemblyFromFile(string path);
    public virtual Assembly GetSystemRuntimeAssembly();
    public virtual Assembly ResolveAssembly(AssemblyName name, bool throwOnError);
    public virtual Assembly GetSystemAssembly();
    public Assembly GetXamlProxyAssembly();
    public Type FindType(string typeName);
}
public class Microsoft.UI.Xaml.Markup.Compiler.MapIndexStep : BindPathStep {
    private string keyHashCode;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Key { get; }
    public string UniqueName { get; }
    public MapIndexStep(string key, XamlType valueType, BindPathStep parent, ApiInformation apiInformation);
    [CompilerGeneratedAttribute]
public string get_Key();
    public virtual string get_UniqueName();
}
public class Microsoft.UI.Xaml.Markup.Compiler.MethodStep : BindPathStep {
    private MemberInfo[] methodInfos;
    private IList`1<Parameter> parameters;
    [CompilerGeneratedAttribute]
private string <UniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOverloaded>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <OwnerType>k__BackingField;
    public bool IsIncludedInUpdate { get; }
    public string UniqueName { get; }
    public XamlType ValueType { get; }
    public bool IsOverloaded { get; }
    public bool IsStatic { get; }
    public string MethodName { get; }
    public XamlType OwnerType { get; }
    public IReadOnlyList`1<Parameter> Parameters { get; }
    public MethodStep(MemberInfo[] memberInfos, XamlType ownerType, BindPathStep parent, ApiInformation apiInformation);
    private MethodStep(MemberInfo[] memberInfos, UInt32 selectedOverload, XamlType ownerType, BindPathStep parent, ApiInformation apiInformation);
    public virtual bool get_IsIncludedInUpdate();
    [CompilerGeneratedAttribute]
public virtual string get_UniqueName();
    [CompilerGeneratedAttribute]
public virtual XamlType get_ValueType();
    [CompilerGeneratedAttribute]
public bool get_IsOverloaded();
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public XamlType get_OwnerType();
    public IReadOnlyList`1<Parameter> get_Parameters();
    public MethodStep GetOverload(int parameterCount);
}
[ExtensionAttribute]
internal static class Microsoft.UI.Xaml.Markup.Compiler.MoreXamlTypeExtensions : object {
    private static IDictionary`2<string, Dictionary`2<string, bool>> implicitCastCache;
    private static IReadOnlyDictionary`2<string, HashSet`1<string>> primitiveTypesCasting;
    private static IDictionary`2<string, Dictionary`2<string, LanguageSpecificString>> inlineConversionsCache;
    private static IReadOnlyDictionary`2<string, Dictionary`2<string, LanguageSpecificString>> inlineConversionsSupported;
    internal static IDictionary`2<string, Dictionary`2<string, LanguageSpecificString>> InlineConversionsCache { get; }
    private static MoreXamlTypeExtensions();
    internal static IDictionary`2<string, Dictionary`2<string, LanguageSpecificString>> get_InlineConversionsCache();
    [ExtensionAttribute]
internal static bool ImplementsXamlINotifyPropertyChanged(XamlType type);
    [ExtensionAttribute]
internal static bool ImplementsXamlINotifyDataErrorInfo(XamlType type);
    [ExtensionAttribute]
internal static bool ImplementsXamlINotifyCollectionChanged(XamlType type);
    [ExtensionAttribute]
internal static bool ImplementsIInputValidationControl(XamlType type);
    [ExtensionAttribute]
internal static bool IsDerivedFromValidationCommand(XamlType type);
    [ExtensionAttribute]
internal static bool IsDeprecated(XamlType type);
    [ExtensionAttribute]
internal static bool IsDerivedFromFrameworkTemplate(XamlType type);
    [ExtensionAttribute]
internal static bool IsDerivedFromDataTemplate(XamlType type);
    [ExtensionAttribute]
internal static bool IsDerivedFromControlTemplate(XamlType type);
    [ExtensionAttribute]
internal static bool IsDerivedFromResourceDictionary(XamlType type);
    [ExtensionAttribute]
internal static bool IsDerivedFromUIElement(XamlType type);
    [ExtensionAttribute]
internal static bool IsDerivedFromWindow(XamlType type);
    [ExtensionAttribute]
internal static bool IsDerivedFromFlyoutBase(XamlType type);
    [ExtensionAttribute]
internal static bool IsDerivedFromMarkupExtension(XamlType type);
    [ExtensionAttribute]
internal static bool IsDerivedFromTextBox(XamlType type);
    [ExtensionAttribute]
internal static bool IsDelegate(XamlType type);
    [ExtensionAttribute]
internal static bool IsObject(XamlType type);
    [ExtensionAttribute]
internal static bool IsVoid(XamlType type);
    [ExtensionAttribute]
internal static bool IsBoolOrNullableBool(XamlType xamlType);
    private static DirectUIXamlType GetDirectUIXamlType(XamlType type);
    private static bool CacheImplicitCast(Type source, Type target, bool castable);
    private static bool IsImplicitlyCastableTo(Type source, Type target);
    [ExtensionAttribute]
internal static bool CanAssignDirectlyTo(XamlType source, XamlType target);
    [ExtensionAttribute]
internal static bool CanAssignDirectlyTo(XamlType source, Type targetType);
    [ExtensionAttribute]
internal static bool CanAssignDirectlyTo(Type sourceType, Type targetType);
    [ExtensionAttribute]
internal static bool CanAssignDirectlyWithNoImplicitCast(XamlType source, Type targetType);
    [ExtensionAttribute]
internal static bool CanAssignDirectlyWithNoImplicitCast(Type sourceType, Type targetType);
    [ExtensionAttribute]
internal static bool CanBoxTo(XamlType source, XamlType target);
    [ExtensionAttribute]
internal static bool CanInlineConvert(XamlType source, XamlType target);
    [ExtensionAttribute]
public static LanguageSpecificString GetInlineConversionExpression(XamlType source, XamlType target, LanguageSpecificString memberExpression);
    [ExtensionAttribute]
internal static LanguageSpecificString GetInlineConversionFormats(XamlType source, XamlType target);
    [ExtensionAttribute]
internal static bool IsEnum(XamlType source);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.MoreXamlTypeExtensions/<GetEnumNames>d__38")]
[ExtensionAttribute]
internal static IEnumerable`1<string> GetEnumNames(XamlType source);
    [ExtensionAttribute]
public static bool IsNullExtension(XamlType instance);
    [ExtensionAttribute]
public static string GetVBCastName(XamlType source, Type targetType);
    [ExtensionAttribute]
public static bool IsContractVersionAttribute(Type type);
    [ExtensionAttribute]
internal static bool HasCreateFromStringMethod(XamlType type);
    [ExtensionAttribute]
internal static bool HasMember(XamlType type, string name);
    [ExtensionAttribute]
internal static CreateFromStringMethod GetCreateFromStringMethod(XamlType type);
    [ExtensionAttribute]
internal static XamlCompileError EnsureCreateFromStringResolved(DirectUISchemaContext schemaContext, string declaringTypeName, CreateFromStringMethod createMethod, XamlDomNode locationForErrors);
    [ExtensionAttribute]
public static string NameWithApiInformation(XamlMember member);
    [ExtensionAttribute]
public static LanguageSpecificString GetStringToThing(XamlType type, string valueName, bool isLiteral);
    [ExtensionAttribute]
public static LanguageSpecificString GetStringToThing(XamlType type, LanguageSpecificString valueName, bool isLiteral);
    [ExtensionAttribute]
public static LanguageSpecificString ToStringWithNullCheckExpression(XamlType type, LanguageSpecificString expression);
    [ExtensionAttribute]
public static bool NeedsBoxUnbox(XamlType instance);
    [ExtensionAttribute]
public static string CppWinRTCast(XamlType source, XamlType target, string expression);
    [ExtensionAttribute]
public static string CppWinRTLocalElseRef(XamlType type);
    [ExtensionAttribute]
public static bool HasFullXamlMetadataProviderAttribute(Type type);
    [ExtensionAttribute]
public static bool IsBoxedType(XamlType type);
    [ExtensionAttribute]
public static bool IsBoxedType(Type type);
    [ExtensionAttribute]
public static Type GetBoxedType(XamlType type);
    [ExtensionAttribute]
public static Type GetBoxedType(Type type);
    [ExtensionAttribute]
public static string TryGetInputPropertyName(XamlType type);
}
public class Microsoft.UI.Xaml.Markup.Compiler.Parameter : object {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOut>k__BackingField;
    public int Position { get; protected set; }
    public Type ParameterType { get; protected set; }
    public bool IsOut { get; protected set; }
    public string Name { get; }
    public Parameter(ParameterInfo parameterInfo);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
protected void set_Position(int value);
    [CompilerGeneratedAttribute]
public Type get_ParameterType();
    [CompilerGeneratedAttribute]
protected void set_ParameterType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsOut();
    [CompilerGeneratedAttribute]
protected void set_IsOut(bool value);
    public void CopyFrom(Parameter param);
    public string get_Name();
}
public class Microsoft.UI.Xaml.Markup.Compiler.ParseException : Exception {
    public ParseException(string unformatted, Object[] args);
    private static string FormatMessage(string unformatted, Object[] args);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Parsing.BailErrorStrategy : DefaultErrorStrategy {
    public virtual void Recover(Parser recognizer, RecognitionException e);
    public virtual IToken RecoverInline(Parser recognizer);
    public virtual void Sync(Parser recognizer);
}
[ExtensionAttribute]
internal static class Microsoft.UI.Xaml.Markup.Compiler.Parsing.BindingPathLexerExtensions : object {
    [ExtensionAttribute]
public static void ConfirmInputFullyConsumed(BindingPathLexer lexer);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Parsing.BindingPathListener : BindingPathBaseListener {
    private string pathExpression;
    private IXamlTypeResolver resolver;
    private IBindUniverse bindUniverse;
    private ApiInformation apiInformation;
    [CompilerGeneratedAttribute]
private IList`1<string> <Warnings>k__BackingField;
    public IList`1<string> Warnings { get; public set; }
    public BindingPathListener(string pathExpression, ApiInformation apiInformation, IBindUniverse bindUniverse, IXamlTypeResolver resolver);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Warnings();
    [CompilerGeneratedAttribute]
public void set_Warnings(IList`1<string> value);
    public virtual void ExitPathIdentifier(PathIdentifierContext context);
    public virtual void ExitPathDotIdentifier(PathDotIdentifierContext context);
    public virtual void ExitPathStaticIdentifier(PathStaticIdentifierContext context);
    public virtual void ExitPathIndexer(PathIndexerContext context);
    public virtual void ExitPathStringIndexer(PathStringIndexerContext context);
    public virtual void ExitPathDotAttached(PathDotAttachedContext context);
    public virtual void ExitPathCastInvalid(PathCastInvalidContext context);
    public virtual void ExitPathCast(PathCastContext context);
    public virtual void ExitPathCastPath(PathCastPathContext context);
    public virtual void ExitPathCastPathParen(PathCastPathParenContext context);
    public virtual void ExitPathFunction(PathFunctionContext context);
    public virtual void ExitPathStaticFuction(PathStaticFuctionContext context);
    public virtual void ExitPathPathToFunction(PathPathToFunctionContext context);
    public virtual void ExitFunctionParameterInvalid(FunctionParameterInvalidContext context);
    public virtual void ExitFunctionParamPath(FunctionParamPathContext context);
    public virtual void ExitFunctionParamBool(FunctionParamBoolContext context);
    public virtual void ExitFunctionParamNumber(FunctionParamNumberContext context);
    public virtual void ExitFunctionParamString(FunctionParamStringContext context);
    public virtual void ExitFunctionParamNullValue(FunctionParamNullValueContext context);
    private BindPathStep CreateStaticRootStep(Static_typeContext static_type);
    private BindPathStep CreateCastStep(Cast_exprContext castExp, BindPathStep parentStep);
    private BindPathStep CreateFunctionStep(MethodStep method, Function_paramContext[] paramArray);
    private XamlType GetDirectPropertyOrFieldType(XamlType sourceType, string propertyName);
    private static string UnescapeAndStripQuotes(string quotedString);
    private BindPathStep EnsureNotFunction(BindPathStep step);
    private BindPathStep ResolveNameOnRoot(string name);
    private BindPathStep ResolveNameOnType(string name, XamlType type, BindPathStep parentStep);
    private MemberInfo[] GetMembers(Type type, string name);
}
[ExtensionAttribute]
internal static class Microsoft.UI.Xaml.Markup.Compiler.Parsing.ConditionalNamespaceLexerExtensions : object {
    [ExtensionAttribute]
public static void ConfirmInputFullyConsumed(ConditionalNamespaceLexer lexer);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Parsing.ConditionalNamespaceListener : ConditionalNamespaceBaseListener {
    private string expresion;
    public ConditionalNamespaceListener(string expresion);
    public virtual void ExitExpression(ExpressionContext context);
    public virtual void ExitQuery_string(Query_stringContext context);
    public virtual void ExitQueryStringApiInformation(QueryStringApiInformationContext context);
    public virtual void ExitQueryStringTargetPlatform(QueryStringTargetPlatformContext context);
    public virtual void ExitTarget_platform_func(Target_platform_funcContext context);
    public virtual void ExitApi_information(Api_informationContext context);
    public virtual void ExitFunction_param(Function_paramContext context);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Parsing.ParseErrorListener : BaseErrorListener {
    public virtual void SyntaxError(IRecognizer recognizer, IToken offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.PhaseAssignment : object {
    [CompilerGeneratedAttribute]
private ConnectionIdElement <ConnectionIdElement>k__BackingField;
    [CompilerGeneratedAttribute]
private LineNumberInfo <LineNumberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Phase>k__BackingField;
    public ConnectionIdElement ConnectionIdElement { get; private set; }
    public LineNumberInfo LineNumberInfo { get; public set; }
    public int Phase { get; public set; }
    public PhaseAssignment(XamlDomMember phaseMember, ConnectionIdElement connectionIdElement);
    [CompilerGeneratedAttribute]
public ConnectionIdElement get_ConnectionIdElement();
    [CompilerGeneratedAttribute]
private void set_ConnectionIdElement(ConnectionIdElement value);
    [CompilerGeneratedAttribute]
public sealed virtual LineNumberInfo get_LineNumberInfo();
    [CompilerGeneratedAttribute]
public void set_LineNumberInfo(LineNumberInfo value);
    [CompilerGeneratedAttribute]
public int get_Phase();
    [CompilerGeneratedAttribute]
public void set_Phase(int value);
    public sealed virtual XamlCompileError GetAttributeProcessingError();
    public sealed virtual int CompareTo(PhaseAssignment other);
}
public enum Microsoft.UI.Xaml.Markup.Compiler.Platform : Enum {
    public int value__;
    public static Platform Any;
    public static Platform UWP;
    public static Platform iOS;
    public static Platform Android;
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.ProgrammingLanguage : object {
    public static string CSharp;
    public static string VB;
    public static string CppCX;
    public static string CppWinRT;
    public static string IdlWinRT;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string BindAssignment_BindBack_InvalidMethod { get; }
    internal static string BindAssignment_BindBack_NotFound { get; }
    internal static string BindAssignment_BindBack_NotMethod { get; }
    internal static string BindAssignment_BindBack_Unexpected { get; }
    internal static string BindAssignment_CastCannotStartWithAttachedProperty { get; }
    internal static string BindAssignment_ConverterWithFunctionBindingNotSupported { get; }
    internal static string BindAssignment_FieldNameElementName_Conflict { get; }
    internal static string BindAssignment_FieldNameElementName_ConflictBadConfig { get; }
    internal static string BindAssignment_FunctionReturnTypeInvalid { get; }
    internal static string BindAssignment_InvalidCast { get; }
    internal static string BindAssignment_InvalidFallbackValue { get; }
    internal static string BindAssignment_InvalidPropertyPathSyntax { get; }
    internal static string BindAssignment_NeedsConverter { get; }
    internal static string BindAssignment_OneWay_NoWay { get; }
    internal static string BindAssignment_OrphanConverterParam { get; }
    internal static string BindAssignment_RequiresConditionalNamespace { get; }
    internal static string BindAssignment_UpdateSourceTrigger_ExplicitUnsupported { get; }
    internal static string BindAssignment_UpdateSourceTrigger_LostFocusEventRequired { get; }
    internal static string BindAssignment_UpdateSourceTrigger_PropertyChangedOnlyOnDP { get; }
    internal static string BindAssignment_UpdateSourceTrigger_UnrecognizedValue { get; }
    internal static string BindAssignment_UpdateSourceTrigger_UpdateSourceTriggerOnlyWithTwoWay { get; }
    internal static string BindAssignment_XamlXBindAssignmentValidationError { get; }
    internal static string BindAssignment_XamlXBindParseError { get; }
    internal static string BindAssignment_XamlXBindUsedInStyleError { get; }
    internal static string BindPathParser_CantBindToMethods { get; }
    internal static string BindPathParser_CantTwoWayCastStep { get; }
    internal static string BindPathParser_PathSetTwice { get; }
    internal static string BindPathParser_UnexpectedReflectionType { get; }
    internal static string BoundEventAssignment_InvalidSignature { get; }
    internal static string BoundEventAssignment_NonDelegateProperty { get; }
    internal static string BoundEventAssignment_NonLeafMethod { get; }
    internal static string BoundEventAssignment_NoOverloads { get; }
    internal static string BoundEventAssignment_SignatureMismatch { get; }
    internal static string ConditionalNamespace_ConditionalInStandard { get; }
    internal static string ConditionalNamespace_FailedToParse { get; }
    internal static string ConditionalNamespace_MultipleApiInformations { get; }
    internal static string ConditionalNamespace_MultipleTargetPlatforms { get; }
    internal static string ConditionalNamespace_UnmatchedApiInformationParameters { get; }
    internal static string ConditionalNamespace_UnrecognizedApiInformation { get; }
    internal static string CppCodeGen_MissingMember { get; }
    internal static string CreateFromString_InvalidMethodSignature { get; }
    internal static string CreateFromString_MethodOnTypeNotFound { get; }
    internal static string CreateFromString_TypeNotFound { get; }
    internal static string DuiSchema_AmbiguousCollectionAdd { get; }
    internal static string DuiSchema_ArgumentNotXamlDirective { get; }
    internal static string DuiSchema_BadBindablePropertyProvider { get; }
    internal static string DuiSchema_BindableNotSupportedOnGeneric { get; }
    internal static string DuiSchema_CustomAttributesTypeLoadException { get; }
    internal static string DuiSchema_GetAllXamlTypeNotImpl { get; }
    internal static string DuiSchema_TypeLoadException { get; }
    internal static string DuiSchema_TypeLoadExceptionMessage { get; }
    internal static string DuiSchema_WRTAssembliesMissing { get; }
    internal static string Harvester_ClassMustHaveANamespace { get; }
    internal static string Harvester_ClassNameEmptyPathPart { get; }
    internal static string Harvester_ClassNameNoWhiteSpace { get; }
    internal static string Harvester_ControlTemplateDoesNotDefineTargetType { get; }
    internal static string Harvester_DataTemplateDoesNotDefineDataType { get; }
    internal static string Harvester_ProjectFolderIsNotADirectory { get; }
    internal static string TypeInfoReflection_TypeViolatesNamingConvention { get; }
    internal static string XamlCompiler_BadName { get; }
    internal static string XamlCompiler_BadNameChar { get; }
    internal static string XamlCompiler_BadValueInSupressWarningsList { get; }
    internal static string XamlCompiler_BaseFilenamesMustBeTheSame { get; }
    internal static string XamlCompiler_BindingSetValueFailed { get; }
    internal static string XamlCompiler_BindingUpdateFailed { get; }
    internal static string XamlCompiler_CannotHaveDeferLoadStrategy { get; }
    internal static string XamlCompiler_CannotNameElementTwice { get; }
    internal static string XamlCompiler_CantAccessNonPublicType { get; }
    internal static string XamlCompiler_CantAddToCollectionObject { get; }
    internal static string XamlCompiler_CantAddToCollectionProperty { get; }
    internal static string XamlCompiler_CantAddToDictionaryObject { get; }
    internal static string XamlCompiler_CantAddToDictionaryProperty { get; }
    internal static string XamlCompiler_CantAssign { get; }
    internal static string XamlCompiler_CantAssignTextToProperty { get; }
    internal static string XamlCompiler_CantAssignToReadOnlyProperty { get; }
    internal static string XamlCompiler_CantNameValueTypes { get; }
    internal static string XamlCompiler_CantResolveAssembly { get; }
    internal static string XamlCompiler_CantResolveDataType { get; }
    internal static string XamlCompiler_CantResolveWinUIMetadata { get; }
    internal static string XamlCompiler_CodeGenStaticAssert_IncompleteType { get; }
    internal static string XamlCompiler_CodeGenStaticAssert_IncompleteType_NoPch { get; }
    internal static string XamlCompiler_CodeGenString_Bad { get; }
    internal static string XamlCompiler_CodeGenString_NotSupported { get; }
    internal static string XamlCompiler_CodeGenString_Using { get; }
    internal static string XamlCompiler_CodeLangNotSupported { get; }
    internal static string XamlCompiler_DeferLoadStrategyMissingXName { get; }
    internal static string XamlCompiler_Deprecated { get; }
    internal static string XamlCompiler_DictionaryItemsCannotBeText { get; }
    internal static string XamlCompiler_DictionaryItemsHasDuplicateKey { get; }
    internal static string XamlCompiler_DictionaryItemsMustHaveKeys { get; }
    internal static string XamlCompiler_DuplicateTypeName { get; }
    internal static string XamlCompiler_DuplicationAssignment { get; }
    internal static string XamlCompiler_ElementNameAlreadyUsed { get; }
    internal static string XamlCompiler_EventValuesMustBeText { get; }
    internal static string XamlCompiler_Experimental { get; }
    internal static string XamlCompiler_FeatureNotInMinVersion { get; }
    internal static string XamlCompiler_FeatureOnlyInTargetVersion { get; }
    internal static string XamlCompiler_FileOpenFailure { get; }
    internal static string XamlCompiler_IdPropertiesMustBeText { get; }
    internal static string XamlCompiler_InternalErrorProcessingStyle { get; }
    internal static string XamlCompiler_InvalidCPA { get; }
    internal static string XamlCompiler_InvalidFieldModifier { get; }
    internal static string XamlCompiler_InvalidPropertyType { get; }
    internal static string XamlCompiler_InvalidSignedChar { get; }
    internal static string XamlCompiler_InvalidValueForPhase { get; }
    internal static string XamlCompiler_LanguageUnsupported { get; }
    internal static string XamlCompiler_LoadConflict { get; }
    internal static string XamlCompiler_LoadMissingName { get; }
    internal static string XamlCompiler_LoadNotSupported { get; }
    internal static string XamlCompiler_LocalAssemblyMissingWarning { get; }
    internal static string XamlCompiler_MemberContractDoesNotExist { get; }
    internal static string XamlCompiler_MissingCPA { get; }
    internal static string XamlCompiler_MoreThanOneApplicationXaml { get; }
    internal static string XamlCompiler_MustNotSetLocalAssembly { get; }
    internal static string XamlCompiler_MustSetLocalAssembly { get; }
    internal static string XamlCompiler_NoEventsInAppXaml { get; }
    internal static string XamlCompiler_NotConstructibleObj { get; }
    internal static string XamlCompiler_NoXamlGiven { get; }
    internal static string XamlCompiler_NullablePropertyType { get; }
    internal static string XamlCompiler_OnlyOneLocalAssembly { get; }
    internal static string XamlCompiler_PhaseMustBeUsedWithinADataTemplate { get; }
    internal static string XamlCompiler_PhaseMustHaveAssociatedBind { get; }
    internal static string XamlCompiler_PlatformUnsupported { get; }
    internal static string XamlCompiler_Preview { get; }
    internal static string XamlCompiler_SetterMustHaveValue { get; }
    internal static string XamlCompiler_SetterPropertyMustBeDP { get; }
    internal static string XamlCompiler_SettersMustHaveProperty { get; }
    internal static string XamlCompiler_SetterValueWrongType { get; }
    internal static string XamlCompiler_StyleBasedOnBadStyleTargetType { get; }
    internal static string XamlCompiler_StyleBasedOnMustBeStyle_BadObj { get; }
    internal static string XamlCompiler_StyleBasedOnMustBeStyle_SR { get; }
    internal static string XamlCompiler_StyleBasedOnMustBeStyle_Text { get; }
    internal static string XamlCompiler_StyleMustHaveTargetType { get; }
    internal static string XamlCompiler_TwoWayTargetNotADependencyProperty { get; }
    internal static string XamlCompiler_TypeContractDoesNotExist { get; }
    internal static string XamlCompiler_TypeMustHaveANamespace { get; }
    internal static string XamlCompiler_UnknownAttachableMember { get; }
    internal static string XamlCompiler_UnknownMember { get; }
    internal static string XamlCompiler_UnknownObject { get; }
    internal static string XamlCompiler_UnknownSetterAttachableMember { get; }
    internal static string XamlCompiler_UnknownStyleTargetType { get; }
    internal static string XamlCompiler_UnknownTypeError { get; }
    internal static string XamlCompiler_UnresolvedForwardedTypeAssembly { get; }
    internal static string XamlCompiler_WrongMemberContract { get; }
    internal static string XamlCompiler_WrongTypeContract { get; }
    internal static string XamlCompiler_XamlFileMustEndInDotXaml { get; }
    internal static string XamlCompiler_XamlFilesHaveTheSameName { get; }
    internal static string XamlCompiler_XBindInsideXBind { get; }
    internal static string XamlCompiler_XBindOnControlTemplate { get; }
    internal static string XamlCompiler_XBindOutOfScopeUnsupported { get; }
    internal static string XamlCompiler_XBindRootMustHaveLoading { get; }
    internal static string XamlCompiler_XBindTargetNullValueOnNonNullableType { get; }
    internal static string XamlCompiler_XBindWithoutCodeBehind { get; }
    internal static string XamlCompiler_XClassDerivesFromXClass { get; }
    internal static string XamlCompiler_xClassTypeDoesntMatchWinmd { get; }
    internal static string XamlCompiler_xClassTypeIsNotFound { get; }
    internal static string XamlCompiler_XPropertyUsageNotSupportedForLanguage { get; }
    internal static string XamlDom_IncorrectMemberConstructor { get; }
    internal static string XamlDom_MemberDifferentSchemas { get; }
    internal static string XamlDom_MemberHasMoreThanOneItem { get; }
    internal static string XamlDom_SealedNamespaceCollection { get; }
    internal static string XamlDom_SealedXamlDomNode { get; }
    internal static string XamlDom_TypeDifferentSchemas { get; }
    internal static string XamlDom_UnknownAttachableMember { get; }
    internal static string XamlDom_UseHasAttachedMember { get; }
    internal static string XamlDom_UseHasGetAttachedMember { get; }
    internal static string XamlInternlError { get; }
    internal static string XamlRewriter_CompiledBindingsCannotBeInElementForm { get; }
    internal static string XamlRewriter_EventsAcrossLine { get; }
    internal static string XamlRewriter_EventsCannotBeInElementForm { get; }
    internal static string XamlRewriter_XamlRewriterErrorDataTypeLongForm { get; }
    internal static string XamlValidationError_AmbiguousEvent { get; }
    internal static string XamlValidationError_DataTypeOnlyAllowedOnDataTemplate { get; }
    internal static string XamlValidationError_DefaultBindModeInvalidValue { get; }
    internal static string XamlValidationError_DeferLoadStrategyInvalidValue { get; }
    internal static string XamlValidationError_InvalidAttributeValue { get; }
    internal static string XamlValidationError_SuccinctSyntaxError { get; }
    internal static string XamlXmlParsingError { get; }
    internal static string XbfGeneration_CouldNotLoadXbfGenerator { get; }
    internal static string XbfGeneration_GeneralFailure { get; }
    internal static string XbfGeneration_MissingGenXbfPath { get; }
    internal static string XbfGeneration_MissingXbfApi { get; }
    internal static string XbfGeneration_PropertyNotFoundError { get; }
    internal static string XbfGeneration_SyntaxError { get; }
    internal static string XbfGeneration_SyntaxErrorME { get; }
    internal static string XbfGeneration_XamlInputFileOpenFailure { get; }
    internal static string XbfGeneration_XbfOutputFileOpenFailure { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_BindAssignment_BindBack_InvalidMethod();
    internal static string get_BindAssignment_BindBack_NotFound();
    internal static string get_BindAssignment_BindBack_NotMethod();
    internal static string get_BindAssignment_BindBack_Unexpected();
    internal static string get_BindAssignment_CastCannotStartWithAttachedProperty();
    internal static string get_BindAssignment_ConverterWithFunctionBindingNotSupported();
    internal static string get_BindAssignment_FieldNameElementName_Conflict();
    internal static string get_BindAssignment_FieldNameElementName_ConflictBadConfig();
    internal static string get_BindAssignment_FunctionReturnTypeInvalid();
    internal static string get_BindAssignment_InvalidCast();
    internal static string get_BindAssignment_InvalidFallbackValue();
    internal static string get_BindAssignment_InvalidPropertyPathSyntax();
    internal static string get_BindAssignment_NeedsConverter();
    internal static string get_BindAssignment_OneWay_NoWay();
    internal static string get_BindAssignment_OrphanConverterParam();
    internal static string get_BindAssignment_RequiresConditionalNamespace();
    internal static string get_BindAssignment_UpdateSourceTrigger_ExplicitUnsupported();
    internal static string get_BindAssignment_UpdateSourceTrigger_LostFocusEventRequired();
    internal static string get_BindAssignment_UpdateSourceTrigger_PropertyChangedOnlyOnDP();
    internal static string get_BindAssignment_UpdateSourceTrigger_UnrecognizedValue();
    internal static string get_BindAssignment_UpdateSourceTrigger_UpdateSourceTriggerOnlyWithTwoWay();
    internal static string get_BindAssignment_XamlXBindAssignmentValidationError();
    internal static string get_BindAssignment_XamlXBindParseError();
    internal static string get_BindAssignment_XamlXBindUsedInStyleError();
    internal static string get_BindPathParser_CantBindToMethods();
    internal static string get_BindPathParser_CantTwoWayCastStep();
    internal static string get_BindPathParser_PathSetTwice();
    internal static string get_BindPathParser_UnexpectedReflectionType();
    internal static string get_BoundEventAssignment_InvalidSignature();
    internal static string get_BoundEventAssignment_NonDelegateProperty();
    internal static string get_BoundEventAssignment_NonLeafMethod();
    internal static string get_BoundEventAssignment_NoOverloads();
    internal static string get_BoundEventAssignment_SignatureMismatch();
    internal static string get_ConditionalNamespace_ConditionalInStandard();
    internal static string get_ConditionalNamespace_FailedToParse();
    internal static string get_ConditionalNamespace_MultipleApiInformations();
    internal static string get_ConditionalNamespace_MultipleTargetPlatforms();
    internal static string get_ConditionalNamespace_UnmatchedApiInformationParameters();
    internal static string get_ConditionalNamespace_UnrecognizedApiInformation();
    internal static string get_CppCodeGen_MissingMember();
    internal static string get_CreateFromString_InvalidMethodSignature();
    internal static string get_CreateFromString_MethodOnTypeNotFound();
    internal static string get_CreateFromString_TypeNotFound();
    internal static string get_DuiSchema_AmbiguousCollectionAdd();
    internal static string get_DuiSchema_ArgumentNotXamlDirective();
    internal static string get_DuiSchema_BadBindablePropertyProvider();
    internal static string get_DuiSchema_BindableNotSupportedOnGeneric();
    internal static string get_DuiSchema_CustomAttributesTypeLoadException();
    internal static string get_DuiSchema_GetAllXamlTypeNotImpl();
    internal static string get_DuiSchema_TypeLoadException();
    internal static string get_DuiSchema_TypeLoadExceptionMessage();
    internal static string get_DuiSchema_WRTAssembliesMissing();
    internal static string get_Harvester_ClassMustHaveANamespace();
    internal static string get_Harvester_ClassNameEmptyPathPart();
    internal static string get_Harvester_ClassNameNoWhiteSpace();
    internal static string get_Harvester_ControlTemplateDoesNotDefineTargetType();
    internal static string get_Harvester_DataTemplateDoesNotDefineDataType();
    internal static string get_Harvester_ProjectFolderIsNotADirectory();
    internal static string get_TypeInfoReflection_TypeViolatesNamingConvention();
    internal static string get_XamlCompiler_BadName();
    internal static string get_XamlCompiler_BadNameChar();
    internal static string get_XamlCompiler_BadValueInSupressWarningsList();
    internal static string get_XamlCompiler_BaseFilenamesMustBeTheSame();
    internal static string get_XamlCompiler_BindingSetValueFailed();
    internal static string get_XamlCompiler_BindingUpdateFailed();
    internal static string get_XamlCompiler_CannotHaveDeferLoadStrategy();
    internal static string get_XamlCompiler_CannotNameElementTwice();
    internal static string get_XamlCompiler_CantAccessNonPublicType();
    internal static string get_XamlCompiler_CantAddToCollectionObject();
    internal static string get_XamlCompiler_CantAddToCollectionProperty();
    internal static string get_XamlCompiler_CantAddToDictionaryObject();
    internal static string get_XamlCompiler_CantAddToDictionaryProperty();
    internal static string get_XamlCompiler_CantAssign();
    internal static string get_XamlCompiler_CantAssignTextToProperty();
    internal static string get_XamlCompiler_CantAssignToReadOnlyProperty();
    internal static string get_XamlCompiler_CantNameValueTypes();
    internal static string get_XamlCompiler_CantResolveAssembly();
    internal static string get_XamlCompiler_CantResolveDataType();
    internal static string get_XamlCompiler_CantResolveWinUIMetadata();
    internal static string get_XamlCompiler_CodeGenStaticAssert_IncompleteType();
    internal static string get_XamlCompiler_CodeGenStaticAssert_IncompleteType_NoPch();
    internal static string get_XamlCompiler_CodeGenString_Bad();
    internal static string get_XamlCompiler_CodeGenString_NotSupported();
    internal static string get_XamlCompiler_CodeGenString_Using();
    internal static string get_XamlCompiler_CodeLangNotSupported();
    internal static string get_XamlCompiler_DeferLoadStrategyMissingXName();
    internal static string get_XamlCompiler_Deprecated();
    internal static string get_XamlCompiler_DictionaryItemsCannotBeText();
    internal static string get_XamlCompiler_DictionaryItemsHasDuplicateKey();
    internal static string get_XamlCompiler_DictionaryItemsMustHaveKeys();
    internal static string get_XamlCompiler_DuplicateTypeName();
    internal static string get_XamlCompiler_DuplicationAssignment();
    internal static string get_XamlCompiler_ElementNameAlreadyUsed();
    internal static string get_XamlCompiler_EventValuesMustBeText();
    internal static string get_XamlCompiler_Experimental();
    internal static string get_XamlCompiler_FeatureNotInMinVersion();
    internal static string get_XamlCompiler_FeatureOnlyInTargetVersion();
    internal static string get_XamlCompiler_FileOpenFailure();
    internal static string get_XamlCompiler_IdPropertiesMustBeText();
    internal static string get_XamlCompiler_InternalErrorProcessingStyle();
    internal static string get_XamlCompiler_InvalidCPA();
    internal static string get_XamlCompiler_InvalidFieldModifier();
    internal static string get_XamlCompiler_InvalidPropertyType();
    internal static string get_XamlCompiler_InvalidSignedChar();
    internal static string get_XamlCompiler_InvalidValueForPhase();
    internal static string get_XamlCompiler_LanguageUnsupported();
    internal static string get_XamlCompiler_LoadConflict();
    internal static string get_XamlCompiler_LoadMissingName();
    internal static string get_XamlCompiler_LoadNotSupported();
    internal static string get_XamlCompiler_LocalAssemblyMissingWarning();
    internal static string get_XamlCompiler_MemberContractDoesNotExist();
    internal static string get_XamlCompiler_MissingCPA();
    internal static string get_XamlCompiler_MoreThanOneApplicationXaml();
    internal static string get_XamlCompiler_MustNotSetLocalAssembly();
    internal static string get_XamlCompiler_MustSetLocalAssembly();
    internal static string get_XamlCompiler_NoEventsInAppXaml();
    internal static string get_XamlCompiler_NotConstructibleObj();
    internal static string get_XamlCompiler_NoXamlGiven();
    internal static string get_XamlCompiler_NullablePropertyType();
    internal static string get_XamlCompiler_OnlyOneLocalAssembly();
    internal static string get_XamlCompiler_PhaseMustBeUsedWithinADataTemplate();
    internal static string get_XamlCompiler_PhaseMustHaveAssociatedBind();
    internal static string get_XamlCompiler_PlatformUnsupported();
    internal static string get_XamlCompiler_Preview();
    internal static string get_XamlCompiler_SetterMustHaveValue();
    internal static string get_XamlCompiler_SetterPropertyMustBeDP();
    internal static string get_XamlCompiler_SettersMustHaveProperty();
    internal static string get_XamlCompiler_SetterValueWrongType();
    internal static string get_XamlCompiler_StyleBasedOnBadStyleTargetType();
    internal static string get_XamlCompiler_StyleBasedOnMustBeStyle_BadObj();
    internal static string get_XamlCompiler_StyleBasedOnMustBeStyle_SR();
    internal static string get_XamlCompiler_StyleBasedOnMustBeStyle_Text();
    internal static string get_XamlCompiler_StyleMustHaveTargetType();
    internal static string get_XamlCompiler_TwoWayTargetNotADependencyProperty();
    internal static string get_XamlCompiler_TypeContractDoesNotExist();
    internal static string get_XamlCompiler_TypeMustHaveANamespace();
    internal static string get_XamlCompiler_UnknownAttachableMember();
    internal static string get_XamlCompiler_UnknownMember();
    internal static string get_XamlCompiler_UnknownObject();
    internal static string get_XamlCompiler_UnknownSetterAttachableMember();
    internal static string get_XamlCompiler_UnknownStyleTargetType();
    internal static string get_XamlCompiler_UnknownTypeError();
    internal static string get_XamlCompiler_UnresolvedForwardedTypeAssembly();
    internal static string get_XamlCompiler_WrongMemberContract();
    internal static string get_XamlCompiler_WrongTypeContract();
    internal static string get_XamlCompiler_XamlFileMustEndInDotXaml();
    internal static string get_XamlCompiler_XamlFilesHaveTheSameName();
    internal static string get_XamlCompiler_XBindInsideXBind();
    internal static string get_XamlCompiler_XBindOnControlTemplate();
    internal static string get_XamlCompiler_XBindOutOfScopeUnsupported();
    internal static string get_XamlCompiler_XBindRootMustHaveLoading();
    internal static string get_XamlCompiler_XBindTargetNullValueOnNonNullableType();
    internal static string get_XamlCompiler_XBindWithoutCodeBehind();
    internal static string get_XamlCompiler_XClassDerivesFromXClass();
    internal static string get_XamlCompiler_xClassTypeDoesntMatchWinmd();
    internal static string get_XamlCompiler_xClassTypeIsNotFound();
    internal static string get_XamlCompiler_XPropertyUsageNotSupportedForLanguage();
    internal static string get_XamlDom_IncorrectMemberConstructor();
    internal static string get_XamlDom_MemberDifferentSchemas();
    internal static string get_XamlDom_MemberHasMoreThanOneItem();
    internal static string get_XamlDom_SealedNamespaceCollection();
    internal static string get_XamlDom_SealedXamlDomNode();
    internal static string get_XamlDom_TypeDifferentSchemas();
    internal static string get_XamlDom_UnknownAttachableMember();
    internal static string get_XamlDom_UseHasAttachedMember();
    internal static string get_XamlDom_UseHasGetAttachedMember();
    internal static string get_XamlInternlError();
    internal static string get_XamlRewriter_CompiledBindingsCannotBeInElementForm();
    internal static string get_XamlRewriter_EventsAcrossLine();
    internal static string get_XamlRewriter_EventsCannotBeInElementForm();
    internal static string get_XamlRewriter_XamlRewriterErrorDataTypeLongForm();
    internal static string get_XamlValidationError_AmbiguousEvent();
    internal static string get_XamlValidationError_DataTypeOnlyAllowedOnDataTemplate();
    internal static string get_XamlValidationError_DefaultBindModeInvalidValue();
    internal static string get_XamlValidationError_DeferLoadStrategyInvalidValue();
    internal static string get_XamlValidationError_InvalidAttributeValue();
    internal static string get_XamlValidationError_SuccinctSyntaxError();
    internal static string get_XamlXmlParsingError();
    internal static string get_XbfGeneration_CouldNotLoadXbfGenerator();
    internal static string get_XbfGeneration_GeneralFailure();
    internal static string get_XbfGeneration_MissingGenXbfPath();
    internal static string get_XbfGeneration_MissingXbfApi();
    internal static string get_XbfGeneration_PropertyNotFoundError();
    internal static string get_XbfGeneration_SyntaxError();
    internal static string get_XbfGeneration_SyntaxErrorME();
    internal static string get_XbfGeneration_XamlInputFileOpenFailure();
    internal static string get_XbfGeneration_XbfOutputFileOpenFailure();
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.PropertyPathParser : object {
    public static bool Parse(string input, List`1& qualifiedProperties, List`1& names);
    private static bool SplitOnParens(string input, String& before, String& inside, String& after);
    private static bool RemoveBrackets(string input, String& result);
}
public class Microsoft.UI.Xaml.Markup.Compiler.PropertyStep : BindPathStep {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; }
    public string UniqueName { get; }
    public bool IsValueRequired { get; }
    public PropertyStep(string name, XamlType valueType, BindPathStep parent, ApiInformation apiInformation);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    public virtual string get_UniqueName();
    public virtual bool get_IsValueRequired();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.ReleaseDefinition : object {
    public static Version MaxSupportedVersion;
    private static ReleaseDefinition();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.RootLog.RootEvent : RootMember {
}
internal class Microsoft.UI.Xaml.Markup.Compiler.RootLog.RootInterface : object {
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    public string FullName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public void set_FullName(string value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.RootLog.RootLogBuilder : object {
    private Dictionary`2<string, RootTypeBuilder> _typeDict;
    private Dictionary`2<string, RootPropertyPathName> _propertyPathNameDict;
    private Dictionary`2<string, RootInterface> _interfaceDict;
    private bool _haveEntered_IValueConverter;
    private bool _haveEntered_IXamlMetadataProvider;
    public Roots GetRoots();
    public RootInterface AddInterface(string name);
    public RootPropertyPathName AddPropertyPathName(string name);
    public RootTypeBuilder AddTypeBuilder(DirectUIXamlType duiType);
    public RootMember AddProperty(DirectUIXamlType duiType, string name);
    public RootMember AddEvent(DirectUIXamlType duiType, string name);
    private void CheckTypeForInterfaces(DirectUIXamlType duiType);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.RootLog.RootMember : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.RootLog.RootMethod : RootMember {
}
internal class Microsoft.UI.Xaml.Markup.Compiler.RootLog.RootProperty : RootMember {
}
internal class Microsoft.UI.Xaml.Markup.Compiler.RootLog.RootPropertyPathName : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.RootLog.Roots : object {
    [CompilerGeneratedAttribute]
private List`1<RootType> <RootTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RootPropertyPathName> <PropertyPathNames>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RootInterface> <Interfaces>k__BackingField;
    public List`1<RootType> RootTypes { get; private set; }
    public List`1<RootPropertyPathName> PropertyPathNames { get; private set; }
    public List`1<RootInterface> Interfaces { get; private set; }
    [CompilerGeneratedAttribute]
public List`1<RootType> get_RootTypes();
    [CompilerGeneratedAttribute]
private void set_RootTypes(List`1<RootType> value);
    [CompilerGeneratedAttribute]
public List`1<RootPropertyPathName> get_PropertyPathNames();
    [CompilerGeneratedAttribute]
private void set_PropertyPathNames(List`1<RootPropertyPathName> value);
    [CompilerGeneratedAttribute]
public List`1<RootInterface> get_Interfaces();
    [CompilerGeneratedAttribute]
private void set_Interfaces(List`1<RootInterface> value);
}
[ContentPropertyAttribute("Members")]
internal class Microsoft.UI.Xaml.Markup.Compiler.RootLog.RootType : object {
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RootMember> <Members>k__BackingField;
    public string FullName { get; public set; }
    public List`1<RootMember> Members { get; private set; }
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public void set_FullName(string value);
    [CompilerGeneratedAttribute]
public List`1<RootMember> get_Members();
    [CompilerGeneratedAttribute]
private void set_Members(List`1<RootMember> value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.RootLog.RootTypeBuilder : object {
    private Dictionary`2<string, RootProperty> _propertyDict;
    private Dictionary`2<string, RootMethod> _MethodDict;
    private Dictionary`2<string, RootEvent> _EventDict;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    public string FullName { get; private set; }
    public RootTypeBuilder(string standardName);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
private void set_FullName(string value);
    public RootMember AddProperty(string name);
    public RootMember AddEvent(string name);
    public RootMember AddMethod(string name);
    public RootType GetRootType();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.RootNamedElementStep : BindPathStep {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UpdateCallParamOverride>k__BackingField;
    public string FieldName { get; private set; }
    public string UpdateCallParamOverride { get; private set; }
    public string UniqueName { get; }
    public RootNamedElementStep(string fieldName, XamlType fieldType, BindPathStep parent, ApiInformation apiInformation, string updateParamOverride);
    public RootNamedElementStep(string fieldName, XamlType fieldType, BindPathStep parent, ApiInformation apiInformation);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
private void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public string get_UpdateCallParamOverride();
    [CompilerGeneratedAttribute]
private void set_UpdateCallParamOverride(string value);
    public virtual string get_UniqueName();
}
public class Microsoft.UI.Xaml.Markup.Compiler.RootStep : BindPathStep {
    public bool IsElementRoot;
    public bool IsIncludedInUpdate { get; }
    public string UniqueName { get; }
    public bool NeedsCheckForNull { get; }
    public RootStep(XamlType valueType, bool isElementRoot);
    public virtual bool get_IsIncludedInUpdate();
    public virtual string get_UniqueName();
    public virtual bool get_NeedsCheckForNull();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.SavedStateManager : object {
    private string _filename;
    private Queue`1<XamlFileCodeInfo> _fileCodeInfosToProcess;
    [CompilerGeneratedAttribute]
private string <LocalAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlFeatureControlFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ReferenceAssemblyList>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Guid> <ReferenceAssemblyGuids>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SaveStatePerXamlFile> <XamlPerFileInfo>k__BackingField;
    private static string XMLNAME_RootNode;
    private static string XMLNAME_XamlCompilerSaveState;
    private static string XMLNAME_ReferenceAssemblyList;
    private static string XMLNAME_LocalAssembly;
    private static string XMLNAME_ReferenceAssembly;
    private static string XMLNAME_PathName;
    private static string XMLNAME_HashGuid;
    private static string XMLNAME_XamlSourceFileDataList;
    private static string XMLNAME_XamlSourceFileData;
    private static string XMLNAME_XamlFeatureControlFlags;
    public string LocalAssemblyName { get; public set; }
    public string XamlFeatureControlFlags { get; public set; }
    public HashSet`1<string> ReferenceAssemblyList { get; private set; }
    public Dictionary`2<string, Guid> ReferenceAssemblyGuids { get; private set; }
    public Dictionary`2<string, SaveStatePerXamlFile> XamlPerFileInfo { get; private set; }
    [CompilerGeneratedAttribute]
public string get_LocalAssemblyName();
    [CompilerGeneratedAttribute]
public void set_LocalAssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_XamlFeatureControlFlags();
    [CompilerGeneratedAttribute]
public void set_XamlFeatureControlFlags(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ReferenceAssemblyList();
    [CompilerGeneratedAttribute]
private void set_ReferenceAssemblyList(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Guid> get_ReferenceAssemblyGuids();
    [CompilerGeneratedAttribute]
private void set_ReferenceAssemblyGuids(Dictionary`2<string, Guid> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SaveStatePerXamlFile> get_XamlPerFileInfo();
    [CompilerGeneratedAttribute]
private void set_XamlPerFileInfo(Dictionary`2<string, SaveStatePerXamlFile> value);
    public static SavedStateManager Load(string fileName);
    public void Save();
    public void LoadSavedTaskItemInfo(TaskItemFilename tif);
    public void SetXamlFileTimeAtLastCompile(string fileName, long fileTime);
    public void SetClassFullName(string fileName, string classFullName);
    public void SetGeneratedCodeFilePathPrefix(string fileName, string namePrefix);
    internal void AddBindingInfo(XamlFileCodeInfo fileCodeInfo);
    internal void ProcessBindingInfo();
    public long GetXamlFileTimeAtLastCompile(string fileName);
    public string GetClassFullName(string fileName);
    private void LoadFile(string fileName);
    private void ReadReferenceAssemblyList(XmlNode listNode);
    private void ReadSourceFileDataList(XmlNode listNode);
    private void SaveFile(string fileName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.SaveStatePerXamlFile : object {
    private static string XMLNAME_XamlFileName;
    private static string XMLNAME_XamlFileTimeAtLastCompileInTicks;
    private static string XMLNAME_ClassFullName;
    private static string XMLNAME_GeneratedCodePathPrefix;
    private static string XMLNAME_BindingObservableVectorTypes;
    private static string XMLNAME_BindingObservableMapTypes;
    private static string XMLNAME_XamlType;
    private static string XMLNAME_BindingSetters;
    private static string XMLNAME_Member;
    private static string XMLNAME_HasBoundEventAssignments;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <XamlFileTimeAtLastCompile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassFullName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SaveStateXamlMember> <BindingSetters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SaveStateXamlType> <BindingObservableVectorTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SaveStateXamlType> <BindingObservableMapTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasBoundEventAssignments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GeneratedCodeFilePathPrefix>k__BackingField;
    public string FileName { get; private set; }
    public long XamlFileTimeAtLastCompile { get; public set; }
    public string ClassFullName { get; public set; }
    public Dictionary`2<string, SaveStateXamlMember> BindingSetters { get; public set; }
    public Dictionary`2<string, SaveStateXamlType> BindingObservableVectorTypes { get; public set; }
    public Dictionary`2<string, SaveStateXamlType> BindingObservableMapTypes { get; public set; }
    public bool HasBoundEventAssignments { get; public set; }
    public string GeneratedCodeFilePathPrefix { get; public set; }
    public SaveStatePerXamlFile(string fileName);
    public SaveStatePerXamlFile(XmlNode node);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
public long get_XamlFileTimeAtLastCompile();
    [CompilerGeneratedAttribute]
public void set_XamlFileTimeAtLastCompile(long value);
    [CompilerGeneratedAttribute]
public string get_ClassFullName();
    [CompilerGeneratedAttribute]
public void set_ClassFullName(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SaveStateXamlMember> get_BindingSetters();
    [CompilerGeneratedAttribute]
public void set_BindingSetters(Dictionary`2<string, SaveStateXamlMember> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SaveStateXamlType> get_BindingObservableVectorTypes();
    [CompilerGeneratedAttribute]
public void set_BindingObservableVectorTypes(Dictionary`2<string, SaveStateXamlType> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SaveStateXamlType> get_BindingObservableMapTypes();
    [CompilerGeneratedAttribute]
public void set_BindingObservableMapTypes(Dictionary`2<string, SaveStateXamlType> value);
    [CompilerGeneratedAttribute]
public bool get_HasBoundEventAssignments();
    [CompilerGeneratedAttribute]
public void set_HasBoundEventAssignments(bool value);
    [CompilerGeneratedAttribute]
public string get_GeneratedCodeFilePathPrefix();
    [CompilerGeneratedAttribute]
public void set_GeneratedCodeFilePathPrefix(string value);
    public void WriteXmlElement(XmlWriter writer, string elementName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.SaveStateXamlMember : object {
    private static string XMLNAME_Name;
    private static string XMLNAME_DeclaringTypeFullName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeclaringTypeFullName>k__BackingField;
    public string Name { get; public set; }
    public string DeclaringTypeFullName { get; public set; }
    public SaveStateXamlMember(BindAssignment bindAssignment);
    public SaveStateXamlMember(XmlNode node);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DeclaringTypeFullName();
    [CompilerGeneratedAttribute]
public void set_DeclaringTypeFullName(string value);
    public virtual string ToString();
    public void WriteXmlElement(XmlWriter writer, string elementName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.SaveStateXamlType : object {
    private static string XMLNAME_FullName;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    public string FullName { get; public set; }
    public SaveStateXamlType(XamlType type);
    public SaveStateXamlType(XmlNode node);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public void set_FullName(string value);
    public virtual string ToString();
    public void WriteXmlElement(XmlWriter writer, string elementName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.SourceFileManager : object {
    private Dictionary`2<string, ClassCodeGenFile> _classXamlFilesMap;
    [CompilerGeneratedAttribute]
private string <ProjectFolderFullpath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFolderFullpath>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <IncludeFolderList>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPass1>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <XbfGenerationIsDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TaskItemFilename> <ProjectXamlTaskItems>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TaskItemFilename> <Sdk80XamlTaskItems>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TaskItemFilename> <SdkNon80XamlTaskItems>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TaskItemFilename> <SdkXamlTaskItems>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildTaskFileService <TaskFileService>k__BackingField;
    [CompilerGeneratedAttribute]
private SavedStateManager <SavedState>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TaskItemFilename> <ClasslessXamlFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GeneratedFileExtension>k__BackingField;
    public string ProjectFolderFullpath { get; private set; }
    public string OutputFolderFullpath { get; private set; }
    public List`1<string> IncludeFolderList { get; private set; }
    public bool IsPass1 { get; private set; }
    public bool XbfGenerationIsDisabled { get; private set; }
    public List`1<TaskItemFilename> ProjectXamlTaskItems { get; private set; }
    public List`1<TaskItemFilename> Sdk80XamlTaskItems { get; private set; }
    public List`1<TaskItemFilename> SdkNon80XamlTaskItems { get; private set; }
    public List`1<TaskItemFilename> SdkXamlTaskItems { get; private set; }
    public BuildTaskFileService TaskFileService { get; private set; }
    public SavedStateManager SavedState { get; private set; }
    public List`1<TaskItemFilename> ClasslessXamlFiles { get; private set; }
    public string GeneratedFileExtension { get; private set; }
    public IEnumerable`1<ClassCodeGenFile> CodeGenFiles { get; }
    public SourceFileManager(CompileXamlInternal compiler);
    [CompilerGeneratedAttribute]
public string get_ProjectFolderFullpath();
    [CompilerGeneratedAttribute]
private void set_ProjectFolderFullpath(string value);
    [CompilerGeneratedAttribute]
public string get_OutputFolderFullpath();
    [CompilerGeneratedAttribute]
private void set_OutputFolderFullpath(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_IncludeFolderList();
    [CompilerGeneratedAttribute]
private void set_IncludeFolderList(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_IsPass1();
    [CompilerGeneratedAttribute]
private void set_IsPass1(bool value);
    [CompilerGeneratedAttribute]
public bool get_XbfGenerationIsDisabled();
    [CompilerGeneratedAttribute]
private void set_XbfGenerationIsDisabled(bool value);
    [CompilerGeneratedAttribute]
public List`1<TaskItemFilename> get_ProjectXamlTaskItems();
    [CompilerGeneratedAttribute]
private void set_ProjectXamlTaskItems(List`1<TaskItemFilename> value);
    [CompilerGeneratedAttribute]
public List`1<TaskItemFilename> get_Sdk80XamlTaskItems();
    [CompilerGeneratedAttribute]
private void set_Sdk80XamlTaskItems(List`1<TaskItemFilename> value);
    [CompilerGeneratedAttribute]
public List`1<TaskItemFilename> get_SdkNon80XamlTaskItems();
    [CompilerGeneratedAttribute]
private void set_SdkNon80XamlTaskItems(List`1<TaskItemFilename> value);
    [CompilerGeneratedAttribute]
public List`1<TaskItemFilename> get_SdkXamlTaskItems();
    [CompilerGeneratedAttribute]
private void set_SdkXamlTaskItems(List`1<TaskItemFilename> value);
    [CompilerGeneratedAttribute]
public BuildTaskFileService get_TaskFileService();
    [CompilerGeneratedAttribute]
private void set_TaskFileService(BuildTaskFileService value);
    [CompilerGeneratedAttribute]
public SavedStateManager get_SavedState();
    [CompilerGeneratedAttribute]
private void set_SavedState(SavedStateManager value);
    [CompilerGeneratedAttribute]
public List`1<TaskItemFilename> get_ClasslessXamlFiles();
    [CompilerGeneratedAttribute]
private void set_ClasslessXamlFiles(List`1<TaskItemFilename> value);
    [CompilerGeneratedAttribute]
public string get_GeneratedFileExtension();
    [CompilerGeneratedAttribute]
private void set_GeneratedFileExtension(string value);
    public void SaveState();
    private void PrepareToSaveState();
    public void PropagateOutOfDateStatus(DirectUISchemaContext context);
    public TaskItemFilename FindTaskItemByFullPath(string fullPath);
    private DateTime GetSourceFileChanged(TaskItemFilename tif);
    private void AddToXamlClassFileMap(string classFullName, TaskItemFilename tif);
    private void RemoveFromXamlClassFileMap(string classFullName, TaskItemFilename tif);
    public string GetTargetFolderOfClass(string classFullName);
    public IEnumerable`1<ClassCodeGenFile> get_CodeGenFiles();
    private TaskItemFilename LoadTaskItem(List`1<TaskItemFilename> tifList, IFileItem item, bool isApplication, bool isSdkXaml);
    private void RegisterClassOfTaskItem(TaskItemFilename tif);
    private void UnregisterClassOfTaskItem(TaskItemFilename tif);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.SourcePos : object {
    public int Row;
    public int Col;
}
public class Microsoft.UI.Xaml.Markup.Compiler.StaticRootStep : BindPathStep {
    public bool IsIncludedInUpdate { get; }
    public string UniqueName { get; }
    public bool NeedsCheckForNull { get; }
    public StaticRootStep(XamlType staticType, ApiInformation apiInformation);
    public virtual bool get_IsIncludedInUpdate();
    public virtual string get_UniqueName();
    public virtual bool get_NeedsCheckForNull();
}
[ExtensionAttribute]
public static class Microsoft.UI.Xaml.Markup.Compiler.StringExtensions : object {
    private static Regex MemberFriendlyNameRegex;
    private static StringExtensions();
    [ExtensionAttribute]
public static string GetMemberFriendlyName(string instance);
    [ExtensionAttribute]
public static bool IsConditionalNamespace(string instance);
    [ExtensionAttribute]
internal static bool HasAtLeastTwo(string instance, char character);
    [ExtensionAttribute]
public static bool HasUsingPrefix(string instance);
    [ExtensionAttribute]
public static string StripUsingPrefix(string instance);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.StrippableMember : object {
    [CompilerGeneratedAttribute]
private LineNumberInfo <LineNumberInfo>k__BackingField;
    public LineNumberInfo LineNumberInfo { get; public set; }
    public StrippableMember(XamlDomMember dataTypeMember);
    [CompilerGeneratedAttribute]
public sealed virtual LineNumberInfo get_LineNumberInfo();
    [CompilerGeneratedAttribute]
public void set_LineNumberInfo(LineNumberInfo value);
    public sealed virtual XamlCompileError GetAttributeProcessingError();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.StrippableNamespace : object {
    [CompilerGeneratedAttribute]
private LineNumberInfo <LineNumberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripWholeNamespace>k__BackingField;
    public LineNumberInfo LineNumberInfo { get; public set; }
    public bool StripWholeNamespace { get; }
    public StrippableNamespace(XamlDomNamespace nameSpace, bool stripWholeNamespace);
    [CompilerGeneratedAttribute]
public sealed virtual LineNumberInfo get_LineNumberInfo();
    [CompilerGeneratedAttribute]
public void set_LineNumberInfo(LineNumberInfo value);
    [CompilerGeneratedAttribute]
public bool get_StripWholeNamespace();
    public sealed virtual XamlCompileError GetAttributeProcessingError();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.StrippableObject : object {
    [CompilerGeneratedAttribute]
private LineNumberInfo <LineNumberInfo>k__BackingField;
    public LineNumberInfo LineNumberInfo { get; public set; }
    public StrippableObject(XamlDomObject obj);
    [CompilerGeneratedAttribute]
public sealed virtual LineNumberInfo get_LineNumberInfo();
    [CompilerGeneratedAttribute]
public void set_LineNumberInfo(LineNumberInfo value);
    public sealed virtual XamlCompileError GetAttributeProcessingError();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.SuccinctCollectionSyntaxVerifier : object {
    public static bool TryParse(string collectionItem, XamlDomNode locationForErrors, List`1<XamlCompileError> Errors, XamlMember property);
    public static void Parse(string bindPath);
}
[ExtensionAttribute]
internal static class Microsoft.UI.Xaml.Markup.Compiler.SuccinctSyntaxLexerExtensions : object {
    [ExtensionAttribute]
public static void ConfirmInputFullyConsumed(SuccinctCollectionSyntaxLexer lexer);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.TaskItemFilename : object {
    [CompilerGeneratedAttribute]
private string <SourceXamlFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlGivenPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileNameNoExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlOutputFilename>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XbfOutputFilename>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelativePathFromGeneratedCodeToXamlFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApparentRelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <XamlOutputChangeTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <XbfOutputChangeTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <XamlFileTimeAtLastCompile>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <XamlLastChangeTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GeneratedCodePathPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsApplication>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSdkXamlFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPathMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassFullName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsForcedOutOfDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlResourceMapName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlComponentResourceLocation>k__BackingField;
    private bool _outputFileIsZeroLength;
    private bool _xbfFileIsZeroLength;
    private SourceFileManager _srcMgr;
    public string SourceXamlFullPath { get; private set; }
    public string XamlGivenPath { get; private set; }
    public string TargetFolder { get; private set; }
    public string FileNameNoExtension { get; private set; }
    public string XamlOutputFilename { get; private set; }
    public string XbfOutputFilename { get; private set; }
    public string RelativePathFromGeneratedCodeToXamlFile { get; private set; }
    public string ApparentRelativePath { get; private set; }
    public DateTime XamlOutputChangeTime { get; private set; }
    public DateTime XbfOutputChangeTime { get; private set; }
    public long XamlFileTimeAtLastCompile { get; public set; }
    public DateTime XamlLastChangeTime { get; public set; }
    public string GeneratedCodePathPrefix { get; public set; }
    public bool IsApplication { get; private set; }
    public bool IsSdkXamlFile { get; private set; }
    public string TargetPathMetadata { get; public set; }
    public string ClassFullName { get; public set; }
    public bool IsForcedOutOfDate { get; public set; }
    public string XamlResourceMapName { get; private set; }
    public string XamlComponentResourceLocation { get; private set; }
    public TaskItemFilename(IFileItem item, SourceFileManager srcMgr, bool isApplication, bool isSdkXaml);
    [CompilerGeneratedAttribute]
public string get_SourceXamlFullPath();
    [CompilerGeneratedAttribute]
private void set_SourceXamlFullPath(string value);
    [CompilerGeneratedAttribute]
public string get_XamlGivenPath();
    [CompilerGeneratedAttribute]
private void set_XamlGivenPath(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFolder();
    [CompilerGeneratedAttribute]
private void set_TargetFolder(string value);
    [CompilerGeneratedAttribute]
public string get_FileNameNoExtension();
    [CompilerGeneratedAttribute]
private void set_FileNameNoExtension(string value);
    [CompilerGeneratedAttribute]
public string get_XamlOutputFilename();
    [CompilerGeneratedAttribute]
private void set_XamlOutputFilename(string value);
    [CompilerGeneratedAttribute]
public string get_XbfOutputFilename();
    [CompilerGeneratedAttribute]
private void set_XbfOutputFilename(string value);
    [CompilerGeneratedAttribute]
public string get_RelativePathFromGeneratedCodeToXamlFile();
    [CompilerGeneratedAttribute]
private void set_RelativePathFromGeneratedCodeToXamlFile(string value);
    [CompilerGeneratedAttribute]
public string get_ApparentRelativePath();
    [CompilerGeneratedAttribute]
private void set_ApparentRelativePath(string value);
    [CompilerGeneratedAttribute]
public DateTime get_XamlOutputChangeTime();
    [CompilerGeneratedAttribute]
private void set_XamlOutputChangeTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_XbfOutputChangeTime();
    [CompilerGeneratedAttribute]
private void set_XbfOutputChangeTime(DateTime value);
    [CompilerGeneratedAttribute]
public long get_XamlFileTimeAtLastCompile();
    [CompilerGeneratedAttribute]
public void set_XamlFileTimeAtLastCompile(long value);
    [CompilerGeneratedAttribute]
public DateTime get_XamlLastChangeTime();
    [CompilerGeneratedAttribute]
public void set_XamlLastChangeTime(DateTime value);
    [CompilerGeneratedAttribute]
public string get_GeneratedCodePathPrefix();
    [CompilerGeneratedAttribute]
public void set_GeneratedCodePathPrefix(string value);
    [CompilerGeneratedAttribute]
public bool get_IsApplication();
    [CompilerGeneratedAttribute]
private void set_IsApplication(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSdkXamlFile();
    [CompilerGeneratedAttribute]
private void set_IsSdkXamlFile(bool value);
    [CompilerGeneratedAttribute]
public string get_TargetPathMetadata();
    [CompilerGeneratedAttribute]
public void set_TargetPathMetadata(string value);
    [CompilerGeneratedAttribute]
public string get_ClassFullName();
    [CompilerGeneratedAttribute]
public void set_ClassFullName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsForcedOutOfDate();
    [CompilerGeneratedAttribute]
public void set_IsForcedOutOfDate(bool value);
    [CompilerGeneratedAttribute]
public string get_XamlResourceMapName();
    [CompilerGeneratedAttribute]
private void set_XamlResourceMapName(string value);
    [CompilerGeneratedAttribute]
public string get_XamlComponentResourceLocation();
    [CompilerGeneratedAttribute]
private void set_XamlComponentResourceLocation(string value);
    public void Refresh(SavedStateManager saveState);
    public bool OutOfDate();
}
public class Microsoft.UI.Xaml.Markup.Compiler.Tasks.AddDefaultXamlLinkMetadata : Task {
    public static string DefaultXamlLink;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CIncludeDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <XamlPages>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <OutputItems>k__BackingField;
    private List`1<string> _folderList;
    [RequiredAttribute]
public string ProjectPath { get; public set; }
    public string CIncludeDirectories { get; public set; }
    [RequiredAttribute]
public ITaskItem[] XamlPages { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutputItems { get; public set; }
    private List`1<string> IncludeFolderList { get; }
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public string get_CIncludeDirectories();
    [CompilerGeneratedAttribute]
public void set_CIncludeDirectories(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_XamlPages();
    [CompilerGeneratedAttribute]
public void set_XamlPages(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_OutputItems();
    [CompilerGeneratedAttribute]
public void set_OutputItems(ITaskItem[] value);
    public virtual bool Execute();
    private List`1<string> get_IncludeFolderList();
}
public class Microsoft.UI.Xaml.Markup.Compiler.Tasks.CompileXaml : Task {
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageSourceExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ReferenceAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformMinVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ReferenceAssemblyPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceSharedStateShutdown>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableXbfGeneration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableXbfLineInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableXBindDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ClIncludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CIncludeDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <XamlApplications>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <XamlPages>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <LocalAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <SdkXamlPages>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPass1>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PriIndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeGenerationControlFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FeatureControlFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <XAMLFingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseVCMetaManaged>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FingerprintIgnorePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VCInstallDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VCInstallPath32>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VCInstallPath64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WindowsSdkPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompileMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SavedStateFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootsLog>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuppressWarnings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GenXbfPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrecompiledHeaderFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlResourceMapName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlComponentResourceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSpecifiedTargetPlatformMinVersion>k__BackingField;
    private List`1<ITaskItem> _generatedCodeFiles;
    private List`1<ITaskItem> _generatedXamlFiles;
    private List`1<ITaskItem> _generatedXbfFiles;
    private List`1<ITaskItem> _generatedXamlPagesFiles;
    private bool _designTimeBuildMode;
    [RequiredAttribute]
public string ProjectPath { get; public set; }
    [RequiredAttribute]
public string Language { get; public set; }
    [RequiredAttribute]
public string LanguageSourceExtension { get; public set; }
    [RequiredAttribute]
public string OutputPath { get; public set; }
    [RequiredAttribute]
public ITaskItem[] ReferenceAssemblies { get; public set; }
    [RequiredAttribute]
public string TargetPlatformMinVersion { get; public set; }
    [RequiredAttribute]
public ITaskItem[] ReferenceAssemblyPaths { get; public set; }
    public string BuildConfiguration { get; public set; }
    public bool ForceSharedStateShutdown { get; public set; }
    public bool DisableXbfGeneration { get; public set; }
    public bool DisableXbfLineInfo { get; public set; }
    public bool EnableXBindDiagnostics { get; public set; }
    public ITaskItem[] ClIncludeFiles { get; public set; }
    public string CIncludeDirectories { get; public set; }
    public ITaskItem[] XamlApplications { get; public set; }
    public ITaskItem[] XamlPages { get; public set; }
    public ITaskItem[] LocalAssembly { get; public set; }
    public ITaskItem[] SdkXamlPages { get; public set; }
    public string ProjectName { get; public set; }
    public bool IsPass1 { get; public set; }
    public string RootNamespace { get; public set; }
    public string OutputType { get; public set; }
    public string PriIndexName { get; public set; }
    public string CodeGenerationControlFlags { get; public set; }
    public string FeatureControlFlags { get; public set; }
    public bool XAMLFingerprint { get; public set; }
    public bool UseVCMetaManaged { get; public set; }
    public String[] FingerprintIgnorePaths { get; public set; }
    public string VCInstallDir { get; public set; }
    public string VCInstallPath32 { get; public set; }
    public string VCInstallPath64 { get; public set; }
    public string WindowsSdkPath { get; public set; }
    public string CompileMode { get; public set; }
    public string SavedStateFile { get; public set; }
    public string RootsLog { get; public set; }
    public string SuppressWarnings { get; public set; }
    public string GenXbfPath { get; public set; }
    public string PrecompiledHeaderFile { get; public set; }
    public string XamlResourceMapName { get; public set; }
    public string XamlComponentResourceLocation { get; public set; }
    public string XamlPlatform { get; public set; }
    public string TargetFileName { get; public set; }
    public bool IgnoreSpecifiedTargetPlatformMinVersion { get; public set; }
    [OutputAttribute]
public ITaskItem[] GeneratedCodeFiles { get; }
    [OutputAttribute]
public ITaskItem[] GeneratedXamlFiles { get; }
    [OutputAttribute]
public ITaskItem[] GeneratedXbfFiles { get; }
    [OutputAttribute]
public ITaskItem[] GeneratedXamlPagesFiles { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Language(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LanguageSourceExtension();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LanguageSourceExtension(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OutputPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_ReferenceAssemblies();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReferenceAssemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetPlatformMinVersion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetPlatformMinVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_ReferenceAssemblyPaths();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReferenceAssemblyPaths(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_BuildConfiguration();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildConfiguration(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ForceSharedStateShutdown();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ForceSharedStateShutdown(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DisableXbfGeneration();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DisableXbfGeneration(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DisableXbfLineInfo();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DisableXbfLineInfo(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableXBindDiagnostics();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EnableXBindDiagnostics(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_ClIncludeFiles();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClIncludeFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CIncludeDirectories();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CIncludeDirectories(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_XamlApplications();
    [CompilerGeneratedAttribute]
public sealed virtual void set_XamlApplications(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_XamlPages();
    [CompilerGeneratedAttribute]
public sealed virtual void set_XamlPages(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_LocalAssembly();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LocalAssembly(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_SdkXamlPages();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SdkXamlPages(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsPass1();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsPass1(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RootNamespace();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RootNamespace(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OutputType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PriIndexName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PriIndexName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CodeGenerationControlFlags();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CodeGenerationControlFlags(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FeatureControlFlags();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FeatureControlFlags(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_XAMLFingerprint();
    [CompilerGeneratedAttribute]
public sealed virtual void set_XAMLFingerprint(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseVCMetaManaged();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseVCMetaManaged(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_FingerprintIgnorePaths();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FingerprintIgnorePaths(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VCInstallDir();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VCInstallDir(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VCInstallPath32();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VCInstallPath32(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VCInstallPath64();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VCInstallPath64(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_WindowsSdkPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WindowsSdkPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CompileMode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CompileMode(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SavedStateFile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SavedStateFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RootsLog();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RootsLog(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SuppressWarnings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SuppressWarnings(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_GenXbfPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_GenXbfPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PrecompiledHeaderFile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PrecompiledHeaderFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_XamlResourceMapName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_XamlResourceMapName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_XamlComponentResourceLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_XamlComponentResourceLocation(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_XamlPlatform();
    [CompilerGeneratedAttribute]
public sealed virtual void set_XamlPlatform(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFileName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetFileName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IgnoreSpecifiedTargetPlatformMinVersion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IgnoreSpecifiedTargetPlatformMinVersion(bool value);
    public sealed virtual ITaskItem[] get_GeneratedCodeFiles();
    public sealed virtual ITaskItem[] get_GeneratedXamlFiles();
    public sealed virtual ITaskItem[] get_GeneratedXbfFiles();
    public sealed virtual ITaskItem[] get_GeneratedXamlPagesFiles();
    public virtual bool Execute();
    private bool CheckForDesignTimeBuildMode();
    private void PopulateWrapper(CompileXamlInternal wrapper);
    private IList`1<IFileItem> GetFileItems(ITaskItem[] source);
    private IList`1<IAssemblyItem> GetAssemblyItems(ITaskItem[] source);
    private void ExtractWrapperResults(CompileXamlInternal wrapper);
}
public class Microsoft.UI.Xaml.Markup.Compiler.Tasks.GetXamlCppIncludeDirectories : Task {
    [CompilerGeneratedAttribute]
private ITaskItem[] <ClCompile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComputedIncludeDirectories>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] ClCompile { get; public set; }
    [OutputAttribute]
public string ComputedIncludeDirectories { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ClCompile();
    [CompilerGeneratedAttribute]
public void set_ClCompile(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_ComputedIncludeDirectories();
    [CompilerGeneratedAttribute]
public void set_ComputedIncludeDirectories(string value);
    public virtual bool Execute();
    private string CombineListOfFolders(List`1<string> folders);
    private static List`1<string> GetAdditionalIncludeDirectories(IEnumerable`1<ITaskItem> items);
    private static List`1<ITaskItem> GetXamlDependentItems(IEnumerable`1<ITaskItem> items);
    private static List`1<string> GetUnionOfAdditionalIncludeDirectoriesElements(IEnumerable`1<ITaskItem> items);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("33372170-A08F-47F9-B1AE-CD9F2C3BB7C9")]
internal interface Microsoft.UI.Xaml.Markup.Compiler.Tasks.IVsMSBuildTaskFileManager {
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual string GetFileContents(string wszFilename);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual object GetFileDocData(string wszFilename);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual long GetFileLastChangeTime(string wszFilename);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual void PutGeneratedFileContents(string wszFilename, string strFileContents);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual bool IsRealBuildOperation();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual void Delete(string wszFilename);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual bool Exists(string wszFilename, bool fOnlyCheckOnDisk);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Tasks.MSBuildLogger : object {
    private TaskLoggingHelper logger;
    public MSBuildLogger(TaskLoggingHelper logger);
    public sealed virtual void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message);
    public sealed virtual void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message);
    public sealed virtual void LogDiagnosticMessage(string message);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper : object {
    private IVsMSBuildTaskFileManager legacy;
    private IVsMSBuildTaskFreeThreadedFileManager freeThreaded;
    private VsMSBuildFileManagerHostObjectWrapper(IVsMSBuildTaskFileManager fileManager);
    private VsMSBuildFileManagerHostObjectWrapper(IVsMSBuildTaskFreeThreadedFileManager fileManager);
    public bool IsRealBuildOperation();
    public sealed virtual void Delete(string fileName);
    public sealed virtual bool Exists(string fileName, bool onlyCheckOnDisk);
    public sealed virtual TextReader GetFileContents(string fileName);
    public sealed virtual DateTime GetFileLastChangeTime(string fileName);
    public sealed virtual void PutGeneratedFileContents(string fileName, string contents);
    internal static VsMSBuildFileManagerHostObjectWrapper Acquire(object hostObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Tasks.VSMSBuildTaskFileService : BuildTaskFileService {
    private VsMSBuildFileManagerHostObjectWrapper hostFileManager;
    public bool HasIdeHost { get; }
    public bool IsRealBuild { get; }
    public VSMSBuildTaskFileService(VsMSBuildFileManagerHostObjectWrapper taskFileManager, string langExtension);
    public virtual bool get_HasIdeHost();
    public virtual TextReader GetFileContents(string srcFile);
    public virtual DateTime GetLastChangeTime(string srcFile);
    public virtual void DeleteFile(string srcFile);
    public virtual bool get_IsRealBuild();
}
public enum Microsoft.UI.Xaml.Markup.Compiler.Tracing.CodeMarkerEvent : Enum {
    public int value__;
    public static CodeMarkerEvent perfXC_StartPass1;
    public static CodeMarkerEvent perfXC_StartPass2;
    public static CodeMarkerEvent perfXC_EndPass1;
    public static CodeMarkerEvent perfXC_EndPass2;
    public static CodeMarkerEvent perfXC_FingerprintCheck;
    public static CodeMarkerEvent perfXC_RestoredTypeInfoBackup;
    public static CodeMarkerEvent perfXC_RestoredGeneratedPass2CodeFileBackup;
    public static CodeMarkerEvent perfXC_CreatingTypeUniverse;
    public static CodeMarkerEvent perfXC_CreatedTypeUniverse;
    public static CodeMarkerEvent perfXC_PageStart;
    public static CodeMarkerEvent perfXC_PageDone;
    public static CodeMarkerEvent perfXC_ReleasingTypeUniverse;
    public static CodeMarkerEvent perfXC_InitializeTypeNameMapStart;
    public static CodeMarkerEvent perfXC_InitializeTypeNameMapEnd;
    public static CodeMarkerEvent perfXC_GenerateTypeInfoStart;
    public static CodeMarkerEvent perfXC_GenerateTypeInfoEnd;
    public static CodeMarkerEvent perfXC_WriteTypeinfoFilesToDiskStart;
    public static CodeMarkerEvent perfXC_WriteTypeinfoFilesToDiskEnd;
    public static CodeMarkerEvent perfXC_PageTypeCollectStart;
    public static CodeMarkerEvent perfXC_PageTypeCollectEnd;
    public static CodeMarkerEvent perfXC_PageHarvestStart;
    public static CodeMarkerEvent perfXC_PageHarvestEnd;
    public static CodeMarkerEvent perfXC_WriteFilesToDiskStart;
    public static CodeMarkerEvent perfXC_WriteFilesToDiskEnd;
    public static CodeMarkerEvent perfXC_PageCodeGenStart;
    public static CodeMarkerEvent perfXC_PageCodeGenEnd;
    public static CodeMarkerEvent perfXC_PageEditStart;
    public static CodeMarkerEvent perfXC_PageEditEnd;
    public static CodeMarkerEvent perfXC_GenerateXBFStart;
    public static CodeMarkerEvent perfXC_GenerateXBFEnd;
    public static CodeMarkerEvent perfXC_GenerateSdkXBFStart;
    public static CodeMarkerEvent perfXC_GenerateSdkXBFEnd;
    public static CodeMarkerEvent perfXC_PageLoadStart;
    public static CodeMarkerEvent perfXC_PageLoadEnd;
    public static CodeMarkerEvent perfXC_PageValidateStart;
    public static CodeMarkerEvent perfXC_PageValidateEnd;
    public static CodeMarkerEvent perfXC_SearchIxmpAndBindableStart;
    public static CodeMarkerEvent perfXC_SearchIxmpAndBindableEnd;
    public static CodeMarkerEvent perfXC_CreatingSchemaContext;
    public static CodeMarkerEvent perfXC_CreatedSchemaContext;
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Tracing.PerformanceUtility : object {
    private static ILog logger;
    internal static void Initialize(ILog logger);
    internal static void Shutdown();
    internal static void FireCodeMarker(CodeMarkerEvent marker, string additionalInformation);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.TypeInfoCollector : object {
    private DirectUISchemaContext _schemaContext;
    private XamlSchemaCodeInfo _schemaInfo;
    private RootLogBuilder _rootLogBuilder;
    private Platform _targPlat;
    [CompilerGeneratedAttribute]
private ClassName <AppXamlInfo>k__BackingField;
    internal ClassName AppXamlInfo { get; internal set; }
    public XamlSchemaCodeInfo SchemaInfo { get; }
    public Roots RootLog { get; }
    public TypeInfoCollector(DirectUISchemaContext schemaContext, Platform targPlat);
    [CompilerGeneratedAttribute]
internal ClassName get_AppXamlInfo();
    [CompilerGeneratedAttribute]
internal void set_AppXamlInfo(ClassName value);
    public void Collect(XamlDomObject domRoot);
    public XamlSchemaCodeInfo get_SchemaInfo();
    public Roots get_RootLog();
    public void AddTypeToRootLog(DirectUIXamlType duiXamlType);
    public void AddMetadataAndBindableTypes(List`1<Assembly> loadedAssemblies, Assembly localAssembly);
    public void AddAllConstructibleTypesFromLocalAssembly(Assembly localAssembly);
    private void AddMemberToRootLog(DirectUIXamlType duiType, DirectUIXamlMember duiMember);
    private bool CollectSettersInStyle(XamlDomObject StyleObject);
    private bool CollectSingleSetter(XamlType xamlTargetType, XamlDomObject domSetterObject);
    private void CollectBindingCtorParam(XamlDomObject domBinding);
    private void CollectPropertyPath(XamlDomMember pathProperty);
    private void CollectPropertyPath(string pathString, XamlDomObject domBinding);
    private void FindAllMetadataAndBindableTypes(IList`1<Assembly> loadedAssemblies, Assembly localAssembly, List`1& otherProviders, List`1& bindableTypes);
    private bool HasBindableAttribute(Type type);
    private bool HasInterface(Type type, string InterfaceName);
    private bool DerivesFromBaseType(Type type, string baseTypeName);
    private bool ShouldTreatAsPropertyPath(XamlDomMember domMember);
    [CompilerGeneratedAttribute]
private DirectUIXamlType <AddMetadataAndBindableTypes>b__15_1(Type p);
}
public enum Microsoft.UI.Xaml.Markup.Compiler.UpdateSourceTrigger : Enum {
    public int value__;
    public static UpdateSourceTrigger Default;
    public static UpdateSourceTrigger PropertyChanged;
    public static UpdateSourceTrigger LostFocus;
    public static UpdateSourceTrigger Explicit;
}
[ExtensionAttribute]
internal static class Microsoft.UI.Xaml.Markup.Compiler.Utilities.AssemblyExtensions : object {
    [ExtensionAttribute]
public static bool IsClsCompliant(Assembly instance);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Utilities.ChecksumHelper : object {
    private static ChecksumHelper instance;
    internal static int ChecksumLength;
    private HashAlgorithm hashProvider;
    internal static ChecksumHelper Instance { get; }
    internal static ChecksumHelper get_Instance();
    internal string ComputeCheckSumForXamlFile(string fullXamlFilePath);
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Utilities.FileHelpers : object {
    private static Char[] DirectorySeparators;
    private static InstanceCache`2<string, string> _platformAssemblyNameCache;
    private static FileHelpers();
    public static void BackupFile(string fullPathFileName);
    public static bool RestoreBackupFile(string fullPathFileName);
    public static void BackupIfExistsAndTruncateToNull(string filename);
    public static string GetSafeName(string ProjectName);
    public static string GetRelativePath(string currentDir, string filePath);
    public static string ComputeBaseFolder(string folder1, string folder2);
    public static bool IsPlatformAssembly(DirectUIAssembly assembly);
    public static bool IsWinUIAssembly(DirectUIAssembly assembly);
    public static bool IsFacadeWinmd(Assembly asm, string windowsSdkPath);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Utilities.NamedElementsStore : object {
    private Stack`1<HashSet`1<string>> _scopeStack;
    internal void EnterNewScope(XamlDomObject member);
    internal void ExitCurrentScope();
    internal void AddNamedElement(string name);
    internal bool IsNameAlreadyUsed(string name);
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Utilities.NativeMethods : object {
    public static int LOAD_WITH_ALTERED_SEARCH_PATH;
    private static NativeMethods();
    public static IntPtr LoadLibraryEx(string libFilename, IntPtr reserved, int flags);
    public static IntPtr GetProcAddress(IntPtr hModule, string procName);
    public static int FreeLibrary(IntPtr hModule);
    public static int HashForWinMD(string lpFileName, Guid& hash);
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Utilities.NativeMethodsHelper : object {
    private static bool s_VcMetaIsLoaded;
    public static bool EnsureVcMetaIsLoaded(string vsInstallDir, string vcInstallPath32, string vcInstallPath64);
    private static IntPtr LoadLibrary32_64(string path32bit, string path64bit);
    public static int Write(IntPtr dllHandle, IStream[] xamlStreams, int numFiles, String[] pbChecksum, int checksumSize, IXbfMetadataProvider provider, TargetOSVersion targetVersion, UInt32 xbfGenerationFlags, IStream[] xbfStreams, Int32& errorCode, Int32& errorFileIndex, Int32& errorLine, Int32& errorColumn);
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Utilities.ResourceUtilities : object {
    private static Regex msbuildMessageCodePattern;
    private static ResourceUtilities();
    internal static string ExtractMessageCode(Regex messageCodePattern, string messageWithCode, String& code);
    internal static string FormatString(string unformatted, Object[] args);
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.Utilities.VCMetaManaged : object {
    public static Guid HashForWinMD(string path);
    private static void Hash(MD5 md5, int value);
    private static void Hash(MD5 md5, string value);
    private static void Hash(MD5 md5, Byte[] bytes);
    private static void Hash(MD5 md5, Byte[] bytes, int length);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Utilities.XamlHelper : object {
    internal static List`1<string> SplitAndEnsureFullpaths(string path, string projectFolderFullpath);
    internal static List`1<string> EnsureFullpaths(String[] paths, string projectFolderFullpath);
    private static string EnsureFullpath(string path, string projectFolderFullpath);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.Utilities.XamlNodeStreamHelper : object {
    public static string ReadXClassFromXamlFileStream(TextReader fileStream, XamlSchemaContext schemaContext);
    public static string ReadXClassFromXamlReader(XamlXmlReader xamlReader);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlClassCodeInfo : object {
    private Dictionary`2<string, FieldDefinition> fieldDefinitions;
    private List`1<FieldDefinition> fieldDeclarations;
    private List`1<XamlFileCodeInfo> xamlFileCodeInfoList;
    private List`1<BindUniverse> bindUniverses;
    private Nullable`1<bool> hasEventAssignments;
    private Nullable`1<BindStatus> bindStatus;
    private Nullable`1<bool> hasPhaseAssignments;
    private string baseFileName;
    private int lastConnectionId;
    [CompilerGeneratedAttribute]
private bool <IsApplication>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ClassName <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseApparentRelativeFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PriIndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <ClassXamlType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeForCodeGen <ClassType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <BaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlResourceMapName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlComponentResourceLocation>k__BackingField;
    public bool IsApplication { get; private set; }
    public string RootNamespace { get; public set; }
    public ClassName ClassName { get; public set; }
    public string BaseFileName { get; }
    public string BaseApparentRelativeFolder { get; private set; }
    public string BaseApparentRelativePath { get; }
    public string TargetFolder { get; public set; }
    public string PriIndexName { get; public set; }
    public XamlType ClassXamlType { get; public set; }
    public TypeForCodeGen ClassType { get; public set; }
    public string BaseTypeName { get; public set; }
    public XamlType BaseType { get; public set; }
    public string XamlResourceMapName { get; public set; }
    public string XamlComponentResourceLocation { get; public set; }
    public bool IsResourceDictionary { get; }
    public bool HasFieldDefinitions { get; }
    public bool HasEventAssignments { get; }
    public BindStatus BindStatus { get; }
    public bool HasPhaseAssignments { get; }
    public List`1<BindUniverse> BindUniverses { get; }
    public IEnumerable`1<FieldDefinition> FieldDeclarations { get; }
    public List`1<XamlFileCodeInfo> PerXamlFileInfo { get; }
    public bool IsUsingCompiledBinding { get; }
    public bool HasBindingSetters { get; }
    public bool HasBindAssignments { get; }
    public bool HasBoundEventAssignments { get; }
    public bool HasInComponentBase { get; }
    public int NextConnectionId { get; }
    public XamlClassCodeInfo(string classFullName, bool isApplication);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsApplication();
    [CompilerGeneratedAttribute]
private void set_IsApplication(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RootNamespace();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RootNamespace(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ClassName get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(ClassName value);
    public sealed virtual string get_BaseFileName();
    [CompilerGeneratedAttribute]
public string get_BaseApparentRelativeFolder();
    [CompilerGeneratedAttribute]
private void set_BaseApparentRelativeFolder(string value);
    public string get_BaseApparentRelativePath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFolder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetFolder(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PriIndexName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PriIndexName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual XamlType get_ClassXamlType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClassXamlType(XamlType value);
    [CompilerGeneratedAttribute]
public sealed virtual TypeForCodeGen get_ClassType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClassType(TypeForCodeGen value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_BaseTypeName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BaseTypeName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual XamlType get_BaseType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BaseType(XamlType value);
    [CompilerGeneratedAttribute]
public string get_XamlResourceMapName();
    [CompilerGeneratedAttribute]
public void set_XamlResourceMapName(string value);
    [CompilerGeneratedAttribute]
public string get_XamlComponentResourceLocation();
    [CompilerGeneratedAttribute]
public void set_XamlComponentResourceLocation(string value);
    public sealed virtual bool get_IsResourceDictionary();
    public sealed virtual bool get_HasFieldDefinitions();
    public sealed virtual bool get_HasEventAssignments();
    public sealed virtual BindStatus get_BindStatus();
    public bool get_HasPhaseAssignments();
    public sealed virtual List`1<BindUniverse> get_BindUniverses();
    public sealed virtual IEnumerable`1<FieldDefinition> get_FieldDeclarations();
    public sealed virtual List`1<XamlFileCodeInfo> get_PerXamlFileInfo();
    public sealed virtual void AddXamlFileInfo(XamlFileCodeInfo fileCodeInfo);
    private bool AddFieldDefinition(FieldDefinition newFieldDef);
    private string ComputeBaseFileName();
    public bool get_IsUsingCompiledBinding();
    public bool get_HasBindingSetters();
    public bool get_HasBindAssignments();
    public bool get_HasBoundEventAssignments();
    public bool get_HasInComponentBase();
    public int get_NextConnectionId();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlCompileError : XamlCompileErrorBase {
    protected XamlCompileError(ErrorCode code);
    public XamlCompileError(ErrorCode code, IXamlDomNode domNode);
    public XamlCompileError(ErrorCode code, int lineNumber, int lineOffset);
    protected XamlCompileError(ErrorCode code, string fileName, int lineNumber, int lineOffset);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlCompileErrorBase : object {
    [CompilerGeneratedAttribute]
private ErrorCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineOffset>k__BackingField;
    public ErrorCode Code { get; protected set; }
    public string Message { get; protected set; }
    public string FileName { get; protected set; }
    public int LineNumber { get; private set; }
    public int LineOffset { get; private set; }
    public XamlCompileErrorBase(ErrorCode code, string fileName, int lineNumber, int lineOffset);
    [CompilerGeneratedAttribute]
public ErrorCode get_Code();
    [CompilerGeneratedAttribute]
protected void set_Code(ErrorCode value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
protected void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
protected void set_FileName(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LineOffset();
    [CompilerGeneratedAttribute]
private void set_LineOffset(int value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlCompileErrorInvalidPropertyType : XamlCompileError {
    public XamlCompileErrorInvalidPropertyType(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlCompileErrorInvalidPropertyType_SignedChar : XamlCompileError {
    public XamlCompileErrorInvalidPropertyType_SignedChar(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlCompilerErrorProcessingStyle : XamlCompileError {
    public XamlCompilerErrorProcessingStyle(XamlDomObject domStyle);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlCompilerTypeMustHaveANamespace : XamlCompileError {
    public XamlCompilerTypeMustHaveANamespace(XamlDomObject domObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlCompileWarning : XamlCompileErrorBase {
    public XamlCompileWarning(ErrorCode code, IXamlDomNode domNode);
    protected XamlCompileWarning(ErrorCode code);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlConnectionIdRewriter : object {
    private String[] xamlLines;
    private List`1<XamlCompileError> errors;
    private static Char[] Whitespace;
    private static Char[] QuoteCharacters;
    public List`1<XamlCompileError> Errors { get; }
    private static XamlConnectionIdRewriter();
    public List`1<XamlCompileError> get_Errors();
    public string Parse(string xamlText, IXamlClassCodeInfo classCodeInfo, IXamlFileCodeInfo fileCodeInfo);
    public string Edit(string xamlFileName, IXamlClassCodeInfo classCodeInfo, IXamlFileCodeInfo fileCodeInfo);
    internal virtual String[] ReadAllLinesFromFile(string xamlFileName);
    internal virtual string ReadAllTextFromFile(string xamlFileName);
    internal static int ConnectionIdElementComparer(ConnectionIdElement a, ConnectionIdElement b);
    private static String[] ReadAllLinesOfString(string xamlText);
    private static string GetSpaces(int start, int end);
    private string ProcessLines(IXamlClassCodeInfo classCodeInfo, IXamlFileCodeInfo fileCodeInfo);
    private void ReplaceWithSpaces(SourcePos start, SourcePos end);
    private void StripObject(ILineNumberAndErrorInfo element);
    private void AttributeProcessingNamespace(StrippableNamespace element);
    private void AttributeProcessing(ILineNumberAndErrorInfo element, bool allowMultiline);
    private string OverwriteText(string text, string replacement);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.DomHelper : object {
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.XamlDom.DomHelper/<DomNodeAncestry>d__0")]
public static IEnumerable`1<XamlDomNode> DomNodeAncestry(XamlDomNode node);
    public static string GetStringValueOfProperty(XamlDomObject domObject, string memberName);
    public static string GetStringValueOfProperty(XamlDomObject domObject, XamlMember member);
    public static string GetStringValueOfProperty(XamlDomMember domMember);
    public static XamlDomObject GetDomRoot(XamlDomNode node);
    public static bool IsLocalType(XamlType xamlType);
    public static XamlDomMember GetAliasedMemberNode(XamlDomObject domObject, XamlDirective directive, bool forcePass1Eval);
    public static string SaveToString(XamlDomObject rootObjectNode);
    internal static bool UnderANamescope(XamlDomObject namedObject, bool isPass1);
    internal static bool IsInsideControlTemplate(XamlDomObject namedObject, bool isPass1);
    public static bool IsDerivedFromDataTemplate(XamlDomObject domObject);
    public static bool IsDerivedFromControlTemplate(XamlDomObject domObject);
    public static bool IsDerivedFromResourceDictionary(XamlDomObject domObject);
    public static bool IsDerivedFromUIElement(XamlDomObject domObject);
    public static bool IsDerivedFromFlyoutBase(XamlDomObject domObject);
    public static bool IsNamedDirective(XamlDomMember domMember, string directiveName);
    public static bool IsDeferLoadStrategyMember(XamlDomMember domMember);
    public static bool IsLoadMember(XamlDomMember domMember);
    public static bool IsPropertiesMember(XamlDomMember domMember);
    public static bool IsDefaultBindModeMember(XamlDomMember domMember);
    public static bool IsDataTypeMember(XamlMember xamlMember);
    public static bool IsDataTypeMember(XamlDomMember domMember);
    public static XamlDomMember GetDataTypeMember(XamlDomObject domObject);
    public static string GetStaticResource_ResourceKey(XamlDomObject domStaticResourceObject);
    public static bool IsPhaseMember(XamlMember xamlMember);
    public static bool IsPhaseMember(XamlDomMember domMember);
    public static bool IsBindExtension(XamlDomMember domMember);
    public static bool IsBindExtension(XamlDomObject domObject);
    public static bool IsDependencyProperty(XamlDomMember domMember);
    public static XamlDomObject GetBindExtensionOrNull(XamlDomMember domMember);
    public static bool HasTwoWayBinding(XamlDomMember domMember);
    public static bool HasTargetNullValue(XamlDomMember domMember);
    public static bool HasUpdateSourceTrigger(XamlDomMember domMember);
    public static bool DoesAnyMemberUseBindExpression(XamlDomObject domObject);
    public static bool CanBeInstantiatedLater(XamlDomObject namedObject);
    public static bool HasLoadOrDeferLoadStrategyMember(XamlDomObject namedObject);
    public static bool HasDefaultBindModeMember(XamlDomObject namedObject);
    public static bool ConditionalValidForPlatform(Platform platCond, Platform targPlat);
    private static bool IsTypeInvalidForPlatform(XamlType type, Platform targPlat);
    public static bool IsObjectInvalidForPlatform(XamlDomObject obj, Platform targPlat);
    public static bool IsMemberInvalidForPlatform(XamlDomMember member, Platform targPlat);
    public static string GetDefaultBindMode(XamlDomObject namedObject);
    public static XamlDomMember GetDefaultBindModeMember(XamlDomObject namedObject);
    private static string GetDefaultBindModeForSingleton(XamlDomObject namedObject);
    public static bool IsNamedCollectableObject(XamlDomObject domObject, bool isPass1);
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.XamlDom.IXamlDomMember {
    public XamlDomItem Item { get; public set; }
    public IList`1<XamlDomItem> Items { get; }
    public XamlMember Member { get; public set; }
    public XamlDomObject Parent { get; public set; }
    public XamlSchemaContext SchemaContext { get; public set; }
    public abstract virtual XamlDomItem get_Item();
    public abstract virtual void set_Item(XamlDomItem value);
    public abstract virtual IList`1<XamlDomItem> get_Items();
    public abstract virtual XamlMember get_Member();
    public abstract virtual void set_Member(XamlMember value);
    public abstract virtual XamlDomObject get_Parent();
    public abstract virtual void set_Parent(XamlDomObject value);
    public abstract virtual XamlSchemaContext get_SchemaContext();
    public abstract virtual void set_SchemaContext(XamlSchemaContext value);
    public abstract virtual void Seal();
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.XamlDom.IXamlDomNode {
    public string SourceFilePath { get; }
    public int EndLineNumber { get; public set; }
    public int EndLinePosition { get; public set; }
    public bool IsSealed { get; }
    public int StartLineNumber { get; public set; }
    public int StartLinePosition { get; public set; }
    public abstract virtual string get_SourceFilePath();
    public abstract virtual int get_EndLineNumber();
    public abstract virtual void set_EndLineNumber(int value);
    public abstract virtual int get_EndLinePosition();
    public abstract virtual void set_EndLinePosition(int value);
    public abstract virtual bool get_IsSealed();
    public abstract virtual int get_StartLineNumber();
    public abstract virtual void set_StartLineNumber(int value);
    public abstract virtual int get_StartLinePosition();
    public abstract virtual void set_StartLinePosition(int value);
    public abstract virtual void Seal();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.SealableNamespaceCollection : KeyedCollection`2<string, XamlDomNamespace> {
    private bool _isSealed;
    public bool IsSealed { get; }
    public void Seal();
    public bool get_IsSealed();
    protected virtual string GetKeyForItem(XamlDomNamespace item);
    protected virtual void InsertItem(int index, XamlDomNamespace item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, XamlDomNamespace item);
    protected virtual void ClearItems();
    private void CheckSealed();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomDFSValidator : object {
    private XamlDomObject _owner;
    private DirectUISchemaContext _schema;
    internal XamlDomDFSValidator(XamlDomObject owner, DirectUISchemaContext schema);
    internal virtual List`1<XamlCompileError> EnsureNoXBindIsUsedInsideAStyle();
}
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomItem : XamlDomNode {
    private XamlDomMember _parent;
    [DesignerSerializationVisibilityAttribute("0")]
[DefaultValueAttribute("")]
public XamlDomMember Parent { get; public set; }
    public XamlDomItem(string sourceFilePath);
    public XamlDomMember get_Parent();
    public void set_Parent(XamlDomMember value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomIterator : object {
    private Stack`1<XamlDomMember> _members;
    private Stack`1<int> _scopes;
    private XamlDomObject _owner;
    [CompilerGeneratedAttribute]
private XamlDomIteratorEnterNewScopeEvent EnterNewScopeCallback;
    [CompilerGeneratedAttribute]
private XamlDomIteratorExitNewScopeEvent ExitScopeCallback;
    internal XamlDomIterator(XamlDomObject owner);
    [CompilerGeneratedAttribute]
internal void add_EnterNewScopeCallback(XamlDomIteratorEnterNewScopeEvent value);
    [CompilerGeneratedAttribute]
internal void remove_EnterNewScopeCallback(XamlDomIteratorEnterNewScopeEvent value);
    [CompilerGeneratedAttribute]
internal void add_ExitScopeCallback(XamlDomIteratorExitNewScopeEvent value);
    [CompilerGeneratedAttribute]
internal void remove_ExitScopeCallback(XamlDomIteratorExitNewScopeEvent value);
    internal virtual IEnumerable`1<XamlDomObject> DescendantsAndSelf();
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomIterator/<DescendantsAndSelf>d__11")]
internal virtual IEnumerable`1<XamlDomObject> DescendantsAndSelf(XamlType type);
    private void ShouldNotifyNamingScopeEnter(XamlDomMember member);
    private static bool IsObjectNodeAssignable(XamlType type, XamlDomObject objectNode);
    private void ShouldNotifyNamingScopeExit();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomIteratorEnterNewScopeEvent : MulticastDelegate {
    public XamlDomIteratorEnterNewScopeEvent(object object, IntPtr method);
    public virtual void Invoke(XamlDomObject obj);
    public virtual IAsyncResult BeginInvoke(XamlDomObject obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomIteratorExitNewScopeEvent : MulticastDelegate {
    public XamlDomIteratorExitNewScopeEvent(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DebuggerDisplayAttribute("{Member.Name}")]
[ContentPropertyAttribute("ItemNodes")]
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomMember : XamlDomNode {
    private XamlMember member;
    private XamlNodeCollection`1<XamlDomItem> items;
    private XamlDomObject parent;
    private XamlSchemaContext schemaContext;
    private string unresolvedMemberName;
    private Type unresolvedDeclaringType;
    [CompilerGeneratedAttribute]
private ApiInformation <ApiInformation>k__BackingField;
    public ApiInformation ApiInformation { get; }
    public XamlSchemaContext SchemaContext { get; public set; }
    [DefaultValueAttribute("")]
public XamlMember Member { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public XamlDomObject Parent { get; public set; }
    public XamlDomItem Item { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public IList`1<XamlDomItem> Items { get; }
    private XamlDomItem Internal_Item { get; private set; }
    private IList`1<XamlDomItem> Internal_Items { get; }
    public XamlDomMember(XamlMember xamlMember, string sourceFilePath);
    [CompilerGeneratedAttribute]
public ApiInformation get_ApiInformation();
    public virtual XamlSchemaContext get_SchemaContext();
    public virtual void set_SchemaContext(XamlSchemaContext value);
    public virtual XamlMember get_Member();
    public virtual void set_Member(XamlMember value);
    public sealed virtual XamlDomObject get_Parent();
    public sealed virtual void set_Parent(XamlDomObject value);
    public virtual XamlDomItem get_Item();
    public virtual void set_Item(XamlDomItem value);
    public virtual IList`1<XamlDomItem> get_Items();
    private XamlDomItem get_Internal_Item();
    private void set_Internal_Item(XamlDomItem value);
    private IList`1<XamlDomItem> get_Internal_Items();
    public virtual void Seal();
    internal void Resolve();
    internal string LookupNamespaceByPrefix(string prefix);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomNamespace : XamlDomNode {
    private NamespaceDeclaration namespaceDeclaration;
    public NamespaceDeclaration NamespaceDeclaration { get; public set; }
    public XamlDomNamespace(NamespaceDeclaration namespaceDeclaration, string sourceFilePath);
    public NamespaceDeclaration get_NamespaceDeclaration();
    public void set_NamespaceDeclaration(NamespaceDeclaration value);
}
internal abstract class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomNode : object {
    private bool isSealed;
    private int startLineNumber;
    private int startLinePosition;
    private int endLineNumber;
    private int endLinePosition;
    [CompilerGeneratedAttribute]
private string <SourceFilePath>k__BackingField;
    public string SourceFilePath { get; }
    public int StartLineNumber { get; public set; }
    public int StartLinePosition { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndLinePosition { get; public set; }
    public bool IsSealed { get; }
    public XamlDomNode(string sourceFilePath);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SourceFilePath();
    public sealed virtual int get_StartLineNumber();
    public sealed virtual void set_StartLineNumber(int value);
    public sealed virtual int get_StartLinePosition();
    public sealed virtual void set_StartLinePosition(int value);
    public sealed virtual int get_EndLineNumber();
    public sealed virtual void set_EndLineNumber(int value);
    public sealed virtual int get_EndLinePosition();
    public sealed virtual void set_EndLinePosition(int value);
    public sealed virtual bool get_IsSealed();
    public virtual void Seal();
    protected void CheckSealed();
}
[DebuggerDisplayAttribute("<{Type.Name}>")]
[ContentPropertyAttribute("MemberNodes")]
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomObject : XamlDomItem {
    private SealableNamespaceCollection namespaces;
    private XamlSchemaContext schemaContext;
    private XamlType type;
    private bool isGetObject;
    private Type unresolvedType;
    private XamlNodeCollection`1<XamlDomMember> memberNodes;
    [CompilerGeneratedAttribute]
private ApiInformation <ApiInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private xPropertyInfo <XPropertyInfo>k__BackingField;
    public ApiInformation ApiInformation { get; }
    [DefaultValueAttribute("")]
public xPropertyInfo XPropertyInfo { get; public set; }
    [DefaultValueAttribute("")]
public XamlType Type { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsGetObject { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public KeyedCollection`2<string, XamlDomNamespace> Namespaces { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public IList`1<XamlDomMember> MemberNodes { get; }
    private IList`1<XamlDomMember> Internal_MemberNodes { get; }
    public XamlSchemaContext SchemaContext { get; public set; }
    public IEnumerable`1<XamlDomNamespace> AllXmlnsDefinitions { get; }
    public XamlDomObject(bool isGetObject, XamlType xamlType, string sourceFilePath);
    [CompilerGeneratedAttribute]
public ApiInformation get_ApiInformation();
    [CompilerGeneratedAttribute]
public xPropertyInfo get_XPropertyInfo();
    [CompilerGeneratedAttribute]
public void set_XPropertyInfo(xPropertyInfo value);
    public virtual XamlType get_Type();
    public virtual void set_Type(XamlType value);
    public virtual bool get_IsGetObject();
    public virtual void set_IsGetObject(bool value);
    public virtual KeyedCollection`2<string, XamlDomNamespace> get_Namespaces();
    public virtual IList`1<XamlDomMember> get_MemberNodes();
    private IList`1<XamlDomMember> get_Internal_MemberNodes();
    public virtual XamlSchemaContext get_SchemaContext();
    public virtual void set_SchemaContext(XamlSchemaContext value);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomObject/<get_AllXmlnsDefinitions>d__30")]
public IEnumerable`1<XamlDomNamespace> get_AllXmlnsDefinitions();
    public virtual void Seal();
    public bool HasMember(string instanceMember);
    public bool HasAttachableMember(XamlType declaringType, string attachableMember);
    public bool HasAttachableMember(Type declaringType, string attachableMember);
    public virtual bool HasMember(XamlMember xamlMember);
    public XamlDomMember GetMemberNode(string instanceMember);
    public XamlDomMember GetAttachableMemberNode(XamlType declaringType, string attachableMember);
    public XamlDomMember GetAttachableMemberNode(Type declaringType, string attachableMember);
    public virtual XamlDomMember GetMemberNode(XamlMember xamlMember, bool allowPropertyAliasing);
    public void SetAttachableMemberValue(Type declaringType, string attachableMember, object value);
    public void SetAttachableMemberValue(XamlType declaringType, string attachableMember, object value);
    public void SetMemberValue(string instanceMember, object value);
    public virtual void SetMemberValue(XamlMember xamlMember, object value);
    public virtual XamlDomMember RemoveMember(XamlMember xamlMember);
    public virtual XamlDomMember RemoveMemberNode(XamlDomMember node);
    public string ResolveXmlPrefix(string prefix);
    public XamlTypeName ResolveXmlNameToTypeName(string xName);
    public virtual XamlType ResolveXmlName(string xName);
    public XamlMember ResolveMemberName(XamlType xamlTargetType, string longPropertyName);
    public XamlMember ResolveMemberName(string longPropertyName);
    public XamlMember ResolveMemberName(XamlType xamlTargetType, XamlType memberType, string shortPropertyName);
    public virtual Type Resolve(string qualifiedTypeName);
    public virtual string GetNamespace(string prefix);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomObject/<GetNamespacePrefixes>d__54")]
public sealed virtual IEnumerable`1<NamespaceDeclaration> GetNamespacePrefixes();
    internal void Resolve();
    private XamlMember ResolveXamlMember(XamlType declaringType, string member);
    private XamlDomMember Logic_GetMemberNode(Type declaringType, string member);
    private XamlDomMember Logic_GetMemberNode(XamlType declaringXamlType, string member);
    private bool Logic_HasMember(Type declaringType, string member);
    private bool Logic_HasMember(XamlType declaringXamlType, string member);
    private void Logic_SetMember(XamlType declaringXamlType, string member, object value);
    private static void SplitQualifiedName(string qualifiedName, String& prefix, String& name);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomReader : XamlReader {
    private IEnumerator`1<XamlNode> nodes;
    private XamlSchemaContext schemaContext;
    private bool doNotReorder;
    public bool IsEof { get; }
    public XamlMember Member { get; }
    public NamespaceDeclaration Namespace { get; }
    public XamlNodeType NodeType { get; }
    public XamlSchemaContext SchemaContext { get; }
    public XamlType Type { get; }
    public object Value { get; }
    private bool System.Xaml.IXamlLineInfo.HasLineInfo { get; }
    private int System.Xaml.IXamlLineInfo.LineNumber { get; }
    private int System.Xaml.IXamlLineInfo.LinePosition { get; }
    public XamlDomReader(IXamlDomNode domNode, XamlSchemaContext schemaContext);
    public XamlDomReader(IXamlDomNode domNode, XamlSchemaContext schemaContext, XamlDomReaderSettings settings);
    public virtual bool get_IsEof();
    public virtual XamlMember get_Member();
    public virtual NamespaceDeclaration get_Namespace();
    public virtual XamlNodeType get_NodeType();
    public virtual XamlSchemaContext get_SchemaContext();
    public virtual XamlType get_Type();
    public virtual object get_Value();
    private sealed virtual override bool System.Xaml.IXamlLineInfo.get_HasLineInfo();
    private sealed virtual override int System.Xaml.IXamlLineInfo.get_LineNumber();
    private sealed virtual override int System.Xaml.IXamlLineInfo.get_LinePosition();
    public virtual bool Read();
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomReader/<WalkDom>d__26")]
private IEnumerable`1<XamlNode> WalkDom(IXamlDomNode domNode);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomReader/<ReadValueNode>d__27")]
private IEnumerable`1<XamlNode> ReadValueNode(XamlDomValue xamlDomValue);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomReader/<ReadMemberNode>d__28")]
private IEnumerable`1<XamlNode> ReadMemberNode(XamlDomMember memberNode);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomReader/<ReadObjectNode>d__29")]
private IEnumerable`1<XamlNode> ReadObjectNode(XamlDomObject objectNode);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomReader/<WriteElementMembers>d__30")]
private IEnumerable`1<XamlNode> WriteElementMembers(XamlDomObject objectNode);
    [IteratorStateMachineAttribute("Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomReader/<WritePossibleAttributes>d__31")]
private IEnumerable`1<XamlNode> WritePossibleAttributes(XamlDomObject objectNode);
    private static bool IsAttribute(XamlDomMember memberNode);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomReaderSettings : XamlReaderSettings {
    [CompilerGeneratedAttribute]
private bool <DoNotReorderMembers>k__BackingField;
    public bool DoNotReorderMembers { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DoNotReorderMembers();
    [CompilerGeneratedAttribute]
public void set_DoNotReorderMembers(bool value);
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomServices : object {
    public static XamlDomNode Load(XamlReader xamlReader, string sourceFilePath);
    public static void Save(XamlDomObject rootObjectNode, string fileName);
}
[DebuggerDisplayAttribute("{Value}")]
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomValue : XamlDomItem {
    private object _value;
    [DefaultValueAttribute("")]
public object Value { get; public set; }
    public XamlDomValue(string sourceFilePath);
    public XamlDomValue(object value, string sourceFilePath);
    public virtual object get_Value();
    public virtual void set_Value(object value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomWriter : XamlWriter {
    private string _sourceFilePath;
    private Stack`1<XamlDomNode> writerStack;
    [CompilerGeneratedAttribute]
private XamlDomNode <RootNode>k__BackingField;
    private XamlSchemaContext _schemaContext;
    private int _lineNumber;
    private int _linePosition;
    private List`1<XamlDomNamespace> _namespaces;
    public XamlDomNode RootNode { get; public set; }
    public XamlSchemaContext SchemaContext { get; }
    private bool System.Xaml.IXamlLineInfoConsumer.ShouldProvideLineInfo { get; }
    private XamlDomNode CurrentStackNode { get; }
    public XamlDomWriter(XamlSchemaContext schemaContext, string sourceFilePath);
    [CompilerGeneratedAttribute]
public XamlDomNode get_RootNode();
    [CompilerGeneratedAttribute]
public void set_RootNode(XamlDomNode value);
    public virtual void WriteGetObject();
    public virtual void WriteStartObject(XamlType type);
    private void WriteObject(XamlType xamlType, bool isGetObject);
    public virtual void WriteEndObject();
    public virtual void WriteStartMember(XamlMember xamlMember);
    public virtual void WriteEndMember();
    public virtual void WriteValue(object value);
    public virtual void WriteNamespace(NamespaceDeclaration namespaceDeclaration);
    public virtual XamlSchemaContext get_SchemaContext();
    private sealed virtual override void System.Xaml.IXamlLineInfoConsumer.SetLineInfo(int lineNumber, int linePosition);
    private sealed virtual override bool System.Xaml.IXamlLineInfoConsumer.get_ShouldProvideLineInfo();
    private XamlDomNode get_CurrentStackNode();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlNodeCollection`1 : object {
    private XamlDomNode _parentNode;
    private List`1<T> _nodes;
    private bool _isSealed;
    public int Count { get; }
    public bool IsSealed { get; }
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    private List`1<T> Nodes { get; }
    public XamlNodeCollection`1(XamlDomNode parent);
    public sealed virtual int get_Count();
    public void Seal();
    public bool get_IsSealed();
    public sealed virtual void Add(T node);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private List`1<T> get_Nodes();
    private void SetParent(T node);
    private static void SetParentToNull(T node);
    private void CheckSealed();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlDomValidator : object {
    private Lazy`1<List`1<XamlCompileError>> _errors;
    private Lazy`1<List`1<XamlCompileWarning>> _warnings;
    private NamedElementsStore _namedElementsHash;
    private DirectUISchemaContext _schemaContext;
    private bool _domRootHasCodeBehind;
    private bool _skipMinSdkValidation;
    private HashSet`1<string> _minVersionTypeCache;
    private HashSet`1<Tuple`2<string, string>> _minVersionMemberCache;
    private Dictionary`2<string, Version> _contractCache;
    [CompilerGeneratedAttribute]
private bool <IsPass1>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasUnknownChildren>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <TargetPlatformMinVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Platform <XamlPlatform>k__BackingField;
    public bool IsPass1 { get; public set; }
    public bool HasUnknownChildren { get; public set; }
    public Version TargetPlatformMinVersion { get; public set; }
    public Platform XamlPlatform { get; public set; }
    public bool HasErrors { get; }
    public List`1<XamlCompileError> Errors { get; }
    public bool HasWarnings { get; }
    public List`1<XamlCompileWarning> Warnings { get; }
    [CompilerGeneratedAttribute]
public bool get_IsPass1();
    [CompilerGeneratedAttribute]
public void set_IsPass1(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasUnknownChildren();
    [CompilerGeneratedAttribute]
public void set_HasUnknownChildren(bool value);
    [CompilerGeneratedAttribute]
public Version get_TargetPlatformMinVersion();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformMinVersion(Version value);
    [CompilerGeneratedAttribute]
public Platform get_XamlPlatform();
    [CompilerGeneratedAttribute]
public void set_XamlPlatform(Platform value);
    public bool Validate(XamlDomObject domRoot);
    public bool get_HasErrors();
    public List`1<XamlCompileError> get_Errors();
    public bool get_HasWarnings();
    public List`1<XamlCompileWarning> get_Warnings();
    private void CheckXaml(XamlDomObject domRoot);
    private bool CheckIsUnresolvedForwardedType(XamlDomObject domObject, String& errorMessage);
    private bool CheckIsUnresolvedForwardedType(XamlDomMember domMember, String& errorMessage);
    private void ForceTypeResolution(XamlType type);
    private bool ProcessUnknownObjectNode(XamlDomObject domObject);
    private void ErrorOnUnknownType(XamlDomObject domObject);
    private void ProcessObjectNode(XamlDomObject domObject, bool isRoot);
    private void ValidateTypePresentInMinVersion(Type type, XamlDomObject domObject, XamlDomMember domMember);
    private void ValidateMemberPresentInMinVersion(DirectUIXamlMember duiMember, XamlDomMember domMember);
    private void EnsureUniqueElementName(XamlDomObject domObject, string name);
    private void CheckDomObjectIsConstructibleOrTypeConvertable(XamlDomObject domObject);
    private void ProcessGetObjectNode(XamlDomObject domObject);
    private void ProcessClassName(XamlDomObject domRoot, XamlDomMember domMember, string className);
    private void ProcessNormalPropertyNode(XamlDomMember domMember);
    private void ProcessXBindPropertyNode(XamlDomMember domMember);
    private bool CheckIsAmbiguousEvent(XamlDomObject domObject, XamlDomMember domMember);
    private bool CheckCanAssignTextToProperty(XamlDomNode locationForErrors, XamlMember property, string text);
    private void ProcessNormalPropertyWithObjectChild(XamlDomMember domMember, XamlDomObject domChildObject);
    private void ProcessItemsNode(XamlDomObject domCollectionObject, XamlDomMember domItemsMember);
    private void ProcessCollectionItemsNode(XamlDomObject domCollectionObject, XamlDomMember domItemsMember);
    private void ProcessSpecialCollections(XamlDomObject domCollectionObject, XamlDomMember domItemsMember);
    private void ProcessStyleSetterCollection(XamlDomObject domStyleObject, XamlDomMember domItemsMember);
    private void ProcessSingleSetter(XamlType xamlTargetType, XamlDomObject domSetterObject);
    private XamlType GetAndResolveStyleTargetTypeProperty(XamlDomObject domStyleObject, bool reportErrors);
    private void CheckBasedOnIsCorrect(XamlDomObject domStyleObject, XamlType xamlTargetType, XamlDomMember domBasedOnMember);
    private void ProcessDictionaryItemsNode(XamlDomObject domDictionaryObject, XamlDomMember domItemsMember);
    private void ProcessUnknownMemberNode(XamlDomObject domObject, XamlDomMember domMember);
    private bool IsPossiblyALocalType(XamlType xamlType);
    private bool TryFindPropertyInSchema(XamlMember unknownMember, XamlMember& member);
    private void CheckPropertyTypeForIllegalValueType(XamlDomMember domMember);
    private bool HasStringAttribute(XamlDomObject domObject, XamlMember member);
    private bool TryGetStringAttribute(XamlDomObject domObject, XamlMember member, String& value, XamlDomMember& domMember);
    private void CheckIdDirectiveUsage(XamlDomObject domObject, XamlDomMember domMember, XamlDirective xamlDirective);
    private void CheckModifierUsage(XamlDomObject domObject, XamlDomMember domMember, XamlDirective xamlDirective);
    private XamlDomObject ResolveStaticResource(XamlDomObject domObject, string keyString, String& otherFile);
    private bool IsAnItemInAResourceDictionary(XamlDomObject item);
    private XamlDomObject FindKeyInResources(string keyString, XamlDomMember resources, XamlDomObject searchLimit);
    public static bool IsValidIdentifierName(string name);
    public static bool IsValidIdentifierName(string name, Int32& idx);
    public static bool IsValidKeyIdentifierName(string name);
    public static bool IsValidModifier(string modifierValue);
    public bool CanHaveDeferLoadStrategyOrLoad(XamlDomObject domObject);
    private void ValidateNamespaces(IEnumerable`1<XamlDomNamespace> namespacesToValidate);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlErrorDuplicateType : XamlCompileError {
    public XamlErrorDuplicateType(string fullName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlFileCodeInfo : object {
    private List`1<ConnectionIdElement> connectionIdElements;
    private List`1<DataTypeAssignment> dataTypeAssignments;
    private List`1<StrippableMember> strippableMembers;
    private List`1<StrippableObject> strippableObjects;
    private List`1<StrippableNamespace> strippableNamespaces;
    [CompilerGeneratedAttribute]
private string <SourceXamlGivenPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlOutputFilename>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasEventAssignments>k__BackingField;
    [CompilerGeneratedAttribute]
private BindStatus <BindStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private xPropertyInfo <XPropertyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPathToXamlFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApparentRelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelativePathFromGeneratedCodeToXamlFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPhaseAssignments>k__BackingField;
    public string SourceXamlGivenPath { get; public set; }
    public string XamlOutputFilename { get; public set; }
    public bool HasEventAssignments { get; public set; }
    public BindStatus BindStatus { get; public set; }
    public xPropertyInfo XPropertyInfo { get; public set; }
    public List`1<ConnectionIdElement> ConnectionIdElements { get; }
    public List`1<DataTypeAssignment> DataTypeAssignments { get; }
    public List`1<StrippableMember> StrippableMembers { get; }
    public List`1<StrippableObject> StrippableObjects { get; }
    public List`1<StrippableNamespace> StrippableNamespaces { get; }
    public string FullPathToXamlFile { get; public set; }
    public string ApparentRelativePath { get; public set; }
    public string RelativePathFromGeneratedCodeToXamlFile { get; public set; }
    public bool HasPhaseAssignments { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_SourceXamlGivenPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SourceXamlGivenPath(string value);
    [CompilerGeneratedAttribute]
public string get_XamlOutputFilename();
    [CompilerGeneratedAttribute]
public void set_XamlOutputFilename(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasEventAssignments();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HasEventAssignments(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual BindStatus get_BindStatus();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BindStatus(BindStatus value);
    [CompilerGeneratedAttribute]
public sealed virtual xPropertyInfo get_XPropertyInfo();
    [CompilerGeneratedAttribute]
public sealed virtual void set_XPropertyInfo(xPropertyInfo value);
    public sealed virtual List`1<ConnectionIdElement> get_ConnectionIdElements();
    public sealed virtual List`1<DataTypeAssignment> get_DataTypeAssignments();
    public sealed virtual List`1<StrippableMember> get_StrippableMembers();
    public sealed virtual List`1<StrippableObject> get_StrippableObjects();
    public sealed virtual List`1<StrippableNamespace> get_StrippableNamespaces();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullPathToXamlFile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FullPathToXamlFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ApparentRelativePath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ApparentRelativePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RelativePathFromGeneratedCodeToXamlFile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RelativePathFromGeneratedCodeToXamlFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasPhaseAssignments();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HasPhaseAssignments(bool value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlFileMustEndInDotXaml : XamlCompileError {
    public XamlFileMustEndInDotXaml(string fileName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlHarvester : object {
    private string _projectFolder;
    private bool _isPass1;
    private Platform _targPlat;
    private Dictionary`2<XamlDomObject, ConnectionIdElement> _collectedObjects;
    [CompilerGeneratedAttribute]
private bool <SkipNameFieldsForRootElements>k__BackingField;
    public bool SkipNameFieldsForRootElements { get; public set; }
    public XamlHarvester(string projectFolder, bool isPass1, Platform targPlat);
    [CompilerGeneratedAttribute]
public bool get_SkipNameFieldsForRootElements();
    [CompilerGeneratedAttribute]
public void set_SkipNameFieldsForRootElements(bool value);
    public XamlClassCodeInfo HarvestClassInfo(string classFullName, XamlDomObject domRoot, bool isApplication);
    public XamlFileCodeInfo HarvestXamlFileInfo(XamlClassCodeInfo classCodeInfo, XamlDomObject domRoot);
    private string GetFullTypePath(XamlType type);
    private bool IsACollectableCodeBehindElement(XamlDomObject domObject);
    private bool IsAPotentialBindingRoot(XamlDomObject domObject);
    internal static bool IsPossiblyALocalType(XamlType xamlType, String& usingTypePath);
    private bool CollectCodeBehindElements(XamlDomObject domRoot, XamlClassCodeInfo classCodeInfo, XamlFileCodeInfo fileCodeInfo);
    private void EnsureTemplateUniverse(ConnectionIdElement templateConnectionIdElement, XamlType dataRootType, XamlClassCodeInfo classCodeInfo);
    private ConnectionIdElement CollectElement(XamlDomObject domRoot, XamlDomObject domObject, BindUniverse bindUniverse, XamlClassCodeInfo classCodeInfo, XamlFileCodeInfo fileCodeInfo, XamlType dataRootType);
    public static string GetClassFullName(XamlDomObject domRoot);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlLocalAssemblyNotFound : XamlCompileWarning {
}
[ExtensionAttribute]
public static class Microsoft.UI.Xaml.Markup.Compiler.XamlMemberExtensions : object {
    [ExtensionAttribute]
internal static bool IsDependencyProperty(XamlMember instance);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlProjectInfo : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IFileItem> <AdditionalXamlTypeInfoIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLibrary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCLSCompliant>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGenCtrlFlags <CodeGenFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldGenerateDisableXBind>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ClassToHeaderFileMap>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GenXbf32Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GenXbf64Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GenXbfArm64Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VSDesignerDontLoadAsDll>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableTypeInfoReflection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDefaultValidationContextGeneration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInputValidationEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <TargetPlatformMinVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWin32App>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsingCSWinRT>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrecompiledHeaderFile>k__BackingField;
    public IEnumerable`1<IFileItem> AdditionalXamlTypeInfoIncludes { get; public set; }
    public string RootNamespace { get; public set; }
    public string ProjectName { get; public set; }
    public bool IsLibrary { get; public set; }
    public bool IsCLSCompliant { get; public set; }
    public CodeGenCtrlFlags CodeGenFlags { get; public set; }
    public bool ShouldGenerateDisableXBind { get; public set; }
    public Dictionary`2<string, string> ClassToHeaderFileMap { get; public set; }
    public string GenXbf32Path { get; public set; }
    public string GenXbf64Path { get; public set; }
    public string GenXbfArm64Path { get; public set; }
    public bool VSDesignerDontLoadAsDll { get; public set; }
    public bool EnableTypeInfoReflection { get; public set; }
    public bool EnableDefaultValidationContextGeneration { get; public set; }
    public bool GenerateIncrementalTypeInfo { get; }
    public bool GenerateProviderCode { get; }
    public bool GenerateCppWinRTStaticAsserts { get; }
    public bool GenerateOtherProvidersForCX { get; }
    public bool GenerateFullXamlMetadataProvider { get; }
    public bool IsInputValidationEnabled { get; public set; }
    public Version TargetPlatformMinVersion { get; public set; }
    public string XamlTypeInfoNamespace { get; }
    public string XamlTypeInfoReflectionNamespace { get; }
    public bool IsWin32App { get; public set; }
    public bool UsingCSWinRT { get; public set; }
    public string PrecompiledHeaderFile { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<IFileItem> get_AdditionalXamlTypeInfoIncludes();
    [CompilerGeneratedAttribute]
public void set_AdditionalXamlTypeInfoIncludes(IEnumerable`1<IFileItem> value);
    [CompilerGeneratedAttribute]
public string get_RootNamespace();
    [CompilerGeneratedAttribute]
public void set_RootNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public void set_ProjectName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsLibrary();
    [CompilerGeneratedAttribute]
public void set_IsLibrary(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCLSCompliant();
    [CompilerGeneratedAttribute]
public void set_IsCLSCompliant(bool value);
    [CompilerGeneratedAttribute]
public CodeGenCtrlFlags get_CodeGenFlags();
    [CompilerGeneratedAttribute]
public void set_CodeGenFlags(CodeGenCtrlFlags value);
    [CompilerGeneratedAttribute]
public bool get_ShouldGenerateDisableXBind();
    [CompilerGeneratedAttribute]
public void set_ShouldGenerateDisableXBind(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ClassToHeaderFileMap();
    [CompilerGeneratedAttribute]
public void set_ClassToHeaderFileMap(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_GenXbf32Path();
    [CompilerGeneratedAttribute]
public void set_GenXbf32Path(string value);
    [CompilerGeneratedAttribute]
public string get_GenXbf64Path();
    [CompilerGeneratedAttribute]
public void set_GenXbf64Path(string value);
    [CompilerGeneratedAttribute]
public string get_GenXbfArm64Path();
    [CompilerGeneratedAttribute]
public void set_GenXbfArm64Path(string value);
    [CompilerGeneratedAttribute]
public bool get_VSDesignerDontLoadAsDll();
    [CompilerGeneratedAttribute]
public void set_VSDesignerDontLoadAsDll(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableTypeInfoReflection();
    [CompilerGeneratedAttribute]
public void set_EnableTypeInfoReflection(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableDefaultValidationContextGeneration();
    [CompilerGeneratedAttribute]
public void set_EnableDefaultValidationContextGeneration(bool value);
    public bool HasCodeGenFlag(CodeGenCtrlFlags flag);
    public bool get_GenerateIncrementalTypeInfo();
    public bool get_GenerateProviderCode();
    public bool get_GenerateCppWinRTStaticAsserts();
    public bool get_GenerateOtherProvidersForCX();
    public bool get_GenerateFullXamlMetadataProvider();
    [CompilerGeneratedAttribute]
public bool get_IsInputValidationEnabled();
    [CompilerGeneratedAttribute]
public void set_IsInputValidationEnabled(bool value);
    [CompilerGeneratedAttribute]
public Version get_TargetPlatformMinVersion();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformMinVersion(Version value);
    public string get_XamlTypeInfoNamespace();
    public string get_XamlTypeInfoReflectionNamespace();
    [CompilerGeneratedAttribute]
public bool get_IsWin32App();
    [CompilerGeneratedAttribute]
public void set_IsWin32App(bool value);
    [CompilerGeneratedAttribute]
public bool get_UsingCSWinRT();
    [CompilerGeneratedAttribute]
public void set_UsingCSWinRT(bool value);
    [CompilerGeneratedAttribute]
public string get_PrecompiledHeaderFile();
    [CompilerGeneratedAttribute]
public void set_PrecompiledHeaderFile(string value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlRewriterErrorCompiledBindingLongForm : XamlCompileError {
    public XamlRewriterErrorCompiledBindingLongForm(int line, int column);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlRewriterErrorDataTypeLongForm : XamlCompileError {
    public XamlRewriterErrorDataTypeLongForm(int line, int column);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlRewriterErrorEventLongForm : XamlCompileError {
    public XamlRewriterErrorEventLongForm(int line, int column);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlRewriterErrorFileOpenFailure : XamlCompileError {
    public XamlRewriterErrorFileOpenFailure(string xamlFileName, string message);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlRewriterErrorLineBreak : XamlCompileError {
    public XamlRewriterErrorLineBreak(int line, int column);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlSchemaCodeInfo : object {
    private static Dictionary`2<string, ProjectionDefinition> _winRtPrimitiveTypeList;
    private List`1<InternalTypeEntry> _typeTable;
    private List`1<InternalXamlUserTypeInfo> _userTypeInfo;
    private List`1<InternalXamlUserMemberInfo> _userMemberInfo;
    private bool typeInfoReflectionEnabled;
    private IReadOnlyCollection`1<TypeForCodeGen> _otherMetadataProviders;
    public static bool SetAirityOnGenericTypeNames;
    public IReadOnlyCollection`1<TypeForCodeGen> OtherMetadataProviders { get; public set; }
    public bool TypeInfoReflectionEnabled { get; public set; }
    public List`1<InternalTypeEntry> TypeTableFromAllAssemblies { get; }
    public IReadOnlyList`1<InternalTypeEntry> TypeTable { get; }
    public List`1<InternalXamlUserTypeInfo> UserTypeInfo { get; }
    public List`1<InternalXamlUserMemberInfo> UserMemberInfo { get; }
    private static IDictionary`2<string, ProjectionDefinition> WinRtPrimitiveTypesForProjection { get; }
    private static XamlSchemaCodeInfo();
    public IReadOnlyCollection`1<TypeForCodeGen> get_OtherMetadataProviders();
    public void set_OtherMetadataProviders(IReadOnlyCollection`1<TypeForCodeGen> value);
    public bool get_TypeInfoReflectionEnabled();
    public void set_TypeInfoReflectionEnabled(bool value);
    public List`1<InternalTypeEntry> get_TypeTableFromAllAssemblies();
    private bool ShouldIncludeTypeInTypeTable(InternalTypeEntry type);
    public IReadOnlyList`1<InternalTypeEntry> get_TypeTable();
    public List`1<InternalXamlUserTypeInfo> get_UserTypeInfo();
    public List`1<InternalXamlUserMemberInfo> get_UserMemberInfo();
    public bool TryFindType(string systemName, InternalTypeEntry& type);
    public InternalTypeEntry AddTypeAndProperties(XamlType xamlType);
    public InternalTypeEntry AddReturnTypeStub(XamlType xamlType);
    public InternalTypeEntry AddType(XamlType xamlType, bool isReturnTypeStub);
    public InternalTypeEntry AddBindableType(XamlType type);
    private void AddAllCodeGenProperties(XamlType type);
    public bool TryFindIndexOfMember(string name, InternalTypeEntry declaringType, Int32& idx);
    private bool TryFindMember(string name, InternalTypeEntry declaringType, InternalXamlUserMemberInfo& member);
    private void AddCodeGenProperty(XamlMember xamlMember);
    public InternalXamlUserMemberInfo AddMember(InternalTypeEntry usingType, XamlMember xamlMember, bool declaringTypeAsStub);
    private InternalTypeEntry AddNewTypeEntry(XamlType xamlType);
    private InternalTypeEntry AddNewUserTypeInfo(XamlType xamlType, bool isReturnTypeStub);
    internal static string GetFullGenericNestedName(Type type, bool setAirity);
    public static string GetFullGenericNestedName(Type type, string programmingLanguage, bool globalized);
    public static bool GetGlobalizedFullNameForCppRefType(Type type, String& fullName);
    public static string GetFullGenericNestedName(Type type, string programmingLanguage, bool globalized, bool setAirity);
    internal static string FixNestedTypeName(Type type);
    internal static Type GetArrayElementType(Type type, String& suffix, string programmingLanguage);
    public static XamlTypeName GetXamlTypeNameFromFullName(string typeFullName);
    private static int CountTypeArgs(string namePart, String& remainder);
    private static IDictionary`2<string, ProjectionDefinition> get_WinRtPrimitiveTypesForProjection();
    public static bool IsProjectedPrimitiveCppType(string typeFullName);
    private static string ProjectionNameTranslation(string simpleTypeName, string programmingLanguage);
    private static bool IsTypeHandledByOtherProviders(Type type, IEnumerable`1<TypeForCodeGen> otherProviders);
    [CompilerGeneratedAttribute]
private bool <get_TypeTable>b__18_0(InternalTypeEntry t);
    [CompilerGeneratedAttribute]
private bool <get_UserTypeInfo>b__20_0(InternalXamlUserTypeInfo t);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlSchemaError_AmbiguousCollectionAdd : XamlCompileError {
    public XamlSchemaError_AmbiguousCollectionAdd(string typeName, string methodName, int argumentCount);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlSchemaError_BadBindablePropertyProvider : XamlCompileError {
    public XamlSchemaError_BadBindablePropertyProvider(string typeName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlSchemaError_BindableNotSupportedOnGeneric : XamlCompileError {
    public XamlSchemaError_BindableNotSupportedOnGeneric(string typeName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlSchemaError_CustomAttributesTypeLoadException : XamlCompileError {
    public XamlSchemaError_CustomAttributesTypeLoadException(string asmName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlSchemaError_TypeLoadException : XamlCompileError {
    public XamlSchemaError_TypeLoadException(string typeName, string asmName);
    public XamlSchemaError_TypeLoadException(XamlDomObject domObject, string typeName, string innerMessage);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlSchemaError_UnknownTypeError : XamlCompileError {
    public XamlSchemaError_UnknownTypeError(string typeName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlSchemaError_WRTAssembliesMissing : XamlCompileError {
}
internal static class Microsoft.UI.Xaml.Markup.Compiler.XamlSourceInfoFixer : object {
    public static string ReadMarkup(SourcePos start, SourcePos end, String[] xamlLines);
    public static FixedSourceInfo GetFixedSourceInfo(ILineNumberAndErrorInfo element, String[] xamlLines);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlSuccinctSyntaxError : XamlCompileError {
    public XamlSuccinctSyntaxError(int line, int col, string offendingToken, string fileName);
}
[ExtensionAttribute]
public static class Microsoft.UI.Xaml.Markup.Compiler.XamlTypeExtensions : object {
    [ExtensionAttribute]
internal static bool IsFloat(XamlType source);
    [ExtensionAttribute]
internal static bool IsString(XamlType source);
    [ExtensionAttribute]
internal static bool IsIntegerIndexable(XamlType source);
    [ExtensionAttribute]
internal static bool IsStringIndexable(XamlType source);
    [ExtensionAttribute]
public static bool ImplementsINotifyPropertyChanged(XamlType type);
    [ExtensionAttribute]
public static bool ImplementsINotifyCollectionChanged(XamlType type);
    [ExtensionAttribute]
public static bool ImplementsIObservableVector(XamlType type);
    [ExtensionAttribute]
public static bool ImplementsIObservableMap(XamlType type);
    [ExtensionAttribute]
public static bool ImplementsINotifyDataErrorInfo(XamlType type);
    [ExtensionAttribute]
private static bool InheritsFromNamedType(Type type, string inheritedTypeName);
    [ExtensionAttribute]
public static bool IsDependencyProperty(Type declaringType, string propertyName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlTypeInfoReflectionTypeNamingConventionViolation : XamlCompileWarning {
    public XamlTypeInfoReflectionTypeNamingConventionViolation(string typeName, string asmName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlTypeInfoValidator : object {
    private DirectUISchemaContext schema;
    private List`1<XamlCompileError> errors;
    private List`1<XamlCompileWarning> warnings;
    public IEnumerable`1<XamlCompileError> Errors { get; }
    public IEnumerable`1<XamlCompileWarning> Warnings { get; }
    public XamlTypeInfoValidator(DirectUISchemaContext duiSchema);
    public IEnumerable`1<XamlCompileError> get_Errors();
    public IEnumerable`1<XamlCompileWarning> get_Warnings();
    public void Validate(IEnumerable`1<InternalTypeEntry> typeTable);
    private void ValidateCreateFromStringMethods(IEnumerable`1<InternalTypeEntry> typeTable);
    private void ValidateCreateFromStringMethod(InternalTypeEntry declaringType);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlTypeNameConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationConditionalNamespaceError : XamlCompileError {
    public XamlValidationConditionalNamespaceError(string expressionBeingParsed, string message, XamlDomNode domNode);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationCreateFromStringError : XamlCompileError {
    public XamlValidationCreateFromStringError(string typeName, string createFromStringMethodName, string message, XamlDomNode locationForErrors);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationDictionaryKeyError : XamlCompileError {
    public XamlValidationDictionaryKeyError(XamlDomObject domObject);
    public XamlValidationDictionaryKeyError(XamlDomObject domObject, string keyText);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_CannotHaveDeferLoadStrategy : XamlCompileError {
    public XamlValidationError_CannotHaveDeferLoadStrategy(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_CantResolveDataType : XamlCompileError {
    public XamlValidationError_CantResolveDataType(XamlDomObject domObject, string dataTypeName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_DataTypeOnlyAllowedOnDataTemplate : XamlCompileError {
    public XamlValidationError_DataTypeOnlyAllowedOnDataTemplate(XamlDomObject domObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_DefaultBindModeInvalidValue : XamlCompileError {
    public XamlValidationError_DefaultBindModeInvalidValue(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_DeferLoadStrategyInvalidValue : XamlCompileError {
    public XamlValidationError_DeferLoadStrategyInvalidValue(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_DeferLoadStrategyMissingXName : XamlCompileError {
    public XamlValidationError_DeferLoadStrategyMissingXName(XamlDomObject domObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_InvalidValueForPhase : XamlCompileError {
    public XamlValidationError_InvalidValueForPhase(XamlDomObject domObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_LoadConflict : XamlCompileError {
    public XamlValidationError_LoadConflict(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_LoadInvalidValue : XamlCompileError {
    public XamlValidationError_LoadInvalidValue(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_LoadMissingName : XamlCompileError {
    public XamlValidationError_LoadMissingName(XamlDomObject domObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_LoadNotSupported : XamlCompileError {
    public XamlValidationError_LoadNotSupported(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_PhaseCanBeUsedOnlyWithBind : XamlCompileError {
    public XamlValidationError_PhaseCanBeUsedOnlyWithBind(XamlDomObject domObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationError_PhaseOnlyAllowedInDataTemplate : XamlCompileError {
    public XamlValidationError_PhaseOnlyAllowedInDataTemplate(XamlDomObject domObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorAmbiguousEvent : XamlCompileError {
    public XamlValidationErrorAmbiguousEvent(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorAssignment : XamlCompileError {
    public XamlValidationErrorAssignment(XamlDomObject domChildObject, XamlMember property, XamlType propertyItemType);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorBadCPA : XamlCompileError {
    public XamlValidationErrorBadCPA(XamlDomObject domObject, string cpaName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorBadName : XamlCompileError {
    public XamlValidationErrorBadName(XamlDomMember domMember, string name);
    public XamlValidationErrorBadName(XamlDomMember domMember, string name, char badChar);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorCannotAssignNullableProperty : XamlCompileError {
    public XamlValidationErrorCannotAssignNullableProperty(XamlDomNode location, XamlMember member);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorCannotAssignTextToProperty : XamlCompileError {
    public XamlValidationErrorCannotAssignTextToProperty(XamlDomNode location, XamlMember member, string value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorCannotAssignToReadOnlyProperty : XamlCompileError {
    public XamlValidationErrorCannotAssignToReadOnlyProperty(XamlDomMember domMember);
    public XamlValidationErrorCannotAssignToReadOnlyProperty(XamlDomNode location, XamlMember member, string value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorCannotNameElementTwice : XamlCompileError {
    public XamlValidationErrorCannotNameElementTwice(XamlDomObject domObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorCannotNameValueTypes : XamlCompileError {
    public XamlValidationErrorCannotNameValueTypes(XamlDomObject domObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorClassMustHaveANamespace : XamlCompileError {
    public XamlValidationErrorClassMustHaveANamespace(XamlDomMember domMember, string classname);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorClassNameEmptyPathPart : XamlCompileError {
    public XamlValidationErrorClassNameEmptyPathPart(XamlDomMember domMember, string classname);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorClassNameNoWhiteSpace : XamlCompileError {
    public XamlValidationErrorClassNameNoWhiteSpace(XamlDomMember domMember, string classname);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorCollectionAdd : XamlCompileError {
    public XamlValidationErrorCollectionAdd(XamlDomItem domChildItem, XamlType itemType, XamlDomObject collectionObject, XamlDomMember collectionMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorContractDoesNotExist : XamlCompileWarning {
    public XamlValidationErrorContractDoesNotExist(XamlDomObject domObject, string typeName, string contractName, string runtimeVer);
    public XamlValidationErrorContractDoesNotExist(XamlDomMember domMember, string typeName, string contractName, string runtimeVer);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorDeprecated : XamlCompileError {
    public XamlValidationErrorDeprecated(XamlDomObject domObject, string name, string message);
    public XamlValidationErrorDeprecated(XamlDomMember domMember, string name, string message);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorDictionaryAdd : XamlCompileError {
    public XamlValidationErrorDictionaryAdd(XamlDomValue domChildValue);
    public XamlValidationErrorDictionaryAdd(XamlDomObject domChildObject, XamlType itemType, XamlDomObject domDictionaryObject, XamlDomMember domDictionaryProperty);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorDuplicateAssigment : XamlCompileError {
    public XamlValidationErrorDuplicateAssigment(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorElementNameAlreadyUsed : XamlCompileError {
    public XamlValidationErrorElementNameAlreadyUsed(XamlDomObject domObject, string duplicateName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorEventValuesMustBeText : XamlCompileError {
    public XamlValidationErrorEventValuesMustBeText(XamlDomNode domNode, string eventName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorInvalidFieldModifier : XamlCompileError {
    public XamlValidationErrorInvalidFieldModifier(XamlDomObject domObject, string invalidModifier);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorMissingCPA : XamlCompileError {
    public XamlValidationErrorMissingCPA(XamlDomObject domParentObject, XamlDomItem firstChild);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorNonPublicType : XamlCompileError {
    public XamlValidationErrorNonPublicType(XamlDomObject domObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorNotConstructibleObject : XamlCompileError {
    public XamlValidationErrorNotConstructibleObject(XamlDomObject domObject, XamlType xamlType);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorSetterMissingField : XamlCompileError {
    public XamlValidationErrorSetterMissingField(XamlDomNode setterOrProperty, bool isProperty);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorSetterSetterPropertyMustBeDP : XamlCompileError {
    public XamlValidationErrorSetterSetterPropertyMustBeDP(XamlDomMember domPropertyMember, string propertyName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorSetterUnknownMember : XamlCompileError {
    public XamlValidationErrorSetterUnknownMember(XamlDomMember domPropertyMember, XamlType xamlTargetType, string propertyName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorStyleBasedOnBadStyleTargetType : XamlCompileError {
    public XamlValidationErrorStyleBasedOnBadStyleTargetType(XamlDomNode styleObject, XamlType targetType, XamlType basedOnTargetType);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorStyleBasedOnMustBeStyle : XamlCompileError {
    public XamlValidationErrorStyleBasedOnMustBeStyle(XamlDomObject styleObject, string keyString, XamlDomObject domBaseStyleObject, string otherFile);
    public XamlValidationErrorStyleBasedOnMustBeStyle(XamlDomObject styleObject, XamlDomObject domNotStyleObject);
    public XamlValidationErrorStyleBasedOnMustBeStyle(XamlDomObject styleObject, string text);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorStyleMustHaveTargetType : XamlCompileError {
    public XamlValidationErrorStyleMustHaveTargetType(XamlDomNode styleOrTargetType);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorUnknownMember : XamlCompileError {
    public XamlValidationErrorUnknownMember(XamlDomObject domObject, XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorUnknownObject : XamlCompileError {
    public XamlValidationErrorUnknownObject(XamlDomObject domObject);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorUnknownStyleTargetType : XamlCompileError {
    public XamlValidationErrorUnknownStyleTargetType(XamlDomMember targetTypeMember, string typeName);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorUnresolvedForwardedTypeAssembly : XamlCompileError {
    public XamlValidationErrorUnresolvedForwardedTypeAssembly(XamlDomMember domMember, string errorMessage);
    public XamlValidationErrorUnresolvedForwardedTypeAssembly(XamlDomObject domObject, string errorMessage);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationErrorWrongContract : XamlCompileWarning {
    public XamlValidationErrorWrongContract(XamlDomObject domObject, string typeName, string contractName, string runtimeVer, string parseVer);
    public XamlValidationErrorWrongContract(XamlDomMember domMember, string typeName, string contractName, string runtimeVer, string parseVer);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationIdPropertiesMustBeText : XamlCompileError {
    public XamlValidationIdPropertiesMustBeText(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationPlatformConditionalStrict : XamlCompileError {
    public XamlValidationPlatformConditionalStrict(XamlDomNode domNode);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationWarningDeprecated : XamlCompileWarning {
    public XamlValidationWarningDeprecated(IXamlDomNode domObject, string name, string message);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationWarningExperimental : XamlCompileWarning {
    public XamlValidationWarningExperimental(ErrorCode warningCode, string name);
    public XamlValidationWarningExperimental(ErrorCode warningCode, IXamlDomNode domNode, string name);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationWarningNoXaml : XamlCompileWarning {
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationWarningPreview : XamlCompileWarning {
    public XamlValidationWarningPreview(ErrorCode warningCode, string name);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationWarningUnsupportedCodeGenFlags : XamlCompileWarning {
    public XamlValidationWarningUnsupportedCodeGenFlags(CodeGenCtrlFlags flags);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlValidationWarningUsingCodeGenFlags : XamlCompileWarning {
    public XamlValidationWarningUsingCodeGenFlags(CodeGenCtrlFlags flags);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindControlTemplateDoesNotDefineTargetTypeError : XamlCompileError {
    public XamlXBindControlTemplateDoesNotDefineTargetTypeError(IXamlDomNode node);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindDataTemplateDoesNotDefineDataTypeError : XamlCompileError {
    public XamlXBindDataTemplateDoesNotDefineDataTypeError(IXamlDomNode node);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindInsideXBindError : XamlCompileError {
    public XamlXBindInsideXBindError(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindOnControlTemplateError : XamlCompileError {
    public XamlXBindOnControlTemplateError(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindOutOfScopeUnsupported : XamlCompileError {
    public XamlXBindOutOfScopeUnsupported(BindAssignment ba, string elementName, int namedElementLineNumber);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindParseError : XamlCompileError {
    public XamlXBindParseError(IXamlDomNode node, CompiledBindingParseException ex);
    public XamlXBindParseError(BindAssignmentBase bindAssignment, CompiledBindingParseException ex);
    public XamlXBindParseError(BindAssignmentBase bindAssignment, int startCharacterPosition, string expressionBeingParsed, string exceptionMessage);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindParseWarning : XamlCompileWarning {
    public XamlXBindParseWarning(XamlDomObject domObject, string message);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindRootNoLoadingEvent : XamlCompileError {
    public XamlXBindRootNoLoadingEvent(XamlDomMember domMember, string rootElementType);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindTargetNullValueOnNonNullableTypeError : XamlCompileError {
    public XamlXBindTargetNullValueOnNonNullableTypeError(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindTwoWayBindingToANonDependencyPropertyError : XamlCompileError {
    public XamlXBindTwoWayBindingToANonDependencyPropertyError(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindUsedInStyleError : XamlCompileError {
    public XamlXBindUsedInStyleError(IXamlDomNode node);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXBindWithoutCodeBehindError : XamlCompileError {
    public XamlXBindWithoutCodeBehindError(XamlDomMember domMember);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XamlXClassDerivedFromXClassWarning : XamlCompileWarning {
    public XamlXClassDerivedFromXClassWarning(XamlDomObject domObject, string derivedClass, string baseClass);
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.XBF.IXbfFileNameInfo {
    public string GivenXamlName { get; public set; }
    public string InputXamlName { get; public set; }
    public string OutputXbfName { get; public set; }
    public string XamlFileChecksum { get; public set; }
    public abstract virtual string get_GivenXamlName();
    public abstract virtual void set_GivenXamlName(string value);
    public abstract virtual string get_InputXamlName();
    public abstract virtual void set_InputXamlName(string value);
    public abstract virtual string get_OutputXbfName();
    public abstract virtual void set_OutputXbfName(string value);
    public abstract virtual string get_XamlFileChecksum();
    public abstract virtual void set_XamlFileChecksum(string value);
}
[GuidAttribute("d0aa6fc8-087f-46cf-b36a-7e68f8295ceb")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.UI.Xaml.Markup.Compiler.XBF.IXbfMember {
    public bool IsAttachable { get; }
    public bool IsDependencyProperty { get; }
    public bool IsReadOnly { get; }
    public string Name { get; }
    public IXbfType TargetType { get; }
    public IXbfType Type { get; }
    public abstract virtual bool get_IsAttachable();
    public abstract virtual bool get_IsDependencyProperty();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual string get_Name();
    public abstract virtual IXbfType get_TargetType();
    public abstract virtual IXbfType get_Type();
    public abstract virtual object GetValue(object instance);
    public abstract virtual void SetValue(object instance, object value);
}
[GuidAttribute("ef46679c-4ec5-447a-bd26-e04f1d2c2551")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.UI.Xaml.Markup.Compiler.XBF.IXbfMetadataProvider {
    public abstract virtual IXbfType GetXamlType(Type type);
    public abstract virtual IXbfType GetXamlType(string fullName);
    public abstract virtual Object[] GetXmlnsDefinitions();
}
[GuidAttribute("a50fc345-4c61-411b-8a68-13da7b7c4ee4")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.UI.Xaml.Markup.Compiler.XBF.IXbfType {
    public IXbfType BaseType { get; }
    public IXbfMember ContentProperty { get; }
    public string FullName { get; }
    public bool IsArray { get; }
    public bool IsCollection { get; }
    public bool IsConstructible { get; }
    public bool IsDictionary { get; }
    public bool IsMarkupExtension { get; }
    public bool IsBindable { get; }
    public IXbfType ItemType { get; }
    public IXbfType KeyType { get; }
    public IXbfType BoxedType { get; }
    public Type UnderlyingType { get; }
    public abstract virtual IXbfType get_BaseType();
    public abstract virtual IXbfMember get_ContentProperty();
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsCollection();
    public abstract virtual bool get_IsConstructible();
    public abstract virtual bool get_IsDictionary();
    public abstract virtual bool get_IsMarkupExtension();
    public abstract virtual bool get_IsBindable();
    public abstract virtual IXbfType get_ItemType();
    public abstract virtual IXbfType get_KeyType();
    public abstract virtual IXbfType get_BoxedType();
    public abstract virtual Type get_UnderlyingType();
    public abstract virtual object ActivateInstance();
    public abstract virtual object CreateFromString(string value);
    public abstract virtual IXbfMember GetMember(string name);
    public abstract virtual void AddToVector(object instance, object value);
    public abstract virtual void AddToMap(object instance, object key, object value);
    public abstract virtual void RunInitializer();
}
internal interface Microsoft.UI.Xaml.Markup.Compiler.XBF.IXmpXamlType {
    public abstract virtual IXbfType GetXmpXamlType(DirectUIXamlType xamlType);
}
public class Microsoft.UI.Xaml.Markup.Compiler.XBF.TargetOSVersion : object {
    [CLSCompliantAttribute("False")]
public ushort major;
    [CLSCompliantAttribute("False")]
public ushort minor;
    [CLSCompliantAttribute("False")]
public ushort build;
    [CLSCompliantAttribute("False")]
public ushort revision;
}
[ExtensionAttribute]
internal static class Microsoft.UI.Xaml.Markup.Compiler.XBF.TargetOSVersionExtension : object {
    [ExtensionAttribute]
public static TargetOSVersion ToTargetOSVersion(Version version);
}
internal enum Microsoft.UI.Xaml.Markup.Compiler.XBF.XbfErrorConstants : Enum {
    public int value__;
    public static XbfErrorConstants PropertyNotFound;
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XBF.XbfFileNameInfo : object {
    [CompilerGeneratedAttribute]
private string <GivenXamlName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InputXamlName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputXbfName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlFileChecksum>k__BackingField;
    public string GivenXamlName { get; public set; }
    public string InputXamlName { get; public set; }
    public string OutputXbfName { get; public set; }
    public string XamlFileChecksum { get; public set; }
    public XbfFileNameInfo(string sourceXamlFullName, string givenXaml, string inputXaml, string outputXbf, string checksum);
    [CompilerGeneratedAttribute]
public sealed virtual string get_GivenXamlName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_GivenXamlName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_InputXamlName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_InputXamlName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OutputXbfName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputXbfName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_XamlFileChecksum();
    [CompilerGeneratedAttribute]
public sealed virtual void set_XamlFileChecksum(string value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XBF.XbfGenerator : object {
    private static Dictionary`2<Version, IntPtr> s_GenXbfDllHandles;
    private List`1<IXbfFileNameInfo> xamlFiles;
    private IXbfMetadataProvider xbfMetadataProvider;
    private XamlProjectInfo projectInfo;
    private Lazy`1<List`1<XamlCompileWarning>> warningMessages;
    private Lazy`1<List`1<XamlCompileError>> errorMessages;
    public List`1<XamlCompileWarning> XbfWarnings { get; }
    public List`1<XamlCompileError> XbfErrors { get; }
    public XbfGenerator(XamlProjectInfo projectInfo, IXbfMetadataProvider xbfMetadataProvider);
    private static XbfGenerator();
    public List`1<XamlCompileWarning> get_XbfWarnings();
    public List`1<XamlCompileError> get_XbfErrors();
    public void SetXamlInputFilesFromTaskItems(IEnumerable`1<TaskItemFilename> tifs, bool isSdk);
    public void SetXamlInputFiles(IEnumerable`1<IXbfFileNameInfo> xamlFiles);
    public bool GenerateXbfFiles(UInt32 xbfGenerationFlags, bool v80Compat);
    internal virtual List`1<IStream> GetInputOutputStreams();
    internal virtual bool GenerateXbfFromStreams(IntPtr dllHandle, IStream[] inputStreams, IStream[] outputStreams, UInt32 xbfGenerationFlags, String[] checksums, TargetOSVersion targetOS, Int32& errorCode, Int32& errorFile, Int32& errorLine, Int32& errorPosition);
    internal virtual string GetTextLine(string fileName, int line);
    private String[] GetAllXamlFilesChecksums();
    private bool GenerateAll(IntPtr dllHandle, UInt32 xbfGenerationFlags);
    private void LogXbfError(int errorCode, int errorFile, int errorLine, int errorPosition);
    private bool IsMarkupExtensionAssignmentError(string fileName, int line, int pos, String& additional);
    private bool LookslikeMarkupExtensionAssigment(string textLine, int pos, String& meName);
    private string ScanIdentifierToken(string textLine, int start);
    private static void ClearCache();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XBF.XbfMetadataProvider : object {
    private DirectUISchemaContext _schema;
    private Dictionary`2<string, IXbfType> _standardNames;
    private Dictionary`2<DirectUIXamlType, IXbfType> _typeMap;
    public XbfMetadataProvider(DirectUISchemaContext schema);
    public sealed virtual IXbfType GetXamlType(string fullName);
    public sealed virtual IXbfType GetXamlType(Type type);
    public sealed virtual IXbfType GetXmpXamlType(DirectUIXamlType xamlType);
    public sealed virtual Object[] GetXmlnsDefinitions();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XBF.XbfXamlMember : object {
    private DirectUIXamlMember _xamlMember;
    private IXmpXamlType _xmp;
    public bool IsAttachable { get; }
    public bool IsDependencyProperty { get; }
    public bool IsReadOnly { get; }
    public string Name { get; }
    public IXbfType TargetType { get; }
    public IXbfType Type { get; }
    public XbfXamlMember(DirectUIXamlMember member, IXmpXamlType xmp);
    public sealed virtual bool get_IsAttachable();
    public sealed virtual bool get_IsDependencyProperty();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual string get_Name();
    public sealed virtual IXbfType get_TargetType();
    public sealed virtual IXbfType get_Type();
    public sealed virtual void SetValue(object instance, object value);
    public sealed virtual object GetValue(object instance);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XBF.XbfXamlType : object {
    private DirectUIXamlType _xamlType;
    private IXmpXamlType _xmp;
    private Dictionary`2<string, XbfXamlMember> _memberMap;
    private Nullable`1<bool> isBindable;
    private string _fullName;
    public IXbfType BaseType { get; }
    public IXbfMember ContentProperty { get; }
    public string FullName { get; }
    public bool IsArray { get; }
    public bool IsBindable { get; }
    public bool IsCollection { get; }
    public bool IsConstructible { get; }
    public bool IsDictionary { get; }
    public bool IsMarkupExtension { get; }
    public IXbfType ItemType { get; }
    public IXbfType KeyType { get; }
    public IXbfType BoxedType { get; }
    public Type UnderlyingType { get; }
    public XbfXamlType(DirectUIXamlType xamlType, IXmpXamlType xmp);
    public sealed virtual IXbfType get_BaseType();
    public sealed virtual IXbfMember get_ContentProperty();
    public sealed virtual string get_FullName();
    public sealed virtual IXbfMember GetMember(string name);
    public sealed virtual bool get_IsArray();
    public sealed virtual bool get_IsBindable();
    public sealed virtual bool get_IsCollection();
    public sealed virtual bool get_IsConstructible();
    public sealed virtual bool get_IsDictionary();
    public sealed virtual bool get_IsMarkupExtension();
    public sealed virtual IXbfType get_ItemType();
    public sealed virtual IXbfType get_KeyType();
    public sealed virtual IXbfType get_BoxedType();
    public sealed virtual Type get_UnderlyingType();
    public sealed virtual object ActivateInstance();
    public sealed virtual void AddToMap(object instance, object key, object value);
    public sealed virtual void AddToVector(object instance, object value);
    public sealed virtual object CreateFromString(string value);
    public sealed virtual void RunInitializer();
    private bool HasBindableAttribute();
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XbfGeneration_CouldNotLoadXbfGenerator : XamlCompileError {
    public XbfGeneration_CouldNotLoadXbfGenerator(string path);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XbfGeneration_NonMeInCurlyBraces : XamlCompileError {
    public XbfGeneration_NonMeInCurlyBraces(string fileName, int line, int column, string nonMeName, int xbfErrorCode);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XbfGeneration_NoWindowsSdk : XamlCompileError {
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XbfGenerationGeneralFailure : XamlCompileError {
    public XbfGenerationGeneralFailure(string message);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XbfGenerationParseError : XamlCompileError {
    public XbfGenerationParseError(string fileName, int line, int column, int xbfErrorCode);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XbfGenerationPropertyNotFoundError : XamlCompileError {
    public XbfGenerationPropertyNotFoundError(string fileName, int line, int column);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XbfInputFileOpenFailure : XamlCompileError {
    public XbfInputFileOpenFailure(string xbfFile, string message);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.XbfOutputFileOpenFailure : XamlCompileError {
    public XbfOutputFileOpenFailure(string xbfFile, string message);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.xProperty : object {
    public string Name;
    public bool IsReadOnly;
    public XamlType PropertyType;
    public XamlDomObject OriginalXProperty;
    private string _changedHandler;
    public string FullTypeName;
    public string DefaultValueMarkup;
    public string DefaultValueString;
    public string CodegenComment;
    public string ChangedHandler { get; public set; }
    public string get_ChangedHandler();
    public void set_ChangedHandler(string value);
}
internal class Microsoft.UI.Xaml.Markup.Compiler.xPropertyInfo : object {
    public XamlDomObject xPropertiesNode;
    public XamlDomObject xPropertiesRoot;
    public List`1<xProperty> xProperties;
}
[CompilerGeneratedAttribute]
[GuidAttribute("E05097E8-AFE8-4590-9A7C-7E229EBD2D4C")]
[TypeIdentifierAttribute]
public interface Microsoft.VisualStudio.ProjectSystem.Interop.IVsMSBuildTaskFreeThreadedFileManager {
    public abstract virtual void Delete(string fileName);
    public abstract virtual bool Exists(string fileName, bool onlyCheckOnDisk);
    public abstract virtual TextReader GetFileContents(string fileName);
    public abstract virtual DateTime GetFileLastChangeTime(string fileName);
    public abstract virtual void PutGeneratedFileContents(string fileName, string contents);
}
internal class MS.Internal.Serialization.StringValueSerializer : ValueSerializer {
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
internal class MS.Internal.Serialization.TypeConverterValueSerializer : ValueSerializer {
    private TypeConverter converter;
    public TypeConverterValueSerializer(TypeConverter converter);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
}
[AttributeUsageAttribute("5628")]
internal class MS.Internal.WindowsBase.FriendAccessAllowedAttribute : Attribute {
}
internal static class MS.Internal.Xaml.Context.ContextServices : object {
    public static object GetTargetProperty(ObjectWriterContext xamlContext);
}
internal class MS.Internal.Xaml.Context.FixupTarget : object {
    [CompilerGeneratedAttribute]
private XamlMember <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceName>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <InstanceType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TemporaryCollectionIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndInstanceLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndInstanceLinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private FixupTargetKeyHolder <KeyHolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstanceIsOnTheStack>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstanceWasGotten>k__BackingField;
    public XamlMember Property { get; public set; }
    public object Instance { get; public set; }
    public string InstanceName { get; public set; }
    public XamlType InstanceType { get; public set; }
    public int TemporaryCollectionIndex { get; public set; }
    public int EndInstanceLineNumber { get; public set; }
    public int EndInstanceLinePosition { get; public set; }
    public FixupTargetKeyHolder KeyHolder { get; public set; }
    public bool InstanceIsOnTheStack { get; public set; }
    public bool InstanceWasGotten { get; public set; }
    [CompilerGeneratedAttribute]
public XamlMember get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(XamlMember value);
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(object value);
    [CompilerGeneratedAttribute]
public string get_InstanceName();
    [CompilerGeneratedAttribute]
public void set_InstanceName(string value);
    [CompilerGeneratedAttribute]
public XamlType get_InstanceType();
    [CompilerGeneratedAttribute]
public void set_InstanceType(XamlType value);
    [CompilerGeneratedAttribute]
public int get_TemporaryCollectionIndex();
    [CompilerGeneratedAttribute]
public void set_TemporaryCollectionIndex(int value);
    [CompilerGeneratedAttribute]
public int get_EndInstanceLineNumber();
    [CompilerGeneratedAttribute]
public void set_EndInstanceLineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_EndInstanceLinePosition();
    [CompilerGeneratedAttribute]
public void set_EndInstanceLinePosition(int value);
    [CompilerGeneratedAttribute]
public FixupTargetKeyHolder get_KeyHolder();
    [CompilerGeneratedAttribute]
public void set_KeyHolder(FixupTargetKeyHolder value);
    [CompilerGeneratedAttribute]
public bool get_InstanceIsOnTheStack();
    [CompilerGeneratedAttribute]
public void set_InstanceIsOnTheStack(bool value);
    [CompilerGeneratedAttribute]
public bool get_InstanceWasGotten();
    [CompilerGeneratedAttribute]
public void set_InstanceWasGotten(bool value);
    private sealed virtual override XamlException MS.Internal.Xaml.Runtime.IAddLineInfo.WithLineInfo(XamlException ex);
}
internal class MS.Internal.Xaml.Context.FixupTargetKeyHolder : object {
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    public object Key { get; public set; }
    public FixupTargetKeyHolder(object key);
    [CompilerGeneratedAttribute]
public object get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(object value);
}
internal enum MS.Internal.Xaml.Context.FixupType : Enum {
    public int value__;
    public static FixupType MarkupExtensionFirstRun;
    public static FixupType MarkupExtensionRerun;
    public static FixupType PropertyValue;
    public static FixupType ObjectInitializationValue;
    public static FixupType UnresolvedChildren;
}
internal interface MS.Internal.Xaml.Context.ICheckIfInitialized {
    public abstract virtual bool IsFullyInitialized(object obj);
}
internal class MS.Internal.Xaml.Context.NameFixupGraph : object {
    private Dictionary`2<object, FrugalObjectList`1<NameFixupToken>> _dependenciesByParentObject;
    private Dictionary`2<object, NameFixupToken> _dependenciesByChildObject;
    private Dictionary`2<string, FrugalObjectList`1<NameFixupToken>> _dependenciesByName;
    private Queue`1<NameFixupToken> _resolvedTokensPendingProcessing;
    private NameFixupToken _deferredRootProvideValue;
    private HashSet`1<object> _uninitializedObjectsAtParseEnd;
    public bool HasResolvedTokensPendingProcessing { get; }
    public void AddDependency(NameFixupToken fixupToken);
    public bool HasUnresolvedChildren(object parent);
    public bool HasUnresolvedOrPendingChildren(object instance);
    public bool WasUninitializedAtEndOfParse(object instance);
    public void GetDependentNames(object instance, List`1<string> result);
    public void ResolveDependenciesTo(object instance, string name);
    public bool get_HasResolvedTokensPendingProcessing();
    public NameFixupToken GetNextResolvedTokenPendingProcessing();
    public void IsOffTheStack(object instance, string name, int lineNumber, int linePosition);
    public void AddEndOfParseDependency(object childThatHasUnresolvedChildren, FixupTarget parentObject);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Context.NameFixupGraph/<GetRemainingSimpleFixups>d__18")]
public IEnumerable`1<NameFixupToken> GetRemainingSimpleFixups();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Context.NameFixupGraph/<GetRemainingReparses>d__19")]
public IEnumerable`1<NameFixupToken> GetRemainingReparses();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Context.NameFixupGraph/<GetRemainingObjectDependencies>d__20")]
public IEnumerable`1<NameFixupToken> GetRemainingObjectDependencies();
    private bool FindDependencies(NameFixupToken inEdge, List`1<NameFixupToken> alreadyTraversed);
    private void RemoveTokenByParent(NameFixupToken token);
    private static void AddToMultiDict(Dictionary`2<TKey, FrugalObjectList`1<NameFixupToken>> dict, TKey key, NameFixupToken value);
    private static void ThrowProvideValueCycle(IEnumerable`1<NameFixupToken> markupExtensionTokens);
}
internal class MS.Internal.Xaml.Context.NameFixupToken : object {
    private List`1<string> _names;
    private List`1<INameScopeDictionary> _nameScopeDictionaryList;
    [CompilerGeneratedAttribute]
private bool <CanAssignDirectly>k__BackingField;
    [CompilerGeneratedAttribute]
private FixupType <FixupType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private FixupTarget <Target>k__BackingField;
    private XamlRuntime _runtime;
    private ObjectWriterContext _targetContext;
    [CompilerGeneratedAttribute]
private XamlSavedContext <SavedContext>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ReferencedObject>k__BackingField;
    public bool CanAssignDirectly { get; public set; }
    public FixupType FixupType { get; public set; }
    public int LineNumber { get; public set; }
    public int LinePosition { get; public set; }
    public FixupTarget Target { get; public set; }
    public XamlRuntime Runtime { get; public set; }
    public ObjectWriterContext TargetContext { get; }
    public XamlSavedContext SavedContext { get; public set; }
    public List`1<INameScopeDictionary> NameScopeDictionaryList { get; }
    public List`1<string> NeededNames { get; }
    public object ReferencedObject { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CanAssignDirectly();
    [CompilerGeneratedAttribute]
public void set_CanAssignDirectly(bool value);
    [CompilerGeneratedAttribute]
public FixupType get_FixupType();
    [CompilerGeneratedAttribute]
public void set_FixupType(FixupType value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
public void set_LinePosition(int value);
    [CompilerGeneratedAttribute]
public FixupTarget get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(FixupTarget value);
    public XamlRuntime get_Runtime();
    public void set_Runtime(XamlRuntime value);
    public ObjectWriterContext get_TargetContext();
    [CompilerGeneratedAttribute]
public XamlSavedContext get_SavedContext();
    [CompilerGeneratedAttribute]
public void set_SavedContext(XamlSavedContext value);
    public List`1<INameScopeDictionary> get_NameScopeDictionaryList();
    public List`1<string> get_NeededNames();
    [CompilerGeneratedAttribute]
public object get_ReferencedObject();
    [CompilerGeneratedAttribute]
public void set_ReferencedObject(object value);
    internal object ResolveName(string name);
    private sealed virtual override XamlException MS.Internal.Xaml.Runtime.IAddLineInfo.WithLineInfo(XamlException ex);
}
internal class MS.Internal.Xaml.Context.ObjectWriterContext : XamlContext {
    private XamlContextStack`1<ObjectWriterFrame> _stack;
    private object _rootInstance;
    private ServiceProviderContext _serviceProviderContext;
    private XamlRuntime _runtime;
    private int _savedDepth;
    private bool _nameResolutionComplete;
    private XamlObjectWriterSettings _settings;
    private List`1<NameScopeInitializationCompleteSubscriber> _nameScopeInitializationCompleteSubscribers;
    [CompilerGeneratedAttribute]
private ICheckIfInitialized <IsInitializedCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber_StartObject>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition_StartObject>k__BackingField;
    public Assembly LocalAssembly { get; protected set; }
    internal ICheckIfInitialized IsInitializedCallback { get; internal set; }
    internal bool NameResolutionComplete { get; internal set; }
    internal XamlRuntime Runtime { get; }
    internal ServiceProviderContext ServiceProviderContext { get; }
    public int Depth { get; }
    public int SavedDepth { get; }
    public int LiveDepth { get; }
    public XamlType CurrentType { get; public set; }
    public XamlType ParentType { get; }
    public XamlType GrandParentType { get; }
    public XamlMember CurrentProperty { get; public set; }
    public XamlMember ParentProperty { get; }
    public XamlMember GrandParentProperty { get; }
    public object CurrentInstance { get; public set; }
    public object ParentInstance { get; }
    public object GrandParentInstance { get; }
    public object CurrentCollection { get; public set; }
    public object ParentCollection { get; }
    public bool CurrentWasAssignedAtCreation { get; public set; }
    public bool CurrentIsObjectFromMember { get; public set; }
    public bool ParentIsObjectFromMember { get; }
    public bool GrandParentIsObjectFromMember { get; }
    unknown bool CurrentIsPropertyValueSet {public set; }
    public bool ParentIsPropertyValueSet { get; public set; }
    public bool CurrentIsTypeConvertedObject { get; public set; }
    public Dictionary`2<XamlMember, object> CurrentPreconstructionPropertyValues { get; }
    public bool CurrentHasPreconstructionPropertyValuesDictionary { get; }
    public Dictionary`2<XamlMember, object> ParentPreconstructionPropertyValues { get; }
    public HashSet`1<XamlMember> CurrentAssignedProperties { get; }
    public HashSet`1<XamlMember> ParentAssignedProperties { get; }
    public string CurrentInstanceRegisteredName { get; public set; }
    public string ParentInstanceRegisteredName { get; public set; }
    public Uri BaseUri { get; public set; }
    public int LineNumber { get; public set; }
    public int LinePosition { get; public set; }
    public Uri SourceBamlUri { get; }
    public int LineNumber_StartObject { get; public set; }
    public int LinePosition_StartObject { get; public set; }
    public INameScopeDictionary CurrentNameScope { get; }
    public INameScopeDictionary ParentNameScope { get; }
    public INameScopeDictionary GrandParentNameScope { get; }
    public INameScopeDictionary RootNameScope { get; }
    public Object[] CurrentCtorArgs { get; public set; }
    public object CurrentKey { get; }
    public bool CurrentIsKeySet { get; }
    public object ParentKey { get; public set; }
    public bool CurrentKeyIsUnconverted { get; public set; }
    unknown bool ParentKeyIsUnconverted {public set; }
    public bool ParentShouldConvertChildKeys { get; public set; }
    public bool GrandParentShouldConvertChildKeys { get; public set; }
    public bool ParentShouldNotConvertChildKeys { get; public set; }
    public bool GrandParentShouldNotConvertChildKeys { get; }
    public object RootInstance { get; }
    public IEnumerable`1<INameScopeDictionary> StackWalkOfNameScopes { get; }
    public ObjectWriterContext(XamlSavedContext savedContext, XamlObjectWriterSettings settings, INameScope rootNameScope, XamlRuntime runtime);
    public ObjectWriterContext(XamlSchemaContext schemaContext, XamlObjectWriterSettings settings, INameScope rootNameScope, XamlRuntime runtime);
    public virtual Assembly get_LocalAssembly();
    protected virtual void set_LocalAssembly(Assembly value);
    [CompilerGeneratedAttribute]
internal ICheckIfInitialized get_IsInitializedCallback();
    [CompilerGeneratedAttribute]
internal void set_IsInitializedCallback(ICheckIfInitialized value);
    internal bool get_NameResolutionComplete();
    internal void set_NameResolutionComplete(bool value);
    internal XamlRuntime get_Runtime();
    internal Type ServiceProvider_Resolve(string qName);
    internal XamlType ServiceProvider_ResolveXamlType(string qName);
    internal AmbientPropertyValue ServiceProvider_GetFirstAmbientValue(IEnumerable`1<XamlType> ceilingTypes, XamlMember[] properties);
    internal object ServiceProvider_GetFirstAmbientValue(XamlType[] types);
    internal IEnumerable`1<AmbientPropertyValue> ServiceProvider_GetAllAmbientValues(IEnumerable`1<XamlType> ceilingTypes, XamlMember[] properties);
    internal IEnumerable`1<object> ServiceProvider_GetAllAmbientValues(XamlType[] types);
    internal IEnumerable`1<AmbientPropertyValue> ServiceProvider_GetAllAmbientValues(IEnumerable`1<XamlType> ceilingTypes, bool searchLiveStackOnly, IEnumerable`1<XamlType> types, XamlMember[] properties);
    private static void CheckAmbient(XamlMember xamlMember);
    private static void CheckAmbient(XamlType xamlType);
    internal XamlObjectWriterSettings ServiceProvider_GetSettings();
    public virtual void AddNamespacePrefix(string prefix, string xamlNS);
    public virtual string FindNamespaceByPrefix(string prefix);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Context.ObjectWriterContext/<GetNamespacePrefixes>d__34")]
public virtual IEnumerable`1<NamespaceDeclaration> GetNamespacePrefixes();
    public XamlException WithLineInfo(XamlException ex);
    internal ServiceProviderContext get_ServiceProviderContext();
    internal XamlType GetDestinationType();
    private List`1<AmbientPropertyValue> FindAmbientValues(IEnumerable`1<XamlType> ceilingTypesEnumerable, bool searchLiveStackOnly, IEnumerable`1<XamlType> types, XamlMember[] properties, bool stopAfterFirst);
    private List`1<object> FindAmbientValues(XamlType[] types, bool stopAfterFirst);
    public void PushScope();
    public void LiftScope();
    public void UnLiftScope();
    public void PopScope();
    public int get_Depth();
    public int get_SavedDepth();
    public int get_LiveDepth();
    public XamlType get_CurrentType();
    public void set_CurrentType(XamlType value);
    public XamlType get_ParentType();
    public XamlType get_GrandParentType();
    public XamlMember get_CurrentProperty();
    public void set_CurrentProperty(XamlMember value);
    public XamlMember get_ParentProperty();
    public XamlMember get_GrandParentProperty();
    public object get_CurrentInstance();
    public void set_CurrentInstance(object value);
    public object get_ParentInstance();
    public object get_GrandParentInstance();
    public object get_CurrentCollection();
    public void set_CurrentCollection(object value);
    public object get_ParentCollection();
    public bool get_CurrentWasAssignedAtCreation();
    public void set_CurrentWasAssignedAtCreation(bool value);
    public bool get_CurrentIsObjectFromMember();
    public void set_CurrentIsObjectFromMember(bool value);
    public bool get_ParentIsObjectFromMember();
    public bool get_GrandParentIsObjectFromMember();
    public void set_CurrentIsPropertyValueSet(bool value);
    public bool get_ParentIsPropertyValueSet();
    public void set_ParentIsPropertyValueSet(bool value);
    public bool get_CurrentIsTypeConvertedObject();
    public void set_CurrentIsTypeConvertedObject(bool value);
    public Dictionary`2<XamlMember, object> get_CurrentPreconstructionPropertyValues();
    public bool get_CurrentHasPreconstructionPropertyValuesDictionary();
    public Dictionary`2<XamlMember, object> get_ParentPreconstructionPropertyValues();
    public HashSet`1<XamlMember> get_CurrentAssignedProperties();
    public HashSet`1<XamlMember> get_ParentAssignedProperties();
    public string get_CurrentInstanceRegisteredName();
    public void set_CurrentInstanceRegisteredName(string value);
    public string get_ParentInstanceRegisteredName();
    public void set_ParentInstanceRegisteredName(string value);
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    [CompilerGeneratedAttribute]
public void set_BaseUri(Uri value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
public void set_LinePosition(int value);
    public Uri get_SourceBamlUri();
    [CompilerGeneratedAttribute]
public int get_LineNumber_StartObject();
    [CompilerGeneratedAttribute]
public void set_LineNumber_StartObject(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition_StartObject();
    [CompilerGeneratedAttribute]
public void set_LinePosition_StartObject(int value);
    public INameScopeDictionary get_CurrentNameScope();
    public INameScopeDictionary get_ParentNameScope();
    public INameScopeDictionary get_GrandParentNameScope();
    public INameScopeDictionary get_RootNameScope();
    public Object[] get_CurrentCtorArgs();
    public void set_CurrentCtorArgs(Object[] value);
    public object get_CurrentKey();
    public bool get_CurrentIsKeySet();
    public object get_ParentKey();
    public void set_ParentKey(object value);
    public bool get_CurrentKeyIsUnconverted();
    public void set_CurrentKeyIsUnconverted(bool value);
    public void set_ParentKeyIsUnconverted(bool value);
    public bool get_ParentShouldConvertChildKeys();
    public void set_ParentShouldConvertChildKeys(bool value);
    public bool get_GrandParentShouldConvertChildKeys();
    public void set_GrandParentShouldConvertChildKeys(bool value);
    public bool get_ParentShouldNotConvertChildKeys();
    public void set_ParentShouldNotConvertChildKeys(bool value);
    public bool get_GrandParentShouldNotConvertChildKeys();
    public object get_RootInstance();
    private ObjectWriterFrame GetTopFrame();
    private INameScopeDictionary LookupNameScopeDictionary(ObjectWriterFrame frame);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Context.ObjectWriterContext/<get_StackWalkOfNameScopes>d__172")]
public IEnumerable`1<INameScopeDictionary> get_StackWalkOfNameScopes();
    public bool IsOnTheLiveStack(object instance);
    private INameScopeDictionary HuntAroundForARootNameScope(ObjectWriterFrame rootFrame);
    public XamlSavedContext GetSavedContext(SavedContextType savedContextType);
    public object ResolveName(string name, Boolean& isFullyInitialized);
    public IEnumerable`1<KeyValuePair`2<string, object>> GetAllNamesAndValuesInScope();
    internal void AddNameScopeInitializationCompleteSubscriber(EventHandler handler);
    internal void RemoveNameScopeInitializationCompleteSubscriber(EventHandler handler);
    internal void RaiseNameScopeInitializationCompleteEvent();
}
[DebuggerDisplayAttribute("{ToString()}")]
internal class MS.Internal.Xaml.Context.ObjectWriterFrame : XamlCommonFrame {
    private ObjectWriterFrameFlags _flags;
    private Dictionary`2<XamlMember, object> _preconstructionPropertyValues;
    private HashSet`1<XamlMember> _assignedProperties;
    private object _key;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private INameScopeDictionary <NameScopeDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <PositionalCtorArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceRegisteredName>k__BackingField;
    public object Instance { get; public set; }
    public object Collection { get; public set; }
    public bool WasAssignedAtCreation { get; public set; }
    public bool IsObjectFromMember { get; public set; }
    public bool IsPropertyValueSet { get; public set; }
    public bool IsKeySet { get; private set; }
    public bool IsTypeConvertedObject { get; public set; }
    public bool KeyIsUnconverted { get; public set; }
    public bool ShouldConvertChildKeys { get; public set; }
    public bool ShouldNotConvertChildKeys { get; public set; }
    public INameScopeDictionary NameScopeDictionary { get; public set; }
    public Object[] PositionalCtorArgs { get; public set; }
    public object Key { get; public set; }
    public string InstanceRegisteredName { get; public set; }
    public Dictionary`2<XamlMember, object> PreconstructionPropertyValues { get; }
    public bool HasPreconstructionPropertyValuesDictionary { get; }
    public HashSet`1<XamlMember> AssignedProperties { get; }
    public ObjectWriterFrame(ObjectWriterFrame source);
    public virtual void Reset();
    public virtual XamlFrame Clone();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(object value);
    [CompilerGeneratedAttribute]
public object get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(object value);
    public bool get_WasAssignedAtCreation();
    public void set_WasAssignedAtCreation(bool value);
    public bool get_IsObjectFromMember();
    public void set_IsObjectFromMember(bool value);
    public bool get_IsPropertyValueSet();
    public void set_IsPropertyValueSet(bool value);
    public bool get_IsKeySet();
    private void set_IsKeySet(bool value);
    public bool get_IsTypeConvertedObject();
    public void set_IsTypeConvertedObject(bool value);
    public bool get_KeyIsUnconverted();
    public void set_KeyIsUnconverted(bool value);
    public bool get_ShouldConvertChildKeys();
    public void set_ShouldConvertChildKeys(bool value);
    public bool get_ShouldNotConvertChildKeys();
    public void set_ShouldNotConvertChildKeys(bool value);
    [CompilerGeneratedAttribute]
public INameScopeDictionary get_NameScopeDictionary();
    [CompilerGeneratedAttribute]
public void set_NameScopeDictionary(INameScopeDictionary value);
    [CompilerGeneratedAttribute]
public Object[] get_PositionalCtorArgs();
    [CompilerGeneratedAttribute]
public void set_PositionalCtorArgs(Object[] value);
    public object get_Key();
    public void set_Key(object value);
    [CompilerGeneratedAttribute]
public string get_InstanceRegisteredName();
    [CompilerGeneratedAttribute]
public void set_InstanceRegisteredName(string value);
    public Dictionary`2<XamlMember, object> get_PreconstructionPropertyValues();
    public bool get_HasPreconstructionPropertyValuesDictionary();
    public HashSet`1<XamlMember> get_AssignedProperties();
    private bool GetFlag(ObjectWriterFrameFlags flag);
    private void SetFlag(ObjectWriterFrameFlags flag, bool value);
}
internal abstract class MS.Internal.Xaml.Context.XamlCommonFrame : XamlFrame {
    internal Dictionary`2<string, string> _namespaces;
    [CompilerGeneratedAttribute]
private XamlType <XamlType>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlMember <Member>k__BackingField;
    public Dictionary`2<string, string> Namespaces { get; }
    public XamlType XamlType { get; public set; }
    public XamlMember Member { get; public set; }
    public XamlCommonFrame(XamlCommonFrame source);
    public Dictionary`2<string, string> get_Namespaces();
    public virtual void Reset();
    [CompilerGeneratedAttribute]
public XamlType get_XamlType();
    [CompilerGeneratedAttribute]
public void set_XamlType(XamlType value);
    [CompilerGeneratedAttribute]
public XamlMember get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(XamlMember value);
    public void AddNamespace(string prefix, string xamlNs);
    public void SetNamespaces(Dictionary`2<string, string> namespaces);
    public bool TryGetNamespaceByPrefix(string prefix, String& xamlNs);
    public IEnumerable`1<NamespaceDeclaration> GetNamespacePrefixes();
}
internal class MS.Internal.Xaml.Context.XamlContextStack`1 : object {
    private int _depth;
    private T _currentFrame;
    private T _recycledFrame;
    private Func`1<T> _creationDelegate;
    public T CurrentFrame { get; }
    public T PreviousFrame { get; }
    public T PreviousPreviousFrame { get; }
    public int Depth { get; public set; }
    public string Frames { get; }
    public XamlContextStack`1(Func`1<T> creationDelegate);
    public XamlContextStack`1(XamlContextStack`1<T> source, bool copy);
    private void Grow();
    public T get_CurrentFrame();
    public T get_PreviousFrame();
    public T get_PreviousPreviousFrame();
    public T GetFrame(int depth);
    public void PushScope();
    public void PopScope();
    public int get_Depth();
    public void set_Depth(int value);
    public void Trim();
    public string get_Frames();
    private void ShowFrame(StringBuilder sb, T iteratorFrame);
}
internal abstract class MS.Internal.Xaml.Context.XamlFrame : object {
    private int _depth;
    private XamlFrame _previous;
    public int Depth { get; }
    public XamlFrame Previous { get; public set; }
    protected XamlFrame(XamlFrame source);
    public virtual XamlFrame Clone();
    public abstract virtual void Reset();
    public int get_Depth();
    public XamlFrame get_Previous();
    public void set_Previous(XamlFrame value);
}
internal class MS.Internal.Xaml.Context.XamlObjectWriterFactory : object {
    private XamlSavedContext _savedContext;
    private XamlObjectWriterSettings _parentSettings;
    public XamlObjectWriterFactory(ObjectWriterContext context);
    public sealed virtual XamlObjectWriter GetXamlObjectWriter(XamlObjectWriterSettings settings);
    public sealed virtual XamlObjectWriterSettings GetParentSettings();
}
internal class MS.Internal.Xaml.Context.XamlParserContext : XamlContext {
    private XamlContextStack`1<XamlParserFrame> _stack;
    private Dictionary`2<string, string> _prescopeNamespaces;
    [CompilerGeneratedAttribute]
private bool <AllowProtectedMembersOnRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, string> <XmlNamespaceResolver>k__BackingField;
    public bool AllowProtectedMembersOnRoot { get; public set; }
    public Func`2<string, string> XmlNamespaceResolver { get; public set; }
    public XamlType CurrentType { get; public set; }
    internal BracketModeParseParameters CurrentBracketModeParseParameters { get; internal set; }
    internal ParameterInfo[] CurrentLongestConstructorOfMarkupExtension { get; internal set; }
    internal Dictionary`2<string, SpecialBracketCharacters> CurrentEscapeCharacterMapForMarkupExtension { get; internal set; }
    public string CurrentTypeNamespace { get; public set; }
    public bool CurrentInContainerDirective { get; public set; }
    public XamlMember CurrentMember { get; public set; }
    public int CurrentArgCount { get; public set; }
    public bool CurrentForcedToUseConstructor { get; public set; }
    public bool CurrentInItemsProperty { get; }
    public bool CurrentInInitProperty { get; }
    public bool CurrentInUnknownContent { get; }
    public bool CurrentInImplicitArray { get; public set; }
    public bool CurrentInCollectionFromMember { get; public set; }
    public XamlType CurrentPreviousChildType { get; public set; }
    public bool CurrentTypeIsRoot { get; }
    public XamlParserContext(XamlSchemaContext schemaContext, Assembly localAssembly);
    [CompilerGeneratedAttribute]
public bool get_AllowProtectedMembersOnRoot();
    [CompilerGeneratedAttribute]
public void set_AllowProtectedMembersOnRoot(bool value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_XmlNamespaceResolver();
    [CompilerGeneratedAttribute]
public void set_XmlNamespaceResolver(Func`2<string, string> value);
    public virtual void AddNamespacePrefix(string prefix, string xamlNS);
    public string FindNamespaceByPrefixInParseStack(string prefix);
    public virtual string FindNamespaceByPrefix(string prefix);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Context.XamlParserContext/<GetNamespacePrefixes>d__14")]
public virtual IEnumerable`1<NamespaceDeclaration> GetNamespacePrefixes();
    internal virtual bool IsVisible(XamlMember member, XamlType rootObjectType);
    public void PushScope();
    public void PopScope();
    internal void InitBracketCharacterCacheForType(XamlType extensionType);
    internal void InitLongestConstructor(XamlType xamlType);
    public XamlType get_CurrentType();
    public void set_CurrentType(XamlType value);
    internal BracketModeParseParameters get_CurrentBracketModeParseParameters();
    internal void set_CurrentBracketModeParseParameters(BracketModeParseParameters value);
    internal ParameterInfo[] get_CurrentLongestConstructorOfMarkupExtension();
    internal void set_CurrentLongestConstructorOfMarkupExtension(ParameterInfo[] value);
    internal Dictionary`2<string, SpecialBracketCharacters> get_CurrentEscapeCharacterMapForMarkupExtension();
    internal void set_CurrentEscapeCharacterMapForMarkupExtension(Dictionary`2<string, SpecialBracketCharacters> value);
    public string get_CurrentTypeNamespace();
    public void set_CurrentTypeNamespace(string value);
    public bool get_CurrentInContainerDirective();
    public void set_CurrentInContainerDirective(bool value);
    public XamlMember get_CurrentMember();
    public void set_CurrentMember(XamlMember value);
    public int get_CurrentArgCount();
    public void set_CurrentArgCount(int value);
    public bool get_CurrentForcedToUseConstructor();
    public void set_CurrentForcedToUseConstructor(bool value);
    public bool get_CurrentInItemsProperty();
    public bool get_CurrentInInitProperty();
    public bool get_CurrentInUnknownContent();
    public bool get_CurrentInImplicitArray();
    public void set_CurrentInImplicitArray(bool value);
    public bool get_CurrentInCollectionFromMember();
    public void set_CurrentInCollectionFromMember(bool value);
    public XamlType get_CurrentPreviousChildType();
    public void set_CurrentPreviousChildType(XamlType value);
    public bool CurrentMemberIsWriteVisible();
    public bool get_CurrentTypeIsRoot();
}
internal class MS.Internal.Xaml.Context.XamlParserFrame : XamlCommonFrame {
    [CompilerGeneratedAttribute]
private XamlType <PreviousChildType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CtorArgCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForcedToUseConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InCollectionFromMember>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InImplicitArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InContainerDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterInfo[] <LongestConstructorOfCurrentMarkupExtensionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SpecialBracketCharacters> <EscapeCharacterMapForMarkupExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private BracketModeParseParameters <BracketModeParseParameters>k__BackingField;
    public XamlType PreviousChildType { get; public set; }
    public int CtorArgCount { get; public set; }
    public bool ForcedToUseConstructor { get; public set; }
    public bool InCollectionFromMember { get; public set; }
    public bool InImplicitArray { get; public set; }
    public bool InContainerDirective { get; public set; }
    public string TypeNamespace { get; public set; }
    public ParameterInfo[] LongestConstructorOfCurrentMarkupExtensionType { get; public set; }
    public Dictionary`2<string, SpecialBracketCharacters> EscapeCharacterMapForMarkupExtension { get; public set; }
    public BracketModeParseParameters BracketModeParseParameters { get; public set; }
    public virtual void Reset();
    [CompilerGeneratedAttribute]
public XamlType get_PreviousChildType();
    [CompilerGeneratedAttribute]
public void set_PreviousChildType(XamlType value);
    [CompilerGeneratedAttribute]
public int get_CtorArgCount();
    [CompilerGeneratedAttribute]
public void set_CtorArgCount(int value);
    [CompilerGeneratedAttribute]
public bool get_ForcedToUseConstructor();
    [CompilerGeneratedAttribute]
public void set_ForcedToUseConstructor(bool value);
    [CompilerGeneratedAttribute]
public bool get_InCollectionFromMember();
    [CompilerGeneratedAttribute]
public void set_InCollectionFromMember(bool value);
    [CompilerGeneratedAttribute]
public bool get_InImplicitArray();
    [CompilerGeneratedAttribute]
public void set_InImplicitArray(bool value);
    [CompilerGeneratedAttribute]
public bool get_InContainerDirective();
    [CompilerGeneratedAttribute]
public void set_InContainerDirective(bool value);
    [CompilerGeneratedAttribute]
public string get_TypeNamespace();
    [CompilerGeneratedAttribute]
public void set_TypeNamespace(string value);
    [CompilerGeneratedAttribute]
public ParameterInfo[] get_LongestConstructorOfCurrentMarkupExtensionType();
    [CompilerGeneratedAttribute]
public void set_LongestConstructorOfCurrentMarkupExtensionType(ParameterInfo[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SpecialBracketCharacters> get_EscapeCharacterMapForMarkupExtension();
    [CompilerGeneratedAttribute]
public void set_EscapeCharacterMapForMarkupExtension(Dictionary`2<string, SpecialBracketCharacters> value);
    [CompilerGeneratedAttribute]
public BracketModeParseParameters get_BracketModeParseParameters();
    [CompilerGeneratedAttribute]
public void set_BracketModeParseParameters(BracketModeParseParameters value);
}
internal class MS.Internal.Xaml.NodeStreamSorter : object {
    private XamlParserContext _context;
    private XamlXmlReaderSettings _settings;
    private IEnumerator`1<XamlNode> _source;
    private Queue`1<XamlNode> _buffer;
    private XamlNode _current;
    private ReorderInfo[] _sortingInfoArray;
    private XamlNode[] _originalNodesInOrder;
    private Dictionary`2<string, string> _xmlnsDictionary;
    private List`1<SeenCtorDirectiveFlags> _seenStack;
    private int _startObjectDepth;
    private List`1<int> _moveList;
    private bool HaveSeenInstancingProperty { get; private set; }
    private bool HaveSeenOutOfOrderCtorDirective { get; private set; }
    public XamlNode Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public NodeStreamSorter(XamlParserContext context, XamlPullParser parser, XamlXmlReaderSettings settings, Dictionary`2<string, string> xmlnsDictionary);
    private void InitializeObjectFrameStack();
    private void StartObjectFrame();
    private void EndObjectFrame();
    private bool get_HaveSeenInstancingProperty();
    private void set_HaveSeenInstancingProperty(bool value);
    private bool get_HaveSeenOutOfOrderCtorDirective();
    private void set_HaveSeenOutOfOrderCtorDirective(bool value);
    public sealed virtual XamlNode get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    private void StartNewNodeStreamWithSettingsPreamble();
    private void EnqueueInitialExtraXmlNses();
    private void EnqueueInitialXmlState();
    private void EnqueueOneXmlDirectiveProperty(XamlMember xmlDirectiveProperty, string textValue);
    private void ReadAheadAndSortCtorProperties();
    private void ReadAheadToEndObjectOrFirstPropertyElement();
    private void ReadAheadToEndOfAttributes();
    private void ReadAheadToFirstInstancingProperty();
    private bool CheckForOutOfOrderCtorDirectives(XamlNode node);
    private bool IsCtorDirective(XamlMember member);
    private bool IsInstancingMember(XamlMember member);
    private void SortContentsOfReadAheadBuffer();
    private void BuildSortingBuffer();
    private void ReloadSortedBuffer();
    private void MoveList_Process();
    private bool MoveList_RemoveStartMemberIndexWithGreatestDepth(Int32& deepestCtorIdx, Int32& deepestDepth);
    private void SortMembers(int start);
    private bool AdvanceToNextInstancingMember(int current, int depth, Int32& end);
    private bool AdvanceToNextCtorDirective(int current, int depth, Int32& end);
    private int AdvanceOverNoninstancingDirectives(int start, int depth);
    private void SwapRanges(int beginning, int middle, int end);
    private bool AdvanceTo(int start, XamlNodeType nodeType, int searchDepth, Int32& end);
    private bool BackupTo(int start, XamlNodeType nodeType, int searchDepth, Int32& end);
}
internal class MS.Internal.Xaml.Parser.BracketModeParseParameters : object {
    [CompilerGeneratedAttribute]
private int <CurrentConstructorParam>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConstructorParams>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConstructorParsingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBracketEscapeMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<char> <BracketCharacterStack>k__BackingField;
    internal int CurrentConstructorParam { get; internal set; }
    internal int MaxConstructorParams { get; internal set; }
    internal bool IsConstructorParsingMode { get; internal set; }
    internal bool IsBracketEscapeMode { get; internal set; }
    internal Stack`1<char> BracketCharacterStack { get; internal set; }
    internal BracketModeParseParameters(XamlParserContext context);
    [CompilerGeneratedAttribute]
internal int get_CurrentConstructorParam();
    [CompilerGeneratedAttribute]
internal void set_CurrentConstructorParam(int value);
    [CompilerGeneratedAttribute]
internal int get_MaxConstructorParams();
    [CompilerGeneratedAttribute]
internal void set_MaxConstructorParams(int value);
    [CompilerGeneratedAttribute]
internal bool get_IsConstructorParsingMode();
    [CompilerGeneratedAttribute]
internal void set_IsConstructorParsingMode(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsBracketEscapeMode();
    [CompilerGeneratedAttribute]
internal void set_IsBracketEscapeMode(bool value);
    [CompilerGeneratedAttribute]
internal Stack`1<char> get_BracketCharacterStack();
    [CompilerGeneratedAttribute]
internal void set_BracketCharacterStack(Stack`1<char> value);
}
internal class MS.Internal.Xaml.Parser.GenericTypeNameParser : object {
    private GenericTypeNameScanner _scanner;
    private string _inputText;
    private Func`2<string, string> _prefixResolver;
    private Stack`1<TypeNameFrame> _stack;
    public GenericTypeNameParser(Func`2<string, string> prefixResolver);
    public static XamlTypeName ParseIfTrivalName(string text, Func`2<string, string> prefixResolver, String& error);
    public XamlTypeName ParseName(string text, String& error);
    public IList`1<XamlTypeName> ParseList(string text, String& error);
    private void P_XamlTypeName();
    private void P_SimpleTypeName();
    private void P_TypeParameters();
    private void P_XamlTypeNameList();
    private void P_NameListExt();
    private void P_RepeatingSubscript();
    private void ThrowOnBadInput();
    private void StartStack();
    private void Callout_FoundName(string prefix, string name);
    private void Callout_EndOfType();
    private void Callout_Subscript(string subscript);
    private XamlTypeName CollectNameFromStack();
    private IList`1<XamlTypeName> CollectNameListFromStack();
}
internal class MS.Internal.Xaml.Parser.GenericTypeNameScanner : Sample_StringParserBase {
    public static char Space;
    public static char OpenParen;
    public static char CloseParen;
    public static char Comma;
    public static char OpenBracket;
    public static char CloseBracket;
    public static char Colon;
    private GenericTypeNameScannerToken _token;
    private string _tokenText;
    private State _state;
    private GenericTypeNameScannerToken _pushedBackSymbol;
    private int _multiCharTokenStartIdx;
    private int _multiCharTokenLength;
    private char _lastChar;
    public GenericTypeNameScannerToken Token { get; }
    public string MultiCharTokenText { get; }
    public char ErrorCurrentChar { get; }
    public GenericTypeNameScanner(string text);
    public GenericTypeNameScannerToken get_Token();
    public string get_MultiCharTokenText();
    public char get_ErrorCurrentChar();
    public void Read();
    internal static int ParseSubscriptSegment(string subscript, Int32& pos);
    internal static string StripSubscript(string typeName, String& subscript);
    private void State_Start();
    private void State_InName();
    private void State_InSubscript();
    private void StartMultiCharToken();
    private void AddToMultiCharToken();
    private string CollectMultiCharToken();
}
internal enum MS.Internal.Xaml.Parser.GenericTypeNameScannerToken : Enum {
    public int value__;
    public static GenericTypeNameScannerToken NONE;
    public static GenericTypeNameScannerToken ERROR;
    public static GenericTypeNameScannerToken OPEN;
    public static GenericTypeNameScannerToken CLOSE;
    public static GenericTypeNameScannerToken COLON;
    public static GenericTypeNameScannerToken COMMA;
    public static GenericTypeNameScannerToken SUBSCRIPT;
    public static GenericTypeNameScannerToken NAME;
}
internal class MS.Internal.Xaml.Parser.MePullParser : object {
    private XamlParserContext _context;
    private string _originalText;
    private MeScanner _tokenizer;
    private string _brokenRule;
    private int LineNumber { get; }
    private int LinePosition { get; }
    public MePullParser(XamlParserContext stack);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.MePullParser/<Parse>d__6")]
public IEnumerable`1<XamlNode> Parse(string text, int lineNumber, int linePosition);
    private void SetBrokenRuleString(string ruleString);
    private bool Expect(MeTokenType token, string ruleString);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.MePullParser/<P_MarkupExtension>d__9")]
private IEnumerable`1<XamlNode> P_MarkupExtension(Found f);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.MePullParser/<P_Arguments>d__10")]
private IEnumerable`1<XamlNode> P_Arguments(Found f);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.MePullParser/<P_PositionalArgs>d__11")]
private IEnumerable`1<XamlNode> P_PositionalArgs(Found f);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.MePullParser/<P_NamedArgs>d__12")]
private IEnumerable`1<XamlNode> P_NamedArgs(Found f);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.MePullParser/<P_Value>d__13")]
private IEnumerable`1<XamlNode> P_Value(Found f);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.MePullParser/<P_NamedArg>d__14")]
private IEnumerable`1<XamlNode> P_NamedArg(Found f);
    private void NextToken();
    private int get_LineNumber();
    private int get_LinePosition();
    private XamlNode Logic_StartElement(XamlType xamlType, string xamlNamespace);
    private XamlNode Logic_EndObject();
    private XamlNode Logic_StartMember();
    private XamlNode Logic_EndMember();
    private XamlNode Logic_StartPositionalParameters();
    private XamlNode Logic_EndPositionalParameters();
    private XamlNode Logic_Text();
}
internal class MS.Internal.Xaml.Parser.MeScanner : object {
    public static char Space;
    public static char OpenCurlie;
    public static char CloseCurlie;
    public static char Comma;
    public static char EqualSign;
    public static char Quote1;
    public static char Quote2;
    public static char Backslash;
    public static char NullChar;
    private XamlParserContext _context;
    private string _inputText;
    private int _idx;
    private MeTokenType _token;
    private XamlType _tokenXamlType;
    private XamlMember _tokenProperty;
    private string _tokenNamespace;
    private string _tokenText;
    private StringState _state;
    private bool _hasTrailingWhitespace;
    private int _lineNumber;
    private int _startPosition;
    private string _currentParameterName;
    private SpecialBracketCharacters _currentSpecialBracketCharacters;
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string Namespace { get; }
    public MeTokenType Token { get; }
    public XamlType TokenType { get; }
    public XamlMember TokenProperty { get; }
    public string TokenText { get; }
    public bool IsAtEndOfInput { get; }
    public bool HasTrailingWhitespace { get; }
    private char CurrentChar { get; }
    private char NextChar { get; }
    public MeScanner(XamlParserContext context, string text, int lineNumber, int linePosition);
    public int get_LineNumber();
    public int get_LinePosition();
    public string get_Namespace();
    public MeTokenType get_Token();
    public XamlType get_TokenType();
    public XamlMember get_TokenProperty();
    public string get_TokenText();
    public bool get_IsAtEndOfInput();
    public bool get_HasTrailingWhitespace();
    public void Read();
    private static string RemoveEscapes(string value);
    private void ResolveTypeName(string longName);
    private void ResolvePropertyName(string longName);
    private string ReadString();
    private char get_CurrentChar();
    private char get_NextChar();
    private bool Advance();
    private static bool IsWhitespaceChar(char ch);
    private void AdvanceOverWhitespace();
    private void PushBack();
    private SpecialBracketCharacters GetBracketCharacterForProperty(string propertyName);
}
internal enum MS.Internal.Xaml.Parser.MeTokenType : Enum {
    public int value__;
    public static MeTokenType None;
    public static MeTokenType Open;
    public static MeTokenType Close;
    public static MeTokenType EqualSign;
    public static MeTokenType Comma;
    public static MeTokenType TypeName;
    public static MeTokenType PropertyName;
    public static MeTokenType String;
    public static MeTokenType QuotedMarkupExtension;
}
internal class MS.Internal.Xaml.Parser.NamespacePrefixLookup : object {
    private List`1<NamespaceDeclaration> _newNamespaces;
    private Func`2<string, string> _nsResolver;
    private int n;
    public NamespacePrefixLookup(IEnumerable`1& newNamespaces, Func`2<string, string> nsResolver);
    public sealed virtual string LookupPrefix(string ns);
}
internal class MS.Internal.Xaml.Parser.Sample_StringParserBase : object {
    protected static char NullChar;
    protected string _inputText;
    protected int _idx;
    protected char CurrentChar { get; }
    public bool IsAtEndOfInput { get; }
    public Sample_StringParserBase(string text);
    protected char get_CurrentChar();
    public bool get_IsAtEndOfInput();
    protected bool Advance();
    protected static bool IsWhitespaceChar(char ch);
    protected bool AdvanceOverWhitespace();
}
internal enum MS.Internal.Xaml.Parser.ScannerAttributeKind : Enum {
    public int value__;
    public static ScannerAttributeKind Namespace;
    public static ScannerAttributeKind CtorDirective;
    public static ScannerAttributeKind Name;
    public static ScannerAttributeKind Directive;
    public static ScannerAttributeKind XmlSpace;
    public static ScannerAttributeKind Event;
    public static ScannerAttributeKind Property;
    public static ScannerAttributeKind AttachableProperty;
    public static ScannerAttributeKind Unknown;
}
internal enum MS.Internal.Xaml.Parser.ScannerNodeType : Enum {
    public int value__;
    public static ScannerNodeType NONE;
    public static ScannerNodeType ELEMENT;
    public static ScannerNodeType EMPTYELEMENT;
    public static ScannerNodeType ATTRIBUTE;
    public static ScannerNodeType DIRECTIVE;
    public static ScannerNodeType PREFIXDEFINITION;
    public static ScannerNodeType PROPERTYELEMENT;
    public static ScannerNodeType EMPTYPROPERTYELEMENT;
    public static ScannerNodeType TEXT;
    public static ScannerNodeType ENDTAG;
}
internal class MS.Internal.Xaml.Parser.SpecialBracketCharacters : object {
    private string _startChars;
    private string _endChars;
    private static ISet`1<char> _restrictedCharSet;
    private bool _initializing;
    private StringBuilder _startCharactersStringBuilder;
    private StringBuilder _endCharactersStringBuilder;
    internal string StartBracketCharacters { get; }
    internal string EndBracketCharacters { get; }
    internal SpecialBracketCharacters(IReadOnlyDictionary`2<char, char> attributeList);
    private static SpecialBracketCharacters();
    internal void AddBracketCharacters(char openingBracket, char closingBracket);
    private void Tokenize(IReadOnlyDictionary`2<char, char> attributeList);
    private bool IsValidBracketCharacter(char openingBracket, char closingBracket);
    internal bool IsSpecialCharacter(char ch);
    internal bool StartsEscapeSequence(char ch);
    internal bool EndsEscapeSequence(char ch);
    internal bool Match(char start, char end);
    internal string get_StartBracketCharacters();
    internal string get_EndBracketCharacters();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
}
internal class MS.Internal.Xaml.Parser.TypeNameFrame : object {
    private List`1<XamlTypeName> _typeArgs;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Namespace { get; public set; }
    public string Name { get; public set; }
    public List`1<XamlTypeName> TypeArgs { get; }
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public List`1<XamlTypeName> get_TypeArgs();
    public void AllocateTypeArgs();
}
[DebuggerDisplayAttribute("{Name.ScopedName}='{Value}'  {Kind}")]
internal class MS.Internal.Xaml.Parser.XamlAttribute : object {
    private string _xmlnsDefinitionPrefix;
    private string _xmlnsDefinitionUri;
    [CompilerGeneratedAttribute]
private XamlPropertyName <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ScannerAttributeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlMember <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    public XamlPropertyName Name { get; private set; }
    public string Value { get; private set; }
    public ScannerAttributeKind Kind { get; private set; }
    public XamlMember Property { get; private set; }
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public string XmlNsPrefixDefined { get; }
    public string XmlNsUriDefined { get; }
    public XamlAttribute(XamlPropertyName propName, string val, IXmlLineInfo lineInfo);
    [CompilerGeneratedAttribute]
public XamlPropertyName get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(XamlPropertyName value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public ScannerAttributeKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(ScannerAttributeKind value);
    [CompilerGeneratedAttribute]
public XamlMember get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(XamlMember value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
    public void Initialize(XamlParserContext context, XamlType tagType, string ownerNamespace, bool tagIsRoot);
    public string get_XmlNsPrefixDefined();
    public string get_XmlNsUriDefined();
    internal bool CheckIsXmlNamespaceDefinition(String& definingPrefix, String& uri);
    private XamlMember GetXamlAttributeProperty(XamlParserContext context, XamlPropertyName propName, XamlType tagType, string tagNamespace, bool tagIsRoot);
}
internal abstract class MS.Internal.Xaml.Parser.XamlName : object {
    public static char PlusSign;
    public static char UnderScore;
    public static char Dot;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    protected string _prefix;
    protected string _namespace;
    public string Name { get; protected set; }
    public string ScopedName { get; }
    public string Prefix { get; }
    public string Namespace { get; }
    public XamlName(string name);
    public XamlName(string prefix, string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    public abstract virtual string get_ScopedName();
    public string get_Prefix();
    public string get_Namespace();
    public static bool ContainsDot(string name);
    public static bool IsValidXamlName(string name);
    public static bool IsValidNameStartChar(char ch);
    public static bool IsValidNameChar(char ch);
    public static bool IsValidQualifiedNameChar(char ch);
    public static bool IsValidQualifiedNameCharPlus(char ch);
}
internal class MS.Internal.Xaml.Parser.XamlPropertyName : XamlName {
    public XamlName Owner;
    public string ScopedName { get; }
    public string OwnerName { get; }
    public bool IsDotted { get; }
    private XamlPropertyName(XamlName owner, string prefix, string name);
    public static XamlPropertyName Parse(string longName);
    public static XamlPropertyName Parse(string longName, string namespaceURI);
    public virtual string get_ScopedName();
    public string get_OwnerName();
    public bool get_IsDotted();
}
internal class MS.Internal.Xaml.Parser.XamlPullParser : object {
    private XamlParserContext _context;
    private XamlScanner _xamlScanner;
    private XamlXmlReaderSettings _settings;
    private XamlTypeName arrayType;
    private XamlType _arrayExtensionType;
    private XamlMember _arrayTypeMember;
    private XamlMember _itemsTypeMember;
    private int LineNumber { get; }
    private int LinePosition { get; }
    private bool ProvideLineInfo { get; }
    private XamlType ArrayExtensionType { get; }
    private XamlMember ArrayTypeMember { get; }
    private XamlMember ItemsTypeMember { get; }
    public XamlPullParser(XamlParserContext context, XamlScanner scanner, XamlXmlReaderSettings settings);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<Parse>d__4")]
public IEnumerable`1<XamlNode> Parse();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<P_Element>d__5")]
public IEnumerable`1<XamlNode> P_Element();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<P_EmptyElement>d__6")]
public IEnumerable`1<XamlNode> P_EmptyElement();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<P_StartElement>d__7")]
public IEnumerable`1<XamlNode> P_StartElement();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<P_ElementBody>d__8")]
public IEnumerable`1<XamlNode> P_ElementBody();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<P_PropertyElement>d__9")]
public IEnumerable`1<XamlNode> P_PropertyElement();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<P_EmptyPropertyElement>d__10")]
public IEnumerable`1<XamlNode> P_EmptyPropertyElement();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<P_NonemptyPropertyElement>d__11")]
public IEnumerable`1<XamlNode> P_NonemptyPropertyElement();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<P_ElementContent>d__12")]
public IEnumerable`1<XamlNode> P_ElementContent();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<P_PropertyContent>d__13")]
public IEnumerable`1<XamlNode> P_PropertyContent();
    private int get_LineNumber();
    private int get_LinePosition();
    private bool get_ProvideLineInfo();
    private XamlNode Logic_LineInfo();
    private XamlNode Logic_PrefixDefinition();
    private XamlNode Logic_StartObject(XamlType xamlType, string xamlNamespace);
    private XamlNode Logic_EndObject();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<LogicStream_Attribute>d__24")]
private IEnumerable`1<XamlNode> LogicStream_Attribute();
    private XamlNode Logic_EndOfAttributes();
    private XamlNode Logic_StartMember(XamlMember member);
    private XamlNode Logic_EndMember();
    private XamlNode Logic_StartContentProperty(XamlMember property);
    private XamlNode Logic_StartInitProperty(XamlType ownerType);
    private string Logic_ApplyFinalTextTrimming(XamlText text);
    private XamlNode Logic_StartGetObjectFromMember(XamlType realType);
    private XamlNode Logic_StartItemsProperty(XamlType collectionType);
    private XamlType get_ArrayExtensionType();
    private XamlMember get_ArrayTypeMember();
    private XamlMember get_ItemsTypeMember();
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Parser.XamlPullParser/<LogicStream_CheckForStartGetCollectionFromMember>d__43")]
private IEnumerable`1<XamlNode> LogicStream_CheckForStartGetCollectionFromMember();
    private bool Logic_IsDiscardableWhitespace(XamlText text);
    private static bool CanAcceptString(XamlMember property);
}
internal class MS.Internal.Xaml.Parser.XamlQualifiedName : XamlName {
    public string ScopedName { get; }
    public XamlQualifiedName(string prefix, string name);
    public virtual string get_ScopedName();
    internal static bool IsNameValid(string name);
    internal static bool IsNameValid_WithPlus(string name);
    public static bool Parse(string longName, String& prefix, String& name);
}
internal class MS.Internal.Xaml.Parser.XamlScanner : object {
    private XmlReader _xmlReader;
    private IXmlLineInfo _xmlLineInfo;
    private XamlScannerStack _scannerStack;
    private XamlParserContext _parserContext;
    private XamlText _accumulatedText;
    private List`1<XamlAttribute> _attributes;
    private int _nextAttribute;
    private XamlScannerNode _currentNode;
    private Queue`1<XamlScannerNode> _readNodesQueue;
    private XamlXmlReaderSettings _settings;
    private XamlAttribute _typeArgumentAttribute;
    private bool _hasKeyAttribute;
    public ScannerNodeType PeekNodeType { get; }
    public XamlType PeekType { get; }
    public ScannerNodeType NodeType { get; }
    public XamlType Type { get; }
    public XamlMember PropertyAttribute { get; }
    public XamlText PropertyAttributeText { get; }
    public bool IsCtorForcingMember { get; }
    public XamlMember PropertyElement { get; }
    public XamlText TextContent { get; }
    public bool IsXDataText { get; }
    public bool HasKeyAttribute { get; }
    public string Prefix { get; }
    public string Namespace { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    private XamlText AccumulatedText { get; }
    private bool HaveAccumulatedText { get; }
    private bool HaveUnprocessedAttributes { get; }
    internal XamlScanner(XamlParserContext context, XmlReader xmlReader, XamlXmlReaderSettings settings);
    public void Read();
    public ScannerNodeType get_PeekNodeType();
    public XamlType get_PeekType();
    public ScannerNodeType get_NodeType();
    public XamlType get_Type();
    public XamlMember get_PropertyAttribute();
    public XamlText get_PropertyAttributeText();
    public bool get_IsCtorForcingMember();
    public XamlMember get_PropertyElement();
    public XamlText get_TextContent();
    public bool get_IsXDataText();
    public bool get_HasKeyAttribute();
    public string get_Prefix();
    public string get_Namespace();
    public int get_LineNumber();
    public int get_LinePosition();
    private void LoadQueue();
    private void DoXmlRead();
    private void ProcessCurrentXmlNode();
    private XamlText get_AccumulatedText();
    private void ClearAccumulatedText();
    private bool get_HaveAccumulatedText();
    private void ReadElement();
    private void ReadObjectElement(XamlName name, bool isEmptyTag);
    private void ReadObjectElement_NoNamespace(XamlName name, XamlScannerNode node);
    private void ReadObjectElement_DirectiveProperty(XamlMember dirProperty, XamlScannerNode node);
    private bool ReadObjectElement_Object(string xmlns, string name, XamlScannerNode node);
    private void ReadPropertyElement(XamlPropertyName name, XamlType tagType, string tagNamespace, bool isEmptyTag);
    private void ReadEndElement();
    private void ReadText();
    private void ReadWhitespace();
    private void ReadNone();
    private void ReadInnerXDataSection();
    private XamlType CreateErrorXamlType(XamlName name, string xmlns);
    private void PreprocessAttributes();
    private void PreprocessForTypeArguments(List`1<XamlAttribute> attrList);
    private void PostprocessAttributes(XamlScannerNode node);
    private void StripUidProperty();
    private bool get_HaveUnprocessedAttributes();
    private void EnqueueAnotherAttribute(bool isEmptyTag);
    private void EnqueueAnyText();
    private void EnqueueTextNode();
    private void EnqueuePrefixDefinition(XamlAttribute attr);
    private bool IsXDataElement(string xmlns, string name);
    private XamlException LineInfo(XamlException e);
}
internal class MS.Internal.Xaml.Parser.XamlScannerFrame : object {
    [CompilerGeneratedAttribute]
private XamlType <XamlType>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlMember <XamlProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <XmlSpacePreserve>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InContent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeNamespace>k__BackingField;
    public XamlType XamlType { get; public set; }
    public XamlMember XamlProperty { get; public set; }
    public bool XmlSpacePreserve { get; public set; }
    public bool InContent { get; public set; }
    public string TypeNamespace { get; public set; }
    public XamlScannerFrame(XamlType xamlType, string ns);
    [CompilerGeneratedAttribute]
public XamlType get_XamlType();
    [CompilerGeneratedAttribute]
public void set_XamlType(XamlType value);
    [CompilerGeneratedAttribute]
public XamlMember get_XamlProperty();
    [CompilerGeneratedAttribute]
public void set_XamlProperty(XamlMember value);
    [CompilerGeneratedAttribute]
public bool get_XmlSpacePreserve();
    [CompilerGeneratedAttribute]
public void set_XmlSpacePreserve(bool value);
    [CompilerGeneratedAttribute]
public bool get_InContent();
    [CompilerGeneratedAttribute]
public void set_InContent(bool value);
    [CompilerGeneratedAttribute]
public string get_TypeNamespace();
    [CompilerGeneratedAttribute]
public void set_TypeNamespace(string value);
}
[DebuggerDisplayAttribute("{_nodeType}")]
internal class MS.Internal.Xaml.Parser.XamlScannerNode : object {
    [CompilerGeneratedAttribute]
private ScannerNodeType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlMember <PropertyAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlText <PropertyAttributeText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCtorForcingMember>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlMember <PropertyElement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEmptyTag>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlText <TextContent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsXDataText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    public ScannerNodeType NodeType { get; public set; }
    public XamlType Type { get; public set; }
    public string TypeNamespace { get; public set; }
    public XamlMember PropertyAttribute { get; public set; }
    public XamlText PropertyAttributeText { get; public set; }
    public bool IsCtorForcingMember { get; public set; }
    public XamlMember PropertyElement { get; public set; }
    public bool IsEmptyTag { get; public set; }
    public XamlText TextContent { get; public set; }
    public bool IsXDataText { get; public set; }
    public string Prefix { get; public set; }
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public XamlScannerNode(IXmlLineInfo lineInfo);
    public XamlScannerNode(XamlAttribute attr);
    [CompilerGeneratedAttribute]
public ScannerNodeType get_NodeType();
    [CompilerGeneratedAttribute]
public void set_NodeType(ScannerNodeType value);
    [CompilerGeneratedAttribute]
public XamlType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(XamlType value);
    [CompilerGeneratedAttribute]
public string get_TypeNamespace();
    [CompilerGeneratedAttribute]
public void set_TypeNamespace(string value);
    [CompilerGeneratedAttribute]
public XamlMember get_PropertyAttribute();
    [CompilerGeneratedAttribute]
public void set_PropertyAttribute(XamlMember value);
    [CompilerGeneratedAttribute]
public XamlText get_PropertyAttributeText();
    [CompilerGeneratedAttribute]
public void set_PropertyAttributeText(XamlText value);
    [CompilerGeneratedAttribute]
public bool get_IsCtorForcingMember();
    [CompilerGeneratedAttribute]
public void set_IsCtorForcingMember(bool value);
    [CompilerGeneratedAttribute]
public XamlMember get_PropertyElement();
    [CompilerGeneratedAttribute]
public void set_PropertyElement(XamlMember value);
    [CompilerGeneratedAttribute]
public bool get_IsEmptyTag();
    [CompilerGeneratedAttribute]
public void set_IsEmptyTag(bool value);
    [CompilerGeneratedAttribute]
public XamlText get_TextContent();
    [CompilerGeneratedAttribute]
public void set_TextContent(XamlText value);
    [CompilerGeneratedAttribute]
public bool get_IsXDataText();
    [CompilerGeneratedAttribute]
public void set_IsXDataText(bool value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
}
internal class MS.Internal.Xaml.Parser.XamlScannerStack : object {
    private Stack`1<XamlScannerFrame> _stack;
    public int Depth { get; }
    public XamlType CurrentType { get; }
    public string CurrentTypeNamespace { get; }
    public XamlMember CurrentProperty { get; public set; }
    public bool CurrentXmlSpacePreserve { get; public set; }
    public bool CurrentlyInContent { get; public set; }
    public void Push(XamlType type, string ns);
    public void Pop();
    public int get_Depth();
    public XamlType get_CurrentType();
    public string get_CurrentTypeNamespace();
    public XamlMember get_CurrentProperty();
    public void set_CurrentProperty(XamlMember value);
    public bool get_CurrentXmlSpacePreserve();
    public void set_CurrentXmlSpacePreserve(bool value);
    public bool get_CurrentlyInContent();
    public void set_CurrentlyInContent(bool value);
}
[DebuggerDisplayAttribute("{Text}")]
internal class MS.Internal.Xaml.Parser.XamlText : object {
    private static char SPACE;
    private static char NEWLINE;
    private static char RETURN;
    private static char TAB;
    private static char OPENCURLIE;
    private static char CLOSECURLIE;
    private static string ME_ESCAPE;
    private static string RETURN_STRING;
    private StringBuilder _sb;
    private bool _isSpacePreserve;
    private bool _isWhiteSpaceOnly;
    private static CodePointRange[] EastAsianCodePointRanges;
    public bool IsEmpty { get; }
    public string Text { get; }
    public string AttributeText { get; }
    public bool IsSpacePreserved { get; }
    public bool IsWhiteSpaceOnly { get; }
    public bool LooksLikeAMarkupExtension { get; }
    public XamlText(bool spacePreserve);
    private static XamlText();
    public bool get_IsEmpty();
    public string get_Text();
    public string get_AttributeText();
    public bool get_IsSpacePreserved();
    public bool get_IsWhiteSpaceOnly();
    public void Paste(string text, bool trimLeadingWhitespace, bool convertCRLFtoLF);
    public bool get_LooksLikeAMarkupExtension();
    private static bool IsWhitespace(string text);
    private static bool IsWhitespaceChar(char ch);
    private static string CollapseWhitespace(string text);
    public static string TrimLeadingWhitespace(string source);
    public static string TrimTrailingWhitespace(string source);
    private static bool HasSurroundingEastAsianChars(int start, int end, string text);
    private static int ComputeUnicodeScalarValue(int takeOneIdx, int takeTwoIdx, string text);
    private static bool IsEastAsianCodePoint(int unicodeScalarValue);
}
internal class MS.Internal.Xaml.Parser.XamlUnexpectedParseException : XamlParseException {
    public XamlUnexpectedParseException(XamlScanner xamlScanner, ScannerNodeType nodetype, string parseRule);
    protected XamlUnexpectedParseException(SerializationInfo info, StreamingContext context);
}
internal class MS.Internal.Xaml.Runtime.ClrObjectRuntime : XamlRuntime {
    private bool _ignoreCanConvert;
    private bool _isWriter;
    [CompilerGeneratedAttribute]
private IAddLineInfo <LineInfo>k__BackingField;
    public IAddLineInfo LineInfo { get; public set; }
    public ClrObjectRuntime(XamlRuntimeSettings settings, bool isWriter);
    [CompilerGeneratedAttribute]
public virtual IAddLineInfo get_LineInfo();
    [CompilerGeneratedAttribute]
public virtual void set_LineInfo(IAddLineInfo value);
    private static Exception UnwrapTargetInvocationException(Exception e);
    public virtual object CreateInstance(XamlType xamlType, Object[] args);
    protected virtual object CreateInstanceWithCtor(XamlType xamlType, Object[] args);
    public virtual object CreateWithFactoryMethod(XamlType xamlType, string methodName, Object[] args);
    protected virtual object InvokeFactoryMethod(Type type, string methodName, Object[] args);
    protected MethodInfo GetFactoryMethod(Type type, string methodName, Object[] args, BindingFlags flags);
    protected MethodBase BindToMethod(BindingFlags bindingFlags, MethodBase[] candidates, Object[] args);
    public virtual object CreateFromValue(ServiceProviderContext serviceContext, XamlValueConverter`1<TypeConverter> ts, object value, XamlMember property);
    public virtual bool CanConvertToString(IValueSerializerContext context, ValueSerializer serializer, object instance);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, TypeConverter converter);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, TypeConverter converter, Type type);
    public virtual string ConvertToString(IValueSerializerContext context, ValueSerializer serializer, object instance);
    public virtual T ConvertToValue(ITypeDescriptorContext context, TypeConverter converter, object instance);
    public virtual object GetValue(object obj, XamlMember property, bool failIfWriteOnly);
    protected virtual object GetValue(XamlMember member, object obj);
    public virtual void SetValue(object inst, XamlMember property, object value);
    protected virtual void SetValue(XamlMember member, object obj, object value);
    public virtual void Add(object collection, XamlType collectionType, object value, XamlType valueXamlType);
    public virtual void AddToDictionary(object collection, XamlType dictionaryType, object value, XamlType valueXamlType, object key);
    public virtual IList`1<object> GetCollectionItems(object collection, XamlType collectionType);
    public virtual IEnumerable`1<DictionaryEntry> GetDictionaryItems(object dictionary, XamlType dictionaryType);
    public virtual int AttachedPropertyCount(object instance);
    public virtual KeyValuePair`2[] GetAttachedProperties(object instance);
    public virtual void SetConnectionId(object root, int connectionId, object instance);
    public virtual void InitializationGuard(XamlType xamlType, object obj, bool begin);
    public virtual object CallProvideValue(MarkupExtension me, IServiceProvider serviceProvider);
    public virtual void SetUriBase(XamlType xamlType, object obj, Uri baseUri);
    public virtual void SetXmlInstance(object inst, XamlMember property, XData xData);
    public virtual TConverterBase GetConverterInstance(XamlValueConverter`1<TConverterBase> converter);
    public virtual object DeferredLoad(ServiceProviderContext serviceContext, XamlValueConverter`1<XamlDeferringLoader> deferringLoader, XamlReader deferredContent);
    public virtual XamlReader DeferredSave(IServiceProvider serviceContext, XamlValueConverter`1<XamlDeferringLoader> deferringLoader, object value);
    public virtual ShouldSerializeResult ShouldSerialize(XamlMember member, object instance);
    private object CreateObjectWithTypeConverter(ServiceProviderContext serviceContext, XamlValueConverter`1<TypeConverter> ts, object value);
    protected virtual Delegate CreateDelegate(Type delegateType, object target, string methodName);
    internal XamlRuntimeSettings GetSettings();
    private XamlException CreateException(string message);
    private XamlException CreateException(string message, Exception innerException);
    private IEnumerator GetItems(object collection, XamlType collectionType);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Runtime.ClrObjectRuntime/<DictionaryEntriesFromIDictionaryEnumerator>d__45")]
private static IEnumerable`1<DictionaryEntry> DictionaryEntriesFromIDictionaryEnumerator(IDictionaryEnumerator enumerator);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Runtime.ClrObjectRuntime/<DictionaryEntriesFromIEnumerator>d__46")]
private static IEnumerable`1<DictionaryEntry> DictionaryEntriesFromIEnumerator(IEnumerator enumerator);
    [IteratorStateMachineAttribute("MS.Internal.Xaml.Runtime.ClrObjectRuntime/<DictionaryEntriesFromIEnumeratorKvp>d__47`2")]
private static IEnumerable`1<DictionaryEntry> DictionaryEntriesFromIEnumeratorKvp(IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumerator);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Xaml.Runtime.DynamicMethodRuntime : ClrObjectRuntime {
    private static BindingFlags BF_AllInstanceMembers;
    private static BindingFlags BF_AllStaticMembers;
    private static PermissionSet s_FullTrustPermission;
    private static MethodInfo s_GetTypeFromHandleMethod;
    private static MethodInfo s_InvokeMemberMethod;
    private XamlLoadPermission _xamlLoadPermission;
    private Assembly _localAssembly;
    private Type _localType;
    private XamlSchemaContext _schemaContext;
    private Dictionary`2<MethodInfo, PropertyGetDelegate> _propertyGetDelegates;
    private Dictionary`2<MethodInfo, PropertySetDelegate> _propertySetDelegates;
    private Dictionary`2<MethodBase, FactoryDelegate> _factoryDelegates;
    private Dictionary`2<Type, object> _converterInstances;
    private Dictionary`2<Type, DelegateCreator> _delegateCreators;
    private DelegateCreator _delegateCreatorWithoutHelper;
    private Dictionary`2<MethodInfo, PropertyGetDelegate> PropertyGetDelegates { get; }
    private Dictionary`2<MethodInfo, PropertySetDelegate> PropertySetDelegates { get; }
    private Dictionary`2<MethodBase, FactoryDelegate> FactoryDelegates { get; }
    private Dictionary`2<Type, object> ConverterInstances { get; }
    private Dictionary`2<Type, DelegateCreator> DelegateCreators { get; }
    [SecurityCriticalAttribute]
internal DynamicMethodRuntime(XamlRuntimeSettings settings, XamlSchemaContext schemaContext, XamlAccessLevel accessLevel);
    private Dictionary`2<MethodInfo, PropertyGetDelegate> get_PropertyGetDelegates();
    private Dictionary`2<MethodInfo, PropertySetDelegate> get_PropertySetDelegates();
    private Dictionary`2<MethodBase, FactoryDelegate> get_FactoryDelegates();
    private Dictionary`2<Type, object> get_ConverterInstances();
    private Dictionary`2<Type, DelegateCreator> get_DelegateCreators();
    [SecuritySafeCriticalAttribute]
public virtual TConverterBase GetConverterInstance(XamlValueConverter`1<TConverterBase> ts);
    [SecuritySafeCriticalAttribute]
public virtual object CreateFromValue(ServiceProviderContext serviceContext, XamlValueConverter`1<TypeConverter> ts, object value, XamlMember property);
    [SecuritySafeCriticalAttribute]
protected virtual Delegate CreateDelegate(Type delegateType, object target, string methodName);
    [SecuritySafeCriticalAttribute]
protected virtual object CreateInstanceWithCtor(XamlType xamlType, Object[] args);
    private object CreateInstanceWithCtor(Type type, Object[] args);
    [SecuritySafeCriticalAttribute]
protected virtual object InvokeFactoryMethod(Type type, string methodName, Object[] args);
    [SecuritySafeCriticalAttribute]
protected virtual object GetValue(XamlMember member, object obj);
    [SecuritySafeCriticalAttribute]
protected virtual void SetValue(XamlMember member, object obj, object value);
    private DelegateCreator CreateDelegateCreator(Type targetType);
    private DelegateCreator CreateDelegateCreatorWithoutHelper();
    private FactoryDelegate CreateFactoryDelegate(ConstructorInfo ctor);
    private FactoryDelegate CreateFactoryDelegate(MethodInfo factory);
    private LocalBuilder[] LoadArguments(ILGenerator ilGenerator, MethodBase method);
    private void UnloadArguments(ILGenerator ilGenerator, LocalBuilder[] locals);
    private PropertyGetDelegate CreateGetDelegate(MethodInfo getter);
    private PropertySetDelegate CreateSetDelegate(MethodInfo setter);
    private DynamicMethod CreateDynamicMethod(string name, Type returnType, Type[] argTypes);
    private void DemandXamlLoadPermission();
    private Type GetTargetType(MethodInfo instanceMethod);
    private static void Emit_Call(ILGenerator ilGenerator, MethodInfo method);
    private static void Emit_CastTo(ILGenerator ilGenerator, Type toType);
    private static void Emit_BoxIfValueType(ILGenerator ilGenerator, Type type);
    private static void Emit_ConstInt(ILGenerator ilGenerator, int value);
    private void Emit_LateBoundInvoke(ILGenerator ilGenerator, Type targetType, string methodName, BindingFlags bindingFlags, short targetArgNum, Int16[] paramArgNums);
    private void Emit_TypeOf(ILGenerator ilGenerator, Type type);
}
internal interface MS.Internal.Xaml.Runtime.IAddLineInfo {
    public abstract virtual XamlException WithLineInfo(XamlException ex);
}
internal class MS.Internal.Xaml.Runtime.PartialTrustTolerantRuntime : XamlRuntime {
    private bool _memberAccessPermissionDenied;
    private ClrObjectRuntime _transparentRuntime;
    private ClrObjectRuntime _elevatedRuntime;
    private XamlAccessLevel _accessLevel;
    private XamlSchemaContext _schemaContext;
    public IAddLineInfo LineInfo { get; public set; }
    private bool MemberAccessPermissionDenied { get; private set; }
    public PartialTrustTolerantRuntime(XamlRuntimeSettings runtimeSettings, XamlAccessLevel accessLevel, XamlSchemaContext schemaContext);
    public virtual IAddLineInfo get_LineInfo();
    public virtual void set_LineInfo(IAddLineInfo value);
    public virtual void Add(object collection, XamlType collectionType, object value, XamlType valueXamlType);
    public virtual void AddToDictionary(object collection, XamlType dictionaryType, object value, XamlType valueXamlType, object key);
    public virtual object CallProvideValue(MarkupExtension me, IServiceProvider serviceProvider);
    public virtual object CreateFromValue(ServiceProviderContext serviceContext, XamlValueConverter`1<TypeConverter> ts, object value, XamlMember property);
    public virtual int AttachedPropertyCount(object instance);
    public virtual KeyValuePair`2[] GetAttachedProperties(object instance);
    public virtual bool CanConvertToString(IValueSerializerContext context, ValueSerializer serializer, object instance);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, TypeConverter converter);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, TypeConverter converter, Type type);
    public virtual string ConvertToString(IValueSerializerContext context, ValueSerializer serializer, object instance);
    public virtual T ConvertToValue(ITypeDescriptorContext context, TypeConverter converter, object instance);
    public virtual object CreateInstance(XamlType xamlType, Object[] args);
    public virtual object CreateWithFactoryMethod(XamlType xamlType, string methodName, Object[] args);
    public virtual object DeferredLoad(ServiceProviderContext serviceContext, XamlValueConverter`1<XamlDeferringLoader> deferringLoader, XamlReader deferredContent);
    public virtual XamlReader DeferredSave(IServiceProvider context, XamlValueConverter`1<XamlDeferringLoader> deferringLoader, object value);
    public virtual TConverterBase GetConverterInstance(XamlValueConverter`1<TConverterBase> converter);
    public virtual object GetValue(object obj, XamlMember property, bool failIfWriteOnly);
    public virtual void InitializationGuard(XamlType xamlType, object obj, bool begin);
    public virtual void SetConnectionId(object root, int connectionId, object instance);
    public virtual void SetUriBase(XamlType xamlType, object obj, Uri baseUri);
    public virtual void SetValue(object obj, XamlMember property, object value);
    public virtual void SetXmlInstance(object inst, XamlMember property, XData xData);
    public virtual ShouldSerializeResult ShouldSerialize(XamlMember member, object instance);
    public virtual IList`1<object> GetCollectionItems(object collection, XamlType collectionType);
    public virtual IEnumerable`1<DictionaryEntry> GetDictionaryItems(object dictionary, XamlType dictionaryType);
    private bool get_MemberAccessPermissionDenied();
    private void set_MemberAccessPermissionDenied(bool value);
    [SecuritySafeCriticalAttribute]
private void EnsureElevatedRuntime();
    private static bool HasDefaultInvoker(XamlType xamlType);
    private static bool HasDefaultInvoker(XamlMember xamlMember);
    private static bool IsDefaultConverter(XamlValueConverter`1<TConverterBase> converter);
}
internal abstract class MS.Internal.Xaml.Runtime.XamlRuntime : object {
    public IAddLineInfo LineInfo { get; public set; }
    public abstract virtual IAddLineInfo get_LineInfo();
    public abstract virtual void set_LineInfo(IAddLineInfo value);
    public abstract virtual object CreateInstance(XamlType xamlType, Object[] args);
    public abstract virtual object CreateWithFactoryMethod(XamlType xamlType, string methodName, Object[] args);
    public abstract virtual object CreateFromValue(ServiceProviderContext serviceContext, XamlValueConverter`1<TypeConverter> ts, object value, XamlMember property);
    public abstract virtual bool CanConvertToString(IValueSerializerContext context, ValueSerializer serializer, object instance);
    public abstract virtual bool CanConvertFrom(ITypeDescriptorContext context, TypeConverter converter);
    public abstract virtual bool CanConvertTo(ITypeDescriptorContext context, TypeConverter converter, Type type);
    public abstract virtual string ConvertToString(IValueSerializerContext context, ValueSerializer serializer, object instance);
    public abstract virtual T ConvertToValue(ITypeDescriptorContext context, TypeConverter converter, object instance);
    public abstract virtual object DeferredLoad(ServiceProviderContext serviceContext, XamlValueConverter`1<XamlDeferringLoader> deferringLoader, XamlReader deferredContent);
    public abstract virtual XamlReader DeferredSave(IServiceProvider context, XamlValueConverter`1<XamlDeferringLoader> deferringLoader, object value);
    public object GetValue(object obj, XamlMember property);
    public abstract virtual object GetValue(object obj, XamlMember property, bool failIfWriteOnly);
    public abstract virtual void SetValue(object obj, XamlMember property, object value);
    public abstract virtual void SetUriBase(XamlType xamlType, object obj, Uri baseUri);
    public abstract virtual void SetXmlInstance(object inst, XamlMember property, XData xData);
    public abstract virtual void Add(object collection, XamlType collectionType, object value, XamlType valueXamlType);
    public abstract virtual void AddToDictionary(object collection, XamlType dictionaryType, object value, XamlType valueXamlType, object key);
    public abstract virtual IList`1<object> GetCollectionItems(object collection, XamlType collectionType);
    public abstract virtual IEnumerable`1<DictionaryEntry> GetDictionaryItems(object dictionary, XamlType dictionaryType);
    public abstract virtual int AttachedPropertyCount(object instance);
    public abstract virtual KeyValuePair`2[] GetAttachedProperties(object instance);
    public abstract virtual void SetConnectionId(object root, int connectionId, object instance);
    public abstract virtual void InitializationGuard(XamlType xamlType, object obj, bool begin);
    public abstract virtual object CallProvideValue(MarkupExtension me, IServiceProvider serviceProvider);
    public abstract virtual ShouldSerializeResult ShouldSerialize(XamlMember member, object instance);
    public abstract virtual TConverterBase GetConverterInstance(XamlValueConverter`1<TConverterBase> converter);
}
internal class MS.Internal.Xaml.Runtime.XamlRuntimeSettings : object {
    [CompilerGeneratedAttribute]
private bool <IgnoreCanConvert>k__BackingField;
    public bool IgnoreCanConvert { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IgnoreCanConvert();
    [CompilerGeneratedAttribute]
public void set_IgnoreCanConvert(bool value);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.Xaml.SecurityCriticalDataForSet`1 : ValueType {
    [SecurityCriticalAttribute]
private T _value;
    internal T Value { get; internal set; }
    [SecurityCriticalAttribute]
internal SecurityCriticalDataForSet`1(T value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal T get_Value();
    [SecurityCriticalAttribute]
internal void set_Value(T value);
}
internal class MS.Internal.Xaml.ServiceProviderContext : object {
    private ObjectWriterContext _xamlContext;
    private IContainer System.ComponentModel.ITypeDescriptorContext.Container { get; }
    private object System.ComponentModel.ITypeDescriptorContext.Instance { get; }
    private PropertyDescriptor System.ComponentModel.ITypeDescriptorContext.PropertyDescriptor { get; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    private XamlSchemaContext System.Xaml.IXamlSchemaContextProvider.SchemaContext { get; }
    private object System.Windows.Markup.IProvideValueTarget.TargetObject { get; }
    private object System.Windows.Markup.IProvideValueTarget.TargetProperty { get; }
    private object System.Xaml.IRootObjectProvider.RootObject { get; }
    private bool System.Xaml.IXamlNameResolver.IsFixupTokenAvailable { get; }
    public bool HasLineInfo { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public ServiceProviderContext(ObjectWriterContext context);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override void System.ComponentModel.ITypeDescriptorContext.OnComponentChanged();
    private sealed virtual override bool System.ComponentModel.ITypeDescriptorContext.OnComponentChanging();
    private sealed virtual override IContainer System.ComponentModel.ITypeDescriptorContext.get_Container();
    private sealed virtual override object System.ComponentModel.ITypeDescriptorContext.get_Instance();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ITypeDescriptorContext.get_PropertyDescriptor();
    private sealed virtual override Type System.Windows.Markup.IXamlTypeResolver.Resolve(string qName);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    private sealed virtual override AmbientPropertyValue System.Xaml.IAmbientProvider.GetFirstAmbientValue(IEnumerable`1<XamlType> ceilingTypes, XamlMember[] properties);
    private sealed virtual override object System.Xaml.IAmbientProvider.GetFirstAmbientValue(XamlType[] types);
    private sealed virtual override IEnumerable`1<AmbientPropertyValue> System.Xaml.IAmbientProvider.GetAllAmbientValues(IEnumerable`1<XamlType> ceilingTypes, XamlMember[] properties);
    private sealed virtual override IEnumerable`1<object> System.Xaml.IAmbientProvider.GetAllAmbientValues(XamlType[] types);
    private sealed virtual override IEnumerable`1<AmbientPropertyValue> System.Xaml.IAmbientProvider.GetAllAmbientValues(IEnumerable`1<XamlType> ceilingTypes, bool searchLiveStackOnly, IEnumerable`1<XamlType> types, XamlMember[] properties);
    private sealed virtual override XamlSchemaContext System.Xaml.IXamlSchemaContextProvider.get_SchemaContext();
    private sealed virtual override object System.Windows.Markup.IProvideValueTarget.get_TargetObject();
    private sealed virtual override object System.Windows.Markup.IProvideValueTarget.get_TargetProperty();
    private sealed virtual override object System.Xaml.IRootObjectProvider.get_RootObject();
    private sealed virtual override string System.Xaml.IXamlNamespaceResolver.GetNamespace(string prefix);
    private sealed virtual override IEnumerable`1<NamespaceDeclaration> System.Xaml.IXamlNamespaceResolver.GetNamespacePrefixes();
    private sealed virtual override bool System.Xaml.IXamlNameResolver.get_IsFixupTokenAvailable();
    private sealed virtual override object System.Xaml.IXamlNameResolver.Resolve(string name);
    private sealed virtual override object System.Xaml.IXamlNameResolver.Resolve(string name, Boolean& isFullyInitialized);
    private sealed virtual override object System.Xaml.IXamlNameResolver.GetFixupToken(IEnumerable`1<string> names);
    private sealed virtual override object System.Xaml.IXamlNameResolver.GetFixupToken(IEnumerable`1<string> names, bool canAssignDirectly);
    private sealed virtual override IEnumerable`1<KeyValuePair`2<string, object>> System.Xaml.IXamlNameResolver.GetAllNamesAndValuesInScope();
    private sealed virtual override void System.Xaml.IXamlNameResolver.add_OnNameScopeInitializationComplete(EventHandler value);
    private sealed virtual override void System.Xaml.IXamlNameResolver.remove_OnNameScopeInitializationComplete(EventHandler value);
    public sealed virtual Type GetDestinationType();
    public sealed virtual bool get_HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
internal abstract class MS.Internal.Xaml.XamlContext : object {
    private XamlSchemaContext _schemaContext;
    private Func`2<string, string> _resolvePrefixCachedDelegate;
    protected Assembly _localAssembly;
    public XamlSchemaContext SchemaContext { get; }
    public Assembly LocalAssembly { get; protected set; }
    internal Func`2<string, string> ResolvePrefixCachedDelegate { get; }
    protected XamlContext(XamlSchemaContext schemaContext);
    public XamlSchemaContext get_SchemaContext();
    public virtual Assembly get_LocalAssembly();
    protected virtual void set_LocalAssembly(Assembly value);
    public XamlMember GetXamlProperty(XamlType xamlType, string propertyName, XamlType rootObjectType);
    public XamlMember GetXamlAttachableProperty(XamlType xamlType, string propertyName);
    public XamlMember GetDottedProperty(XamlType tagType, string tagNamespace, XamlPropertyName propName, bool tagIsRoot);
    public string GetAttributeNamespace(XamlPropertyName propName, string tagNamespace);
    public string IgnoreAPIInformation(string namespaceName);
    public bool HasAPIInformation(string namespaceName);
    public XamlMember GetNoDotAttributeProperty(XamlType tagType, XamlPropertyName propName, string tagNamespace, string propUsageNamespace, bool tagIsRoot);
    public abstract virtual void AddNamespacePrefix(string prefix, string xamlNamespace);
    public abstract virtual string FindNamespaceByPrefix(string prefix);
    public abstract virtual IEnumerable`1<NamespaceDeclaration> GetNamespacePrefixes();
    private XamlType GetXamlTypeOrUnknown(XamlTypeName typeName);
    internal XamlType GetXamlType(XamlName typeName);
    internal XamlType GetXamlType(XamlName typeName, bool returnUnknownTypesOnFailure);
    internal XamlTypeName GetXamlTypeName(XamlName typeName);
    internal XamlType GetXamlType(XamlTypeName typeName);
    internal XamlType GetXamlType(XamlTypeName typeName, bool returnUnknownTypesOnFailure);
    internal XamlType GetXamlType(XamlTypeName typeName, bool returnUnknownTypesOnFailure, bool skipVisibilityCheck);
    internal Func`2<string, string> get_ResolvePrefixCachedDelegate();
    private string ResolveXamlNameNS(XamlName name);
    internal XamlType ResolveXamlType(string qName, bool skipVisibilityCheck);
    internal XamlMember ResolveDirectiveProperty(string xamlNS, string name);
    internal virtual bool IsVisible(XamlMember member, XamlType rootObjectType);
    private XamlMember CreateUnknownMember(XamlType declaringType, string name);
    private XamlMember CreateUnknownAttachableMember(XamlType declaringType, string name);
    private bool PropertyTypeMatchesGenericTagType(XamlType tagType, string tagNs, string propNs, string propTypeName);
    private XamlMember GetInstanceOrAttachableProperty(XamlType tagType, string propName, XamlType rootTagType);
    private XamlType GetXamlType(string ns, string name, IList`1<XamlType> typeArguments);
}
public class SuccinctCollectionSyntax.SuccinctCollectionSyntaxErrorListener : BaseErrorListener {
    public virtual void SyntaxError(IRecognizer recognizer, IToken offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public class SuccinctCollectionSyntax.SuccinctCollectionSyntaxException : Exception {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Col>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OffendingToken>k__BackingField;
    public int Line { get; }
    public int Col { get; }
    public string OffendingToken { get; }
    public SuccinctCollectionSyntaxException(string syntaxError, string offendingSymbolText, int line, int charPositionInLine);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Col();
    [CompilerGeneratedAttribute]
public string get_OffendingToken();
    private static string FormatMessage(string errorMessage, string offendingSymbolText, int line, int charPositionInLine);
}
[GeneratedCodeAttribute("ANTLR", "4.5.1")]
[CLSCompliantAttribute("False")]
public class SuccinctCollectionSyntaxBaseListener : object {
    public virtual void EnterProgram(ProgramContext context);
    public virtual void ExitProgram(ProgramContext context);
    public virtual void EnterItems(ItemsContext context);
    public virtual void ExitItems(ItemsContext context);
    public virtual void EnterZ(ZContext context);
    public virtual void ExitZ(ZContext context);
    public virtual void EnterItem(ItemContext context);
    public virtual void ExitItem(ItemContext context);
    public virtual void EnterText(TextContext context);
    public virtual void ExitText(TextContext context);
    public virtual void EnterLiteral_text(Literal_textContext context);
    public virtual void ExitLiteral_text(Literal_textContext context);
    public virtual void EnterSequence(SequenceContext context);
    public virtual void ExitSequence(SequenceContext context);
    public virtual void EnterEveryRule(ParserRuleContext context);
    public virtual void ExitEveryRule(ParserRuleContext context);
    public virtual void VisitTerminal(ITerminalNode node);
    public virtual void VisitErrorNode(IErrorNode node);
}
[GeneratedCodeAttribute("ANTLR", "4.5.1")]
[CLSCompliantAttribute("False")]
public class SuccinctCollectionSyntaxLexer : Lexer {
    public static int SINGLE_QUOTE;
    public static int DOUBLE_QUOTE;
    public static int OPEN_SQUARE_BRACE;
    public static int CLOSE_SQUARE_BRACE;
    public static int CHARACTER;
    public static int COMMA;
    public static int BACKSLASH;
    public static int RESERVED_SYMBOL;
    public static int QUOTE;
    public static String[] modeNames;
    public static String[] ruleNames;
    private static String[] _LiteralNames;
    private static String[] _SymbolicNames;
    public static IVocabulary DefaultVocabulary;
    public static string _serializedATN;
    public static ATN _ATN;
    [NotNullAttribute]
public IVocabulary Vocabulary { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public String[] ModeNames { get; }
    public string SerializedAtn { get; }
    public SuccinctCollectionSyntaxLexer(ICharStream input);
    private static SuccinctCollectionSyntaxLexer();
    public virtual IVocabulary get_Vocabulary();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual String[] get_ModeNames();
    public virtual string get_SerializedAtn();
}
[GeneratedCodeAttribute("ANTLR", "4.5.1")]
[CLSCompliantAttribute("False")]
public class SuccinctCollectionSyntaxParser : Parser {
    public static int SINGLE_QUOTE;
    public static int DOUBLE_QUOTE;
    public static int OPEN_SQUARE_BRACE;
    public static int CLOSE_SQUARE_BRACE;
    public static int CHARACTER;
    public static int COMMA;
    public static int BACKSLASH;
    public static int RESERVED_SYMBOL;
    public static int QUOTE;
    public static int RULE_program;
    public static int RULE_items;
    public static int RULE_z;
    public static int RULE_item;
    public static int RULE_text;
    public static int RULE_literal_text;
    public static int RULE_sequence;
    public static String[] ruleNames;
    private static String[] _LiteralNames;
    private static String[] _SymbolicNames;
    public static IVocabulary DefaultVocabulary;
    public static string _serializedATN;
    public static ATN _ATN;
    [NotNullAttribute]
public IVocabulary Vocabulary { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public string SerializedAtn { get; }
    public SuccinctCollectionSyntaxParser(ITokenStream input);
    private static SuccinctCollectionSyntaxParser();
    public virtual IVocabulary get_Vocabulary();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual string get_SerializedAtn();
    [RuleVersionAttribute("0")]
public ProgramContext program();
    [RuleVersionAttribute("0")]
public ItemsContext items();
    [RuleVersionAttribute("0")]
public ZContext z();
    [RuleVersionAttribute("0")]
public ItemContext item();
    [RuleVersionAttribute("0")]
public TextContext text();
    [RuleVersionAttribute("0")]
public Literal_textContext literal_text();
    [RuleVersionAttribute("0")]
public SequenceContext sequence();
}
[DebuggerDisplayAttribute("AssemblyProxy")]
internal abstract class System.Reflection.Adds.AssemblyProxy : Assembly {
    private ITypeUniverse m_universe;
    private Assembly m_assembly;
    public ITypeUniverse TypeUniverse { get; }
    public string FullName { get; }
    public string Location { get; }
    public bool ReflectionOnly { get; }
    public string CodeBase { get; }
    public string EscapedCodeBase { get; }
    public MethodInfo EntryPoint { get; }
    public Module ManifestModule { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    protected AssemblyProxy(ITypeUniverse universe);
    public Assembly GetResolvedAssembly();
    public sealed virtual ITypeUniverse get_TypeUniverse();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    protected abstract virtual Assembly GetResolvedAssemblyWorker();
    protected abstract virtual AssemblyName GetNameWithNoResolution();
    public virtual AssemblyName GetName();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual string get_FullName();
    public virtual string get_Location();
    public virtual Type[] GetExportedTypes();
    public virtual bool get_ReflectionOnly();
    public virtual Type[] GetTypes();
    public virtual string get_CodeBase();
    public virtual string get_EscapedCodeBase();
    public virtual MethodInfo get_EntryPoint();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Module GetModule(string name);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module get_ManifestModule();
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual String[] GetManifestResourceNames();
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual FileStream[] GetFiles();
    public virtual FileStream GetFile(string name);
}
internal abstract class System.Reflection.Adds.ConstructorInfoProxy : ConstructorInfo {
    private ConstructorInfo m_cachedResolved;
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    protected abstract virtual ConstructorInfo GetResolvedWorker();
    public ConstructorInfo GetResolvedConstructor();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual ParameterInfo[] GetParameters();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBody GetMethodBody();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
internal enum System.Reflection.Adds.CorElementType : Enum {
    public int value__;
    public static CorElementType Array;
    public static CorElementType Bool;
    public static CorElementType Byref;
    public static CorElementType Char;
    public static CorElementType Class;
    public static CorElementType CModOpt;
    public static CorElementType CModReqd;
    public static CorElementType End;
    public static CorElementType FnPtr;
    public static CorElementType IntPtr;
    public static CorElementType SByte;
    public static CorElementType Short;
    public static CorElementType Int;
    public static CorElementType Long;
    public static CorElementType Internal;
    public static CorElementType Max;
    public static CorElementType Modifier;
    public static CorElementType Object;
    public static CorElementType Pinned;
    public static CorElementType Pointer;
    public static CorElementType Float;
    public static CorElementType Double;
    public static CorElementType Sentinel;
    public static CorElementType String;
    public static CorElementType SzArray;
    public static CorElementType TypedByRef;
    public static CorElementType UIntPtr;
    public static CorElementType Byte;
    public static CorElementType UShort;
    public static CorElementType UInt;
    public static CorElementType ULong;
    public static CorElementType ValueType;
    public static CorElementType Void;
    public static CorElementType TypeVar;
    public static CorElementType MethodVar;
    public static CorElementType GenericInstantiation;
    public static CorElementType Type;
    public static CorElementType Enum;
}
[FlagsAttribute]
public enum System.Reflection.Adds.CorOpenFlags : Enum {
    public int value__;
    public static CorOpenFlags Read;
    public static CorOpenFlags Write;
    public static CorOpenFlags ReadWriteMask;
    public static CorOpenFlags CopyMemory;
    public static CorOpenFlags ReadOnly;
    public static CorOpenFlags TakeOwnership;
    public static CorOpenFlags NoTypeLib;
    public static CorOpenFlags NoTransform;
}
internal static class System.Reflection.Adds.ElementTypeUtility : object {
    public static string GetNameForPrimitive(CorElementType value);
}
internal class System.Reflection.Adds.EmbeddedBlobPointer : ValueType {
    private IntPtr m_data;
    internal IntPtr GetDangerousLivePointer { get; }
    internal IntPtr get_GetDangerousLivePointer();
}
internal class System.Reflection.Adds.FileMapping : object {
    private string m_fileName;
    private string m_filePath;
    private long m_fileLength;
    private IntPtr m_baseAddress;
    private SafeFileHandle m_fileHandle;
    private SafeWin32Handle m_fileMapping;
    private SafeMapViewHandle m_View;
    public string Path { get; }
    public long Length { get; }
    public IntPtr BaseAddress { get; }
    public FileMapping(IntPtr baseAddress, long fileLength, string fileName);
    public FileMapping(string fileName);
    public string get_Path();
    public long get_Length();
    public IntPtr get_BaseAddress();
    public virtual string ToString();
    public sealed virtual void Dispose();
}
internal static class System.Reflection.Adds.Helpers : object {
    public static ITypeUniverse Universe(Type type);
    public static Type EnsureResolve(Type type);
}
internal interface System.Reflection.Adds.IAssembly2 {
    public ITypeUniverse TypeUniverse { get; }
    public abstract virtual ITypeUniverse get_TypeUniverse();
}
internal interface System.Reflection.Adds.IFieldInfo2 {
    public abstract virtual Byte[] GetRvaField();
}
internal class System.Reflection.Adds.ImageHelper : object {
    private IntPtr m_baseAddress;
    private long m_lengthBytes;
    private UInt32 m_idx;
    private UInt32 m_idxSectionStart;
    private UInt32 m_numSections;
    private UInt32 m_clrHeaderRva;
    [CompilerGeneratedAttribute]
private ImageType <ImageType>k__BackingField;
    public ImageType ImageType { get; private set; }
    public ImageHelper(IntPtr baseAddress, long lengthBytes);
    [CompilerGeneratedAttribute]
public ImageType get_ImageType();
    [CompilerGeneratedAttribute]
private void set_ImageType(ImageType value);
    public IntPtr GetResourcesSectionStart();
    internal IMAGE_COR20_HEADER GetCor20Header();
    public Token GetEntryPointToken();
    public IntPtr ResolveRva(long rva);
    internal T MarshalAt(UInt32 offset);
}
internal enum System.Reflection.Adds.ImageType : Enum {
    public ushort value__;
    public static ImageType Pe32bit;
    public static ImageType Pe64bit;
}
internal interface System.Reflection.Adds.IModule2 {
    public abstract virtual int RowCount(MetadataTable metadataTableIndex);
    public abstract virtual AssemblyName GetAssemblyNameFromAssemblyRef(Token token);
}
internal interface System.Reflection.Adds.IMutableTypeUniverse {
    public abstract virtual void AddAssembly(Assembly assembly);
}
internal interface System.Reflection.Adds.ITypeProxy {
    public ITypeUniverse TypeUniverse { get; }
    public abstract virtual Type GetResolvedType();
    public abstract virtual ITypeUniverse get_TypeUniverse();
}
internal interface System.Reflection.Adds.ITypeReference {
    public Token TypeRefToken { get; }
    public string RawName { get; }
    public Token ResolutionScope { get; }
    public string FullName { get; }
    public Module DeclaringScope { get; }
    public abstract virtual Token get_TypeRefToken();
    public abstract virtual string get_RawName();
    public abstract virtual Token get_ResolutionScope();
    public abstract virtual string get_FullName();
    public abstract virtual Module get_DeclaringScope();
}
internal interface System.Reflection.Adds.ITypeSignatureBlob {
    public Byte[] Blob { get; }
    public Module DeclaringScope { get; }
    public abstract virtual Byte[] get_Blob();
    public abstract virtual Module get_DeclaringScope();
}
internal interface System.Reflection.Adds.ITypeSpec {
    public Token TypeSpecToken { get; }
    public abstract virtual Token get_TypeSpecToken();
}
internal interface System.Reflection.Adds.ITypeUniverse {
    public abstract virtual Type GetBuiltInType(CorElementType elementType);
    public abstract virtual Type GetTypeXFromName(string fullName);
    public abstract virtual Assembly GetSystemAssembly();
    public abstract virtual Assembly GetSystemRuntimeAssembly();
    public abstract virtual Assembly ResolveAssembly(AssemblyName name);
    public abstract virtual Assembly ResolveAssembly(AssemblyName name, bool throwOnError);
    public abstract virtual Assembly ResolveAssembly(Module scope, Token tokenAssemblyRef);
    public abstract virtual bool WouldResolveToAssembly(AssemblyName name, Assembly assembly);
    public abstract virtual Module ResolveModule(Assembly containingAssembly, string moduleName);
    public abstract virtual Type ResolveWindowsRuntimeType(string typeName, bool throwOnError, bool ignoreCase);
}
internal class System.Reflection.Adds.MetadataDispenser : object {
    private CorOpenFlags m_openFlags;
    public CorOpenFlags OpenFlags { get; public set; }
    private static IMetaDataDispenserEx GetDispenserShim();
    public MetadataFile OpenFromByteArray(Byte[] data);
    public MetadataFile OpenFileAsFileMapping(string fileName);
    public MetadataFile OpenFileAsFileMapping(object importer, string fileName);
    public MetadataFile OpenFile(string fileName);
    public CorOpenFlags get_OpenFlags();
    public void set_OpenFlags(CorOpenFlags value);
}
internal class System.Reflection.Adds.MetadataFile : object {
    private IntPtr m_rawPointer;
    public IntPtr RawPtr { get; }
    public string FilePath { get; }
    public MetadataFile(object importer);
    internal MetadataFile(IntPtr rawImporter);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public IntPtr get_RawPtr();
    public virtual string get_FilePath();
    public virtual Byte[] ReadRva(long rva, int countBytes);
    public virtual Byte[] ReadResource(long offset);
    public Byte[] ReadEmbeddedBlob(EmbeddedBlobPointer pointer, int countBytes);
    protected virtual void ValidateRange(IntPtr ptr, int countBytes);
    public virtual Token ReadEntryPointToken();
    public virtual T ReadRvaStruct(long rva);
    protected void EnsureNotDispose();
}
internal class System.Reflection.Adds.MetadataFileAndRvaResolver : MetadataFile {
    private FileMapping m_file;
    private bool m_disableRangeValidation;
    public string FilePath { get; }
    public MetadataFileAndRvaResolver(IntPtr importer, FileMapping file);
    public MetadataFileAndRvaResolver(IntPtr importer, FileMapping file, bool disableRangeValidation);
    public MetadataFileAndRvaResolver(object importer, FileMapping file);
    protected virtual void Dispose(bool disposing);
    public virtual string get_FilePath();
    private IntPtr ResolveRva(long rva);
    public virtual Byte[] ReadRva(long rva, int countBytes);
    protected virtual void ValidateRange(IntPtr ptr, int countBytes);
    public virtual Byte[] ReadResource(long offset);
    public virtual Token ReadEntryPointToken();
    public virtual T ReadRvaStruct(long rva);
}
internal enum System.Reflection.Adds.MetadataTable : Enum {
    public int value__;
    public static MetadataTable Module;
    public static MetadataTable TypeRef;
    public static MetadataTable TypeDef;
    public static MetadataTable FieldDef;
    public static MetadataTable MethodDef;
    public static MetadataTable ParamDef;
    public static MetadataTable InterfaceImpl;
    public static MetadataTable MemberRef;
    public static MetadataTable CustomAttribute;
    public static MetadataTable Permission;
    public static MetadataTable Signature;
    public static MetadataTable Event;
    public static MetadataTable Property;
    public static MetadataTable ModuleRef;
    public static MetadataTable TypeSpec;
    public static MetadataTable Assembly;
    public static MetadataTable AssemblyRef;
    public static MetadataTable File;
    public static MetadataTable ExportedType;
    public static MetadataTable ManifestResource;
    public static MetadataTable GenericPar;
    public static MetadataTable MethodSpec;
}
internal static class System.Reflection.Adds.NativeMethods : object {
    private static string Kernel32LibraryName;
    private static int FILE_TYPE_DISK;
    private static int GENERIC_READ;
    private static SafeFileHandle CreateFile(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, IntPtr securityAttrs, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);
    private static int GetFileType(SafeFileHandle handle);
    internal static SafeFileHandle SafeOpenFile(string fileName);
    private static int GetFileSize(SafeFileHandle hFile, Int32& highSize);
    internal static long FileSize(SafeFileHandle handle);
    public static bool CloseHandle(IntPtr handle);
    public static SafeWin32Handle CreateFileMapping(SafeFileHandle hFile, IntPtr lpFileMappingAttributes, PageProtection flProtect, UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, string lpName);
    public static SafeMapViewHandle MapViewOfFile(SafeWin32Handle hFileMappingObject, UInt32 dwDesiredAccess, UInt32 dwFileOffsetHigh, UInt32 dwFileOffsetLow, IntPtr dwNumberOfBytesToMap);
    public static bool UnmapViewOfFile(IntPtr baseAddress);
}
[DebuggerDisplayAttribute("Resolve for {Name}")]
internal class System.Reflection.Adds.ResolveAssemblyNameEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private AssemblyName <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <Target>k__BackingField;
    public AssemblyName Name { get; internal set; }
    public Assembly Target { get; public set; }
    public ResolveAssemblyNameEventArgs(AssemblyName name);
    [CompilerGeneratedAttribute]
public AssemblyName get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(AssemblyName value);
    [CompilerGeneratedAttribute]
public Assembly get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(Assembly value);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class System.Reflection.Adds.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArrayInsideArrayInAttributeNotSupported { get; }
    internal static string AssemblyRefTokenExpected { get; }
    internal static string CannotDetermineSystemAssembly { get; }
    internal static string CannotFindTypeInModule { get; }
    internal static string CannotResolveModuleRefOnNetModule { get; }
    internal static string CannotResolveRVA { get; }
    internal static string CaseInsensitiveTypeLookupNotImplemented { get; }
    internal static string CorruptImage { get; }
    internal static string DefaultTokenResolverRequired { get; }
    internal static string DifferentTokenResolverForOuterType { get; }
    internal static string EscapeSequenceMissingCharacter { get; }
    internal static string ExpectedPositiveNumberOfGenericParameters { get; }
    internal static string ExpectedPropertyOrFieldId { get; }
    internal static string ExpectedTokenType { get; }
    internal static string ExtraAssemblyManifest { get; }
    internal static string ExtraCharactersAfterTypeName { get; }
    internal static string ExtraInformationAfterLastParameter { get; }
    internal static string HostSpecifierMissing { get; }
    internal static string IdTokenTypeExpected { get; }
    internal static string IllegalElementType { get; }
    internal static string IllegalLayoutMask { get; }
    internal static string IncorrectElementTypeValue { get; }
    internal static string InvalidCustomAttributeFormat { get; }
    internal static string InvalidCustomAttributeFormatForEnum { get; }
    internal static string InvalidElementTypeInAttribute { get; }
    internal static string InvalidFileFormat { get; }
    internal static string InvalidFileName { get; }
    internal static string InvalidMetadata { get; }
    internal static string InvalidMetadataSignature { get; }
    internal static string InvalidMetadataToken { get; }
    internal static string InvalidPublicKeyTokenLength { get; }
    internal static string JaggedArrayInAttributeNotSupported { get; }
    internal static string ManifestModuleMustBeProvided { get; }
    internal static string MethodIsUsingUnsupportedBindingFlags { get; }
    internal static string MethodTokenExpected { get; }
    internal static string NoAssemblyManifest { get; }
    internal static string OperationInvalidOnAutoLayoutFields { get; }
    internal static string OperationValidOnArrayTypeOnly { get; }
    internal static string OperationValidOnEnumOnly { get; }
    internal static string OperationValidOnLiteralFieldsOnly { get; }
    internal static string OperationValidOnRVAFieldsOnly { get; }
    internal static string ResolvedAssemblyMustBeWithinSameUniverse { get; }
    internal static string ResolverMustResolveToValidAssembly { get; }
    internal static string ResolverMustResolveToValidModule { get; }
    internal static string ResolverMustSetAssemblyProperty { get; }
    internal static string RVAUnsupported { get; }
    internal static string TypeArgumentCannotBeResolved { get; }
    internal static string TypeTokenExpected { get; }
    internal static string UnexpectedCharacterFound { get; }
    internal static string UnexpectedEndOfInput { get; }
    internal static string UniverseCannotResolveAssembly { get; }
    internal static string UnrecognizedAssemblyAttribute { get; }
    internal static string UnsupportedExceptionFlags { get; }
    internal static string UnsupportedImageType { get; }
    internal static string UnsupportedTypeInAttributeSignature { get; }
    internal static string ValidOnGenericParameterTypeOnly { get; }
    internal static string VarargSignaturesNotImplemented { get; }
    internal static string VersionAlreadyDefined { get; }
    internal static string WindowsRuntimeTypeNotFound { get; }
    internal static string WrongNumberOfGenericArguments { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArrayInsideArrayInAttributeNotSupported();
    internal static string get_AssemblyRefTokenExpected();
    internal static string get_CannotDetermineSystemAssembly();
    internal static string get_CannotFindTypeInModule();
    internal static string get_CannotResolveModuleRefOnNetModule();
    internal static string get_CannotResolveRVA();
    internal static string get_CaseInsensitiveTypeLookupNotImplemented();
    internal static string get_CorruptImage();
    internal static string get_DefaultTokenResolverRequired();
    internal static string get_DifferentTokenResolverForOuterType();
    internal static string get_EscapeSequenceMissingCharacter();
    internal static string get_ExpectedPositiveNumberOfGenericParameters();
    internal static string get_ExpectedPropertyOrFieldId();
    internal static string get_ExpectedTokenType();
    internal static string get_ExtraAssemblyManifest();
    internal static string get_ExtraCharactersAfterTypeName();
    internal static string get_ExtraInformationAfterLastParameter();
    internal static string get_HostSpecifierMissing();
    internal static string get_IdTokenTypeExpected();
    internal static string get_IllegalElementType();
    internal static string get_IllegalLayoutMask();
    internal static string get_IncorrectElementTypeValue();
    internal static string get_InvalidCustomAttributeFormat();
    internal static string get_InvalidCustomAttributeFormatForEnum();
    internal static string get_InvalidElementTypeInAttribute();
    internal static string get_InvalidFileFormat();
    internal static string get_InvalidFileName();
    internal static string get_InvalidMetadata();
    internal static string get_InvalidMetadataSignature();
    internal static string get_InvalidMetadataToken();
    internal static string get_InvalidPublicKeyTokenLength();
    internal static string get_JaggedArrayInAttributeNotSupported();
    internal static string get_ManifestModuleMustBeProvided();
    internal static string get_MethodIsUsingUnsupportedBindingFlags();
    internal static string get_MethodTokenExpected();
    internal static string get_NoAssemblyManifest();
    internal static string get_OperationInvalidOnAutoLayoutFields();
    internal static string get_OperationValidOnArrayTypeOnly();
    internal static string get_OperationValidOnEnumOnly();
    internal static string get_OperationValidOnLiteralFieldsOnly();
    internal static string get_OperationValidOnRVAFieldsOnly();
    internal static string get_ResolvedAssemblyMustBeWithinSameUniverse();
    internal static string get_ResolverMustResolveToValidAssembly();
    internal static string get_ResolverMustResolveToValidModule();
    internal static string get_ResolverMustSetAssemblyProperty();
    internal static string get_RVAUnsupported();
    internal static string get_TypeArgumentCannotBeResolved();
    internal static string get_TypeTokenExpected();
    internal static string get_UnexpectedCharacterFound();
    internal static string get_UnexpectedEndOfInput();
    internal static string get_UniverseCannotResolveAssembly();
    internal static string get_UnrecognizedAssemblyAttribute();
    internal static string get_UnsupportedExceptionFlags();
    internal static string get_UnsupportedImageType();
    internal static string get_UnsupportedTypeInAttributeSignature();
    internal static string get_ValidOnGenericParameterTypeOnly();
    internal static string get_VarargSignaturesNotImplemented();
    internal static string get_VersionAlreadyDefined();
    internal static string get_WindowsRuntimeTypeNotFound();
    internal static string get_WrongNumberOfGenericArguments();
}
internal class System.Reflection.Adds.SimpleUniverse : object {
    private Dictionary`2<string, Type> m_hash;
    private List`1<Assembly> m_loadedAssemblies;
    private Assembly m_systemAssembly;
    [CompilerGeneratedAttribute]
private EventHandler`1<ResolveAssemblyNameEventArgs> OnResolveEvent;
    public IEnumerable`1<Assembly> Assemblies { get; }
    private bool IsAssemblyInList(Assembly assembly);
    public IEnumerable`1<Assembly> get_Assemblies();
    public sealed virtual void AddAssembly(Assembly assembly);
    public void SetSystemAssembly(Assembly systemAssembly);
    [CompilerGeneratedAttribute]
public void add_OnResolveEvent(EventHandler`1<ResolveAssemblyNameEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnResolveEvent(EventHandler`1<ResolveAssemblyNameEventArgs> value);
    public virtual Type GetBuiltInType(CorElementType elementType);
    public virtual Type GetTypeXFromName(string fullName);
    public virtual Assembly GetSystemAssembly();
    public virtual Assembly GetSystemRuntimeAssembly();
    protected Assembly FindSystemAssembly();
    public virtual Assembly ResolveAssembly(AssemblyName name);
    public virtual Assembly ResolveAssembly(AssemblyName name, bool throwOnError);
    public virtual Assembly ResolveAssembly(Module scope, Token tokenAssemblyRef);
    public virtual Module ResolveModule(Assembly containingAssembly, string moduleName);
    public virtual bool WouldResolveToAssembly(AssemblyName name, Assembly assembly);
    public sealed virtual Type ResolveWindowsRuntimeType(string typeName, bool throwOnError, bool ignoreCase);
    protected Assembly TryResolveAssembly(AssemblyName name);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class System.Reflection.Adds.Token : ValueType {
    public static Token Nil;
    private int value;
    public int Value { get; }
    public TokenType TokenType { get; }
    public int Index { get; }
    public bool IsNil { get; }
    [DebuggerStepThroughAttribute]
public Token(int value);
    public Token(TokenType type, int rid);
    [DebuggerStepThroughAttribute]
public Token(UInt32 value);
    private static Token();
    public int get_Value();
    public TokenType get_TokenType();
    public int get_Index();
    public bool get_IsNil();
    public static int op_Implicit(Token token);
    public static bool op_Equality(Token token1, Token token2);
    public static bool op_Inequality(Token token1, Token token2);
    public static bool op_Equality(Token token1, int token2);
    public static bool op_Inequality(Token token1, int token2);
    public static bool op_Equality(int token1, Token token2);
    public static bool op_Inequality(int token1, Token token2);
    public static bool IsType(int token, TokenType[] types);
    public bool IsType(TokenType type);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal enum System.Reflection.Adds.TokenType : Enum {
    public int value__;
    public static TokenType Module;
    public static TokenType TypeRef;
    public static TokenType TypeDef;
    public static TokenType FieldDef;
    public static TokenType MethodDef;
    public static TokenType ParamDef;
    public static TokenType InterfaceImpl;
    public static TokenType MemberRef;
    public static TokenType CustomAttribute;
    public static TokenType Permission;
    public static TokenType Signature;
    public static TokenType Event;
    public static TokenType Property;
    public static TokenType ModuleRef;
    public static TokenType TypeSpec;
    public static TokenType Assembly;
    public static TokenType AssemblyRef;
    public static TokenType File;
    public static TokenType ExportedType;
    public static TokenType ManifestResource;
    public static TokenType GenericPar;
    public static TokenType MethodSpec;
    public static TokenType String;
    public static TokenType Name;
    public static TokenType BaseType;
    public static TokenType Invalid;
}
internal static class System.Reflection.Adds.TypeNameParser : object {
    private static Char[] compoundTypeNameCharacters;
    private static TypeNameParser();
    public static Type ParseTypeName(ITypeUniverse universe, Module module, string input);
    public static Type ParseTypeName(ITypeUniverse universe, Module module, string input, bool throwOnError);
    public static Type ParseTypeName(ITypeUniverse universe, Module module, string input, bool useSystemAssemblyToResolveTypes, bool useWindowsRuntimeResolution, bool throwOnError);
    private static Type ParseTypeName(ITypeUniverse universe, Module defaultTokenResolver, string input, Int32& idx, bool throwOnError, bool isGenericArgument, bool expectAssemblyName);
    private static bool IsGenericType(string input, int idx);
    private static Type ReadModifiers(Type type, string input, Int32& idx);
    private static AssemblyName ParseAssemblyInfo(string input, Int32& idx);
    private static Assembly DetermineAssembly(AssemblyName assemblyName, Module defaultTokenResolver, ITypeUniverse universe, bool throwOnError);
    private static Type Resolve(List`1<string> path, List`1<Type> genericTypeArgs, Assembly assembly);
    private static void ReadSpecialToken(string input, TokenType expected, Int32& idx);
    private static string ReadIdToken(string input, Int32& idx);
    private static string ReadIdWithoutLeadingSpaces(string input, Int32& idx);
    private static string ReadIdWithoutLeadingAndEndingSpaces(string input, Int32& idx);
    private static TokenType PeekNextToken(string input, int idx);
    private static TokenType PeekSecondToken(string input, int idx);
    private static Token ReadToken(string input, Int32& idx);
    private static string TrimLeadingSpaces(string str);
    public static bool IsCompoundType(string name);
}
internal class System.Reflection.Adds.UnresolvedAssemblyException : Exception {
    public UnresolvedAssemblyException(string message);
    public UnresolvedAssemblyException(string message, Exception innerException);
    protected UnresolvedAssemblyException(SerializationInfo info, StreamingContext context);
}
[ObsoleteAttribute("This is not used by the XAML parser. Please look at XamlSetMarkupExtensionAttribute.")]
[AttributeUsageAttribute("4")]
public class System.Windows.Markup.AcceptedMarkupExtensionExpressionTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; public set; }
    public AcceptedMarkupExtensionExpressionTypeAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
}
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[AttributeUsageAttribute("196")]
public class System.Windows.Markup.AmbientAttribute : Attribute {
}
[TypeForwardedFromAttribute("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[ContentPropertyAttribute("Items")]
[MarkupExtensionReturnTypeAttribute("System.Array")]
public class System.Windows.Markup.ArrayExtension : MarkupExtension {
    private ArrayList _arrayList;
    private Type _arrayType;
    [ConstructorArgumentAttribute("type")]
public Type Type { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public IList Items { get; }
    public ArrayExtension(Type arrayType);
    public ArrayExtension(Array elements);
    public void AddChild(object value);
    public void AddText(string text);
    public Type get_Type();
    public void set_Type(Type value);
    public IList get_Items();
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[AttributeUsageAttribute("128")]
public class System.Windows.Markup.ConstructorArgumentAttribute : Attribute {
    private string _argumentName;
    public string ArgumentName { get; }
    public ConstructorArgumentAttribute(string argumentName);
    public string get_ArgumentName();
}
[AttributeUsageAttribute("4")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.ContentPropertyAttribute : Attribute {
    private string _name;
    public string Name { get; }
    public ContentPropertyAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("4")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.ContentWrapperAttribute : Attribute {
    private Type _contentWrapper;
    public Type ContentWrapper { get; }
    public object TypeId { get; }
    public ContentWrapperAttribute(Type contentWrapper);
    public Type get_ContentWrapper();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Windows.Markup.DateTimeOffsetConverter2 : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    [SecuritySafeCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.DateTimeValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[AttributeUsageAttribute("192")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.DependsOnAttribute : Attribute {
    private string _name;
    public object TypeId { get; }
    public string Name { get; }
    public DependsOnAttribute(string name);
    public virtual object get_TypeId();
    public string get_Name();
}
[AttributeUsageAttribute("4")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.DictionaryKeyPropertyAttribute : Attribute {
    private string _name;
    public string Name { get; }
    public DictionaryKeyPropertyAttribute(string name);
    public string get_Name();
}
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Windows.Markup.IComponentConnector {
    public abstract virtual void Connect(int connectionId, object target);
    public abstract virtual void InitializeComponent();
}
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Windows.Markup.INameScope {
    public abstract virtual void RegisterName(string name, object scopedElement);
    public abstract virtual void UnregisterName(string name);
    public abstract virtual object FindName(string name);
}
public interface System.Windows.Markup.INameScopeDictionary {
}
[TypeForwardedFromAttribute("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Windows.Markup.IProvideValueTarget {
    public object TargetObject { get; }
    public object TargetProperty { get; }
    public abstract virtual object get_TargetObject();
    public abstract virtual object get_TargetProperty();
}
public interface System.Windows.Markup.IQueryAmbient {
    public abstract virtual bool IsAmbientPropertyAvailable(string propertyName);
}
[TypeForwardedFromAttribute("PresentationCore, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Windows.Markup.IUriContext {
    public Uri BaseUri { get; public set; }
    public abstract virtual Uri get_BaseUri();
    public abstract virtual void set_BaseUri(Uri value);
}
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Windows.Markup.IValueSerializerContext {
    public abstract virtual ValueSerializer GetValueSerializerFor(Type type);
    public abstract virtual ValueSerializer GetValueSerializerFor(PropertyDescriptor descriptor);
}
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Windows.Markup.IXamlTypeResolver {
    public abstract virtual Type Resolve(string qualifiedTypeName);
}
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public abstract class System.Windows.Markup.MarkupExtension : object {
    public abstract virtual object ProvideValue(IServiceProvider serviceProvider);
}
[AttributeUsageAttribute("128")]
public class System.Windows.Markup.MarkupExtensionBracketCharactersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private char <OpeningBracket>k__BackingField;
    [CompilerGeneratedAttribute]
private char <ClosingBracket>k__BackingField;
    public char OpeningBracket { get; }
    public char ClosingBracket { get; }
    public MarkupExtensionBracketCharactersAttribute(char openingBracket, char closingBracket);
    [CompilerGeneratedAttribute]
public char get_OpeningBracket();
    [CompilerGeneratedAttribute]
public char get_ClosingBracket();
}
[AttributeUsageAttribute("4")]
public class System.Windows.Markup.MarkupExtensionReturnTypeAttribute : Attribute {
    private Type _returnType;
    private Type _expressionType;
    public Type ReturnType { get; }
    [ObsoleteAttribute("This is not used by the XAML parser. Please look at XamlSetMarkupExtensionAttribute.")]
public Type ExpressionType { get; }
    public MarkupExtensionReturnTypeAttribute(Type returnType);
    [ObsoleteAttribute("The expressionType argument is not used by the XAML parser. To specify the expected return type, use MarkupExtensionReturnTypeAttribute(Type). To specify custom handling for expression types, use XamlSetMarkupExtensionAttribute.")]
public MarkupExtensionReturnTypeAttribute(Type returnType, Type expressionType);
    public Type get_ReturnType();
    public Type get_ExpressionType();
}
public abstract class System.Windows.Markup.MemberDefinition : object {
    public string Name { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
public class System.Windows.Markup.NameReferenceConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[AttributeUsageAttribute("4")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.NameScopePropertyAttribute : Attribute {
    private string _name;
    private Type _type;
    public string Name { get; }
    public Type Type { get; }
    public NameScopePropertyAttribute(string name);
    public NameScopePropertyAttribute(string name, Type type);
    public string get_Name();
    public Type get_Type();
}
[TypeForwardedFromAttribute("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[MarkupExtensionReturnTypeAttribute("System.Object")]
public class System.Windows.Markup.NullExtension : MarkupExtension {
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
public class System.Windows.Markup.PropertyDefinition : MemberDefinition {
    private IList`1<Attribute> attributes;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Modifier>k__BackingField;
    public string Name { get; public set; }
    [TypeConverterAttribute("System.Xaml.Schema.XamlTypeTypeConverter")]
public XamlType Type { get; public set; }
    [DefaultValueAttribute("")]
public string Modifier { get; public set; }
    public IList`1<Attribute> Attributes { get; }
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public XamlType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(XamlType value);
    [CompilerGeneratedAttribute]
public string get_Modifier();
    [CompilerGeneratedAttribute]
public void set_Modifier(string value);
    public IList`1<Attribute> get_Attributes();
}
[ContentPropertyAttribute("Name")]
public class System.Windows.Markup.Reference : MarkupExtension {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [ConstructorArgumentAttribute("name")]
public string Name { get; public set; }
    public Reference(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
[AttributeUsageAttribute("1")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.RootNamespaceAttribute : Attribute {
    private string _nameSpace;
    public string Namespace { get; }
    public RootNamespaceAttribute(string nameSpace);
    public string get_Namespace();
}
[AttributeUsageAttribute("4")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.RuntimeNamePropertyAttribute : Attribute {
    private string _name;
    public string Name { get; }
    public RuntimeNamePropertyAttribute(string name);
    public string get_Name();
}
[TypeForwardedFromAttribute("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[TypeConverterAttribute("System.Windows.Markup.StaticExtensionConverter")]
[MarkupExtensionReturnTypeAttribute("System.Object")]
public class System.Windows.Markup.StaticExtension : MarkupExtension {
    private string _member;
    private Type _memberType;
    [ConstructorArgumentAttribute("member")]
public string Member { get; public set; }
    [DefaultValueAttribute("")]
public Type MemberType { get; public set; }
    public StaticExtension(string member);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    private bool GetFieldOrPropertyValue(Type type, string name, Object& value);
    public string get_Member();
    public void set_Member(string value);
    public Type get_MemberType();
    public void set_MemberType(Type value);
}
internal class System.Windows.Markup.StaticExtensionConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[AttributeUsageAttribute("4")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.TrimSurroundingWhitespaceAttribute : Attribute {
}
[TypeForwardedFromAttribute("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[TypeConverterAttribute("System.Windows.Markup.TypeExtensionConverter")]
[MarkupExtensionReturnTypeAttribute("System.Type")]
public class System.Windows.Markup.TypeExtension : MarkupExtension {
    private string _typeName;
    private Type _type;
    [DesignerSerializationVisibilityAttribute("0")]
public string TypeName { get; public set; }
    [DefaultValueAttribute("")]
[ConstructorArgumentAttribute("type")]
public Type Type { get; public set; }
    public TypeExtension(string typeName);
    public TypeExtension(Type type);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    public string get_TypeName();
    public void set_TypeName(string value);
    public Type get_Type();
    public void set_Type(Type value);
}
internal class System.Windows.Markup.TypeExtensionConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[AttributeUsageAttribute("4")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.UidPropertyAttribute : Attribute {
    private string _name;
    public string Name { get; }
    public UidPropertyAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("4")]
public class System.Windows.Markup.UsableDuringInitializationAttribute : Attribute {
    private bool _usable;
    public bool Usable { get; }
    public UsableDuringInitializationAttribute(bool usable);
    public bool get_Usable();
}
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public abstract class System.Windows.Markup.ValueSerializer : object {
    private static List`1<Type> Empty;
    private static object _valueSerializersLock;
    private static Hashtable _valueSerializers;
    private static ValueSerializer();
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual IEnumerable`1<Type> TypeReferences(object value, IValueSerializerContext context);
    public static ValueSerializer GetSerializerFor(Type type);
    public static ValueSerializer GetSerializerFor(PropertyDescriptor descriptor);
    public static ValueSerializer GetSerializerFor(Type type, IValueSerializerContext context);
    public static ValueSerializer GetSerializerFor(PropertyDescriptor descriptor, IValueSerializerContext context);
    protected Exception GetConvertToException(object value, Type destinationType);
    protected Exception GetConvertFromException(object value);
    private static void TypeDescriptorRefreshed(RefreshEventArgs args);
}
[AttributeUsageAttribute("4")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.WhitespaceSignificantCollectionAttribute : Attribute {
}
[AttributeUsageAttribute("132")]
public class System.Windows.Markup.XamlDeferLoadAttribute : Attribute {
    private string _contentTypeName;
    private string _loaderTypeName;
    [CompilerGeneratedAttribute]
private Type <LoaderType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ContentType>k__BackingField;
    public string LoaderTypeName { get; }
    public string ContentTypeName { get; }
    public Type LoaderType { get; private set; }
    public Type ContentType { get; private set; }
    public XamlDeferLoadAttribute(Type loaderType, Type contentType);
    public XamlDeferLoadAttribute(string loaderType, string contentType);
    public string get_LoaderTypeName();
    public string get_ContentTypeName();
    [CompilerGeneratedAttribute]
public Type get_LoaderType();
    [CompilerGeneratedAttribute]
private void set_LoaderType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ContentType();
    [CompilerGeneratedAttribute]
private void set_ContentType(Type value);
}
[AttributeUsageAttribute("4")]
public class System.Windows.Markup.XamlSetMarkupExtensionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <XamlSetMarkupExtensionHandler>k__BackingField;
    public string XamlSetMarkupExtensionHandler { get; private set; }
    public XamlSetMarkupExtensionAttribute(string xamlSetMarkupExtensionHandler);
    [CompilerGeneratedAttribute]
public string get_XamlSetMarkupExtensionHandler();
    [CompilerGeneratedAttribute]
private void set_XamlSetMarkupExtensionHandler(string value);
}
public class System.Windows.Markup.XamlSetMarkupExtensionEventArgs : XamlSetValueEventArgs {
    [CompilerGeneratedAttribute]
private IServiceProvider <ServiceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <CurrentType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TargetObject>k__BackingField;
    public MarkupExtension MarkupExtension { get; }
    public IServiceProvider ServiceProvider { get; private set; }
    internal XamlType CurrentType { get; internal set; }
    internal object TargetObject { get; private set; }
    public XamlSetMarkupExtensionEventArgs(XamlMember member, MarkupExtension value, IServiceProvider serviceProvider);
    internal XamlSetMarkupExtensionEventArgs(XamlMember member, MarkupExtension value, IServiceProvider serviceProvider, object targetObject);
    public MarkupExtension get_MarkupExtension();
    [CompilerGeneratedAttribute]
public IServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
private void set_ServiceProvider(IServiceProvider value);
    [CompilerGeneratedAttribute]
internal XamlType get_CurrentType();
    [CompilerGeneratedAttribute]
internal void set_CurrentType(XamlType value);
    [CompilerGeneratedAttribute]
internal object get_TargetObject();
    [CompilerGeneratedAttribute]
private void set_TargetObject(object value);
    public virtual void CallBase();
}
[AttributeUsageAttribute("4")]
public class System.Windows.Markup.XamlSetTypeConverterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <XamlSetTypeConverterHandler>k__BackingField;
    public string XamlSetTypeConverterHandler { get; private set; }
    public XamlSetTypeConverterAttribute(string xamlSetTypeConverterHandler);
    [CompilerGeneratedAttribute]
public string get_XamlSetTypeConverterHandler();
    [CompilerGeneratedAttribute]
private void set_XamlSetTypeConverterHandler(string value);
}
public class System.Windows.Markup.XamlSetTypeConverterEventArgs : XamlSetValueEventArgs {
    [CompilerGeneratedAttribute]
private TypeConverter <TypeConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeDescriptorContext <ServiceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <CultureInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TargetObject>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <CurrentType>k__BackingField;
    public TypeConverter TypeConverter { get; private set; }
    public ITypeDescriptorContext ServiceProvider { get; private set; }
    public CultureInfo CultureInfo { get; private set; }
    internal object TargetObject { get; private set; }
    internal XamlType CurrentType { get; internal set; }
    public XamlSetTypeConverterEventArgs(XamlMember member, TypeConverter typeConverter, object value, ITypeDescriptorContext serviceProvider, CultureInfo cultureInfo);
    internal XamlSetTypeConverterEventArgs(XamlMember member, TypeConverter typeConverter, object value, ITypeDescriptorContext serviceProvider, CultureInfo cultureInfo, object targetObject);
    [CompilerGeneratedAttribute]
public TypeConverter get_TypeConverter();
    [CompilerGeneratedAttribute]
private void set_TypeConverter(TypeConverter value);
    [CompilerGeneratedAttribute]
public ITypeDescriptorContext get_ServiceProvider();
    [CompilerGeneratedAttribute]
private void set_ServiceProvider(ITypeDescriptorContext value);
    [CompilerGeneratedAttribute]
public CultureInfo get_CultureInfo();
    [CompilerGeneratedAttribute]
private void set_CultureInfo(CultureInfo value);
    [CompilerGeneratedAttribute]
internal object get_TargetObject();
    [CompilerGeneratedAttribute]
private void set_TargetObject(object value);
    [CompilerGeneratedAttribute]
internal XamlType get_CurrentType();
    [CompilerGeneratedAttribute]
internal void set_CurrentType(XamlType value);
    public virtual void CallBase();
}
public class System.Windows.Markup.XamlSetValueEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private XamlMember <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    public XamlMember Member { get; private set; }
    public object Value { get; private set; }
    public bool Handled { get; public set; }
    public XamlSetValueEventArgs(XamlMember member, object value);
    [CompilerGeneratedAttribute]
public XamlMember get_Member();
    [CompilerGeneratedAttribute]
private void set_Member(XamlMember value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
    public virtual void CallBase();
}
[ContentPropertyAttribute("Text")]
public class System.Windows.Markup.XData : object {
    private XmlReader _reader;
    private string _text;
    public string Text { get; public set; }
    public object XmlReader { get; public set; }
    public string get_Text();
    public void set_Text(string value);
    public object get_XmlReader();
    public void set_XmlReader(object value);
}
[AttributeUsageAttribute("4")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.XmlLangPropertyAttribute : Attribute {
    private string _name;
    public string Name { get; }
    public XmlLangPropertyAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("1")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.XmlnsCompatibleWithAttribute : Attribute {
    private string _oldNamespace;
    private string _newNamespace;
    public string OldNamespace { get; }
    public string NewNamespace { get; }
    public XmlnsCompatibleWithAttribute(string oldNamespace, string newNamespace);
    public string get_OldNamespace();
    public string get_NewNamespace();
}
[AttributeUsageAttribute("1")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.XmlnsDefinitionAttribute : Attribute {
    private string _xmlNamespace;
    private string _clrNamespace;
    private string _assemblyName;
    public string XmlNamespace { get; }
    public string ClrNamespace { get; }
    public string AssemblyName { get; public set; }
    public XmlnsDefinitionAttribute(string xmlNamespace, string clrNamespace);
    public string get_XmlNamespace();
    public string get_ClrNamespace();
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
}
[AttributeUsageAttribute("1")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.XmlnsPrefixAttribute : Attribute {
    private string _xmlNamespace;
    private string _prefix;
    public string XmlNamespace { get; }
    public string Prefix { get; }
    public XmlnsPrefixAttribute(string xmlNamespace, string prefix);
    public string get_XmlNamespace();
    public string get_Prefix();
}
public class System.Xaml.AmbientPropertyValue : object {
    private XamlMember _property;
    private object _value;
    public object Value { get; }
    public XamlMember RetrievedProperty { get; }
    public AmbientPropertyValue(XamlMember property, object value);
    public object get_Value();
    public XamlMember get_RetrievedProperty();
}
internal static class System.Xaml.ArrayHelper : object {
    internal static S[] ConvertArrayType(ICollection`1<R> src, Func`2<R, S> f);
    internal static void ForAll(R[] src, Action`1<R> f);
    internal static List`1<T> ToList(IEnumerable`1<T> src);
}
public class System.Xaml.AttachableMemberIdentifier : object {
    private Type declaringType;
    private string memberName;
    public string MemberName { get; }
    public Type DeclaringType { get; }
    public AttachableMemberIdentifier(Type declaringType, string memberName);
    public string get_MemberName();
    public Type get_DeclaringType();
    public static bool op_Inequality(AttachableMemberIdentifier left, AttachableMemberIdentifier right);
    public static bool op_Equality(AttachableMemberIdentifier left, AttachableMemberIdentifier right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AttachableMemberIdentifier other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class System.Xaml.AttachablePropertyServices : object {
    private static DefaultAttachedPropertyStore attachedProperties;
    private static AttachablePropertyServices();
    public static int GetAttachedPropertyCount(object instance);
    public static void CopyPropertiesTo(object instance, KeyValuePair`2[] array, int index);
    public static bool RemoveProperty(object instance, AttachableMemberIdentifier name);
    public static void SetProperty(object instance, AttachableMemberIdentifier name, object value);
    public static bool TryGetProperty(object instance, AttachableMemberIdentifier name, Object& value);
    public static bool TryGetProperty(object instance, AttachableMemberIdentifier name, T& value);
}
internal enum System.Xaml.BoolMemberBits : Enum {
    public int value__;
    public static BoolMemberBits ReadOnly;
    public static BoolMemberBits WriteOnly;
    public static BoolMemberBits Event;
    public static BoolMemberBits Unknown;
    public static BoolMemberBits Ambient;
    public static BoolMemberBits ReadPublic;
    public static BoolMemberBits WritePublic;
    public static BoolMemberBits Default;
    public static BoolMemberBits Directive;
    public static BoolMemberBits AllValid;
}
[FlagsAttribute]
internal enum System.Xaml.BoolTypeBits : Enum {
    public int value__;
    public static BoolTypeBits Constructible;
    public static BoolTypeBits XmlData;
    public static BoolTypeBits MarkupExtension;
    public static BoolTypeBits Nullable;
    public static BoolTypeBits NameScope;
    public static BoolTypeBits ConstructionRequiresArguments;
    public static BoolTypeBits Public;
    public static BoolTypeBits Unknown;
    public static BoolTypeBits TrimSurroundingWhitespace;
    public static BoolTypeBits WhitespaceSignificantCollection;
    public static BoolTypeBits UsableDuringInitialization;
    public static BoolTypeBits Ambient;
    public static BoolTypeBits Default;
    public static BoolTypeBits AllValid;
}
internal class System.Xaml.Context.HashSet`1 : Dictionary`2<T, object> {
    public HashSet`1(IDictionary`2<T, object> other);
    public HashSet`1(IEqualityComparer`1<T> comparer);
    public void Add(T item);
}
internal static class System.Xaml.CriticalExceptions : object {
    internal static bool IsCriticalException(Exception ex);
    internal static Exception Unwrap(Exception ex);
}
internal enum System.Xaml.DeferringMode : Enum {
    public int value__;
    public static DeferringMode Off;
    public static DeferringMode TemplateStarting;
    public static DeferringMode TemplateDeferring;
    public static DeferringMode TemplateReady;
}
internal class System.Xaml.DeferringWriter : XamlWriter {
    private DeferringMode _mode;
    private bool _handled;
    private ObjectWriterContext _context;
    private XamlNodeList _deferredList;
    private XamlWriter _deferredWriter;
    private int _deferredTreeDepth;
    public bool Handled { get; }
    public DeferringMode Mode { get; }
    public XamlSchemaContext SchemaContext { get; }
    public bool ShouldProvideLineInfo { get; }
    public DeferringWriter(ObjectWriterContext context);
    public void Clear();
    public bool get_Handled();
    public DeferringMode get_Mode();
    public XamlNodeList CollectTemplateList();
    public virtual void WriteGetObject();
    public virtual void WriteStartObject(XamlType xamlType);
    private void WriteObject(XamlType xamlType, bool fromMember, string methodName);
    public virtual void WriteEndObject();
    public virtual void WriteStartMember(XamlMember property);
    public virtual void WriteEndMember();
    public virtual void WriteValue(object value);
    public virtual void WriteNamespace(NamespaceDeclaration namespaceDeclaration);
    protected virtual void Dispose(bool disposing);
    public virtual XamlSchemaContext get_SchemaContext();
    public sealed virtual void SetLineInfo(int lineNumber, int linePosition);
    public sealed virtual bool get_ShouldProvideLineInfo();
    private void StartDeferredList();
}
internal class System.Xaml.EventConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    internal static void GetRootObjectAndDelegateType(ITypeDescriptorContext context, Object& rootObject, Type& delegateType);
}
internal class System.Xaml.GCNotificationToken : object {
    private WaitCallback callback;
    private object state;
    private GCNotificationToken(WaitCallback callback, object state);
    protected virtual override void Finalize();
    internal static void RegisterCallback(WaitCallback callback, object state);
}
internal class System.Xaml.HandleAttributeCallback : MulticastDelegate {
    public HandleAttributeCallback(object object, IntPtr method);
    public virtual void Invoke(int elementDepth);
    public virtual IAsyncResult BeginInvoke(int elementDepth, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Xaml.HandleElementCallback : MulticastDelegate {
    public HandleElementCallback(object object, IntPtr method);
    public virtual void Invoke(int elementDepth, Boolean& more);
    public virtual IAsyncResult BeginInvoke(int elementDepth, Boolean& more, AsyncCallback callback, object object);
    public virtual void EndInvoke(Boolean& more, IAsyncResult result);
}
public interface System.Xaml.IAmbientProvider {
    public abstract virtual AmbientPropertyValue GetFirstAmbientValue(IEnumerable`1<XamlType> ceilingTypes, XamlMember[] properties);
    public abstract virtual object GetFirstAmbientValue(XamlType[] types);
    public abstract virtual IEnumerable`1<AmbientPropertyValue> GetAllAmbientValues(IEnumerable`1<XamlType> ceilingTypes, XamlMember[] properties);
    public abstract virtual IEnumerable`1<object> GetAllAmbientValues(XamlType[] types);
    public abstract virtual IEnumerable`1<AmbientPropertyValue> GetAllAmbientValues(IEnumerable`1<XamlType> ceilingTypes, bool searchLiveStackOnly, IEnumerable`1<XamlType> types, XamlMember[] properties);
}
public interface System.Xaml.IAttachedPropertyStore {
    public int PropertyCount { get; }
    public abstract virtual int get_PropertyCount();
    public abstract virtual void CopyPropertiesTo(KeyValuePair`2[] array, int index);
    public abstract virtual bool RemoveProperty(AttachableMemberIdentifier attachableMemberIdentifier);
    public abstract virtual void SetProperty(AttachableMemberIdentifier attachableMemberIdentifier, object value);
    public abstract virtual bool TryGetProperty(AttachableMemberIdentifier attachableMemberIdentifier, Object& value);
}
public interface System.Xaml.IDestinationTypeProvider {
    public abstract virtual Type GetDestinationType();
}
public interface System.Xaml.INamespacePrefixLookup {
    public abstract virtual string LookupPrefix(string ns);
}
public interface System.Xaml.IRootObjectProvider {
    public object RootObject { get; }
    public abstract virtual object get_RootObject();
}
internal class System.Xaml.IsXmlNamespaceSupportedCallback : MulticastDelegate {
    public IsXmlNamespaceSupportedCallback(object object, IntPtr method);
    public virtual bool Invoke(string xmlNamespace, String& newXmlNamespace);
    public virtual IAsyncResult BeginInvoke(string xmlNamespace, String& newXmlNamespace, AsyncCallback callback, object object);
    public virtual bool EndInvoke(String& newXmlNamespace, IAsyncResult result);
}
public interface System.Xaml.IXamlIndexingReader {
    public int Count { get; }
    public int CurrentIndex { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual int get_CurrentIndex();
    public abstract virtual void set_CurrentIndex(int value);
}
public interface System.Xaml.IXamlLineInfo {
    public bool HasLineInfo { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public abstract virtual bool get_HasLineInfo();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_LinePosition();
}
public interface System.Xaml.IXamlLineInfoConsumer {
    public bool ShouldProvideLineInfo { get; }
    public abstract virtual void SetLineInfo(int lineNumber, int linePosition);
    public abstract virtual bool get_ShouldProvideLineInfo();
}
public interface System.Xaml.IXamlNameProvider {
    public abstract virtual string GetName(object value);
}
public interface System.Xaml.IXamlNameResolver {
    public bool IsFixupTokenAvailable { get; }
    public abstract virtual bool get_IsFixupTokenAvailable();
    public abstract virtual object Resolve(string name);
    public abstract virtual object Resolve(string name, Boolean& isFullyInitialized);
    public abstract virtual object GetFixupToken(IEnumerable`1<string> names);
    public abstract virtual object GetFixupToken(IEnumerable`1<string> names, bool canAssignDirectly);
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, object>> GetAllNamesAndValuesInScope();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnNameScopeInitializationComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnNameScopeInitializationComplete(EventHandler value);
}
public interface System.Xaml.IXamlNamespaceResolver {
    public abstract virtual string GetNamespace(string prefix);
    public abstract virtual IEnumerable`1<NamespaceDeclaration> GetNamespacePrefixes();
}
public interface System.Xaml.IXamlObjectWriterFactory {
    public abstract virtual XamlObjectWriterSettings GetParentSettings();
    public abstract virtual XamlObjectWriter GetXamlObjectWriter(XamlObjectWriterSettings settings);
}
public interface System.Xaml.IXamlSchemaContextProvider {
    public XamlSchemaContext SchemaContext { get; }
    public abstract virtual XamlSchemaContext get_SchemaContext();
}
internal class System.Xaml.LineInfo : object {
    private int _lineNumber;
    private int _linePosition;
    public int LineNumber { get; }
    public int LinePosition { get; }
    internal LineInfo(int lineNumber, int linePosition);
    public int get_LineNumber();
    public int get_LinePosition();
}
internal static class System.Xaml.LooseTypeExtensions : object {
    private static string WindowsBase;
    private static Byte[] WindowsBaseToken;
    private static LooseTypeExtensions();
    internal static bool AssemblyQualifiedNameEquals(Type t1, Type t2);
    private static bool IsWindowsBaseToSystemXamlComparison(Assembly a1, Assembly a2, AssemblyName name1, AssemblyName name2);
    internal static bool IsAssemblyQualifiedNameAssignableFrom(Type t1, Type t2);
    private static bool LooselyImplementInterface(Type t, Type interfaceType);
    private static bool IsLooseSubClassOf(Type t1, Type t2);
}
internal class System.Xaml.MS.Impl.ArrayItemList`1 : FrugalListBase`1<T> {
    private static int MINSIZE;
    private static int GROWTH;
    private static int LARGEGROWTH;
    private T[] _entries;
    public int Capacity { get; }
    public ArrayItemList`1(int size);
    public ArrayItemList`1(ICollection collection);
    public ArrayItemList`1(ICollection`1<T> collection);
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SixItemList`1<T> oldList);
    public void Promote(ArrayItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
    public virtual Compacter<T> NewCompacter(int newCount);
}
[DebuggerDisplayAttribute("{ClrNamespace} {Assembly.FullName}")]
internal class System.Xaml.MS.Impl.AssemblyNamespacePair : object {
    private WeakReference _assembly;
    private string _clrNamespace;
    public Assembly Assembly { get; }
    public string ClrNamespace { get; }
    public AssemblyNamespacePair(Assembly asm, string clrNamespace);
    public Assembly get_Assembly();
    public string get_ClrNamespace();
}
internal abstract class System.Xaml.MS.Impl.FrugalListBase`1 : object {
    protected int _count;
    public int Count { get; }
    public int Capacity { get; }
    public int get_Count();
    internal void TrustedSetCount(int newCount);
    public abstract virtual int get_Capacity();
    public abstract virtual FrugalListStoreState Add(T value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T value);
    public abstract virtual int IndexOf(T value);
    public abstract virtual void Insert(int index, T value);
    public abstract virtual void SetAt(int index, T value);
    public abstract virtual bool Remove(T value);
    public abstract virtual void RemoveAt(int index);
    public abstract virtual T EntryAt(int index);
    public abstract virtual void Promote(FrugalListBase`1<T> newList);
    public abstract virtual T[] ToArray();
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual object Clone();
    public virtual Compacter<T> NewCompacter(int newCount);
}
internal enum System.Xaml.MS.Impl.FrugalListStoreState : Enum {
    public int value__;
    public static FrugalListStoreState Success;
    public static FrugalListStoreState SingleItemList;
    public static FrugalListStoreState ThreeItemList;
    public static FrugalListStoreState SixItemList;
    public static FrugalListStoreState Array;
}
[DefaultMemberAttribute("Item")]
internal class System.Xaml.MS.Impl.FrugalObjectList`1 : object {
    internal FrugalListBase`1<T> _listStore;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public FrugalObjectList`1(int size);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int Add(T value);
    public void Clear();
    public bool Contains(T value);
    public int IndexOf(T value);
    public void Insert(int index, T value);
    public bool Remove(T value);
    public void RemoveAt(int index);
    public void EnsureIndex(int index);
    public T[] ToArray();
    public void CopyTo(T[] array, int index);
    public FrugalObjectList`1<T> Clone();
}
[DefaultMemberAttribute("Item")]
internal class System.Xaml.MS.Impl.FrugalStructList`1 : ValueType {
    internal FrugalListBase`1<T> _listStore;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public FrugalStructList`1(int size);
    public FrugalStructList`1(ICollection collection);
    public FrugalStructList`1(ICollection`1<T> collection);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int Add(T value);
    public void Clear();
    public bool Contains(T value);
    public int IndexOf(T value);
    public void Insert(int index, T value);
    public bool Remove(T value);
    public void RemoveAt(int index);
    public void EnsureIndex(int index);
    public T[] ToArray();
    public void CopyTo(T[] array, int index);
    public FrugalStructList`1<T> Clone();
}
internal static class System.Xaml.MS.Impl.KnownStrings : object {
    public static string XmlPrefix;
    public static string XmlNsPrefix;
    public static string Preserve;
    public static string Default;
    public static string UriClrNamespace;
    public static string UriAssembly;
    public static string StringType;
    public static string ObjectType;
    public static string Get;
    public static string Set;
    public static string Add;
    public static string Handler;
    public static string Extension;
    public static string IsReadOnly;
    public static string ShouldSerialize;
    public static string FrameworkElement;
    public static string TypeExtension;
    public static char GraveQuote;
    public static char NestedTypeDelimiter;
    public static string GetEnumerator;
    public static string ICollectionOfT;
    public static string IDictionary;
    public static string IDictionaryOfKT;
    public static string NullableOfT;
    public static string KeyValuePairOfTT;
    public static string AmbientPropertyAttribute;
    public static string DependencyPropertySuffix;
    public static string XpsNamespace;
    public static string LocalPrefix;
    public static string DefaultPrefix;
    public static string ReferenceName;
    public static Char[] WhitespaceChars;
    public static char SpaceChar;
    public static char TabChar;
    public static char NewlineChar;
    public static char ReturnChar;
    public static string ClrNamespaceFormat;
    public static string CreateDelegateHelper;
    public static string CreateDelegate;
    public static string InvokeMember;
    public static string GetTypeFromHandle;
    public static string Member;
    public static string Property;
    private static KnownStrings();
}
internal static class System.Xaml.MS.Impl.KS : object {
    public static bool Eq(string a, string b);
    public static int IndexOf(string src, string chars);
    public static bool EndsWith(string src, string target);
    public static bool StartsWith(string src, string target);
    public static string Fmt(string formatString, Object[] otherArgs);
}
internal class System.Xaml.MS.Impl.PositionalParameterDescriptor : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasText>k__BackingField;
    public object Value { get; public set; }
    public bool WasText { get; public set; }
    public PositionalParameterDescriptor(object value, bool wasText);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    [CompilerGeneratedAttribute]
public bool get_WasText();
    [CompilerGeneratedAttribute]
public void set_WasText(bool value);
}
internal class System.Xaml.MS.Impl.SingleItemList`1 : FrugalListBase`1<T> {
    private static int SIZE;
    private T _loneEntry;
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SingleItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
}
internal class System.Xaml.MS.Impl.SixItemList`1 : FrugalListBase`1<T> {
    private static int SIZE;
    private T _entry0;
    private T _entry1;
    private T _entry2;
    private T _entry3;
    private T _entry4;
    private T _entry5;
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(ThreeItemList`1<T> oldList);
    public void Promote(SixItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
}
internal class System.Xaml.MS.Impl.ThreeItemList`1 : FrugalListBase`1<T> {
    private static int SIZE;
    private T _entry0;
    private T _entry1;
    private T _entry2;
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SingleItemList`1<T> oldList);
    public void Promote(ThreeItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
}
internal class System.Xaml.MS.Impl.XmlNsInfo : object {
    private IList`1<XmlNsDefinition> _nsDefs;
    private ConcurrentDictionary`2<string, IList`1<string>> _clrToXmlNs;
    private ICollection`1<AssemblyName> _internalsVisibleTo;
    private Dictionary`2<string, string> _oldToNewNs;
    private Dictionary`2<string, string> _prefixes;
    private string _rootNamespace;
    private WeakReference _assembly;
    private IList`1<CustomAttributeData> _attributeData;
    private bool _fullyQualifyAssemblyName;
    internal Assembly Assembly { get; }
    internal IList`1<XmlNsDefinition> NsDefs { get; }
    internal ConcurrentDictionary`2<string, IList`1<string>> ClrToXmlNs { get; }
    internal ICollection`1<AssemblyName> InternalsVisibleTo { get; }
    internal Dictionary`2<string, string> OldToNewNs { get; }
    internal Dictionary`2<string, string> Prefixes { get; }
    internal string RootNamespace { get; }
    internal XmlNsInfo(Assembly assembly, bool fullyQualifyAssemblyName);
    internal Assembly get_Assembly();
    internal IList`1<XmlNsDefinition> get_NsDefs();
    internal ConcurrentDictionary`2<string, IList`1<string>> get_ClrToXmlNs();
    internal ICollection`1<AssemblyName> get_InternalsVisibleTo();
    internal Dictionary`2<string, string> get_OldToNewNs();
    internal Dictionary`2<string, string> get_Prefixes();
    internal string get_RootNamespace();
    private void EnsureReflectionOnlyAttributeData();
    internal static string GetPreferredPrefix(string prefix1, string prefix2);
    private IList`1<XmlNsDefinition> LoadNsDefs();
    private void LoadNsDefHelper(IList`1<XmlNsDefinition> result, string xmlns, string clrns, Assembly assembly);
    private ConcurrentDictionary`2<string, IList`1<string>> LoadClrToXmlNs();
    private ICollection`1<AssemblyName> LoadInternalsVisibleTo();
    private void LoadInternalsVisibleToHelper(List`1<AssemblyName> result, string assemblyName, Assembly assembly);
    private Dictionary`2<string, string> LoadOldToNewNs();
    private void LoadOldToNewNsHelper(Dictionary`2<string, string> result, string oldns, string newns, Assembly assembly);
    private Dictionary`2<string, string> LoadPrefixes();
    private void LoadPrefixesHelper(Dictionary`2<string, string> result, string xmlns, string prefix, Assembly assembly);
    private string LoadRootNamespace();
    private void MakeListsImmutable(IDictionary`2<string, IList`1<string>> dict);
}
[DefaultMemberAttribute("Item")]
internal class System.Xaml.NameScope : object {
    private HybridDictionary _nameMap;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public sealed virtual void RegisterName(string name, object scopedElement);
    public sealed virtual void UnregisterName(string name);
    public sealed virtual object FindName(string name);
    private IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
}
internal class System.Xaml.NameScopeDictionary : object {
    private HybridDictionary _nameMap;
    private INameScope _underlyingNameScope;
    private FrugalObjectList`1<string> _names;
    internal INameScope UnderlyingNameScope { get; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
    private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    public NameScopeDictionary(INameScope underlyingNameScope);
    public sealed virtual void RegisterName(string name, object scopedElement);
    public sealed virtual void UnregisterName(string name);
    public sealed virtual object FindName(string name);
    internal INameScope get_UnderlyingNameScope();
    private IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
}
[DebuggerDisplayAttribute("Prefix={Prefix} Namespace={Namespace}")]
public class System.Xaml.NamespaceDeclaration : object {
    private string prefix;
    private string ns;
    public string Prefix { get; }
    public string Namespace { get; }
    public NamespaceDeclaration(string ns, string prefix);
    public string get_Prefix();
    public string get_Namespace();
}
internal static class System.Xaml.NameValidationHelper : object {
    internal static bool IsValidIdentifierName(string name);
}
internal class System.Xaml.NullableReference`1 : ValueType {
    private static object s_NullSentinel;
    private static object s_NotPresentSentinel;
    private object _value;
    public bool IsNotPresent { get; public set; }
    public bool IsSet { get; }
    public bool IsSetVolatile { get; }
    public T Value { get; public set; }
    private static NullableReference`1();
    public bool get_IsNotPresent();
    public void set_IsNotPresent(bool value);
    public bool get_IsSet();
    public bool get_IsSetVolatile();
    public T get_Value();
    public void set_Value(T value);
    public void SetIfNull(T value);
    public void SetVolatile(T value);
}
public class System.Xaml.Permissions.XamlAccessLevel : object {
    [CompilerGeneratedAttribute]
private string <PrivateAccessToTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyNameString>k__BackingField;
    public AssemblyName AssemblyAccessToAssemblyName { get; }
    public string PrivateAccessToTypeName { get; private set; }
    internal string AssemblyNameString { get; private set; }
    private XamlAccessLevel(string assemblyName, string typeName);
    public static XamlAccessLevel AssemblyAccessTo(Assembly assembly);
    public static XamlAccessLevel AssemblyAccessTo(AssemblyName assemblyName);
    public static XamlAccessLevel PrivateAccessTo(Type type);
    public static XamlAccessLevel PrivateAccessTo(string assemblyQualifiedTypeName);
    public AssemblyName get_AssemblyAccessToAssemblyName();
    [CompilerGeneratedAttribute]
public string get_PrivateAccessToTypeName();
    [CompilerGeneratedAttribute]
private void set_PrivateAccessToTypeName(string value);
    [CompilerGeneratedAttribute]
internal string get_AssemblyNameString();
    [CompilerGeneratedAttribute]
private void set_AssemblyNameString(string value);
    internal XamlAccessLevel AssemblyOnly();
    internal static XamlAccessLevel FromXml(SecurityElement elem);
    internal bool Includes(XamlAccessLevel other);
    internal SecurityElement ToXml();
    private static void ValidateAssemblyName(AssemblyName assemblyName, string argName);
}
public class System.Xaml.Permissions.XamlLoadPermission : CodeAccessPermission {
    private static IList`1<XamlAccessLevel> s_emptyAccessLevel;
    private bool _isUnrestricted;
    [CompilerGeneratedAttribute]
private IList`1<XamlAccessLevel> <AllowedAccess>k__BackingField;
    public IList`1<XamlAccessLevel> AllowedAccess { get; private set; }
    public XamlLoadPermission(PermissionState state);
    public XamlLoadPermission(XamlAccessLevel allowedAccess);
    public XamlLoadPermission(IEnumerable`1<XamlAccessLevel> allowedAccess);
    private XamlLoadPermission(XamlLoadPermission other);
    private void Init(bool isUnrestricted, IList`1<XamlAccessLevel> allowedAccess);
    [CompilerGeneratedAttribute]
public IList`1<XamlAccessLevel> get_AllowedAccess();
    [CompilerGeneratedAttribute]
private void set_AllowedAccess(IList`1<XamlAccessLevel> value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement elem);
    public bool Includes(XamlAccessLevel requestedAccess);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission other);
    public sealed virtual bool IsUnrestricted();
    private static XamlLoadPermission CastPermission(IPermission other, string argName);
}
internal abstract class System.Xaml.ReaderBaseDelegate : XamlReader {
    protected XamlSchemaContext _schemaContext;
    protected XamlNode _currentNode;
    protected LineInfo _currentLineInfo;
    protected bool _hasLineInfo;
    public XamlNodeType NodeType { get; }
    public bool IsEof { get; }
    public NamespaceDeclaration Namespace { get; }
    public XamlType Type { get; }
    public object Value { get; }
    public XamlMember Member { get; }
    public XamlSchemaContext SchemaContext { get; }
    public bool HasLineInfo { get; public set; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    protected ReaderBaseDelegate(XamlSchemaContext schemaContext);
    public virtual XamlNodeType get_NodeType();
    public virtual bool get_IsEof();
    public virtual NamespaceDeclaration get_Namespace();
    public virtual XamlType get_Type();
    public virtual object get_Value();
    public virtual XamlMember get_Member();
    public virtual XamlSchemaContext get_SchemaContext();
    public sealed virtual bool get_HasLineInfo();
    public void set_HasLineInfo(bool value);
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
internal class System.Xaml.ReaderDelegate : ReaderBaseDelegate {
    private XamlNodeNextDelegate _nextDelegate;
    public ReaderDelegate(XamlSchemaContext schemaContext, XamlNodeNextDelegate next, bool hasLineInfo);
    public virtual bool Read();
}
internal class System.Xaml.ReaderMultiIndexDelegate : ReaderBaseDelegate {
    private static XamlNode s_StartOfStream;
    private static XamlNode s_EndOfStream;
    private XamlNodeIndexDelegate _indexDelegate;
    private int _count;
    private int _idx;
    public int Count { get; }
    public int CurrentIndex { get; public set; }
    public ReaderMultiIndexDelegate(XamlSchemaContext schemaContext, XamlNodeIndexDelegate indexDelegate, int count, bool hasLineInfo);
    private static ReaderMultiIndexDelegate();
    public virtual bool Read();
    public sealed virtual int get_Count();
    public sealed virtual int get_CurrentIndex();
    public sealed virtual void set_CurrentIndex(int value);
}
internal static class System.Xaml.ReflectionHelper : object {
    private static Hashtable _loadedAssembliesHash;
    private static ReflectionHelper();
    internal static Type GetQualifiedType(string typeName);
    internal static bool IsNullableType(Type type);
    internal static bool IsInternalType(Type type);
    internal static bool IsPublicType(Type type);
    internal static Type GetSystemType(Type type);
    internal static string GetTypeConverterAttributeData(Type type, Type& converterType);
    internal static string GetTypeConverterAttributeData(MemberInfo mi, Type& converterType);
    private static string GetCustomAttributeData(MemberInfo mi, Type attrType, Type& typeValue);
    private static string GetCustomAttributeData(IList`1<CustomAttributeData> list, Type attrType, Type& typeValue, bool allowTypeAlso, bool allowZeroArgs);
    internal static string GetCustomAttributeData(Type t, Type attrType, bool allowTypeAlso, Boolean& attributeDataFound, Type& typeValue);
    private static string GetCustomAttributeData(CustomAttributeData cad, Type attrType, Type& typeValue, bool allowTypeAlso, bool noArgs, bool zeroArgsAllowed);
    internal static void ResetCacheForAssembly(string assemblyName);
    internal static Assembly LoadAssembly(string assemblyName, string assemblyPath);
    internal static Assembly GetAlreadyLoadedAssembly(string assemblyNameLookup);
    private static Assembly LoadAssemblyHelper(string assemblyGivenName, string assemblyPath);
}
internal class System.Xaml.Replacements.DateTimeConverter2 : TypeConverter {
    private DateTimeValueSerializer _dateTimeValueSerializer;
    private IValueSerializerContext _valueSerializerContext;
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Xaml.Replacements.DateTimeValueSerializerContext : object {
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public sealed virtual ValueSerializer GetValueSerializerFor(PropertyDescriptor descriptor);
    public sealed virtual ValueSerializer GetValueSerializerFor(Type type);
    public sealed virtual IContainer get_Container();
    public sealed virtual object get_Instance();
    public sealed virtual void OnComponentChanged();
    public sealed virtual bool OnComponentChanging();
    public sealed virtual PropertyDescriptor get_PropertyDescriptor();
    public sealed virtual object GetService(Type serviceType);
}
internal static class System.Xaml.Replacements.StringHelpers : object {
    public static String[] SplitTypeList(string typeList);
}
internal class System.Xaml.Replacements.TypeListConverter : TypeConverter {
    private static TypeTypeConverter typeTypeConverter;
    private static TypeListConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
internal class System.Xaml.Replacements.TypeTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    private static string ConvertTypeToString(ITypeDescriptorContext context, Type type);
    private static TService GetService(ITypeDescriptorContext context);
}
internal static class System.Xaml.SafeSecurityHelper : object {
    private static Dictionary`2<object, AssemblyName> _assemblies;
    private static object syncObject;
    private static bool _isGCCallbackPending;
    private static WaitCallback _cleanupCollectedAssemblies;
    internal static string IMAGE;
    private static SafeSecurityHelper();
    internal static Assembly GetLoadedAssembly(AssemblyName assemblyName);
    private static AssemblyName GetAssemblyName(Assembly assembly);
    private static void CleanupCollectedAssemblies(object state);
    internal static bool IsSameKeyToken(Byte[] reqKeyToken, Byte[] curKeyToken);
}
internal enum System.Xaml.SavedContextType : Enum {
    public int value__;
    public static SavedContextType Template;
    public static SavedContextType ReparseValue;
    public static SavedContextType ReparseMarkupExtension;
}
[FlagsAttribute]
public enum System.Xaml.Schema.AllowedMemberLocations : Enum {
    public int value__;
    public static AllowedMemberLocations None;
    public static AllowedMemberLocations Attribute;
    public static AllowedMemberLocations MemberElement;
    public static AllowedMemberLocations Any;
}
internal static class System.Xaml.Schema.BuiltInValueConverter : object {
    private static XamlValueConverter`1<TypeConverter> s_String;
    private static XamlValueConverter`1<TypeConverter> s_Object;
    private static XamlValueConverter`1<TypeConverter> s_Int32;
    private static XamlValueConverter`1<TypeConverter> s_Int16;
    private static XamlValueConverter`1<TypeConverter> s_Int64;
    private static XamlValueConverter`1<TypeConverter> s_UInt32;
    private static XamlValueConverter`1<TypeConverter> s_UInt16;
    private static XamlValueConverter`1<TypeConverter> s_UInt64;
    private static XamlValueConverter`1<TypeConverter> s_Boolean;
    private static XamlValueConverter`1<TypeConverter> s_Double;
    private static XamlValueConverter`1<TypeConverter> s_Single;
    private static XamlValueConverter`1<TypeConverter> s_Byte;
    private static XamlValueConverter`1<TypeConverter> s_SByte;
    private static XamlValueConverter`1<TypeConverter> s_Char;
    private static XamlValueConverter`1<TypeConverter> s_Decimal;
    private static XamlValueConverter`1<TypeConverter> s_TimeSpan;
    private static XamlValueConverter`1<TypeConverter> s_Guid;
    private static XamlValueConverter`1<TypeConverter> s_Type;
    private static XamlValueConverter`1<TypeConverter> s_TypeList;
    private static XamlValueConverter`1<TypeConverter> s_DateTime;
    private static XamlValueConverter`1<TypeConverter> s_DateTimeOffset;
    private static XamlValueConverter`1<TypeConverter> s_CultureInfo;
    private static XamlValueConverter`1<ValueSerializer> s_StringSerializer;
    private static XamlValueConverter`1<TypeConverter> s_Delegate;
    internal static XamlValueConverter`1<TypeConverter> Int32 { get; }
    internal static XamlValueConverter`1<TypeConverter> String { get; }
    internal static XamlValueConverter`1<TypeConverter> Object { get; }
    internal static XamlValueConverter`1<TypeConverter> Event { get; }
    internal static XamlValueConverter`1<TypeConverter> get_Int32();
    internal static XamlValueConverter`1<TypeConverter> get_String();
    internal static XamlValueConverter`1<TypeConverter> get_Object();
    internal static XamlValueConverter`1<TypeConverter> get_Event();
    internal static XamlValueConverter`1<TypeConverter> GetTypeConverter(Type targetType);
    internal static XamlValueConverter`1<ValueSerializer> GetValueSerializer(Type targetType);
}
internal class System.Xaml.Schema.BuiltInValueConverter`1 : XamlValueConverter`1<TConverterBase> {
    private Func`1<TConverterBase> _factory;
    internal bool IsPublic { get; }
    internal BuiltInValueConverter`1(Type converterType, Func`1<TConverterBase> factory);
    internal virtual bool get_IsPublic();
    protected virtual TConverterBase CreateInstance();
}
internal static class System.Xaml.Schema.ClrNamespaceUriParser : object {
    public static string GetUri(string clrNs, string assemblyName);
    public static bool TryParseUri(string uriInput, String& clrNs, String& assemblyName);
    private static bool TryParseUri(string uriInput, String& clrNs, String& assemblyName, String& error, bool returnErrors);
}
internal static class System.Xaml.Schema.CollectionReflector : object {
    private static Type[] s_typeOfObjectArray;
    private static Type[] s_typeOfTwoObjectArray;
    private static MethodInfo s_getEnumeratorMethod;
    private static MethodInfo s_listAddMethod;
    private static MethodInfo s_dictionaryAddMethod;
    private static Type[] TypeOfObjectArray { get; }
    private static Type[] TypeOfTwoObjectArray { get; }
    private static MethodInfo IEnumerableGetEnumeratorMethod { get; }
    private static MethodInfo IListAddMethod { get; }
    private static MethodInfo IDictionaryAddMethod { get; }
    internal static XamlCollectionKind LookupCollectionKind(Type type, MethodInfo& addMethod);
    internal static MethodInfo LookupAddMethod(Type type, XamlCollectionKind collectionKind);
    private static bool TryGetICollectionAdder(Type type, MethodInfo& addMethod);
    private static bool TryGetCollectionAdder(Type type, bool mayBeICollection, MethodInfo& addMethod);
    private static bool TryGetIDictionaryAdder(Type type, MethodInfo& addMethod);
    private static bool TryGetDictionaryAdder(Type type, bool mayBeIDictionary, MethodInfo& addMethod);
    internal static MethodInfo GetAddMethod(Type type, Type contentType);
    internal static MethodInfo GetEnumeratorMethod(Type type);
    internal static MethodInfo GetIsReadOnlyMethod(Type collectionType, Type itemType);
    private static MethodInfo LookupEnumeratorMethod(Type type);
    private static Type GetGenericInterface(Type type, Type interfaceType, Boolean& hasMultiple);
    private static MethodInfo GetAddMethod(Type type, int paramCount, Boolean& hasMoreThanOne);
    private static BindingFlags GetBindingFlags(Type type);
    private static MethodInfo GetMethod(Type type, string name, Type[] argTypes);
    private static MethodInfo GetPublicMethod(Type type, string name, int argCount);
    private static Type[] get_TypeOfObjectArray();
    private static Type[] get_TypeOfTwoObjectArray();
    private static MethodInfo get_IEnumerableGetEnumeratorMethod();
    private static MethodInfo get_IListAddMethod();
    private static MethodInfo get_IDictionaryAddMethod();
}
internal class System.Xaml.Schema.MemberReflector : Reflector {
    private static DesignerSerializationVisibility VisibilityInvalid;
    private static DesignerSerializationVisibility VisibilityNone;
    private static MemberReflector s_UnknownReflector;
    private NullableReference`1<string> _constructorArgument;
    private NullableReference`1<XamlValueConverter`1<XamlDeferringLoader>> _deferringLoader;
    private NullableReference`1<object> _defaultValue;
    [SecurityCriticalAttribute]
private NullableReference`1<MethodInfo> _getter;
    [SecurityCriticalAttribute]
private NullableReference`1<MethodInfo> _setter;
    private NullableReference`1<XamlValueConverter`1<TypeConverter>> _typeConverter;
    private NullableReference`1<XamlValueConverter`1<ValueSerializer>> _valueSerializer;
    private DesignerSerializationVisibility _designerSerializationVisibility;
    private int _memberBits;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<char, char> <MarkupExtensionBracketCharactersArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MarkupExtensionBracketCharactersArgumentIsSet>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<XamlMember> <DependsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlMemberInvoker <Invoker>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <UnderlyingMember>k__BackingField;
    internal static MemberReflector UnknownReflector { get; }
    internal string ConstructorArgument { get; internal set; }
    internal bool ConstructorArgumentIsSet { get; }
    internal IReadOnlyDictionary`2<char, char> MarkupExtensionBracketCharactersArgument { get; internal set; }
    internal bool MarkupExtensionBracketCharactersArgumentIsSet { get; internal set; }
    internal object DefaultValue { get; internal set; }
    internal bool DefaultValueIsNotPresent { get; internal set; }
    internal bool DefaultValueIsSet { get; }
    internal XamlValueConverter`1<XamlDeferringLoader> DeferringLoader { get; internal set; }
    internal bool DeferringLoaderIsSet { get; }
    internal IList`1<XamlMember> DependsOn { get; internal set; }
    internal Nullable`1<DesignerSerializationVisibility> SerializationVisibility { get; internal set; }
    internal bool DesignerSerializationVisibilityIsSet { get; }
    internal MethodInfo Getter { get; internal set; }
    internal bool GetterIsSet { get; }
    internal XamlMemberInvoker Invoker { get; internal set; }
    internal bool IsUnknown { get; }
    internal MethodInfo Setter { get; internal set; }
    internal bool SetterIsSet { get; }
    internal XamlType Type { get; internal set; }
    internal XamlType TargetType { get; internal set; }
    internal XamlValueConverter`1<TypeConverter> TypeConverter { get; internal set; }
    internal bool TypeConverterIsSet { get; }
    internal MemberInfo UnderlyingMember { get; internal set; }
    internal XamlValueConverter`1<ValueSerializer> ValueSerializer { get; internal set; }
    internal bool ValueSerializerIsSet { get; }
    protected MemberInfo Member { get; }
    internal MemberReflector(bool isEvent);
    [SecuritySafeCriticalAttribute]
internal MemberReflector(MethodInfo getter, MethodInfo setter, bool isEvent);
    [SecuritySafeCriticalAttribute]
internal MemberReflector(XamlType type, XamlValueConverter`1<TypeConverter> typeConverter);
    [SecuritySafeCriticalAttribute]
internal static MemberReflector get_UnknownReflector();
    internal string get_ConstructorArgument();
    internal void set_ConstructorArgument(string value);
    internal bool get_ConstructorArgumentIsSet();
    [CompilerGeneratedAttribute]
internal IReadOnlyDictionary`2<char, char> get_MarkupExtensionBracketCharactersArgument();
    [CompilerGeneratedAttribute]
internal void set_MarkupExtensionBracketCharactersArgument(IReadOnlyDictionary`2<char, char> value);
    [CompilerGeneratedAttribute]
internal bool get_MarkupExtensionBracketCharactersArgumentIsSet();
    [CompilerGeneratedAttribute]
internal void set_MarkupExtensionBracketCharactersArgumentIsSet(bool value);
    internal object get_DefaultValue();
    internal void set_DefaultValue(object value);
    internal bool get_DefaultValueIsNotPresent();
    internal void set_DefaultValueIsNotPresent(bool value);
    internal bool get_DefaultValueIsSet();
    internal XamlValueConverter`1<XamlDeferringLoader> get_DeferringLoader();
    internal void set_DeferringLoader(XamlValueConverter`1<XamlDeferringLoader> value);
    internal bool get_DeferringLoaderIsSet();
    [CompilerGeneratedAttribute]
internal IList`1<XamlMember> get_DependsOn();
    [CompilerGeneratedAttribute]
internal void set_DependsOn(IList`1<XamlMember> value);
    internal Nullable`1<DesignerSerializationVisibility> get_SerializationVisibility();
    internal void set_SerializationVisibility(Nullable`1<DesignerSerializationVisibility> value);
    internal bool get_DesignerSerializationVisibilityIsSet();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_Getter();
    [SecuritySafeCriticalAttribute]
internal void set_Getter(MethodInfo value);
    [SecuritySafeCriticalAttribute]
internal bool get_GetterIsSet();
    [CompilerGeneratedAttribute]
internal XamlMemberInvoker get_Invoker();
    [CompilerGeneratedAttribute]
internal void set_Invoker(XamlMemberInvoker value);
    internal bool get_IsUnknown();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_Setter();
    [SecuritySafeCriticalAttribute]
internal void set_Setter(MethodInfo value);
    [SecuritySafeCriticalAttribute]
internal bool get_SetterIsSet();
    [CompilerGeneratedAttribute]
internal XamlType get_Type();
    [CompilerGeneratedAttribute]
internal void set_Type(XamlType value);
    [CompilerGeneratedAttribute]
internal XamlType get_TargetType();
    [CompilerGeneratedAttribute]
internal void set_TargetType(XamlType value);
    internal XamlValueConverter`1<TypeConverter> get_TypeConverter();
    internal void set_TypeConverter(XamlValueConverter`1<TypeConverter> value);
    internal bool get_TypeConverterIsSet();
    [CompilerGeneratedAttribute]
internal MemberInfo get_UnderlyingMember();
    [CompilerGeneratedAttribute]
internal void set_UnderlyingMember(MemberInfo value);
    internal XamlValueConverter`1<ValueSerializer> get_ValueSerializer();
    internal void set_ValueSerializer(XamlValueConverter`1<ValueSerializer> value);
    internal bool get_ValueSerializerIsSet();
    internal Nullable`1<bool> GetFlag(BoolMemberBits flag);
    internal void SetFlag(BoolMemberBits flag, bool value);
    internal static bool IsInternalVisibleTo(MethodInfo method, Assembly accessingAssembly, XamlSchemaContext schemaContext);
    internal static bool IsProtectedVisibleTo(MethodInfo method, Type derivedType, XamlSchemaContext schemaContext);
    internal static bool GenericArgumentsAreVisibleTo(MethodInfo method, Assembly accessingAssembly, XamlSchemaContext schemaContext);
    protected virtual MemberInfo get_Member();
}
internal class System.Xaml.Schema.ReferenceEqualityComparer`1 : EqualityComparer`1<T> {
    internal static ReferenceEqualityComparer`1<T> Singleton;
    private static ReferenceEqualityComparer`1();
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
}
internal class System.Xaml.Schema.ReferenceEqualityTuple`2 : Tuple`2<T1, T2> {
    public ReferenceEqualityTuple`2(T1 item1, T2 item2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Xaml.Schema.ReferenceEqualityTuple`3 : Tuple`3<T1, T2, T3> {
    public ReferenceEqualityTuple`3(T1 item1, T2 item2, T3 item3);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class System.Xaml.Schema.Reflector : object {
    protected NullableReference`1<ICustomAttributeProvider> _attributeProvider;
    protected IList`1<CustomAttributeData> _attributeData;
    internal ICustomAttributeProvider CustomAttributeProvider { get; internal set; }
    internal bool CustomAttributeProviderIsSet { get; }
    internal bool CustomAttributeProviderIsSetVolatile { get; }
    protected MemberInfo Member { get; }
    internal ICustomAttributeProvider get_CustomAttributeProvider();
    internal void set_CustomAttributeProvider(ICustomAttributeProvider value);
    internal void SetCustomAttributeProviderVolatile(ICustomAttributeProvider value);
    internal bool get_CustomAttributeProviderIsSet();
    internal bool get_CustomAttributeProviderIsSetVolatile();
    protected abstract virtual MemberInfo get_Member();
    public bool IsAttributePresent(Type attributeType);
    public string GetAttributeString(Type attributeType, Boolean& checkedInherited);
    public IReadOnlyDictionary`2<char, char> GetBracketCharacterAttributes(Type attributeType);
    public Nullable`1<T> GetAttributeValue(Type attributeType);
    public Type GetAttributeType(Type attributeType);
    public Type[] GetAttributeTypes(Type attributeType, int count);
    public List`1<T> GetAllAttributeContents(Type attributeType);
    protected static Nullable`1<bool> GetFlag(int bitMask, int bitToCheck);
    protected static int GetValidMask(int flagMask);
    protected static void SetFlag(Int32& bitMask, int bitToSet, bool value);
    protected static void SetBit(Int32& flags, int mask);
    private static bool TypesAreEqual(Type userType, Type builtInType);
    private ReadOnlyDictionary`2<char, char> TokenizeBracketCharacters(Type attributeType);
    private Type ExtractType(CustomAttributeData cad);
    private Type[] ExtractTypes(CustomAttributeData cad, int count);
    private Type ExtractType(CustomAttributeTypedArgument arg);
    private T Extract(CustomAttributeData cad);
    protected void EnsureAttributeData();
    private CustomAttributeData GetAttribute(Type attributeType);
    private void GetAttributes(Type attributeType, IList`1<CustomAttributeData> cads);
    protected void ThrowInvalidMetadata(CustomAttributeData cad, int expectedCount, Type expectedType);
}
internal static class System.Xaml.Schema.SafeReflectionInvoker : object {
    private static bool s_UseDynamicAssembly;
    private static object lockObject;
    private static CreateDelegate1Delegate s_CreateDelegate1;
    private static CreateDelegate2Delegate s_CreateDelegate2;
    private static CreateInstanceDelegate s_CreateInstance;
    private static InvokeMethodDelegate s_InvokeMethod;
    [SecurityCriticalAttribute]
private static ReflectionPermission s_reflectionMemberAccess;
    private static Assembly SystemXaml;
    private static SafeReflectionInvoker();
    [SecurityCriticalAttribute]
private static bool UseDynamicAssembly();
    [SecurityCriticalAttribute]
private static void CreateDynamicAssembly();
    [SecuritySafeCriticalAttribute]
public static bool IsInSystemXaml(Type type);
    [SecuritySafeCriticalAttribute]
internal static Delegate CreateDelegate(Type delegateType, Type targetType, string methodName);
    internal static Delegate CreateDelegateCritical(Type delegateType, Type targetType, string methodName);
    [SecuritySafeCriticalAttribute]
internal static Delegate CreateDelegate(Type delegateType, object target, string methodName);
    internal static Delegate CreateDelegateCritical(Type delegateType, object target, string methodName);
    [SecuritySafeCriticalAttribute]
internal static object CreateInstance(Type type, Object[] arguments);
    internal static object CreateInstanceCritical(Type type, Object[] arguments);
    [SecuritySafeCriticalAttribute]
internal static void DemandMemberAccessPermission();
    [SecuritySafeCriticalAttribute]
internal static object InvokeMethod(MethodInfo method, object instance, Object[] args);
    internal static object InvokeMethodCritical(MethodInfo method, object instance, Object[] args);
    [SecuritySafeCriticalAttribute]
internal static bool IsSystemXamlNonPublic(MethodInfo method);
}
public enum System.Xaml.Schema.ShouldSerializeResult : Enum {
    public int value__;
    public static ShouldSerializeResult Default;
    public static ShouldSerializeResult True;
    public static ShouldSerializeResult False;
}
internal class System.Xaml.Schema.TypeReflector : Reflector {
    private static XamlCollectionKind XamlCollectionKindInvalid;
    private static BindingFlags AllProperties_BF;
    private static BindingFlags AttachableProperties_BF;
    private static TypeReflector s_UnknownReflector;
    private ThreadSafeDictionary`2<string, XamlMember> _nonAttachableMemberCache;
    private ThreadSafeDictionary`2<string, XamlMember> _attachableMemberCache;
    private int _boolTypeBits;
    private ThreadSafeDictionary`2<int, IList`1<XamlType>> _positionalParameterTypes;
    private ConcurrentDictionary`2<XamlDirective, XamlMember> _aliasedProperties;
    private XamlCollectionKind _collectionKind;
    private NullableReference`1<XamlMember> _contentProperty;
    private NullableReference`1<XamlMember> _runtimeNameProperty;
    private NullableReference`1<XamlMember> _xmlLangProperty;
    private NullableReference`1<XamlMember> _dictionaryKeyProperty;
    private NullableReference`1<XamlMember> _uidProperty;
    private NullableReference`1<MethodInfo> _isReadOnlyMethod;
    private NullableReference`1<XamlValueConverter`1<TypeConverter>> _typeConverter;
    private NullableReference`1<XamlValueConverter`1<ValueSerializer>> _valueSerializer;
    private NullableReference`1<XamlValueConverter`1<XamlDeferringLoader>> _deferringLoader;
    private NullableReference`1<EventHandler`1<XamlSetMarkupExtensionEventArgs>> _xamlSetMarkupExtensionHandler;
    private NullableReference`1<EventHandler`1<XamlSetTypeConverterEventArgs>> _xamlSetTypeConverterHandler;
    private NullableReference`1<MethodInfo> _addMethod;
    private NullableReference`1<XamlType> _baseType;
    private NullableReference`1<MethodInfo> _getEnumeratorMethod;
    [CompilerGeneratedAttribute]
private IList`1<XamlType> <AllowedContentTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<XamlType> <ContentWrappers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<XamlMember> <ExcludedReadOnlyMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlTypeInvoker <Invoker>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <MarkupExtensionReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, IList`1<XamlType>> <ReflectedPositionalParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    internal static TypeReflector UnknownReflector { get; }
    internal IList`1<XamlType> AllowedContentTypes { get; internal set; }
    internal ThreadSafeDictionary`2<string, XamlMember> AttachableMembers { get; }
    internal XamlType BaseType { get; internal set; }
    internal bool BaseTypeIsSet { get; }
    internal XamlCollectionKind CollectionKind { get; internal set; }
    internal bool CollectionKindIsSet { get; }
    internal XamlMember ContentProperty { get; internal set; }
    internal bool ContentPropertyIsSet { get; }
    internal IList`1<XamlType> ContentWrappers { get; internal set; }
    internal XamlValueConverter`1<XamlDeferringLoader> DeferringLoader { get; internal set; }
    internal bool DeferringLoaderIsSet { get; }
    internal ICollection`1<XamlMember> ExcludedReadOnlyMembers { get; internal set; }
    internal XamlType KeyType { get; internal set; }
    internal XamlTypeInvoker Invoker { get; internal set; }
    internal MethodInfo IsReadOnlyMethod { get; internal set; }
    internal bool IsReadOnlyMethodIsSet { get; }
    internal bool IsUnknown { get; }
    internal XamlType ItemType { get; internal set; }
    internal XamlType MarkupExtensionReturnType { get; internal set; }
    internal ThreadSafeDictionary`2<string, XamlMember> Members { get; }
    internal Dictionary`2<int, IList`1<XamlType>> ReflectedPositionalParameters { get; internal set; }
    internal XamlValueConverter`1<TypeConverter> TypeConverter { get; internal set; }
    internal bool TypeConverterIsSet { get; }
    internal Type UnderlyingType { get; internal set; }
    internal XamlValueConverter`1<ValueSerializer> ValueSerializer { get; internal set; }
    internal bool ValueSerializerIsSet { get; }
    internal EventHandler`1<XamlSetMarkupExtensionEventArgs> XamlSetMarkupExtensionHandler { get; internal set; }
    internal bool XamlSetMarkupExtensionHandlerIsSet { get; }
    internal EventHandler`1<XamlSetTypeConverterEventArgs> XamlSetTypeConverterHandler { get; internal set; }
    internal bool XamlSetTypeConverterHandlerIsSet { get; }
    internal MethodInfo AddMethod { get; internal set; }
    internal bool AddMethodIsSet { get; }
    internal MethodInfo GetEnumeratorMethod { get; internal set; }
    internal bool GetEnumeratorMethodIsSet { get; }
    protected MemberInfo Member { get; }
    public TypeReflector(Type underlyingType);
    internal static TypeReflector get_UnknownReflector();
    internal static bool IsVisibleTo(Type type, Assembly accessingAssembly, XamlSchemaContext schemaContext);
    internal static bool IsInternal(Type type);
    internal static bool IsPublicOrInternal(MethodBase method);
    [CompilerGeneratedAttribute]
internal IList`1<XamlType> get_AllowedContentTypes();
    [CompilerGeneratedAttribute]
internal void set_AllowedContentTypes(IList`1<XamlType> value);
    internal ThreadSafeDictionary`2<string, XamlMember> get_AttachableMembers();
    internal XamlType get_BaseType();
    internal void set_BaseType(XamlType value);
    internal bool get_BaseTypeIsSet();
    internal XamlCollectionKind get_CollectionKind();
    internal void set_CollectionKind(XamlCollectionKind value);
    internal bool get_CollectionKindIsSet();
    internal XamlMember get_ContentProperty();
    internal void set_ContentProperty(XamlMember value);
    internal bool get_ContentPropertyIsSet();
    [CompilerGeneratedAttribute]
internal IList`1<XamlType> get_ContentWrappers();
    [CompilerGeneratedAttribute]
internal void set_ContentWrappers(IList`1<XamlType> value);
    internal XamlValueConverter`1<XamlDeferringLoader> get_DeferringLoader();
    internal void set_DeferringLoader(XamlValueConverter`1<XamlDeferringLoader> value);
    internal bool get_DeferringLoaderIsSet();
    [CompilerGeneratedAttribute]
internal ICollection`1<XamlMember> get_ExcludedReadOnlyMembers();
    [CompilerGeneratedAttribute]
internal void set_ExcludedReadOnlyMembers(ICollection`1<XamlMember> value);
    [CompilerGeneratedAttribute]
internal XamlType get_KeyType();
    [CompilerGeneratedAttribute]
internal void set_KeyType(XamlType value);
    [CompilerGeneratedAttribute]
internal XamlTypeInvoker get_Invoker();
    [CompilerGeneratedAttribute]
internal void set_Invoker(XamlTypeInvoker value);
    internal MethodInfo get_IsReadOnlyMethod();
    internal void set_IsReadOnlyMethod(MethodInfo value);
    internal bool get_IsReadOnlyMethodIsSet();
    internal bool get_IsUnknown();
    [CompilerGeneratedAttribute]
internal XamlType get_ItemType();
    [CompilerGeneratedAttribute]
internal void set_ItemType(XamlType value);
    [CompilerGeneratedAttribute]
internal XamlType get_MarkupExtensionReturnType();
    [CompilerGeneratedAttribute]
internal void set_MarkupExtensionReturnType(XamlType value);
    internal ThreadSafeDictionary`2<string, XamlMember> get_Members();
    [CompilerGeneratedAttribute]
internal Dictionary`2<int, IList`1<XamlType>> get_ReflectedPositionalParameters();
    [CompilerGeneratedAttribute]
internal void set_ReflectedPositionalParameters(Dictionary`2<int, IList`1<XamlType>> value);
    internal XamlValueConverter`1<TypeConverter> get_TypeConverter();
    internal void set_TypeConverter(XamlValueConverter`1<TypeConverter> value);
    internal bool get_TypeConverterIsSet();
    [CompilerGeneratedAttribute]
internal Type get_UnderlyingType();
    [CompilerGeneratedAttribute]
internal void set_UnderlyingType(Type value);
    internal XamlValueConverter`1<ValueSerializer> get_ValueSerializer();
    internal void set_ValueSerializer(XamlValueConverter`1<ValueSerializer> value);
    internal bool get_ValueSerializerIsSet();
    internal EventHandler`1<XamlSetMarkupExtensionEventArgs> get_XamlSetMarkupExtensionHandler();
    internal void set_XamlSetMarkupExtensionHandler(EventHandler`1<XamlSetMarkupExtensionEventArgs> value);
    internal bool get_XamlSetMarkupExtensionHandlerIsSet();
    internal EventHandler`1<XamlSetTypeConverterEventArgs> get_XamlSetTypeConverterHandler();
    internal void set_XamlSetTypeConverterHandler(EventHandler`1<XamlSetTypeConverterEventArgs> value);
    internal bool get_XamlSetTypeConverterHandlerIsSet();
    internal bool TryGetPositionalParameters(int paramCount, IList`1& result);
    internal IList`1<XamlType> TryAddPositionalParameters(int paramCount, IList`1<XamlType> paramList);
    internal bool TryGetAliasedProperty(XamlDirective directive, XamlMember& member);
    internal void TryAddAliasedProperty(XamlDirective directive, XamlMember member);
    internal MethodInfo get_AddMethod();
    internal void set_AddMethod(MethodInfo value);
    internal bool get_AddMethodIsSet();
    internal MethodInfo get_GetEnumeratorMethod();
    internal void set_GetEnumeratorMethod(MethodInfo value);
    internal bool get_GetEnumeratorMethodIsSet();
    internal static XamlMember LookupNameScopeProperty(XamlType xamlType);
    internal PropertyInfo LookupProperty(string name);
    internal EventInfo LookupEvent(string name);
    internal void LookupAllMembers(ICollection`1& newProperties, ICollection`1& newEvents, List`1& knownMembers);
    internal IList`1<PropertyInfo> LookupRemainingProperties();
    private IList`1<PropertyInfo> FilterProperties(PropertyInfo[] propList, List`1<XamlMember> knownMembers, bool skipKnownNegatives);
    private ICollection`1<EventInfo> FilterEvents(EventInfo[] eventList, List`1<XamlMember> knownMembers);
    private PropertyInfo GetNonIndexerProperty(string name);
    private static bool IsPrivate(PropertyInfo pi);
    private static bool IsPrivate(EventInfo ei);
    private static bool IsPrivateOrNull(MethodInfo mi);
    private void PickAttachablePropertyAccessors(List`1<MethodInfo> getters, List`1<MethodInfo> setters, MethodInfo& getter, MethodInfo& setter);
    private MethodInfo PickAttachableEventAdder(IEnumerable`1<MethodInfo> adders);
    internal bool LookupAttachableProperty(string name, MethodInfo& getter, MethodInfo& setter);
    internal MethodInfo LookupAttachableEvent(string name);
    private void LookupAllStaticAccessors(Dictionary`2& getters, Dictionary`2& setters, Dictionary`2& adders);
    private void LookupAllStaticAccessorsHelper(MethodInfo[] allMethods, Dictionary`2<string, List`1<MethodInfo>> getters, Dictionary`2<string, List`1<MethodInfo>> setters, Dictionary`2<string, List`1<MethodInfo>> adders, bool isUnderlyingTypePublic);
    private List`1<MethodInfo> LookupStaticAdders(string name);
    private List`1<MethodInfo> LookupStaticGetters(string name);
    private List`1<MethodInfo> LookupStaticSetters(string name);
    private void PrioritizeAccessors(MemberInfo[] accessors, bool isEvent, bool isGetter, List`1& preferredAccessors, List`1& otherAccessors);
    private bool IsAttachablePropertyAccessor(bool isEvent, bool isGetter, MethodInfo accessor);
    private static void AddToMultiDict(Dictionary`2<string, List`1<MethodInfo>> dict, string name, MethodInfo value, bool isUnderlyingTypePublic);
    private bool IsAttachablePropertyGetter(MethodInfo mi, String& name);
    private bool IsAttachablePropertyGetter(MethodInfo mi);
    private bool IsAttachablePropertySetter(MethodInfo mi, String& name);
    private bool IsAttachablePropertySetter(MethodInfo mi);
    private bool IsAttachableEventAdder(MethodInfo mi, String& name);
    private bool IsAttachableEventAdder(MethodInfo mi);
    internal IList`1<XamlMember> LookupAllAttachableMembers(XamlSchemaContext schemaContext);
    private void GetOrCreateAttachableProperties(XamlSchemaContext schemaContext, List`1<XamlMember> result, Dictionary`2<string, List`1<MethodInfo>> getters, Dictionary`2<string, List`1<MethodInfo>> setters);
    private void GetOrCreateAttachableEvents(XamlSchemaContext schemaContext, List`1<XamlMember> result, Dictionary`2<string, List`1<MethodInfo>> adders);
    internal Nullable`1<bool> GetFlag(BoolTypeBits typeBit);
    internal void SetFlag(BoolTypeBits typeBit, bool value);
    protected virtual MemberInfo get_Member();
    private static object GetCustomAttribute(Type attrType, Type reflectedType);
    private static TypeVisibility GetVisibility(Type type);
}
public enum System.Xaml.Schema.XamlCollectionKind : Enum {
    public byte value__;
    public static XamlCollectionKind None;
    public static XamlCollectionKind Collection;
    public static XamlCollectionKind Dictionary;
    public static XamlCollectionKind Array;
}
public class System.Xaml.Schema.XamlMemberInvoker : object {
    private static XamlMemberInvoker s_Directive;
    private static XamlMemberInvoker s_Unknown;
    private static Object[] s_emptyObjectArray;
    private XamlMember _member;
    private NullableReference`1<MethodInfo> _shouldSerializeMethod;
    public static XamlMemberInvoker UnknownInvoker { get; }
    public MethodInfo UnderlyingGetter { get; }
    public MethodInfo UnderlyingSetter { get; }
    internal static XamlMemberInvoker DirectiveInvoker { get; }
    private bool IsUnknown { get; }
    public XamlMemberInvoker(XamlMember member);
    private static XamlMemberInvoker();
    public static XamlMemberInvoker get_UnknownInvoker();
    public MethodInfo get_UnderlyingGetter();
    public MethodInfo get_UnderlyingSetter();
    public virtual object GetValue(object instance);
    [SecuritySafeCriticalAttribute]
private object GetValueSafeCritical(object instance);
    public virtual void SetValue(object instance, object value);
    [SecuritySafeCriticalAttribute]
private void SetValueSafeCritical(object instance, object value);
    internal static XamlMemberInvoker get_DirectiveInvoker();
    public virtual ShouldSerializeResult ShouldSerializeValue(object instance);
    [SecuritySafeCriticalAttribute]
private static bool IsSystemXamlNonPublic(ThreeValuedBool& methodIsSystemXamlNonPublic, MethodInfo method);
    private bool get_IsUnknown();
    private void ThrowIfUnknown();
}
internal class System.Xaml.Schema.XamlNamespace : object {
    public XamlSchemaContext SchemaContext;
    private List`1<AssemblyNamespacePair> _assemblyNamespaces;
    private ConcurrentDictionary`2<string, XamlType> _typeCache;
    private ICollection`1<XamlType> _allPublicTypes;
    [CompilerGeneratedAttribute]
private bool <IsClrNamespace>k__BackingField;
    public bool IsClrNamespace { get; private set; }
    public bool IsResolved { get; }
    internal int RevisionNumber { get; }
    public XamlNamespace(XamlSchemaContext schemaContext);
    public XamlNamespace(XamlSchemaContext schemaContext, string clrNs, string assemblyName);
    [CompilerGeneratedAttribute]
public bool get_IsClrNamespace();
    [CompilerGeneratedAttribute]
private void set_IsClrNamespace(bool value);
    private void Initialize();
    public bool get_IsResolved();
    public ICollection`1<XamlType> GetAllXamlTypes();
    public XamlType GetXamlType(string typeName, XamlType[] typeArgs);
    private XamlType TryGetXamlType(string typeName);
    private XamlType TryGetXamlType(string typeName, Type[] typeArgs);
    private static Type MakeArrayType(Type elementType, string subscript);
    private static string MangleGenericTypeName(string typeName, int paramNum);
    private Type[] ConvertArrayOfXamlTypesToTypes(XamlType[] typeArgs);
    internal int get_RevisionNumber();
    internal static Type GetTypeFromFullTypeName(string fullName);
    private Type TryGetType(string typeName);
    private ICollection`1<XamlType> LookupAllTypes();
    private List`1<AssemblyNamespacePair> GetClrNamespacePair(string clrNs, string assemblyName);
    private Type SearchAssembliesForShortName(string shortName);
    internal void AddAssemblyNamespacePair(AssemblyNamespacePair pair);
    private string GetTypeExtensionName(string typeName);
}
public class System.Xaml.Schema.XamlTypeInvoker : object {
    private static XamlTypeInvoker s_Unknown;
    private static Object[] s_emptyObjectArray;
    private Dictionary`2<XamlType, MethodInfo> _addMethods;
    [CompilerGeneratedAttribute]
private MethodInfo <EnumeratorMethod>k__BackingField;
    private XamlType _xamlType;
    [SecurityCriticalAttribute]
private Action`1<object> _constructorDelegate;
    [SecurityCriticalAttribute]
private ThreeValuedBool _isPublic;
    [SecurityCriticalAttribute]
private ThreeValuedBool _isInSystemXaml;
    internal MethodInfo EnumeratorMethod { get; internal set; }
    public static XamlTypeInvoker UnknownInvoker { get; }
    public EventHandler`1<XamlSetMarkupExtensionEventArgs> SetMarkupExtensionHandler { get; }
    public EventHandler`1<XamlSetTypeConverterEventArgs> SetTypeConverterHandler { get; }
    private bool IsInSystemXaml { get; }
    private bool IsPublic { get; }
    private bool IsUnknown { get; }
    public XamlTypeInvoker(XamlType type);
    private static XamlTypeInvoker();
    [CompilerGeneratedAttribute]
internal MethodInfo get_EnumeratorMethod();
    [CompilerGeneratedAttribute]
internal void set_EnumeratorMethod(MethodInfo value);
    public static XamlTypeInvoker get_UnknownInvoker();
    public EventHandler`1<XamlSetMarkupExtensionEventArgs> get_SetMarkupExtensionHandler();
    public EventHandler`1<XamlSetTypeConverterEventArgs> get_SetTypeConverterHandler();
    public virtual void AddToCollection(object instance, object item);
    public virtual void AddToDictionary(object instance, object key, object item);
    public virtual object CreateInstance(Object[] arguments);
    public virtual MethodInfo GetAddMethod(XamlType contentType);
    public virtual MethodInfo GetEnumeratorMethod();
    public virtual IEnumerator GetItems(object instance);
    [SecuritySafeCriticalAttribute]
private bool get_IsInSystemXaml();
    [SecuritySafeCriticalAttribute]
private bool get_IsPublic();
    private bool get_IsUnknown();
    [SecuritySafeCriticalAttribute]
private object CreateInstanceWithActivator(Type type, Object[] arguments);
    private void ThrowIfUnknown();
}
[DebuggerDisplayAttribute("{{{Namespace}}}{Name}{TypeArgStringForDebugger}")]
public class System.Xaml.Schema.XamlTypeName : object {
    private List`1<XamlTypeName> _typeArguments;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public IList`1<XamlTypeName> TypeArguments { get; }
    internal bool HasTypeArgs { get; }
    public XamlTypeName(string xamlNamespace, string name);
    public XamlTypeName(string xamlNamespace, string name, IEnumerable`1<XamlTypeName> typeArguments);
    public XamlTypeName(XamlType xamlType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    public IList`1<XamlTypeName> get_TypeArguments();
    public virtual string ToString();
    public string ToString(INamespacePrefixLookup prefixLookup);
    public static string ToString(IList`1<XamlTypeName> typeNameList, INamespacePrefixLookup prefixLookup);
    public static XamlTypeName Parse(string typeName, IXamlNamespaceResolver namespaceResolver);
    public static IList`1<XamlTypeName> ParseList(string typeNameList, IXamlNamespaceResolver namespaceResolver);
    public static bool TryParse(string typeName, IXamlNamespaceResolver namespaceResolver, XamlTypeName& result);
    public static bool TryParseList(string typeNameList, IXamlNamespaceResolver namespaceResolver, IList`1& result);
    internal bool get_HasTypeArgs();
    internal static string ConvertListToStringInternal(IList`1<XamlTypeName> typeNameList, Func`2<string, string> prefixGenerator);
    internal static void ConvertListToStringInternal(StringBuilder result, IList`1<XamlTypeName> typeNameList, Func`2<string, string> prefixGenerator);
    internal static XamlTypeName ParseInternal(string typeName, Func`2<string, string> prefixResolver, String& error);
    internal static IList`1<XamlTypeName> ParseListInternal(string typeNameList, Func`2<string, string> prefixResolver, String& error);
    internal string ConvertToStringInternal(Func`2<string, string> prefixGenerator);
    internal void ConvertToStringInternal(StringBuilder result, Func`2<string, string> prefixGenerator);
}
public class System.Xaml.Schema.XamlTypeTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static string ConvertXamlTypeToString(ITypeDescriptorContext context, XamlType xamlType);
    private static XamlType ConvertStringToXamlType(ITypeDescriptorContext context, string typeName);
    private static TService GetService(ITypeDescriptorContext context);
    private static XamlType GetXamlTypeOrUnknown(XamlSchemaContext schemaContext, XamlTypeName typeName);
}
public class System.Xaml.Schema.XamlValueConverter`1 : object {
    private TConverterBase _instance;
    private ThreeValuedBool _isPublic;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _instanceIsSet;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ConverterType>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <TargetType>k__BackingField;
    public string Name { get; private set; }
    public Type ConverterType { get; private set; }
    public XamlType TargetType { get; private set; }
    public TConverterBase ConverterInstance { get; }
    internal bool IsPublic { get; }
    public XamlValueConverter`1(Type converterType, XamlType targetType);
    public XamlValueConverter`1(Type converterType, XamlType targetType, string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_ConverterType();
    [CompilerGeneratedAttribute]
private void set_ConverterType(Type value);
    [CompilerGeneratedAttribute]
public XamlType get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(XamlType value);
    public TConverterBase get_ConverterInstance();
    public virtual string ToString();
    internal virtual bool get_IsPublic();
    protected virtual TConverterBase CreateInstance();
    private string GetDefaultName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(XamlValueConverter`1<TConverterBase> other);
    public static bool op_Equality(XamlValueConverter`1<TConverterBase> converter1, XamlValueConverter`1<TConverterBase> converter2);
    public static bool op_Inequality(XamlValueConverter`1<TConverterBase> converter1, XamlValueConverter`1<TConverterBase> converter2);
}
internal static class System.Xaml.SR : object {
    private static ResourceManager _resourceManager;
    internal static ResourceManager ResourceManager { get; }
    private static SR();
    internal static string Get(string id);
    internal static string Get(string id, Object[] args);
    internal static ResourceManager get_ResourceManager();
}
internal class System.Xaml.SRID : ValueType {
    public static string Default;
    public static string UnexpectedParameterType;
    public static string CannotConvertStringToType;
    public static string CannotConvertType;
    public static string StringEmpty;
    public static string ParameterCannotBeNegative;
    public static string Enum_Invalid;
    public static string Collection_BadType;
    public static string Collection_CopyTo_IndexGreaterThanOrEqualToArrayLength;
    public static string Collection_CopyTo_NumberOfElementsExceedsArrayLength;
    public static string Collection_CopyTo_ArrayCannotBeMultidimensional;
    public static string CollectionNumberOfElementsMustBeLessOrEqualTo;
    public static string Enumerator_VerifyContext;
    public static string Animation_ChildMustBeKeyFrame;
    public static string Animation_NoTextChildren;
    public static string Animation_InvalidBaseValue;
    public static string Animation_InvalidTimeKeyTime;
    public static string Animation_InvalidResolvedKeyTimes;
    public static string Animation_InvalidAnimationUsingKeyFramesDuration;
    public static string Animation_Invalid_DefaultValue;
    public static string Freezable_CantBeFrozen;
    public static string CannotModifyReadOnlyContainer;
    public static string CannotRetrievePartsOfWriteOnlyContainer;
    public static string TokenizerHelperPrematureStringTermination;
    public static string TokenizerHelperMissingEndQuote;
    public static string TokenizerHelperExtraDataEncountered;
    public static string TokenizerHelperEmptyToken;
    public static string InvalidPermissionType;
    public static string InvalidPermissionStateValue;
    public static string SecurityExceptionForSettingSandboxExternalToTrue;
    public static string FileFormatException;
    public static string FileFormatExceptionWithFileName;
    public static string TypeMetadataCannotChangeAfterUse;
    public static string Visual_ArgumentOutOfRange;
    public static string XCRChoiceOnlyInAC;
    public static string XCRChoiceAfterFallback;
    public static string XCRRequiresAttribNotFound;
    public static string XCRInvalidRequiresAttribute;
    public static string XCRFallbackOnlyInAC;
    public static string XCRChoiceNotFound;
    public static string XCRMultipleFallbackFound;
    public static string XCRInvalidAttribInElement;
    public static string XCRUnknownCompatElement;
    public static string XCRInvalidACChild;
    public static string XCRInvalidFormat;
    public static string XCRUndefinedPrefix;
    public static string XCRUnknownCompatAttrib;
    public static string XCRNSProcessContentNotIgnorable;
    public static string XCRDuplicateProcessContent;
    public static string XCRInvalidProcessContent;
    public static string XCRDuplicateWildcardProcessContent;
    public static string XCRMustUnderstandFailed;
    public static string XCRNSPreserveNotIgnorable;
    public static string XCRDuplicatePreserve;
    public static string XCRInvalidPreserve;
    public static string XCRDuplicateWildcardPreserve;
    public static string XCRInvalidXMLName;
    public static string XCRCompatCycle;
    public static string BadXmlnsDefinition;
    public static string BadXmlnsCompat;
    public static string BadXmlnsPrefix;
    public static string BadInternalsVisibleTo1;
    public static string BadInternalsVisibleTo2;
    public static string DuplicateXmlnsCompat;
    public static string XmlnsCompatCycle;
    public static string UriNotFound;
    public static string DuplicateXmlnsCompatAcrossAssemblies;
    public static string UnresolvedNamespace;
    public static string TypeNotFound;
    public static string TypeNotPublic;
    public static string TooManyTypeConverterAttributes;
    public static string CannotFindAssembly;
    public static string MissingAssemblyName;
    public static string InvalidTypeArgument;
    public static string FileNotFoundExceptionMessage;
    public static string DirectiveNotFound;
    public static string MustNotCallSetter;
    public static string MissingLookPropertyBit;
    public static string TooManyAttributes;
    public static string GetTargetTypeOnNonAttachableMember;
    public static string SetTargetTypeOnNonAttachableMember;
    public static string InvalidExpression;
    public static string MissingKey;
    public static string PropertyDoesNotTakeText;
    public static string EventCannotBeAssigned;
    public static string TypeConverterFailed;
    public static string CantCreateUnknownType;
    public static string CantSetUnknownProperty;
    public static string MissingImplicitProperty;
    public static string BuilderStackNotEmptyOnClose;
    public static string CannotSetSchemaContext;
    public static string MissingImplicitPropertyTypeCase;
    public static string ConstructImplicitType;
    public static string NonMEWithPositionalParameters;
    public static string PositionalParamsWrongLength;
    public static string BadStateObjectWriter;
    public static string DuplicateMemberSet;
    public static string NotAmbientProperty;
    public static string NotAmbientType;
    public static string NoSuchConstructor;
    public static string UnresolvedForwardReferences;
    public static string CantAssignRootInstance;
    public static string ForwardRefDirectives;
    public static string TransitiveForwardRefDirectives;
    public static string TypeHasNoContentProperty;
    public static string GetObjectNull;
    public static string NotAssignableFrom;
    public static string NameScopeNameNotEmptyString;
    public static string NameScopeNameNotFound;
    public static string NameScopeDuplicateNamesNotAllowed;
    public static string NameScopeInvalidIdentifierName;
    public static string NameScopeException;
    public static string ObjectWriterTypeNotAllowed;
    public static string DirectiveNotAtRoot;
    public static string DirectiveMustBeString;
    public static string XClassMustMatchRootInstance;
    public static string SavedContextSchemaContextMismatch;
    public static string SavedContextSchemaContextNull;
    public static string SettingPropertiesIsNotAllowed;
    public static string LateConstructionDirective;
    public static string ProvideValueCycle;
    public static string AttachedPropOnFwdRefTC;
    public static string InitializationSyntaxWithoutTypeConverter;
    public static string NoPropertyInCurrentFrame_SO;
    public static string NoPropertyInCurrentFrame_NS;
    public static string NoPropertyInCurrentFrame_GO;
    public static string NoPropertyInCurrentFrame_GO_noType;
    public static string NoPropertyInCurrentFrame_V;
    public static string NoPropertyInCurrentFrame_V_noType;
    public static string OpenPropertyInCurrentFrame_EO;
    public static string OpenPropertyInCurrentFrame_SM;
    public static string NoTypeInCurrentFrame_SM;
    public static string NoTypeInCurrentFrame_EO;
    public static string NoPropertyInCurrentFrame_EM;
    public static string NoPropertyInCurrentFrame_EM_noType;
    public static string ValueMustBeFollowedByEndMember;
    public static string DictionaryFirstChanceException;
    public static string CannotSetBaseUri;
    public static string DependsOnMissing;
    public static string CloseInsideTemplate;
    public static string UnexpectedClose;
    public static string TemplateNotCollected;
    public static string DeferredPropertyNotCollected;
    public static string MissingCase;
    public static string NamespaceNotFound;
    public static string NameScopeOnRootInstance;
    public static string MissingNameResolver;
    public static string ObjectNotTcOrMe;
    public static string SimpleFixupsMustHaveOneName;
    public static string UnexpectedTokenAfterME;
    public static string WhitespaceAfterME;
    public static string UnexpectedToken;
    public static string NoConstructorWithNArugments;
    public static string MissingComma1;
    public static string MissingComma2;
    public static string TypeNameCannotHavePeriod;
    public static string UnexpectedNodeType;
    public static string ElementRuleException;
    public static string EmptyElementRuleException;
    public static string EmptyPropertyElementRuleException;
    public static string StartElementRuleException;
    public static string ElementBodyRuleException;
    public static string NonemptyPropertyElementRuleException;
    public static string PropertyElementRuleException;
    public static string MissingTagInNamespace;
    public static string AssemblyTagMissing;
    public static string UnknownAttributeProperty;
    public static string NotDeclaringTypeAttributeProperty;
    public static string UsableDuringInitializationOnME;
    public static string TooManyAttributesOnType;
    public static string MissingPropertyCaseClrType;
    public static string UnhandledBoolTypeBit;
    public static string AmbiguousCollectionItemType;
    public static string AmbiguousDictionaryItemType;
    public static string MarkupExtensionWithDuplicateArity;
    public static string SetOnlyProperty;
    public static string XaslTypePropertiesNotImplemented;
    public static string AttachableMemberNotFound;
    public static string PropertyNotImplemented;
    public static string PrefixNotFound;
    public static string LineNumberAndPosition;
    public static string LineNumberOnly;
    public static string QuoteCharactersOutOfPlace;
    public static string UnclosedQuote;
    public static string MalformedPropertyName;
    public static string MalformedBracketCharacters;
    public static string InvalidClosingBracketCharacers;
    public static string MalformedBracketCharacers;
    public static string AttributeUnhandledKind;
    public static string UnknownType;
    public static string UnknownMember;
    public static string UnknownMemberSimple;
    public static string UnknownMemberOnUnknownType;
    public static string MemberIsInternal;
    public static string NoAttributeUsage;
    public static string NoElementUsage;
    public static string InvalidXamlMemberName;
    public static string ParentlessPropertyElement;
    public static string SchemaContextNotInitialized;
    public static string ThreadAlreadyStarted;
    public static string SchemaContextNull;
    public static string CloseXamlWriterBeforeReading;
    public static string CannotWriteClosedWriter;
    public static string WriterIsClosed;
    public static string DirectiveGetter;
    public static string BadMethod;
    public static string CannotResolveTypeForFactoryMethod;
    public static string CannotCreateBadType;
    public static string CannotCreateBadEventDelegate;
    public static string AttachableEventNotImplemented;
    public static string ListNotIList;
    public static string ArrayAddNotImplemented;
    public static string NoAddMethodFound;
    public static string MissingTypeConverter;
    public static string CantSetReadonlyProperty;
    public static string CantGetWriteonlyProperty;
    public static string XmlDataNull;
    public static string XmlValueNotReader;
    public static string NameNotFound;
    public static string MustHaveName;
    public static string MethodInvocation;
    public static string GetValue;
    public static string SetValue;
    public static string AddCollection;
    public static string AddDictionary;
    public static string SetConnectionId;
    public static string InitializationGuard;
    public static string SetUriBase;
    public static string ProvideValue;
    public static string SetXmlInstance;
    public static string GetConverterInstance;
    public static string DeferredLoad;
    public static string DeferredSave;
    public static string FactoryReturnedNull;
    public static string ConstructorInvocation;
    public static string NoDefaultConstructor;
    public static string NoConstructor;
    public static string DeferringLoaderInstanceNull;
    public static string TypeConverterFailed2;
    public static string CanConvertFromFailed;
    public static string CanConvertToFailed;
    public static string ShouldSerializeFailed;
    public static string GetItemsReturnedNull;
    public static string GetItemsException;
    public static string APSException;
    public static string CannotReassignSchemaContext;
    public static string CannotSetSchemaContextNull;
    public static string MissingCaseXamlNodes;
    public static string MarkupExtensionTypeName;
    public static string MarkupExtensionTypeNameBad;
    public static string MarkupExtensionNoContext;
    public static string XamlXmlWriterWriteNotSupportedInCurrentState;
    public static string XamlXmlWriterWriteObjectNotSupportedInCurrentState;
    public static string XamlXmlWriterPrefixAlreadyDefinedInCurrentScope;
    public static string XamlXmlWriterNamespaceAlreadyHasPrefixInCurrentScope;
    public static string XamlXmlWriterDuplicateMember;
    public static string XamlXmlWriterIsObjectFromMemberSetForArraysOrNonCollections;
    public static string XamlXmlWriterCannotWriteNonstringValue;
    public static string ExpandPositionalParametersinTypeWithNoDefaultConstructor;
    public static string ConstructorNotFoundForGivenPositionalParameters;
    public static string ExpandPositionalParametersWithReadOnlyProperties;
    public static string TypeHasInvalidXamlName;
    public static string MemberHasInvalidXamlName;
    public static string NamespaceDeclarationCannotBeXml;
    public static string ExpandPositionalParametersWithoutUnderlyingType;
    public static string PrefixNotInFrames;
    public static string WhiteSpaceInCollection;
    public static string CannotWriteXmlSpacePreserveOnMember;
    public static string InvalidTypeString;
    public static string InvalidTypeListString;
    public static string InvalidCharInTypeName;
    public static string XamlTypeNameNamespaceIsNull;
    public static string XamlTypeNameNameIsNullOrEmpty;
    public static string XamlTypeNameCannotGetPrefix;
    public static string CollectionCannotContainNulls;
    public static string NamespaceDeclarationPrefixCannotBeNull;
    public static string NamespaceDeclarationNamespaceCannotBeNull;
    public static string IncorrectGetterParamNum;
    public static string IncorrectSetterParamNum;
    public static string GetterOrSetterRequired;
    public static string ObjectReaderDictionaryMethod1NotFound;
    public static string ObjectReaderXamlNamedElementAlreadyRegistered;
    public static string ObjectReaderXamlNameScopeResultsInClonedObject;
    public static string ObjectReaderXamlNamePropertyMustBeString;
    public static string ObjectReaderNoDefaultConstructor;
    public static string ObjectReaderNoMatchingConstructor;
    public static string ObjectReaderInstanceDescriptorIncompatibleArgumentTypes;
    public static string ObjectReaderInstanceDescriptorIncompatibleArguments;
    public static string ObjectReaderInstanceDescriptorInvalidMethod;
    public static string ObjectReaderTypeCannotRoundtrip;
    public static string ObjectReaderTypeIsNested;
    public static string ObjectReaderAttachedPropertyNotFound;
    public static string XamlFactoryInvalidXamlNode;
    public static string CannotAddPositionalParameters;
    public static string ObjectReaderMultidimensionalArrayNotSupported;
    public static string ObjectReaderTypeNotAllowed;
    public static string ObjectReader_TypeNotVisible;
    public static string ExpectedObjectMarkupInfo;
    public static string AttachedPropertyOnTypeConvertedOrStringProperty;
    public static string AttachedPropertyOnDictionaryKey;
    public static string MissingNameProvider;
    public static string XamlMarkupExtensionWriterCannotSetSchemaContext;
    public static string XamlMarkupExtensionWriterDuplicateMember;
    public static string XamlMarkupExtensionWriterCannotWriteNonstringValue;
    public static string XamlMarkupExtensionWriterInputInvalid;
    public static string DefaultAttachablePropertyStoreCannotAddInstance;
    public static string UnexpectedConstructorArg;
    public static string ShouldOverrideMethod;
    public static string ExpectedQualifiedTypeName;
    public static string ExpectedQualifiedAssemblyName;
    public static string ExpectedLoadPermission;
    public static string SecurityXmlUnexpectedTag;
    public static string SecurityXmlUnexpectedValue;
    public static string SecurityXmlMissingAttribute;
    public static string StringIsNullOrEmpty;
    public static string NotSupportedOnUnknownType;
    public static string OnlySupportedOnCollections;
    public static string OnlySupportedOnDictionaries;
    public static string OnlySupportedOnCollectionsAndDictionaries;
    public static string NotSupportedOnUnknownMember;
    public static string NotSupportedOnDirective;
    public static string ArgumentRequired;
    public static string ConverterMustDeriveFromBase;
    public static string ReferenceIsNull;
    public static string MarkupExtensionArrayType;
    public static string MarkupExtensionArrayBadType;
    public static string MarkupExtensionBadStatic;
    public static string MarkupExtensionStaticMember;
    public static string MustBeOfType;
    public static string ToStringNull;
    public static string ConvertToException;
    public static string ConvertFromException;
    public static string ServiceTypeAlreadyAdded;
    public static string QualifiedNameHasWrongFormat;
    public static string ParserAttributeArgsHigh;
    public static string ParserAttributeArgsLow;
    public static string ParserAssemblyLoadVersionMismatch;
    public static string FrugalList_TargetMapCannotHoldAllData;
    public static string FrugalList_CannotPromoteBeyondArray;
    public static string ValueInArrayIsNull;
    public static string InvalidEvent;
}
internal enum System.Xaml.ThreeValuedBool : Enum {
    public byte value__;
    public static ThreeValuedBool NotSet;
    public static ThreeValuedBool False;
    public static ThreeValuedBool True;
}
internal static class System.Xaml.TypeConverterHelper : object {
    private static CultureInfo invariantEnglishUS;
    internal static CultureInfo InvariantEnglishUS { get; }
    private static TypeConverterHelper();
    internal static CultureInfo get_InvariantEnglishUS();
    internal static Type GetConverterType(Type type);
    private static Type GetConverterTypeFromName(string converterName);
    private static TypeConverter GetCoreConverterFromCoreType(Type type);
    internal static TypeConverter GetCoreConverterFromCustomType(Type type);
    internal static TypeConverter GetTypeConverter(Type type);
}
internal class System.Xaml.WeakRefKey : WeakReference {
    private int _hashCode;
    public WeakRefKey(object target);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(WeakRefKey left, WeakRefKey right);
    public static bool op_Inequality(WeakRefKey left, WeakRefKey right);
}
internal class System.Xaml.WriterDelegate : XamlWriter {
    private XamlNodeAddDelegate _addDelegate;
    private XamlLineInfoAddDelegate _addLineInfoDelegate;
    private XamlSchemaContext _schemaContext;
    public XamlSchemaContext SchemaContext { get; }
    public bool ShouldProvideLineInfo { get; }
    public WriterDelegate(XamlNodeAddDelegate add, XamlLineInfoAddDelegate addlineInfoDelegate, XamlSchemaContext xamlSchemaContext);
    public virtual void WriteGetObject();
    public virtual void WriteStartObject(XamlType xamlType);
    public virtual void WriteEndObject();
    public virtual void WriteStartMember(XamlMember member);
    public virtual void WriteEndMember();
    public virtual void WriteValue(object value);
    public virtual void WriteNamespace(NamespaceDeclaration namespaceDeclaration);
    protected virtual void Dispose(bool disposing);
    public virtual XamlSchemaContext get_SchemaContext();
    public sealed virtual void SetLineInfo(int lineNumber, int linePosition);
    public sealed virtual bool get_ShouldProvideLineInfo();
    private void ThrowBecauseWriterIsClosed(XamlNodeType nodeType, object data);
    private void ThrowBecauseWriterIsClosed2(int lineNumber, int linePosition);
    private void ThrowIsDisposed();
}
public class System.Xaml.XamlBackgroundReader : XamlReader {
    private EventWaitHandle _providerFullEvent;
    private EventWaitHandle _dataReceivedEvent;
    private XamlNode[] _incoming;
    private int _inIdx;
    private XamlNode[] _outgoing;
    private int _outIdx;
    private int _outValid;
    private XamlNode _currentNode;
    private XamlReader _wrappedReader;
    private XamlReader _internalReader;
    private XamlWriter _writer;
    private bool _wrappedReaderHasLineInfo;
    private int _lineNumber;
    private int _linePosition;
    private Thread _thread;
    private Exception _caughtException;
    internal bool IncomingFull { get; }
    internal bool OutgoingEmpty { get; }
    public XamlNodeType NodeType { get; }
    public bool IsEof { get; }
    public NamespaceDeclaration Namespace { get; }
    public XamlType Type { get; }
    public object Value { get; }
    public XamlMember Member { get; }
    public XamlSchemaContext SchemaContext { get; }
    public bool HasLineInfo { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public XamlBackgroundReader(XamlReader wrappedReader);
    private void Initialize(XamlReader wrappedReader, int bufferSize);
    public void StartThread();
    public void StartThread(string threadName);
    private void XamlReaderThreadStart(object none);
    internal bool get_IncomingFull();
    internal bool get_OutgoingEmpty();
    private void SwapBuffers();
    private void AddToBuffer(XamlNode node);
    private void Add(XamlNodeType nodeType, object data);
    private void AddLineInfo(int lineNumber, int linePosition);
    private XamlNode Next();
    private XamlNode Next_ProcessLineInfo();
    private void InterruptableTransform(XamlReader reader, XamlWriter writer, bool closeWriter);
    public virtual bool Read();
    public virtual XamlNodeType get_NodeType();
    public virtual bool get_IsEof();
    public virtual NamespaceDeclaration get_Namespace();
    public virtual XamlType get_Type();
    public virtual object get_Value();
    public virtual XamlMember get_Member();
    public virtual XamlSchemaContext get_SchemaContext();
    public sealed virtual bool get_HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    protected virtual void Dispose(bool disposing);
}
public abstract class System.Xaml.XamlDeferringLoader : object {
    public abstract virtual object Load(XamlReader xamlReader, IServiceProvider serviceProvider);
    public abstract virtual XamlReader Save(object value, IServiceProvider serviceProvider);
}
public class System.Xaml.XamlDirective : XamlMember {
    private AllowedMemberLocations _allowedLocation;
    private IList`1<string> _xamlNamespaces;
    public AllowedMemberLocations AllowedLocation { get; }
    internal XamlDirective(IEnumerable`1<string> xamlNamespaces, string name, AllowedMemberLocations allowedLocation, MemberReflector reflector);
    public XamlDirective(IEnumerable`1<string> xamlNamespaces, string name, XamlType xamlType, XamlValueConverter`1<TypeConverter> typeConverter, AllowedMemberLocations allowedLocation);
    public XamlDirective(string xamlNamespace, string name);
    public AllowedMemberLocations get_AllowedLocation();
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual IList`1<string> GetXamlNamespaces();
    internal static bool NamespacesAreEqual(XamlDirective directive1, XamlDirective directive2);
    protected sealed virtual XamlMemberInvoker LookupInvoker();
    protected sealed virtual ICustomAttributeProvider LookupCustomAttributeProvider();
    protected sealed virtual IList`1<XamlMember> LookupDependsOn();
    protected sealed virtual XamlValueConverter`1<XamlDeferringLoader> LookupDeferringLoader();
    protected sealed virtual bool LookupIsAmbient();
    protected sealed virtual bool LookupIsEvent();
    protected sealed virtual bool LookupIsReadOnly();
    protected sealed virtual bool LookupIsReadPublic();
    protected sealed virtual bool LookupIsUnknown();
    protected sealed virtual bool LookupIsWriteOnly();
    protected sealed virtual bool LookupIsWritePublic();
    protected sealed virtual XamlType LookupTargetType();
    protected sealed virtual XamlValueConverter`1<TypeConverter> LookupTypeConverter();
    protected sealed virtual XamlType LookupType();
    protected sealed virtual MethodInfo LookupUnderlyingGetter();
    protected sealed virtual MemberInfo LookupUnderlyingMember();
    protected sealed virtual MethodInfo LookupUnderlyingSetter();
    private static ReadOnlyCollection`1<string> GetReadOnly(string xamlNamespace);
    private static ReadOnlyCollection`1<string> GetReadOnly(IEnumerable`1<string> xamlNamespaces);
}
public class System.Xaml.XamlDuplicateMemberException : XamlException {
    [CompilerGeneratedAttribute]
private XamlMember <DuplicateMember>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <ParentType>k__BackingField;
    public XamlMember DuplicateMember { get; public set; }
    public XamlType ParentType { get; public set; }
    public XamlDuplicateMemberException(XamlMember member, XamlType type);
    public XamlDuplicateMemberException(string message);
    public XamlDuplicateMemberException(string message, Exception innerException);
    protected XamlDuplicateMemberException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public XamlMember get_DuplicateMember();
    [CompilerGeneratedAttribute]
public void set_DuplicateMember(XamlMember value);
    [CompilerGeneratedAttribute]
public XamlType get_ParentType();
    [CompilerGeneratedAttribute]
public void set_ParentType(XamlType value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Xaml.XamlException : Exception {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    public string Message { get; }
    public int LineNumber { get; protected set; }
    public int LinePosition { get; protected set; }
    public XamlException(string message, Exception innerException, int lineNumber, int linePosition);
    public XamlException(string message, Exception innerException);
    public XamlException(string message);
    protected XamlException(SerializationInfo info, StreamingContext context);
    internal void SetLineInfo(int lineNumber, int linePosition);
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
protected void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
protected void set_LinePosition(int value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Xaml.XamlInternalException : XamlException {
    private static string MessagePrefix;
    public XamlInternalException(string message);
    public XamlInternalException(string message, Exception innerException);
    protected XamlInternalException(SerializationInfo info, StreamingContext context);
}
public static class System.Xaml.XamlLanguage : object {
    public static string Xaml2006Namespace;
    public static string Xml1998Namespace;
    internal static string SWMNamespace;
    internal static string PreferredPrefix;
    private static string x_AsyncRecords;
    private static string x_Arguments;
    private static string x_Class;
    private static string x_ClassModifier;
    private static string x_Code;
    private static string x_ConnectionId;
    private static string x_FactoryMethod;
    private static string x_FieldModifier;
    private static string x_Initialization;
    private static string x_Items;
    private static string x_Key;
    private static string x_Members;
    private static string x_ClassAttributes;
    private static string x_Name;
    private static string x_PositionalParameters;
    private static string x_Shared;
    private static string x_Subclass;
    private static string x_SynchronousMode;
    private static string x_TypeArguments;
    private static string x_Uid;
    private static string x_UnknownContent;
    private static string xml_Space;
    private static string xml_Lang;
    private static string xml_Base;
    private static ReadOnlyCollection`1<string> s_xamlNamespaces;
    private static ReadOnlyCollection`1<string> s_xmlNamespaces;
    private static Lazy`1<XamlSchemaContext> s_schemaContext;
    private static Lazy`1<XamlType> s_array;
    private static Lazy`1<XamlType> s_null;
    private static Lazy`1<XamlType> s_reference;
    private static Lazy`1<XamlType> s_static;
    private static Lazy`1<XamlType> s_type;
    private static Lazy`1<XamlType> s_string;
    private static Lazy`1<XamlType> s_double;
    private static Lazy`1<XamlType> s_int32;
    private static Lazy`1<XamlType> s_boolean;
    private static Lazy`1<XamlType> s_member;
    private static Lazy`1<XamlType> s_property;
    private static Lazy`1<XamlType> s_xDataHolder;
    private static Lazy`1<XamlType> s_object;
    private static Lazy`1<XamlType> s_listOfObject;
    private static Lazy`1<XamlType> s_listOfMembers;
    private static Lazy`1<XamlType> s_listOfAttributes;
    private static Lazy`1<XamlType> s_markupExtension;
    private static Lazy`1<XamlType> s_iNameScope;
    private static Lazy`1<XamlType> s_iXmlSerializable;
    private static Lazy`1<XamlType> s_positionalParameterDescriptor;
    private static Lazy`1<XamlType> s_char;
    private static Lazy`1<XamlType> s_single;
    private static Lazy`1<XamlType> s_byte;
    private static Lazy`1<XamlType> s_int16;
    private static Lazy`1<XamlType> s_int64;
    private static Lazy`1<XamlType> s_decimal;
    private static Lazy`1<XamlType> s_uri;
    private static Lazy`1<XamlType> s_timespan;
    private static Lazy`1<ReadOnlyCollection`1<XamlType>> s_allTypes;
    private static Lazy`1<XamlDirective> s_asyncRecords;
    private static Lazy`1<XamlDirective> s_arguments;
    private static Lazy`1<XamlDirective> s_class;
    private static Lazy`1<XamlDirective> s_classModifier;
    private static Lazy`1<XamlDirective> s_code;
    private static Lazy`1<XamlDirective> s_connectionId;
    private static Lazy`1<XamlDirective> s_factoryMethod;
    private static Lazy`1<XamlDirective> s_fieldModifier;
    private static Lazy`1<XamlDirective> s_items;
    private static Lazy`1<XamlDirective> s_initialization;
    private static Lazy`1<XamlDirective> s_key;
    private static Lazy`1<XamlDirective> s_members;
    private static Lazy`1<XamlDirective> s_classAttributes;
    private static Lazy`1<XamlDirective> s_name;
    private static Lazy`1<XamlDirective> s_positionalParameters;
    private static Lazy`1<XamlDirective> s_shared;
    private static Lazy`1<XamlDirective> s_subclass;
    private static Lazy`1<XamlDirective> s_synchronousMode;
    private static Lazy`1<XamlDirective> s_typeArguments;
    private static Lazy`1<XamlDirective> s_uid;
    private static Lazy`1<XamlDirective> s_unknownContent;
    private static Lazy`1<XamlDirective> s_base;
    private static Lazy`1<XamlDirective> s_lang;
    private static Lazy`1<XamlDirective> s_space;
    private static Lazy`1<ReadOnlyCollection`1<XamlDirective>> s_allDirectives;
    public static IList`1<string> XamlNamespaces { get; }
    public static IList`1<string> XmlNamespaces { get; }
    public static XamlType Array { get; }
    public static XamlType Member { get; }
    public static XamlType Null { get; }
    public static XamlType Property { get; }
    public static XamlType Reference { get; }
    public static XamlType Static { get; }
    public static XamlType Type { get; }
    public static XamlType String { get; }
    public static XamlType Double { get; }
    public static XamlType Int32 { get; }
    public static XamlType Boolean { get; }
    public static XamlType XData { get; }
    public static XamlType Object { get; }
    public static XamlType Char { get; }
    public static XamlType Single { get; }
    public static XamlType Byte { get; }
    public static XamlType Int16 { get; }
    public static XamlType Int64 { get; }
    public static XamlType Decimal { get; }
    public static XamlType Uri { get; }
    public static XamlType TimeSpan { get; }
    public static ReadOnlyCollection`1<XamlType> AllTypes { get; }
    public static XamlDirective Arguments { get; }
    public static XamlDirective AsyncRecords { get; }
    public static XamlDirective Class { get; }
    public static XamlDirective ClassModifier { get; }
    public static XamlDirective Code { get; }
    public static XamlDirective ConnectionId { get; }
    public static XamlDirective FactoryMethod { get; }
    public static XamlDirective FieldModifier { get; }
    public static XamlDirective Items { get; }
    public static XamlDirective Initialization { get; }
    public static XamlDirective Key { get; }
    public static XamlDirective Members { get; }
    public static XamlDirective ClassAttributes { get; }
    public static XamlDirective Name { get; }
    public static XamlDirective PositionalParameters { get; }
    public static XamlDirective Shared { get; }
    public static XamlDirective Subclass { get; }
    public static XamlDirective SynchronousMode { get; }
    public static XamlDirective TypeArguments { get; }
    public static XamlDirective Uid { get; }
    public static XamlDirective UnknownContent { get; }
    public static XamlDirective Base { get; }
    public static XamlDirective Lang { get; }
    public static XamlDirective Space { get; }
    public static ReadOnlyCollection`1<XamlDirective> AllDirectives { get; }
    internal static XamlType MarkupExtension { get; }
    internal static XamlType INameScope { get; }
    internal static XamlType PositionalParameterDescriptor { get; }
    internal static XamlType IXmlSerializable { get; }
    private static XamlLanguage();
    public static IList`1<string> get_XamlNamespaces();
    public static IList`1<string> get_XmlNamespaces();
    public static XamlType get_Array();
    public static XamlType get_Member();
    public static XamlType get_Null();
    public static XamlType get_Property();
    public static XamlType get_Reference();
    public static XamlType get_Static();
    public static XamlType get_Type();
    public static XamlType get_String();
    public static XamlType get_Double();
    public static XamlType get_Int32();
    public static XamlType get_Boolean();
    public static XamlType get_XData();
    public static XamlType get_Object();
    public static XamlType get_Char();
    public static XamlType get_Single();
    public static XamlType get_Byte();
    public static XamlType get_Int16();
    public static XamlType get_Int64();
    public static XamlType get_Decimal();
    public static XamlType get_Uri();
    public static XamlType get_TimeSpan();
    public static ReadOnlyCollection`1<XamlType> get_AllTypes();
    public static XamlDirective get_Arguments();
    public static XamlDirective get_AsyncRecords();
    public static XamlDirective get_Class();
    public static XamlDirective get_ClassModifier();
    public static XamlDirective get_Code();
    public static XamlDirective get_ConnectionId();
    public static XamlDirective get_FactoryMethod();
    public static XamlDirective get_FieldModifier();
    public static XamlDirective get_Items();
    public static XamlDirective get_Initialization();
    public static XamlDirective get_Key();
    public static XamlDirective get_Members();
    public static XamlDirective get_ClassAttributes();
    public static XamlDirective get_Name();
    public static XamlDirective get_PositionalParameters();
    public static XamlDirective get_Shared();
    public static XamlDirective get_Subclass();
    public static XamlDirective get_SynchronousMode();
    public static XamlDirective get_TypeArguments();
    public static XamlDirective get_Uid();
    public static XamlDirective get_UnknownContent();
    public static XamlDirective get_Base();
    public static XamlDirective get_Lang();
    public static XamlDirective get_Space();
    public static ReadOnlyCollection`1<XamlDirective> get_AllDirectives();
    internal static XamlType get_MarkupExtension();
    internal static XamlType get_INameScope();
    internal static XamlType get_PositionalParameterDescriptor();
    internal static XamlType get_IXmlSerializable();
    internal static string TypeAlias(Type type);
    internal static XamlDirective LookupXamlDirective(string name);
    internal static XamlType LookupXamlType(string typeNamespace, string typeName);
    internal static Type LookupClrNamespaceType(AssemblyNamespacePair nsPair, string typeName);
    internal static XamlDirective LookupXmlDirective(string name);
    private static ReadOnlyCollection`1<XamlType> GetAllTypes();
    private static ReadOnlyCollection`1<XamlDirective> GetAllDirectives();
    private static XamlSchemaContext GetSchemaContext();
    private static XamlDirective GetXamlDirective(string name);
    private static XamlDirective GetXamlDirective(string name, AllowedMemberLocations allowedLocation, MemberReflector reflector);
    private static XamlDirective GetXamlDirective(string name, XamlType xamlType, XamlValueConverter`1<TypeConverter> typeConverter, AllowedMemberLocations allowedLocation);
    private static XamlDirective GetXmlDirective(string name);
    private static XamlType GetXamlType(Type type);
}
internal class System.Xaml.XamlLineInfoAddDelegate : MulticastDelegate {
    public XamlLineInfoAddDelegate(object object, IntPtr method);
    public virtual void Invoke(int lineNumber, int linePosition);
    public virtual IAsyncResult BeginInvoke(int lineNumber, int linePosition, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Xaml.XamlMarkupExtensionWriter : XamlWriter {
    private StringBuilder sb;
    private Stack`1<Node> nodes;
    private WriterState currentState;
    private XamlXmlWriter xamlXmlWriter;
    private XamlXmlWriterSettings settings;
    private XamlMarkupExtensionWriterSettings meSettings;
    private bool failed;
    public XamlSchemaContext SchemaContext { get; }
    public string MarkupExtensionString { get; }
    public bool Failed { get; }
    public XamlMarkupExtensionWriter(XamlXmlWriter xamlXmlWriter);
    public XamlMarkupExtensionWriter(XamlXmlWriter xamlXmlWriter, XamlMarkupExtensionWriterSettings meSettings);
    private void Initialize(XamlXmlWriter xamlXmlWriter);
    protected virtual void Dispose(bool disposing);
    public virtual XamlSchemaContext get_SchemaContext();
    public void Reset();
    public string get_MarkupExtensionString();
    public bool get_Failed();
    private string LookupPrefix(XamlType type);
    private string LookupPrefix(XamlMember property);
    private void CheckMemberForUniqueness(Node objectNode, XamlMember property);
    public virtual void WriteStartObject(XamlType type);
    public virtual void WriteGetObject();
    public virtual void WriteEndObject();
    public virtual void WriteStartMember(XamlMember property);
    public virtual void WriteEndMember();
    public virtual void WriteNamespace(NamespaceDeclaration namespaceDeclaration);
    public virtual void WriteValue(object value);
}
internal class System.Xaml.XamlMarkupExtensionWriterSettings : object {
    [CompilerGeneratedAttribute]
private bool <ContinueWritingWhenPrefixIsNotFound>k__BackingField;
    public bool ContinueWritingWhenPrefixIsNotFound { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ContinueWritingWhenPrefixIsNotFound();
    [CompilerGeneratedAttribute]
public void set_ContinueWritingWhenPrefixIsNotFound(bool value);
}
public class System.Xaml.XamlMember : object {
    private string _name;
    private XamlType _declaringType;
    private MemberType _memberType;
    private ThreeValuedBool _isNameValid;
    private MemberReflector _reflector;
    [SecurityCriticalAttribute]
private NullableReference`1<MemberInfo> _underlyingMember;
    public XamlType DeclaringType { get; }
    public XamlMemberInvoker Invoker { get; }
    public bool IsUnknown { get; }
    public bool IsReadPublic { get; }
    public bool IsWritePublic { get; }
    public string Name { get; }
    public bool IsNameValid { get; }
    public string PreferredXamlNamespace { get; }
    public XamlType TargetType { get; }
    public XamlType Type { get; }
    public XamlValueConverter`1<TypeConverter> TypeConverter { get; }
    public XamlValueConverter`1<ValueSerializer> ValueSerializer { get; }
    public XamlValueConverter`1<XamlDeferringLoader> DeferringLoader { get; }
    public MemberInfo UnderlyingMember { get; }
    internal NullableReference`1<MemberInfo> UnderlyingMemberInternal { get; }
    public bool IsReadOnly { get; }
    public bool IsWriteOnly { get; }
    public bool IsAttachable { get; }
    public bool IsEvent { get; }
    public bool IsDirective { get; }
    public IList`1<XamlMember> DependsOn { get; }
    public bool IsAmbient { get; }
    public DesignerSerializationVisibility SerializationVisibility { get; }
    public IReadOnlyDictionary`2<char, char> MarkupExtensionBracketCharacters { get; }
    internal string ConstructorArgument { get; }
    internal object DefaultValue { get; }
    internal MethodInfo Getter { get; }
    internal bool HasDefaultValue { get; }
    internal bool HasSerializationVisibility { get; }
    internal MethodInfo Setter { get; }
    private bool IsReadPublicIgnoringType { get; }
    private bool IsWritePublicIgnoringType { get; }
    private bool AreAttributesAvailable { get; }
    private XamlSchemaContext SchemaContext { get; }
    public XamlMember(string name, XamlType declaringType, bool isAttachable);
    public XamlMember(PropertyInfo propertyInfo, XamlSchemaContext schemaContext);
    public XamlMember(PropertyInfo propertyInfo, XamlSchemaContext schemaContext, XamlMemberInvoker invoker);
    [SecuritySafeCriticalAttribute]
internal XamlMember(PropertyInfo propertyInfo, XamlSchemaContext schemaContext, XamlMemberInvoker invoker, MemberReflector reflector);
    public XamlMember(EventInfo eventInfo, XamlSchemaContext schemaContext);
    public XamlMember(EventInfo eventInfo, XamlSchemaContext schemaContext, XamlMemberInvoker invoker);
    [SecuritySafeCriticalAttribute]
internal XamlMember(EventInfo eventInfo, XamlSchemaContext schemaContext, XamlMemberInvoker invoker, MemberReflector reflector);
    public XamlMember(string attachablePropertyName, MethodInfo getter, MethodInfo setter, XamlSchemaContext schemaContext);
    public XamlMember(string attachablePropertyName, MethodInfo getter, MethodInfo setter, XamlSchemaContext schemaContext, XamlMemberInvoker invoker);
    [SecuritySafeCriticalAttribute]
internal XamlMember(string attachablePropertyName, MethodInfo getter, MethodInfo setter, XamlSchemaContext schemaContext, XamlMemberInvoker invoker, MemberReflector reflector);
    public XamlMember(string attachableEventName, MethodInfo adder, XamlSchemaContext schemaContext);
    public XamlMember(string attachableEventName, MethodInfo adder, XamlSchemaContext schemaContext, XamlMemberInvoker invoker);
    [SecuritySafeCriticalAttribute]
internal XamlMember(string attachableEventName, MethodInfo adder, XamlSchemaContext schemaContext, XamlMemberInvoker invoker, MemberReflector reflector);
    internal XamlMember(string name, MemberReflector reflector);
    public XamlType get_DeclaringType();
    public XamlMemberInvoker get_Invoker();
    public bool get_IsUnknown();
    public bool get_IsReadPublic();
    public bool get_IsWritePublic();
    public string get_Name();
    public bool get_IsNameValid();
    public string get_PreferredXamlNamespace();
    public XamlType get_TargetType();
    public XamlType get_Type();
    public XamlValueConverter`1<TypeConverter> get_TypeConverter();
    public XamlValueConverter`1<ValueSerializer> get_ValueSerializer();
    public XamlValueConverter`1<XamlDeferringLoader> get_DeferringLoader();
    [SecuritySafeCriticalAttribute]
public MemberInfo get_UnderlyingMember();
    [SecuritySafeCriticalAttribute]
internal NullableReference`1<MemberInfo> get_UnderlyingMemberInternal();
    public bool get_IsReadOnly();
    public bool get_IsWriteOnly();
    public bool get_IsAttachable();
    public bool get_IsEvent();
    public bool get_IsDirective();
    public virtual IList`1<string> GetXamlNamespaces();
    public virtual string ToString();
    public IList`1<XamlMember> get_DependsOn();
    public bool get_IsAmbient();
    public DesignerSerializationVisibility get_SerializationVisibility();
    public IReadOnlyDictionary`2<char, char> get_MarkupExtensionBracketCharacters();
    internal string get_ConstructorArgument();
    internal object get_DefaultValue();
    internal MethodInfo get_Getter();
    internal bool get_HasDefaultValue();
    internal bool get_HasSerializationVisibility();
    internal MethodInfo get_Setter();
    internal bool IsReadVisibleTo(Assembly accessingAssembly, Type accessingType);
    internal bool IsWriteVisibleTo(Assembly accessingAssembly, Type accessingType);
    protected virtual XamlMemberInvoker LookupInvoker();
    protected virtual ICustomAttributeProvider LookupCustomAttributeProvider();
    protected virtual XamlValueConverter`1<XamlDeferringLoader> LookupDeferringLoader();
    protected virtual IList`1<XamlMember> LookupDependsOn();
    private Nullable`1<DesignerSerializationVisibility> LookupSerializationVisibility();
    protected virtual bool LookupIsAmbient();
    protected virtual bool LookupIsEvent();
    protected virtual bool LookupIsReadPublic();
    protected virtual bool LookupIsReadOnly();
    protected virtual bool LookupIsUnknown();
    protected virtual bool LookupIsWriteOnly();
    protected virtual bool LookupIsWritePublic();
    protected virtual XamlType LookupTargetType();
    protected virtual XamlValueConverter`1<TypeConverter> LookupTypeConverter();
    protected virtual XamlValueConverter`1<ValueSerializer> LookupValueSerializer();
    protected virtual IReadOnlyDictionary`2<char, char> LookupMarkupExtensionBracketCharacters();
    protected virtual XamlType LookupType();
    protected virtual MethodInfo LookupUnderlyingGetter();
    protected virtual MethodInfo LookupUnderlyingSetter();
    protected virtual MemberInfo LookupUnderlyingMember();
    private bool get_IsReadPublicIgnoringType();
    private bool get_IsWritePublicIgnoringType();
    private static void ValidateGetter(MethodInfo method, string argumentName);
    private static void ValidateSetter(MethodInfo method, string argumentName);
    private bool get_AreAttributesAvailable();
    private XamlSchemaContext get_SchemaContext();
    private static bool GetDefaultFlag(BoolMemberBits flagBit);
    private void CreateReflector();
    private void EnsureDefaultValue();
    private void EnsureReflector();
    private bool GetFlag(BoolMemberBits flagBit);
    private bool LookupBooleanValue(BoolMemberBits flag);
    private string LookupConstructorArgument();
    private Type LookupSystemType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(XamlMember other);
    public static bool op_Equality(XamlMember xamlMember1, XamlMember xamlMember2);
    public static bool op_Inequality(XamlMember xamlMember1, XamlMember xamlMember2);
}
[DebuggerDisplayAttribute("{ToString()}")]
internal class System.Xaml.XamlNode : ValueType {
    private XamlNodeType _nodeType;
    private InternalNodeType _internalNodeType;
    private object _data;
    public XamlNodeType NodeType { get; }
    public NamespaceDeclaration NamespaceDeclaration { get; }
    public XamlType XamlType { get; }
    public object Value { get; }
    public XamlMember Member { get; }
    public LineInfo LineInfo { get; }
    internal bool IsEof { get; }
    internal bool IsEndOfAttributes { get; }
    internal bool IsLineInfo { get; }
    public XamlNode(XamlNodeType nodeType);
    public XamlNode(XamlNodeType nodeType, object data);
    public XamlNode(InternalNodeType internalNodeType);
    public XamlNode(LineInfo lineInfo);
    public XamlNodeType get_NodeType();
    public virtual string ToString();
    public NamespaceDeclaration get_NamespaceDeclaration();
    public XamlType get_XamlType();
    public object get_Value();
    public XamlMember get_Member();
    public LineInfo get_LineInfo();
    internal bool get_IsEof();
    internal bool get_IsEndOfAttributes();
    internal bool get_IsLineInfo();
    internal static bool IsEof_Helper(XamlNodeType nodeType, object data);
}
internal class System.Xaml.XamlNodeAddDelegate : MulticastDelegate {
    public XamlNodeAddDelegate(object object, IntPtr method);
    public virtual void Invoke(XamlNodeType nodeType, object data);
    public virtual IAsyncResult BeginInvoke(XamlNodeType nodeType, object data, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Xaml.XamlNodeIndexDelegate : MulticastDelegate {
    public XamlNodeIndexDelegate(object object, IntPtr method);
    public virtual XamlNode Invoke(int idx);
    public virtual IAsyncResult BeginInvoke(int idx, AsyncCallback callback, object object);
    public virtual XamlNode EndInvoke(IAsyncResult result);
}
public class System.Xaml.XamlNodeList : object {
    private List`1<XamlNode> _nodeList;
    private bool _readMode;
    private XamlWriter _writer;
    private bool _hasLineInfo;
    public XamlWriter Writer { get; }
    public int Count { get; }
    public XamlNodeList(XamlSchemaContext schemaContext);
    public XamlNodeList(XamlSchemaContext schemaContext, int size);
    private void Initialize(XamlSchemaContext schemaContext, int size);
    public XamlWriter get_Writer();
    public XamlReader GetReader();
    private void Add(XamlNodeType nodeType, object data);
    private void AddLineInfo(int lineNumber, int linePosition);
    private XamlNode Index(int idx);
    public void Clear();
    public int get_Count();
}
internal class System.Xaml.XamlNodeNextDelegate : MulticastDelegate {
    public XamlNodeNextDelegate(object object, IntPtr method);
    public virtual XamlNode Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual XamlNode EndInvoke(IAsyncResult result);
}
public class System.Xaml.XamlNodeQueue : object {
    private Queue`1<XamlNode> _nodeQueue;
    private XamlNode _endOfStreamNode;
    private ReaderDelegate _reader;
    private XamlWriter _writer;
    private bool _hasLineInfo;
    public XamlReader Reader { get; }
    public XamlWriter Writer { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public XamlNodeQueue(XamlSchemaContext schemaContext);
    public XamlReader get_Reader();
    public XamlWriter get_Writer();
    public bool get_IsEmpty();
    public int get_Count();
    private void Add(XamlNodeType nodeType, object data);
    private void AddLineInfo(int lineNumber, int linePosition);
    private XamlNode Next();
}
public enum System.Xaml.XamlNodeType : Enum {
    public byte value__;
    public static XamlNodeType None;
    public static XamlNodeType StartObject;
    public static XamlNodeType GetObject;
    public static XamlNodeType EndObject;
    public static XamlNodeType StartMember;
    public static XamlNodeType EndMember;
    public static XamlNodeType Value;
    public static XamlNodeType NamespaceDeclaration;
}
public class System.Xaml.XamlObjectEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceBamlUri>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ElementLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ElementLinePosition>k__BackingField;
    public object Instance { get; private set; }
    public Uri SourceBamlUri { get; private set; }
    public int ElementLineNumber { get; private set; }
    public int ElementLinePosition { get; private set; }
    public XamlObjectEventArgs(object instance);
    internal XamlObjectEventArgs(object instance, Uri sourceBamlUri, int elementLineNumber, int elementLinePosition);
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(object value);
    [CompilerGeneratedAttribute]
public Uri get_SourceBamlUri();
    [CompilerGeneratedAttribute]
private void set_SourceBamlUri(Uri value);
    [CompilerGeneratedAttribute]
public int get_ElementLineNumber();
    [CompilerGeneratedAttribute]
private void set_ElementLineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_ElementLinePosition();
    [CompilerGeneratedAttribute]
private void set_ElementLinePosition(int value);
}
public class System.Xaml.XamlObjectReader : XamlReader {
    private XamlObjectReaderSettings settings;
    private XamlSchemaContext schemaContext;
    private XamlNode currentXamlNode;
    private object currentInstance;
    private Stack`1<MarkupInfo> nodes;
    public XamlNodeType NodeType { get; }
    public NamespaceDeclaration Namespace { get; }
    public XamlType Type { get; }
    public XamlMember Member { get; }
    public object Value { get; }
    public XamlSchemaContext SchemaContext { get; }
    public bool IsEof { get; }
    public object Instance { get; }
    public XamlObjectReader(object instance);
    public XamlObjectReader(object instance, XamlObjectReaderSettings settings);
    public XamlObjectReader(object instance, XamlSchemaContext schemaContext);
    public XamlObjectReader(object instance, XamlSchemaContext schemaContext, XamlObjectReaderSettings settings);
    public virtual bool Read();
    public virtual XamlNodeType get_NodeType();
    public virtual NamespaceDeclaration get_Namespace();
    public virtual XamlType get_Type();
    public virtual XamlMember get_Member();
    public virtual object get_Value();
    public virtual XamlSchemaContext get_SchemaContext();
    public virtual bool get_IsEof();
    public virtual object get_Instance();
    internal static DesignerSerializationVisibility GetSerializationVisibility(XamlMember member);
    internal static string GetConstructorArgument(XamlMember member);
    internal static bool GetDefaultValue(XamlMember member, Object& value);
}
public class System.Xaml.XamlObjectReaderException : XamlException {
    public XamlObjectReaderException(string message);
    public XamlObjectReaderException(string message, Exception innerException);
    protected XamlObjectReaderException(SerializationInfo info, StreamingContext context);
}
public class System.Xaml.XamlObjectReaderSettings : XamlReaderSettings {
    [CompilerGeneratedAttribute]
private bool <RequireExplicitContentVisibility>k__BackingField;
    public bool RequireExplicitContentVisibility { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_RequireExplicitContentVisibility();
    [CompilerGeneratedAttribute]
public void set_RequireExplicitContentVisibility(bool value);
}
public class System.Xaml.XamlObjectWriter : XamlWriter {
    private object _lastInstance;
    private bool _inDispose;
    private ObjectWriterContext _context;
    private DeferringWriter _deferringWriter;
    private EventHandler`1<XamlObjectEventArgs> _afterBeginInitHandler;
    private EventHandler`1<XamlObjectEventArgs> _beforePropertiesHandler;
    private EventHandler`1<XamlObjectEventArgs> _afterPropertiesHandler;
    private EventHandler`1<XamlObjectEventArgs> _afterEndInitHandler;
    private EventHandler`1<XamlSetValueEventArgs> _xamlSetValueHandler;
    private object _rootObjectInstance;
    private bool _skipDuplicatePropertyCheck;
    private NameFixupGraph _nameFixupGraph;
    private Dictionary`2<object, List`1<PendingCollectionAdd>> _pendingCollectionAdds;
    private INameScope _rootNamescope;
    private bool _skipProvideValueOnRoot;
    private bool _nextNodeMustBeEndMember;
    private bool _preferUnconvertedDictionaryKeys;
    private Dictionary`2<object, ObjectWriterContext> _pendingKeyConversionContexts;
    private NameFixupGraph NameFixupGraph { get; }
    private Dictionary`2<object, List`1<PendingCollectionAdd>> PendingCollectionAdds { get; }
    private Dictionary`2<object, ObjectWriterContext> PendingKeyConversionContexts { get; }
    private XamlRuntime Runtime { get; }
    public INameScope RootNameScope { get; }
    public object Result { get; }
    public XamlSchemaContext SchemaContext { get; }
    public bool ShouldProvideLineInfo { get; }
    public XamlObjectWriter(XamlSchemaContext schemaContext);
    public XamlObjectWriter(XamlSchemaContext schemaContext, XamlObjectWriterSettings settings);
    internal XamlObjectWriter(XamlSavedContext savedContext, XamlObjectWriterSettings settings);
    private void Initialize(XamlSchemaContext schemaContext, XamlSavedContext savedContext, XamlObjectWriterSettings settings);
    private XamlRuntime CreateRuntime(XamlObjectWriterSettings settings, XamlSchemaContext schemaContext);
    protected virtual void OnAfterBeginInit(object value);
    protected virtual void OnBeforeProperties(object value);
    protected virtual void OnAfterProperties(object value);
    protected virtual void OnAfterEndInit(object value);
    protected virtual bool OnSetValue(object eventSender, XamlMember member, object value);
    private NameFixupGraph get_NameFixupGraph();
    private bool HasUnresolvedChildren(object parent);
    private Dictionary`2<object, List`1<PendingCollectionAdd>> get_PendingCollectionAdds();
    private Dictionary`2<object, ObjectWriterContext> get_PendingKeyConversionContexts();
    private XamlRuntime get_Runtime();
    private void TryCreateParentInstance(ObjectWriterContext ctx);
    public virtual void WriteGetObject();
    public virtual void WriteStartObject(XamlType xamlType);
    public virtual void WriteEndObject();
    public virtual void WriteStartMember(XamlMember property);
    public virtual void WriteEndMember();
    public virtual void WriteValue(object value);
    public virtual void WriteNamespace(NamespaceDeclaration namespaceDeclaration);
    public void Clear();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    public INameScope get_RootNameScope();
    public virtual object get_Result();
    public virtual XamlSchemaContext get_SchemaContext();
    public sealed virtual void SetLineInfo(int lineNumber, int linePosition);
    public sealed virtual bool get_ShouldProvideLineInfo();
    private sealed virtual override XamlException MS.Internal.Xaml.Runtime.IAddLineInfo.WithLineInfo(XamlException ex);
    private object GetKeyFromInstance(object instance, XamlType instanceType, IAddLineInfo lineInfo);
    private XamlType GetXamlType(Type clrType);
    private bool IsConstructionDirective(XamlMember xamlMember);
    private bool IsTextConstructionDirective(XamlMember xamlMember);
    private bool IsDirectiveAllowedOnNullInstance(XamlMember xamlMember, XamlType xamlType);
    private void Logic_CreateAndAssignToParentStart(ObjectWriterContext ctx);
    private void Logic_ConvertPositionalParamsToArgs(ObjectWriterContext ctx);
    private void Logic_CreateFromInitializationValue(ObjectWriterContext ctx);
    private object Logic_CreateFromValue(ObjectWriterContext ctx, XamlValueConverter`1<TypeConverter> typeConverter, object value, XamlMember property, string targetName);
    private object Logic_CreateFromValue(ObjectWriterContext ctx, XamlValueConverter`1<TypeConverter> typeConverter, object value, XamlMember property, string targetName, IAddLineInfo lineInfo);
    private bool Logic_CreatePropertyValueFromValue(ObjectWriterContext ctx);
    private bool Logic_ShouldConvertKey(ObjectWriterContext ctx);
    private static bool IsBuiltInGenericDictionary(Type type);
    private void Logic_BeginInit(ObjectWriterContext ctx);
    private void Logic_EndInit(ObjectWriterContext ctx);
    private void Logic_DeferProvideValue(ObjectWriterContext ctx);
    private void Logic_DuplicatePropertyCheck(ObjectWriterContext ctx, XamlMember property, bool onParent);
    private void Logic_ApplyCurrentPreconstructionPropertyValues(ObjectWriterContext ctx);
    private void Logic_ApplyCurrentPreconstructionPropertyValues(ObjectWriterContext ctx, bool skipDirectives);
    private object Logic_PushAndPopAProvideValueStackFrame(ObjectWriterContext ctx, XamlMember prop, MarkupExtension me, bool useIRME);
    private void Logic_ApplyPropertyValue(ObjectWriterContext ctx, XamlMember prop, object value, bool onParent);
    private void Logic_CheckBaseUri(ObjectWriterContext ctx, string value);
    private void Logic_AssignProvidedValue(ObjectWriterContext ctx);
    private bool Logic_ProvideValue(ObjectWriterContext ctx);
    private void Logic_PendCurrentFixupToken_SetValue(ObjectWriterContext ctx, NameFixupToken token);
    private void Logic_CheckAssignmentToParentStart(ObjectWriterContext ctx);
    private void Logic_DoAssignmentToParentCollection(ObjectWriterContext ctx);
    private bool Logic_WillParentCollectionAdd(ObjectWriterContext ctx, Type type, bool excludeObjectType);
    private void Logic_AddToParentDictionary(ObjectWriterContext ctx, object key, object value);
    private bool Logic_PendAssignmentToParentCollection(ObjectWriterContext ctx, object key, bool keyIsSet);
    private void Logic_DoAssignmentToParentProperty(ObjectWriterContext ctx);
    private void Logic_PendKeyFixupToken(ObjectWriterContext ctx, NameFixupToken token);
    private void Logic_RegisterName_OnCurrent(ObjectWriterContext ctx, string name);
    private void Logic_RegisterName_OnParent(ObjectWriterContext ctx, string name);
    private void RegisterName(ObjectWriterContext ctx, string name, object inst, XamlType xamlType, INameScope nameScope, INameScope parentNameScope, bool isRoot);
    private void Logic_SetConnectionId(ObjectWriterContext ctx, int connectionId, object instance);
    private void SetValue(object inst, XamlMember property, object value);
    private void Logic_ValidateXClass(ObjectWriterContext ctx, object value);
    private void Logic_AddDependencyForUnresolvedChildren(ObjectWriterContext ctx, XamlSavedContext deferredMarkupExtensionContext);
    private NameFixupToken GetTokenForUnresolvedChildren(object childThatHasUnresolvedChildren, XamlMember property, XamlSavedContext deferredMarkupExtensionContext);
    private void CompleteNameReferences();
    private void ThrowUnresolvedRefs(IEnumerable`1<NameFixupToken> unresolvedRefs);
    private void TriggerNameResolution(object instance, string name);
    private sealed virtual override bool MS.Internal.Xaml.Context.ICheckIfInitialized.IsFullyInitialized(object instance);
    private void CompleteDeferredInitialization(FixupTarget target);
    private void ProcessNameFixup(NameFixupToken token, bool nameResolutionIsComplete);
    private void ProcessNameFixup_Simple(NameFixupToken token);
    private void ProcessNameFixup_Reparse(NameFixupToken token, bool nameResolutionIsComplete);
    private void ProcessNameFixup_UpdatePendingAddKey(NameFixupToken token, object key);
    private void ProcessNameFixup_UpdatePendingAddItem(NameFixupToken token, object item);
    private void ExecutePendingAdds(XamlType instanceType, object instance);
}
public class System.Xaml.XamlObjectWriterException : XamlException {
    public XamlObjectWriterException(string message);
    public XamlObjectWriterException(string message, Exception innerException);
    protected XamlObjectWriterException(SerializationInfo info, StreamingContext context);
}
public class System.Xaml.XamlObjectWriterSettings : XamlWriterSettings {
    [CompilerGeneratedAttribute]
private EventHandler`1<XamlObjectEventArgs> <AfterBeginInitHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<XamlObjectEventArgs> <BeforePropertiesHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<XamlObjectEventArgs> <AfterPropertiesHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<XamlObjectEventArgs> <AfterEndInitHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<XamlSetValueEventArgs> <XamlSetValueHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RootObjectInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCanConvert>k__BackingField;
    [CompilerGeneratedAttribute]
private INameScope <ExternalNameScope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipDuplicatePropertyCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RegisterNamesOnExternalNamescope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipProvideValueOnRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferUnconvertedDictionaryKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceBamlUri>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlAccessLevel <AccessLevel>k__BackingField;
    public EventHandler`1<XamlObjectEventArgs> AfterBeginInitHandler { get; public set; }
    public EventHandler`1<XamlObjectEventArgs> BeforePropertiesHandler { get; public set; }
    public EventHandler`1<XamlObjectEventArgs> AfterPropertiesHandler { get; public set; }
    public EventHandler`1<XamlObjectEventArgs> AfterEndInitHandler { get; public set; }
    public EventHandler`1<XamlSetValueEventArgs> XamlSetValueHandler { get; public set; }
    public object RootObjectInstance { get; public set; }
    public bool IgnoreCanConvert { get; public set; }
    public INameScope ExternalNameScope { get; public set; }
    public bool SkipDuplicatePropertyCheck { get; public set; }
    public bool RegisterNamesOnExternalNamescope { get; public set; }
    public bool SkipProvideValueOnRoot { get; public set; }
    public bool PreferUnconvertedDictionaryKeys { get; public set; }
    public Uri SourceBamlUri { get; public set; }
    public XamlAccessLevel AccessLevel { get; public set; }
    public XamlObjectWriterSettings(XamlObjectWriterSettings settings);
    [CompilerGeneratedAttribute]
public EventHandler`1<XamlObjectEventArgs> get_AfterBeginInitHandler();
    [CompilerGeneratedAttribute]
public void set_AfterBeginInitHandler(EventHandler`1<XamlObjectEventArgs> value);
    [CompilerGeneratedAttribute]
public EventHandler`1<XamlObjectEventArgs> get_BeforePropertiesHandler();
    [CompilerGeneratedAttribute]
public void set_BeforePropertiesHandler(EventHandler`1<XamlObjectEventArgs> value);
    [CompilerGeneratedAttribute]
public EventHandler`1<XamlObjectEventArgs> get_AfterPropertiesHandler();
    [CompilerGeneratedAttribute]
public void set_AfterPropertiesHandler(EventHandler`1<XamlObjectEventArgs> value);
    [CompilerGeneratedAttribute]
public EventHandler`1<XamlObjectEventArgs> get_AfterEndInitHandler();
    [CompilerGeneratedAttribute]
public void set_AfterEndInitHandler(EventHandler`1<XamlObjectEventArgs> value);
    [CompilerGeneratedAttribute]
public EventHandler`1<XamlSetValueEventArgs> get_XamlSetValueHandler();
    [CompilerGeneratedAttribute]
public void set_XamlSetValueHandler(EventHandler`1<XamlSetValueEventArgs> value);
    [CompilerGeneratedAttribute]
public object get_RootObjectInstance();
    [CompilerGeneratedAttribute]
public void set_RootObjectInstance(object value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCanConvert();
    [CompilerGeneratedAttribute]
public void set_IgnoreCanConvert(bool value);
    [CompilerGeneratedAttribute]
public INameScope get_ExternalNameScope();
    [CompilerGeneratedAttribute]
public void set_ExternalNameScope(INameScope value);
    [CompilerGeneratedAttribute]
public bool get_SkipDuplicatePropertyCheck();
    [CompilerGeneratedAttribute]
public void set_SkipDuplicatePropertyCheck(bool value);
    [CompilerGeneratedAttribute]
public bool get_RegisterNamesOnExternalNamescope();
    [CompilerGeneratedAttribute]
public void set_RegisterNamesOnExternalNamescope(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipProvideValueOnRoot();
    [CompilerGeneratedAttribute]
public void set_SkipProvideValueOnRoot(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreferUnconvertedDictionaryKeys();
    [CompilerGeneratedAttribute]
public void set_PreferUnconvertedDictionaryKeys(bool value);
    [CompilerGeneratedAttribute]
public Uri get_SourceBamlUri();
    [CompilerGeneratedAttribute]
public void set_SourceBamlUri(Uri value);
    [CompilerGeneratedAttribute]
public XamlAccessLevel get_AccessLevel();
    [CompilerGeneratedAttribute]
public void set_AccessLevel(XamlAccessLevel value);
    internal XamlObjectWriterSettings StripDelegates();
}
public class System.Xaml.XamlParseException : XamlException {
    internal XamlParseException(MeScanner meScanner, string message);
    internal XamlParseException(XamlScanner xamlScanner, string message);
    internal XamlParseException(int lineNumber, int linePosition, string message);
    public XamlParseException(string message);
    public XamlParseException(string message, Exception innerException);
    protected XamlParseException(SerializationInfo info, StreamingContext context);
}
internal class System.Xaml.XamlPropertySet : object {
    private Dictionary`2<XamlMember, bool> dictionary;
    public bool Contains(XamlMember member);
    public void Add(XamlMember member);
}
public abstract class System.Xaml.XamlReader : object {
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public XamlNodeType NodeType { get; }
    public bool IsEof { get; }
    public NamespaceDeclaration Namespace { get; }
    public XamlType Type { get; }
    public object Value { get; }
    public XamlMember Member { get; }
    public XamlSchemaContext SchemaContext { get; }
    protected bool IsDisposed { get; private set; }
    public abstract virtual bool Read();
    public abstract virtual XamlNodeType get_NodeType();
    public abstract virtual bool get_IsEof();
    public abstract virtual NamespaceDeclaration get_Namespace();
    public abstract virtual XamlType get_Type();
    public abstract virtual object get_Value();
    public abstract virtual XamlMember get_Member();
    public abstract virtual XamlSchemaContext get_SchemaContext();
    public virtual void Skip();
    private sealed virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
protected bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    protected virtual void Dispose(bool disposing);
    public void Close();
    public virtual XamlReader ReadSubtree();
    private void SkipFromTo(XamlNodeType startNodeType, XamlNodeType endNodeType);
}
public class System.Xaml.XamlReaderSettings : object {
    [CompilerGeneratedAttribute]
private bool <AllowProtectedMembersOnRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProvideLineInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <LocalAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreUidsOnPropertyElements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValuesMustBeString>k__BackingField;
    public bool AllowProtectedMembersOnRoot { get; public set; }
    public bool ProvideLineInfo { get; public set; }
    public Uri BaseUri { get; public set; }
    public Assembly LocalAssembly { get; public set; }
    public bool IgnoreUidsOnPropertyElements { get; public set; }
    public bool ValuesMustBeString { get; public set; }
    public XamlReaderSettings(XamlReaderSettings settings);
    [CompilerGeneratedAttribute]
public bool get_AllowProtectedMembersOnRoot();
    [CompilerGeneratedAttribute]
public void set_AllowProtectedMembersOnRoot(bool value);
    [CompilerGeneratedAttribute]
public bool get_ProvideLineInfo();
    [CompilerGeneratedAttribute]
public void set_ProvideLineInfo(bool value);
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    [CompilerGeneratedAttribute]
public void set_BaseUri(Uri value);
    [CompilerGeneratedAttribute]
public Assembly get_LocalAssembly();
    [CompilerGeneratedAttribute]
public void set_LocalAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreUidsOnPropertyElements();
    [CompilerGeneratedAttribute]
public void set_IgnoreUidsOnPropertyElements(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValuesMustBeString();
    [CompilerGeneratedAttribute]
public void set_ValuesMustBeString(bool value);
    private void InitializeProvideLineInfo();
}
internal class System.Xaml.XamlSavedContext : object {
    private XamlSchemaContext _context;
    private XamlContextStack`1<ObjectWriterFrame> _stack;
    private SavedContextType _savedContextType;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    public SavedContextType SaveContextType { get; }
    public XamlContextStack`1<ObjectWriterFrame> Stack { get; }
    public XamlSchemaContext SchemaContext { get; }
    public Uri BaseUri { get; private set; }
    public XamlSavedContext(SavedContextType savedContextType, ObjectWriterContext owContext, XamlContextStack`1<ObjectWriterFrame> stack);
    public SavedContextType get_SaveContextType();
    public XamlContextStack`1<ObjectWriterFrame> get_Stack();
    public XamlSchemaContext get_SchemaContext();
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    [CompilerGeneratedAttribute]
private void set_BaseUri(Uri value);
}
public class System.Xaml.XamlSchemaContext : object {
    private static int ConcurrencyLevel;
    private static int DictionaryCapacity;
    private ReadOnlyCollection`1<Assembly> _referenceAssemblies;
    private object _syncExaminingAssemblies;
    private IList`1<string> _nonClrNamespaces;
    private ConcurrentDictionary`2<string, string> _preferredPrefixes;
    private ConcurrentDictionary`2<string, string> _xmlNsCompatDict;
    private ConcurrentDictionary`2<Type, XamlType> _masterTypeList;
    private ConcurrentDictionary`2<ReferenceEqualityTuple`3<Type, XamlType, Type>, object> _masterValueConverterList;
    private ConcurrentDictionary`2<ReferenceEqualityTuple`2<MemberInfo, MemberInfo>, XamlMember> _masterMemberList;
    private ConcurrentDictionary`2<XamlType, Dictionary`2<string, SpecialBracketCharacters>> _masterBracketCharacterCache;
    private XamlSchemaContextSettings _settings;
    private ConcurrentDictionary`2<string, XamlNamespace> _namespaceByUriList;
    private ConcurrentDictionary`2<Assembly, XmlNsInfo> _xmlnsInfo;
    private ConcurrentDictionary`2<WeakRefKey, XmlNsInfo> _xmlnsInfoForDynamicAssemblies;
    private ConcurrentDictionary`2<Assembly, XmlNsInfo> _xmlnsInfoForUnreferencedAssemblies;
    private AssemblyLoadHandler _assemblyLoadHandler;
    private IList`1<Assembly> _unexaminedAssemblies;
    private bool _isGCCallbackPending;
    private object _syncAccessingUnexaminedAssemblies;
    private AssemblyName[] _referenceAssemblyNames;
    private ConcurrentDictionary`2<string, string> XmlNsCompatDict { get; }
    private ConcurrentDictionary`2<XamlType, Dictionary`2<string, SpecialBracketCharacters>> MasterBracketCharacterCache { get; }
    private ConcurrentDictionary`2<Type, XamlType> MasterTypeList { get; }
    private ConcurrentDictionary`2<ReferenceEqualityTuple`3<Type, XamlType, Type>, object> MasterValueConverterList { get; }
    private ConcurrentDictionary`2<ReferenceEqualityTuple`2<MemberInfo, MemberInfo>, XamlMember> MasterMemberList { get; }
    public bool SupportMarkupExtensionsWithDuplicateArity { get; }
    public bool FullyQualifyAssemblyNamesInClrNamespaces { get; }
    public IList`1<Assembly> ReferenceAssemblies { get; }
    private ConcurrentDictionary`2<Assembly, XmlNsInfo> XmlnsInfo { get; }
    private ConcurrentDictionary`2<WeakRefKey, XmlNsInfo> XmlnsInfoForDynamicAssemblies { get; }
    private ConcurrentDictionary`2<string, XamlNamespace> NamespaceByUriList { get; }
    private ConcurrentDictionary`2<Assembly, XmlNsInfo> XmlnsInfoForUnreferencedAssemblies { get; }
    public XamlSchemaContext(XamlSchemaContextSettings settings);
    public XamlSchemaContext(IEnumerable`1<Assembly> referenceAssemblies);
    public XamlSchemaContext(IEnumerable`1<Assembly> referenceAssemblies, XamlSchemaContextSettings settings);
    protected virtual override void Finalize();
    public virtual ICollection`1<XamlType> GetAllXamlTypes(string xamlNamespace);
    public virtual IEnumerable`1<string> GetAllXamlNamespaces();
    public virtual string GetPreferredPrefix(string xmlns);
    private string GetPrefixForClrNs(string clrNs, string assemblyName);
    private void InitializePreferredPrefixes();
    private void UpdatePreferredPrefixes(XmlNsInfo newNamespaces, ConcurrentDictionary`2<string, string> prefixDict);
    public virtual XamlDirective GetXamlDirective(string xamlNamespace, string name);
    public XamlType GetXamlType(XamlTypeName xamlTypeName);
    protected internal virtual XamlType GetXamlType(string xamlNamespace, string name, XamlType[] typeArguments);
    private ConcurrentDictionary`2<string, string> get_XmlNsCompatDict();
    public virtual bool TryGetCompatibleXamlNamespace(string xamlNamespace, String& compatibleNamespace);
    private string GetCompatibleNamespace(string oldNs);
    private ConcurrentDictionary`2<XamlType, Dictionary`2<string, SpecialBracketCharacters>> get_MasterBracketCharacterCache();
    private ConcurrentDictionary`2<Type, XamlType> get_MasterTypeList();
    private ConcurrentDictionary`2<ReferenceEqualityTuple`3<Type, XamlType, Type>, object> get_MasterValueConverterList();
    private ConcurrentDictionary`2<ReferenceEqualityTuple`2<MemberInfo, MemberInfo>, XamlMember> get_MasterMemberList();
    public virtual XamlType GetXamlType(Type type);
    internal XamlType GetXamlType(Type type, string alias);
    internal Dictionary`2<string, SpecialBracketCharacters> InitBracketCharacterCacheForType(XamlType type);
    private Dictionary`2<string, SpecialBracketCharacters> BuildBracketCharacterCacheForType(XamlType type);
    protected internal XamlValueConverter`1<TConverterBase> GetValueConverter(Type converterType, XamlType targetType);
    internal virtual XamlMember GetProperty(PropertyInfo pi);
    internal virtual XamlMember GetEvent(EventInfo ei);
    internal virtual XamlMember GetAttachableProperty(string name, MethodInfo getter, MethodInfo setter);
    internal virtual XamlMember GetAttachableEvent(string name, MethodInfo adder);
    public bool get_SupportMarkupExtensionsWithDuplicateArity();
    public bool get_FullyQualifyAssemblyNamesInClrNamespaces();
    public IList`1<Assembly> get_ReferenceAssemblies();
    private ConcurrentDictionary`2<Assembly, XmlNsInfo> get_XmlnsInfo();
    private ConcurrentDictionary`2<WeakRefKey, XmlNsInfo> get_XmlnsInfoForDynamicAssemblies();
    private ConcurrentDictionary`2<string, XamlNamespace> get_NamespaceByUriList();
    private ConcurrentDictionary`2<Assembly, XmlNsInfo> get_XmlnsInfoForUnreferencedAssemblies();
    internal bool AreInternalsVisibleTo(Assembly fromAssembly, Assembly toAssembly);
    private static void CleanupCollectedAssemblies(object schemaContextWeakRef);
    private void CleanupCollectedAssemblies();
    private void RegisterAssemblyCleanup();
    private IEnumerable`1<XmlNsInfo> EnumerateXmlnsInfos();
    [IteratorStateMachineAttribute("System.Xaml.XamlSchemaContext/<EnumerateStaticAndDynamicXmlnsInfos>d__74")]
private IEnumerable`1<XmlNsInfo> EnumerateStaticAndDynamicXmlnsInfos();
    internal string GetRootNamespace(Assembly asm);
    internal ReadOnlyCollection`1<string> GetXamlNamespaces(XamlType type);
    private XamlNamespace GetXamlNamespace(string xmlns);
    private XmlNsInfo GetXmlNsInfo(Assembly assembly);
    private ReadOnlyCollection`1<string> GetXmlNsMappings(Assembly assembly, string clrNs);
    private void InitializeAssemblyLoadHook();
    private void SchemaContextAssemblyLoadEventHandler(object sender, AssemblyLoadEventArgs args);
    private void UpdateXmlNsInfo();
    private bool UpdateXmlNsInfo(XmlNsInfo nsInfo);
    private bool UpdateNamespaceByUriList(XmlNsInfo nsInfo);
    internal static string GetAssemblyShortName(Assembly assembly);
    internal static ConcurrentDictionary`2<K, V> CreateDictionary();
    internal static ConcurrentDictionary`2<K, V> CreateDictionary(IEqualityComparer`1<K> comparer);
    internal static V TryAdd(ConcurrentDictionary`2<K, V> dictionary, K key, V value);
    internal static V TryUpdate(ConcurrentDictionary`2<K, V> dictionary, K key, V value, V comparand);
    protected internal virtual Assembly OnAssemblyResolve(string assemblyName);
    private Assembly ResolveReferenceAssembly(string assemblyName);
    private static bool AssemblySatisfiesReference(AssemblyName assemblyName, AssemblyName reference);
    private Assembly ResolveAssembly(string assemblyName);
}
public class System.Xaml.XamlSchemaContextSettings : object {
    [CompilerGeneratedAttribute]
private bool <SupportMarkupExtensionsWithDuplicateArity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FullyQualifyAssemblyNamesInClrNamespaces>k__BackingField;
    public bool SupportMarkupExtensionsWithDuplicateArity { get; public set; }
    public bool FullyQualifyAssemblyNamesInClrNamespaces { get; public set; }
    public XamlSchemaContextSettings(XamlSchemaContextSettings settings);
    [CompilerGeneratedAttribute]
public bool get_SupportMarkupExtensionsWithDuplicateArity();
    [CompilerGeneratedAttribute]
public void set_SupportMarkupExtensionsWithDuplicateArity(bool value);
    [CompilerGeneratedAttribute]
public bool get_FullyQualifyAssemblyNamesInClrNamespaces();
    [CompilerGeneratedAttribute]
public void set_FullyQualifyAssemblyNamesInClrNamespaces(bool value);
}
public class System.Xaml.XamlSchemaException : XamlException {
    public XamlSchemaException(string message);
    public XamlSchemaException(string message, Exception innerException);
    protected XamlSchemaException(SerializationInfo info, StreamingContext context);
}
public static class System.Xaml.XamlServices : object {
    public static object Parse(string xaml);
    public static object Load(string fileName);
    public static object Load(Stream stream);
    public static object Load(TextReader textReader);
    public static object Load(XmlReader xmlReader);
    public static object Load(XamlReader xamlReader);
    public static void Transform(XamlReader xamlReader, XamlWriter xamlWriter);
    public static void Transform(XamlReader xamlReader, XamlWriter xamlWriter, bool closeWriter);
    public static string Save(object instance);
    public static void Save(string fileName, object instance);
    public static void Save(Stream stream, object instance);
    public static void Save(TextWriter writer, object instance);
    public static void Save(XmlWriter writer, object instance);
    public static void Save(XamlWriter writer, object instance);
}
internal class System.Xaml.XamlSubreader : XamlReader {
    private XamlReader _reader;
    private IXamlLineInfo _lineInfoReader;
    private bool _done;
    private bool _firstRead;
    private bool _rootIsStartMember;
    private int _depth;
    private bool IsEmpty { get; }
    public XamlNodeType NodeType { get; }
    public bool IsEof { get; }
    public NamespaceDeclaration Namespace { get; }
    public XamlType Type { get; }
    public object Value { get; }
    public XamlMember Member { get; }
    public XamlSchemaContext SchemaContext { get; }
    public bool HasLineInfo { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public XamlSubreader(XamlReader reader);
    public virtual bool Read();
    private bool get_IsEmpty();
    public virtual XamlNodeType get_NodeType();
    public virtual bool get_IsEof();
    public virtual NamespaceDeclaration get_Namespace();
    public virtual XamlType get_Type();
    public virtual object get_Value();
    public virtual XamlMember get_Member();
    public virtual XamlSchemaContext get_SchemaContext();
    public sealed virtual bool get_HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    private bool LimitedRead();
}
public class System.Xaml.XamlType : object {
    private string _name;
    private XamlSchemaContext _schemaContext;
    private IList`1<XamlType> _typeArguments;
    private TypeReflector _reflector;
    [SecurityCriticalAttribute]
private NullableReference`1<Type> _underlyingType;
    private ReadOnlyCollection`1<string> _namespaces;
    private ThreeValuedBool _isNameValid;
    public XamlType BaseType { get; }
    public XamlTypeInvoker Invoker { get; }
    public bool IsNameValid { get; }
    public bool IsUnknown { get; }
    public string Name { get; }
    public string PreferredXamlNamespace { get; }
    public IList`1<XamlType> TypeArguments { get; }
    public Type UnderlyingType { get; }
    internal NullableReference`1<Type> UnderlyingTypeInternal { get; }
    public bool ConstructionRequiresArguments { get; }
    public bool IsArray { get; }
    public bool IsCollection { get; }
    public bool IsConstructible { get; }
    public bool IsDictionary { get; }
    public bool IsGeneric { get; }
    public bool IsMarkupExtension { get; }
    public bool IsNameScope { get; }
    public bool IsNullable { get; }
    public bool IsPublic { get; }
    public bool IsUsableDuringInitialization { get; }
    public bool IsWhitespaceSignificantCollection { get; }
    public bool IsXData { get; }
    public bool TrimSurroundingWhitespace { get; }
    public bool IsAmbient { get; }
    public XamlType KeyType { get; }
    public XamlType ItemType { get; }
    public IList`1<XamlType> AllowedContentTypes { get; }
    public IList`1<XamlType> ContentWrappers { get; }
    public XamlValueConverter`1<TypeConverter> TypeConverter { get; }
    public XamlValueConverter`1<ValueSerializer> ValueSerializer { get; }
    public XamlMember ContentProperty { get; }
    public XamlValueConverter`1<XamlDeferringLoader> DeferringLoader { get; }
    public XamlType MarkupExtensionReturnType { get; }
    public XamlSchemaContext SchemaContext { get; }
    internal bool IsUsableAsReadOnly { get; }
    internal MethodInfo IsReadOnlyMethod { get; }
    internal EventHandler`1<XamlSetMarkupExtensionEventArgs> SetMarkupExtensionHandler { get; }
    internal EventHandler`1<XamlSetTypeConverterEventArgs> SetTypeConverterHandler { get; }
    internal MethodInfo AddMethod { get; }
    internal MethodInfo GetEnumeratorMethod { get; }
    private bool AreAttributesAvailable { get; }
    private BindingFlags ConstructorBindingFlags { get; }
    protected XamlType(string typeName, IList`1<XamlType> typeArguments, XamlSchemaContext schemaContext);
    public XamlType(string unknownTypeNamespace, string unknownTypeName, IList`1<XamlType> typeArguments, XamlSchemaContext schemaContext);
    public XamlType(Type underlyingType, XamlSchemaContext schemaContext);
    public XamlType(Type underlyingType, XamlSchemaContext schemaContext, XamlTypeInvoker invoker);
    [SecuritySafeCriticalAttribute]
internal XamlType(string alias, Type underlyingType, XamlSchemaContext schemaContext, XamlTypeInvoker invoker, TypeReflector reflector);
    public XamlType get_BaseType();
    public XamlTypeInvoker get_Invoker();
    public bool get_IsNameValid();
    public bool get_IsUnknown();
    public string get_Name();
    public string get_PreferredXamlNamespace();
    public IList`1<XamlType> get_TypeArguments();
    [SecuritySafeCriticalAttribute]
public Type get_UnderlyingType();
    [SecuritySafeCriticalAttribute]
internal NullableReference`1<Type> get_UnderlyingTypeInternal();
    public bool get_ConstructionRequiresArguments();
    public bool get_IsArray();
    public bool get_IsCollection();
    public bool get_IsConstructible();
    public bool get_IsDictionary();
    public bool get_IsGeneric();
    public bool get_IsMarkupExtension();
    public bool get_IsNameScope();
    public bool get_IsNullable();
    public bool get_IsPublic();
    public bool get_IsUsableDuringInitialization();
    public bool get_IsWhitespaceSignificantCollection();
    public bool get_IsXData();
    public bool get_TrimSurroundingWhitespace();
    public bool get_IsAmbient();
    public XamlType get_KeyType();
    public XamlType get_ItemType();
    public IList`1<XamlType> get_AllowedContentTypes();
    public IList`1<XamlType> get_ContentWrappers();
    public XamlValueConverter`1<TypeConverter> get_TypeConverter();
    public XamlValueConverter`1<ValueSerializer> get_ValueSerializer();
    public XamlMember get_ContentProperty();
    public XamlValueConverter`1<XamlDeferringLoader> get_DeferringLoader();
    public XamlType get_MarkupExtensionReturnType();
    public XamlSchemaContext get_SchemaContext();
    public XamlMember GetMember(string name);
    public ICollection`1<XamlMember> GetAllMembers();
    public XamlMember GetAliasedProperty(XamlDirective directive);
    public XamlMember GetAttachableMember(string name);
    public ICollection`1<XamlMember> GetAllAttachableMembers();
    public virtual bool CanAssignTo(XamlType xamlType);
    public IList`1<XamlType> GetPositionalParameters(int parameterCount);
    public virtual IList`1<string> GetXamlNamespaces();
    public virtual string ToString();
    internal bool get_IsUsableAsReadOnly();
    internal MethodInfo get_IsReadOnlyMethod();
    internal EventHandler`1<XamlSetMarkupExtensionEventArgs> get_SetMarkupExtensionHandler();
    internal EventHandler`1<XamlSetTypeConverterEventArgs> get_SetTypeConverterHandler();
    internal MethodInfo get_AddMethod();
    internal MethodInfo get_GetEnumeratorMethod();
    internal string GetQualifiedName();
    internal bool IsVisibleTo(Assembly accessingAssembly);
    internal ICollection`1<XamlMember> GetAllExcludedReadOnlyMembers();
    internal IEnumerable`1<ConstructorInfo> GetConstructors();
    internal ConstructorInfo GetConstructor(Type[] paramTypes);
    protected virtual XamlMember LookupAliasedProperty(XamlDirective directive);
    protected virtual IList`1<XamlType> LookupAllowedContentTypes();
    protected virtual XamlType LookupBaseType();
    protected virtual XamlCollectionKind LookupCollectionKind();
    protected virtual bool LookupConstructionRequiresArguments();
    protected virtual XamlMember LookupContentProperty();
    protected virtual IList`1<XamlType> LookupContentWrappers();
    protected virtual ICustomAttributeProvider LookupCustomAttributeProvider();
    protected virtual XamlValueConverter`1<XamlDeferringLoader> LookupDeferringLoader();
    protected virtual bool LookupIsConstructible();
    protected virtual XamlTypeInvoker LookupInvoker();
    protected virtual bool LookupIsMarkupExtension();
    protected virtual bool LookupIsNameScope();
    protected virtual bool LookupIsNullable();
    protected virtual bool LookupIsUnknown();
    protected virtual bool LookupIsWhitespaceSignificantCollection();
    protected virtual XamlType LookupKeyType();
    protected virtual XamlType LookupItemType();
    protected virtual XamlType LookupMarkupExtensionReturnType();
    protected virtual IEnumerable`1<XamlMember> LookupAllAttachableMembers();
    protected virtual IEnumerable`1<XamlMember> LookupAllMembers();
    protected virtual XamlMember LookupMember(string name, bool skipReadOnlyCheck);
    protected virtual XamlMember LookupAttachableMember(string name);
    protected virtual IList`1<XamlType> LookupPositionalParameters(int parameterCount);
    protected virtual Type LookupUnderlyingType();
    protected virtual bool LookupIsPublic();
    protected virtual bool LookupIsXData();
    protected virtual bool LookupIsAmbient();
    protected virtual XamlValueConverter`1<TypeConverter> LookupTypeConverter();
    protected virtual XamlValueConverter`1<ValueSerializer> LookupValueSerializer();
    protected virtual bool LookupTrimSurroundingWhitespace();
    protected virtual bool LookupUsableDuringInitialization();
    protected virtual EventHandler`1<XamlSetMarkupExtensionEventArgs> LookupSetMarkupExtensionHandler();
    protected virtual EventHandler`1<XamlSetTypeConverterEventArgs> LookupSetTypeConverterHandler();
    private bool get_AreAttributesAvailable();
    private BindingFlags get_ConstructorBindingFlags();
    private void AppendTypeName(StringBuilder sb, bool forceNsInitialization);
    private void CreateReflector();
    private void EnsureReflector();
    private XamlCollectionKind GetCollectionKind();
    private bool GetFlag(BoolTypeBits flagBit);
    private XamlMember GetPropertyOrUnknown(string propertyName, bool skipReadOnlyCheck);
    private static bool GetDefaultFlag(BoolTypeBits flagBit);
    [IteratorStateMachineAttribute("System.Xaml.XamlType/<GetPublicAndInternalConstructors>d__151")]
private IEnumerable`1<ConstructorInfo> GetPublicAndInternalConstructors();
    internal static ReadOnlyCollection`1<T> GetReadOnly(IList`1<T> list);
    private static ReadOnlyCollection`1<XamlType> GetTypeArguments(IList`1<XamlType> typeArguments);
    private static ReadOnlyCollection`1<XamlType> GetTypeArguments(Type type, XamlSchemaContext schemaContext);
    private static string GetTypeName(Type type);
    private bool IsNullableGeneric();
    private ICollection`1<XamlMember> LookupAllExcludedReadOnlyMembers();
    private Dictionary`2<int, IList`1<XamlType>> LookupAllPositionalParameters();
    private bool LookupBooleanValue(BoolTypeBits typeBit);
    private bool TryGetAttributeString(Type attributeType, String& result);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(XamlType other);
    public static bool op_Equality(XamlType xamlType1, XamlType xamlType2);
    public static bool op_Inequality(XamlType xamlType1, XamlType xamlType2);
    private static bool typeArgumentsAreEqual(XamlType xamlType1, XamlType xamlType2);
}
public abstract class System.Xaml.XamlWriter : object {
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public XamlSchemaContext SchemaContext { get; }
    protected bool IsDisposed { get; private set; }
    public abstract virtual void WriteGetObject();
    public abstract virtual void WriteStartObject(XamlType type);
    public abstract virtual void WriteEndObject();
    public abstract virtual void WriteStartMember(XamlMember xamlMember);
    public abstract virtual void WriteEndMember();
    public abstract virtual void WriteValue(object value);
    public abstract virtual void WriteNamespace(NamespaceDeclaration namespaceDeclaration);
    public abstract virtual XamlSchemaContext get_SchemaContext();
    public void WriteNode(XamlReader reader);
    [CompilerGeneratedAttribute]
protected bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public void Close();
}
public class System.Xaml.XamlWriterSettings : object {
    public XamlWriterSettings(XamlWriterSettings settings);
}
public class System.Xaml.XamlXmlReader : XamlReader {
    private XamlParserContext _context;
    private IEnumerator`1<XamlNode> _nodeStream;
    private XamlNode _current;
    private LineInfo _currentLineInfo;
    private XamlNode _endOfStreamNode;
    private XamlXmlReaderSettings _mergedSettings;
    public XamlNodeType NodeType { get; }
    public bool IsEof { get; }
    public NamespaceDeclaration Namespace { get; }
    public XamlType Type { get; }
    public object Value { get; }
    public XamlMember Member { get; }
    public XamlSchemaContext SchemaContext { get; }
    public bool HasLineInfo { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public XamlXmlReader(XmlReader xmlReader);
    public XamlXmlReader(XmlReader xmlReader, XamlXmlReaderSettings settings);
    public XamlXmlReader(XmlReader xmlReader, XamlSchemaContext schemaContext);
    public XamlXmlReader(XmlReader xmlReader, XamlSchemaContext schemaContext, XamlXmlReaderSettings settings);
    public XamlXmlReader(string fileName);
    public XamlXmlReader(string fileName, XamlXmlReaderSettings settings);
    public XamlXmlReader(string fileName, XamlSchemaContext schemaContext);
    public XamlXmlReader(string fileName, XamlSchemaContext schemaContext, XamlXmlReaderSettings settings);
    public XamlXmlReader(Stream stream);
    public XamlXmlReader(Stream stream, XamlXmlReaderSettings settings);
    public XamlXmlReader(Stream stream, XamlSchemaContext schemaContext);
    public XamlXmlReader(Stream stream, XamlSchemaContext schemaContext, XamlXmlReaderSettings settings);
    public XamlXmlReader(TextReader textReader);
    public XamlXmlReader(TextReader textReader, XamlXmlReaderSettings settings);
    public XamlXmlReader(TextReader textReader, XamlSchemaContext schemaContext);
    public XamlXmlReader(TextReader textReader, XamlSchemaContext schemaContext, XamlXmlReaderSettings settings);
    private XmlReader CreateXmlReader(string fileName, XamlXmlReaderSettings settings);
    private XmlReader CreateXmlReader(Stream stream, XamlXmlReaderSettings settings);
    private XmlReader CreateXmlReader(TextReader textReader, XamlXmlReaderSettings settings);
    private void Initialize(XmlReader givenXmlReader, XamlSchemaContext schemaContext, XamlXmlReaderSettings settings);
    public virtual bool Read();
    public virtual XamlNodeType get_NodeType();
    public virtual bool get_IsEof();
    public virtual NamespaceDeclaration get_Namespace();
    public virtual XamlType get_Type();
    public virtual object get_Value();
    public virtual XamlMember get_Member();
    public virtual XamlSchemaContext get_SchemaContext();
    public sealed virtual bool get_HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    private void ThrowIfDisposed();
    internal bool IsXmlNamespaceSupported(string xmlNamespace, String& newXmlNamespace);
}
public class System.Xaml.XamlXmlReaderSettings : XamlReaderSettings {
    [CompilerGeneratedAttribute]
private string <XmlLang>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <XmlSpacePreserve>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipXmlCompatibilityProcessing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    internal Dictionary`2<string, string> _xmlnsDictionary;
    public string XmlLang { get; public set; }
    public bool XmlSpacePreserve { get; public set; }
    public bool SkipXmlCompatibilityProcessing { get; public set; }
    public bool CloseInput { get; public set; }
    public XamlXmlReaderSettings(XamlXmlReaderSettings settings);
    [CompilerGeneratedAttribute]
public string get_XmlLang();
    [CompilerGeneratedAttribute]
public void set_XmlLang(string value);
    [CompilerGeneratedAttribute]
public bool get_XmlSpacePreserve();
    [CompilerGeneratedAttribute]
public void set_XmlSpacePreserve(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipXmlCompatibilityProcessing();
    [CompilerGeneratedAttribute]
public void set_SkipXmlCompatibilityProcessing(bool value);
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
}
public class System.Xaml.XamlXmlWriter : XamlWriter {
    private WriterState currentState;
    private XmlWriter output;
    private XamlXmlWriterSettings settings;
    private Stack`1<Frame> namespaceScopes;
    private Stack`1<List`1<XamlNode>> meNodesStack;
    private XamlMarkupExtensionWriter meWriter;
    private PositionalParameterStateInfo ppStateInfo;
    private string deferredValue;
    private bool deferredValueIsME;
    private bool isFirstElementOfWhitespaceSignificantCollection;
    private XamlSchemaContext schemaContext;
    private Dictionary`2<string, string> prefixAssignmentHistory;
    public XamlXmlWriterSettings Settings { get; }
    public XamlSchemaContext SchemaContext { get; }
    public XamlXmlWriter(Stream stream, XamlSchemaContext schemaContext);
    public XamlXmlWriter(Stream stream, XamlSchemaContext schemaContext, XamlXmlWriterSettings settings);
    public XamlXmlWriter(TextWriter textWriter, XamlSchemaContext schemaContext);
    public XamlXmlWriter(TextWriter textWriter, XamlSchemaContext schemaContext, XamlXmlWriterSettings settings);
    public XamlXmlWriter(XmlWriter xmlWriter, XamlSchemaContext schemaContext);
    public XamlXmlWriter(XmlWriter xmlWriter, XamlSchemaContext schemaContext, XamlXmlWriterSettings settings);
    private void InitializeXamlXmlWriter(XmlWriter xmlWriter, XamlSchemaContext schemaContext, XamlXmlWriterSettings settings);
    protected virtual void Dispose(bool disposing);
    public void Flush();
    public virtual void WriteGetObject();
    public virtual void WriteStartObject(XamlType type);
    public virtual void WriteEndObject();
    public virtual void WriteStartMember(XamlMember property);
    public virtual void WriteEndMember();
    public virtual void WriteValue(object value);
    public virtual void WriteNamespace(NamespaceDeclaration namespaceDeclaration);
    public XamlXmlWriterSettings get_Settings();
    public virtual XamlSchemaContext get_SchemaContext();
    private void CheckIsDisposed();
    private static bool StringStartsWithCurly(string s);
    internal static bool IsImplicit(XamlMember xamlMember);
    internal static bool HasSignificantWhitespace(string s);
    internal static bool ContainsLeadingSpace(string s);
    internal static bool ContainsTrailingSpace(string s);
    internal static bool ContainsConsecutiveInnerSpaces(string s);
    internal static bool ContainsWhitespaceThatIsNotSpace(string s);
    private static void WriteXmlSpace(XamlXmlWriter writer);
    private static XamlType GetContainingXamlType(XamlXmlWriter writer);
    private void AssignNamespacePrefix(string ns, string prefix);
    private bool IsShadowed(string ns, string prefix);
    private string FindPrefix(IList`1<string> namespaces, String& chosenNamespace);
    internal string LookupPrefix(IList`1<string> namespaces, String& chosenNamespace);
    private bool IsPrefixEverUsedForAnotherNamespace(string prefix, string ns);
    private string DefinePrefix(string ns);
    private void CheckMemberForUniqueness(XamlMember property);
    private void WriteDeferredNamespaces(XamlNodeType nodeType);
    private void WriteTypeArguments(XamlType type);
    private void WriteUndefinedNamespaces(XamlType type);
    private bool TypeArgumentsContainNamespaceThatNeedsDefinition(XamlType type);
    private string BuildTypeArgumentsString(IList`1<XamlType> typeArguments);
    private string ConvertXamlTypeToString(XamlType typeArgument);
    private void ConvertXamlTypeToStringHelper(XamlType type, StringBuilder builder);
    internal static string GetTypeName(XamlType type);
}
public class System.Xaml.XamlXmlWriterException : XamlException {
    public XamlXmlWriterException(string message);
    public XamlXmlWriterException(string message, Exception innerException);
    protected XamlXmlWriterException(SerializationInfo info, StreamingContext context);
}
public class System.Xaml.XamlXmlWriterSettings : XamlWriterSettings {
    [CompilerGeneratedAttribute]
private bool <AssumeValidInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CloseOutput>k__BackingField;
    public bool AssumeValidInput { get; public set; }
    public bool CloseOutput { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AssumeValidInput();
    [CompilerGeneratedAttribute]
public void set_AssumeValidInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_CloseOutput();
    [CompilerGeneratedAttribute]
public void set_CloseOutput(bool value);
    public XamlXmlWriterSettings Copy();
}
internal class System.Xaml.XmlCompatibilityReader : XmlWrappingReader {
    private bool _inAttribute;
    private string _currentName;
    private IsXmlNamespaceSupportedCallback _namespaceCallback;
    private Dictionary`2<string, object> _knownNamespaces;
    private Dictionary`2<string, string> _namespaceMap;
    private Dictionary`2<string, object> _subsumingNamespaces;
    private Dictionary`2<string, HandleElementCallback> _elementHandler;
    private Dictionary`2<string, HandleAttributeCallback> _attributeHandler;
    private int _depthOffset;
    private int _ignoredAttributeCount;
    private int _attributePosition;
    private string _compatibilityUri;
    private string _alternateContent;
    private string _choice;
    private string _fallback;
    private string _requires;
    private string _ignorable;
    private string _mustUnderstand;
    private string _processContent;
    private string _preserveElements;
    private string _preserveAttributes;
    private CompatibilityScope _compatibilityScope;
    private bool isPreviousElementEmpty;
    private int previousElementDepth;
    private static string XmlnsDeclaration;
    private static string MarkupCompatibilityURI;
    private static String[] _predefinedNamespaces;
    public string Value { get; }
    public string NamespaceURI { get; }
    public int Depth { get; }
    public bool HasAttributes { get; }
    public int AttributeCount { get; }
    unknown bool Normalization {public set; }
    internal Encoding Encoding { get; }
    private CompatibilityScope Scope { get; }
    private string AlternateContent { get; }
    private string Choice { get; }
    private string Fallback { get; }
    private string Requires { get; }
    private string Ignorable { get; }
    private string MustUnderstand { get; }
    private string ProcessContent { get; }
    private string PreserveElements { get; }
    private string PreserveAttributes { get; }
    private string CompatibilityUri { get; }
    public XmlCompatibilityReader(XmlReader baseReader);
    public XmlCompatibilityReader(XmlReader baseReader, IsXmlNamespaceSupportedCallback isXmlNamespaceSupported);
    public XmlCompatibilityReader(XmlReader baseReader, IsXmlNamespaceSupportedCallback isXmlNamespaceSupported, IEnumerable`1<string> supportedNamespaces);
    public XmlCompatibilityReader(XmlReader baseReader, IEnumerable`1<string> supportedNamespaces);
    private static XmlCompatibilityReader();
    public void DeclareNamespaceCompatibility(string newNamespace, string oldNamespace);
    public virtual bool Read();
    private bool ReadStartElement(Boolean& more);
    private bool ReadEndElement(Boolean& more);
    public virtual string GetAttribute(int i);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string localName, string namespaceURI);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual string LookupNamespace(string prefix);
    public virtual string get_Value();
    public virtual string get_NamespaceURI();
    public virtual int get_Depth();
    public virtual bool get_HasAttributes();
    public virtual int get_AttributeCount();
    public void set_Normalization(bool value);
    internal Encoding get_Encoding();
    private void SaveReaderPosition();
    private void RestoreReaderPosition();
    private string GetMappedNamespace(string namespaceName);
    private string MapNewNamespace(string namespaceName);
    private bool IsSubsumingNamespace(string namespaceName);
    private void AddSubsumingNamespace(string namespaceName);
    private bool IsNamespaceKnown(string namespaceName);
    private void AddKnownNamespace(string namespaceName);
    private bool ShouldIgnoreNamespace(string namespaceName);
    [IteratorStateMachineAttribute("System.Xaml.XmlCompatibilityReader/<ParseContentToNamespaceElementPair>d__40")]
private IEnumerable`1<NamespaceElementPair> ParseContentToNamespaceElementPair(string content, string callerContext);
    [IteratorStateMachineAttribute("System.Xaml.XmlCompatibilityReader/<PrefixesToNamespaces>d__41")]
private IEnumerable`1<string> PrefixesToNamespaces(string prefixes);
    private bool SkipToKnownAttribute();
    private void ScanForCompatibility(int elementDepth);
    private void ScanForEndCompatibility(int elementDepth);
    private void PushScope(int elementDepth);
    private void PopScope();
    private void HandleAlternateContent(int elementDepth, Boolean& more);
    private void HandleChoice(int elementDepth, Boolean& more);
    private void HandleFallback(int elementDepth, Boolean& more);
    private void HandleIgnorable(int elementDepth);
    private void HandleMustUnderstand(int elementDepth);
    private void HandleProcessContent(int elementDepth);
    private void HandlePreserveElements(int elementDepth);
    private void HandlePreserveAttributes(int elementDepth);
    private void Error(string message, Object[] args);
    private CompatibilityScope get_Scope();
    private string get_AlternateContent();
    private string get_Choice();
    private string get_Fallback();
    private string get_Requires();
    private string get_Ignorable();
    private string get_MustUnderstand();
    private string get_ProcessContent();
    private string get_PreserveElements();
    private string get_PreserveAttributes();
    private string get_CompatibilityUri();
}
[DefaultMemberAttribute("Item")]
internal class System.Xaml.XmlWrappingReader : XmlReader {
    protected XmlReader _reader;
    protected IXmlLineInfo _readerAsIXmlLineInfo;
    protected IXmlNamespaceResolver _readerAsResolver;
    public XmlReaderSettings Settings { get; }
    public XmlNodeType NodeType { get; }
    public string Name { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Prefix { get; }
    public bool HasValue { get; }
    public string Value { get; }
    public int Depth { get; }
    public string BaseURI { get; }
    public bool IsEmptyElement { get; }
    public bool IsDefault { get; }
    public char QuoteChar { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public Type ValueType { get; }
    public int AttributeCount { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public bool CanResolveEntity { get; }
    public bool EOF { get; }
    public ReadState ReadState { get; }
    public bool HasAttributes { get; }
    public XmlNameTable NameTable { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    protected XmlReader Reader { get; protected set; }
    internal XmlWrappingReader(XmlReader baseReader);
    public virtual XmlReaderSettings get_Settings();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Name();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Prefix();
    public virtual bool get_HasValue();
    public virtual string get_Value();
    public virtual int get_Depth();
    public virtual string get_BaseURI();
    public virtual bool get_IsEmptyElement();
    public virtual bool get_IsDefault();
    public virtual char get_QuoteChar();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual Type get_ValueType();
    public virtual int get_AttributeCount();
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public virtual bool get_CanResolveEntity();
    public virtual bool get_EOF();
    public virtual ReadState get_ReadState();
    public virtual bool get_HasAttributes();
    public virtual XmlNameTable get_NameTable();
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string GetAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToElement();
    public virtual bool Read();
    public virtual void Close();
    public virtual void Skip();
    public virtual string LookupNamespace(string prefix);
    private sealed virtual override string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName);
    private sealed virtual override IDictionary`2<string, string> System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope);
    public virtual void ResolveEntity();
    public virtual bool ReadAttributeValue();
    protected virtual void Dispose(bool disposing);
    public virtual bool HasLineInfo();
    public virtual int get_LineNumber();
    public virtual int get_LinePosition();
    protected XmlReader get_Reader();
    protected void set_Reader(XmlReader value);
}
[CLSCompliantAttribute("False")]
public class XPathLexer : Lexer {
    public static int TokenRef;
    public static int RuleRef;
    public static int Anywhere;
    public static int Root;
    public static int Wildcard;
    public static int Bang;
    public static int ID;
    public static int String;
    public static String[] modeNames;
    public static String[] ruleNames;
    private static String[] _LiteralNames;
    private static String[] _SymbolicNames;
    public static IVocabulary DefaultVocabulary;
    public static string _serializedATN;
    public static ATN _ATN;
    [NotNullAttribute]
public IVocabulary Vocabulary { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public String[] ModeNames { get; }
    public string SerializedAtn { get; }
    public XPathLexer(ICharStream input);
    private static XPathLexer();
    public virtual IVocabulary get_Vocabulary();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual String[] get_ModeNames();
    public virtual string get_SerializedAtn();
    public virtual void Action(RuleContext _localctx, int ruleIndex, int actionIndex);
    private void ID_action(RuleContext _localctx, int actionIndex);
}
