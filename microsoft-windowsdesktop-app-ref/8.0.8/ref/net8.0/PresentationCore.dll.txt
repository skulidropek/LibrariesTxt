internal static class MS.Internal.PresentationCore.BuildInfo : object {
    internal static string WCP_VERSION;
    internal static string WCP_VERSION_SUFFIX;
    internal static string MIL_VERSION_SUFFIX;
    internal static string WCP_PUBLIC_KEY_TOKEN;
    internal static string WCP_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_TOKEN;
    internal static string DirectWriteForwarder;
    internal static string PresentationCore;
    internal static string PresentationCFFRasterizer;
    internal static string PresentationFramework;
    internal static string PresentationUI;
    internal static string PresentationFrameworkLuna;
    internal static string PresentationFrameworkRoyale;
    internal static string PresentationFrameworkAero;
    internal static string PresentationFrameworkAero2;
    internal static string PresentationFrameworkAeroLite;
    internal static string PresentationFrameworkClassic;
    internal static string PresentationFrameworkSystemCore;
    internal static string PresentationFrameworkSystemData;
    internal static string PresentationFrameworkSystemDrawing;
    internal static string PresentationFrameworkSystemXml;
    internal static string PresentationFrameworkSystemXmlLinq;
    internal static string ReachFramework;
    internal static string SystemPrinting;
    internal static string SystemXaml;
    internal static string WindowsFormsIntegration;
    internal static string SystemWindowsPresentation;
    internal static string SystemWindowsControlsRibbon;
}
internal static class MS.Internal.PresentationCore.DllImport : object {
    internal static string PresentationNative;
    internal static string PresentationCFFRasterizerNative;
    internal static string MilCore;
    internal static string UIAutomationCore;
    internal static string Wininet;
    internal static string WindowsCodecs;
    internal static string WindowsCodecsExt;
    internal static string Mscms;
    internal static string PrntvPt;
    internal static string Ole32;
    internal static string User32;
    internal static string NInput;
    internal static string ApiSetWinRT;
    internal static string ApiSetWinRTString;
}
public static class System.IO.Packaging.PackageStore : object {
    public static void AddPackage(Uri uri, Package package);
    public static Package GetPackage(Uri uri);
    public static void RemovePackage(Uri uri);
}
public class System.IO.Packaging.PackWebRequest : WebRequest {
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public Uri RequestUri { get; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual Uri get_RequestUri();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public WebRequest GetInnerRequest();
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
}
public class System.IO.Packaging.PackWebRequestFactory : object {
    private sealed virtual override WebRequest System.Net.IWebRequestCreate.Create(Uri uri);
}
public class System.IO.Packaging.PackWebResponse : WebResponse {
    public long ContentLength { get; }
    public string ContentType { get; }
    public WebHeaderCollection Headers { get; }
    public WebResponse InnerResponse { get; }
    public bool IsFromCache { get; }
    public Uri ResponseUri { get; }
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public virtual WebHeaderCollection get_Headers();
    public WebResponse get_InnerResponse();
    public virtual bool get_IsFromCache();
    public virtual Uri get_ResponseUri();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Stream GetResponseStream();
}
public enum System.Windows.Automation.AutomationHeadingLevel : Enum {
    public int value__;
    public static AutomationHeadingLevel None;
    public static AutomationHeadingLevel Level1;
    public static AutomationHeadingLevel Level2;
    public static AutomationHeadingLevel Level3;
    public static AutomationHeadingLevel Level4;
    public static AutomationHeadingLevel Level5;
    public static AutomationHeadingLevel Level6;
    public static AutomationHeadingLevel Level7;
    public static AutomationHeadingLevel Level8;
    public static AutomationHeadingLevel Level9;
}
public enum System.Windows.Automation.AutomationLiveSetting : Enum {
    public int value__;
    public static AutomationLiveSetting Off;
    public static AutomationLiveSetting Polite;
    public static AutomationLiveSetting Assertive;
}
public static class System.Windows.Automation.AutomationProperties : object {
    public static DependencyProperty AcceleratorKeyProperty;
    public static DependencyProperty AccessKeyProperty;
    public static DependencyProperty AutomationIdProperty;
    public static DependencyProperty HeadingLevelProperty;
    public static DependencyProperty HelpTextProperty;
    public static DependencyProperty IsColumnHeaderProperty;
    public static DependencyProperty IsDialogProperty;
    public static DependencyProperty IsOffscreenBehaviorProperty;
    public static DependencyProperty IsRequiredForFormProperty;
    public static DependencyProperty IsRowHeaderProperty;
    public static DependencyProperty ItemStatusProperty;
    public static DependencyProperty ItemTypeProperty;
    public static DependencyProperty LabeledByProperty;
    public static DependencyProperty LiveSettingProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty PositionInSetProperty;
    public static DependencyProperty SizeOfSetProperty;
    public static string GetAcceleratorKey(DependencyObject element);
    public static string GetAccessKey(DependencyObject element);
    public static string GetAutomationId(DependencyObject element);
    public static AutomationHeadingLevel GetHeadingLevel(DependencyObject element);
    public static string GetHelpText(DependencyObject element);
    public static bool GetIsColumnHeader(DependencyObject element);
    public static bool GetIsDialog(DependencyObject element);
    public static IsOffscreenBehavior GetIsOffscreenBehavior(DependencyObject element);
    public static bool GetIsRequiredForForm(DependencyObject element);
    public static bool GetIsRowHeader(DependencyObject element);
    public static string GetItemStatus(DependencyObject element);
    public static string GetItemType(DependencyObject element);
    public static UIElement GetLabeledBy(DependencyObject element);
    public static AutomationLiveSetting GetLiveSetting(DependencyObject element);
    public static string GetName(DependencyObject element);
    public static int GetPositionInSet(DependencyObject element);
    public static int GetSizeOfSet(DependencyObject element);
    public static void SetAcceleratorKey(DependencyObject element, string value);
    public static void SetAccessKey(DependencyObject element, string value);
    public static void SetAutomationId(DependencyObject element, string value);
    public static void SetHeadingLevel(DependencyObject element, AutomationHeadingLevel value);
    public static void SetHelpText(DependencyObject element, string value);
    public static void SetIsColumnHeader(DependencyObject element, bool value);
    public static void SetIsDialog(DependencyObject element, bool value);
    public static void SetIsOffscreenBehavior(DependencyObject element, IsOffscreenBehavior value);
    public static void SetIsRequiredForForm(DependencyObject element, bool value);
    public static void SetIsRowHeader(DependencyObject element, bool value);
    public static void SetItemStatus(DependencyObject element, string value);
    public static void SetItemType(DependencyObject element, string value);
    public static void SetLabeledBy(DependencyObject element, UIElement value);
    public static void SetLiveSetting(DependencyObject element, AutomationLiveSetting value);
    public static void SetName(DependencyObject element, string value);
    public static void SetPositionInSet(DependencyObject element, int value);
    public static void SetSizeOfSet(DependencyObject element, int value);
}
public enum System.Windows.Automation.IsOffscreenBehavior : Enum {
    public int value__;
    public static IsOffscreenBehavior Default;
    public static IsOffscreenBehavior Onscreen;
    public static IsOffscreenBehavior Offscreen;
    public static IsOffscreenBehavior FromClip;
}
public enum System.Windows.Automation.Peers.AutomationControlType : Enum {
    public int value__;
    public static AutomationControlType Button;
    public static AutomationControlType Calendar;
    public static AutomationControlType CheckBox;
    public static AutomationControlType ComboBox;
    public static AutomationControlType Edit;
    public static AutomationControlType Hyperlink;
    public static AutomationControlType Image;
    public static AutomationControlType ListItem;
    public static AutomationControlType List;
    public static AutomationControlType Menu;
    public static AutomationControlType MenuBar;
    public static AutomationControlType MenuItem;
    public static AutomationControlType ProgressBar;
    public static AutomationControlType RadioButton;
    public static AutomationControlType ScrollBar;
    public static AutomationControlType Slider;
    public static AutomationControlType Spinner;
    public static AutomationControlType StatusBar;
    public static AutomationControlType Tab;
    public static AutomationControlType TabItem;
    public static AutomationControlType Text;
    public static AutomationControlType ToolBar;
    public static AutomationControlType ToolTip;
    public static AutomationControlType Tree;
    public static AutomationControlType TreeItem;
    public static AutomationControlType Custom;
    public static AutomationControlType Group;
    public static AutomationControlType Thumb;
    public static AutomationControlType DataGrid;
    public static AutomationControlType DataItem;
    public static AutomationControlType Document;
    public static AutomationControlType SplitButton;
    public static AutomationControlType Window;
    public static AutomationControlType Pane;
    public static AutomationControlType Header;
    public static AutomationControlType HeaderItem;
    public static AutomationControlType Table;
    public static AutomationControlType TitleBar;
    public static AutomationControlType Separator;
}
public enum System.Windows.Automation.Peers.AutomationEvents : Enum {
    public int value__;
    public static AutomationEvents ToolTipOpened;
    public static AutomationEvents ToolTipClosed;
    public static AutomationEvents MenuOpened;
    public static AutomationEvents MenuClosed;
    public static AutomationEvents AutomationFocusChanged;
    public static AutomationEvents InvokePatternOnInvoked;
    public static AutomationEvents SelectionItemPatternOnElementAddedToSelection;
    public static AutomationEvents SelectionItemPatternOnElementRemovedFromSelection;
    public static AutomationEvents SelectionItemPatternOnElementSelected;
    public static AutomationEvents SelectionPatternOnInvalidated;
    public static AutomationEvents TextPatternOnTextSelectionChanged;
    public static AutomationEvents TextPatternOnTextChanged;
    public static AutomationEvents AsyncContentLoaded;
    public static AutomationEvents PropertyChanged;
    public static AutomationEvents StructureChanged;
    public static AutomationEvents InputReachedTarget;
    public static AutomationEvents InputReachedOtherElement;
    public static AutomationEvents InputDiscarded;
    public static AutomationEvents LiveRegionChanged;
    public static AutomationEvents Notification;
    public static AutomationEvents ActiveTextPositionChanged;
}
public enum System.Windows.Automation.Peers.AutomationOrientation : Enum {
    public int value__;
    public static AutomationOrientation None;
    public static AutomationOrientation Horizontal;
    public static AutomationOrientation Vertical;
}
public abstract class System.Windows.Automation.Peers.AutomationPeer : DispatcherObject {
    public AutomationPeer EventsSource { get; public set; }
    protected internal bool IsHwndHost { get; }
    public AutomationPeer get_EventsSource();
    public void set_EventsSource(AutomationPeer value);
    protected internal virtual bool get_IsHwndHost();
    public string GetAcceleratorKey();
    protected abstract virtual string GetAcceleratorKeyCore();
    public string GetAccessKey();
    protected abstract virtual string GetAccessKeyCore();
    public AutomationControlType GetAutomationControlType();
    protected abstract virtual AutomationControlType GetAutomationControlTypeCore();
    public string GetAutomationId();
    protected abstract virtual string GetAutomationIdCore();
    public Rect GetBoundingRectangle();
    protected abstract virtual Rect GetBoundingRectangleCore();
    public List`1<AutomationPeer> GetChildren();
    protected abstract virtual List`1<AutomationPeer> GetChildrenCore();
    public string GetClassName();
    protected abstract virtual string GetClassNameCore();
    public Point GetClickablePoint();
    protected abstract virtual Point GetClickablePointCore();
    public List`1<AutomationPeer> GetControlledPeers();
    protected virtual List`1<AutomationPeer> GetControlledPeersCore();
    public AutomationHeadingLevel GetHeadingLevel();
    protected virtual AutomationHeadingLevel GetHeadingLevelCore();
    public string GetHelpText();
    protected abstract virtual string GetHelpTextCore();
    protected virtual HostedWindowWrapper GetHostRawElementProviderCore();
    public string GetItemStatus();
    protected abstract virtual string GetItemStatusCore();
    public string GetItemType();
    protected abstract virtual string GetItemTypeCore();
    public AutomationPeer GetLabeledBy();
    protected abstract virtual AutomationPeer GetLabeledByCore();
    public AutomationLiveSetting GetLiveSetting();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    public string GetLocalizedControlType();
    protected virtual string GetLocalizedControlTypeCore();
    public string GetName();
    protected abstract virtual string GetNameCore();
    public AutomationOrientation GetOrientation();
    protected abstract virtual AutomationOrientation GetOrientationCore();
    public AutomationPeer GetParent();
    public abstract virtual object GetPattern(PatternInterface patternInterface);
    public AutomationPeer GetPeerFromPoint(Point point);
    protected virtual AutomationPeer GetPeerFromPointCore(Point point);
    public int GetPositionInSet();
    protected virtual int GetPositionInSetCore();
    public int GetSizeOfSet();
    protected virtual int GetSizeOfSetCore();
    public bool HasKeyboardFocus();
    protected abstract virtual bool HasKeyboardFocusCore();
    public void InvalidatePeer();
    public bool IsContentElement();
    protected abstract virtual bool IsContentElementCore();
    public bool IsControlElement();
    protected abstract virtual bool IsControlElementCore();
    public bool IsDialog();
    protected virtual bool IsDialogCore();
    public bool IsEnabled();
    protected abstract virtual bool IsEnabledCore();
    public bool IsKeyboardFocusable();
    protected abstract virtual bool IsKeyboardFocusableCore();
    public bool IsOffscreen();
    protected abstract virtual bool IsOffscreenCore();
    public bool IsPassword();
    protected abstract virtual bool IsPasswordCore();
    public bool IsRequiredForForm();
    protected abstract virtual bool IsRequiredForFormCore();
    public static bool ListenerExists(AutomationEvents eventId);
    protected AutomationPeer PeerFromProvider(IRawElementProviderSimple provider);
    protected internal IRawElementProviderSimple ProviderFromPeer(AutomationPeer peer);
    public void RaiseAsyncContentLoadedEvent(AsyncContentLoadedEventArgs args);
    public void RaiseAutomationEvent(AutomationEvents eventId);
    public void RaiseNotificationEvent(AutomationNotificationKind notificationKind, AutomationNotificationProcessing notificationProcessing, string displayString, string activityId);
    public void RaisePropertyChangedEvent(AutomationProperty property, object oldValue, object newValue);
    public void ResetChildrenCache();
    public void SetFocus();
    protected abstract virtual void SetFocusCore();
}
public class System.Windows.Automation.Peers.ContentElementAutomationPeer : AutomationPeer {
    public ContentElement Owner { get; }
    public ContentElementAutomationPeer(ContentElement owner);
    public ContentElement get_Owner();
    public static AutomationPeer CreatePeerForElement(ContentElement element);
    public static AutomationPeer FromElement(ContentElement element);
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    protected virtual Point GetClickablePointCore();
    protected virtual AutomationHeadingLevel GetHeadingLevelCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetItemStatusCore();
    protected virtual string GetItemTypeCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual string GetNameCore();
    protected virtual AutomationOrientation GetOrientationCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual int GetPositionInSetCore();
    protected virtual int GetSizeOfSetCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual bool IsDialogCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool IsOffscreenCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual void SetFocusCore();
}
public class System.Windows.Automation.Peers.GenericRootAutomationPeer : UIElementAutomationPeer {
    public GenericRootAutomationPeer(UIElement owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetNameCore();
}
public class System.Windows.Automation.Peers.HostedWindowWrapper : object {
    public HostedWindowWrapper(IntPtr hwnd);
}
public enum System.Windows.Automation.Peers.PatternInterface : Enum {
    public int value__;
    public static PatternInterface Invoke;
    public static PatternInterface Selection;
    public static PatternInterface Value;
    public static PatternInterface RangeValue;
    public static PatternInterface Scroll;
    public static PatternInterface ScrollItem;
    public static PatternInterface ExpandCollapse;
    public static PatternInterface Grid;
    public static PatternInterface GridItem;
    public static PatternInterface MultipleView;
    public static PatternInterface Window;
    public static PatternInterface SelectionItem;
    public static PatternInterface Dock;
    public static PatternInterface Table;
    public static PatternInterface TableItem;
    public static PatternInterface Toggle;
    public static PatternInterface Transform;
    public static PatternInterface Text;
    public static PatternInterface ItemContainer;
    public static PatternInterface VirtualizedItem;
    public static PatternInterface SynchronizedInput;
}
public class System.Windows.Automation.Peers.UIElement3DAutomationPeer : AutomationPeer {
    public UIElement3D Owner { get; }
    public UIElement3DAutomationPeer(UIElement3D owner);
    public UIElement3D get_Owner();
    public static AutomationPeer CreatePeerForElement(UIElement3D element);
    public static AutomationPeer FromElement(UIElement3D element);
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    protected virtual Point GetClickablePointCore();
    protected virtual AutomationHeadingLevel GetHeadingLevelCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetItemStatusCore();
    protected virtual string GetItemTypeCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual string GetNameCore();
    protected virtual AutomationOrientation GetOrientationCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual int GetPositionInSetCore();
    protected virtual int GetSizeOfSetCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual bool IsDialogCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool IsOffscreenCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual void SetFocusCore();
}
public class System.Windows.Automation.Peers.UIElementAutomationPeer : AutomationPeer {
    public UIElement Owner { get; }
    public UIElementAutomationPeer(UIElement owner);
    public UIElement get_Owner();
    public static AutomationPeer CreatePeerForElement(UIElement element);
    public static AutomationPeer FromElement(UIElement element);
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    protected virtual Point GetClickablePointCore();
    protected virtual AutomationHeadingLevel GetHeadingLevelCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetItemStatusCore();
    protected virtual string GetItemTypeCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual string GetNameCore();
    protected virtual AutomationOrientation GetOrientationCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual int GetPositionInSetCore();
    protected virtual int GetSizeOfSetCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual bool IsDialogCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool IsOffscreenCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual void SetFocusCore();
}
public class System.Windows.AutoResizedEventArgs : EventArgs {
    public Size Size { get; }
    public AutoResizedEventArgs(Size size);
    public Size get_Size();
}
public class System.Windows.AutoResizedEventHandler : MulticastDelegate {
    public AutoResizedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AutoResizedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AutoResizedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.BaselineAlignment : Enum {
    public int value__;
    public static BaselineAlignment Top;
    public static BaselineAlignment Center;
    public static BaselineAlignment Bottom;
    public static BaselineAlignment Baseline;
    public static BaselineAlignment TextTop;
    public static BaselineAlignment TextBottom;
    public static BaselineAlignment Subscript;
    public static BaselineAlignment Superscript;
}
public static class System.Windows.Clipboard : object {
    public static void Clear();
    public static bool ContainsAudio();
    public static bool ContainsData(string format);
    public static bool ContainsFileDropList();
    public static bool ContainsImage();
    public static bool ContainsText();
    public static bool ContainsText(TextDataFormat format);
    public static void Flush();
    public static Stream GetAudioStream();
    public static object GetData(string format);
    public static IDataObject GetDataObject();
    public static StringCollection GetFileDropList();
    public static BitmapSource GetImage();
    public static string GetText();
    public static string GetText(TextDataFormat format);
    public static bool IsCurrent(IDataObject data);
    public static void SetAudio(Byte[] audioBytes);
    public static void SetAudio(Stream audioStream);
    public static void SetData(string format, object data);
    public static void SetDataObject(object data);
    public static void SetDataObject(object data, bool copy);
    public static void SetFileDropList(StringCollection fileDropList);
    public static void SetImage(BitmapSource image);
    public static void SetText(string text);
    public static void SetText(string text, TextDataFormat format);
}
public class System.Windows.ContentElement : DependencyObject {
    public static DependencyProperty AllowDropProperty;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    public static DependencyProperty AreAnyTouchesOverProperty;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent DropEvent;
    public static DependencyProperty FocusableProperty;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty IsFocusedProperty;
    public static DependencyProperty IsKeyboardFocusedProperty;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    public static DependencyProperty IsMouseCapturedProperty;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    public static DependencyProperty IsMouseOverProperty;
    public static DependencyProperty IsStylusCapturedProperty;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    public static DependencyProperty IsStylusOverProperty;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent LostFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent QueryCursorEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent TouchUpEvent;
    public bool AllowDrop { get; public set; }
    public bool AreAnyTouchesCaptured { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesOver { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    public bool Focusable { get; public set; }
    public bool HasAnimatedProperties { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool IsFocused { get; }
    public bool IsInputMethodEnabled { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusOver { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    public bool get_AreAnyTouchesCaptured();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesOver();
    public CommandBindingCollection get_CommandBindings();
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public sealed virtual bool get_HasAnimatedProperties();
    public InputBindingCollection get_InputBindings();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    protected virtual bool get_IsEnabledCore();
    public bool get_IsFocused();
    public bool get_IsInputMethodEnabled();
    public sealed virtual bool get_IsKeyboardFocused();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public sealed virtual bool get_IsMouseCaptured();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsMouseDirectlyOver();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusCaptured();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    public sealed virtual bool get_IsStylusOver();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public void add_DragEnter(DragEventHandler value);
    public void remove_DragEnter(DragEventHandler value);
    public void add_DragLeave(DragEventHandler value);
    public void remove_DragLeave(DragEventHandler value);
    public void add_DragOver(DragEventHandler value);
    public void remove_DragOver(DragEventHandler value);
    public void add_Drop(DragEventHandler value);
    public void remove_Drop(DragEventHandler value);
    public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void add_GiveFeedback(GiveFeedbackEventHandler value);
    public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    public void add_GotFocus(RoutedEventHandler value);
    public void remove_GotFocus(RoutedEventHandler value);
    public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public sealed virtual void add_KeyDown(KeyEventHandler value);
    public sealed virtual void remove_KeyDown(KeyEventHandler value);
    public sealed virtual void add_KeyUp(KeyEventHandler value);
    public sealed virtual void remove_KeyUp(KeyEventHandler value);
    public void add_LostFocus(RoutedEventHandler value);
    public void remove_LostFocus(RoutedEventHandler value);
    public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void add_MouseDown(MouseButtonEventHandler value);
    public void remove_MouseDown(MouseButtonEventHandler value);
    public sealed virtual void add_MouseEnter(MouseEventHandler value);
    public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    public sealed virtual void add_MouseLeave(MouseEventHandler value);
    public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void add_MouseMove(MouseEventHandler value);
    public sealed virtual void remove_MouseMove(MouseEventHandler value);
    public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    public void add_MouseUp(MouseButtonEventHandler value);
    public void remove_MouseUp(MouseButtonEventHandler value);
    public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    public void add_PreviewDragEnter(DragEventHandler value);
    public void remove_PreviewDragEnter(DragEventHandler value);
    public void add_PreviewDragLeave(DragEventHandler value);
    public void remove_PreviewDragLeave(DragEventHandler value);
    public void add_PreviewDragOver(DragEventHandler value);
    public void remove_PreviewDragOver(DragEventHandler value);
    public void add_PreviewDrop(DragEventHandler value);
    public void remove_PreviewDrop(DragEventHandler value);
    public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public void add_PreviewMouseDown(MouseButtonEventHandler value);
    public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public void add_PreviewMouseUp(MouseButtonEventHandler value);
    public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void add_QueryCursor(QueryCursorEventHandler value);
    public void remove_QueryCursor(QueryCursorEventHandler value);
    public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    public sealed virtual void add_StylusEnter(StylusEventHandler value);
    public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void add_StylusInRange(StylusEventHandler value);
    public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    public sealed virtual void add_StylusLeave(StylusEventHandler value);
    public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    public sealed virtual void add_StylusMove(StylusEventHandler value);
    public sealed virtual void remove_StylusMove(StylusEventHandler value);
    public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void add_StylusUp(StylusEventHandler value);
    public sealed virtual void remove_StylusUp(StylusEventHandler value);
    public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual bool CaptureMouse();
    public sealed virtual bool CaptureStylus();
    public bool CaptureTouch(TouchDevice touchDevice);
    public sealed virtual bool Focus();
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    protected internal virtual DependencyObject GetUIParentCore();
    public virtual bool MoveFocus(TraversalRequest request);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected internal virtual void OnDragEnter(DragEventArgs e);
    protected internal virtual void OnDragLeave(DragEventArgs e);
    protected internal virtual void OnDragOver(DragEventArgs e);
    protected internal virtual void OnDrop(DragEventArgs e);
    protected internal virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected internal virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnGotMouseCapture(MouseEventArgs e);
    protected internal virtual void OnGotStylusCapture(StylusEventArgs e);
    protected internal virtual void OnGotTouchCapture(TouchEventArgs e);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected internal virtual void OnKeyDown(KeyEventArgs e);
    protected internal virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    protected internal virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnLostMouseCapture(MouseEventArgs e);
    protected internal virtual void OnLostStylusCapture(StylusEventArgs e);
    protected internal virtual void OnLostTouchCapture(TouchEventArgs e);
    protected internal virtual void OnMouseDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseEnter(MouseEventArgs e);
    protected internal virtual void OnMouseLeave(MouseEventArgs e);
    protected internal virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnMouseMove(MouseEventArgs e);
    protected internal virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnMouseUp(MouseButtonEventArgs e);
    protected internal virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected internal virtual void OnPreviewDragEnter(DragEventArgs e);
    protected internal virtual void OnPreviewDragLeave(DragEventArgs e);
    protected internal virtual void OnPreviewDragOver(DragEventArgs e);
    protected internal virtual void OnPreviewDrop(DragEventArgs e);
    protected internal virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    protected internal virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected internal virtual void OnPreviewKeyUp(KeyEventArgs e);
    protected internal virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseMove(MouseEventArgs e);
    protected internal virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    protected internal virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    protected internal virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    protected internal virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    protected internal virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    protected internal virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusInRange(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusMove(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected internal virtual void OnPreviewStylusUp(StylusEventArgs e);
    protected internal virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    protected internal virtual void OnPreviewTouchDown(TouchEventArgs e);
    protected internal virtual void OnPreviewTouchMove(TouchEventArgs e);
    protected internal virtual void OnPreviewTouchUp(TouchEventArgs e);
    protected internal virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    protected internal virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected internal virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    protected internal virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    protected internal virtual void OnStylusDown(StylusDownEventArgs e);
    protected internal virtual void OnStylusEnter(StylusEventArgs e);
    protected internal virtual void OnStylusInAirMove(StylusEventArgs e);
    protected internal virtual void OnStylusInRange(StylusEventArgs e);
    protected internal virtual void OnStylusLeave(StylusEventArgs e);
    protected internal virtual void OnStylusMove(StylusEventArgs e);
    protected internal virtual void OnStylusOutOfRange(StylusEventArgs e);
    protected internal virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected internal virtual void OnStylusUp(StylusEventArgs e);
    protected internal virtual void OnTextInput(TextCompositionEventArgs e);
    protected internal virtual void OnTouchDown(TouchEventArgs e);
    protected internal virtual void OnTouchEnter(TouchEventArgs e);
    protected internal virtual void OnTouchLeave(TouchEventArgs e);
    protected internal virtual void OnTouchMove(TouchEventArgs e);
    protected internal virtual void OnTouchUp(TouchEventArgs e);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    public void ReleaseAllTouchCaptures();
    public sealed virtual void ReleaseMouseCapture();
    public sealed virtual void ReleaseStylusCapture();
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
}
public static class System.Windows.ContentOperations : object {
    public static DependencyObject GetParent(ContentElement reference);
    public static void SetParent(ContentElement reference, DependencyObject parent);
}
public static class System.Windows.CoreCompatibilityPreferences : object {
    public static Nullable`1<bool> EnableMultiMonitorDisplayClipping { get; public set; }
    public static bool IsAltKeyRequiredInAccessKeyDefaultScope { get; public set; }
    public static Nullable`1<bool> get_EnableMultiMonitorDisplayClipping();
    public static void set_EnableMultiMonitorDisplayClipping(Nullable`1<bool> value);
    public static bool get_IsAltKeyRequiredInAccessKeyDefaultScope();
    public static void set_IsAltKeyRequiredInAccessKeyDefaultScope(bool value);
}
public class System.Windows.CultureInfoIetfLanguageTagConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.DataFormat : object {
    public int Id { get; }
    public string Name { get; }
    public DataFormat(string name, int id);
    public int get_Id();
    public string get_Name();
}
public static class System.Windows.DataFormats : object {
    public static string Bitmap;
    public static string CommaSeparatedValue;
    public static string Dib;
    public static string Dif;
    public static string EnhancedMetafile;
    public static string FileDrop;
    public static string Html;
    public static string Locale;
    public static string MetafilePicture;
    public static string OemText;
    public static string Palette;
    public static string PenData;
    public static string Riff;
    public static string Rtf;
    public static string Serializable;
    public static string StringFormat;
    public static string SymbolicLink;
    public static string Text;
    public static string Tiff;
    public static string UnicodeText;
    public static string WaveAudio;
    public static string Xaml;
    public static string XamlPackage;
    public static DataFormat GetDataFormat(int id);
    public static DataFormat GetDataFormat(string format);
}
public class System.Windows.DataObject : object {
    public static RoutedEvent CopyingEvent;
    public static RoutedEvent PastingEvent;
    public static RoutedEvent SettingDataEvent;
    public DataObject(object data);
    public DataObject(string format, object data);
    public DataObject(string format, object data, bool autoConvert);
    public DataObject(Type format, object data);
    public static void AddCopyingHandler(DependencyObject element, DataObjectCopyingEventHandler handler);
    public static void AddPastingHandler(DependencyObject element, DataObjectPastingEventHandler handler);
    public static void AddSettingDataHandler(DependencyObject element, DataObjectSettingDataEventHandler handler);
    public bool ContainsAudio();
    public bool ContainsFileDropList();
    public bool ContainsImage();
    public bool ContainsText();
    public bool ContainsText(TextDataFormat format);
    public Stream GetAudioStream();
    public sealed virtual object GetData(string format);
    public sealed virtual object GetData(string format, bool autoConvert);
    public sealed virtual object GetData(Type format);
    public sealed virtual bool GetDataPresent(string format);
    public sealed virtual bool GetDataPresent(string format, bool autoConvert);
    public sealed virtual bool GetDataPresent(Type format);
    public StringCollection GetFileDropList();
    public sealed virtual String[] GetFormats();
    public sealed virtual String[] GetFormats(bool autoConvert);
    public BitmapSource GetImage();
    public string GetText();
    public string GetText(TextDataFormat format);
    public static void RemoveCopyingHandler(DependencyObject element, DataObjectCopyingEventHandler handler);
    public static void RemovePastingHandler(DependencyObject element, DataObjectPastingEventHandler handler);
    public static void RemoveSettingDataHandler(DependencyObject element, DataObjectSettingDataEventHandler handler);
    public void SetAudio(Byte[] audioBytes);
    public void SetAudio(Stream audioStream);
    public sealed virtual void SetData(object data);
    public sealed virtual void SetData(string format, object data);
    public sealed virtual void SetData(string format, object data, bool autoConvert);
    public sealed virtual void SetData(Type format, object data);
    public void SetFileDropList(StringCollection fileDropList);
    public void SetImage(BitmapSource image);
    public void SetText(string textData);
    public void SetText(string textData, TextDataFormat format);
    private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.DAdvise(FORMATETC& pFormatetc, ADVF advf, IAdviseSink pAdvSink, Int32& pdwConnection);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.DUnadvise(int dwConnection);
    private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.EnumDAdvise(IEnumSTATDATA& enumAdvise);
    private sealed virtual override IEnumFORMATETC System.Runtime.InteropServices.ComTypes.IDataObject.EnumFormatEtc(DATADIR dwDirection);
    private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.GetCanonicalFormatEtc(FORMATETC& pformatetcIn, FORMATETC& pformatetcOut);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.GetData(FORMATETC& formatetc, STGMEDIUM& medium);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.GetDataHere(FORMATETC& formatetc, STGMEDIUM& medium);
    private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.QueryGetData(FORMATETC& formatetc);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.SetData(FORMATETC& pFormatetcIn, STGMEDIUM& pmedium, bool fRelease);
}
public class System.Windows.DataObjectCopyingEventArgs : DataObjectEventArgs {
    public IDataObject DataObject { get; }
    public DataObjectCopyingEventArgs(IDataObject dataObject, bool isDragDrop);
    public IDataObject get_DataObject();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectCopyingEventHandler : MulticastDelegate {
    public DataObjectCopyingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectCopyingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectCopyingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.DataObjectEventArgs : RoutedEventArgs {
    public bool CommandCancelled { get; }
    public bool IsDragDrop { get; }
    public bool get_CommandCancelled();
    public bool get_IsDragDrop();
    public void CancelCommand();
}
public class System.Windows.DataObjectPastingEventArgs : DataObjectEventArgs {
    public IDataObject DataObject { get; public set; }
    public string FormatToApply { get; public set; }
    public IDataObject SourceDataObject { get; }
    public DataObjectPastingEventArgs(IDataObject dataObject, bool isDragDrop, string formatToApply);
    public IDataObject get_DataObject();
    public void set_DataObject(IDataObject value);
    public string get_FormatToApply();
    public void set_FormatToApply(string value);
    public IDataObject get_SourceDataObject();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectPastingEventHandler : MulticastDelegate {
    public DataObjectPastingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectPastingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectPastingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DataObjectSettingDataEventArgs : DataObjectEventArgs {
    public IDataObject DataObject { get; }
    public string Format { get; }
    public DataObjectSettingDataEventArgs(IDataObject dataObject, string format);
    public IDataObject get_DataObject();
    public string get_Format();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectSettingDataEventHandler : MulticastDelegate {
    public DataObjectSettingDataEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectSettingDataEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectSettingDataEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Diagnostics.VisualDiagnostics : object {
    public static void add_VisualTreeChanged(EventHandler`1<VisualTreeChangeEventArgs> value);
    public static void remove_VisualTreeChanged(EventHandler`1<VisualTreeChangeEventArgs> value);
    public static void DisableVisualTreeChanged();
    public static void EnableVisualTreeChanged();
    public static XamlSourceInfo GetXamlSourceInfo(object obj);
}
public class System.Windows.Diagnostics.VisualTreeChangeEventArgs : EventArgs {
    public VisualTreeChangeType ChangeType { get; }
    public DependencyObject Child { get; }
    public int ChildIndex { get; }
    public DependencyObject Parent { get; }
    public VisualTreeChangeEventArgs(DependencyObject parent, DependencyObject child, int childIndex, VisualTreeChangeType changeType);
    public VisualTreeChangeType get_ChangeType();
    public DependencyObject get_Child();
    public int get_ChildIndex();
    public DependencyObject get_Parent();
}
public enum System.Windows.Diagnostics.VisualTreeChangeType : Enum {
    public int value__;
    public static VisualTreeChangeType Add;
    public static VisualTreeChangeType Remove;
}
public class System.Windows.Diagnostics.XamlSourceInfo : object {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public Uri SourceUri { get; }
    public XamlSourceInfo(Uri sourceUri, int lineNumber, int linePosition);
    public int get_LineNumber();
    public int get_LinePosition();
    public Uri get_SourceUri();
}
public abstract class System.Windows.Documents.ContentPosition : object {
    public static ContentPosition Missing;
}
public class System.Windows.Documents.DocumentPage : object {
    public static DocumentPage Missing;
    public Rect BleedBox { get; }
    public Rect ContentBox { get; }
    public Size Size { get; }
    public Visual Visual { get; }
    public DocumentPage(Visual visual);
    public DocumentPage(Visual visual, Size pageSize, Rect bleedBox, Rect contentBox);
    public virtual Rect get_BleedBox();
    public virtual Rect get_ContentBox();
    public virtual Size get_Size();
    public virtual Visual get_Visual();
    public void add_PageDestroyed(EventHandler value);
    public void remove_PageDestroyed(EventHandler value);
    public virtual void Dispose();
    protected void OnPageDestroyed(EventArgs e);
    protected void SetBleedBox(Rect bleedBox);
    protected void SetContentBox(Rect contentBox);
    protected void SetSize(Size size);
    protected void SetVisual(Visual visual);
}
public abstract class System.Windows.Documents.DocumentPaginator : object {
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    public abstract virtual bool get_IsPageCountValid();
    public abstract virtual int get_PageCount();
    public abstract virtual Size get_PageSize();
    public abstract virtual void set_PageSize(Size value);
    public abstract virtual IDocumentPaginatorSource get_Source();
    public void add_ComputePageCountCompleted(AsyncCompletedEventHandler value);
    public void remove_ComputePageCountCompleted(AsyncCompletedEventHandler value);
    public void add_GetPageCompleted(GetPageCompletedEventHandler value);
    public void remove_GetPageCompleted(GetPageCompletedEventHandler value);
    public void add_PagesChanged(PagesChangedEventHandler value);
    public void remove_PagesChanged(PagesChangedEventHandler value);
    public virtual void CancelAsync(object userState);
    public virtual void ComputePageCount();
    public virtual void ComputePageCountAsync();
    public virtual void ComputePageCountAsync(object userState);
    public abstract virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageAsync(int pageNumber);
    public virtual void GetPageAsync(int pageNumber, object userState);
    protected virtual void OnComputePageCountCompleted(AsyncCompletedEventArgs e);
    protected virtual void OnGetPageCompleted(GetPageCompletedEventArgs e);
    protected virtual void OnPagesChanged(PagesChangedEventArgs e);
}
public abstract class System.Windows.Documents.DynamicDocumentPaginator : DocumentPaginator {
    public bool IsBackgroundPaginationEnabled { get; public set; }
    public virtual bool get_IsBackgroundPaginationEnabled();
    public virtual void set_IsBackgroundPaginationEnabled(bool value);
    public void add_GetPageNumberCompleted(GetPageNumberCompletedEventHandler value);
    public void remove_GetPageNumberCompleted(GetPageNumberCompletedEventHandler value);
    public void add_PaginationCompleted(EventHandler value);
    public void remove_PaginationCompleted(EventHandler value);
    public void add_PaginationProgress(PaginationProgressEventHandler value);
    public void remove_PaginationProgress(PaginationProgressEventHandler value);
    public abstract virtual ContentPosition GetObjectPosition(object value);
    public abstract virtual int GetPageNumber(ContentPosition contentPosition);
    public virtual void GetPageNumberAsync(ContentPosition contentPosition);
    public virtual void GetPageNumberAsync(ContentPosition contentPosition, object userState);
    public abstract virtual ContentPosition GetPagePosition(DocumentPage page);
    protected virtual void OnGetPageNumberCompleted(GetPageNumberCompletedEventArgs e);
    protected virtual void OnPaginationCompleted(EventArgs e);
    protected virtual void OnPaginationProgress(PaginationProgressEventArgs e);
}
public class System.Windows.Documents.GetPageCompletedEventArgs : AsyncCompletedEventArgs {
    public DocumentPage DocumentPage { get; }
    public int PageNumber { get; }
    public GetPageCompletedEventArgs(DocumentPage page, int pageNumber, Exception error, bool cancelled, object userState);
    public DocumentPage get_DocumentPage();
    public int get_PageNumber();
}
public class System.Windows.Documents.GetPageCompletedEventHandler : MulticastDelegate {
    public GetPageCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GetPageCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GetPageCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.GetPageNumberCompletedEventArgs : AsyncCompletedEventArgs {
    public ContentPosition ContentPosition { get; }
    public int PageNumber { get; }
    public GetPageNumberCompletedEventArgs(ContentPosition contentPosition, int pageNumber, Exception error, bool cancelled, object userState);
    public ContentPosition get_ContentPosition();
    public int get_PageNumber();
}
public class System.Windows.Documents.GetPageNumberCompletedEventHandler : MulticastDelegate {
    public GetPageNumberCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GetPageNumberCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GetPageNumberCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.Windows.Documents.IDocumentPaginatorSource {
    public DocumentPaginator DocumentPaginator { get; }
    public abstract virtual DocumentPaginator get_DocumentPaginator();
}
public class System.Windows.Documents.PagesChangedEventArgs : EventArgs {
    public int Count { get; }
    public int Start { get; }
    public PagesChangedEventArgs(int start, int count);
    public int get_Count();
    public int get_Start();
}
public class System.Windows.Documents.PagesChangedEventHandler : MulticastDelegate {
    public PagesChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PagesChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PagesChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.PaginationProgressEventArgs : EventArgs {
    public int Count { get; }
    public int Start { get; }
    public PaginationProgressEventArgs(int start, int count);
    public int get_Count();
    public int get_Start();
}
public class System.Windows.Documents.PaginationProgressEventHandler : MulticastDelegate {
    public PaginationProgressEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PaginationProgressEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PaginationProgressEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DpiChangedEventArgs : RoutedEventArgs {
    public DpiScale NewDpi { get; }
    public DpiScale OldDpi { get; }
    public DpiScale get_NewDpi();
    public DpiScale get_OldDpi();
}
public class System.Windows.DpiChangedEventHandler : MulticastDelegate {
    public DpiChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DpiChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DpiChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DpiScale : ValueType {
    public double DpiScaleX { get; }
    public double DpiScaleY { get; }
    public double PixelsPerDip { get; }
    public double PixelsPerInchX { get; }
    public double PixelsPerInchY { get; }
    public DpiScale(double dpiScaleX, double dpiScaleY);
    public double get_DpiScaleX();
    public double get_DpiScaleY();
    public double get_PixelsPerDip();
    public double get_PixelsPerInchX();
    public double get_PixelsPerInchY();
}
public enum System.Windows.DragAction : Enum {
    public int value__;
    public static DragAction Continue;
    public static DragAction Drop;
    public static DragAction Cancel;
}
public static class System.Windows.DragDrop : object {
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent DropEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static void AddDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDropHandler(DependencyObject element, DragEventHandler handler);
    public static void AddGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void AddPreviewDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDropHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void AddPreviewQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void AddQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static DragDropEffects DoDragDrop(DependencyObject dragSource, object data, DragDropEffects allowedEffects);
    public static void RemoveDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDropHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void RemovePreviewDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDropHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void RemovePreviewQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void RemoveQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
}
[FlagsAttribute]
public enum System.Windows.DragDropEffects : Enum {
    public int value__;
    public static DragDropEffects Scroll;
    public static DragDropEffects All;
    public static DragDropEffects None;
    public static DragDropEffects Copy;
    public static DragDropEffects Move;
    public static DragDropEffects Link;
}
[FlagsAttribute]
public enum System.Windows.DragDropKeyStates : Enum {
    public int value__;
    public static DragDropKeyStates None;
    public static DragDropKeyStates LeftMouseButton;
    public static DragDropKeyStates RightMouseButton;
    public static DragDropKeyStates ShiftKey;
    public static DragDropKeyStates ControlKey;
    public static DragDropKeyStates MiddleMouseButton;
    public static DragDropKeyStates AltKey;
}
public class System.Windows.DragEventArgs : RoutedEventArgs {
    public DragDropEffects AllowedEffects { get; }
    public IDataObject Data { get; }
    public DragDropEffects Effects { get; public set; }
    public DragDropKeyStates KeyStates { get; }
    public DragDropEffects get_AllowedEffects();
    public IDataObject get_Data();
    public DragDropEffects get_Effects();
    public void set_Effects(DragDropEffects value);
    public DragDropKeyStates get_KeyStates();
    public Point GetPosition(IInputElement relativeTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DragEventHandler : MulticastDelegate {
    public DragEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DragEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DragEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.DurationConverter")]
public class System.Windows.Duration : ValueType {
    public static Duration Automatic { get; }
    public static Duration Forever { get; }
    public bool HasTimeSpan { get; }
    public TimeSpan TimeSpan { get; }
    public Duration(TimeSpan timeSpan);
    public static Duration get_Automatic();
    public static Duration get_Forever();
    public bool get_HasTimeSpan();
    public TimeSpan get_TimeSpan();
    public Duration Add(Duration duration);
    public static int Compare(Duration t1, Duration t2);
    public virtual bool Equals(object value);
    public bool Equals(Duration duration);
    public static bool Equals(Duration t1, Duration t2);
    public virtual int GetHashCode();
    public static Duration op_Addition(Duration t1, Duration t2);
    public static bool op_Equality(Duration t1, Duration t2);
    public static bool op_GreaterThan(Duration t1, Duration t2);
    public static bool op_GreaterThanOrEqual(Duration t1, Duration t2);
    public static Duration op_Implicit(TimeSpan timeSpan);
    public static bool op_Inequality(Duration t1, Duration t2);
    public static bool op_LessThan(Duration t1, Duration t2);
    public static bool op_LessThanOrEqual(Duration t1, Duration t2);
    public static Duration op_Subtraction(Duration t1, Duration t2);
    public static Duration op_UnaryPlus(Duration duration);
    public static Duration Plus(Duration duration);
    public Duration Subtract(Duration duration);
    public virtual string ToString();
}
public class System.Windows.DurationConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
public static class System.Windows.EventManager : object {
    public static RoutedEvent[] GetRoutedEvents();
    public static RoutedEvent[] GetRoutedEventsForOwner(Type ownerType);
    public static void RegisterClassHandler(Type classType, RoutedEvent routedEvent, Delegate handler);
    public static void RegisterClassHandler(Type classType, RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public static RoutedEvent RegisterRoutedEvent(string name, RoutingStrategy routingStrategy, Type handlerType, Type ownerType);
}
public class System.Windows.EventPrivateKey : object {
}
public class System.Windows.EventRoute : object {
    public EventRoute(RoutedEvent routedEvent);
    public void Add(object target, Delegate handler, bool handledEventsToo);
    [EditorBrowsableAttribute("2")]
public object PeekBranchNode();
    [EditorBrowsableAttribute("2")]
public object PeekBranchSource();
    [EditorBrowsableAttribute("2")]
public object PopBranchNode();
    [EditorBrowsableAttribute("2")]
public void PushBranchNode(object node, object source);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.FlowDirection : Enum {
    public int value__;
    public static FlowDirection LeftToRight;
    public static FlowDirection RightToLeft;
}
public enum System.Windows.FontCapitals : Enum {
    public int value__;
    public static FontCapitals Normal;
    public static FontCapitals AllSmallCaps;
    public static FontCapitals SmallCaps;
    public static FontCapitals AllPetiteCaps;
    public static FontCapitals PetiteCaps;
    public static FontCapitals Unicase;
    public static FontCapitals Titling;
}
public enum System.Windows.FontEastAsianLanguage : Enum {
    public int value__;
    public static FontEastAsianLanguage Normal;
    public static FontEastAsianLanguage Jis78;
    public static FontEastAsianLanguage Jis83;
    public static FontEastAsianLanguage Jis90;
    public static FontEastAsianLanguage Jis04;
    public static FontEastAsianLanguage HojoKanji;
    public static FontEastAsianLanguage NlcKanji;
    public static FontEastAsianLanguage Simplified;
    public static FontEastAsianLanguage Traditional;
    public static FontEastAsianLanguage TraditionalNames;
}
public enum System.Windows.FontEastAsianWidths : Enum {
    public int value__;
    public static FontEastAsianWidths Normal;
    public static FontEastAsianWidths Proportional;
    public static FontEastAsianWidths Full;
    public static FontEastAsianWidths Half;
    public static FontEastAsianWidths Third;
    public static FontEastAsianWidths Quarter;
}
public enum System.Windows.FontFraction : Enum {
    public int value__;
    public static FontFraction Normal;
    public static FontFraction Slashed;
    public static FontFraction Stacked;
}
public enum System.Windows.FontNumeralAlignment : Enum {
    public int value__;
    public static FontNumeralAlignment Normal;
    public static FontNumeralAlignment Proportional;
    public static FontNumeralAlignment Tabular;
}
public enum System.Windows.FontNumeralStyle : Enum {
    public int value__;
    public static FontNumeralStyle Normal;
    public static FontNumeralStyle Lining;
    public static FontNumeralStyle OldStyle;
}
[TypeConverterAttribute("System.Windows.FontStretchConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.FontStretch : ValueType {
    public static int Compare(FontStretch left, FontStretch right);
    public virtual bool Equals(object obj);
    public bool Equals(FontStretch obj);
    public static FontStretch FromOpenTypeStretch(int stretchValue);
    public virtual int GetHashCode();
    public static bool op_Equality(FontStretch left, FontStretch right);
    public static bool op_GreaterThan(FontStretch left, FontStretch right);
    public static bool op_GreaterThanOrEqual(FontStretch left, FontStretch right);
    public static bool op_Inequality(FontStretch left, FontStretch right);
    public static bool op_LessThan(FontStretch left, FontStretch right);
    public static bool op_LessThanOrEqual(FontStretch left, FontStretch right);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public int ToOpenTypeStretch();
    public virtual string ToString();
}
public class System.Windows.FontStretchConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontStretches : object {
    public static FontStretch Condensed { get; }
    public static FontStretch Expanded { get; }
    public static FontStretch ExtraCondensed { get; }
    public static FontStretch ExtraExpanded { get; }
    public static FontStretch Medium { get; }
    public static FontStretch Normal { get; }
    public static FontStretch SemiCondensed { get; }
    public static FontStretch SemiExpanded { get; }
    public static FontStretch UltraCondensed { get; }
    public static FontStretch UltraExpanded { get; }
    public static FontStretch get_Condensed();
    public static FontStretch get_Expanded();
    public static FontStretch get_ExtraCondensed();
    public static FontStretch get_ExtraExpanded();
    public static FontStretch get_Medium();
    public static FontStretch get_Normal();
    public static FontStretch get_SemiCondensed();
    public static FontStretch get_SemiExpanded();
    public static FontStretch get_UltraCondensed();
    public static FontStretch get_UltraExpanded();
}
[TypeConverterAttribute("System.Windows.FontStyleConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.FontStyle : ValueType {
    public virtual bool Equals(object obj);
    public bool Equals(FontStyle obj);
    public virtual int GetHashCode();
    public static bool op_Equality(FontStyle left, FontStyle right);
    public static bool op_Inequality(FontStyle left, FontStyle right);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
}
public class System.Windows.FontStyleConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontStyles : object {
    public static FontStyle Italic { get; }
    public static FontStyle Normal { get; }
    public static FontStyle Oblique { get; }
    public static FontStyle get_Italic();
    public static FontStyle get_Normal();
    public static FontStyle get_Oblique();
}
public enum System.Windows.FontVariants : Enum {
    public int value__;
    public static FontVariants Normal;
    public static FontVariants Superscript;
    public static FontVariants Subscript;
    public static FontVariants Ordinal;
    public static FontVariants Inferior;
    public static FontVariants Ruby;
}
[TypeConverterAttribute("System.Windows.FontWeightConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.FontWeight : ValueType {
    public static int Compare(FontWeight left, FontWeight right);
    public virtual bool Equals(object obj);
    public bool Equals(FontWeight obj);
    public static FontWeight FromOpenTypeWeight(int weightValue);
    public virtual int GetHashCode();
    public static bool op_Equality(FontWeight left, FontWeight right);
    public static bool op_GreaterThan(FontWeight left, FontWeight right);
    public static bool op_GreaterThanOrEqual(FontWeight left, FontWeight right);
    public static bool op_Inequality(FontWeight left, FontWeight right);
    public static bool op_LessThan(FontWeight left, FontWeight right);
    public static bool op_LessThanOrEqual(FontWeight left, FontWeight right);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public int ToOpenTypeWeight();
    public virtual string ToString();
}
public class System.Windows.FontWeightConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontWeights : object {
    public static FontWeight Black { get; }
    public static FontWeight Bold { get; }
    public static FontWeight DemiBold { get; }
    public static FontWeight ExtraBlack { get; }
    public static FontWeight ExtraBold { get; }
    public static FontWeight ExtraLight { get; }
    public static FontWeight Heavy { get; }
    public static FontWeight Light { get; }
    public static FontWeight Medium { get; }
    public static FontWeight Normal { get; }
    public static FontWeight Regular { get; }
    public static FontWeight SemiBold { get; }
    public static FontWeight Thin { get; }
    public static FontWeight UltraBlack { get; }
    public static FontWeight UltraBold { get; }
    public static FontWeight UltraLight { get; }
    public static FontWeight get_Black();
    public static FontWeight get_Bold();
    public static FontWeight get_DemiBold();
    public static FontWeight get_ExtraBlack();
    public static FontWeight get_ExtraBold();
    public static FontWeight get_ExtraLight();
    public static FontWeight get_Heavy();
    public static FontWeight get_Light();
    public static FontWeight get_Medium();
    public static FontWeight get_Normal();
    public static FontWeight get_Regular();
    public static FontWeight get_SemiBold();
    public static FontWeight get_Thin();
    public static FontWeight get_UltraBlack();
    public static FontWeight get_UltraBold();
    public static FontWeight get_UltraLight();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.FreezableCollection`1 : Animatable {
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public FreezableCollection`1(IEnumerable`1<T> collection);
    public FreezableCollection`1(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void Add(T value);
    public sealed virtual void Clear();
    public FreezableCollection`1<T> Clone();
    protected virtual void CloneCore(Freezable source);
    public FreezableCollection`1<T> CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    public sealed virtual void Insert(int index, T value);
    public sealed virtual bool Remove(T value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public class System.Windows.GiveFeedbackEventArgs : RoutedEventArgs {
    public DragDropEffects Effects { get; }
    public bool UseDefaultCursors { get; public set; }
    public DragDropEffects get_Effects();
    public bool get_UseDefaultCursors();
    public void set_UseDefaultCursors(bool value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.GiveFeedbackEventHandler : MulticastDelegate {
    public GiveFeedbackEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GiveFeedbackEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GiveFeedbackEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.HwndDpiChangedEventArgs : HandledEventArgs {
    public DpiScale NewDpi { get; }
    public DpiScale OldDpi { get; }
    public Rect SuggestedRect { get; }
    public DpiScale get_NewDpi();
    public DpiScale get_OldDpi();
    public Rect get_SuggestedRect();
}
public class System.Windows.HwndDpiChangedEventHandler : MulticastDelegate {
    public HwndDpiChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, HwndDpiChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, HwndDpiChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.Windows.IContentHost {
    public IEnumerator`1<IInputElement> HostedElements { get; }
    public abstract virtual IEnumerator`1<IInputElement> get_HostedElements();
    public abstract virtual ReadOnlyCollection`1<Rect> GetRectangles(ContentElement child);
    public abstract virtual IInputElement InputHitTest(Point point);
    public abstract virtual void OnChildDesiredSizeChanged(UIElement child);
}
public interface System.Windows.IDataObject {
    public abstract virtual object GetData(string format);
    public abstract virtual object GetData(string format, bool autoConvert);
    public abstract virtual object GetData(Type format);
    public abstract virtual bool GetDataPresent(string format);
    public abstract virtual bool GetDataPresent(string format, bool autoConvert);
    public abstract virtual bool GetDataPresent(Type format);
    public abstract virtual String[] GetFormats();
    public abstract virtual String[] GetFormats(bool autoConvert);
    public abstract virtual void SetData(object data);
    public abstract virtual void SetData(string format, object data);
    public abstract virtual void SetData(string format, object data, bool autoConvert);
    public abstract virtual void SetData(Type format, object data);
}
public interface System.Windows.IInputElement {
    public bool Focusable { get; public set; }
    public bool IsEnabled { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusOver { get; }
    public abstract virtual bool get_Focusable();
    public abstract virtual void set_Focusable(bool value);
    public abstract virtual bool get_IsEnabled();
    public abstract virtual bool get_IsKeyboardFocused();
    public abstract virtual bool get_IsKeyboardFocusWithin();
    public abstract virtual bool get_IsMouseCaptured();
    public abstract virtual bool get_IsMouseDirectlyOver();
    public abstract virtual bool get_IsMouseOver();
    public abstract virtual bool get_IsStylusCaptured();
    public abstract virtual bool get_IsStylusDirectlyOver();
    public abstract virtual bool get_IsStylusOver();
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextInput(TextCompositionEventHandler value);
    public abstract virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public abstract virtual bool CaptureMouse();
    public abstract virtual bool CaptureStylus();
    public abstract virtual bool Focus();
    public abstract virtual void RaiseEvent(RoutedEventArgs e);
    public abstract virtual void ReleaseMouseCapture();
    public abstract virtual void ReleaseStylusCapture();
    public abstract virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
}
public enum System.Windows.Ink.ApplicationGesture : Enum {
    public int value__;
    public static ApplicationGesture AllGestures;
    public static ApplicationGesture NoGesture;
    public static ApplicationGesture ScratchOut;
    public static ApplicationGesture Triangle;
    public static ApplicationGesture Square;
    public static ApplicationGesture Star;
    public static ApplicationGesture Check;
    public static ApplicationGesture Curlicue;
    public static ApplicationGesture DoubleCurlicue;
    public static ApplicationGesture Circle;
    public static ApplicationGesture DoubleCircle;
    public static ApplicationGesture SemicircleLeft;
    public static ApplicationGesture SemicircleRight;
    public static ApplicationGesture ChevronUp;
    public static ApplicationGesture ChevronDown;
    public static ApplicationGesture ChevronLeft;
    public static ApplicationGesture ChevronRight;
    public static ApplicationGesture ArrowUp;
    public static ApplicationGesture ArrowDown;
    public static ApplicationGesture ArrowLeft;
    public static ApplicationGesture ArrowRight;
    public static ApplicationGesture Up;
    public static ApplicationGesture Down;
    public static ApplicationGesture Left;
    public static ApplicationGesture Right;
    public static ApplicationGesture UpDown;
    public static ApplicationGesture DownUp;
    public static ApplicationGesture LeftRight;
    public static ApplicationGesture RightLeft;
    public static ApplicationGesture UpLeftLong;
    public static ApplicationGesture UpRightLong;
    public static ApplicationGesture DownLeftLong;
    public static ApplicationGesture DownRightLong;
    public static ApplicationGesture UpLeft;
    public static ApplicationGesture UpRight;
    public static ApplicationGesture DownLeft;
    public static ApplicationGesture DownRight;
    public static ApplicationGesture LeftUp;
    public static ApplicationGesture LeftDown;
    public static ApplicationGesture RightUp;
    public static ApplicationGesture RightDown;
    public static ApplicationGesture Exclamation;
    public static ApplicationGesture Tap;
    public static ApplicationGesture DoubleTap;
}
public static class System.Windows.Ink.DrawingAttributeIds : object {
    public static Guid Color;
    public static Guid DrawingFlags;
    public static Guid IsHighlighter;
    public static Guid StylusHeight;
    public static Guid StylusTip;
    public static Guid StylusTipTransform;
    public static Guid StylusWidth;
}
public class System.Windows.Ink.DrawingAttributes : object {
    public static double MaxHeight;
    public static double MaxWidth;
    public static double MinHeight;
    public static double MinWidth;
    public Color Color { get; public set; }
    public bool FitToCurve { get; public set; }
    public double Height { get; public set; }
    public bool IgnorePressure { get; public set; }
    public bool IsHighlighter { get; public set; }
    public StylusTip StylusTip { get; public set; }
    public Matrix StylusTipTransform { get; public set; }
    public double Width { get; public set; }
    public Color get_Color();
    public void set_Color(Color value);
    public bool get_FitToCurve();
    public void set_FitToCurve(bool value);
    public double get_Height();
    public void set_Height(double value);
    public bool get_IgnorePressure();
    public void set_IgnorePressure(bool value);
    public bool get_IsHighlighter();
    public void set_IsHighlighter(bool value);
    public StylusTip get_StylusTip();
    public void set_StylusTip(StylusTip value);
    public Matrix get_StylusTipTransform();
    public void set_StylusTipTransform(Matrix value);
    public double get_Width();
    public void set_Width(double value);
    public void add_AttributeChanged(PropertyDataChangedEventHandler value);
    public void remove_AttributeChanged(PropertyDataChangedEventHandler value);
    public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    public virtual DrawingAttributes Clone();
    public bool ContainsPropertyData(Guid propertyDataId);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    protected virtual void OnAttributeChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    public static bool op_Equality(DrawingAttributes first, DrawingAttributes second);
    public static bool op_Inequality(DrawingAttributes first, DrawingAttributes second);
    public void RemovePropertyData(Guid propertyDataId);
}
public class System.Windows.Ink.DrawingAttributesReplacedEventArgs : EventArgs {
    public DrawingAttributes NewDrawingAttributes { get; }
    public DrawingAttributes PreviousDrawingAttributes { get; }
    public DrawingAttributesReplacedEventArgs(DrawingAttributes newDrawingAttributes, DrawingAttributes previousDrawingAttributes);
    public DrawingAttributes get_NewDrawingAttributes();
    public DrawingAttributes get_PreviousDrawingAttributes();
}
public class System.Windows.Ink.DrawingAttributesReplacedEventHandler : MulticastDelegate {
    public DrawingAttributesReplacedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DrawingAttributesReplacedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DrawingAttributesReplacedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Ink.EllipseStylusShape : StylusShape {
    public EllipseStylusShape(double width, double height);
    public EllipseStylusShape(double width, double height, double rotation);
}
public class System.Windows.Ink.GestureRecognitionResult : object {
    public ApplicationGesture ApplicationGesture { get; }
    public RecognitionConfidence RecognitionConfidence { get; }
    public ApplicationGesture get_ApplicationGesture();
    public RecognitionConfidence get_RecognitionConfidence();
}
public class System.Windows.Ink.GestureRecognizer : DependencyObject {
    public bool IsRecognizerAvailable { get; }
    public GestureRecognizer(IEnumerable`1<ApplicationGesture> enabledApplicationGestures);
    public bool get_IsRecognizerAvailable();
    public sealed virtual void Dispose();
    public ReadOnlyCollection`1<ApplicationGesture> GetEnabledGestures();
    public ReadOnlyCollection`1<GestureRecognitionResult> Recognize(StrokeCollection strokes);
    public void SetEnabledGestures(IEnumerable`1<ApplicationGesture> applicationGestures);
}
public abstract class System.Windows.Ink.IncrementalHitTester : object {
    public bool IsValid { get; }
    public bool get_IsValid();
    public void AddPoint(Point point);
    public void AddPoints(IEnumerable`1<Point> points);
    public void AddPoints(StylusPointCollection stylusPoints);
    protected abstract virtual void AddPointsCore(IEnumerable`1<Point> points);
    public void EndHitTesting();
}
public class System.Windows.Ink.IncrementalLassoHitTester : IncrementalHitTester {
    public void add_SelectionChanged(LassoSelectionChangedEventHandler value);
    public void remove_SelectionChanged(LassoSelectionChangedEventHandler value);
    protected virtual void AddPointsCore(IEnumerable`1<Point> points);
    protected void OnSelectionChanged(LassoSelectionChangedEventArgs eventArgs);
}
public class System.Windows.Ink.IncrementalStrokeHitTester : IncrementalHitTester {
    public void add_StrokeHit(StrokeHitEventHandler value);
    public void remove_StrokeHit(StrokeHitEventHandler value);
    protected virtual void AddPointsCore(IEnumerable`1<Point> points);
    protected void OnStrokeHit(StrokeHitEventArgs eventArgs);
}
public class System.Windows.Ink.LassoSelectionChangedEventArgs : EventArgs {
    public StrokeCollection DeselectedStrokes { get; }
    public StrokeCollection SelectedStrokes { get; }
    public StrokeCollection get_DeselectedStrokes();
    public StrokeCollection get_SelectedStrokes();
}
public class System.Windows.Ink.LassoSelectionChangedEventHandler : MulticastDelegate {
    public LassoSelectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, LassoSelectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, LassoSelectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Ink.PropertyDataChangedEventArgs : EventArgs {
    public object NewValue { get; }
    public object PreviousValue { get; }
    public Guid PropertyGuid { get; }
    public PropertyDataChangedEventArgs(Guid propertyGuid, object newValue, object previousValue);
    public object get_NewValue();
    public object get_PreviousValue();
    public Guid get_PropertyGuid();
}
public class System.Windows.Ink.PropertyDataChangedEventHandler : MulticastDelegate {
    public PropertyDataChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyDataChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyDataChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Ink.RecognitionConfidence : Enum {
    public int value__;
    public static RecognitionConfidence Strong;
    public static RecognitionConfidence Intermediate;
    public static RecognitionConfidence Poor;
}
public class System.Windows.Ink.RectangleStylusShape : StylusShape {
    public RectangleStylusShape(double width, double height);
    public RectangleStylusShape(double width, double height, double rotation);
}
public class System.Windows.Ink.Stroke : object {
    public DrawingAttributes DrawingAttributes { get; public set; }
    public StylusPointCollection StylusPoints { get; public set; }
    public Stroke(StylusPointCollection stylusPoints);
    public Stroke(StylusPointCollection stylusPoints, DrawingAttributes drawingAttributes);
    public DrawingAttributes get_DrawingAttributes();
    public void set_DrawingAttributes(DrawingAttributes value);
    public StylusPointCollection get_StylusPoints();
    public void set_StylusPoints(StylusPointCollection value);
    public void add_DrawingAttributesChanged(PropertyDataChangedEventHandler value);
    public void remove_DrawingAttributesChanged(PropertyDataChangedEventHandler value);
    public void add_DrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    public void remove_DrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    public void add_Invalidated(EventHandler value);
    public void remove_Invalidated(EventHandler value);
    public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    public void add_StylusPointsChanged(EventHandler value);
    public void remove_StylusPointsChanged(EventHandler value);
    public void add_StylusPointsReplaced(StylusPointsReplacedEventHandler value);
    public void remove_StylusPointsReplaced(StylusPointsReplacedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    public virtual Stroke Clone();
    public bool ContainsPropertyData(Guid propertyDataId);
    public void Draw(DrawingContext context);
    public void Draw(DrawingContext drawingContext, DrawingAttributes drawingAttributes);
    protected virtual void DrawCore(DrawingContext drawingContext, DrawingAttributes drawingAttributes);
    public StylusPointCollection GetBezierStylusPoints();
    public virtual Rect GetBounds();
    public StrokeCollection GetClipResult(IEnumerable`1<Point> lassoPoints);
    public StrokeCollection GetClipResult(Rect bounds);
    public StrokeCollection GetEraseResult(IEnumerable`1<Point> lassoPoints);
    public StrokeCollection GetEraseResult(IEnumerable`1<Point> eraserPath, StylusShape eraserShape);
    public StrokeCollection GetEraseResult(Rect bounds);
    public Geometry GetGeometry();
    public Geometry GetGeometry(DrawingAttributes drawingAttributes);
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    public bool HitTest(IEnumerable`1<Point> lassoPoints, int percentageWithinLasso);
    public bool HitTest(IEnumerable`1<Point> path, StylusShape stylusShape);
    public bool HitTest(Point point);
    public bool HitTest(Point point, double diameter);
    public bool HitTest(Rect bounds, int percentageWithinBounds);
    protected virtual void OnDrawingAttributesChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnDrawingAttributesReplaced(DrawingAttributesReplacedEventArgs e);
    protected virtual void OnInvalidated(EventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnStylusPointsChanged(EventArgs e);
    protected virtual void OnStylusPointsReplaced(StylusPointsReplacedEventArgs e);
    public void RemovePropertyData(Guid propertyDataId);
    public virtual void Transform(Matrix transformMatrix, bool applyToStylusTip);
}
[TypeConverterAttribute("System.Windows.StrokeCollectionConverter")]
public class System.Windows.Ink.StrokeCollection : Collection`1<Stroke> {
    public static string InkSerializedFormat;
    public StrokeCollection(IEnumerable`1<Stroke> strokes);
    public StrokeCollection(Stream stream);
    public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    public void add_StrokesChanged(StrokeCollectionChangedEventHandler value);
    public void remove_StrokesChanged(StrokeCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    public void Add(StrokeCollection strokes);
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    protected sealed virtual void ClearItems();
    public void Clip(IEnumerable`1<Point> lassoPoints);
    public void Clip(Rect bounds);
    public virtual StrokeCollection Clone();
    public bool ContainsPropertyData(Guid propertyDataId);
    public void Draw(DrawingContext context);
    public void Erase(IEnumerable`1<Point> lassoPoints);
    public void Erase(IEnumerable`1<Point> eraserPath, StylusShape eraserShape);
    public void Erase(Rect bounds);
    public Rect GetBounds();
    public IncrementalLassoHitTester GetIncrementalLassoHitTester(int percentageWithinLasso);
    public IncrementalStrokeHitTester GetIncrementalStrokeHitTester(StylusShape eraserShape);
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    public StrokeCollection HitTest(IEnumerable`1<Point> lassoPoints, int percentageWithinLasso);
    public StrokeCollection HitTest(IEnumerable`1<Point> path, StylusShape stylusShape);
    public StrokeCollection HitTest(Point point);
    public StrokeCollection HitTest(Point point, double diameter);
    public StrokeCollection HitTest(Rect bounds, int percentageWithinBounds);
    public int IndexOf(Stroke stroke);
    protected sealed virtual void InsertItem(int index, Stroke stroke);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnStrokesChanged(StrokeCollectionChangedEventArgs e);
    public void Remove(StrokeCollection strokes);
    protected sealed virtual void RemoveItem(int index);
    public void RemovePropertyData(Guid propertyDataId);
    public void Replace(Stroke strokeToReplace, StrokeCollection strokesToReplaceWith);
    public void Replace(StrokeCollection strokesToReplace, StrokeCollection strokesToReplaceWith);
    public void Save(Stream stream);
    public virtual void Save(Stream stream, bool compress);
    protected sealed virtual void SetItem(int index, Stroke stroke);
    public void Transform(Matrix transformMatrix, bool applyToStylusTip);
}
public class System.Windows.Ink.StrokeCollectionChangedEventArgs : EventArgs {
    public StrokeCollection Added { get; }
    public StrokeCollection Removed { get; }
    public StrokeCollectionChangedEventArgs(StrokeCollection added, StrokeCollection removed);
    public StrokeCollection get_Added();
    public StrokeCollection get_Removed();
}
public class System.Windows.Ink.StrokeCollectionChangedEventHandler : MulticastDelegate {
    public StrokeCollectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StrokeCollectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StrokeCollectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Ink.StrokeHitEventArgs : EventArgs {
    public Stroke HitStroke { get; }
    public Stroke get_HitStroke();
    public StrokeCollection GetPointEraseResults();
}
public class System.Windows.Ink.StrokeHitEventHandler : MulticastDelegate {
    public StrokeHitEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StrokeHitEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StrokeHitEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Ink.StylusPointsReplacedEventArgs : EventArgs {
    public StylusPointCollection NewStylusPoints { get; }
    public StylusPointCollection PreviousStylusPoints { get; }
    public StylusPointsReplacedEventArgs(StylusPointCollection newStylusPoints, StylusPointCollection previousStylusPoints);
    public StylusPointCollection get_NewStylusPoints();
    public StylusPointCollection get_PreviousStylusPoints();
}
public class System.Windows.Ink.StylusPointsReplacedEventHandler : MulticastDelegate {
    public StylusPointsReplacedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusPointsReplacedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusPointsReplacedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Ink.StylusShape : object {
    public double Height { get; }
    public double Rotation { get; }
    public double Width { get; }
    public double get_Height();
    public double get_Rotation();
    public double get_Width();
}
public enum System.Windows.Ink.StylusTip : Enum {
    public int value__;
    public static StylusTip Rectangle;
    public static StylusTip Ellipse;
}
public class System.Windows.Input.AccessKeyEventArgs : EventArgs {
    public bool IsMultiple { get; }
    public string Key { get; }
    public bool get_IsMultiple();
    public string get_Key();
}
public class System.Windows.Input.AccessKeyManager : object {
    public static RoutedEvent AccessKeyPressedEvent;
    public static void AddAccessKeyPressedHandler(DependencyObject element, AccessKeyPressedEventHandler handler);
    public static bool IsKeyRegistered(object scope, string key);
    public static bool ProcessKey(object scope, string key, bool isMultiple);
    public static void Register(string key, IInputElement element);
    public static void RemoveAccessKeyPressedHandler(DependencyObject element, AccessKeyPressedEventHandler handler);
    public static void Unregister(string key, IInputElement element);
}
public class System.Windows.Input.AccessKeyPressedEventArgs : RoutedEventArgs {
    public string Key { get; }
    public object Scope { get; public set; }
    public UIElement Target { get; public set; }
    public AccessKeyPressedEventArgs(string key);
    public string get_Key();
    public object get_Scope();
    public void set_Scope(object value);
    public UIElement get_Target();
    public void set_Target(UIElement value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.AccessKeyPressedEventHandler : MulticastDelegate {
    public AccessKeyPressedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AccessKeyPressedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AccessKeyPressedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Input.ApplicationCommands : object {
    public static RoutedUICommand CancelPrint { get; }
    public static RoutedUICommand Close { get; }
    public static RoutedUICommand ContextMenu { get; }
    public static RoutedUICommand Copy { get; }
    public static RoutedUICommand CorrectionList { get; }
    public static RoutedUICommand Cut { get; }
    public static RoutedUICommand Delete { get; }
    public static RoutedUICommand Find { get; }
    public static RoutedUICommand Help { get; }
    public static RoutedUICommand New { get; }
    public static RoutedUICommand NotACommand { get; }
    public static RoutedUICommand Open { get; }
    public static RoutedUICommand Paste { get; }
    public static RoutedUICommand Print { get; }
    public static RoutedUICommand PrintPreview { get; }
    public static RoutedUICommand Properties { get; }
    public static RoutedUICommand Redo { get; }
    public static RoutedUICommand Replace { get; }
    public static RoutedUICommand Save { get; }
    public static RoutedUICommand SaveAs { get; }
    public static RoutedUICommand SelectAll { get; }
    public static RoutedUICommand Stop { get; }
    public static RoutedUICommand Undo { get; }
    public static RoutedUICommand get_CancelPrint();
    public static RoutedUICommand get_Close();
    public static RoutedUICommand get_ContextMenu();
    public static RoutedUICommand get_Copy();
    public static RoutedUICommand get_CorrectionList();
    public static RoutedUICommand get_Cut();
    public static RoutedUICommand get_Delete();
    public static RoutedUICommand get_Find();
    public static RoutedUICommand get_Help();
    public static RoutedUICommand get_New();
    public static RoutedUICommand get_NotACommand();
    public static RoutedUICommand get_Open();
    public static RoutedUICommand get_Paste();
    public static RoutedUICommand get_Print();
    public static RoutedUICommand get_PrintPreview();
    public static RoutedUICommand get_Properties();
    public static RoutedUICommand get_Redo();
    public static RoutedUICommand get_Replace();
    public static RoutedUICommand get_Save();
    public static RoutedUICommand get_SaveAs();
    public static RoutedUICommand get_SelectAll();
    public static RoutedUICommand get_Stop();
    public static RoutedUICommand get_Undo();
}
public class System.Windows.Input.CanExecuteChangedEventManager : WeakEventManager {
    public static void AddHandler(ICommand source, EventHandler`1<EventArgs> handler);
    protected virtual bool Purge(object source, object data, bool purgeAll);
    public static void RemoveHandler(ICommand source, EventHandler`1<EventArgs> handler);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public class System.Windows.Input.CanExecuteRoutedEventArgs : RoutedEventArgs {
    public bool CanExecute { get; public set; }
    public ICommand Command { get; }
    public bool ContinueRouting { get; public set; }
    public object Parameter { get; }
    public bool get_CanExecute();
    public void set_CanExecute(bool value);
    public ICommand get_Command();
    public bool get_ContinueRouting();
    public void set_ContinueRouting(bool value);
    public object get_Parameter();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object target);
}
public class System.Windows.Input.CanExecuteRoutedEventHandler : MulticastDelegate {
    public CanExecuteRoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CanExecuteRoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CanExecuteRoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.CaptureMode : Enum {
    public int value__;
    public static CaptureMode None;
    public static CaptureMode Element;
    public static CaptureMode SubTree;
}
public class System.Windows.Input.CommandBinding : object {
    [LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    public CommandBinding(ICommand command);
    public CommandBinding(ICommand command, ExecutedRoutedEventHandler executed);
    public CommandBinding(ICommand command, ExecutedRoutedEventHandler executed, CanExecuteRoutedEventHandler canExecute);
    public ICommand get_Command();
    public void set_Command(ICommand value);
    public void add_CanExecute(CanExecuteRoutedEventHandler value);
    public void remove_CanExecute(CanExecuteRoutedEventHandler value);
    public void add_Executed(ExecutedRoutedEventHandler value);
    public void remove_Executed(ExecutedRoutedEventHandler value);
    public void add_PreviewCanExecute(CanExecuteRoutedEventHandler value);
    public void remove_PreviewCanExecute(CanExecuteRoutedEventHandler value);
    public void add_PreviewExecuted(ExecutedRoutedEventHandler value);
    public void remove_PreviewExecuted(ExecutedRoutedEventHandler value);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.CommandBindingCollection : object {
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public CommandBinding Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public CommandBindingCollection(IList commandBindings);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public CommandBinding get_Item(int index);
    public void set_Item(int index, CommandBinding value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(CommandBinding commandBinding);
    public void AddRange(ICollection collection);
    public sealed virtual void Clear();
    public bool Contains(CommandBinding commandBinding);
    public void CopyTo(CommandBinding[] commandBindings, int index);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(CommandBinding value);
    public void Insert(int index, CommandBinding commandBinding);
    public void Remove(CommandBinding commandBinding);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object commandBinding);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object commandBinding);
}
public class System.Windows.Input.CommandManager : object {
    public static RoutedEvent CanExecuteEvent;
    public static RoutedEvent ExecutedEvent;
    public static RoutedEvent PreviewCanExecuteEvent;
    public static RoutedEvent PreviewExecutedEvent;
    public static void add_RequerySuggested(EventHandler value);
    public static void remove_RequerySuggested(EventHandler value);
    public static void AddCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void AddExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void AddPreviewCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void AddPreviewExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void InvalidateRequerySuggested();
    public static void RegisterClassCommandBinding(Type type, CommandBinding commandBinding);
    public static void RegisterClassInputBinding(Type type, InputBinding inputBinding);
    public static void RemoveCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void RemoveExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void RemovePreviewCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void RemovePreviewExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
}
public static class System.Windows.Input.ComponentCommands : object {
    public static RoutedUICommand ExtendSelectionDown { get; }
    public static RoutedUICommand ExtendSelectionLeft { get; }
    public static RoutedUICommand ExtendSelectionRight { get; }
    public static RoutedUICommand ExtendSelectionUp { get; }
    public static RoutedUICommand MoveDown { get; }
    public static RoutedUICommand MoveFocusBack { get; }
    public static RoutedUICommand MoveFocusDown { get; }
    public static RoutedUICommand MoveFocusForward { get; }
    public static RoutedUICommand MoveFocusPageDown { get; }
    public static RoutedUICommand MoveFocusPageUp { get; }
    public static RoutedUICommand MoveFocusUp { get; }
    public static RoutedUICommand MoveLeft { get; }
    public static RoutedUICommand MoveRight { get; }
    public static RoutedUICommand MoveToEnd { get; }
    public static RoutedUICommand MoveToHome { get; }
    public static RoutedUICommand MoveToPageDown { get; }
    public static RoutedUICommand MoveToPageUp { get; }
    public static RoutedUICommand MoveUp { get; }
    public static RoutedUICommand ScrollByLine { get; }
    public static RoutedUICommand ScrollPageDown { get; }
    public static RoutedUICommand ScrollPageLeft { get; }
    public static RoutedUICommand ScrollPageRight { get; }
    public static RoutedUICommand ScrollPageUp { get; }
    public static RoutedUICommand SelectToEnd { get; }
    public static RoutedUICommand SelectToHome { get; }
    public static RoutedUICommand SelectToPageDown { get; }
    public static RoutedUICommand SelectToPageUp { get; }
    public static RoutedUICommand get_ExtendSelectionDown();
    public static RoutedUICommand get_ExtendSelectionLeft();
    public static RoutedUICommand get_ExtendSelectionRight();
    public static RoutedUICommand get_ExtendSelectionUp();
    public static RoutedUICommand get_MoveDown();
    public static RoutedUICommand get_MoveFocusBack();
    public static RoutedUICommand get_MoveFocusDown();
    public static RoutedUICommand get_MoveFocusForward();
    public static RoutedUICommand get_MoveFocusPageDown();
    public static RoutedUICommand get_MoveFocusPageUp();
    public static RoutedUICommand get_MoveFocusUp();
    public static RoutedUICommand get_MoveLeft();
    public static RoutedUICommand get_MoveRight();
    public static RoutedUICommand get_MoveToEnd();
    public static RoutedUICommand get_MoveToHome();
    public static RoutedUICommand get_MoveToPageDown();
    public static RoutedUICommand get_MoveToPageUp();
    public static RoutedUICommand get_MoveUp();
    public static RoutedUICommand get_ScrollByLine();
    public static RoutedUICommand get_ScrollPageDown();
    public static RoutedUICommand get_ScrollPageLeft();
    public static RoutedUICommand get_ScrollPageRight();
    public static RoutedUICommand get_ScrollPageUp();
    public static RoutedUICommand get_SelectToEnd();
    public static RoutedUICommand get_SelectToHome();
    public static RoutedUICommand get_SelectToPageDown();
    public static RoutedUICommand get_SelectToPageUp();
}
[TypeConverterAttribute("System.Windows.Input.CursorConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.Input.Cursor : object {
    public Cursor(Stream cursorStream);
    public Cursor(Stream cursorStream, bool scaleWithDpi);
    public Cursor(string cursorFile);
    public Cursor(string cursorFile, bool scaleWithDpi);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public virtual string ToString();
}
public class System.Windows.Input.CursorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
public static class System.Windows.Input.Cursors : object {
    public static Cursor AppStarting { get; }
    public static Cursor Arrow { get; }
    public static Cursor ArrowCD { get; }
    public static Cursor Cross { get; }
    public static Cursor Hand { get; }
    public static Cursor Help { get; }
    public static Cursor IBeam { get; }
    public static Cursor No { get; }
    public static Cursor None { get; }
    public static Cursor Pen { get; }
    public static Cursor ScrollAll { get; }
    public static Cursor ScrollE { get; }
    public static Cursor ScrollN { get; }
    public static Cursor ScrollNE { get; }
    public static Cursor ScrollNS { get; }
    public static Cursor ScrollNW { get; }
    public static Cursor ScrollS { get; }
    public static Cursor ScrollSE { get; }
    public static Cursor ScrollSW { get; }
    public static Cursor ScrollW { get; }
    public static Cursor ScrollWE { get; }
    public static Cursor SizeAll { get; }
    public static Cursor SizeNESW { get; }
    public static Cursor SizeNS { get; }
    public static Cursor SizeNWSE { get; }
    public static Cursor SizeWE { get; }
    public static Cursor UpArrow { get; }
    public static Cursor Wait { get; }
    public static Cursor get_AppStarting();
    public static Cursor get_Arrow();
    public static Cursor get_ArrowCD();
    public static Cursor get_Cross();
    public static Cursor get_Hand();
    public static Cursor get_Help();
    public static Cursor get_IBeam();
    public static Cursor get_No();
    public static Cursor get_None();
    public static Cursor get_Pen();
    public static Cursor get_ScrollAll();
    public static Cursor get_ScrollE();
    public static Cursor get_ScrollN();
    public static Cursor get_ScrollNE();
    public static Cursor get_ScrollNS();
    public static Cursor get_ScrollNW();
    public static Cursor get_ScrollS();
    public static Cursor get_ScrollSE();
    public static Cursor get_ScrollSW();
    public static Cursor get_ScrollW();
    public static Cursor get_ScrollWE();
    public static Cursor get_SizeAll();
    public static Cursor get_SizeNESW();
    public static Cursor get_SizeNS();
    public static Cursor get_SizeNWSE();
    public static Cursor get_SizeWE();
    public static Cursor get_UpArrow();
    public static Cursor get_Wait();
}
public enum System.Windows.Input.CursorType : Enum {
    public int value__;
    public static CursorType None;
    public static CursorType No;
    public static CursorType Arrow;
    public static CursorType AppStarting;
    public static CursorType Cross;
    public static CursorType Help;
    public static CursorType IBeam;
    public static CursorType SizeAll;
    public static CursorType SizeNESW;
    public static CursorType SizeNS;
    public static CursorType SizeNWSE;
    public static CursorType SizeWE;
    public static CursorType UpArrow;
    public static CursorType Wait;
    public static CursorType Hand;
    public static CursorType Pen;
    public static CursorType ScrollNS;
    public static CursorType ScrollWE;
    public static CursorType ScrollAll;
    public static CursorType ScrollN;
    public static CursorType ScrollS;
    public static CursorType ScrollW;
    public static CursorType ScrollE;
    public static CursorType ScrollNW;
    public static CursorType ScrollNE;
    public static CursorType ScrollSW;
    public static CursorType ScrollSE;
    public static CursorType ArrowCD;
}
public class System.Windows.Input.ExecutedRoutedEventArgs : RoutedEventArgs {
    public ICommand Command { get; }
    public object Parameter { get; }
    public ICommand get_Command();
    public object get_Parameter();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object target);
}
public class System.Windows.Input.ExecutedRoutedEventHandler : MulticastDelegate {
    public ExecutedRoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExecutedRoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ExecutedRoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Input.FocusManager : object {
    public static DependencyProperty FocusedElementProperty;
    public static RoutedEvent GotFocusEvent;
    public static DependencyProperty IsFocusScopeProperty;
    public static RoutedEvent LostFocusEvent;
    public static void AddGotFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void AddLostFocusHandler(DependencyObject element, RoutedEventHandler handler);
    [DesignerSerializationVisibilityAttribute("0")]
public static IInputElement GetFocusedElement(DependencyObject element);
    public static DependencyObject GetFocusScope(DependencyObject element);
    public static bool GetIsFocusScope(DependencyObject element);
    public static void RemoveGotFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void RemoveLostFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void SetFocusedElement(DependencyObject element, IInputElement value);
    public static void SetIsFocusScope(DependencyObject element, bool value);
}
public interface System.Windows.Input.ICommandSource {
    public ICommand Command { get; }
    public object CommandParameter { get; }
    public IInputElement CommandTarget { get; }
    public abstract virtual ICommand get_Command();
    public abstract virtual object get_CommandParameter();
    public abstract virtual IInputElement get_CommandTarget();
}
public interface System.Windows.Input.IInputLanguageSource {
    public CultureInfo CurrentInputLanguage { get; public set; }
    public IEnumerable InputLanguageList { get; }
    public abstract virtual CultureInfo get_CurrentInputLanguage();
    public abstract virtual void set_CurrentInputLanguage(CultureInfo value);
    public abstract virtual IEnumerable get_InputLanguageList();
    public abstract virtual void Initialize();
    public abstract virtual void Uninitialize();
}
public interface System.Windows.Input.IManipulator {
    public int Id { get; }
    public abstract virtual int get_Id();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Updated(EventHandler value);
    public abstract virtual Point GetPosition(IInputElement relativeTo);
    public abstract virtual void ManipulationEnded(bool cancel);
}
[FlagsAttribute]
public enum System.Windows.Input.ImeConversionModeValues : Enum {
    public int value__;
    public static ImeConversionModeValues DoNotCare;
    public static ImeConversionModeValues Native;
    public static ImeConversionModeValues Katakana;
    public static ImeConversionModeValues FullShape;
    public static ImeConversionModeValues Roman;
    public static ImeConversionModeValues CharCode;
    public static ImeConversionModeValues NoConversion;
    public static ImeConversionModeValues Eudc;
    public static ImeConversionModeValues Symbol;
    public static ImeConversionModeValues Fixed;
    public static ImeConversionModeValues Alphanumeric;
}
[FlagsAttribute]
public enum System.Windows.Input.ImeSentenceModeValues : Enum {
    public int value__;
    public static ImeSentenceModeValues DoNotCare;
    public static ImeSentenceModeValues None;
    public static ImeSentenceModeValues PluralClause;
    public static ImeSentenceModeValues SingleConversion;
    public static ImeSentenceModeValues Automatic;
    public static ImeSentenceModeValues PhrasePrediction;
    public static ImeSentenceModeValues Conversation;
}
public class System.Windows.Input.InertiaExpansionBehavior : object {
    public double DesiredDeceleration { get; public set; }
    public Vector DesiredExpansion { get; public set; }
    public double InitialRadius { get; public set; }
    public Vector InitialVelocity { get; public set; }
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public Vector get_DesiredExpansion();
    public void set_DesiredExpansion(Vector value);
    public double get_InitialRadius();
    public void set_InitialRadius(double value);
    public Vector get_InitialVelocity();
    public void set_InitialVelocity(Vector value);
}
public class System.Windows.Input.InertiaRotationBehavior : object {
    public double DesiredDeceleration { get; public set; }
    public double DesiredRotation { get; public set; }
    public double InitialVelocity { get; public set; }
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public double get_DesiredRotation();
    public void set_DesiredRotation(double value);
    public double get_InitialVelocity();
    public void set_InitialVelocity(double value);
}
public class System.Windows.Input.InertiaTranslationBehavior : object {
    public double DesiredDeceleration { get; public set; }
    public double DesiredDisplacement { get; public set; }
    public Vector InitialVelocity { get; public set; }
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public double get_DesiredDisplacement();
    public void set_DesiredDisplacement(double value);
    public Vector get_InitialVelocity();
    public void set_InitialVelocity(Vector value);
}
public class System.Windows.Input.InputBinding : Freezable {
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandTargetProperty;
    [TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    public object CommandParameter { get; public set; }
    public IInputElement CommandTarget { get; public set; }
    public InputGesture Gesture { get; public set; }
    public InputBinding(ICommand command, InputGesture gesture);
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
    public virtual InputGesture get_Gesture();
    public virtual void set_Gesture(InputGesture value);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.InputBindingCollection : object {
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public InputBinding Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public InputBindingCollection(IList inputBindings);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public InputBinding get_Item(int index);
    public void set_Item(int index, InputBinding value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(InputBinding inputBinding);
    public void AddRange(ICollection collection);
    public sealed virtual void Clear();
    public bool Contains(InputBinding key);
    public void CopyTo(InputBinding[] inputBindings, int index);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(InputBinding value);
    public void Insert(int index, InputBinding inputBinding);
    public void Remove(InputBinding inputBinding);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object inputBinding);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object inputBinding);
}
public abstract class System.Windows.Input.InputDevice : DispatcherObject {
    public PresentationSource ActiveSource { get; }
    public IInputElement Target { get; }
    public abstract virtual PresentationSource get_ActiveSource();
    public abstract virtual IInputElement get_Target();
}
public class System.Windows.Input.InputEventArgs : RoutedEventArgs {
    public InputDevice Device { get; }
    public int Timestamp { get; }
    public InputEventArgs(InputDevice inputDevice, int timestamp);
    public InputDevice get_Device();
    public int get_Timestamp();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.InputEventHandler : MulticastDelegate {
    public InputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Input.InputGesture : object {
    public abstract virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.InputGestureCollection : object {
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public InputGesture Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public InputGestureCollection(IList inputGestures);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public InputGesture get_Item(int index);
    public void set_Item(int index, InputGesture value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(InputGesture inputGesture);
    public void AddRange(ICollection collection);
    public sealed virtual void Clear();
    public bool Contains(InputGesture key);
    public void CopyTo(InputGesture[] inputGestures, int index);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(InputGesture value);
    public void Insert(int index, InputGesture inputGesture);
    public void Remove(InputGesture inputGesture);
    public sealed virtual void RemoveAt(int index);
    public void Seal();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object inputGesture);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object inputGesture);
}
public class System.Windows.Input.InputLanguageChangedEventArgs : InputLanguageEventArgs {
    public InputLanguageChangedEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
}
public class System.Windows.Input.InputLanguageChangingEventArgs : InputLanguageEventArgs {
    public bool Rejected { get; public set; }
    public InputLanguageChangingEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public bool get_Rejected();
    public void set_Rejected(bool value);
}
public abstract class System.Windows.Input.InputLanguageEventArgs : EventArgs {
    public CultureInfo NewLanguage { get; }
    public CultureInfo PreviousLanguage { get; }
    protected InputLanguageEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public virtual CultureInfo get_NewLanguage();
    public virtual CultureInfo get_PreviousLanguage();
}
public class System.Windows.Input.InputLanguageEventHandler : MulticastDelegate {
    public InputLanguageEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputLanguageEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputLanguageEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.InputLanguageManager : DispatcherObject {
    public static DependencyProperty InputLanguageProperty;
    public static DependencyProperty RestoreInputLanguageProperty;
    public IEnumerable AvailableInputLanguages { get; }
    public static InputLanguageManager Current { get; }
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo CurrentInputLanguage { get; public set; }
    public IEnumerable get_AvailableInputLanguages();
    public static InputLanguageManager get_Current();
    public CultureInfo get_CurrentInputLanguage();
    public void set_CurrentInputLanguage(CultureInfo value);
    public void add_InputLanguageChanged(InputLanguageEventHandler value);
    public void remove_InputLanguageChanged(InputLanguageEventHandler value);
    public void add_InputLanguageChanging(InputLanguageEventHandler value);
    public void remove_InputLanguageChanging(InputLanguageEventHandler value);
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static CultureInfo GetInputLanguage(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetRestoreInputLanguage(DependencyObject target);
    public void RegisterInputLanguageSource(IInputLanguageSource inputLanguageSource);
    public void ReportInputLanguageChanged(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public bool ReportInputLanguageChanging(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public static void SetInputLanguage(DependencyObject target, CultureInfo inputLanguage);
    public static void SetRestoreInputLanguage(DependencyObject target, bool restore);
}
public class System.Windows.Input.InputManager : DispatcherObject {
    public static InputManager Current { get; }
    public ICollection InputProviders { get; }
    public bool IsInMenuMode { get; }
    public InputDevice MostRecentInputDevice { get; }
    public KeyboardDevice PrimaryKeyboardDevice { get; }
    public MouseDevice PrimaryMouseDevice { get; }
    public static InputManager get_Current();
    public ICollection get_InputProviders();
    public bool get_IsInMenuMode();
    public InputDevice get_MostRecentInputDevice();
    public KeyboardDevice get_PrimaryKeyboardDevice();
    public MouseDevice get_PrimaryMouseDevice();
    public void add_EnterMenuMode(EventHandler value);
    public void remove_EnterMenuMode(EventHandler value);
    public void add_HitTestInvalidatedAsync(EventHandler value);
    public void remove_HitTestInvalidatedAsync(EventHandler value);
    public void add_LeaveMenuMode(EventHandler value);
    public void remove_LeaveMenuMode(EventHandler value);
    public void add_PostNotifyInput(NotifyInputEventHandler value);
    public void remove_PostNotifyInput(NotifyInputEventHandler value);
    public void add_PostProcessInput(ProcessInputEventHandler value);
    public void remove_PostProcessInput(ProcessInputEventHandler value);
    public void add_PreNotifyInput(NotifyInputEventHandler value);
    public void remove_PreNotifyInput(NotifyInputEventHandler value);
    public void add_PreProcessInput(PreProcessInputEventHandler value);
    public void remove_PreProcessInput(PreProcessInputEventHandler value);
    public void PopMenuMode(PresentationSource menuSite);
    public bool ProcessInput(InputEventArgs input);
    public void PushMenuMode(PresentationSource menuSite);
}
public class System.Windows.Input.InputMethod : DispatcherObject {
    public static DependencyProperty InputScopeProperty;
    public static DependencyProperty IsInputMethodEnabledProperty;
    public static DependencyProperty IsInputMethodSuspendedProperty;
    public static DependencyProperty PreferredImeConversionModeProperty;
    public static DependencyProperty PreferredImeSentenceModeProperty;
    public static DependencyProperty PreferredImeStateProperty;
    public bool CanShowConfigurationUI { get; }
    public bool CanShowRegisterWordUI { get; }
    public static InputMethod Current { get; }
    public InputMethodState HandwritingState { get; public set; }
    public ImeConversionModeValues ImeConversionMode { get; public set; }
    public ImeSentenceModeValues ImeSentenceMode { get; public set; }
    public InputMethodState ImeState { get; public set; }
    public InputMethodState MicrophoneState { get; public set; }
    public SpeechMode SpeechMode { get; public set; }
    public bool get_CanShowConfigurationUI();
    public bool get_CanShowRegisterWordUI();
    public static InputMethod get_Current();
    public InputMethodState get_HandwritingState();
    public void set_HandwritingState(InputMethodState value);
    public ImeConversionModeValues get_ImeConversionMode();
    public void set_ImeConversionMode(ImeConversionModeValues value);
    public ImeSentenceModeValues get_ImeSentenceMode();
    public void set_ImeSentenceMode(ImeSentenceModeValues value);
    public InputMethodState get_ImeState();
    public void set_ImeState(InputMethodState value);
    public InputMethodState get_MicrophoneState();
    public void set_MicrophoneState(InputMethodState value);
    public SpeechMode get_SpeechMode();
    public void set_SpeechMode(SpeechMode value);
    public void add_StateChanged(InputMethodStateChangedEventHandler value);
    public void remove_StateChanged(InputMethodStateChangedEventHandler value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static InputScope GetInputScope(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsInputMethodEnabled(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsInputMethodSuspended(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ImeConversionModeValues GetPreferredImeConversionMode(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ImeSentenceModeValues GetPreferredImeSentenceMode(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static InputMethodState GetPreferredImeState(DependencyObject target);
    public static void SetInputScope(DependencyObject target, InputScope value);
    public static void SetIsInputMethodEnabled(DependencyObject target, bool value);
    public static void SetIsInputMethodSuspended(DependencyObject target, bool value);
    public static void SetPreferredImeConversionMode(DependencyObject target, ImeConversionModeValues value);
    public static void SetPreferredImeSentenceMode(DependencyObject target, ImeSentenceModeValues value);
    public static void SetPreferredImeState(DependencyObject target, InputMethodState value);
    public void ShowConfigureUI();
    public void ShowConfigureUI(UIElement element);
    public void ShowRegisterWordUI();
    public void ShowRegisterWordUI(string registeredText);
    public void ShowRegisterWordUI(UIElement element, string registeredText);
}
public enum System.Windows.Input.InputMethodState : Enum {
    public int value__;
    public static InputMethodState Off;
    public static InputMethodState On;
    public static InputMethodState DoNotCare;
}
public class System.Windows.Input.InputMethodStateChangedEventArgs : EventArgs {
    public bool IsHandwritingStateChanged { get; }
    public bool IsImeConversionModeChanged { get; }
    public bool IsImeSentenceModeChanged { get; }
    public bool IsImeStateChanged { get; }
    public bool IsMicrophoneStateChanged { get; }
    public bool IsSpeechModeChanged { get; }
    public bool get_IsHandwritingStateChanged();
    public bool get_IsImeConversionModeChanged();
    public bool get_IsImeSentenceModeChanged();
    public bool get_IsImeStateChanged();
    public bool get_IsMicrophoneStateChanged();
    public bool get_IsSpeechModeChanged();
}
public class System.Windows.Input.InputMethodStateChangedEventHandler : MulticastDelegate {
    public InputMethodStateChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputMethodStateChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputMethodStateChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.InputMode : Enum {
    public int value__;
    public static InputMode Foreground;
    public static InputMode Sink;
}
[TypeConverterAttribute("System.Windows.Input.InputScopeConverter, PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.InputScope : object {
    [DesignerSerializationVisibilityAttribute("2")]
public IList Names { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public IList PhraseList { get; }
    [DefaultValueAttribute("")]
public string RegularExpression { get; public set; }
    [DefaultValueAttribute("")]
public string SrgsMarkup { get; public set; }
    public IList get_Names();
    public IList get_PhraseList();
    public string get_RegularExpression();
    public void set_RegularExpression(string value);
    public string get_SrgsMarkup();
    public void set_SrgsMarkup(string value);
}
public class System.Windows.Input.InputScopeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[TypeConverterAttribute("System.Windows.Input.InputScopeNameConverter, PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[ContentPropertyAttribute("NameValue")]
public class System.Windows.Input.InputScopeName : object {
    public InputScopeNameValue NameValue { get; public set; }
    public InputScopeName(InputScopeNameValue nameValue);
    public InputScopeNameValue get_NameValue();
    public void set_NameValue(InputScopeNameValue value);
    public sealed virtual void AddChild(object value);
    public sealed virtual void AddText(string name);
}
public class System.Windows.Input.InputScopeNameConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Input.InputScopeNameValue : Enum {
    public int value__;
    public static InputScopeNameValue Xml;
    public static InputScopeNameValue Srgs;
    public static InputScopeNameValue RegularExpression;
    public static InputScopeNameValue PhraseList;
    public static InputScopeNameValue Default;
    public static InputScopeNameValue Url;
    public static InputScopeNameValue FullFilePath;
    public static InputScopeNameValue FileName;
    public static InputScopeNameValue EmailUserName;
    public static InputScopeNameValue EmailSmtpAddress;
    public static InputScopeNameValue LogOnName;
    public static InputScopeNameValue PersonalFullName;
    public static InputScopeNameValue PersonalNamePrefix;
    public static InputScopeNameValue PersonalGivenName;
    public static InputScopeNameValue PersonalMiddleName;
    public static InputScopeNameValue PersonalSurname;
    public static InputScopeNameValue PersonalNameSuffix;
    public static InputScopeNameValue PostalAddress;
    public static InputScopeNameValue PostalCode;
    public static InputScopeNameValue AddressStreet;
    public static InputScopeNameValue AddressStateOrProvince;
    public static InputScopeNameValue AddressCity;
    public static InputScopeNameValue AddressCountryName;
    public static InputScopeNameValue AddressCountryShortName;
    public static InputScopeNameValue CurrencyAmountAndSymbol;
    public static InputScopeNameValue CurrencyAmount;
    public static InputScopeNameValue Date;
    public static InputScopeNameValue DateMonth;
    public static InputScopeNameValue DateDay;
    public static InputScopeNameValue DateYear;
    public static InputScopeNameValue DateMonthName;
    public static InputScopeNameValue DateDayName;
    public static InputScopeNameValue Digits;
    public static InputScopeNameValue Number;
    public static InputScopeNameValue OneChar;
    public static InputScopeNameValue Password;
    public static InputScopeNameValue TelephoneNumber;
    public static InputScopeNameValue TelephoneCountryCode;
    public static InputScopeNameValue TelephoneAreaCode;
    public static InputScopeNameValue TelephoneLocalNumber;
    public static InputScopeNameValue Time;
    public static InputScopeNameValue TimeHour;
    public static InputScopeNameValue TimeMinorSec;
    public static InputScopeNameValue NumberFullWidth;
    public static InputScopeNameValue AlphanumericHalfWidth;
    public static InputScopeNameValue AlphanumericFullWidth;
    public static InputScopeNameValue CurrencyChinese;
    public static InputScopeNameValue Bopomofo;
    public static InputScopeNameValue Hiragana;
    public static InputScopeNameValue KatakanaHalfWidth;
    public static InputScopeNameValue KatakanaFullWidth;
    public static InputScopeNameValue Hanja;
}
[ContentPropertyAttribute("Name")]
public class System.Windows.Input.InputScopePhrase : object {
    public string Name { get; public set; }
    public InputScopePhrase(string name);
    public string get_Name();
    public void set_Name(string value);
    public sealed virtual void AddChild(object value);
    public sealed virtual void AddText(string name);
}
public enum System.Windows.Input.InputType : Enum {
    public int value__;
    public static InputType Keyboard;
    public static InputType Mouse;
    public static InputType Stylus;
    public static InputType Hid;
    public static InputType Text;
    public static InputType Command;
}
public class System.Windows.Input.KeyBinding : InputBinding {
    public static DependencyProperty KeyProperty;
    public static DependencyProperty ModifiersProperty;
    [TypeConverterAttribute("System.Windows.Input.KeyGestureConverter")]
[ValueSerializerAttribute("System.Windows.Input.KeyGestureValueSerializer")]
public InputGesture Gesture { get; public set; }
    public Key Key { get; public set; }
    public ModifierKeys Modifiers { get; public set; }
    public KeyBinding(ICommand command, Key key, ModifierKeys modifiers);
    public KeyBinding(ICommand command, KeyGesture gesture);
    public virtual InputGesture get_Gesture();
    public virtual void set_Gesture(InputGesture value);
    public Key get_Key();
    public void set_Key(Key value);
    public ModifierKeys get_Modifiers();
    public void set_Modifiers(ModifierKeys value);
    protected virtual Freezable CreateInstanceCore();
}
public static class System.Windows.Input.Keyboard : object {
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent KeyboardInputProviderAcquireFocusEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent PreviewKeyboardInputProviderAcquireFocusEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RestoreFocusMode DefaultRestoreFocusMode { get; public set; }
    public static IInputElement FocusedElement { get; }
    public static ModifierKeys Modifiers { get; }
    public static KeyboardDevice PrimaryDevice { get; }
    public static RestoreFocusMode get_DefaultRestoreFocusMode();
    public static void set_DefaultRestoreFocusMode(RestoreFocusMode value);
    public static IInputElement get_FocusedElement();
    public static ModifierKeys get_Modifiers();
    public static KeyboardDevice get_PrimaryDevice();
    public static void AddGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void AddKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddPreviewGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddPreviewKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void AddPreviewKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddPreviewKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddPreviewLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void ClearFocus();
    public static IInputElement Focus(IInputElement element);
    public static KeyStates GetKeyStates(Key key);
    public static bool IsKeyDown(Key key);
    public static bool IsKeyToggled(Key key);
    public static bool IsKeyUp(Key key);
    public static void RemoveGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemoveKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void RemoveKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemoveKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemoveLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemovePreviewGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemovePreviewKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void RemovePreviewKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemovePreviewKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemovePreviewLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
}
public abstract class System.Windows.Input.KeyboardDevice : InputDevice {
    public PresentationSource ActiveSource { get; }
    public RestoreFocusMode DefaultRestoreFocusMode { get; public set; }
    public IInputElement FocusedElement { get; }
    public ModifierKeys Modifiers { get; }
    public IInputElement Target { get; }
    protected KeyboardDevice(InputManager inputManager);
    public virtual PresentationSource get_ActiveSource();
    public RestoreFocusMode get_DefaultRestoreFocusMode();
    public void set_DefaultRestoreFocusMode(RestoreFocusMode value);
    public IInputElement get_FocusedElement();
    public ModifierKeys get_Modifiers();
    public virtual IInputElement get_Target();
    public void ClearFocus();
    public IInputElement Focus(IInputElement element);
    public KeyStates GetKeyStates(Key key);
    protected abstract virtual KeyStates GetKeyStatesFromSystem(Key key);
    public bool IsKeyDown(Key key);
    public bool IsKeyToggled(Key key);
    public bool IsKeyUp(Key key);
}
public class System.Windows.Input.KeyboardEventArgs : InputEventArgs {
    public KeyboardDevice KeyboardDevice { get; }
    public KeyboardEventArgs(KeyboardDevice keyboard, int timestamp);
    public KeyboardDevice get_KeyboardDevice();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardEventHandler : MulticastDelegate {
    public KeyboardEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyboardFocusChangedEventArgs : KeyboardEventArgs {
    public IInputElement NewFocus { get; }
    public IInputElement OldFocus { get; }
    public KeyboardFocusChangedEventArgs(KeyboardDevice keyboard, int timestamp, IInputElement oldFocus, IInputElement newFocus);
    public IInputElement get_NewFocus();
    public IInputElement get_OldFocus();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardFocusChangedEventHandler : MulticastDelegate {
    public KeyboardFocusChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardFocusChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardFocusChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyboardInputProviderAcquireFocusEventArgs : KeyboardEventArgs {
    public bool FocusAcquired { get; }
    public KeyboardInputProviderAcquireFocusEventArgs(KeyboardDevice keyboard, int timestamp, bool focusAcquired);
    public bool get_FocusAcquired();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler : MulticastDelegate {
    public KeyboardInputProviderAcquireFocusEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardInputProviderAcquireFocusEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardInputProviderAcquireFocusEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyEventArgs : KeyboardEventArgs {
    public Key DeadCharProcessedKey { get; }
    public Key ImeProcessedKey { get; }
    public PresentationSource InputSource { get; }
    public bool IsDown { get; }
    public bool IsRepeat { get; }
    public bool IsToggled { get; }
    public bool IsUp { get; }
    public Key Key { get; }
    public KeyStates KeyStates { get; }
    public Key SystemKey { get; }
    public KeyEventArgs(KeyboardDevice keyboard, PresentationSource inputSource, int timestamp, Key key);
    public Key get_DeadCharProcessedKey();
    public Key get_ImeProcessedKey();
    public PresentationSource get_InputSource();
    public bool get_IsDown();
    public bool get_IsRepeat();
    public bool get_IsToggled();
    public bool get_IsUp();
    public Key get_Key();
    public KeyStates get_KeyStates();
    public Key get_SystemKey();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyEventHandler : MulticastDelegate {
    public KeyEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.Input.KeyGestureConverter")]
[ValueSerializerAttribute("System.Windows.Input.KeyGestureValueSerializer")]
public class System.Windows.Input.KeyGesture : InputGesture {
    public string DisplayString { get; }
    public Key Key { get; }
    public ModifierKeys Modifiers { get; }
    public KeyGesture(Key key);
    public KeyGesture(Key key, ModifierKeys modifiers);
    public KeyGesture(Key key, ModifierKeys modifiers, string displayString);
    public string get_DisplayString();
    public Key get_Key();
    public ModifierKeys get_Modifiers();
    public string GetDisplayStringForCulture(CultureInfo culture);
    public virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
}
public class System.Windows.Input.KeyGestureConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Input.KeyGestureValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[FlagsAttribute]
public enum System.Windows.Input.KeyStates : Enum {
    public byte value__;
    public static KeyStates None;
    public static KeyStates Down;
    public static KeyStates Toggled;
}
public static class System.Windows.Input.Manipulation : object {
    public static void AddManipulator(UIElement element, IManipulator manipulator);
    public static void CompleteManipulation(UIElement element);
    public static IInputElement GetManipulationContainer(UIElement element);
    public static ManipulationModes GetManipulationMode(UIElement element);
    public static ManipulationPivot GetManipulationPivot(UIElement element);
    public static bool IsManipulationActive(UIElement element);
    public static void RemoveManipulator(UIElement element, IManipulator manipulator);
    public static void SetManipulationContainer(UIElement element, IInputElement container);
    public static void SetManipulationMode(UIElement element, ManipulationModes mode);
    [BrowsableAttribute("False")]
public static void SetManipulationParameter(UIElement element, ManipulationParameters2D parameter);
    public static void SetManipulationPivot(UIElement element, ManipulationPivot pivot);
    public static void StartInertia(UIElement element);
}
public class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs : InputEventArgs {
    public ManipulationDelta BoundaryFeedback { get; }
    public IInputElement ManipulationContainer { get; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public ManipulationDelta get_BoundaryFeedback();
    public IInputElement get_ManipulationContainer();
    public IEnumerable`1<IManipulator> get_Manipulators();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.ManipulationCompletedEventArgs : InputEventArgs {
    public ManipulationVelocities FinalVelocities { get; }
    public bool IsInertial { get; }
    public IInputElement ManipulationContainer { get; }
    public Point ManipulationOrigin { get; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public ManipulationDelta TotalManipulation { get; }
    public ManipulationVelocities get_FinalVelocities();
    public bool get_IsInertial();
    public IInputElement get_ManipulationContainer();
    public Point get_ManipulationOrigin();
    public IEnumerable`1<IManipulator> get_Manipulators();
    public ManipulationDelta get_TotalManipulation();
    public bool Cancel();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.ManipulationDelta : object {
    public Vector Expansion { get; }
    public double Rotation { get; }
    public Vector Scale { get; }
    public Vector Translation { get; }
    public ManipulationDelta(Vector translation, double rotation, Vector scale, Vector expansion);
    public Vector get_Expansion();
    public double get_Rotation();
    public Vector get_Scale();
    public Vector get_Translation();
}
public class System.Windows.Input.ManipulationDeltaEventArgs : InputEventArgs {
    public ManipulationDelta CumulativeManipulation { get; }
    public ManipulationDelta DeltaManipulation { get; }
    public bool IsInertial { get; }
    public IInputElement ManipulationContainer { get; }
    public Point ManipulationOrigin { get; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public ManipulationVelocities Velocities { get; }
    public ManipulationDelta get_CumulativeManipulation();
    public ManipulationDelta get_DeltaManipulation();
    public bool get_IsInertial();
    public IInputElement get_ManipulationContainer();
    public Point get_ManipulationOrigin();
    public IEnumerable`1<IManipulator> get_Manipulators();
    public ManipulationVelocities get_Velocities();
    public bool Cancel();
    public void Complete();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    public void ReportBoundaryFeedback(ManipulationDelta unusedManipulation);
    public void StartInertia();
}
public class System.Windows.Input.ManipulationInertiaStartingEventArgs : InputEventArgs {
    public InertiaExpansionBehavior ExpansionBehavior { get; public set; }
    public ManipulationVelocities InitialVelocities { get; }
    public IInputElement ManipulationContainer { get; }
    public Point ManipulationOrigin { get; public set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public InertiaRotationBehavior RotationBehavior { get; public set; }
    public InertiaTranslationBehavior TranslationBehavior { get; public set; }
    public InertiaExpansionBehavior get_ExpansionBehavior();
    public void set_ExpansionBehavior(InertiaExpansionBehavior value);
    public ManipulationVelocities get_InitialVelocities();
    public IInputElement get_ManipulationContainer();
    public Point get_ManipulationOrigin();
    public void set_ManipulationOrigin(Point value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    public InertiaRotationBehavior get_RotationBehavior();
    public void set_RotationBehavior(InertiaRotationBehavior value);
    public InertiaTranslationBehavior get_TranslationBehavior();
    public void set_TranslationBehavior(InertiaTranslationBehavior value);
    public bool Cancel();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [BrowsableAttribute("False")]
public void SetInertiaParameter(InertiaParameters2D parameter);
}
[FlagsAttribute]
public enum System.Windows.Input.ManipulationModes : Enum {
    public int value__;
    public static ManipulationModes None;
    public static ManipulationModes TranslateX;
    public static ManipulationModes TranslateY;
    public static ManipulationModes Translate;
    public static ManipulationModes Rotate;
    public static ManipulationModes Scale;
    public static ManipulationModes All;
}
public class System.Windows.Input.ManipulationPivot : object {
    public Point Center { get; public set; }
    public double Radius { get; public set; }
    public ManipulationPivot(Point center, double radius);
    public Point get_Center();
    public void set_Center(Point value);
    public double get_Radius();
    public void set_Radius(double value);
}
public class System.Windows.Input.ManipulationStartedEventArgs : InputEventArgs {
    public IInputElement ManipulationContainer { get; }
    public Point ManipulationOrigin { get; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public IInputElement get_ManipulationContainer();
    public Point get_ManipulationOrigin();
    public IEnumerable`1<IManipulator> get_Manipulators();
    public bool Cancel();
    public void Complete();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.ManipulationStartingEventArgs : InputEventArgs {
    public bool IsSingleTouchEnabled { get; public set; }
    public IInputElement ManipulationContainer { get; public set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public ManipulationModes Mode { get; public set; }
    public ManipulationPivot Pivot { get; public set; }
    public bool get_IsSingleTouchEnabled();
    public void set_IsSingleTouchEnabled(bool value);
    public IInputElement get_ManipulationContainer();
    public void set_ManipulationContainer(IInputElement value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    public ManipulationModes get_Mode();
    public void set_Mode(ManipulationModes value);
    public ManipulationPivot get_Pivot();
    public void set_Pivot(ManipulationPivot value);
    public bool Cancel();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [BrowsableAttribute("False")]
public void SetManipulationParameter(ManipulationParameters2D parameter);
}
public class System.Windows.Input.ManipulationVelocities : object {
    public double AngularVelocity { get; }
    public Vector ExpansionVelocity { get; }
    public Vector LinearVelocity { get; }
    public ManipulationVelocities(Vector linearVelocity, double angularVelocity, Vector expansionVelocity);
    public double get_AngularVelocity();
    public Vector get_ExpansionVelocity();
    public Vector get_LinearVelocity();
}
public static class System.Windows.Input.MediaCommands : object {
    public static RoutedUICommand BoostBass { get; }
    public static RoutedUICommand ChannelDown { get; }
    public static RoutedUICommand ChannelUp { get; }
    public static RoutedUICommand DecreaseBass { get; }
    public static RoutedUICommand DecreaseMicrophoneVolume { get; }
    public static RoutedUICommand DecreaseTreble { get; }
    public static RoutedUICommand DecreaseVolume { get; }
    public static RoutedUICommand FastForward { get; }
    public static RoutedUICommand IncreaseBass { get; }
    public static RoutedUICommand IncreaseMicrophoneVolume { get; }
    public static RoutedUICommand IncreaseTreble { get; }
    public static RoutedUICommand IncreaseVolume { get; }
    public static RoutedUICommand MuteMicrophoneVolume { get; }
    public static RoutedUICommand MuteVolume { get; }
    public static RoutedUICommand NextTrack { get; }
    public static RoutedUICommand Pause { get; }
    public static RoutedUICommand Play { get; }
    public static RoutedUICommand PreviousTrack { get; }
    public static RoutedUICommand Record { get; }
    public static RoutedUICommand Rewind { get; }
    public static RoutedUICommand Select { get; }
    public static RoutedUICommand Stop { get; }
    public static RoutedUICommand ToggleMicrophoneOnOff { get; }
    public static RoutedUICommand TogglePlayPause { get; }
    public static RoutedUICommand get_BoostBass();
    public static RoutedUICommand get_ChannelDown();
    public static RoutedUICommand get_ChannelUp();
    public static RoutedUICommand get_DecreaseBass();
    public static RoutedUICommand get_DecreaseMicrophoneVolume();
    public static RoutedUICommand get_DecreaseTreble();
    public static RoutedUICommand get_DecreaseVolume();
    public static RoutedUICommand get_FastForward();
    public static RoutedUICommand get_IncreaseBass();
    public static RoutedUICommand get_IncreaseMicrophoneVolume();
    public static RoutedUICommand get_IncreaseTreble();
    public static RoutedUICommand get_IncreaseVolume();
    public static RoutedUICommand get_MuteMicrophoneVolume();
    public static RoutedUICommand get_MuteVolume();
    public static RoutedUICommand get_NextTrack();
    public static RoutedUICommand get_Pause();
    public static RoutedUICommand get_Play();
    public static RoutedUICommand get_PreviousTrack();
    public static RoutedUICommand get_Record();
    public static RoutedUICommand get_Rewind();
    public static RoutedUICommand get_Select();
    public static RoutedUICommand get_Stop();
    public static RoutedUICommand get_ToggleMicrophoneOnOff();
    public static RoutedUICommand get_TogglePlayPause();
}
public static class System.Windows.Input.Mouse : object {
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent MouseUpEvent;
    public static int MouseWheelDeltaForOneLine;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent PreviewMouseDownOutsideCapturedElementEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent PreviewMouseUpOutsideCapturedElementEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent QueryCursorEvent;
    public static IInputElement Captured { get; }
    public static IInputElement DirectlyOver { get; }
    public static MouseButtonState LeftButton { get; }
    public static MouseButtonState MiddleButton { get; }
    public static Cursor OverrideCursor { get; public set; }
    public static MouseDevice PrimaryDevice { get; }
    public static MouseButtonState RightButton { get; }
    public static MouseButtonState XButton1 { get; }
    public static MouseButtonState XButton2 { get; }
    public static IInputElement get_Captured();
    public static IInputElement get_DirectlyOver();
    public static MouseButtonState get_LeftButton();
    public static MouseButtonState get_MiddleButton();
    public static Cursor get_OverrideCursor();
    public static void set_OverrideCursor(Cursor value);
    public static MouseDevice get_PrimaryDevice();
    public static MouseButtonState get_RightButton();
    public static MouseButtonState get_XButton1();
    public static MouseButtonState get_XButton2();
    public static void AddGotMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddLostMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddMouseEnterHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddMouseLeaveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void AddPreviewMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseDownOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddPreviewMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseUpOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void AddQueryCursorHandler(DependencyObject element, QueryCursorEventHandler handler);
    public static bool Capture(IInputElement element);
    public static bool Capture(IInputElement element, CaptureMode captureMode);
    public static int GetIntermediatePoints(IInputElement relativeTo, Point[] points);
    public static Point GetPosition(IInputElement relativeTo);
    public static void RemoveGotMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveLostMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemoveMouseEnterHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseLeaveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemoveMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void RemovePreviewMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseDownOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemovePreviewMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseUpOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void RemoveQueryCursorHandler(DependencyObject element, QueryCursorEventHandler handler);
    public static bool SetCursor(Cursor cursor);
    public static void Synchronize();
    public static void UpdateCursor();
}
[TypeConverterAttribute("System.Windows.Input.MouseActionConverter")]
[ValueSerializerAttribute("System.Windows.Input.MouseActionValueSerializer")]
public enum System.Windows.Input.MouseAction : Enum {
    public byte value__;
    public static MouseAction None;
    public static MouseAction LeftClick;
    public static MouseAction RightClick;
    public static MouseAction MiddleClick;
    public static MouseAction WheelClick;
    public static MouseAction LeftDoubleClick;
    public static MouseAction RightDoubleClick;
    public static MouseAction MiddleDoubleClick;
}
public class System.Windows.Input.MouseActionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Input.MouseActionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.MouseBinding : InputBinding {
    public static DependencyProperty MouseActionProperty;
    [TypeConverterAttribute("System.Windows.Input.MouseGestureConverter")]
[ValueSerializerAttribute("System.Windows.Input.MouseGestureValueSerializer")]
public InputGesture Gesture { get; public set; }
    public MouseAction MouseAction { get; public set; }
    public MouseBinding(ICommand command, MouseGesture gesture);
    public virtual InputGesture get_Gesture();
    public virtual void set_Gesture(InputGesture value);
    public MouseAction get_MouseAction();
    public void set_MouseAction(MouseAction value);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
public enum System.Windows.Input.MouseButton : Enum {
    public int value__;
    public static MouseButton Left;
    public static MouseButton Middle;
    public static MouseButton Right;
    public static MouseButton XButton1;
    public static MouseButton XButton2;
}
public class System.Windows.Input.MouseButtonEventArgs : MouseEventArgs {
    public MouseButtonState ButtonState { get; }
    public MouseButton ChangedButton { get; }
    public int ClickCount { get; }
    public MouseButtonEventArgs(MouseDevice mouse, int timestamp, MouseButton button);
    public MouseButtonEventArgs(MouseDevice mouse, int timestamp, MouseButton button, StylusDevice stylusDevice);
    public MouseButtonState get_ButtonState();
    public MouseButton get_ChangedButton();
    public int get_ClickCount();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseButtonEventHandler : MulticastDelegate {
    public MouseButtonEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseButtonEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseButtonEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.MouseButtonState : Enum {
    public int value__;
    public static MouseButtonState Released;
    public static MouseButtonState Pressed;
}
public abstract class System.Windows.Input.MouseDevice : InputDevice {
    public PresentationSource ActiveSource { get; }
    public IInputElement Captured { get; }
    public IInputElement DirectlyOver { get; }
    public MouseButtonState LeftButton { get; }
    public MouseButtonState MiddleButton { get; }
    public Cursor OverrideCursor { get; public set; }
    public MouseButtonState RightButton { get; }
    public IInputElement Target { get; }
    public MouseButtonState XButton1 { get; }
    public MouseButtonState XButton2 { get; }
    public virtual PresentationSource get_ActiveSource();
    public IInputElement get_Captured();
    public IInputElement get_DirectlyOver();
    public MouseButtonState get_LeftButton();
    public MouseButtonState get_MiddleButton();
    public Cursor get_OverrideCursor();
    public void set_OverrideCursor(Cursor value);
    public MouseButtonState get_RightButton();
    public virtual IInputElement get_Target();
    public MouseButtonState get_XButton1();
    public MouseButtonState get_XButton2();
    public bool Capture(IInputElement element);
    public bool Capture(IInputElement element, CaptureMode captureMode);
    protected MouseButtonState GetButtonState(MouseButton mouseButton);
    protected Point GetClientPosition();
    protected Point GetClientPosition(PresentationSource presentationSource);
    public Point GetPosition(IInputElement relativeTo);
    protected Point GetScreenPosition();
    public bool SetCursor(Cursor cursor);
    public void Synchronize();
    public void UpdateCursor();
}
public class System.Windows.Input.MouseEventArgs : InputEventArgs {
    public MouseButtonState LeftButton { get; }
    public MouseButtonState MiddleButton { get; }
    public MouseDevice MouseDevice { get; }
    public MouseButtonState RightButton { get; }
    public StylusDevice StylusDevice { get; }
    public MouseButtonState XButton1 { get; }
    public MouseButtonState XButton2 { get; }
    public MouseEventArgs(MouseDevice mouse, int timestamp);
    public MouseEventArgs(MouseDevice mouse, int timestamp, StylusDevice stylusDevice);
    public MouseButtonState get_LeftButton();
    public MouseButtonState get_MiddleButton();
    public MouseDevice get_MouseDevice();
    public MouseButtonState get_RightButton();
    public StylusDevice get_StylusDevice();
    public MouseButtonState get_XButton1();
    public MouseButtonState get_XButton2();
    public Point GetPosition(IInputElement relativeTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseEventHandler : MulticastDelegate {
    public MouseEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.Input.MouseGestureConverter")]
[ValueSerializerAttribute("System.Windows.Input.MouseGestureValueSerializer")]
public class System.Windows.Input.MouseGesture : InputGesture {
    public ModifierKeys Modifiers { get; public set; }
    public MouseAction MouseAction { get; public set; }
    public MouseGesture(MouseAction mouseAction);
    public MouseGesture(MouseAction mouseAction, ModifierKeys modifiers);
    public ModifierKeys get_Modifiers();
    public void set_Modifiers(ModifierKeys value);
    public MouseAction get_MouseAction();
    public void set_MouseAction(MouseAction value);
    public virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
}
public class System.Windows.Input.MouseGestureConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Input.MouseGestureValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.MouseWheelEventArgs : MouseEventArgs {
    public int Delta { get; }
    public MouseWheelEventArgs(MouseDevice mouse, int timestamp, int delta);
    public int get_Delta();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseWheelEventHandler : MulticastDelegate {
    public MouseWheelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseWheelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseWheelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Input.NavigationCommands : object {
    public static RoutedUICommand BrowseBack { get; }
    public static RoutedUICommand BrowseForward { get; }
    public static RoutedUICommand BrowseHome { get; }
    public static RoutedUICommand BrowseStop { get; }
    public static RoutedUICommand DecreaseZoom { get; }
    public static RoutedUICommand Favorites { get; }
    public static RoutedUICommand FirstPage { get; }
    public static RoutedUICommand GoToPage { get; }
    public static RoutedUICommand IncreaseZoom { get; }
    public static RoutedUICommand LastPage { get; }
    public static RoutedUICommand NavigateJournal { get; }
    public static RoutedUICommand NextPage { get; }
    public static RoutedUICommand PreviousPage { get; }
    public static RoutedUICommand Refresh { get; }
    public static RoutedUICommand Search { get; }
    public static RoutedUICommand Zoom { get; }
    public static RoutedUICommand get_BrowseBack();
    public static RoutedUICommand get_BrowseForward();
    public static RoutedUICommand get_BrowseHome();
    public static RoutedUICommand get_BrowseStop();
    public static RoutedUICommand get_DecreaseZoom();
    public static RoutedUICommand get_Favorites();
    public static RoutedUICommand get_FirstPage();
    public static RoutedUICommand get_GoToPage();
    public static RoutedUICommand get_IncreaseZoom();
    public static RoutedUICommand get_LastPage();
    public static RoutedUICommand get_NavigateJournal();
    public static RoutedUICommand get_NextPage();
    public static RoutedUICommand get_PreviousPage();
    public static RoutedUICommand get_Refresh();
    public static RoutedUICommand get_Search();
    public static RoutedUICommand get_Zoom();
}
public class System.Windows.Input.NotifyInputEventArgs : EventArgs {
    public InputManager InputManager { get; }
    public StagingAreaInputItem StagingItem { get; }
    public InputManager get_InputManager();
    public StagingAreaInputItem get_StagingItem();
}
public class System.Windows.Input.NotifyInputEventHandler : MulticastDelegate {
    public NotifyInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NotifyInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NotifyInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.PreProcessInputEventArgs : ProcessInputEventArgs {
    public bool Canceled { get; }
    public bool get_Canceled();
    public void Cancel();
}
public class System.Windows.Input.PreProcessInputEventHandler : MulticastDelegate {
    public PreProcessInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PreProcessInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PreProcessInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.ProcessInputEventArgs : NotifyInputEventArgs {
    public StagingAreaInputItem PeekInput();
    public StagingAreaInputItem PopInput();
    public StagingAreaInputItem PushInput(InputEventArgs input, StagingAreaInputItem promote);
    public StagingAreaInputItem PushInput(StagingAreaInputItem input);
}
public class System.Windows.Input.ProcessInputEventHandler : MulticastDelegate {
    public ProcessInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ProcessInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ProcessInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.QueryCursorEventArgs : MouseEventArgs {
    public Cursor Cursor { get; public set; }
    public QueryCursorEventArgs(MouseDevice mouse, int timestamp);
    public QueryCursorEventArgs(MouseDevice mouse, int timestamp, StylusDevice stylusDevice);
    public Cursor get_Cursor();
    public void set_Cursor(Cursor value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.QueryCursorEventHandler : MulticastDelegate {
    public QueryCursorEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, QueryCursorEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, QueryCursorEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.RestoreFocusMode : Enum {
    public int value__;
    public static RestoreFocusMode Auto;
    public static RestoreFocusMode None;
}
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[ValueSerializerAttribute("System.Windows.Input.CommandValueSerializer, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.RoutedCommand : object {
    public InputGestureCollection InputGestures { get; }
    public string Name { get; }
    public Type OwnerType { get; }
    public RoutedCommand(string name, Type ownerType);
    public RoutedCommand(string name, Type ownerType, InputGestureCollection inputGestures);
    public InputGestureCollection get_InputGestures();
    public string get_Name();
    public Type get_OwnerType();
    public sealed virtual void add_CanExecuteChanged(EventHandler value);
    public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public bool CanExecute(object parameter, IInputElement target);
    public void Execute(object parameter, IInputElement target);
    private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object parameter);
    private sealed virtual override void System.Windows.Input.ICommand.Execute(object parameter);
}
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.RoutedUICommand : RoutedCommand {
    public string Text { get; public set; }
    public RoutedUICommand(string text, string name, Type ownerType);
    public RoutedUICommand(string text, string name, Type ownerType, InputGestureCollection inputGestures);
    public string get_Text();
    public void set_Text(string value);
}
public enum System.Windows.Input.SpeechMode : Enum {
    public int value__;
    public static SpeechMode Dictation;
    public static SpeechMode Command;
    public static SpeechMode Indeterminate;
}
public class System.Windows.Input.StagingAreaInputItem : object {
    public InputEventArgs Input { get; }
    public InputEventArgs get_Input();
    public object GetData(object key);
    public void SetData(object key, object value);
}
public static class System.Windows.Input.Stylus : object {
    public static RoutedEvent GotStylusCaptureEvent;
    public static DependencyProperty IsFlicksEnabledProperty;
    public static DependencyProperty IsPressAndHoldEnabledProperty;
    public static DependencyProperty IsTapFeedbackEnabledProperty;
    public static DependencyProperty IsTouchFeedbackEnabledProperty;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent StylusUpEvent;
    public static IInputElement Captured { get; }
    public static StylusDevice CurrentStylusDevice { get; }
    public static IInputElement DirectlyOver { get; }
    public static IInputElement get_Captured();
    public static StylusDevice get_CurrentStylusDevice();
    public static IInputElement get_DirectlyOver();
    public static void AddGotStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddLostStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddPreviewStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddPreviewStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void AddPreviewStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void AddPreviewStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void AddStylusEnterHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusLeaveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void AddStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static bool Capture(IInputElement element);
    public static bool Capture(IInputElement element, CaptureMode captureMode);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsFlicksEnabled(DependencyObject element);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsPressAndHoldEnabled(DependencyObject element);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsTapFeedbackEnabled(DependencyObject element);
    public static bool GetIsTouchFeedbackEnabled(DependencyObject element);
    public static void RemoveGotStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveLostStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemovePreviewStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemovePreviewStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void RemovePreviewStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void RemovePreviewStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemoveStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemoveStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void RemoveStylusEnterHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusLeaveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void RemoveStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void SetIsFlicksEnabled(DependencyObject element, bool enabled);
    public static void SetIsPressAndHoldEnabled(DependencyObject element, bool enabled);
    public static void SetIsTapFeedbackEnabled(DependencyObject element, bool enabled);
    public static void SetIsTouchFeedbackEnabled(DependencyObject element, bool enabled);
    public static void Synchronize();
}
public class System.Windows.Input.StylusButton : object {
    public Guid Guid { get; }
    public string Name { get; }
    public StylusButtonState StylusButtonState { get; }
    public StylusDevice StylusDevice { get; }
    public Guid get_Guid();
    public string get_Name();
    public StylusButtonState get_StylusButtonState();
    public StylusDevice get_StylusDevice();
    public virtual string ToString();
}
public class System.Windows.Input.StylusButtonCollection : ReadOnlyCollection`1<StylusButton> {
    public StylusButton GetStylusButtonByGuid(Guid guid);
}
public class System.Windows.Input.StylusButtonEventArgs : StylusEventArgs {
    public StylusButton StylusButton { get; }
    public StylusButtonEventArgs(StylusDevice stylusDevice, int timestamp, StylusButton button);
    public StylusButton get_StylusButton();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusButtonEventHandler : MulticastDelegate {
    public StylusButtonEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusButtonEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusButtonEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.StylusButtonState : Enum {
    public int value__;
    public static StylusButtonState Up;
    public static StylusButtonState Down;
}
public class System.Windows.Input.StylusDevice : InputDevice {
    public PresentationSource ActiveSource { get; }
    public IInputElement Captured { get; }
    public IInputElement DirectlyOver { get; }
    public int Id { get; }
    public bool InAir { get; }
    public bool InRange { get; }
    public bool Inverted { get; }
    public bool IsValid { get; }
    public string Name { get; }
    public StylusButtonCollection StylusButtons { get; }
    public TabletDevice TabletDevice { get; }
    public IInputElement Target { get; }
    public virtual PresentationSource get_ActiveSource();
    public IInputElement get_Captured();
    public IInputElement get_DirectlyOver();
    public int get_Id();
    public bool get_InAir();
    public bool get_InRange();
    public bool get_Inverted();
    public bool get_IsValid();
    public string get_Name();
    public StylusButtonCollection get_StylusButtons();
    public TabletDevice get_TabletDevice();
    public virtual IInputElement get_Target();
    public bool Capture(IInputElement element);
    public bool Capture(IInputElement element, CaptureMode captureMode);
    public Point GetPosition(IInputElement relativeTo);
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    public void Synchronize();
    public virtual string ToString();
}
public class System.Windows.Input.StylusDeviceCollection : ReadOnlyCollection`1<StylusDevice> {
}
public class System.Windows.Input.StylusDownEventArgs : StylusEventArgs {
    public int TapCount { get; }
    public StylusDownEventArgs(StylusDevice stylusDevice, int timestamp);
    public int get_TapCount();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusDownEventHandler : MulticastDelegate {
    public StylusDownEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusDownEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusDownEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.StylusEventArgs : InputEventArgs {
    public bool InAir { get; }
    public bool Inverted { get; }
    public StylusDevice StylusDevice { get; }
    public StylusEventArgs(StylusDevice stylus, int timestamp);
    public bool get_InAir();
    public bool get_Inverted();
    public StylusDevice get_StylusDevice();
    public Point GetPosition(IInputElement relativeTo);
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusEventHandler : MulticastDelegate {
    public StylusEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.StylusPlugIns.DynamicRenderer : StylusPlugIn {
    public DrawingAttributes DrawingAttributes { get; public set; }
    public Visual RootVisual { get; }
    public DrawingAttributes get_DrawingAttributes();
    public void set_DrawingAttributes(DrawingAttributes value);
    public Visual get_RootVisual();
    protected Dispatcher GetDispatcher();
    protected virtual void OnAdded();
    protected virtual void OnDraw(DrawingContext drawingContext, StylusPointCollection stylusPoints, Geometry geometry, Brush fillBrush);
    protected virtual void OnDrawingAttributesReplaced();
    protected virtual void OnEnabledChanged();
    protected virtual void OnIsActiveForInputChanged();
    protected virtual void OnRemoved();
    protected virtual void OnStylusDown(RawStylusInput rawStylusInput);
    protected virtual void OnStylusDownProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusEnter(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusLeave(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusMove(RawStylusInput rawStylusInput);
    protected virtual void OnStylusUp(RawStylusInput rawStylusInput);
    protected virtual void OnStylusUpProcessed(object callbackData, bool targetVerified);
    public virtual void Reset(StylusDevice stylusDevice, StylusPointCollection stylusPoints);
}
public class System.Windows.Input.StylusPlugIns.RawStylusInput : object {
    public int StylusDeviceId { get; }
    public int TabletDeviceId { get; }
    public int Timestamp { get; }
    public int get_StylusDeviceId();
    public int get_TabletDeviceId();
    public int get_Timestamp();
    public StylusPointCollection GetStylusPoints();
    public void NotifyWhenProcessed(object callbackData);
    public void SetStylusPoints(StylusPointCollection stylusPoints);
}
public abstract class System.Windows.Input.StylusPlugIns.StylusPlugIn : object {
    public UIElement Element { get; }
    public Rect ElementBounds { get; }
    public bool Enabled { get; public set; }
    public bool IsActiveForInput { get; }
    public UIElement get_Element();
    public Rect get_ElementBounds();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public bool get_IsActiveForInput();
    protected virtual void OnAdded();
    protected virtual void OnEnabledChanged();
    protected virtual void OnIsActiveForInputChanged();
    protected virtual void OnRemoved();
    protected virtual void OnStylusDown(RawStylusInput rawStylusInput);
    protected virtual void OnStylusDownProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusEnter(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusLeave(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusMove(RawStylusInput rawStylusInput);
    protected virtual void OnStylusMoveProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusUp(RawStylusInput rawStylusInput);
    protected virtual void OnStylusUpProcessed(object callbackData, bool targetVerified);
}
public class System.Windows.Input.StylusPlugIns.StylusPlugInCollection : Collection`1<StylusPlugIn> {
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, StylusPlugIn plugIn);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, StylusPlugIn plugIn);
}
public class System.Windows.Input.StylusPoint : ValueType {
    public static double MaxXY;
    public static double MinXY;
    public StylusPointDescription Description { get; }
    public float PressureFactor { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public StylusPoint(double x, double y);
    public StylusPoint(double x, double y, float pressureFactor);
    public StylusPoint(double x, double y, float pressureFactor, StylusPointDescription stylusPointDescription, Int32[] additionalValues);
    public StylusPointDescription get_Description();
    public float get_PressureFactor();
    public void set_PressureFactor(float value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(StylusPoint value);
    public static bool Equals(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public virtual int GetHashCode();
    public int GetPropertyValue(StylusPointProperty stylusPointProperty);
    public bool HasProperty(StylusPointProperty stylusPointProperty);
    public static bool op_Equality(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public static Point op_Explicit(StylusPoint stylusPoint);
    public static bool op_Inequality(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public void SetPropertyValue(StylusPointProperty stylusPointProperty, int value);
    public Point ToPoint();
}
public class System.Windows.Input.StylusPointCollection : Collection`1<StylusPoint> {
    public StylusPointDescription Description { get; }
    public StylusPointCollection(IEnumerable`1<StylusPoint> stylusPoints);
    public StylusPointCollection(IEnumerable`1<Point> points);
    public StylusPointCollection(int initialCapacity);
    public StylusPointCollection(StylusPointDescription stylusPointDescription);
    public StylusPointCollection(StylusPointDescription stylusPointDescription, int initialCapacity);
    public StylusPointDescription get_Description();
    public void add_Changed(EventHandler value);
    public void remove_Changed(EventHandler value);
    public void Add(StylusPointCollection stylusPoints);
    protected sealed virtual void ClearItems();
    public StylusPointCollection Clone();
    protected sealed virtual void InsertItem(int index, StylusPoint stylusPoint);
    protected virtual void OnChanged(EventArgs e);
    public static Point[] op_Explicit(StylusPointCollection stylusPoints);
    public StylusPointCollection Reformat(StylusPointDescription subsetToReformatTo);
    protected sealed virtual void RemoveItem(int index);
    protected sealed virtual void SetItem(int index, StylusPoint stylusPoint);
    public Int32[] ToHiMetricArray();
}
public class System.Windows.Input.StylusPointDescription : object {
    public int PropertyCount { get; }
    public StylusPointDescription(IEnumerable`1<StylusPointPropertyInfo> stylusPointPropertyInfos);
    public int get_PropertyCount();
    public static bool AreCompatible(StylusPointDescription stylusPointDescription1, StylusPointDescription stylusPointDescription2);
    public static StylusPointDescription GetCommonDescription(StylusPointDescription stylusPointDescription, StylusPointDescription stylusPointDescriptionPreserveInfo);
    public StylusPointPropertyInfo GetPropertyInfo(StylusPointProperty stylusPointProperty);
    public ReadOnlyCollection`1<StylusPointPropertyInfo> GetStylusPointProperties();
    public bool HasProperty(StylusPointProperty stylusPointProperty);
    public bool IsSubsetOf(StylusPointDescription stylusPointDescriptionSuperset);
}
public static class System.Windows.Input.StylusPointProperties : object {
    public static StylusPointProperty AltitudeOrientation;
    public static StylusPointProperty AzimuthOrientation;
    public static StylusPointProperty BarrelButton;
    public static StylusPointProperty ButtonPressure;
    public static StylusPointProperty Height;
    public static StylusPointProperty NormalPressure;
    public static StylusPointProperty PacketStatus;
    public static StylusPointProperty PitchRotation;
    public static StylusPointProperty RollRotation;
    public static StylusPointProperty SecondaryTipButton;
    public static StylusPointProperty SerialNumber;
    public static StylusPointProperty SystemTouch;
    public static StylusPointProperty TangentPressure;
    public static StylusPointProperty TipButton;
    public static StylusPointProperty TwistOrientation;
    public static StylusPointProperty Width;
    public static StylusPointProperty X;
    public static StylusPointProperty XTiltOrientation;
    public static StylusPointProperty Y;
    public static StylusPointProperty YawRotation;
    public static StylusPointProperty YTiltOrientation;
    public static StylusPointProperty Z;
}
public class System.Windows.Input.StylusPointProperty : object {
    public Guid Id { get; }
    public bool IsButton { get; }
    public StylusPointProperty(Guid identifier, bool isButton);
    protected StylusPointProperty(StylusPointProperty stylusPointProperty);
    public Guid get_Id();
    public bool get_IsButton();
    public virtual string ToString();
}
public class System.Windows.Input.StylusPointPropertyInfo : StylusPointProperty {
    public int Maximum { get; }
    public int Minimum { get; }
    public float Resolution { get; }
    public StylusPointPropertyUnit Unit { get; }
    public StylusPointPropertyInfo(StylusPointProperty stylusPointProperty);
    public StylusPointPropertyInfo(StylusPointProperty stylusPointProperty, int minimum, int maximum, StylusPointPropertyUnit unit, float resolution);
    public int get_Maximum();
    public int get_Minimum();
    public float get_Resolution();
    public StylusPointPropertyUnit get_Unit();
}
public enum System.Windows.Input.StylusPointPropertyUnit : Enum {
    public int value__;
    public static StylusPointPropertyUnit None;
    public static StylusPointPropertyUnit Inches;
    public static StylusPointPropertyUnit Centimeters;
    public static StylusPointPropertyUnit Degrees;
    public static StylusPointPropertyUnit Radians;
    public static StylusPointPropertyUnit Seconds;
    public static StylusPointPropertyUnit Pounds;
    public static StylusPointPropertyUnit Grams;
}
public class System.Windows.Input.StylusSystemGestureEventArgs : StylusEventArgs {
    public SystemGesture SystemGesture { get; }
    public StylusSystemGestureEventArgs(StylusDevice stylusDevice, int timestamp, SystemGesture systemGesture);
    public SystemGesture get_SystemGesture();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusSystemGestureEventHandler : MulticastDelegate {
    public StylusSystemGestureEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusSystemGestureEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusSystemGestureEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.StylusWisp.WispTabletDeviceCollection : TabletDeviceCollection {
}
public enum System.Windows.Input.SystemGesture : Enum {
    public int value__;
    public static SystemGesture None;
    public static SystemGesture Tap;
    public static SystemGesture RightTap;
    public static SystemGesture Drag;
    public static SystemGesture RightDrag;
    public static SystemGesture HoldEnter;
    public static SystemGesture HoldLeave;
    public static SystemGesture HoverEnter;
    public static SystemGesture HoverLeave;
    public static SystemGesture Flick;
    public static SystemGesture TwoFingerTap;
}
public static class System.Windows.Input.Tablet : object {
    public static TabletDevice CurrentTabletDevice { get; }
    public static TabletDeviceCollection TabletDevices { get; }
    public static TabletDevice get_CurrentTabletDevice();
    public static TabletDeviceCollection get_TabletDevices();
}
public class System.Windows.Input.TabletDevice : InputDevice {
    public PresentationSource ActiveSource { get; }
    public int Id { get; }
    public string Name { get; }
    public string ProductId { get; }
    public StylusDeviceCollection StylusDevices { get; }
    public ReadOnlyCollection`1<StylusPointProperty> SupportedStylusPointProperties { get; }
    public TabletHardwareCapabilities TabletHardwareCapabilities { get; }
    public IInputElement Target { get; }
    public TabletDeviceType Type { get; }
    public virtual PresentationSource get_ActiveSource();
    public int get_Id();
    public string get_Name();
    public string get_ProductId();
    public StylusDeviceCollection get_StylusDevices();
    public ReadOnlyCollection`1<StylusPointProperty> get_SupportedStylusPointProperties();
    public TabletHardwareCapabilities get_TabletHardwareCapabilities();
    public virtual IInputElement get_Target();
    public TabletDeviceType get_Type();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.TabletDeviceCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public TabletDevice Item { get; }
    public object SyncRoot { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public TabletDevice get_Item(int index);
    public sealed virtual object get_SyncRoot();
    public void CopyTo(TabletDevice[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum System.Windows.Input.TabletDeviceType : Enum {
    public int value__;
    public static TabletDeviceType Stylus;
    public static TabletDeviceType Touch;
}
[FlagsAttribute]
public enum System.Windows.Input.TabletHardwareCapabilities : Enum {
    public int value__;
    public static TabletHardwareCapabilities None;
    public static TabletHardwareCapabilities Integrated;
    public static TabletHardwareCapabilities StylusMustTouch;
    public static TabletHardwareCapabilities HardProximity;
    public static TabletHardwareCapabilities StylusHasPhysicalIds;
    public static TabletHardwareCapabilities SupportsPressure;
}
public class System.Windows.Input.TextComposition : DispatcherObject {
    public TextCompositionAutoComplete AutoComplete { get; }
    [CLSCompliantAttribute("False")]
public string CompositionText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string ControlText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string SystemCompositionText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string SystemText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string Text { get; protected set; }
    public TextComposition(InputManager inputManager, IInputElement source, string resultText);
    public TextComposition(InputManager inputManager, IInputElement source, string resultText, TextCompositionAutoComplete autoComplete);
    public TextCompositionAutoComplete get_AutoComplete();
    public string get_CompositionText();
    protected void set_CompositionText(string value);
    public string get_ControlText();
    protected void set_ControlText(string value);
    public string get_SystemCompositionText();
    protected void set_SystemCompositionText(string value);
    public string get_SystemText();
    protected void set_SystemText(string value);
    public string get_Text();
    protected void set_Text(string value);
    public virtual void Complete();
}
public enum System.Windows.Input.TextCompositionAutoComplete : Enum {
    public int value__;
    public static TextCompositionAutoComplete Off;
    public static TextCompositionAutoComplete On;
}
public class System.Windows.Input.TextCompositionEventArgs : InputEventArgs {
    public string ControlText { get; }
    public string SystemText { get; }
    public string Text { get; }
    public TextComposition TextComposition { get; }
    public TextCompositionEventArgs(InputDevice inputDevice, TextComposition composition);
    public string get_ControlText();
    public string get_SystemText();
    public string get_Text();
    public TextComposition get_TextComposition();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.TextCompositionEventHandler : MulticastDelegate {
    public TextCompositionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TextCompositionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TextCompositionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.TextCompositionManager : DispatcherObject {
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent PreviewTextInputStartEvent;
    public static RoutedEvent PreviewTextInputUpdateEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent TextInputStartEvent;
    public static RoutedEvent TextInputUpdateEvent;
    public static void AddPreviewTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddPreviewTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddPreviewTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static bool CompleteComposition(TextComposition composition);
    public static void RemovePreviewTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemovePreviewTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemovePreviewTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static bool StartComposition(TextComposition composition);
    public static bool UpdateComposition(TextComposition composition);
}
public static class System.Windows.Input.Touch : object {
    public static void add_FrameReported(TouchFrameEventHandler value);
    public static void remove_FrameReported(TouchFrameEventHandler value);
}
public enum System.Windows.Input.TouchAction : Enum {
    public int value__;
    public static TouchAction Down;
    public static TouchAction Move;
    public static TouchAction Up;
}
public abstract class System.Windows.Input.TouchDevice : InputDevice {
    public PresentationSource ActiveSource { get; }
    public IInputElement Captured { get; }
    public CaptureMode CaptureMode { get; }
    public IInputElement DirectlyOver { get; }
    public int Id { get; }
    public bool IsActive { get; }
    private int System.Windows.Input.IManipulator.Id { get; }
    public IInputElement Target { get; }
    protected TouchDevice(int deviceId);
    public sealed virtual PresentationSource get_ActiveSource();
    public IInputElement get_Captured();
    public CaptureMode get_CaptureMode();
    public IInputElement get_DirectlyOver();
    public int get_Id();
    public bool get_IsActive();
    private sealed virtual override int System.Windows.Input.IManipulator.get_Id();
    public sealed virtual IInputElement get_Target();
    public void add_Activated(EventHandler value);
    public void remove_Activated(EventHandler value);
    public void add_Deactivated(EventHandler value);
    public void remove_Deactivated(EventHandler value);
    public sealed virtual void add_Updated(EventHandler value);
    public sealed virtual void remove_Updated(EventHandler value);
    protected void Activate();
    public bool Capture(IInputElement element);
    public bool Capture(IInputElement element, CaptureMode captureMode);
    protected void Deactivate();
    public abstract virtual TouchPointCollection GetIntermediateTouchPoints(IInputElement relativeTo);
    public abstract virtual TouchPoint GetTouchPoint(IInputElement relativeTo);
    protected virtual void OnCapture(IInputElement element, CaptureMode captureMode);
    protected virtual void OnManipulationEnded(bool cancel);
    protected virtual void OnManipulationStarted();
    protected bool ReportDown();
    protected bool ReportMove();
    protected bool ReportUp();
    protected void SetActiveSource(PresentationSource activeSource);
    public void Synchronize();
    private sealed virtual override Point System.Windows.Input.IManipulator.GetPosition(IInputElement relativeTo);
    private sealed virtual override void System.Windows.Input.IManipulator.ManipulationEnded(bool cancel);
}
public class System.Windows.Input.TouchEventArgs : InputEventArgs {
    public TouchDevice TouchDevice { get; }
    public TouchEventArgs(TouchDevice touchDevice, int timestamp);
    public TouchDevice get_TouchDevice();
    public TouchPointCollection GetIntermediateTouchPoints(IInputElement relativeTo);
    public TouchPoint GetTouchPoint(IInputElement relativeTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.TouchFrameEventArgs : EventArgs {
    public int Timestamp { get; }
    public int get_Timestamp();
    public TouchPoint GetPrimaryTouchPoint(IInputElement relativeTo);
    public TouchPointCollection GetTouchPoints(IInputElement relativeTo);
    public void SuspendMousePromotionUntilTouchUp();
}
public class System.Windows.Input.TouchFrameEventHandler : MulticastDelegate {
    public TouchFrameEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TouchFrameEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TouchFrameEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.TouchPoint : object {
    public TouchAction Action { get; }
    public Rect Bounds { get; }
    public Point Position { get; }
    public Size Size { get; }
    public TouchDevice TouchDevice { get; }
    public TouchPoint(TouchDevice device, Point position, Rect bounds, TouchAction action);
    public TouchAction get_Action();
    public Rect get_Bounds();
    public Point get_Position();
    public Size get_Size();
    public TouchDevice get_TouchDevice();
    private sealed virtual override bool System.IEquatable<System.Windows.Input.TouchPoint>.Equals(TouchPoint other);
}
public class System.Windows.Input.TouchPointCollection : Collection`1<TouchPoint> {
}
public static class System.Windows.Interop.CursorInteropHelper : object {
    public static Cursor Create(SafeHandle cursorHandle);
}
public class System.Windows.Interop.D3DImage : ImageSource {
    public static DependencyProperty IsFrontBufferAvailableProperty;
    public double Height { get; }
    public bool IsFrontBufferAvailable { get; }
    public ImageMetadata Metadata { get; }
    public int PixelHeight { get; }
    public int PixelWidth { get; }
    public double Width { get; }
    public D3DImage(double dpiX, double dpiY);
    public sealed virtual double get_Height();
    public bool get_IsFrontBufferAvailable();
    public sealed virtual ImageMetadata get_Metadata();
    public int get_PixelHeight();
    public int get_PixelWidth();
    public sealed virtual double get_Width();
    public void add_IsFrontBufferAvailableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsFrontBufferAvailableChanged(DependencyPropertyChangedEventHandler value);
    public void AddDirtyRect(Int32Rect dirtyRect);
    public D3DImage Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public D3DImage CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected internal virtual BitmapSource CopyBackBuffer();
    protected virtual Freezable CreateInstanceCore();
    protected virtual override void Finalize();
    protected sealed virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public void Lock();
    public void SetBackBuffer(D3DResourceType backBufferType, IntPtr backBuffer);
    public void SetBackBuffer(D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);
    public bool TryLock(Duration timeout);
    public void Unlock();
}
public enum System.Windows.Interop.D3DResourceType : Enum {
    public int value__;
    public static D3DResourceType IDirect3DSurface9;
}
public class System.Windows.Interop.HwndSource : PresentationSource {
    public bool AcquireHwndFocusInMenuMode { get; }
    public IEnumerable`1<IKeyboardInputSink> ChildKeyboardInputSinks { get; }
    public HwndTarget CompositionTarget { get; }
    public static bool DefaultAcquireHwndFocusInMenuMode { get; public set; }
    public IntPtr Handle { get; }
    public bool IsDisposed { get; }
    protected IKeyboardInputSite KeyboardInputSiteCore { get; protected set; }
    public RestoreFocusMode RestoreFocusMode { get; }
    public Visual RootVisual { get; public set; }
    public SizeToContent SizeToContent { get; public set; }
    private IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite { get; private set; }
    public bool UsesPerPixelOpacity { get; }
    public HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent);
    public HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent, bool adjustSizingForNonClientArea);
    public HwndSource(int classStyle, int style, int exStyle, int x, int y, string name, IntPtr parent);
    public HwndSource(HwndSourceParameters parameters);
    public bool get_AcquireHwndFocusInMenuMode();
    public IEnumerable`1<IKeyboardInputSink> get_ChildKeyboardInputSinks();
    public HwndTarget get_CompositionTarget();
    public static bool get_DefaultAcquireHwndFocusInMenuMode();
    public static void set_DefaultAcquireHwndFocusInMenuMode(bool value);
    public sealed virtual IntPtr get_Handle();
    public virtual bool get_IsDisposed();
    protected IKeyboardInputSite get_KeyboardInputSiteCore();
    protected void set_KeyboardInputSiteCore(IKeyboardInputSite value);
    public RestoreFocusMode get_RestoreFocusMode();
    public virtual Visual get_RootVisual();
    public virtual void set_RootVisual(Visual value);
    public SizeToContent get_SizeToContent();
    public void set_SizeToContent(SizeToContent value);
    private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.get_KeyboardInputSite();
    private sealed virtual override void System.Windows.Interop.IKeyboardInputSink.set_KeyboardInputSite(IKeyboardInputSite value);
    public bool get_UsesPerPixelOpacity();
    public void add_AutoResized(AutoResizedEventHandler value);
    public void remove_AutoResized(AutoResizedEventHandler value);
    public void add_Disposed(EventHandler value);
    public void remove_Disposed(EventHandler value);
    public void add_DpiChanged(HwndDpiChangedEventHandler value);
    public void remove_DpiChanged(HwndDpiChangedEventHandler value);
    public void add_SizeToContentChanged(EventHandler value);
    public void remove_SizeToContentChanged(EventHandler value);
    public void AddHook(HwndSourceHook hook);
    public HandleRef CreateHandleRef();
    public sealed virtual void Dispose();
    public static HwndSource FromHwnd(IntPtr hwnd);
    protected virtual CompositionTarget GetCompositionTargetCore();
    protected virtual bool HasFocusWithinCore();
    protected virtual void OnDpiChanged(HwndDpiChangedEventArgs e);
    protected virtual bool OnMnemonicCore(MSG& msg, ModifierKeys modifiers);
    protected IKeyboardInputSite RegisterKeyboardInputSinkCore(IKeyboardInputSink sink);
    public void RemoveHook(HwndSourceHook hook);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.HasFocusWithin();
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.OnMnemonic(MSG& msg, ModifierKeys modifiers);
    private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(IKeyboardInputSink sink);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TabInto(TraversalRequest request);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateChar(MSG& msg, ModifierKeys modifiers);
    protected virtual bool TabIntoCore(TraversalRequest request);
    protected virtual bool TranslateAcceleratorCore(MSG& msg, ModifierKeys modifiers);
    protected virtual bool TranslateCharCore(MSG& msg, ModifierKeys modifiers);
}
public class System.Windows.Interop.HwndSourceHook : MulticastDelegate {
    public HwndSourceHook(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
public class System.Windows.Interop.HwndSourceParameters : ValueType {
    public bool AcquireHwndFocusInMenuMode { get; public set; }
    public bool AdjustSizingForNonClientArea { get; public set; }
    public int ExtendedWindowStyle { get; public set; }
    public bool HasAssignedSize { get; }
    public int Height { get; public set; }
    public HwndSourceHook HwndSourceHook { get; public set; }
    public IntPtr ParentWindow { get; public set; }
    public int PositionX { get; public set; }
    public int PositionY { get; public set; }
    public RestoreFocusMode RestoreFocusMode { get; public set; }
    public bool TreatAncestorsAsNonClientArea { get; public set; }
    public bool TreatAsInputRoot { get; public set; }
    public bool UsesPerPixelOpacity { get; public set; }
    public bool UsesPerPixelTransparency { get; public set; }
    public int Width { get; public set; }
    public int WindowClassStyle { get; public set; }
    public string WindowName { get; public set; }
    public int WindowStyle { get; public set; }
    public HwndSourceParameters(string name);
    public HwndSourceParameters(string name, int width, int height);
    public bool get_AcquireHwndFocusInMenuMode();
    public void set_AcquireHwndFocusInMenuMode(bool value);
    public bool get_AdjustSizingForNonClientArea();
    public void set_AdjustSizingForNonClientArea(bool value);
    public int get_ExtendedWindowStyle();
    public void set_ExtendedWindowStyle(int value);
    public bool get_HasAssignedSize();
    public int get_Height();
    public void set_Height(int value);
    public HwndSourceHook get_HwndSourceHook();
    public void set_HwndSourceHook(HwndSourceHook value);
    public IntPtr get_ParentWindow();
    public void set_ParentWindow(IntPtr value);
    public int get_PositionX();
    public void set_PositionX(int value);
    public int get_PositionY();
    public void set_PositionY(int value);
    public RestoreFocusMode get_RestoreFocusMode();
    public void set_RestoreFocusMode(RestoreFocusMode value);
    public bool get_TreatAncestorsAsNonClientArea();
    public void set_TreatAncestorsAsNonClientArea(bool value);
    public bool get_TreatAsInputRoot();
    public void set_TreatAsInputRoot(bool value);
    public bool get_UsesPerPixelOpacity();
    public void set_UsesPerPixelOpacity(bool value);
    public bool get_UsesPerPixelTransparency();
    public void set_UsesPerPixelTransparency(bool value);
    public int get_Width();
    public void set_Width(int value);
    public int get_WindowClassStyle();
    public void set_WindowClassStyle(int value);
    public string get_WindowName();
    public void set_WindowName(string value);
    public int get_WindowStyle();
    public void set_WindowStyle(int value);
    public virtual bool Equals(object obj);
    public bool Equals(HwndSourceParameters obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HwndSourceParameters a, HwndSourceParameters b);
    public static bool op_Inequality(HwndSourceParameters a, HwndSourceParameters b);
    public void SetPosition(int x, int y);
    public void SetSize(int width, int height);
}
public class System.Windows.Interop.HwndTarget : CompositionTarget {
    public Color BackgroundColor { get; public set; }
    public RenderMode RenderMode { get; public set; }
    unknown Visual RootVisual {public set; }
    public Matrix TransformFromDevice { get; }
    public Matrix TransformToDevice { get; }
    public bool UsesPerPixelOpacity { get; }
    public HwndTarget(IntPtr hwnd);
    public Color get_BackgroundColor();
    public void set_BackgroundColor(Color value);
    public RenderMode get_RenderMode();
    public void set_RenderMode(RenderMode value);
    public virtual void set_RootVisual(Visual value);
    public virtual Matrix get_TransformFromDevice();
    public virtual Matrix get_TransformToDevice();
    public bool get_UsesPerPixelOpacity();
    public virtual void Dispose();
}
public static class System.Windows.Interop.Imaging : object {
    public static BitmapSource CreateBitmapSourceFromHBitmap(IntPtr bitmap, IntPtr palette, Int32Rect sourceRect, BitmapSizeOptions sizeOptions);
    public static BitmapSource CreateBitmapSourceFromHIcon(IntPtr icon, Int32Rect sourceRect, BitmapSizeOptions sizeOptions);
    public static BitmapSource CreateBitmapSourceFromMemorySection(IntPtr section, int pixelWidth, int pixelHeight, PixelFormat format, int stride, int offset);
}
public class System.Windows.Interop.InteropBitmap : BitmapSource {
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public void Invalidate();
    public void Invalidate(Nullable`1<Int32Rect> dirtyRect);
}
public interface System.Windows.Interop.IWin32Window {
    public IntPtr Handle { get; }
    public abstract virtual IntPtr get_Handle();
}
public enum System.Windows.Interop.RenderMode : Enum {
    public int value__;
    public static RenderMode Default;
    public static RenderMode SoftwareOnly;
}
public class System.Windows.KeySplineConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptor, Type destinationType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.KeyTimeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public enum System.Windows.LineBreakCondition : Enum {
    public int value__;
    public static LineBreakCondition BreakDesired;
    public static LineBreakCondition BreakPossible;
    public static LineBreakCondition BreakRestrained;
    public static LineBreakCondition BreakAlways;
}
[AttributeUsageAttribute("412")]
public class System.Windows.LocalizabilityAttribute : Attribute {
    public LocalizationCategory Category { get; }
    public Modifiability Modifiability { get; public set; }
    public Readability Readability { get; public set; }
    public LocalizabilityAttribute(LocalizationCategory category);
    public LocalizationCategory get_Category();
    public Modifiability get_Modifiability();
    public void set_Modifiability(Modifiability value);
    public Readability get_Readability();
    public void set_Readability(Readability value);
}
public enum System.Windows.LocalizationCategory : Enum {
    public int value__;
    public static LocalizationCategory None;
    public static LocalizationCategory Text;
    public static LocalizationCategory Title;
    public static LocalizationCategory Label;
    public static LocalizationCategory Button;
    public static LocalizationCategory CheckBox;
    public static LocalizationCategory ComboBox;
    public static LocalizationCategory ListBox;
    public static LocalizationCategory Menu;
    public static LocalizationCategory RadioButton;
    public static LocalizationCategory ToolTip;
    public static LocalizationCategory Hyperlink;
    public static LocalizationCategory TextFlow;
    public static LocalizationCategory XmlData;
    public static LocalizationCategory Font;
    public static LocalizationCategory Inherit;
    public static LocalizationCategory Ignore;
    public static LocalizationCategory NeverLocalize;
}
public interface System.Windows.Markup.IAddChild {
    public abstract virtual void AddChild(object value);
    public abstract virtual void AddText(string text);
}
internal interface System.Windows.Markup.IAddChildInternal {
}
[TypeConverterAttribute("System.Windows.Markup.XmlLanguageConverter")]
public class System.Windows.Markup.XmlLanguage : object {
    public static XmlLanguage Empty { get; }
    public string IetfLanguageTag { get; }
    public static XmlLanguage get_Empty();
    public string get_IetfLanguageTag();
    public CultureInfo GetEquivalentCulture();
    public static XmlLanguage GetLanguage(string ietfLanguageTag);
    public CultureInfo GetSpecificCulture();
    public virtual string ToString();
}
public class System.Windows.Markup.XmlLanguageConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public enum System.Windows.Media.AlignmentX : Enum {
    public int value__;
    public static AlignmentX Left;
    public static AlignmentX Center;
    public static AlignmentX Right;
}
public enum System.Windows.Media.AlignmentY : Enum {
    public int value__;
    public static AlignmentY Top;
    public static AlignmentY Center;
    public static AlignmentY Bottom;
}
public abstract class System.Windows.Media.Animation.Animatable : Freezable {
    public bool HasAnimatedProperties { get; }
    public sealed virtual bool get_HasAnimatedProperties();
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public Animatable Clone();
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    [EditorBrowsableAttribute("1")]
public static bool ShouldSerializeStoredWeakReference(DependencyObject target);
}
public class System.Windows.Media.Animation.AnimationClock : Clock {
    public AnimationTimeline Timeline { get; }
    protected internal AnimationClock(AnimationTimeline animation);
    public AnimationTimeline get_Timeline();
    public object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue);
}
public class System.Windows.Media.Animation.AnimationException : SystemException {
    public AnimationClock Clock { get; }
    public DependencyProperty Property { get; }
    public IAnimatable Target { get; }
    public AnimationClock get_Clock();
    public DependencyProperty get_Property();
    public IAnimatable get_Target();
}
public abstract class System.Windows.Media.Animation.AnimationTimeline : Timeline {
    public static DependencyProperty IsAdditiveProperty;
    public static DependencyProperty IsCumulativeProperty;
    public bool IsDestinationDefault { get; }
    public Type TargetPropertyType { get; }
    public virtual bool get_IsDestinationDefault();
    public abstract virtual Type get_TargetPropertyType();
    protected internal virtual Clock AllocateClock();
    public AnimationTimeline Clone();
    public AnimationClock CreateClock();
    public virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected virtual Duration GetNaturalDurationCore(Clock clock);
}
public class System.Windows.Media.Animation.BackEase : EasingFunctionBase {
    public static DependencyProperty AmplitudeProperty;
    public double Amplitude { get; public set; }
    public double get_Amplitude();
    public void set_Amplitude(double value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double EaseInCore(double normalizedTime);
}
public abstract class System.Windows.Media.Animation.BooleanAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public BooleanAnimationBase Clone();
    public bool GetCurrentValue(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual bool GetCurrentValueCore(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.BooleanAnimationUsingKeyFrames : BooleanAnimationBase {
    public BooleanKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public BooleanKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(BooleanKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public BooleanAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public BooleanAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual bool GetCurrentValueCore(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.BooleanKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public bool Value { get; public set; }
    protected BooleanKeyFrame(bool value);
    protected BooleanKeyFrame(bool value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public bool get_Value();
    public void set_Value(bool value);
    public bool InterpolateValue(bool baseValue, double keyFrameProgress);
    protected abstract virtual bool InterpolateValueCore(bool baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.BooleanKeyFrameCollection : Freezable {
    public int Count { get; }
    public static BooleanKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public BooleanKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static BooleanKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public BooleanKeyFrame get_Item(int index);
    public void set_Item(int index, BooleanKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(BooleanKeyFrame keyFrame);
    public sealed virtual void Clear();
    public BooleanKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(BooleanKeyFrame keyFrame);
    public void CopyTo(BooleanKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(BooleanKeyFrame keyFrame);
    public void Insert(int index, BooleanKeyFrame keyFrame);
    public void Remove(BooleanKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.BounceEase : EasingFunctionBase {
    public static DependencyProperty BouncesProperty;
    public static DependencyProperty BouncinessProperty;
    public int Bounces { get; public set; }
    public double Bounciness { get; public set; }
    public int get_Bounces();
    public void set_Bounces(int value);
    public double get_Bounciness();
    public void set_Bounciness(double value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.ByteAnimation : ByteAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<byte> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<byte> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<byte> To { get; public set; }
    public ByteAnimation(byte fromValue, byte toValue, Duration duration);
    public ByteAnimation(byte fromValue, byte toValue, Duration duration, FillBehavior fillBehavior);
    public ByteAnimation(byte toValue, Duration duration);
    public ByteAnimation(byte toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<byte> get_By();
    public void set_By(Nullable`1<byte> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<byte> get_From();
    public void set_From(Nullable`1<byte> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<byte> get_To();
    public void set_To(Nullable`1<byte> value);
    public ByteAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.ByteAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public ByteAnimationBase Clone();
    public byte GetCurrentValue(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ByteAnimationUsingKeyFrames : ByteAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public ByteKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public ByteKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ByteKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public ByteAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public ByteAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.ByteKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public byte Value { get; public set; }
    protected ByteKeyFrame(byte value);
    protected ByteKeyFrame(byte value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public byte get_Value();
    public void set_Value(byte value);
    public byte InterpolateValue(byte baseValue, double keyFrameProgress);
    protected abstract virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ByteKeyFrameCollection : Freezable {
    public int Count { get; }
    public static ByteKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public ByteKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static ByteKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public ByteKeyFrame get_Item(int index);
    public void set_Item(int index, ByteKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(ByteKeyFrame keyFrame);
    public sealed virtual void Clear();
    public ByteKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(ByteKeyFrame keyFrame);
    public void CopyTo(ByteKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(ByteKeyFrame keyFrame);
    public void Insert(int index, ByteKeyFrame keyFrame);
    public void Remove(ByteKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public abstract class System.Windows.Media.Animation.CharAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public CharAnimationBase Clone();
    public char GetCurrentValue(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual char GetCurrentValueCore(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.CharAnimationUsingKeyFrames : CharAnimationBase {
    public CharKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public CharKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(CharKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public CharAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public CharAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual char GetCurrentValueCore(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.CharKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public char Value { get; public set; }
    protected CharKeyFrame(char value);
    protected CharKeyFrame(char value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public char get_Value();
    public void set_Value(char value);
    public char InterpolateValue(char baseValue, double keyFrameProgress);
    protected abstract virtual char InterpolateValueCore(char baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.CharKeyFrameCollection : Freezable {
    public int Count { get; }
    public static CharKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public CharKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static CharKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public CharKeyFrame get_Item(int index);
    public void set_Item(int index, CharKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(CharKeyFrame keyFrame);
    public sealed virtual void Clear();
    public CharKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(CharKeyFrame keyFrame);
    public void CopyTo(CharKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(CharKeyFrame keyFrame);
    public void Insert(int index, CharKeyFrame keyFrame);
    public void Remove(CharKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.CircleEase : EasingFunctionBase {
    protected virtual Freezable CreateInstanceCore();
    protected virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.Clock : DispatcherObject {
    public ClockController Controller { get; }
    public Nullable`1<double> CurrentGlobalSpeed { get; }
    protected TimeSpan CurrentGlobalTime { get; }
    public Nullable`1<int> CurrentIteration { get; }
    public Nullable`1<double> CurrentProgress { get; }
    public ClockState CurrentState { get; }
    public Nullable`1<TimeSpan> CurrentTime { get; }
    public bool HasControllableRoot { get; }
    public bool IsPaused { get; }
    public Duration NaturalDuration { get; }
    public Clock Parent { get; }
    public Timeline Timeline { get; }
    protected internal Clock(Timeline timeline);
    public ClockController get_Controller();
    public Nullable`1<double> get_CurrentGlobalSpeed();
    protected TimeSpan get_CurrentGlobalTime();
    public Nullable`1<int> get_CurrentIteration();
    public Nullable`1<double> get_CurrentProgress();
    public ClockState get_CurrentState();
    public Nullable`1<TimeSpan> get_CurrentTime();
    public bool get_HasControllableRoot();
    public bool get_IsPaused();
    public Duration get_NaturalDuration();
    public Clock get_Parent();
    public Timeline get_Timeline();
    public void add_Completed(EventHandler value);
    public void remove_Completed(EventHandler value);
    public void add_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void remove_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void add_CurrentStateInvalidated(EventHandler value);
    public void remove_CurrentStateInvalidated(EventHandler value);
    public void add_CurrentTimeInvalidated(EventHandler value);
    public void remove_CurrentTimeInvalidated(EventHandler value);
    public void add_RemoveRequested(EventHandler value);
    public void remove_RemoveRequested(EventHandler value);
    protected virtual void DiscontinuousTimeMovement();
    protected virtual bool GetCanSlip();
    protected virtual TimeSpan GetCurrentTimeCore();
    protected virtual void SpeedChanged();
    protected virtual void Stopped();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ClockCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Clock Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public Clock get_Item(int index);
    public sealed virtual void Add(Clock item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Clock item);
    public sealed virtual void CopyTo(Clock[] array, int index);
    public virtual bool Equals(object obj);
    public static bool Equals(ClockCollection objA, ClockCollection objB);
    public virtual int GetHashCode();
    public static bool op_Equality(ClockCollection objA, ClockCollection objB);
    public static bool op_Inequality(ClockCollection objA, ClockCollection objB);
    public sealed virtual bool Remove(Clock item);
    private sealed virtual override IEnumerator`1<Clock> System.Collections.Generic.IEnumerable<System.Windows.Media.Animation.Clock>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Media.Animation.ClockController : DispatcherObject {
    public Clock Clock { get; }
    public double SpeedRatio { get; public set; }
    public Clock get_Clock();
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    public void Begin();
    public void Pause();
    public void Remove();
    public void Resume();
    public void Seek(TimeSpan offset, TimeSeekOrigin origin);
    public void SeekAlignedToLastTick(TimeSpan offset, TimeSeekOrigin origin);
    public void SkipToFill();
    public void Stop();
}
public class System.Windows.Media.Animation.ClockGroup : Clock {
    public ClockCollection Children { get; }
    public TimelineGroup Timeline { get; }
    protected internal ClockGroup(TimelineGroup timelineGroup);
    public ClockCollection get_Children();
    public TimelineGroup get_Timeline();
}
public enum System.Windows.Media.Animation.ClockState : Enum {
    public int value__;
    public static ClockState Active;
    public static ClockState Filling;
    public static ClockState Stopped;
}
public class System.Windows.Media.Animation.ColorAnimation : ColorAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<Color> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<Color> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<Color> To { get; public set; }
    public ColorAnimation(Color toValue, Duration duration);
    public ColorAnimation(Color toValue, Duration duration, FillBehavior fillBehavior);
    public ColorAnimation(Color fromValue, Color toValue, Duration duration);
    public ColorAnimation(Color fromValue, Color toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Color> get_By();
    public void set_By(Nullable`1<Color> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<Color> get_From();
    public void set_From(Nullable`1<Color> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<Color> get_To();
    public void set_To(Nullable`1<Color> value);
    public ColorAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.ColorAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public ColorAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Color GetCurrentValue(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ColorAnimationUsingKeyFrames : ColorAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public ColorKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public ColorKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ColorKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public ColorAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public ColorAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.ColorKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Color Value { get; public set; }
    protected ColorKeyFrame(Color value);
    protected ColorKeyFrame(Color value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Color get_Value();
    public void set_Value(Color value);
    public Color InterpolateValue(Color baseValue, double keyFrameProgress);
    protected abstract virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ColorKeyFrameCollection : Freezable {
    public int Count { get; }
    public static ColorKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public ColorKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static ColorKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public ColorKeyFrame get_Item(int index);
    public void set_Item(int index, ColorKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(ColorKeyFrame keyFrame);
    public sealed virtual void Clear();
    public ColorKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(ColorKeyFrame keyFrame);
    public void CopyTo(ColorKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(ColorKeyFrame keyFrame);
    public void Insert(int index, ColorKeyFrame keyFrame);
    public void Remove(ColorKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.CubicEase : EasingFunctionBase {
    protected virtual Freezable CreateInstanceCore();
    protected virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.DecimalAnimation : DecimalAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<decimal> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<decimal> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<decimal> To { get; public set; }
    public DecimalAnimation(decimal fromValue, decimal toValue, Duration duration);
    public DecimalAnimation(decimal fromValue, decimal toValue, Duration duration, FillBehavior fillBehavior);
    public DecimalAnimation(decimal toValue, Duration duration);
    public DecimalAnimation(decimal toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<decimal> get_By();
    public void set_By(Nullable`1<decimal> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<decimal> get_From();
    public void set_From(Nullable`1<decimal> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<decimal> get_To();
    public void set_To(Nullable`1<decimal> value);
    public DecimalAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.DecimalAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public DecimalAnimationBase Clone();
    public decimal GetCurrentValue(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.DecimalAnimationUsingKeyFrames : DecimalAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public DecimalKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public DecimalKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(DecimalKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public DecimalAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public DecimalAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.DecimalKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public decimal Value { get; public set; }
    protected DecimalKeyFrame(decimal value);
    protected DecimalKeyFrame(decimal value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public decimal get_Value();
    public void set_Value(decimal value);
    public decimal InterpolateValue(decimal baseValue, double keyFrameProgress);
    protected abstract virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.DecimalKeyFrameCollection : Freezable {
    public int Count { get; }
    public static DecimalKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public DecimalKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static DecimalKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public DecimalKeyFrame get_Item(int index);
    public void set_Item(int index, DecimalKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(DecimalKeyFrame keyFrame);
    public sealed virtual void Clear();
    public DecimalKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(DecimalKeyFrame keyFrame);
    public void CopyTo(DecimalKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(DecimalKeyFrame keyFrame);
    public void Insert(int index, DecimalKeyFrame keyFrame);
    public void Remove(DecimalKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.DiscreteBooleanKeyFrame : BooleanKeyFrame {
    public DiscreteBooleanKeyFrame(bool value);
    public DiscreteBooleanKeyFrame(bool value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool InterpolateValueCore(bool baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteByteKeyFrame : ByteKeyFrame {
    public DiscreteByteKeyFrame(byte value);
    public DiscreteByteKeyFrame(byte value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteCharKeyFrame : CharKeyFrame {
    public DiscreteCharKeyFrame(char value);
    public DiscreteCharKeyFrame(char value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual char InterpolateValueCore(char baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteColorKeyFrame : ColorKeyFrame {
    public DiscreteColorKeyFrame(Color value);
    public DiscreteColorKeyFrame(Color value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteDecimalKeyFrame : DecimalKeyFrame {
    public DiscreteDecimalKeyFrame(decimal value);
    public DiscreteDecimalKeyFrame(decimal value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteDoubleKeyFrame : DoubleKeyFrame {
    public DiscreteDoubleKeyFrame(double value);
    public DiscreteDoubleKeyFrame(double value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt16KeyFrame : Int16KeyFrame {
    public DiscreteInt16KeyFrame(short value);
    public DiscreteInt16KeyFrame(short value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt32KeyFrame : Int32KeyFrame {
    public DiscreteInt32KeyFrame(int value);
    public DiscreteInt32KeyFrame(int value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt64KeyFrame : Int64KeyFrame {
    public DiscreteInt64KeyFrame(long value);
    public DiscreteInt64KeyFrame(long value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteMatrixKeyFrame : MatrixKeyFrame {
    public DiscreteMatrixKeyFrame(Matrix value);
    public DiscreteMatrixKeyFrame(Matrix value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Matrix InterpolateValueCore(Matrix baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteObjectKeyFrame : ObjectKeyFrame {
    public DiscreteObjectKeyFrame(object value);
    public DiscreteObjectKeyFrame(object value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual object InterpolateValueCore(object baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscretePoint3DKeyFrame : Point3DKeyFrame {
    public DiscretePoint3DKeyFrame(Point3D value);
    public DiscretePoint3DKeyFrame(Point3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscretePointKeyFrame : PointKeyFrame {
    public DiscretePointKeyFrame(Point value);
    public DiscretePointKeyFrame(Point value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteQuaternionKeyFrame : QuaternionKeyFrame {
    public DiscreteQuaternionKeyFrame(Quaternion value);
    public DiscreteQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteRectKeyFrame : RectKeyFrame {
    public DiscreteRectKeyFrame(Rect value);
    public DiscreteRectKeyFrame(Rect value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteRotation3DKeyFrame : Rotation3DKeyFrame {
    public DiscreteRotation3DKeyFrame(Rotation3D value);
    public DiscreteRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteSingleKeyFrame : SingleKeyFrame {
    public DiscreteSingleKeyFrame(float value);
    public DiscreteSingleKeyFrame(float value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteSizeKeyFrame : SizeKeyFrame {
    public DiscreteSizeKeyFrame(Size value);
    public DiscreteSizeKeyFrame(Size value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteStringKeyFrame : StringKeyFrame {
    public DiscreteStringKeyFrame(string value);
    public DiscreteStringKeyFrame(string value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual string InterpolateValueCore(string baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteVector3DKeyFrame : Vector3DKeyFrame {
    public DiscreteVector3DKeyFrame(Vector3D value);
    public DiscreteVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteVectorKeyFrame : VectorKeyFrame {
    public DiscreteVectorKeyFrame(Vector value);
    public DiscreteVectorKeyFrame(Vector value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DoubleAnimation : DoubleAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<double> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<double> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<double> To { get; public set; }
    public DoubleAnimation(double fromValue, double toValue, Duration duration);
    public DoubleAnimation(double fromValue, double toValue, Duration duration, FillBehavior fillBehavior);
    public DoubleAnimation(double toValue, Duration duration);
    public DoubleAnimation(double toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<double> get_By();
    public void set_By(Nullable`1<double> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<double> get_From();
    public void set_From(Nullable`1<double> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<double> get_To();
    public void set_To(Nullable`1<double> value);
    public DoubleAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.DoubleAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public DoubleAnimationBase Clone();
    public double GetCurrentValue(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.DoubleAnimationUsingKeyFrames : DoubleAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public DoubleKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public DoubleKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(DoubleKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public DoubleAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public DoubleAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public class System.Windows.Media.Animation.DoubleAnimationUsingPath : DoubleAnimationBase {
    public static DependencyProperty PathGeometryProperty;
    public static DependencyProperty SourceProperty;
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public PathGeometry PathGeometry { get; public set; }
    public PathAnimationSource Source { get; public set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    public PathAnimationSource get_Source();
    public void set_Source(PathAnimationSource value);
    public DoubleAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    protected virtual void OnChanged();
}
public abstract class System.Windows.Media.Animation.DoubleKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public double Value { get; public set; }
    protected DoubleKeyFrame(double value);
    protected DoubleKeyFrame(double value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public double get_Value();
    public void set_Value(double value);
    public double InterpolateValue(double baseValue, double keyFrameProgress);
    protected abstract virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.DoubleKeyFrameCollection : Freezable {
    public int Count { get; }
    public static DoubleKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public DoubleKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static DoubleKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public DoubleKeyFrame get_Item(int index);
    public void set_Item(int index, DoubleKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(DoubleKeyFrame keyFrame);
    public sealed virtual void Clear();
    public DoubleKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(DoubleKeyFrame keyFrame);
    public void CopyTo(DoubleKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(DoubleKeyFrame keyFrame);
    public void Insert(int index, DoubleKeyFrame keyFrame);
    public void Remove(DoubleKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.EasingByteKeyFrame : ByteKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingByteKeyFrame(byte value);
    public EasingByteKeyFrame(byte value, KeyTime keyTime);
    public EasingByteKeyFrame(byte value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingColorKeyFrame : ColorKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingColorKeyFrame(Color value);
    public EasingColorKeyFrame(Color value, KeyTime keyTime);
    public EasingColorKeyFrame(Color value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingDecimalKeyFrame : DecimalKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingDecimalKeyFrame(decimal value);
    public EasingDecimalKeyFrame(decimal value, KeyTime keyTime);
    public EasingDecimalKeyFrame(decimal value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingDoubleKeyFrame : DoubleKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingDoubleKeyFrame(double value);
    public EasingDoubleKeyFrame(double value, KeyTime keyTime);
    public EasingDoubleKeyFrame(double value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public abstract class System.Windows.Media.Animation.EasingFunctionBase : Freezable {
    public static DependencyProperty EasingModeProperty;
    public EasingMode EasingMode { get; public set; }
    public EasingMode get_EasingMode();
    public void set_EasingMode(EasingMode value);
    public sealed virtual double Ease(double normalizedTime);
    protected abstract virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.EasingInt16KeyFrame : Int16KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt16KeyFrame(short value);
    public EasingInt16KeyFrame(short value, KeyTime keyTime);
    public EasingInt16KeyFrame(short value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingInt32KeyFrame : Int32KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt32KeyFrame(int value);
    public EasingInt32KeyFrame(int value, KeyTime keyTime);
    public EasingInt32KeyFrame(int value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingInt64KeyFrame : Int64KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt64KeyFrame(long value);
    public EasingInt64KeyFrame(long value, KeyTime keyTime);
    public EasingInt64KeyFrame(long value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public enum System.Windows.Media.Animation.EasingMode : Enum {
    public int value__;
    public static EasingMode EaseIn;
    public static EasingMode EaseOut;
    public static EasingMode EaseInOut;
}
public class System.Windows.Media.Animation.EasingPoint3DKeyFrame : Point3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingPoint3DKeyFrame(Point3D value);
    public EasingPoint3DKeyFrame(Point3D value, KeyTime keyTime);
    public EasingPoint3DKeyFrame(Point3D value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingPointKeyFrame : PointKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingPointKeyFrame(Point value);
    public EasingPointKeyFrame(Point value, KeyTime keyTime);
    public EasingPointKeyFrame(Point value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty UseShortestPathProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public bool UseShortestPath { get; public set; }
    public EasingQuaternionKeyFrame(Quaternion value);
    public EasingQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public EasingQuaternionKeyFrame(Quaternion value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingRectKeyFrame : RectKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingRectKeyFrame(Rect value);
    public EasingRectKeyFrame(Rect value, KeyTime keyTime);
    public EasingRectKeyFrame(Rect value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingRotation3DKeyFrame : Rotation3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingRotation3DKeyFrame(Rotation3D value);
    public EasingRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    public EasingRotation3DKeyFrame(Rotation3D value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingSingleKeyFrame : SingleKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingSingleKeyFrame(float value);
    public EasingSingleKeyFrame(float value, KeyTime keyTime);
    public EasingSingleKeyFrame(float value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingSizeKeyFrame : SizeKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingSizeKeyFrame(Size value);
    public EasingSizeKeyFrame(Size value, KeyTime keyTime);
    public EasingSizeKeyFrame(Size value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingVector3DKeyFrame : Vector3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingVector3DKeyFrame(Vector3D value);
    public EasingVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    public EasingVector3DKeyFrame(Vector3D value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingVectorKeyFrame : VectorKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingVectorKeyFrame(Vector value);
    public EasingVectorKeyFrame(Vector value, KeyTime keyTime);
    public EasingVectorKeyFrame(Vector value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.ElasticEase : EasingFunctionBase {
    public static DependencyProperty OscillationsProperty;
    public static DependencyProperty SpringinessProperty;
    public int Oscillations { get; public set; }
    public double Springiness { get; public set; }
    public int get_Oscillations();
    public void set_Oscillations(int value);
    public double get_Springiness();
    public void set_Springiness(double value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.ExponentialEase : EasingFunctionBase {
    public static DependencyProperty ExponentProperty;
    public double Exponent { get; public set; }
    public double get_Exponent();
    public void set_Exponent(double value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double EaseInCore(double normalizedTime);
}
public enum System.Windows.Media.Animation.FillBehavior : Enum {
    public int value__;
    public static FillBehavior HoldEnd;
    public static FillBehavior Stop;
}
public enum System.Windows.Media.Animation.HandoffBehavior : Enum {
    public int value__;
    public static HandoffBehavior SnapshotAndReplace;
    public static HandoffBehavior Compose;
}
public interface System.Windows.Media.Animation.IAnimatable {
    public bool HasAnimatedProperties { get; }
    public abstract virtual bool get_HasAnimatedProperties();
    public abstract virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public abstract virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public abstract virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public abstract virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public abstract virtual object GetAnimationBaseValue(DependencyProperty dp);
}
public interface System.Windows.Media.Animation.IAnimation {
    public abstract virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
}
public interface System.Windows.Media.Animation.IEasingFunction {
    public abstract virtual double Ease(double normalizedTime);
}
public interface System.Windows.Media.Animation.IKeyFrame {
    public KeyTime KeyTime { get; public set; }
    public object Value { get; public set; }
    public abstract virtual KeyTime get_KeyTime();
    public abstract virtual void set_KeyTime(KeyTime value);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
public interface System.Windows.Media.Animation.IKeyFrameAnimation {
    public IList KeyFrames { get; public set; }
    public abstract virtual IList get_KeyFrames();
    public abstract virtual void set_KeyFrames(IList value);
}
public class System.Windows.Media.Animation.Int16Animation : Int16AnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<short> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<short> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<short> To { get; public set; }
    public Int16Animation(short fromValue, short toValue, Duration duration);
    public Int16Animation(short fromValue, short toValue, Duration duration, FillBehavior fillBehavior);
    public Int16Animation(short toValue, Duration duration);
    public Int16Animation(short toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<short> get_By();
    public void set_By(Nullable`1<short> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<short> get_From();
    public void set_From(Nullable`1<short> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<short> get_To();
    public void set_To(Nullable`1<short> value);
    public Int16Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Int16AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Int16AnimationBase Clone();
    public short GetCurrentValue(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int16AnimationUsingKeyFrames : Int16AnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Int16KeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Int16KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int16KeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public Int16AnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public Int16AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.Int16KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public short Value { get; public set; }
    protected Int16KeyFrame(short value);
    protected Int16KeyFrame(short value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public short get_Value();
    public void set_Value(short value);
    public short InterpolateValue(short baseValue, double keyFrameProgress);
    protected abstract virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int16KeyFrameCollection : Freezable {
    public int Count { get; }
    public static Int16KeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Int16KeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static Int16KeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public Int16KeyFrame get_Item(int index);
    public void set_Item(int index, Int16KeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(Int16KeyFrame keyFrame);
    public sealed virtual void Clear();
    public Int16KeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(Int16KeyFrame keyFrame);
    public void CopyTo(Int16KeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(Int16KeyFrame keyFrame);
    public void Insert(int index, Int16KeyFrame keyFrame);
    public void Remove(Int16KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.Int32Animation : Int32AnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<int> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<int> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<int> To { get; public set; }
    public Int32Animation(int fromValue, int toValue, Duration duration);
    public Int32Animation(int fromValue, int toValue, Duration duration, FillBehavior fillBehavior);
    public Int32Animation(int toValue, Duration duration);
    public Int32Animation(int toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<int> get_By();
    public void set_By(Nullable`1<int> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<int> get_From();
    public void set_From(Nullable`1<int> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<int> get_To();
    public void set_To(Nullable`1<int> value);
    public Int32Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Int32AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Int32AnimationBase Clone();
    public int GetCurrentValue(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int32AnimationUsingKeyFrames : Int32AnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Int32KeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Int32KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int32KeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public Int32AnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public Int32AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.Int32KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public int Value { get; public set; }
    protected Int32KeyFrame(int value);
    protected Int32KeyFrame(int value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public int get_Value();
    public void set_Value(int value);
    public int InterpolateValue(int baseValue, double keyFrameProgress);
    protected abstract virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int32KeyFrameCollection : Freezable {
    public int Count { get; }
    public static Int32KeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Int32KeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static Int32KeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public Int32KeyFrame get_Item(int index);
    public void set_Item(int index, Int32KeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(Int32KeyFrame keyFrame);
    public sealed virtual void Clear();
    public Int32KeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(Int32KeyFrame keyFrame);
    public void CopyTo(Int32KeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(Int32KeyFrame keyFrame);
    public void Insert(int index, Int32KeyFrame keyFrame);
    public void Remove(Int32KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.Int64Animation : Int64AnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<long> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<long> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<long> To { get; public set; }
    public Int64Animation(long fromValue, long toValue, Duration duration);
    public Int64Animation(long fromValue, long toValue, Duration duration, FillBehavior fillBehavior);
    public Int64Animation(long toValue, Duration duration);
    public Int64Animation(long toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<long> get_By();
    public void set_By(Nullable`1<long> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<long> get_From();
    public void set_From(Nullable`1<long> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<long> get_To();
    public void set_To(Nullable`1<long> value);
    public Int64Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Int64AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Int64AnimationBase Clone();
    public long GetCurrentValue(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int64AnimationUsingKeyFrames : Int64AnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Int64KeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Int64KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int64KeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public Int64AnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public Int64AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.Int64KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public long Value { get; public set; }
    protected Int64KeyFrame(long value);
    protected Int64KeyFrame(long value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public long get_Value();
    public void set_Value(long value);
    public long InterpolateValue(long baseValue, double keyFrameProgress);
    protected abstract virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int64KeyFrameCollection : Freezable {
    public int Count { get; }
    public static Int64KeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Int64KeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static Int64KeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public Int64KeyFrame get_Item(int index);
    public void set_Item(int index, Int64KeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(Int64KeyFrame keyFrame);
    public sealed virtual void Clear();
    public Int64KeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(Int64KeyFrame keyFrame);
    public void CopyTo(Int64KeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(Int64KeyFrame keyFrame);
    public void Insert(int index, Int64KeyFrame keyFrame);
    public void Remove(Int64KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
[TypeConverterAttribute("System.Windows.KeySplineConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.Animation.KeySpline : Freezable {
    public Point ControlPoint1 { get; public set; }
    public Point ControlPoint2 { get; public set; }
    public KeySpline(double x1, double y1, double x2, double y2);
    public KeySpline(Point controlPoint1, Point controlPoint2);
    public Point get_ControlPoint1();
    public void set_ControlPoint1(Point value);
    public Point get_ControlPoint2();
    public void set_ControlPoint2(Point value);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public double GetSplineProgress(double linearProgress);
    protected virtual void OnChanged();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
}
[TypeConverterAttribute("System.Windows.KeyTimeConverter")]
public class System.Windows.Media.Animation.KeyTime : ValueType {
    public static KeyTime Paced { get; }
    public double Percent { get; }
    public TimeSpan TimeSpan { get; }
    public KeyTimeType Type { get; }
    public static KeyTime Uniform { get; }
    public static KeyTime get_Paced();
    public double get_Percent();
    public TimeSpan get_TimeSpan();
    public KeyTimeType get_Type();
    public static KeyTime get_Uniform();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(KeyTime value);
    public static bool Equals(KeyTime keyTime1, KeyTime keyTime2);
    public static KeyTime FromPercent(double percent);
    public static KeyTime FromTimeSpan(TimeSpan timeSpan);
    public virtual int GetHashCode();
    public static bool op_Equality(KeyTime keyTime1, KeyTime keyTime2);
    public static KeyTime op_Implicit(TimeSpan timeSpan);
    public static bool op_Inequality(KeyTime keyTime1, KeyTime keyTime2);
    public virtual string ToString();
}
public enum System.Windows.Media.Animation.KeyTimeType : Enum {
    public byte value__;
    public static KeyTimeType Uniform;
    public static KeyTimeType Percent;
    public static KeyTimeType TimeSpan;
    public static KeyTimeType Paced;
}
public class System.Windows.Media.Animation.LinearByteKeyFrame : ByteKeyFrame {
    public LinearByteKeyFrame(byte value);
    public LinearByteKeyFrame(byte value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearColorKeyFrame : ColorKeyFrame {
    public LinearColorKeyFrame(Color value);
    public LinearColorKeyFrame(Color value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearDecimalKeyFrame : DecimalKeyFrame {
    public LinearDecimalKeyFrame(decimal value);
    public LinearDecimalKeyFrame(decimal value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearDoubleKeyFrame : DoubleKeyFrame {
    public LinearDoubleKeyFrame(double value);
    public LinearDoubleKeyFrame(double value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt16KeyFrame : Int16KeyFrame {
    public LinearInt16KeyFrame(short value);
    public LinearInt16KeyFrame(short value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt32KeyFrame : Int32KeyFrame {
    public LinearInt32KeyFrame(int value);
    public LinearInt32KeyFrame(int value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt64KeyFrame : Int64KeyFrame {
    public LinearInt64KeyFrame(long value);
    public LinearInt64KeyFrame(long value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearPoint3DKeyFrame : Point3DKeyFrame {
    public LinearPoint3DKeyFrame(Point3D value);
    public LinearPoint3DKeyFrame(Point3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearPointKeyFrame : PointKeyFrame {
    public LinearPointKeyFrame(Point value);
    public LinearPointKeyFrame(Point value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty UseShortestPathProperty;
    public bool UseShortestPath { get; public set; }
    public LinearQuaternionKeyFrame(Quaternion value);
    public LinearQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearRectKeyFrame : RectKeyFrame {
    public LinearRectKeyFrame(Rect value);
    public LinearRectKeyFrame(Rect value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearRotation3DKeyFrame : Rotation3DKeyFrame {
    public LinearRotation3DKeyFrame(Rotation3D value);
    public LinearRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearSingleKeyFrame : SingleKeyFrame {
    public LinearSingleKeyFrame(float value);
    public LinearSingleKeyFrame(float value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearSizeKeyFrame : SizeKeyFrame {
    public LinearSizeKeyFrame(Size value);
    public LinearSizeKeyFrame(Size value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearVector3DKeyFrame : Vector3DKeyFrame {
    public LinearVector3DKeyFrame(Vector3D value);
    public LinearVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearVectorKeyFrame : VectorKeyFrame {
    public LinearVectorKeyFrame(Vector value);
    public LinearVectorKeyFrame(Vector value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public abstract class System.Windows.Media.Animation.MatrixAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public MatrixAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Matrix GetCurrentValue(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.MatrixAnimationUsingKeyFrames : MatrixAnimationBase {
    public MatrixKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public MatrixKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(MatrixKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public MatrixAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public MatrixAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public class System.Windows.Media.Animation.MatrixAnimationUsingPath : MatrixAnimationBase {
    public static DependencyProperty DoesRotateWithTangentProperty;
    public static DependencyProperty IsAngleCumulativeProperty;
    public static DependencyProperty IsOffsetCumulativeProperty;
    public static DependencyProperty PathGeometryProperty;
    public bool DoesRotateWithTangent { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsAngleCumulative { get; public set; }
    public bool IsOffsetCumulative { get; public set; }
    public PathGeometry PathGeometry { get; public set; }
    public bool get_DoesRotateWithTangent();
    public void set_DoesRotateWithTangent(bool value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsAngleCumulative();
    public void set_IsAngleCumulative(bool value);
    public bool get_IsOffsetCumulative();
    public void set_IsOffsetCumulative(bool value);
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    public MatrixAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
    protected virtual void OnChanged();
}
public abstract class System.Windows.Media.Animation.MatrixKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Matrix Value { get; public set; }
    protected MatrixKeyFrame(Matrix value);
    protected MatrixKeyFrame(Matrix value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Matrix get_Value();
    public void set_Value(Matrix value);
    public Matrix InterpolateValue(Matrix baseValue, double keyFrameProgress);
    protected abstract virtual Matrix InterpolateValueCore(Matrix baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.MatrixKeyFrameCollection : Freezable {
    public int Count { get; }
    public static MatrixKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public MatrixKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static MatrixKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public MatrixKeyFrame get_Item(int index);
    public void set_Item(int index, MatrixKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(MatrixKeyFrame keyFrame);
    public sealed virtual void Clear();
    public MatrixKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(MatrixKeyFrame keyFrame);
    public void CopyTo(MatrixKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(MatrixKeyFrame keyFrame);
    public void Insert(int index, MatrixKeyFrame keyFrame);
    public void Remove(MatrixKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public abstract class System.Windows.Media.Animation.ObjectAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public ObjectAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual object GetCurrentValueCore(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ObjectAnimationUsingKeyFrames : ObjectAnimationBase {
    public ObjectKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ObjectKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ObjectKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public ObjectAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public ObjectAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual object GetCurrentValueCore(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.ObjectKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public object Value { get; public set; }
    protected ObjectKeyFrame(object value);
    protected ObjectKeyFrame(object value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public object get_Value();
    public void set_Value(object value);
    public object InterpolateValue(object baseValue, double keyFrameProgress);
    protected abstract virtual object InterpolateValueCore(object baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ObjectKeyFrameCollection : Freezable {
    public int Count { get; }
    public static ObjectKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public ObjectKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static ObjectKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public ObjectKeyFrame get_Item(int index);
    public void set_Item(int index, ObjectKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(ObjectKeyFrame keyFrame);
    public sealed virtual void Clear();
    public ObjectKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(ObjectKeyFrame keyFrame);
    public void CopyTo(ObjectKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(ObjectKeyFrame keyFrame);
    public void Insert(int index, ObjectKeyFrame keyFrame);
    public void Remove(ObjectKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.ParallelTimeline : TimelineGroup {
    public static DependencyProperty SlipBehaviorProperty;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SlipBehavior SlipBehavior { get; public set; }
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime);
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    public SlipBehavior get_SlipBehavior();
    public void set_SlipBehavior(SlipBehavior value);
    public ParallelTimeline Clone();
    public ParallelTimeline CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Duration GetNaturalDurationCore(Clock clock);
}
public enum System.Windows.Media.Animation.PathAnimationSource : Enum {
    public byte value__;
    public static PathAnimationSource X;
    public static PathAnimationSource Y;
    public static PathAnimationSource Angle;
}
public class System.Windows.Media.Animation.Point3DAnimation : Point3DAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<Point3D> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<Point3D> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<Point3D> To { get; public set; }
    public Point3DAnimation(Point3D toValue, Duration duration);
    public Point3DAnimation(Point3D toValue, Duration duration, FillBehavior fillBehavior);
    public Point3DAnimation(Point3D fromValue, Point3D toValue, Duration duration);
    public Point3DAnimation(Point3D fromValue, Point3D toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Point3D> get_By();
    public void set_By(Nullable`1<Point3D> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<Point3D> get_From();
    public void set_From(Nullable`1<Point3D> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<Point3D> get_To();
    public void set_To(Nullable`1<Point3D> value);
    public Point3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Point3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Point3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Point3D GetCurrentValue(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Point3DAnimationUsingKeyFrames : Point3DAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Point3DKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Point3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Point3DKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public Point3DAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public Point3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.Point3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Point3D Value { get; public set; }
    protected Point3DKeyFrame(Point3D value);
    protected Point3DKeyFrame(Point3D value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Point3D get_Value();
    public void set_Value(Point3D value);
    public Point3D InterpolateValue(Point3D baseValue, double keyFrameProgress);
    protected abstract virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Point3DKeyFrameCollection : Freezable {
    public int Count { get; }
    public static Point3DKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Point3DKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static Point3DKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public Point3DKeyFrame get_Item(int index);
    public void set_Item(int index, Point3DKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(Point3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    public Point3DKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(Point3DKeyFrame keyFrame);
    public void CopyTo(Point3DKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(Point3DKeyFrame keyFrame);
    public void Insert(int index, Point3DKeyFrame keyFrame);
    public void Remove(Point3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.PointAnimation : PointAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<Point> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<Point> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<Point> To { get; public set; }
    public PointAnimation(Point toValue, Duration duration);
    public PointAnimation(Point toValue, Duration duration, FillBehavior fillBehavior);
    public PointAnimation(Point fromValue, Point toValue, Duration duration);
    public PointAnimation(Point fromValue, Point toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Point> get_By();
    public void set_By(Nullable`1<Point> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<Point> get_From();
    public void set_From(Nullable`1<Point> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<Point> get_To();
    public void set_To(Nullable`1<Point> value);
    public PointAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.PointAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public PointAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Point GetCurrentValue(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.PointAnimationUsingKeyFrames : PointAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public PointKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public PointKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(PointKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public PointAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public PointAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public class System.Windows.Media.Animation.PointAnimationUsingPath : PointAnimationBase {
    public static DependencyProperty PathGeometryProperty;
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public PathGeometry PathGeometry { get; public set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    public PointAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    protected virtual void OnChanged();
}
public abstract class System.Windows.Media.Animation.PointKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Point Value { get; public set; }
    protected PointKeyFrame(Point value);
    protected PointKeyFrame(Point value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Point get_Value();
    public void set_Value(Point value);
    public Point InterpolateValue(Point baseValue, double keyFrameProgress);
    protected abstract virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.PointKeyFrameCollection : Freezable {
    public int Count { get; }
    public static PointKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public PointKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static PointKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public PointKeyFrame get_Item(int index);
    public void set_Item(int index, PointKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(PointKeyFrame keyFrame);
    public sealed virtual void Clear();
    public PointKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(PointKeyFrame keyFrame);
    public void CopyTo(PointKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(PointKeyFrame keyFrame);
    public void Insert(int index, PointKeyFrame keyFrame);
    public void Remove(PointKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.PowerEase : EasingFunctionBase {
    public static DependencyProperty PowerProperty;
    public double Power { get; public set; }
    public double get_Power();
    public void set_Power(double value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.QuadraticEase : EasingFunctionBase {
    protected virtual Freezable CreateInstanceCore();
    protected virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.QuarticEase : EasingFunctionBase {
    protected virtual Freezable CreateInstanceCore();
    protected virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.QuaternionAnimation : QuaternionAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty UseShortestPathProperty;
    public Nullable`1<Quaternion> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<Quaternion> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<Quaternion> To { get; public set; }
    public bool UseShortestPath { get; public set; }
    public QuaternionAnimation(Quaternion toValue, Duration duration);
    public QuaternionAnimation(Quaternion toValue, Duration duration, FillBehavior fillBehavior);
    public QuaternionAnimation(Quaternion fromValue, Quaternion toValue, Duration duration);
    public QuaternionAnimation(Quaternion fromValue, Quaternion toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Quaternion> get_By();
    public void set_By(Nullable`1<Quaternion> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<Quaternion> get_From();
    public void set_From(Nullable`1<Quaternion> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<Quaternion> get_To();
    public void set_To(Nullable`1<Quaternion> value);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    public QuaternionAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.QuaternionAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public QuaternionAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Quaternion GetCurrentValue(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.QuaternionAnimationUsingKeyFrames : QuaternionAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public QuaternionKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public QuaternionKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(QuaternionKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public QuaternionAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public QuaternionAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.QuaternionKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Quaternion Value { get; public set; }
    protected QuaternionKeyFrame(Quaternion value);
    protected QuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Quaternion get_Value();
    public void set_Value(Quaternion value);
    public Quaternion InterpolateValue(Quaternion baseValue, double keyFrameProgress);
    protected abstract virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.QuaternionKeyFrameCollection : Freezable {
    public int Count { get; }
    public static QuaternionKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public QuaternionKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static QuaternionKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public QuaternionKeyFrame get_Item(int index);
    public void set_Item(int index, QuaternionKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(QuaternionKeyFrame keyFrame);
    public sealed virtual void Clear();
    public QuaternionKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(QuaternionKeyFrame keyFrame);
    public void CopyTo(QuaternionKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(QuaternionKeyFrame keyFrame);
    public void Insert(int index, QuaternionKeyFrame keyFrame);
    public void Remove(QuaternionKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.QuinticEase : EasingFunctionBase {
    protected virtual Freezable CreateInstanceCore();
    protected virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.RectAnimation : RectAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<Rect> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<Rect> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<Rect> To { get; public set; }
    public RectAnimation(Rect toValue, Duration duration);
    public RectAnimation(Rect toValue, Duration duration, FillBehavior fillBehavior);
    public RectAnimation(Rect fromValue, Rect toValue, Duration duration);
    public RectAnimation(Rect fromValue, Rect toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Rect> get_By();
    public void set_By(Nullable`1<Rect> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<Rect> get_From();
    public void set_From(Nullable`1<Rect> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<Rect> get_To();
    public void set_To(Nullable`1<Rect> value);
    public RectAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.RectAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public RectAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Rect GetCurrentValue(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.RectAnimationUsingKeyFrames : RectAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public RectKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public RectKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(RectKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public RectAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public RectAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.RectKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Rect Value { get; public set; }
    protected RectKeyFrame(Rect value);
    protected RectKeyFrame(Rect value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Rect get_Value();
    public void set_Value(Rect value);
    public Rect InterpolateValue(Rect baseValue, double keyFrameProgress);
    protected abstract virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.RectKeyFrameCollection : Freezable {
    public int Count { get; }
    public static RectKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public RectKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static RectKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public RectKeyFrame get_Item(int index);
    public void set_Item(int index, RectKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(RectKeyFrame keyFrame);
    public sealed virtual void Clear();
    public RectKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(RectKeyFrame keyFrame);
    public void CopyTo(RectKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(RectKeyFrame keyFrame);
    public void Insert(int index, RectKeyFrame keyFrame);
    public void Remove(RectKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
[TypeConverterAttribute("System.Windows.Media.Animation.RepeatBehaviorConverter")]
public class System.Windows.Media.Animation.RepeatBehavior : ValueType {
    public double Count { get; }
    public TimeSpan Duration { get; }
    public static RepeatBehavior Forever { get; }
    public bool HasCount { get; }
    public bool HasDuration { get; }
    public RepeatBehavior(double count);
    public RepeatBehavior(TimeSpan duration);
    public double get_Count();
    public TimeSpan get_Duration();
    public static RepeatBehavior get_Forever();
    public bool get_HasCount();
    public bool get_HasDuration();
    public virtual bool Equals(object value);
    public bool Equals(RepeatBehavior repeatBehavior);
    public static bool Equals(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
    public virtual int GetHashCode();
    public static bool op_Equality(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
    public static bool op_Inequality(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
}
public class System.Windows.Media.Animation.RepeatBehaviorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.Media.Animation.Rotation3DAnimation : Rotation3DAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Rotation3D By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Rotation3D From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Rotation3D To { get; public set; }
    public Rotation3DAnimation(Rotation3D toValue, Duration duration);
    public Rotation3DAnimation(Rotation3D toValue, Duration duration, FillBehavior fillBehavior);
    public Rotation3DAnimation(Rotation3D fromValue, Rotation3D toValue, Duration duration);
    public Rotation3DAnimation(Rotation3D fromValue, Rotation3D toValue, Duration duration, FillBehavior fillBehavior);
    public Rotation3D get_By();
    public void set_By(Rotation3D value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Rotation3D get_From();
    public void set_From(Rotation3D value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Rotation3D get_To();
    public void set_To(Rotation3D value);
    public Rotation3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Rotation3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Rotation3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Rotation3D GetCurrentValue(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames : Rotation3DAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Rotation3DKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Rotation3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Rotation3DKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public Rotation3DAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public Rotation3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.Rotation3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Rotation3D Value { get; public set; }
    protected Rotation3DKeyFrame(Rotation3D value);
    protected Rotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Rotation3D get_Value();
    public void set_Value(Rotation3D value);
    public Rotation3D InterpolateValue(Rotation3D baseValue, double keyFrameProgress);
    protected abstract virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Rotation3DKeyFrameCollection : Freezable {
    public int Count { get; }
    public static Rotation3DKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Rotation3DKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static Rotation3DKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public Rotation3DKeyFrame get_Item(int index);
    public void set_Item(int index, Rotation3DKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(Rotation3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    public Rotation3DKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(Rotation3DKeyFrame keyFrame);
    public void CopyTo(Rotation3DKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(Rotation3DKeyFrame keyFrame);
    public void Insert(int index, Rotation3DKeyFrame keyFrame);
    public void Remove(Rotation3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.SineEase : EasingFunctionBase {
    protected virtual Freezable CreateInstanceCore();
    protected virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.SingleAnimation : SingleAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<float> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<float> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<float> To { get; public set; }
    public SingleAnimation(float fromValue, float toValue, Duration duration);
    public SingleAnimation(float fromValue, float toValue, Duration duration, FillBehavior fillBehavior);
    public SingleAnimation(float toValue, Duration duration);
    public SingleAnimation(float toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<float> get_By();
    public void set_By(Nullable`1<float> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<float> get_From();
    public void set_From(Nullable`1<float> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<float> get_To();
    public void set_To(Nullable`1<float> value);
    public SingleAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.SingleAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public SingleAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public float GetCurrentValue(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.SingleAnimationUsingKeyFrames : SingleAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public SingleKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public SingleKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(SingleKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public SingleAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public SingleAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.SingleKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public float Value { get; public set; }
    protected SingleKeyFrame(float value);
    protected SingleKeyFrame(float value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public float get_Value();
    public void set_Value(float value);
    public float InterpolateValue(float baseValue, double keyFrameProgress);
    protected abstract virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.SingleKeyFrameCollection : Freezable {
    public int Count { get; }
    public static SingleKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public SingleKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static SingleKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public SingleKeyFrame get_Item(int index);
    public void set_Item(int index, SingleKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(SingleKeyFrame keyFrame);
    public sealed virtual void Clear();
    public SingleKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(SingleKeyFrame keyFrame);
    public void CopyTo(SingleKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(SingleKeyFrame keyFrame);
    public void Insert(int index, SingleKeyFrame keyFrame);
    public void Remove(SingleKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.SizeAnimation : SizeAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<Size> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<Size> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<Size> To { get; public set; }
    public SizeAnimation(Size toValue, Duration duration);
    public SizeAnimation(Size toValue, Duration duration, FillBehavior fillBehavior);
    public SizeAnimation(Size fromValue, Size toValue, Duration duration);
    public SizeAnimation(Size fromValue, Size toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Size> get_By();
    public void set_By(Nullable`1<Size> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<Size> get_From();
    public void set_From(Nullable`1<Size> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<Size> get_To();
    public void set_To(Nullable`1<Size> value);
    public SizeAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.SizeAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public SizeAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Size GetCurrentValue(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.SizeAnimationUsingKeyFrames : SizeAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public SizeKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public SizeKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(SizeKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public SizeAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public SizeAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.SizeKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Size Value { get; public set; }
    protected SizeKeyFrame(Size value);
    protected SizeKeyFrame(Size value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Size get_Value();
    public void set_Value(Size value);
    public Size InterpolateValue(Size baseValue, double keyFrameProgress);
    protected abstract virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.SizeKeyFrameCollection : Freezable {
    public int Count { get; }
    public static SizeKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public SizeKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static SizeKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public SizeKeyFrame get_Item(int index);
    public void set_Item(int index, SizeKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(SizeKeyFrame keyFrame);
    public sealed virtual void Clear();
    public SizeKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(SizeKeyFrame keyFrame);
    public void CopyTo(SizeKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(SizeKeyFrame keyFrame);
    public void Insert(int index, SizeKeyFrame keyFrame);
    public void Remove(SizeKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public enum System.Windows.Media.Animation.SlipBehavior : Enum {
    public int value__;
    public static SlipBehavior Grow;
    public static SlipBehavior Slip;
}
public class System.Windows.Media.Animation.SplineByteKeyFrame : ByteKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineByteKeyFrame(byte value);
    public SplineByteKeyFrame(byte value, KeyTime keyTime);
    public SplineByteKeyFrame(byte value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineColorKeyFrame : ColorKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineColorKeyFrame(Color value);
    public SplineColorKeyFrame(Color value, KeyTime keyTime);
    public SplineColorKeyFrame(Color value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineDecimalKeyFrame : DecimalKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineDecimalKeyFrame(decimal value);
    public SplineDecimalKeyFrame(decimal value, KeyTime keyTime);
    public SplineDecimalKeyFrame(decimal value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineDoubleKeyFrame : DoubleKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineDoubleKeyFrame(double value);
    public SplineDoubleKeyFrame(double value, KeyTime keyTime);
    public SplineDoubleKeyFrame(double value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineInt16KeyFrame : Int16KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt16KeyFrame(short value);
    public SplineInt16KeyFrame(short value, KeyTime keyTime);
    public SplineInt16KeyFrame(short value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineInt32KeyFrame : Int32KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt32KeyFrame(int value);
    public SplineInt32KeyFrame(int value, KeyTime keyTime);
    public SplineInt32KeyFrame(int value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineInt64KeyFrame : Int64KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt64KeyFrame(long value);
    public SplineInt64KeyFrame(long value, KeyTime keyTime);
    public SplineInt64KeyFrame(long value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplinePoint3DKeyFrame : Point3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplinePoint3DKeyFrame(Point3D value);
    public SplinePoint3DKeyFrame(Point3D value, KeyTime keyTime);
    public SplinePoint3DKeyFrame(Point3D value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplinePointKeyFrame : PointKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplinePointKeyFrame(Point value);
    public SplinePointKeyFrame(Point value, KeyTime keyTime);
    public SplinePointKeyFrame(Point value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public static DependencyProperty UseShortestPathProperty;
    public KeySpline KeySpline { get; public set; }
    public bool UseShortestPath { get; public set; }
    public SplineQuaternionKeyFrame(Quaternion value);
    public SplineQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public SplineQuaternionKeyFrame(Quaternion value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineRectKeyFrame : RectKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineRectKeyFrame(Rect value);
    public SplineRectKeyFrame(Rect value, KeyTime keyTime);
    public SplineRectKeyFrame(Rect value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineRotation3DKeyFrame : Rotation3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineRotation3DKeyFrame(Rotation3D value);
    public SplineRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    public SplineRotation3DKeyFrame(Rotation3D value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineSingleKeyFrame : SingleKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineSingleKeyFrame(float value);
    public SplineSingleKeyFrame(float value, KeyTime keyTime);
    public SplineSingleKeyFrame(float value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineSizeKeyFrame : SizeKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineSizeKeyFrame(Size value);
    public SplineSizeKeyFrame(Size value, KeyTime keyTime);
    public SplineSizeKeyFrame(Size value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineVector3DKeyFrame : Vector3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineVector3DKeyFrame(Vector3D value);
    public SplineVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    public SplineVector3DKeyFrame(Vector3D value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineVectorKeyFrame : VectorKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineVectorKeyFrame(Vector value);
    public SplineVectorKeyFrame(Vector value, KeyTime keyTime);
    public SplineVectorKeyFrame(Vector value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public abstract class System.Windows.Media.Animation.StringAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public StringAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public string GetCurrentValue(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual string GetCurrentValueCore(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.StringAnimationUsingKeyFrames : StringAnimationBase {
    public StringKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public StringKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(StringKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public StringAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public StringAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual string GetCurrentValueCore(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.StringKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public string Value { get; public set; }
    protected StringKeyFrame(string value);
    protected StringKeyFrame(string value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public string get_Value();
    public void set_Value(string value);
    public string InterpolateValue(string baseValue, double keyFrameProgress);
    protected abstract virtual string InterpolateValueCore(string baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.StringKeyFrameCollection : Freezable {
    public int Count { get; }
    public static StringKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public StringKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static StringKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public StringKeyFrame get_Item(int index);
    public void set_Item(int index, StringKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(StringKeyFrame keyFrame);
    public sealed virtual void Clear();
    public StringKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(StringKeyFrame keyFrame);
    public void CopyTo(StringKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(StringKeyFrame keyFrame);
    public void Insert(int index, StringKeyFrame keyFrame);
    public void Remove(StringKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
[LocalizabilityAttribute("0")]
[RuntimeNamePropertyAttribute("Name")]
public abstract class System.Windows.Media.Animation.Timeline : Animatable {
    public static DependencyProperty AccelerationRatioProperty;
    public static DependencyProperty AutoReverseProperty;
    public static DependencyProperty BeginTimeProperty;
    public static DependencyProperty DecelerationRatioProperty;
    public static DependencyProperty DesiredFrameRateProperty;
    public static DependencyProperty DurationProperty;
    public static DependencyProperty FillBehaviorProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty RepeatBehaviorProperty;
    public static DependencyProperty SpeedRatioProperty;
    public double AccelerationRatio { get; public set; }
    [DefaultValueAttribute("False")]
public bool AutoReverse { get; public set; }
    public Nullable`1<TimeSpan> BeginTime { get; public set; }
    public double DecelerationRatio { get; public set; }
    public Duration Duration { get; public set; }
    public FillBehavior FillBehavior { get; public set; }
    [DefaultValueAttribute("")]
[MergablePropertyAttribute("False")]
public string Name { get; public set; }
    public RepeatBehavior RepeatBehavior { get; public set; }
    [DefaultValueAttribute("1")]
public double SpeedRatio { get; public set; }
    protected Timeline(Nullable`1<TimeSpan> beginTime);
    protected Timeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    protected Timeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    public double get_AccelerationRatio();
    public void set_AccelerationRatio(double value);
    public bool get_AutoReverse();
    public void set_AutoReverse(bool value);
    public Nullable`1<TimeSpan> get_BeginTime();
    public void set_BeginTime(Nullable`1<TimeSpan> value);
    public double get_DecelerationRatio();
    public void set_DecelerationRatio(double value);
    public Duration get_Duration();
    public void set_Duration(Duration value);
    public FillBehavior get_FillBehavior();
    public void set_FillBehavior(FillBehavior value);
    public string get_Name();
    public void set_Name(string value);
    public RepeatBehavior get_RepeatBehavior();
    public void set_RepeatBehavior(RepeatBehavior value);
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    public void add_Completed(EventHandler value);
    public void remove_Completed(EventHandler value);
    public void add_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void remove_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void add_CurrentStateInvalidated(EventHandler value);
    public void remove_CurrentStateInvalidated(EventHandler value);
    public void add_CurrentTimeInvalidated(EventHandler value);
    public void remove_CurrentTimeInvalidated(EventHandler value);
    public void add_RemoveRequested(EventHandler value);
    public void remove_RemoveRequested(EventHandler value);
    protected internal virtual Clock AllocateClock();
    public Timeline Clone();
    public Timeline CloneCurrentValue();
    public Clock CreateClock();
    public Clock CreateClock(bool hasControllableRoot);
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public static Nullable`1<int> GetDesiredFrameRate(Timeline timeline);
    protected internal Duration GetNaturalDuration(Clock clock);
    protected virtual Duration GetNaturalDurationCore(Clock clock);
    public static void SetDesiredFrameRate(Timeline timeline, Nullable`1<int> desiredFrameRate);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.TimelineCollection : Animatable {
    public int Count { get; }
    public Timeline Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Animation.Timeline>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public TimelineCollection(IEnumerable`1<Timeline> collection);
    public TimelineCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual Timeline get_Item(int index);
    public sealed virtual void set_Item(int index, Timeline value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Animation.Timeline>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Timeline value);
    public sealed virtual void Clear();
    public TimelineCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public TimelineCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(Timeline value);
    public sealed virtual void CopyTo(Timeline[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Timeline value);
    public sealed virtual void Insert(int index, Timeline value);
    public sealed virtual bool Remove(Timeline value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<Timeline> System.Collections.Generic.IEnumerable<System.Windows.Media.Animation.Timeline>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[ContentPropertyAttribute("Children")]
public abstract class System.Windows.Media.Animation.TimelineGroup : Timeline {
    public static DependencyProperty ChildrenProperty;
    public TimelineCollection Children { get; public set; }
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime);
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime, Duration duration);
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    public TimelineCollection get_Children();
    public void set_Children(TimelineCollection value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected internal virtual Clock AllocateClock();
    public TimelineGroup Clone();
    public TimelineGroup CloneCurrentValue();
    public ClockGroup CreateClock();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public enum System.Windows.Media.Animation.TimeSeekOrigin : Enum {
    public int value__;
    public static TimeSeekOrigin BeginTime;
    public static TimeSeekOrigin Duration;
}
public class System.Windows.Media.Animation.Vector3DAnimation : Vector3DAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<Vector3D> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<Vector3D> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<Vector3D> To { get; public set; }
    public Vector3DAnimation(Vector3D toValue, Duration duration);
    public Vector3DAnimation(Vector3D toValue, Duration duration, FillBehavior fillBehavior);
    public Vector3DAnimation(Vector3D fromValue, Vector3D toValue, Duration duration);
    public Vector3DAnimation(Vector3D fromValue, Vector3D toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Vector3D> get_By();
    public void set_By(Nullable`1<Vector3D> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<Vector3D> get_From();
    public void set_From(Nullable`1<Vector3D> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<Vector3D> get_To();
    public void set_To(Nullable`1<Vector3D> value);
    public Vector3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Vector3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Vector3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Vector3D GetCurrentValue(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Vector3DAnimationUsingKeyFrames : Vector3DAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Vector3DKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Vector3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Vector3DKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public Vector3DAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public Vector3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.Vector3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Vector3D Value { get; public set; }
    protected Vector3DKeyFrame(Vector3D value);
    protected Vector3DKeyFrame(Vector3D value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Vector3D get_Value();
    public void set_Value(Vector3D value);
    public Vector3D InterpolateValue(Vector3D baseValue, double keyFrameProgress);
    protected abstract virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Vector3DKeyFrameCollection : Freezable {
    public int Count { get; }
    public static Vector3DKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Vector3DKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static Vector3DKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public Vector3DKeyFrame get_Item(int index);
    public void set_Item(int index, Vector3DKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(Vector3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    public Vector3DKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(Vector3DKeyFrame keyFrame);
    public void CopyTo(Vector3DKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(Vector3DKeyFrame keyFrame);
    public void Insert(int index, Vector3DKeyFrame keyFrame);
    public void Remove(Vector3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.Animation.VectorAnimation : VectorAnimationBase {
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<Vector> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public Nullable`1<Vector> From { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Nullable`1<Vector> To { get; public set; }
    public VectorAnimation(Vector toValue, Duration duration);
    public VectorAnimation(Vector toValue, Duration duration, FillBehavior fillBehavior);
    public VectorAnimation(Vector fromValue, Vector toValue, Duration duration);
    public VectorAnimation(Vector fromValue, Vector toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Vector> get_By();
    public void set_By(Nullable`1<Vector> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public Nullable`1<Vector> get_From();
    public void set_From(Nullable`1<Vector> value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Nullable`1<Vector> get_To();
    public void set_To(Nullable`1<Vector> value);
    public VectorAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.VectorAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public VectorAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Vector GetCurrentValue(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.VectorAnimationUsingKeyFrames : VectorAnimationBase {
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public VectorKeyFrameCollection KeyFrames { get; public set; }
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public VectorKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(VectorKeyFrameCollection value);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public VectorAnimationUsingKeyFrames Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public VectorAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected sealed virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    protected virtual void OnChanged();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
}
public abstract class System.Windows.Media.Animation.VectorKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Vector Value { get; public set; }
    protected VectorKeyFrame(Vector value);
    protected VectorKeyFrame(Vector value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Vector get_Value();
    public void set_Value(Vector value);
    public Vector InterpolateValue(Vector baseValue, double keyFrameProgress);
    protected abstract virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.VectorKeyFrameCollection : Freezable {
    public int Count { get; }
    public static VectorKeyFrameCollection Empty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public VectorKeyFrame Item { get; public set; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public static VectorKeyFrameCollection get_Empty();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public VectorKeyFrame get_Item(int index);
    public void set_Item(int index, VectorKeyFrame value);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int Add(VectorKeyFrame keyFrame);
    public sealed virtual void Clear();
    public VectorKeyFrameCollection Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool Contains(VectorKeyFrame keyFrame);
    public void CopyTo(VectorKeyFrame[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(VectorKeyFrame keyFrame);
    public void Insert(int index, VectorKeyFrame keyFrame);
    public void Remove(VectorKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
}
public class System.Windows.Media.ArcSegment : PathSegment {
    public static DependencyProperty IsLargeArcProperty;
    public static DependencyProperty PointProperty;
    public static DependencyProperty RotationAngleProperty;
    public static DependencyProperty SizeProperty;
    public static DependencyProperty SweepDirectionProperty;
    public bool IsLargeArc { get; public set; }
    public Point Point { get; public set; }
    public double RotationAngle { get; public set; }
    public Size Size { get; public set; }
    public SweepDirection SweepDirection { get; public set; }
    public ArcSegment(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked);
    public bool get_IsLargeArc();
    public void set_IsLargeArc(bool value);
    public Point get_Point();
    public void set_Point(Point value);
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
    public Size get_Size();
    public void set_Size(Size value);
    public SweepDirection get_SweepDirection();
    public void set_SweepDirection(SweepDirection value);
    public ArcSegment Clone();
    public ArcSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.BezierSegment : PathSegment {
    public static DependencyProperty Point1Property;
    public static DependencyProperty Point2Property;
    public static DependencyProperty Point3Property;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    public Point Point3 { get; public set; }
    public BezierSegment(Point point1, Point point2, Point point3, bool isStroked);
    public Point get_Point1();
    public void set_Point1(Point value);
    public Point get_Point2();
    public void set_Point2(Point value);
    public Point get_Point3();
    public void set_Point3(Point value);
    public BezierSegment Clone();
    public BezierSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.BitmapCache : CacheMode {
    public static DependencyProperty EnableClearTypeProperty;
    public static DependencyProperty RenderAtScaleProperty;
    public static DependencyProperty SnapsToDevicePixelsProperty;
    public bool EnableClearType { get; public set; }
    public double RenderAtScale { get; public set; }
    public bool SnapsToDevicePixels { get; public set; }
    public BitmapCache(double renderAtScale);
    public bool get_EnableClearType();
    public void set_EnableClearType(bool value);
    public double get_RenderAtScale();
    public void set_RenderAtScale(double value);
    public bool get_SnapsToDevicePixels();
    public void set_SnapsToDevicePixels(bool value);
    public BitmapCache Clone();
    public BitmapCache CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.BitmapCacheBrush : Brush {
    public static DependencyProperty AutoLayoutContentProperty;
    public static DependencyProperty BitmapCacheProperty;
    public static DependencyProperty TargetProperty;
    public bool AutoLayoutContent { get; public set; }
    public BitmapCache BitmapCache { get; public set; }
    public Visual Target { get; public set; }
    public BitmapCacheBrush(Visual visual);
    public bool get_AutoLayoutContent();
    public void set_AutoLayoutContent(bool value);
    public BitmapCache get_BitmapCache();
    public void set_BitmapCache(BitmapCache value);
    public Visual get_Target();
    public void set_Target(Visual value);
    public BitmapCacheBrush Clone();
    public BitmapCacheBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
}
public enum System.Windows.Media.BitmapScalingMode : Enum {
    public int value__;
    public static BitmapScalingMode Unspecified;
    public static BitmapScalingMode Linear;
    public static BitmapScalingMode LowQuality;
    public static BitmapScalingMode Fant;
    public static BitmapScalingMode HighQuality;
    public static BitmapScalingMode NearestNeighbor;
}
[TypeConverterAttribute("System.Windows.Media.BrushConverter")]
[LocalizabilityAttribute("0")]
[ValueSerializerAttribute("System.Windows.Media.Converters.BrushValueSerializer")]
public abstract class System.Windows.Media.Brush : Animatable {
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty RelativeTransformProperty;
    public static DependencyProperty TransformProperty;
    public double Opacity { get; public set; }
    public Transform RelativeTransform { get; public set; }
    public Transform Transform { get; public set; }
    public double get_Opacity();
    public void set_Opacity(double value);
    public Transform get_RelativeTransform();
    public void set_RelativeTransform(Transform value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Brush Clone();
    public Brush CloneCurrentValue();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.BrushConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Brushes : object {
    public static SolidColorBrush AliceBlue { get; }
    public static SolidColorBrush AntiqueWhite { get; }
    public static SolidColorBrush Aqua { get; }
    public static SolidColorBrush Aquamarine { get; }
    public static SolidColorBrush Azure { get; }
    public static SolidColorBrush Beige { get; }
    public static SolidColorBrush Bisque { get; }
    public static SolidColorBrush Black { get; }
    public static SolidColorBrush BlanchedAlmond { get; }
    public static SolidColorBrush Blue { get; }
    public static SolidColorBrush BlueViolet { get; }
    public static SolidColorBrush Brown { get; }
    public static SolidColorBrush BurlyWood { get; }
    public static SolidColorBrush CadetBlue { get; }
    public static SolidColorBrush Chartreuse { get; }
    public static SolidColorBrush Chocolate { get; }
    public static SolidColorBrush Coral { get; }
    public static SolidColorBrush CornflowerBlue { get; }
    public static SolidColorBrush Cornsilk { get; }
    public static SolidColorBrush Crimson { get; }
    public static SolidColorBrush Cyan { get; }
    public static SolidColorBrush DarkBlue { get; }
    public static SolidColorBrush DarkCyan { get; }
    public static SolidColorBrush DarkGoldenrod { get; }
    public static SolidColorBrush DarkGray { get; }
    public static SolidColorBrush DarkGreen { get; }
    public static SolidColorBrush DarkKhaki { get; }
    public static SolidColorBrush DarkMagenta { get; }
    public static SolidColorBrush DarkOliveGreen { get; }
    public static SolidColorBrush DarkOrange { get; }
    public static SolidColorBrush DarkOrchid { get; }
    public static SolidColorBrush DarkRed { get; }
    public static SolidColorBrush DarkSalmon { get; }
    public static SolidColorBrush DarkSeaGreen { get; }
    public static SolidColorBrush DarkSlateBlue { get; }
    public static SolidColorBrush DarkSlateGray { get; }
    public static SolidColorBrush DarkTurquoise { get; }
    public static SolidColorBrush DarkViolet { get; }
    public static SolidColorBrush DeepPink { get; }
    public static SolidColorBrush DeepSkyBlue { get; }
    public static SolidColorBrush DimGray { get; }
    public static SolidColorBrush DodgerBlue { get; }
    public static SolidColorBrush Firebrick { get; }
    public static SolidColorBrush FloralWhite { get; }
    public static SolidColorBrush ForestGreen { get; }
    public static SolidColorBrush Fuchsia { get; }
    public static SolidColorBrush Gainsboro { get; }
    public static SolidColorBrush GhostWhite { get; }
    public static SolidColorBrush Gold { get; }
    public static SolidColorBrush Goldenrod { get; }
    public static SolidColorBrush Gray { get; }
    public static SolidColorBrush Green { get; }
    public static SolidColorBrush GreenYellow { get; }
    public static SolidColorBrush Honeydew { get; }
    public static SolidColorBrush HotPink { get; }
    public static SolidColorBrush IndianRed { get; }
    public static SolidColorBrush Indigo { get; }
    public static SolidColorBrush Ivory { get; }
    public static SolidColorBrush Khaki { get; }
    public static SolidColorBrush Lavender { get; }
    public static SolidColorBrush LavenderBlush { get; }
    public static SolidColorBrush LawnGreen { get; }
    public static SolidColorBrush LemonChiffon { get; }
    public static SolidColorBrush LightBlue { get; }
    public static SolidColorBrush LightCoral { get; }
    public static SolidColorBrush LightCyan { get; }
    public static SolidColorBrush LightGoldenrodYellow { get; }
    public static SolidColorBrush LightGray { get; }
    public static SolidColorBrush LightGreen { get; }
    public static SolidColorBrush LightPink { get; }
    public static SolidColorBrush LightSalmon { get; }
    public static SolidColorBrush LightSeaGreen { get; }
    public static SolidColorBrush LightSkyBlue { get; }
    public static SolidColorBrush LightSlateGray { get; }
    public static SolidColorBrush LightSteelBlue { get; }
    public static SolidColorBrush LightYellow { get; }
    public static SolidColorBrush Lime { get; }
    public static SolidColorBrush LimeGreen { get; }
    public static SolidColorBrush Linen { get; }
    public static SolidColorBrush Magenta { get; }
    public static SolidColorBrush Maroon { get; }
    public static SolidColorBrush MediumAquamarine { get; }
    public static SolidColorBrush MediumBlue { get; }
    public static SolidColorBrush MediumOrchid { get; }
    public static SolidColorBrush MediumPurple { get; }
    public static SolidColorBrush MediumSeaGreen { get; }
    public static SolidColorBrush MediumSlateBlue { get; }
    public static SolidColorBrush MediumSpringGreen { get; }
    public static SolidColorBrush MediumTurquoise { get; }
    public static SolidColorBrush MediumVioletRed { get; }
    public static SolidColorBrush MidnightBlue { get; }
    public static SolidColorBrush MintCream { get; }
    public static SolidColorBrush MistyRose { get; }
    public static SolidColorBrush Moccasin { get; }
    public static SolidColorBrush NavajoWhite { get; }
    public static SolidColorBrush Navy { get; }
    public static SolidColorBrush OldLace { get; }
    public static SolidColorBrush Olive { get; }
    public static SolidColorBrush OliveDrab { get; }
    public static SolidColorBrush Orange { get; }
    public static SolidColorBrush OrangeRed { get; }
    public static SolidColorBrush Orchid { get; }
    public static SolidColorBrush PaleGoldenrod { get; }
    public static SolidColorBrush PaleGreen { get; }
    public static SolidColorBrush PaleTurquoise { get; }
    public static SolidColorBrush PaleVioletRed { get; }
    public static SolidColorBrush PapayaWhip { get; }
    public static SolidColorBrush PeachPuff { get; }
    public static SolidColorBrush Peru { get; }
    public static SolidColorBrush Pink { get; }
    public static SolidColorBrush Plum { get; }
    public static SolidColorBrush PowderBlue { get; }
    public static SolidColorBrush Purple { get; }
    public static SolidColorBrush Red { get; }
    public static SolidColorBrush RosyBrown { get; }
    public static SolidColorBrush RoyalBlue { get; }
    public static SolidColorBrush SaddleBrown { get; }
    public static SolidColorBrush Salmon { get; }
    public static SolidColorBrush SandyBrown { get; }
    public static SolidColorBrush SeaGreen { get; }
    public static SolidColorBrush SeaShell { get; }
    public static SolidColorBrush Sienna { get; }
    public static SolidColorBrush Silver { get; }
    public static SolidColorBrush SkyBlue { get; }
    public static SolidColorBrush SlateBlue { get; }
    public static SolidColorBrush SlateGray { get; }
    public static SolidColorBrush Snow { get; }
    public static SolidColorBrush SpringGreen { get; }
    public static SolidColorBrush SteelBlue { get; }
    public static SolidColorBrush Tan { get; }
    public static SolidColorBrush Teal { get; }
    public static SolidColorBrush Thistle { get; }
    public static SolidColorBrush Tomato { get; }
    public static SolidColorBrush Transparent { get; }
    public static SolidColorBrush Turquoise { get; }
    public static SolidColorBrush Violet { get; }
    public static SolidColorBrush Wheat { get; }
    public static SolidColorBrush White { get; }
    public static SolidColorBrush WhiteSmoke { get; }
    public static SolidColorBrush Yellow { get; }
    public static SolidColorBrush YellowGreen { get; }
    public static SolidColorBrush get_AliceBlue();
    public static SolidColorBrush get_AntiqueWhite();
    public static SolidColorBrush get_Aqua();
    public static SolidColorBrush get_Aquamarine();
    public static SolidColorBrush get_Azure();
    public static SolidColorBrush get_Beige();
    public static SolidColorBrush get_Bisque();
    public static SolidColorBrush get_Black();
    public static SolidColorBrush get_BlanchedAlmond();
    public static SolidColorBrush get_Blue();
    public static SolidColorBrush get_BlueViolet();
    public static SolidColorBrush get_Brown();
    public static SolidColorBrush get_BurlyWood();
    public static SolidColorBrush get_CadetBlue();
    public static SolidColorBrush get_Chartreuse();
    public static SolidColorBrush get_Chocolate();
    public static SolidColorBrush get_Coral();
    public static SolidColorBrush get_CornflowerBlue();
    public static SolidColorBrush get_Cornsilk();
    public static SolidColorBrush get_Crimson();
    public static SolidColorBrush get_Cyan();
    public static SolidColorBrush get_DarkBlue();
    public static SolidColorBrush get_DarkCyan();
    public static SolidColorBrush get_DarkGoldenrod();
    public static SolidColorBrush get_DarkGray();
    public static SolidColorBrush get_DarkGreen();
    public static SolidColorBrush get_DarkKhaki();
    public static SolidColorBrush get_DarkMagenta();
    public static SolidColorBrush get_DarkOliveGreen();
    public static SolidColorBrush get_DarkOrange();
    public static SolidColorBrush get_DarkOrchid();
    public static SolidColorBrush get_DarkRed();
    public static SolidColorBrush get_DarkSalmon();
    public static SolidColorBrush get_DarkSeaGreen();
    public static SolidColorBrush get_DarkSlateBlue();
    public static SolidColorBrush get_DarkSlateGray();
    public static SolidColorBrush get_DarkTurquoise();
    public static SolidColorBrush get_DarkViolet();
    public static SolidColorBrush get_DeepPink();
    public static SolidColorBrush get_DeepSkyBlue();
    public static SolidColorBrush get_DimGray();
    public static SolidColorBrush get_DodgerBlue();
    public static SolidColorBrush get_Firebrick();
    public static SolidColorBrush get_FloralWhite();
    public static SolidColorBrush get_ForestGreen();
    public static SolidColorBrush get_Fuchsia();
    public static SolidColorBrush get_Gainsboro();
    public static SolidColorBrush get_GhostWhite();
    public static SolidColorBrush get_Gold();
    public static SolidColorBrush get_Goldenrod();
    public static SolidColorBrush get_Gray();
    public static SolidColorBrush get_Green();
    public static SolidColorBrush get_GreenYellow();
    public static SolidColorBrush get_Honeydew();
    public static SolidColorBrush get_HotPink();
    public static SolidColorBrush get_IndianRed();
    public static SolidColorBrush get_Indigo();
    public static SolidColorBrush get_Ivory();
    public static SolidColorBrush get_Khaki();
    public static SolidColorBrush get_Lavender();
    public static SolidColorBrush get_LavenderBlush();
    public static SolidColorBrush get_LawnGreen();
    public static SolidColorBrush get_LemonChiffon();
    public static SolidColorBrush get_LightBlue();
    public static SolidColorBrush get_LightCoral();
    public static SolidColorBrush get_LightCyan();
    public static SolidColorBrush get_LightGoldenrodYellow();
    public static SolidColorBrush get_LightGray();
    public static SolidColorBrush get_LightGreen();
    public static SolidColorBrush get_LightPink();
    public static SolidColorBrush get_LightSalmon();
    public static SolidColorBrush get_LightSeaGreen();
    public static SolidColorBrush get_LightSkyBlue();
    public static SolidColorBrush get_LightSlateGray();
    public static SolidColorBrush get_LightSteelBlue();
    public static SolidColorBrush get_LightYellow();
    public static SolidColorBrush get_Lime();
    public static SolidColorBrush get_LimeGreen();
    public static SolidColorBrush get_Linen();
    public static SolidColorBrush get_Magenta();
    public static SolidColorBrush get_Maroon();
    public static SolidColorBrush get_MediumAquamarine();
    public static SolidColorBrush get_MediumBlue();
    public static SolidColorBrush get_MediumOrchid();
    public static SolidColorBrush get_MediumPurple();
    public static SolidColorBrush get_MediumSeaGreen();
    public static SolidColorBrush get_MediumSlateBlue();
    public static SolidColorBrush get_MediumSpringGreen();
    public static SolidColorBrush get_MediumTurquoise();
    public static SolidColorBrush get_MediumVioletRed();
    public static SolidColorBrush get_MidnightBlue();
    public static SolidColorBrush get_MintCream();
    public static SolidColorBrush get_MistyRose();
    public static SolidColorBrush get_Moccasin();
    public static SolidColorBrush get_NavajoWhite();
    public static SolidColorBrush get_Navy();
    public static SolidColorBrush get_OldLace();
    public static SolidColorBrush get_Olive();
    public static SolidColorBrush get_OliveDrab();
    public static SolidColorBrush get_Orange();
    public static SolidColorBrush get_OrangeRed();
    public static SolidColorBrush get_Orchid();
    public static SolidColorBrush get_PaleGoldenrod();
    public static SolidColorBrush get_PaleGreen();
    public static SolidColorBrush get_PaleTurquoise();
    public static SolidColorBrush get_PaleVioletRed();
    public static SolidColorBrush get_PapayaWhip();
    public static SolidColorBrush get_PeachPuff();
    public static SolidColorBrush get_Peru();
    public static SolidColorBrush get_Pink();
    public static SolidColorBrush get_Plum();
    public static SolidColorBrush get_PowderBlue();
    public static SolidColorBrush get_Purple();
    public static SolidColorBrush get_Red();
    public static SolidColorBrush get_RosyBrown();
    public static SolidColorBrush get_RoyalBlue();
    public static SolidColorBrush get_SaddleBrown();
    public static SolidColorBrush get_Salmon();
    public static SolidColorBrush get_SandyBrown();
    public static SolidColorBrush get_SeaGreen();
    public static SolidColorBrush get_SeaShell();
    public static SolidColorBrush get_Sienna();
    public static SolidColorBrush get_Silver();
    public static SolidColorBrush get_SkyBlue();
    public static SolidColorBrush get_SlateBlue();
    public static SolidColorBrush get_SlateGray();
    public static SolidColorBrush get_Snow();
    public static SolidColorBrush get_SpringGreen();
    public static SolidColorBrush get_SteelBlue();
    public static SolidColorBrush get_Tan();
    public static SolidColorBrush get_Teal();
    public static SolidColorBrush get_Thistle();
    public static SolidColorBrush get_Tomato();
    public static SolidColorBrush get_Transparent();
    public static SolidColorBrush get_Turquoise();
    public static SolidColorBrush get_Violet();
    public static SolidColorBrush get_Wheat();
    public static SolidColorBrush get_White();
    public static SolidColorBrush get_WhiteSmoke();
    public static SolidColorBrush get_Yellow();
    public static SolidColorBrush get_YellowGreen();
}
public enum System.Windows.Media.BrushMappingMode : Enum {
    public int value__;
    public static BrushMappingMode Absolute;
    public static BrushMappingMode RelativeToBoundingBox;
}
[TypeConverterAttribute("System.Windows.Media.CacheModeConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.CacheModeValueSerializer")]
public abstract class System.Windows.Media.CacheMode : Animatable {
    public CacheMode Clone();
    public CacheMode CloneCurrentValue();
}
public class System.Windows.Media.CacheModeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.CachingHint : Enum {
    public int value__;
    public static CachingHint Unspecified;
    public static CachingHint Cache;
}
public class System.Windows.Media.CharacterMetrics : object {
    public double Baseline { get; }
    public double BlackBoxHeight { get; }
    public double BlackBoxWidth { get; }
    public double BottomSideBearing { get; }
    public double LeftSideBearing { get; }
    public string Metrics { get; public set; }
    public double RightSideBearing { get; }
    public double TopSideBearing { get; }
    public CharacterMetrics(string metrics);
    public double get_Baseline();
    public double get_BlackBoxHeight();
    public double get_BlackBoxWidth();
    public double get_BottomSideBearing();
    public double get_LeftSideBearing();
    public string get_Metrics();
    public void set_Metrics(string value);
    public double get_RightSideBearing();
    public double get_TopSideBearing();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.CharacterMetricsDictionary : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public CharacterMetrics Item { get; public set; }
    [CLSCompliantAttribute("False")]
public ICollection`1<int> Keys { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [CLSCompliantAttribute("False")]
public ICollection`1<CharacterMetrics> Values { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual CharacterMetrics get_Item(int key);
    public sealed virtual void set_Item(int key, CharacterMetrics value);
    public sealed virtual ICollection`1<int> get_Keys();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual ICollection`1<CharacterMetrics> get_Values();
    [CLSCompliantAttribute("False")]
public sealed virtual void Add(KeyValuePair`2<int, CharacterMetrics> item);
    public sealed virtual void Add(int key, CharacterMetrics value);
    public sealed virtual void Clear();
    [CLSCompliantAttribute("False")]
public sealed virtual bool Contains(KeyValuePair`2<int, CharacterMetrics> item);
    public sealed virtual bool ContainsKey(int key);
    [CLSCompliantAttribute("False")]
public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    [CLSCompliantAttribute("False")]
public sealed virtual IEnumerator`1<KeyValuePair`2<int, CharacterMetrics>> GetEnumerator();
    [CLSCompliantAttribute("False")]
public sealed virtual bool Remove(KeyValuePair`2<int, CharacterMetrics> item);
    public sealed virtual bool Remove(int key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryGetValue(int key, CharacterMetrics& value);
}
public enum System.Windows.Media.ClearTypeHint : Enum {
    public int value__;
    public static ClearTypeHint Auto;
    public static ClearTypeHint Enabled;
}
[TypeConverterAttribute("System.Windows.Media.ColorConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.Color : ValueType {
    public byte A { get; public set; }
    public byte B { get; public set; }
    public ColorContext ColorContext { get; }
    public byte G { get; public set; }
    public byte R { get; public set; }
    public float ScA { get; public set; }
    public float ScB { get; public set; }
    public float ScG { get; public set; }
    public float ScR { get; public set; }
    public byte get_A();
    public void set_A(byte value);
    public byte get_B();
    public void set_B(byte value);
    public ColorContext get_ColorContext();
    public byte get_G();
    public void set_G(byte value);
    public byte get_R();
    public void set_R(byte value);
    public float get_ScA();
    public void set_ScA(float value);
    public float get_ScB();
    public void set_ScB(float value);
    public float get_ScG();
    public void set_ScG(float value);
    public float get_ScR();
    public void set_ScR(float value);
    public static Color Add(Color color1, Color color2);
    public static bool AreClose(Color color1, Color color2);
    public void Clamp();
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(Color color);
    public static bool Equals(Color color1, Color color2);
    public static Color FromArgb(byte a, byte r, byte g, byte b);
    public static Color FromAValues(float a, Single[] values, Uri profileUri);
    public static Color FromRgb(byte r, byte g, byte b);
    public static Color FromScRgb(float a, float r, float g, float b);
    public static Color FromValues(Single[] values, Uri profileUri);
    public virtual int GetHashCode();
    public Single[] GetNativeColorValues();
    public static Color Multiply(Color color, float coefficient);
    public static Color op_Addition(Color color1, Color color2);
    public static bool op_Equality(Color color1, Color color2);
    public static bool op_Inequality(Color color1, Color color2);
    public static Color op_Multiply(Color color, float coefficient);
    public static Color op_Subtraction(Color color1, Color color2);
    public static Color Subtract(Color color1, Color color2);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.ColorContext : object {
    public Uri ProfileUri { get; }
    public ColorContext(Uri profileUri);
    public ColorContext(PixelFormat pixelFormat);
    public Uri get_ProfileUri();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Stream OpenProfileStream();
    public static bool op_Equality(ColorContext context1, ColorContext context2);
    public static bool op_Inequality(ColorContext context1, ColorContext context2);
}
public class System.Windows.Media.ColorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public static object ConvertFromString(string value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.ColorInterpolationMode : Enum {
    public int value__;
    public static ColorInterpolationMode ScRgbLinearInterpolation;
    public static ColorInterpolationMode SRgbLinearInterpolation;
}
public class System.Windows.Media.Colors : object {
    public static Color AliceBlue { get; }
    public static Color AntiqueWhite { get; }
    public static Color Aqua { get; }
    public static Color Aquamarine { get; }
    public static Color Azure { get; }
    public static Color Beige { get; }
    public static Color Bisque { get; }
    public static Color Black { get; }
    public static Color BlanchedAlmond { get; }
    public static Color Blue { get; }
    public static Color BlueViolet { get; }
    public static Color Brown { get; }
    public static Color BurlyWood { get; }
    public static Color CadetBlue { get; }
    public static Color Chartreuse { get; }
    public static Color Chocolate { get; }
    public static Color Coral { get; }
    public static Color CornflowerBlue { get; }
    public static Color Cornsilk { get; }
    public static Color Crimson { get; }
    public static Color Cyan { get; }
    public static Color DarkBlue { get; }
    public static Color DarkCyan { get; }
    public static Color DarkGoldenrod { get; }
    public static Color DarkGray { get; }
    public static Color DarkGreen { get; }
    public static Color DarkKhaki { get; }
    public static Color DarkMagenta { get; }
    public static Color DarkOliveGreen { get; }
    public static Color DarkOrange { get; }
    public static Color DarkOrchid { get; }
    public static Color DarkRed { get; }
    public static Color DarkSalmon { get; }
    public static Color DarkSeaGreen { get; }
    public static Color DarkSlateBlue { get; }
    public static Color DarkSlateGray { get; }
    public static Color DarkTurquoise { get; }
    public static Color DarkViolet { get; }
    public static Color DeepPink { get; }
    public static Color DeepSkyBlue { get; }
    public static Color DimGray { get; }
    public static Color DodgerBlue { get; }
    public static Color Firebrick { get; }
    public static Color FloralWhite { get; }
    public static Color ForestGreen { get; }
    public static Color Fuchsia { get; }
    public static Color Gainsboro { get; }
    public static Color GhostWhite { get; }
    public static Color Gold { get; }
    public static Color Goldenrod { get; }
    public static Color Gray { get; }
    public static Color Green { get; }
    public static Color GreenYellow { get; }
    public static Color Honeydew { get; }
    public static Color HotPink { get; }
    public static Color IndianRed { get; }
    public static Color Indigo { get; }
    public static Color Ivory { get; }
    public static Color Khaki { get; }
    public static Color Lavender { get; }
    public static Color LavenderBlush { get; }
    public static Color LawnGreen { get; }
    public static Color LemonChiffon { get; }
    public static Color LightBlue { get; }
    public static Color LightCoral { get; }
    public static Color LightCyan { get; }
    public static Color LightGoldenrodYellow { get; }
    public static Color LightGray { get; }
    public static Color LightGreen { get; }
    public static Color LightPink { get; }
    public static Color LightSalmon { get; }
    public static Color LightSeaGreen { get; }
    public static Color LightSkyBlue { get; }
    public static Color LightSlateGray { get; }
    public static Color LightSteelBlue { get; }
    public static Color LightYellow { get; }
    public static Color Lime { get; }
    public static Color LimeGreen { get; }
    public static Color Linen { get; }
    public static Color Magenta { get; }
    public static Color Maroon { get; }
    public static Color MediumAquamarine { get; }
    public static Color MediumBlue { get; }
    public static Color MediumOrchid { get; }
    public static Color MediumPurple { get; }
    public static Color MediumSeaGreen { get; }
    public static Color MediumSlateBlue { get; }
    public static Color MediumSpringGreen { get; }
    public static Color MediumTurquoise { get; }
    public static Color MediumVioletRed { get; }
    public static Color MidnightBlue { get; }
    public static Color MintCream { get; }
    public static Color MistyRose { get; }
    public static Color Moccasin { get; }
    public static Color NavajoWhite { get; }
    public static Color Navy { get; }
    public static Color OldLace { get; }
    public static Color Olive { get; }
    public static Color OliveDrab { get; }
    public static Color Orange { get; }
    public static Color OrangeRed { get; }
    public static Color Orchid { get; }
    public static Color PaleGoldenrod { get; }
    public static Color PaleGreen { get; }
    public static Color PaleTurquoise { get; }
    public static Color PaleVioletRed { get; }
    public static Color PapayaWhip { get; }
    public static Color PeachPuff { get; }
    public static Color Peru { get; }
    public static Color Pink { get; }
    public static Color Plum { get; }
    public static Color PowderBlue { get; }
    public static Color Purple { get; }
    public static Color Red { get; }
    public static Color RosyBrown { get; }
    public static Color RoyalBlue { get; }
    public static Color SaddleBrown { get; }
    public static Color Salmon { get; }
    public static Color SandyBrown { get; }
    public static Color SeaGreen { get; }
    public static Color SeaShell { get; }
    public static Color Sienna { get; }
    public static Color Silver { get; }
    public static Color SkyBlue { get; }
    public static Color SlateBlue { get; }
    public static Color SlateGray { get; }
    public static Color Snow { get; }
    public static Color SpringGreen { get; }
    public static Color SteelBlue { get; }
    public static Color Tan { get; }
    public static Color Teal { get; }
    public static Color Thistle { get; }
    public static Color Tomato { get; }
    public static Color Transparent { get; }
    public static Color Turquoise { get; }
    public static Color Violet { get; }
    public static Color Wheat { get; }
    public static Color White { get; }
    public static Color WhiteSmoke { get; }
    public static Color Yellow { get; }
    public static Color YellowGreen { get; }
    public static Color get_AliceBlue();
    public static Color get_AntiqueWhite();
    public static Color get_Aqua();
    public static Color get_Aquamarine();
    public static Color get_Azure();
    public static Color get_Beige();
    public static Color get_Bisque();
    public static Color get_Black();
    public static Color get_BlanchedAlmond();
    public static Color get_Blue();
    public static Color get_BlueViolet();
    public static Color get_Brown();
    public static Color get_BurlyWood();
    public static Color get_CadetBlue();
    public static Color get_Chartreuse();
    public static Color get_Chocolate();
    public static Color get_Coral();
    public static Color get_CornflowerBlue();
    public static Color get_Cornsilk();
    public static Color get_Crimson();
    public static Color get_Cyan();
    public static Color get_DarkBlue();
    public static Color get_DarkCyan();
    public static Color get_DarkGoldenrod();
    public static Color get_DarkGray();
    public static Color get_DarkGreen();
    public static Color get_DarkKhaki();
    public static Color get_DarkMagenta();
    public static Color get_DarkOliveGreen();
    public static Color get_DarkOrange();
    public static Color get_DarkOrchid();
    public static Color get_DarkRed();
    public static Color get_DarkSalmon();
    public static Color get_DarkSeaGreen();
    public static Color get_DarkSlateBlue();
    public static Color get_DarkSlateGray();
    public static Color get_DarkTurquoise();
    public static Color get_DarkViolet();
    public static Color get_DeepPink();
    public static Color get_DeepSkyBlue();
    public static Color get_DimGray();
    public static Color get_DodgerBlue();
    public static Color get_Firebrick();
    public static Color get_FloralWhite();
    public static Color get_ForestGreen();
    public static Color get_Fuchsia();
    public static Color get_Gainsboro();
    public static Color get_GhostWhite();
    public static Color get_Gold();
    public static Color get_Goldenrod();
    public static Color get_Gray();
    public static Color get_Green();
    public static Color get_GreenYellow();
    public static Color get_Honeydew();
    public static Color get_HotPink();
    public static Color get_IndianRed();
    public static Color get_Indigo();
    public static Color get_Ivory();
    public static Color get_Khaki();
    public static Color get_Lavender();
    public static Color get_LavenderBlush();
    public static Color get_LawnGreen();
    public static Color get_LemonChiffon();
    public static Color get_LightBlue();
    public static Color get_LightCoral();
    public static Color get_LightCyan();
    public static Color get_LightGoldenrodYellow();
    public static Color get_LightGray();
    public static Color get_LightGreen();
    public static Color get_LightPink();
    public static Color get_LightSalmon();
    public static Color get_LightSeaGreen();
    public static Color get_LightSkyBlue();
    public static Color get_LightSlateGray();
    public static Color get_LightSteelBlue();
    public static Color get_LightYellow();
    public static Color get_Lime();
    public static Color get_LimeGreen();
    public static Color get_Linen();
    public static Color get_Magenta();
    public static Color get_Maroon();
    public static Color get_MediumAquamarine();
    public static Color get_MediumBlue();
    public static Color get_MediumOrchid();
    public static Color get_MediumPurple();
    public static Color get_MediumSeaGreen();
    public static Color get_MediumSlateBlue();
    public static Color get_MediumSpringGreen();
    public static Color get_MediumTurquoise();
    public static Color get_MediumVioletRed();
    public static Color get_MidnightBlue();
    public static Color get_MintCream();
    public static Color get_MistyRose();
    public static Color get_Moccasin();
    public static Color get_NavajoWhite();
    public static Color get_Navy();
    public static Color get_OldLace();
    public static Color get_Olive();
    public static Color get_OliveDrab();
    public static Color get_Orange();
    public static Color get_OrangeRed();
    public static Color get_Orchid();
    public static Color get_PaleGoldenrod();
    public static Color get_PaleGreen();
    public static Color get_PaleTurquoise();
    public static Color get_PaleVioletRed();
    public static Color get_PapayaWhip();
    public static Color get_PeachPuff();
    public static Color get_Peru();
    public static Color get_Pink();
    public static Color get_Plum();
    public static Color get_PowderBlue();
    public static Color get_Purple();
    public static Color get_Red();
    public static Color get_RosyBrown();
    public static Color get_RoyalBlue();
    public static Color get_SaddleBrown();
    public static Color get_Salmon();
    public static Color get_SandyBrown();
    public static Color get_SeaGreen();
    public static Color get_SeaShell();
    public static Color get_Sienna();
    public static Color get_Silver();
    public static Color get_SkyBlue();
    public static Color get_SlateBlue();
    public static Color get_SlateGray();
    public static Color get_Snow();
    public static Color get_SpringGreen();
    public static Color get_SteelBlue();
    public static Color get_Tan();
    public static Color get_Teal();
    public static Color get_Thistle();
    public static Color get_Tomato();
    public static Color get_Transparent();
    public static Color get_Turquoise();
    public static Color get_Violet();
    public static Color get_Wheat();
    public static Color get_White();
    public static Color get_WhiteSmoke();
    public static Color get_Yellow();
    public static Color get_YellowGreen();
}
public class System.Windows.Media.CombinedGeometry : Geometry {
    public static DependencyProperty Geometry1Property;
    public static DependencyProperty Geometry2Property;
    public static DependencyProperty GeometryCombineModeProperty;
    public Rect Bounds { get; }
    public Geometry Geometry1 { get; public set; }
    public Geometry Geometry2 { get; public set; }
    public GeometryCombineMode GeometryCombineMode { get; public set; }
    public CombinedGeometry(Geometry geometry1, Geometry geometry2);
    public CombinedGeometry(GeometryCombineMode geometryCombineMode, Geometry geometry1, Geometry geometry2);
    public CombinedGeometry(GeometryCombineMode geometryCombineMode, Geometry geometry1, Geometry geometry2, Transform transform);
    public virtual Rect get_Bounds();
    public Geometry get_Geometry1();
    public void set_Geometry1(Geometry value);
    public Geometry get_Geometry2();
    public void set_Geometry2(Geometry value);
    public GeometryCombineMode get_GeometryCombineMode();
    public void set_GeometryCombineMode(GeometryCombineMode value);
    public CombinedGeometry Clone();
    public CombinedGeometry CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public virtual double GetArea(double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
}
public abstract class System.Windows.Media.CompositionTarget : DispatcherObject {
    public Visual RootVisual { get; public set; }
    public Matrix TransformFromDevice { get; }
    public Matrix TransformToDevice { get; }
    public virtual Visual get_RootVisual();
    public virtual void set_RootVisual(Visual value);
    public abstract virtual Matrix get_TransformFromDevice();
    public abstract virtual Matrix get_TransformToDevice();
    public static void add_Rendering(EventHandler value);
    public static void remove_Rendering(EventHandler value);
    public virtual void Dispose();
}
public class System.Windows.Media.ContainerVisual : Visual {
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public CacheMode CacheMode { get; public set; }
    public VisualCollection Children { get; }
    public Geometry Clip { get; public set; }
    public Rect ContentBounds { get; }
    public Rect DescendantBounds { get; }
    public Effect Effect { get; public set; }
    public Vector Offset { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    public DependencyObject Parent { get; }
    public Transform Transform { get; public set; }
    protected int VisualChildrenCount { get; }
    [DefaultValueAttribute("")]
public DoubleCollection XSnappingGuidelines { get; public set; }
    [DefaultValueAttribute("")]
public DoubleCollection YSnappingGuidelines { get; public set; }
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    public VisualCollection get_Children();
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public Rect get_ContentBounds();
    public Rect get_DescendantBounds();
    public Effect get_Effect();
    public void set_Effect(Effect value);
    public Vector get_Offset();
    public void set_Offset(Vector value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public DependencyObject get_Parent();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    protected sealed virtual int get_VisualChildrenCount();
    public DoubleCollection get_XSnappingGuidelines();
    public void set_XSnappingGuidelines(DoubleCollection value);
    public DoubleCollection get_YSnappingGuidelines();
    public void set_YSnappingGuidelines(DoubleCollection value);
    protected sealed virtual Visual GetVisualChild(int index);
    public void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    public HitTestResult HitTest(Point point);
}
public abstract class System.Windows.Media.Converters.BaseIListConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.BoolIListConverter : BaseIListConverter {
}
public class System.Windows.Media.Converters.BrushValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.CacheModeValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.CharIListConverter : BaseIListConverter {
}
public class System.Windows.Media.Converters.DoubleCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.DoubleIListConverter : BaseIListConverter {
}
public class System.Windows.Media.Converters.GeometryValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.Int32CollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PathFigureCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PointCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PointIListConverter : BaseIListConverter {
}
public class System.Windows.Media.Converters.TransformValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.UShortIListConverter : BaseIListConverter {
}
public class System.Windows.Media.Converters.VectorCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.DashStyle : Animatable {
    public static DependencyProperty DashesProperty;
    public static DependencyProperty OffsetProperty;
    public DoubleCollection Dashes { get; public set; }
    public double Offset { get; public set; }
    public DashStyle(IEnumerable`1<double> dashes, double offset);
    public DoubleCollection get_Dashes();
    public void set_Dashes(DoubleCollection value);
    public double get_Offset();
    public void set_Offset(double value);
    public DashStyle Clone();
    public DashStyle CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public static class System.Windows.Media.DashStyles : object {
    public static DashStyle Dash { get; }
    public static DashStyle DashDot { get; }
    public static DashStyle DashDotDot { get; }
    public static DashStyle Dot { get; }
    public static DashStyle Solid { get; }
    public static DashStyle get_Dash();
    public static DashStyle get_DashDot();
    public static DashStyle get_DashDotDot();
    public static DashStyle get_Dot();
    public static DashStyle get_Solid();
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.DoubleCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.DoubleCollectionValueSerializer")]
public class System.Windows.Media.DoubleCollection : Freezable {
    public int Count { get; }
    public double Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Double>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public DoubleCollection(IEnumerable`1<double> collection);
    public DoubleCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual double get_Item(int index);
    public sealed virtual void set_Item(int index, double value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Double>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(double value);
    public sealed virtual void Clear();
    public DoubleCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public DoubleCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(double value);
    public sealed virtual void CopyTo(Double[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(double value);
    public sealed virtual void Insert(int index, double value);
    public static DoubleCollection Parse(string source);
    public sealed virtual bool Remove(double value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<double> System.Collections.Generic.IEnumerable<System.Double>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.DoubleCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Drawing : Animatable {
    public Rect Bounds { get; }
    public Rect get_Bounds();
    public Drawing Clone();
    public Drawing CloneCurrentValue();
}
public class System.Windows.Media.DrawingBrush : TileBrush {
    public static DependencyProperty DrawingProperty;
    public Drawing Drawing { get; public set; }
    public DrawingBrush(Drawing drawing);
    public Drawing get_Drawing();
    public void set_Drawing(Drawing value);
    public DrawingBrush Clone();
    public DrawingBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetContentBounds(Rect& contentBounds);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.DrawingCollection : Animatable {
    public int Count { get; }
    public Drawing Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Drawing>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public DrawingCollection(IEnumerable`1<Drawing> collection);
    public DrawingCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual Drawing get_Item(int index);
    public sealed virtual void set_Item(int index, Drawing value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Drawing>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Drawing value);
    public sealed virtual void Clear();
    public DrawingCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public DrawingCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(Drawing value);
    public sealed virtual void CopyTo(Drawing[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Drawing value);
    public sealed virtual void Insert(int index, Drawing value);
    public sealed virtual bool Remove(Drawing value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<Drawing> System.Collections.Generic.IEnumerable<System.Windows.Media.Drawing>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public abstract class System.Windows.Media.DrawingContext : DispatcherObject {
    public abstract virtual void Close();
    protected abstract virtual void DisposeCore();
    public abstract virtual void DrawDrawing(Drawing drawing);
    public abstract virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public abstract virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public abstract virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public abstract virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public abstract virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public abstract virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    public abstract virtual void DrawLine(Pen pen, Point point0, Point point1);
    public abstract virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public abstract virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public abstract virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public void DrawText(FormattedText formattedText, Point origin);
    public abstract virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    public abstract virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void Pop();
    public abstract virtual void PushClip(Geometry clipGeometry);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public abstract virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public abstract virtual void PushGuidelineSet(GuidelineSet guidelines);
    public abstract virtual void PushOpacity(double opacity);
    public abstract virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    public abstract virtual void PushOpacityMask(Brush opacityMask);
    public abstract virtual void PushTransform(Transform transform);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void VerifyApiNonstructuralChange();
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.DrawingGroup : Drawing {
    public static DependencyProperty BitmapEffectInputProperty;
    public static DependencyProperty BitmapEffectProperty;
    public static DependencyProperty ChildrenProperty;
    public static DependencyProperty ClipGeometryProperty;
    public static DependencyProperty GuidelineSetProperty;
    public static DependencyProperty OpacityMaskProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty TransformProperty;
    public BitmapEffect BitmapEffect { get; public set; }
    public BitmapEffectInput BitmapEffectInput { get; public set; }
    public DrawingCollection Children { get; public set; }
    public Geometry ClipGeometry { get; public set; }
    public GuidelineSet GuidelineSet { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    public Transform Transform { get; public set; }
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public DrawingCollection get_Children();
    public void set_Children(DrawingCollection value);
    public Geometry get_ClipGeometry();
    public void set_ClipGeometry(Geometry value);
    public GuidelineSet get_GuidelineSet();
    public void set_GuidelineSet(GuidelineSet value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public DrawingContext Append();
    public DrawingGroup Clone();
    public DrawingGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public DrawingContext Open();
}
public class System.Windows.Media.DrawingImage : ImageSource {
    public static DependencyProperty DrawingProperty;
    public Drawing Drawing { get; public set; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    public double Width { get; }
    public DrawingImage(Drawing drawing);
    public Drawing get_Drawing();
    public void set_Drawing(Drawing value);
    public virtual double get_Height();
    public virtual ImageMetadata get_Metadata();
    public virtual double get_Width();
    public DrawingImage Clone();
    public DrawingImage CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.DrawingVisual : ContainerVisual {
    public DrawingGroup Drawing { get; }
    public DrawingGroup get_Drawing();
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    public DrawingContext RenderOpen();
}
public enum System.Windows.Media.EdgeMode : Enum {
    public int value__;
    public static EdgeMode Unspecified;
    public static EdgeMode Aliased;
}
public class System.Windows.Media.Effects.BevelBitmapEffect : BitmapEffect {
    public static DependencyProperty BevelWidthProperty;
    public static DependencyProperty EdgeProfileProperty;
    public static DependencyProperty LightAngleProperty;
    public static DependencyProperty ReliefProperty;
    public static DependencyProperty SmoothnessProperty;
    public double BevelWidth { get; public set; }
    public EdgeProfile EdgeProfile { get; public set; }
    public double LightAngle { get; public set; }
    public double Relief { get; public set; }
    public double Smoothness { get; public set; }
    public double get_BevelWidth();
    public void set_BevelWidth(double value);
    public EdgeProfile get_EdgeProfile();
    public void set_EdgeProfile(EdgeProfile value);
    public double get_LightAngle();
    public void set_LightAngle(double value);
    public double get_Relief();
    public void set_Relief(double value);
    public double get_Smoothness();
    public void set_Smoothness(double value);
    public BevelBitmapEffect Clone();
    public BevelBitmapEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
}
public abstract class System.Windows.Media.Effects.BitmapEffect : Animatable {
    public BitmapEffect Clone();
    public BitmapEffect CloneCurrentValue();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected static SafeHandle CreateBitmapEffectOuter();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected abstract virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapSource GetOutput(BitmapEffectInput input);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected static void InitializeBitmapEffect(SafeHandle outerObject, SafeHandle innerObject);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected static void SetValue(SafeHandle effect, string propertyName, object value);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected abstract virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Effects.BitmapEffectCollection : Animatable {
    public int Count { get; }
    public BitmapEffect Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Effects.BitmapEffect>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public BitmapEffectCollection(IEnumerable`1<BitmapEffect> collection);
    public BitmapEffectCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual BitmapEffect get_Item(int index);
    public sealed virtual void set_Item(int index, BitmapEffect value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Effects.BitmapEffect>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(BitmapEffect value);
    public sealed virtual void Clear();
    public BitmapEffectCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public BitmapEffectCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(BitmapEffect value);
    public sealed virtual void CopyTo(BitmapEffect[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(BitmapEffect value);
    public sealed virtual void Insert(int index, BitmapEffect value);
    public sealed virtual bool Remove(BitmapEffect value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<BitmapEffect> System.Collections.Generic.IEnumerable<System.Windows.Media.Effects.BitmapEffect>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Effects.BitmapEffectGroup : BitmapEffect {
    public static DependencyProperty ChildrenProperty;
    public BitmapEffectCollection Children { get; public set; }
    public BitmapEffectCollection get_Children();
    public void set_Children(BitmapEffectCollection value);
    public BitmapEffectGroup Clone();
    public BitmapEffectGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
}
public class System.Windows.Media.Effects.BitmapEffectInput : Animatable {
    public static DependencyProperty AreaToApplyEffectProperty;
    public static DependencyProperty AreaToApplyEffectUnitsProperty;
    public static DependencyProperty InputProperty;
    public Rect AreaToApplyEffect { get; public set; }
    public BrushMappingMode AreaToApplyEffectUnits { get; public set; }
    public static BitmapSource ContextInputSource { get; }
    public BitmapSource Input { get; public set; }
    public BitmapEffectInput(BitmapSource input);
    public Rect get_AreaToApplyEffect();
    public void set_AreaToApplyEffect(Rect value);
    public BrushMappingMode get_AreaToApplyEffectUnits();
    public void set_AreaToApplyEffectUnits(BrushMappingMode value);
    public static BitmapSource get_ContextInputSource();
    public BitmapSource get_Input();
    public void set_Input(BitmapSource value);
    public BitmapEffectInput Clone();
    public BitmapEffectInput CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInput();
}
public class System.Windows.Media.Effects.BlurBitmapEffect : BitmapEffect {
    public static DependencyProperty KernelTypeProperty;
    public static DependencyProperty RadiusProperty;
    public KernelType KernelType { get; public set; }
    public double Radius { get; public set; }
    public KernelType get_KernelType();
    public void set_KernelType(KernelType value);
    public double get_Radius();
    public void set_Radius(double value);
    public BlurBitmapEffect Clone();
    public BlurBitmapEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
}
public class System.Windows.Media.Effects.BlurEffect : Effect {
    public static DependencyProperty KernelTypeProperty;
    public static DependencyProperty RadiusProperty;
    public static DependencyProperty RenderingBiasProperty;
    public KernelType KernelType { get; public set; }
    public double Radius { get; public set; }
    public RenderingBias RenderingBias { get; public set; }
    public KernelType get_KernelType();
    public void set_KernelType(KernelType value);
    public double get_Radius();
    public void set_Radius(double value);
    public RenderingBias get_RenderingBias();
    public void set_RenderingBias(RenderingBias value);
    public BlurEffect Clone();
    public BlurEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.DropShadowBitmapEffect : BitmapEffect {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty NoiseProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty ShadowDepthProperty;
    public static DependencyProperty SoftnessProperty;
    public Color Color { get; public set; }
    public double Direction { get; public set; }
    public double Noise { get; public set; }
    public double Opacity { get; public set; }
    public double ShadowDepth { get; public set; }
    public double Softness { get; public set; }
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Direction();
    public void set_Direction(double value);
    public double get_Noise();
    public void set_Noise(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public double get_ShadowDepth();
    public void set_ShadowDepth(double value);
    public double get_Softness();
    public void set_Softness(double value);
    public DropShadowBitmapEffect Clone();
    public DropShadowBitmapEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
}
public class System.Windows.Media.Effects.DropShadowEffect : Effect {
    public static DependencyProperty BlurRadiusProperty;
    public static DependencyProperty ColorProperty;
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty RenderingBiasProperty;
    public static DependencyProperty ShadowDepthProperty;
    public double BlurRadius { get; public set; }
    public Color Color { get; public set; }
    public double Direction { get; public set; }
    public double Opacity { get; public set; }
    public RenderingBias RenderingBias { get; public set; }
    public double ShadowDepth { get; public set; }
    public double get_BlurRadius();
    public void set_BlurRadius(double value);
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Direction();
    public void set_Direction(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public RenderingBias get_RenderingBias();
    public void set_RenderingBias(RenderingBias value);
    public double get_ShadowDepth();
    public void set_ShadowDepth(double value);
    public DropShadowEffect Clone();
    public DropShadowEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.Effects.EdgeProfile : Enum {
    public int value__;
    public static EdgeProfile Linear;
    public static EdgeProfile CurvedIn;
    public static EdgeProfile CurvedOut;
    public static EdgeProfile BulgedUp;
}
public abstract class System.Windows.Media.Effects.Effect : Animatable {
    protected internal GeneralTransform EffectMapping { get; }
    [BrowsableAttribute("False")]
public static Brush ImplicitInput { get; }
    protected internal virtual GeneralTransform get_EffectMapping();
    public static Brush get_ImplicitInput();
    public Effect Clone();
    public Effect CloneCurrentValue();
}
public class System.Windows.Media.Effects.EmbossBitmapEffect : BitmapEffect {
    public static DependencyProperty LightAngleProperty;
    public static DependencyProperty ReliefProperty;
    public double LightAngle { get; public set; }
    public double Relief { get; public set; }
    public double get_LightAngle();
    public void set_LightAngle(double value);
    public double get_Relief();
    public void set_Relief(double value);
    public EmbossBitmapEffect Clone();
    public EmbossBitmapEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
}
public enum System.Windows.Media.Effects.KernelType : Enum {
    public int value__;
    public static KernelType Gaussian;
    public static KernelType Box;
}
public class System.Windows.Media.Effects.OuterGlowBitmapEffect : BitmapEffect {
    public static DependencyProperty GlowColorProperty;
    public static DependencyProperty GlowSizeProperty;
    public static DependencyProperty NoiseProperty;
    public static DependencyProperty OpacityProperty;
    public Color GlowColor { get; public set; }
    public double GlowSize { get; public set; }
    public double Noise { get; public set; }
    public double Opacity { get; public set; }
    public Color get_GlowColor();
    public void set_GlowColor(Color value);
    public double get_GlowSize();
    public void set_GlowSize(double value);
    public double get_Noise();
    public void set_Noise(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public OuterGlowBitmapEffect Clone();
    public OuterGlowBitmapEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
}
public class System.Windows.Media.Effects.PixelShader : Animatable {
    public static DependencyProperty ShaderRenderModeProperty;
    public static DependencyProperty UriSourceProperty;
    public ShaderRenderMode ShaderRenderMode { get; public set; }
    public Uri UriSource { get; public set; }
    public ShaderRenderMode get_ShaderRenderMode();
    public void set_ShaderRenderMode(ShaderRenderMode value);
    public Uri get_UriSource();
    public void set_UriSource(Uri value);
    public static void add_InvalidPixelShaderEncountered(EventHandler value);
    public static void remove_InvalidPixelShaderEncountered(EventHandler value);
    public PixelShader Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public PixelShader CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public void SetStreamSource(Stream source);
}
public enum System.Windows.Media.Effects.RenderingBias : Enum {
    public int value__;
    public static RenderingBias Performance;
    public static RenderingBias Quality;
}
public enum System.Windows.Media.Effects.SamplingMode : Enum {
    public int value__;
    public static SamplingMode NearestNeighbor;
    public static SamplingMode Bilinear;
    public static SamplingMode Auto;
}
public abstract class System.Windows.Media.Effects.ShaderEffect : Effect {
    protected static DependencyProperty PixelShaderProperty;
    protected int DdxUvDdyUvRegisterIndex { get; protected set; }
    protected double PaddingBottom { get; protected set; }
    protected double PaddingLeft { get; protected set; }
    protected double PaddingRight { get; protected set; }
    protected double PaddingTop { get; protected set; }
    protected PixelShader PixelShader { get; protected set; }
    protected int get_DdxUvDdyUvRegisterIndex();
    protected void set_DdxUvDdyUvRegisterIndex(int value);
    protected double get_PaddingBottom();
    protected void set_PaddingBottom(double value);
    protected double get_PaddingLeft();
    protected void set_PaddingLeft(double value);
    protected double get_PaddingRight();
    protected void set_PaddingRight(double value);
    protected double get_PaddingTop();
    protected void set_PaddingTop(double value);
    protected PixelShader get_PixelShader();
    protected void set_PixelShader(PixelShader value);
    public ShaderEffect Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public ShaderEffect CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected static PropertyChangedCallback PixelShaderConstantCallback(int floatRegisterIndex);
    protected static PropertyChangedCallback PixelShaderSamplerCallback(int samplerRegisterIndex);
    protected static PropertyChangedCallback PixelShaderSamplerCallback(int samplerRegisterIndex, SamplingMode samplingMode);
    protected static DependencyProperty RegisterPixelShaderSamplerProperty(string dpName, Type ownerType, int samplerRegisterIndex);
    protected static DependencyProperty RegisterPixelShaderSamplerProperty(string dpName, Type ownerType, int samplerRegisterIndex, SamplingMode samplingMode);
    protected void UpdateShaderValue(DependencyProperty dp);
}
public enum System.Windows.Media.Effects.ShaderRenderMode : Enum {
    public int value__;
    public static ShaderRenderMode Auto;
    public static ShaderRenderMode SoftwareOnly;
    public static ShaderRenderMode HardwareOnly;
}
public class System.Windows.Media.EllipseGeometry : Geometry {
    public static DependencyProperty CenterProperty;
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public Rect Bounds { get; }
    public Point Center { get; public set; }
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public EllipseGeometry(Point center, double radiusX, double radiusY);
    public EllipseGeometry(Point center, double radiusX, double radiusY, Transform transform);
    public EllipseGeometry(Rect rect);
    public virtual Rect get_Bounds();
    public Point get_Center();
    public void set_Center(Point value);
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public EllipseGeometry Clone();
    public EllipseGeometry CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public virtual double GetArea(double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
}
public class System.Windows.Media.ExceptionEventArgs : EventArgs {
    public Exception ErrorException { get; }
    public Exception get_ErrorException();
}
public class System.Windows.Media.FamilyTypeface : object {
    public IDictionary`2<XmlLanguage, string> AdjustedFaceNames { get; }
    public double CapsHeight { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public CharacterMetricsDictionary DeviceFontCharacterMetrics { get; }
    public string DeviceFontName { get; public set; }
    public FontStretch Stretch { get; public set; }
    public double StrikethroughPosition { get; public set; }
    public double StrikethroughThickness { get; public set; }
    public FontStyle Style { get; public set; }
    public double UnderlinePosition { get; public set; }
    public double UnderlineThickness { get; public set; }
    public FontWeight Weight { get; public set; }
    public double XHeight { get; public set; }
    public IDictionary`2<XmlLanguage, string> get_AdjustedFaceNames();
    public double get_CapsHeight();
    public void set_CapsHeight(double value);
    public CharacterMetricsDictionary get_DeviceFontCharacterMetrics();
    public string get_DeviceFontName();
    public void set_DeviceFontName(string value);
    public FontStretch get_Stretch();
    public void set_Stretch(FontStretch value);
    public double get_StrikethroughPosition();
    public void set_StrikethroughPosition(double value);
    public double get_StrikethroughThickness();
    public void set_StrikethroughThickness(double value);
    public FontStyle get_Style();
    public void set_Style(FontStyle value);
    public double get_UnderlinePosition();
    public void set_UnderlinePosition(double value);
    public double get_UnderlineThickness();
    public void set_UnderlineThickness(double value);
    public FontWeight get_Weight();
    public void set_Weight(FontWeight value);
    public double get_XHeight();
    public void set_XHeight(double value);
    public virtual bool Equals(object o);
    public bool Equals(FamilyTypeface typeface);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.FamilyTypefaceCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public FamilyTypeface Item { get; public set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual FamilyTypeface get_Item(int index);
    public sealed virtual void set_Item(int index, FamilyTypeface value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(FamilyTypeface item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(FamilyTypeface item);
    public sealed virtual void CopyTo(FamilyTypeface[] array, int index);
    public sealed virtual IEnumerator`1<FamilyTypeface> GetEnumerator();
    public sealed virtual int IndexOf(FamilyTypeface item);
    public sealed virtual void Insert(int index, FamilyTypeface item);
    public sealed virtual bool Remove(FamilyTypeface item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public enum System.Windows.Media.FillRule : Enum {
    public int value__;
    public static FillRule EvenOdd;
    public static FillRule Nonzero;
}
public class System.Windows.Media.FontEmbeddingManager : object {
    [CLSCompliantAttribute("False")]
public ICollection`1<Uri> GlyphTypefaceUris { get; }
    public ICollection`1<Uri> get_GlyphTypefaceUris();
    [CLSCompliantAttribute("False")]
public ICollection`1<ushort> GetUsedGlyphs(Uri glyphTypeface);
    public void RecordUsage(GlyphRun glyphRun);
}
public enum System.Windows.Media.FontEmbeddingRight : Enum {
    public int value__;
    public static FontEmbeddingRight Installable;
    public static FontEmbeddingRight InstallableButNoSubsetting;
    public static FontEmbeddingRight InstallableButWithBitmapsOnly;
    public static FontEmbeddingRight InstallableButNoSubsettingAndWithBitmapsOnly;
    public static FontEmbeddingRight RestrictedLicense;
    public static FontEmbeddingRight PreviewAndPrint;
    public static FontEmbeddingRight PreviewAndPrintButNoSubsetting;
    public static FontEmbeddingRight PreviewAndPrintButWithBitmapsOnly;
    public static FontEmbeddingRight PreviewAndPrintButNoSubsettingAndWithBitmapsOnly;
    public static FontEmbeddingRight Editable;
    public static FontEmbeddingRight EditableButNoSubsetting;
    public static FontEmbeddingRight EditableButWithBitmapsOnly;
    public static FontEmbeddingRight EditableButNoSubsettingAndWithBitmapsOnly;
}
[TypeConverterAttribute("System.Windows.Media.FontFamilyConverter")]
[LocalizabilityAttribute("14")]
[ValueSerializerAttribute("System.Windows.Media.FontFamilyValueSerializer")]
public class System.Windows.Media.FontFamily : object {
    public double Baseline { get; public set; }
    public Uri BaseUri { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public FontFamilyMapCollection FamilyMaps { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public LanguageSpecificStringDictionary FamilyNames { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public FamilyTypefaceCollection FamilyTypefaces { get; }
    public double LineSpacing { get; public set; }
    public string Source { get; }
    public FontFamily(string familyName);
    public FontFamily(Uri baseUri, string familyName);
    public double get_Baseline();
    public void set_Baseline(double value);
    public Uri get_BaseUri();
    public FontFamilyMapCollection get_FamilyMaps();
    public LanguageSpecificStringDictionary get_FamilyNames();
    public FamilyTypefaceCollection get_FamilyTypefaces();
    public double get_LineSpacing();
    public void set_LineSpacing(double value);
    public string get_Source();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public ICollection`1<Typeface> GetTypefaces();
    public virtual string ToString();
}
public class System.Windows.Media.FontFamilyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo cultureInfo, object o);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.FontFamilyMap : object {
    public XmlLanguage Language { get; public set; }
    public double Scale { get; public set; }
    [DesignerSerializationOptionsAttribute("1")]
public string Target { get; public set; }
    [DesignerSerializationOptionsAttribute("1")]
public string Unicode { get; public set; }
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
    public double get_Scale();
    public void set_Scale(double value);
    public string get_Target();
    public void set_Target(string value);
    public string get_Unicode();
    public void set_Unicode(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.FontFamilyMapCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public FontFamilyMap Item { get; public set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual FontFamilyMap get_Item(int index);
    public sealed virtual void set_Item(int index, FontFamilyMap value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(FontFamilyMap item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(FontFamilyMap item);
    public sealed virtual void CopyTo(FontFamilyMap[] array, int index);
    public sealed virtual IEnumerator`1<FontFamilyMap> GetEnumerator();
    public sealed virtual int IndexOf(FontFamilyMap item);
    public sealed virtual void Insert(int index, FontFamilyMap item);
    public sealed virtual bool Remove(FontFamilyMap item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public class System.Windows.Media.FontFamilyValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public static class System.Windows.Media.Fonts : object {
    public static ICollection`1<FontFamily> SystemFontFamilies { get; }
    public static ICollection`1<Typeface> SystemTypefaces { get; }
    public static ICollection`1<FontFamily> get_SystemFontFamilies();
    public static ICollection`1<Typeface> get_SystemTypefaces();
    public static ICollection`1<FontFamily> GetFontFamilies(string location);
    public static ICollection`1<FontFamily> GetFontFamilies(Uri baseUri);
    public static ICollection`1<FontFamily> GetFontFamilies(Uri baseUri, string location);
    public static ICollection`1<Typeface> GetTypefaces(string location);
    public static ICollection`1<Typeface> GetTypefaces(Uri baseUri);
    public static ICollection`1<Typeface> GetTypefaces(Uri baseUri, string location);
}
public class System.Windows.Media.FormattedText : object {
    public double Baseline { get; }
    public double Extent { get; }
    public FlowDirection FlowDirection { get; public set; }
    public double Height { get; }
    public double LineHeight { get; public set; }
    public int MaxLineCount { get; public set; }
    public double MaxTextHeight { get; public set; }
    public double MaxTextWidth { get; public set; }
    public double MinWidth { get; }
    public double OverhangAfter { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double PixelsPerDip { get; public set; }
    public string Text { get; }
    public TextAlignment TextAlignment { get; public set; }
    public TextTrimming Trimming { get; public set; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    [ObsoleteAttribute("Use the PixelsPerDip override", "False")]
public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground);
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, double pixelsPerDip);
    [ObsoleteAttribute("Use the PixelsPerDip override", "False")]
public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution);
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution, double pixelsPerDip);
    [ObsoleteAttribute("Use the PixelsPerDip override", "False")]
public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution, TextFormattingMode textFormattingMode);
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution, TextFormattingMode textFormattingMode, double pixelsPerDip);
    public double get_Baseline();
    public double get_Extent();
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public double get_Height();
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public int get_MaxLineCount();
    public void set_MaxLineCount(int value);
    public double get_MaxTextHeight();
    public void set_MaxTextHeight(double value);
    public double get_MaxTextWidth();
    public void set_MaxTextWidth(double value);
    public double get_MinWidth();
    public double get_OverhangAfter();
    public double get_OverhangLeading();
    public double get_OverhangTrailing();
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
    public string get_Text();
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public TextTrimming get_Trimming();
    public void set_Trimming(TextTrimming value);
    public double get_Width();
    public double get_WidthIncludingTrailingWhitespace();
    public Geometry BuildGeometry(Point origin);
    public Geometry BuildHighlightGeometry(Point origin);
    public Geometry BuildHighlightGeometry(Point origin, int startIndex, int count);
    public Double[] GetMaxTextWidths();
    public void SetCulture(CultureInfo culture);
    public void SetCulture(CultureInfo culture, int startIndex, int count);
    public void SetFontFamily(string fontFamily);
    public void SetFontFamily(string fontFamily, int startIndex, int count);
    public void SetFontFamily(FontFamily fontFamily);
    public void SetFontFamily(FontFamily fontFamily, int startIndex, int count);
    public void SetFontSize(double emSize);
    public void SetFontSize(double emSize, int startIndex, int count);
    public void SetFontStretch(FontStretch stretch);
    public void SetFontStretch(FontStretch stretch, int startIndex, int count);
    public void SetFontStyle(FontStyle style);
    public void SetFontStyle(FontStyle style, int startIndex, int count);
    public void SetFontTypeface(Typeface typeface);
    public void SetFontTypeface(Typeface typeface, int startIndex, int count);
    public void SetFontWeight(FontWeight weight);
    public void SetFontWeight(FontWeight weight, int startIndex, int count);
    public void SetForegroundBrush(Brush foregroundBrush);
    public void SetForegroundBrush(Brush foregroundBrush, int startIndex, int count);
    public void SetMaxTextWidths(Double[] maxTextWidths);
    public void SetNumberSubstitution(NumberSubstitution numberSubstitution);
    public void SetNumberSubstitution(NumberSubstitution numberSubstitution, int startIndex, int count);
    public void SetTextDecorations(TextDecorationCollection textDecorations);
    public void SetTextDecorations(TextDecorationCollection textDecorations, int startIndex, int count);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.GeneralTransform : Animatable {
    public GeneralTransform Inverse { get; }
    public abstract virtual GeneralTransform get_Inverse();
    public GeneralTransform Clone();
    public GeneralTransform CloneCurrentValue();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public Point Transform(Point point);
    public abstract virtual Rect TransformBounds(Rect rect);
    public abstract virtual bool TryTransform(Point inPoint, Point& result);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GeneralTransformCollection : Animatable {
    public int Count { get; }
    public GeneralTransform Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.GeneralTransform>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public GeneralTransformCollection(IEnumerable`1<GeneralTransform> collection);
    public GeneralTransformCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual GeneralTransform get_Item(int index);
    public sealed virtual void set_Item(int index, GeneralTransform value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.GeneralTransform>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(GeneralTransform value);
    public sealed virtual void Clear();
    public GeneralTransformCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public GeneralTransformCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(GeneralTransform value);
    public sealed virtual void CopyTo(GeneralTransform[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(GeneralTransform value);
    public sealed virtual void Insert(int index, GeneralTransform value);
    public sealed virtual bool Remove(GeneralTransform value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<GeneralTransform> System.Collections.Generic.IEnumerable<System.Windows.Media.GeneralTransform>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[LocalizabilityAttribute("0")]
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.GeneralTransformGroup : GeneralTransform {
    public static DependencyProperty ChildrenProperty;
    public GeneralTransformCollection Children { get; public set; }
    public GeneralTransform Inverse { get; }
    public GeneralTransformCollection get_Children();
    public void set_Children(GeneralTransformCollection value);
    public virtual GeneralTransform get_Inverse();
    public GeneralTransformGroup Clone();
    public GeneralTransformGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public virtual Rect TransformBounds(Rect rect);
    public virtual bool TryTransform(Point inPoint, Point& result);
}
[TypeConverterAttribute("System.Windows.Media.GeometryConverter")]
[LocalizabilityAttribute("0")]
[ValueSerializerAttribute("System.Windows.Media.Converters.GeometryValueSerializer")]
public abstract class System.Windows.Media.Geometry : Animatable {
    public static DependencyProperty TransformProperty;
    public Rect Bounds { get; }
    public static Geometry Empty { get; }
    public static double StandardFlatteningTolerance { get; }
    public Transform Transform { get; public set; }
    public virtual Rect get_Bounds();
    public static Geometry get_Empty();
    public static double get_StandardFlatteningTolerance();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Geometry Clone();
    public Geometry CloneCurrentValue();
    public static PathGeometry Combine(Geometry geometry1, Geometry geometry2, GeometryCombineMode mode, Transform transform);
    public static PathGeometry Combine(Geometry geometry1, Geometry geometry2, GeometryCombineMode mode, Transform transform, double tolerance, ToleranceType type);
    public bool FillContains(Geometry geometry);
    public bool FillContains(Geometry geometry, double tolerance, ToleranceType type);
    public bool FillContains(Point hitPoint);
    public bool FillContains(Point hitPoint, double tolerance, ToleranceType type);
    public IntersectionDetail FillContainsWithDetail(Geometry geometry);
    public virtual IntersectionDetail FillContainsWithDetail(Geometry geometry, double tolerance, ToleranceType type);
    public double GetArea();
    public virtual double GetArea(double tolerance, ToleranceType type);
    public PathGeometry GetFlattenedPathGeometry();
    public virtual PathGeometry GetFlattenedPathGeometry(double tolerance, ToleranceType type);
    public PathGeometry GetOutlinedPathGeometry();
    public virtual PathGeometry GetOutlinedPathGeometry(double tolerance, ToleranceType type);
    public Rect GetRenderBounds(Pen pen);
    public virtual Rect GetRenderBounds(Pen pen, double tolerance, ToleranceType type);
    public PathGeometry GetWidenedPathGeometry(Pen pen);
    public virtual PathGeometry GetWidenedPathGeometry(Pen pen, double tolerance, ToleranceType type);
    public abstract virtual bool IsEmpty();
    public abstract virtual bool MayHaveCurves();
    public static Geometry Parse(string source);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransform();
    public bool StrokeContains(Pen pen, Point hitPoint);
    public bool StrokeContains(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    public IntersectionDetail StrokeContainsWithDetail(Pen pen, Geometry geometry);
    public IntersectionDetail StrokeContainsWithDetail(Pen pen, Geometry geometry, double tolerance, ToleranceType type);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GeometryCollection : Animatable {
    public int Count { get; }
    public Geometry Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Geometry>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public GeometryCollection(IEnumerable`1<Geometry> collection);
    public GeometryCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual Geometry get_Item(int index);
    public sealed virtual void set_Item(int index, Geometry value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Geometry>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Geometry value);
    public sealed virtual void Clear();
    public GeometryCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public GeometryCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(Geometry value);
    public sealed virtual void CopyTo(Geometry[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Geometry value);
    public sealed virtual void Insert(int index, Geometry value);
    public sealed virtual bool Remove(Geometry value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<Geometry> System.Collections.Generic.IEnumerable<System.Windows.Media.Geometry>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public enum System.Windows.Media.GeometryCombineMode : Enum {
    public int value__;
    public static GeometryCombineMode Union;
    public static GeometryCombineMode Intersect;
    public static GeometryCombineMode Xor;
    public static GeometryCombineMode Exclude;
}
public class System.Windows.Media.GeometryConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.GeometryDrawing : Drawing {
    public static DependencyProperty BrushProperty;
    public static DependencyProperty GeometryProperty;
    public static DependencyProperty PenProperty;
    public Brush Brush { get; public set; }
    public Geometry Geometry { get; public set; }
    public Pen Pen { get; public set; }
    public GeometryDrawing(Brush brush, Pen pen, Geometry geometry);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public Geometry get_Geometry();
    public void set_Geometry(Geometry value);
    public Pen get_Pen();
    public void set_Pen(Pen value);
    public GeometryDrawing Clone();
    public GeometryDrawing CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.GeometryGroup : Geometry {
    public static DependencyProperty ChildrenProperty;
    public static DependencyProperty FillRuleProperty;
    public GeometryCollection Children { get; public set; }
    public FillRule FillRule { get; public set; }
    public GeometryCollection get_Children();
    public void set_Children(GeometryCollection value);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    public GeometryGroup Clone();
    public GeometryGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
}
public class System.Windows.Media.GeometryHitTestParameters : HitTestParameters {
    public Geometry HitGeometry { get; }
    public GeometryHitTestParameters(Geometry geometry);
    public Geometry get_HitGeometry();
}
public class System.Windows.Media.GeometryHitTestResult : HitTestResult {
    public IntersectionDetail IntersectionDetail { get; }
    public Visual VisualHit { get; }
    public GeometryHitTestResult(Visual visualHit, IntersectionDetail intersectionDetail);
    public IntersectionDetail get_IntersectionDetail();
    public Visual get_VisualHit();
}
public class System.Windows.Media.GlyphRun : object {
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.DoubleIListConverter")]
public IList`1<double> AdvanceWidths { get; public set; }
    public Point BaselineOrigin { get; public set; }
    public int BidiLevel { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.BoolIListConverter")]
public IList`1<bool> CaretStops { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.CharIListConverter")]
public IList`1<char> Characters { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.UShortIListConverter")]
public IList`1<ushort> ClusterMap { get; public set; }
    public string DeviceFontName { get; public set; }
    public double FontRenderingEmSize { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.UShortIListConverter")]
public IList`1<ushort> GlyphIndices { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.PointIListConverter")]
public IList`1<Point> GlyphOffsets { get; public set; }
    public GlyphTypeface GlyphTypeface { get; public set; }
    public bool IsHitTestable { get; }
    public bool IsSideways { get; public set; }
    public XmlLanguage Language { get; public set; }
    public float PixelsPerDip { get; public set; }
    public GlyphRun(float pixelsPerDip);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Use the PixelsPerDip override", "False")]
public GlyphRun(GlyphTypeface glyphTypeface, int bidiLevel, bool isSideways, double renderingEmSize, IList`1<ushort> glyphIndices, Point baselineOrigin, IList`1<double> advanceWidths, IList`1<Point> glyphOffsets, IList`1<char> characters, string deviceFontName, IList`1<ushort> clusterMap, IList`1<bool> caretStops, XmlLanguage language);
    [CLSCompliantAttribute("False")]
public GlyphRun(GlyphTypeface glyphTypeface, int bidiLevel, bool isSideways, double renderingEmSize, float pixelsPerDip, IList`1<ushort> glyphIndices, Point baselineOrigin, IList`1<double> advanceWidths, IList`1<Point> glyphOffsets, IList`1<char> characters, string deviceFontName, IList`1<ushort> clusterMap, IList`1<bool> caretStops, XmlLanguage language);
    public IList`1<double> get_AdvanceWidths();
    public void set_AdvanceWidths(IList`1<double> value);
    public Point get_BaselineOrigin();
    public void set_BaselineOrigin(Point value);
    public int get_BidiLevel();
    public void set_BidiLevel(int value);
    public IList`1<bool> get_CaretStops();
    public void set_CaretStops(IList`1<bool> value);
    public IList`1<char> get_Characters();
    public void set_Characters(IList`1<char> value);
    public IList`1<ushort> get_ClusterMap();
    public void set_ClusterMap(IList`1<ushort> value);
    public string get_DeviceFontName();
    public void set_DeviceFontName(string value);
    public double get_FontRenderingEmSize();
    public void set_FontRenderingEmSize(double value);
    public IList`1<ushort> get_GlyphIndices();
    public void set_GlyphIndices(IList`1<ushort> value);
    public IList`1<Point> get_GlyphOffsets();
    public void set_GlyphOffsets(IList`1<Point> value);
    public GlyphTypeface get_GlyphTypeface();
    public void set_GlyphTypeface(GlyphTypeface value);
    public bool get_IsHitTestable();
    public bool get_IsSideways();
    public void set_IsSideways(bool value);
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
    public float get_PixelsPerDip();
    public void set_PixelsPerDip(float value);
    public Geometry BuildGeometry();
    public Rect ComputeAlignmentBox();
    public Rect ComputeInkBoundingBox();
    public CharacterHit GetCaretCharacterHitFromDistance(double distance, Boolean& isInside);
    public double GetDistanceFromCaretCharacterHit(CharacterHit characterHit);
    public CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
public class System.Windows.Media.GlyphRunDrawing : Drawing {
    public static DependencyProperty ForegroundBrushProperty;
    public static DependencyProperty GlyphRunProperty;
    public Brush ForegroundBrush { get; public set; }
    public GlyphRun GlyphRun { get; public set; }
    public GlyphRunDrawing(Brush foregroundBrush, GlyphRun glyphRun);
    public Brush get_ForegroundBrush();
    public void set_ForegroundBrush(Brush value);
    public GlyphRun get_GlyphRun();
    public void set_GlyphRun(GlyphRun value);
    public GlyphRunDrawing Clone();
    public GlyphRunDrawing CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.GlyphTypeface : object {
    public IDictionary`2<ushort, double> AdvanceHeights { get; }
    public IDictionary`2<ushort, double> AdvanceWidths { get; }
    public double Baseline { get; }
    public IDictionary`2<ushort, double> BottomSideBearings { get; }
    public double CapsHeight { get; }
    public IDictionary`2<int, ushort> CharacterToGlyphMap { get; }
    public IDictionary`2<CultureInfo, string> Copyrights { get; }
    public IDictionary`2<CultureInfo, string> Descriptions { get; }
    public IDictionary`2<CultureInfo, string> DesignerNames { get; }
    public IDictionary`2<CultureInfo, string> DesignerUrls { get; }
    public IDictionary`2<ushort, double> DistancesFromHorizontalBaselineToBlackBoxBottom { get; }
    public FontEmbeddingRight EmbeddingRights { get; }
    public IDictionary`2<CultureInfo, string> FaceNames { get; }
    public IDictionary`2<CultureInfo, string> FamilyNames { get; }
    public Uri FontUri { get; public set; }
    public int GlyphCount { get; }
    public double Height { get; }
    public IDictionary`2<ushort, double> LeftSideBearings { get; }
    public IDictionary`2<CultureInfo, string> LicenseDescriptions { get; }
    public IDictionary`2<CultureInfo, string> ManufacturerNames { get; }
    public IDictionary`2<ushort, double> RightSideBearings { get; }
    public IDictionary`2<CultureInfo, string> SampleTexts { get; }
    public FontStretch Stretch { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public FontStyle Style { get; }
    public StyleSimulations StyleSimulations { get; public set; }
    public bool Symbol { get; }
    public IDictionary`2<ushort, double> TopSideBearings { get; }
    public IDictionary`2<CultureInfo, string> Trademarks { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public IDictionary`2<CultureInfo, string> VendorUrls { get; }
    public double Version { get; }
    public IDictionary`2<CultureInfo, string> VersionStrings { get; }
    public FontWeight Weight { get; }
    public IDictionary`2<CultureInfo, string> Win32FaceNames { get; }
    public IDictionary`2<CultureInfo, string> Win32FamilyNames { get; }
    public double XHeight { get; }
    public GlyphTypeface(Uri typefaceSource);
    public GlyphTypeface(Uri typefaceSource, StyleSimulations styleSimulations);
    public IDictionary`2<ushort, double> get_AdvanceHeights();
    public IDictionary`2<ushort, double> get_AdvanceWidths();
    public double get_Baseline();
    public IDictionary`2<ushort, double> get_BottomSideBearings();
    public double get_CapsHeight();
    public IDictionary`2<int, ushort> get_CharacterToGlyphMap();
    public IDictionary`2<CultureInfo, string> get_Copyrights();
    public IDictionary`2<CultureInfo, string> get_Descriptions();
    public IDictionary`2<CultureInfo, string> get_DesignerNames();
    public IDictionary`2<CultureInfo, string> get_DesignerUrls();
    public IDictionary`2<ushort, double> get_DistancesFromHorizontalBaselineToBlackBoxBottom();
    public FontEmbeddingRight get_EmbeddingRights();
    public IDictionary`2<CultureInfo, string> get_FaceNames();
    public IDictionary`2<CultureInfo, string> get_FamilyNames();
    public Uri get_FontUri();
    public void set_FontUri(Uri value);
    public int get_GlyphCount();
    public double get_Height();
    public IDictionary`2<ushort, double> get_LeftSideBearings();
    public IDictionary`2<CultureInfo, string> get_LicenseDescriptions();
    public IDictionary`2<CultureInfo, string> get_ManufacturerNames();
    public IDictionary`2<ushort, double> get_RightSideBearings();
    public IDictionary`2<CultureInfo, string> get_SampleTexts();
    public FontStretch get_Stretch();
    public double get_StrikethroughPosition();
    public double get_StrikethroughThickness();
    public FontStyle get_Style();
    public StyleSimulations get_StyleSimulations();
    public void set_StyleSimulations(StyleSimulations value);
    public bool get_Symbol();
    public IDictionary`2<ushort, double> get_TopSideBearings();
    public IDictionary`2<CultureInfo, string> get_Trademarks();
    public double get_UnderlinePosition();
    public double get_UnderlineThickness();
    public IDictionary`2<CultureInfo, string> get_VendorUrls();
    public double get_Version();
    public IDictionary`2<CultureInfo, string> get_VersionStrings();
    public FontWeight get_Weight();
    public IDictionary`2<CultureInfo, string> get_Win32FaceNames();
    public IDictionary`2<CultureInfo, string> get_Win32FamilyNames();
    public double get_XHeight();
    [CLSCompliantAttribute("False")]
public Byte[] ComputeSubset(ICollection`1<ushort> glyphs);
    public virtual bool Equals(object o);
    public Stream GetFontStream();
    [CLSCompliantAttribute("False")]
public Geometry GetGlyphOutline(ushort glyphIndex, double renderingEmSize, double hintingEmSize);
    public virtual int GetHashCode();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
[ContentPropertyAttribute("GradientStops")]
public abstract class System.Windows.Media.GradientBrush : Brush {
    public static DependencyProperty ColorInterpolationModeProperty;
    public static DependencyProperty GradientStopsProperty;
    public static DependencyProperty MappingModeProperty;
    public static DependencyProperty SpreadMethodProperty;
    public ColorInterpolationMode ColorInterpolationMode { get; public set; }
    public GradientStopCollection GradientStops { get; public set; }
    public BrushMappingMode MappingMode { get; public set; }
    public GradientSpreadMethod SpreadMethod { get; public set; }
    protected GradientBrush(GradientStopCollection gradientStopCollection);
    public ColorInterpolationMode get_ColorInterpolationMode();
    public void set_ColorInterpolationMode(ColorInterpolationMode value);
    public GradientStopCollection get_GradientStops();
    public void set_GradientStops(GradientStopCollection value);
    public BrushMappingMode get_MappingMode();
    public void set_MappingMode(BrushMappingMode value);
    public GradientSpreadMethod get_SpreadMethod();
    public void set_SpreadMethod(GradientSpreadMethod value);
    public GradientBrush Clone();
    public GradientBrush CloneCurrentValue();
}
public enum System.Windows.Media.GradientSpreadMethod : Enum {
    public int value__;
    public static GradientSpreadMethod Pad;
    public static GradientSpreadMethod Reflect;
    public static GradientSpreadMethod Repeat;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.GradientStop : Animatable {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty OffsetProperty;
    public Color Color { get; public set; }
    public double Offset { get; public set; }
    public GradientStop(Color color, double offset);
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Offset();
    public void set_Offset(double value);
    public GradientStop Clone();
    public GradientStop CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GradientStopCollection : Animatable {
    public int Count { get; }
    public GradientStop Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.GradientStop>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public GradientStopCollection(IEnumerable`1<GradientStop> collection);
    public GradientStopCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual GradientStop get_Item(int index);
    public sealed virtual void set_Item(int index, GradientStop value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.GradientStop>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(GradientStop value);
    public sealed virtual void Clear();
    public GradientStopCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public GradientStopCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(GradientStop value);
    public sealed virtual void CopyTo(GradientStop[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(GradientStop value);
    public sealed virtual void Insert(int index, GradientStop value);
    public static GradientStopCollection Parse(string source);
    public sealed virtual bool Remove(GradientStop value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<GradientStop> System.Collections.Generic.IEnumerable<System.Windows.Media.GradientStop>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.GuidelineSet : Animatable {
    public static DependencyProperty GuidelinesXProperty;
    public static DependencyProperty GuidelinesYProperty;
    public DoubleCollection GuidelinesX { get; public set; }
    public DoubleCollection GuidelinesY { get; public set; }
    public GuidelineSet(Double[] guidelinesX, Double[] guidelinesY);
    public DoubleCollection get_GuidelinesX();
    public void set_GuidelinesX(DoubleCollection value);
    public DoubleCollection get_GuidelinesY();
    public void set_GuidelinesY(DoubleCollection value);
    public GuidelineSet Clone();
    public GuidelineSet CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.HitTestFilterBehavior : Enum {
    public int value__;
    public static HitTestFilterBehavior ContinueSkipSelfAndChildren;
    public static HitTestFilterBehavior ContinueSkipChildren;
    public static HitTestFilterBehavior ContinueSkipSelf;
    public static HitTestFilterBehavior Continue;
    public static HitTestFilterBehavior Stop;
}
public class System.Windows.Media.HitTestFilterCallback : MulticastDelegate {
    public HitTestFilterCallback(object object, IntPtr method);
    public virtual HitTestFilterBehavior Invoke(DependencyObject potentialHitTestTarget);
    public virtual IAsyncResult BeginInvoke(DependencyObject potentialHitTestTarget, AsyncCallback callback, object object);
    public virtual HitTestFilterBehavior EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Media.HitTestParameters : object {
}
public abstract class System.Windows.Media.HitTestResult : object {
    public DependencyObject VisualHit { get; }
    public DependencyObject get_VisualHit();
}
public enum System.Windows.Media.HitTestResultBehavior : Enum {
    public int value__;
    public static HitTestResultBehavior Stop;
    public static HitTestResultBehavior Continue;
}
public class System.Windows.Media.HitTestResultCallback : MulticastDelegate {
    public HitTestResultCallback(object object, IntPtr method);
    public virtual HitTestResultBehavior Invoke(HitTestResult result);
    public virtual IAsyncResult BeginInvoke(HitTestResult result, AsyncCallback callback, object object);
    public virtual HitTestResultBehavior EndInvoke(IAsyncResult result);
}
public class System.Windows.Media.HostVisual : ContainerVisual {
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
}
public class System.Windows.Media.ImageBrush : TileBrush {
    public static DependencyProperty ImageSourceProperty;
    public ImageSource ImageSource { get; public set; }
    public ImageBrush(ImageSource image);
    public ImageSource get_ImageSource();
    public void set_ImageSource(ImageSource value);
    public ImageBrush Clone();
    public ImageBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetContentBounds(Rect& contentBounds);
}
public class System.Windows.Media.ImageDrawing : Drawing {
    public static DependencyProperty ImageSourceProperty;
    public static DependencyProperty RectProperty;
    public ImageSource ImageSource { get; public set; }
    public Rect Rect { get; public set; }
    public ImageDrawing(ImageSource imageSource, Rect rect);
    public ImageSource get_ImageSource();
    public void set_ImageSource(ImageSource value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    public ImageDrawing Clone();
    public ImageDrawing CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.ImageMetadata : Freezable {
    public ImageMetadata Clone();
}
[TypeConverterAttribute("System.Windows.Media.ImageSourceConverter")]
[LocalizabilityAttribute("0")]
[ValueSerializerAttribute("System.Windows.Media.ImageSourceValueSerializer")]
public abstract class System.Windows.Media.ImageSource : Animatable {
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    public double Width { get; }
    public abstract virtual double get_Height();
    public abstract virtual ImageMetadata get_Metadata();
    public abstract virtual double get_Width();
    public ImageSource Clone();
    public ImageSource CloneCurrentValue();
    protected static double PixelsToDIPs(double dpi, int pixels);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.ImageSourceConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.ImageSourceValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public enum System.Windows.Media.Imaging.BitmapCacheOption : Enum {
    public int value__;
    public static BitmapCacheOption Default;
    public static BitmapCacheOption OnDemand;
    public static BitmapCacheOption OnLoad;
    public static BitmapCacheOption None;
}
public abstract class System.Windows.Media.Imaging.BitmapCodecInfo : object {
    public string Author { get; }
    public Guid ContainerFormat { get; }
    public string DeviceManufacturer { get; }
    public string DeviceModels { get; }
    public string FileExtensions { get; }
    public string FriendlyName { get; }
    public string MimeTypes { get; }
    public Version SpecificationVersion { get; }
    public bool SupportsAnimation { get; }
    public bool SupportsLossless { get; }
    public bool SupportsMultipleFrames { get; }
    public Version Version { get; }
    public virtual string get_Author();
    public virtual Guid get_ContainerFormat();
    public virtual string get_DeviceManufacturer();
    public virtual string get_DeviceModels();
    public virtual string get_FileExtensions();
    public virtual string get_FriendlyName();
    public virtual string get_MimeTypes();
    public virtual Version get_SpecificationVersion();
    public virtual bool get_SupportsAnimation();
    public virtual bool get_SupportsLossless();
    public virtual bool get_SupportsMultipleFrames();
    public virtual Version get_Version();
}
[FlagsAttribute]
public enum System.Windows.Media.Imaging.BitmapCreateOptions : Enum {
    public int value__;
    public static BitmapCreateOptions None;
    public static BitmapCreateOptions PreservePixelFormat;
    public static BitmapCreateOptions DelayCreation;
    public static BitmapCreateOptions IgnoreColorProfile;
    public static BitmapCreateOptions IgnoreImageCache;
}
public abstract class System.Windows.Media.Imaging.BitmapDecoder : DispatcherObject {
    public BitmapCodecInfo CodecInfo { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public ReadOnlyCollection`1<BitmapFrame> Frames { get; }
    public bool IsDownloading { get; }
    public BitmapMetadata Metadata { get; }
    public BitmapPalette Palette { get; }
    public BitmapSource Preview { get; }
    public BitmapSource Thumbnail { get; }
    public virtual BitmapCodecInfo get_CodecInfo();
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public virtual ReadOnlyCollection`1<BitmapFrame> get_Frames();
    public virtual bool get_IsDownloading();
    public virtual BitmapMetadata get_Metadata();
    public virtual BitmapPalette get_Palette();
    public virtual BitmapSource get_Preview();
    public virtual BitmapSource get_Thumbnail();
    public virtual void add_DownloadCompleted(EventHandler value);
    public virtual void remove_DownloadCompleted(EventHandler value);
    public virtual void add_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void remove_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void add_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    public virtual void remove_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    public static BitmapDecoder Create(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapDecoder Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapDecoder Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy);
    public virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
    protected virtual override void Finalize();
    public virtual string ToString();
}
public abstract class System.Windows.Media.Imaging.BitmapEncoder : DispatcherObject {
    public BitmapCodecInfo CodecInfo { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; public set; }
    public IList`1<BitmapFrame> Frames { get; public set; }
    public BitmapMetadata Metadata { get; public set; }
    public BitmapPalette Palette { get; public set; }
    public BitmapSource Preview { get; public set; }
    public BitmapSource Thumbnail { get; public set; }
    public virtual BitmapCodecInfo get_CodecInfo();
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public virtual void set_ColorContexts(ReadOnlyCollection`1<ColorContext> value);
    public virtual IList`1<BitmapFrame> get_Frames();
    public virtual void set_Frames(IList`1<BitmapFrame> value);
    public virtual BitmapMetadata get_Metadata();
    public virtual void set_Metadata(BitmapMetadata value);
    public virtual BitmapPalette get_Palette();
    public virtual void set_Palette(BitmapPalette value);
    public virtual BitmapSource get_Preview();
    public virtual void set_Preview(BitmapSource value);
    public virtual BitmapSource get_Thumbnail();
    public virtual void set_Thumbnail(BitmapSource value);
    public static BitmapEncoder Create(Guid containerFormat);
    public virtual void Save(Stream stream);
}
public abstract class System.Windows.Media.Imaging.BitmapFrame : BitmapSource {
    public Uri BaseUri { get; public set; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public BitmapDecoder Decoder { get; }
    public BitmapSource Thumbnail { get; }
    public abstract virtual Uri get_BaseUri();
    public abstract virtual void set_BaseUri(Uri value);
    public abstract virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public abstract virtual BitmapDecoder get_Decoder();
    public abstract virtual BitmapSource get_Thumbnail();
    public static BitmapFrame Create(Stream bitmapStream);
    public static BitmapFrame Create(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapFrame Create(Uri bitmapUri);
    public static BitmapFrame Create(Uri bitmapUri, RequestCachePolicy uriCachePolicy);
    public static BitmapFrame Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapFrame Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy);
    public static BitmapFrame Create(BitmapSource source);
    public static BitmapFrame Create(BitmapSource source, BitmapSource thumbnail);
    public static BitmapFrame Create(BitmapSource source, BitmapSource thumbnail, BitmapMetadata metadata, ReadOnlyCollection`1<ColorContext> colorContexts);
    public abstract virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
}
public class System.Windows.Media.Imaging.BitmapImage : BitmapSource {
    public static DependencyProperty CacheOptionProperty;
    public static DependencyProperty CreateOptionsProperty;
    public static DependencyProperty DecodePixelHeightProperty;
    public static DependencyProperty DecodePixelWidthProperty;
    public static DependencyProperty RotationProperty;
    public static DependencyProperty SourceRectProperty;
    public static DependencyProperty StreamSourceProperty;
    public static DependencyProperty UriCachePolicyProperty;
    public static DependencyProperty UriSourceProperty;
    public Uri BaseUri { get; public set; }
    public BitmapCacheOption CacheOption { get; public set; }
    public BitmapCreateOptions CreateOptions { get; public set; }
    public int DecodePixelHeight { get; public set; }
    public int DecodePixelWidth { get; public set; }
    public bool IsDownloading { get; }
    public ImageMetadata Metadata { get; }
    public Rotation Rotation { get; public set; }
    public Int32Rect SourceRect { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public Stream StreamSource { get; public set; }
    [TypeConverterAttribute("System.Windows.Media.RequestCachePolicyConverter")]
public RequestCachePolicy UriCachePolicy { get; public set; }
    public Uri UriSource { get; public set; }
    public BitmapImage(Uri uriSource);
    public BitmapImage(Uri uriSource, RequestCachePolicy uriCachePolicy);
    public sealed virtual Uri get_BaseUri();
    public sealed virtual void set_BaseUri(Uri value);
    public BitmapCacheOption get_CacheOption();
    public void set_CacheOption(BitmapCacheOption value);
    public BitmapCreateOptions get_CreateOptions();
    public void set_CreateOptions(BitmapCreateOptions value);
    public int get_DecodePixelHeight();
    public void set_DecodePixelHeight(int value);
    public int get_DecodePixelWidth();
    public void set_DecodePixelWidth(int value);
    public virtual bool get_IsDownloading();
    public virtual ImageMetadata get_Metadata();
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
    public Int32Rect get_SourceRect();
    public void set_SourceRect(Int32Rect value);
    public Stream get_StreamSource();
    public void set_StreamSource(Stream value);
    public RequestCachePolicy get_UriCachePolicy();
    public void set_UriCachePolicy(RequestCachePolicy value);
    public Uri get_UriSource();
    public void set_UriSource(Uri value);
    public sealed virtual void BeginInit();
    public BitmapImage Clone();
    protected virtual void CloneCore(Freezable source);
    public BitmapImage CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual Freezable CreateInstanceCore();
    public sealed virtual void EndInit();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.BitmapMetadata : ImageMetadata {
    public string ApplicationName { get; public set; }
    public ReadOnlyCollection`1<string> Author { get; public set; }
    public string CameraManufacturer { get; public set; }
    public string CameraModel { get; public set; }
    public string Comment { get; public set; }
    public string Copyright { get; public set; }
    public string DateTaken { get; public set; }
    public string Format { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ReadOnlyCollection`1<string> Keywords { get; public set; }
    public string Location { get; }
    public int Rating { get; public set; }
    public string Subject { get; public set; }
    public string Title { get; public set; }
    public BitmapMetadata(string containerFormat);
    public string get_ApplicationName();
    public void set_ApplicationName(string value);
    public ReadOnlyCollection`1<string> get_Author();
    public void set_Author(ReadOnlyCollection`1<string> value);
    public string get_CameraManufacturer();
    public void set_CameraManufacturer(string value);
    public string get_CameraModel();
    public void set_CameraModel(string value);
    public string get_Comment();
    public void set_Comment(string value);
    public string get_Copyright();
    public void set_Copyright(string value);
    public string get_DateTaken();
    public void set_DateTaken(string value);
    public string get_Format();
    public bool get_IsFixedSize();
    public bool get_IsReadOnly();
    public ReadOnlyCollection`1<string> get_Keywords();
    public void set_Keywords(ReadOnlyCollection`1<string> value);
    public string get_Location();
    public int get_Rating();
    public void set_Rating(int value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_Title();
    public void set_Title(string value);
    public BitmapMetadata Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public bool ContainsQuery(string query);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public object GetQuery(string query);
    public void RemoveQuery(string query);
    public void SetQuery(string query, object value);
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Media.Imaging.BitmapMetadataBlob : object {
    public BitmapMetadataBlob(Byte[] blob);
    public Byte[] GetBlobValue();
}
public class System.Windows.Media.Imaging.BitmapPalette : DispatcherObject {
    public IList`1<Color> Colors { get; }
    public BitmapPalette(IList`1<Color> colors);
    public BitmapPalette(BitmapSource bitmapSource, int maxColorCount);
    public IList`1<Color> get_Colors();
}
public static class System.Windows.Media.Imaging.BitmapPalettes : object {
    public static BitmapPalette BlackAndWhite { get; }
    public static BitmapPalette BlackAndWhiteTransparent { get; }
    public static BitmapPalette Gray16 { get; }
    public static BitmapPalette Gray16Transparent { get; }
    public static BitmapPalette Gray256 { get; }
    public static BitmapPalette Gray256Transparent { get; }
    public static BitmapPalette Gray4 { get; }
    public static BitmapPalette Gray4Transparent { get; }
    public static BitmapPalette Halftone125 { get; }
    public static BitmapPalette Halftone125Transparent { get; }
    public static BitmapPalette Halftone216 { get; }
    public static BitmapPalette Halftone216Transparent { get; }
    public static BitmapPalette Halftone252 { get; }
    public static BitmapPalette Halftone252Transparent { get; }
    public static BitmapPalette Halftone256 { get; }
    public static BitmapPalette Halftone256Transparent { get; }
    public static BitmapPalette Halftone27 { get; }
    public static BitmapPalette Halftone27Transparent { get; }
    public static BitmapPalette Halftone64 { get; }
    public static BitmapPalette Halftone64Transparent { get; }
    public static BitmapPalette Halftone8 { get; }
    public static BitmapPalette Halftone8Transparent { get; }
    public static BitmapPalette WebPalette { get; }
    public static BitmapPalette WebPaletteTransparent { get; }
    public static BitmapPalette get_BlackAndWhite();
    public static BitmapPalette get_BlackAndWhiteTransparent();
    public static BitmapPalette get_Gray16();
    public static BitmapPalette get_Gray16Transparent();
    public static BitmapPalette get_Gray256();
    public static BitmapPalette get_Gray256Transparent();
    public static BitmapPalette get_Gray4();
    public static BitmapPalette get_Gray4Transparent();
    public static BitmapPalette get_Halftone125();
    public static BitmapPalette get_Halftone125Transparent();
    public static BitmapPalette get_Halftone216();
    public static BitmapPalette get_Halftone216Transparent();
    public static BitmapPalette get_Halftone252();
    public static BitmapPalette get_Halftone252Transparent();
    public static BitmapPalette get_Halftone256();
    public static BitmapPalette get_Halftone256Transparent();
    public static BitmapPalette get_Halftone27();
    public static BitmapPalette get_Halftone27Transparent();
    public static BitmapPalette get_Halftone64();
    public static BitmapPalette get_Halftone64Transparent();
    public static BitmapPalette get_Halftone8();
    public static BitmapPalette get_Halftone8Transparent();
    public static BitmapPalette get_WebPalette();
    public static BitmapPalette get_WebPaletteTransparent();
}
public class System.Windows.Media.Imaging.BitmapSizeOptions : object {
    public int PixelHeight { get; }
    public int PixelWidth { get; }
    public bool PreservesAspectRatio { get; }
    public Rotation Rotation { get; }
    public int get_PixelHeight();
    public int get_PixelWidth();
    public bool get_PreservesAspectRatio();
    public Rotation get_Rotation();
    public static BitmapSizeOptions FromEmptyOptions();
    public static BitmapSizeOptions FromHeight(int pixelHeight);
    public static BitmapSizeOptions FromRotation(Rotation rotation);
    public static BitmapSizeOptions FromWidth(int pixelWidth);
    public static BitmapSizeOptions FromWidthAndHeight(int pixelWidth, int pixelHeight);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Imaging.BitmapSource : ImageSource {
    public double DpiX { get; }
    public double DpiY { get; }
    public PixelFormat Format { get; }
    public double Height { get; }
    public bool IsDownloading { get; }
    public ImageMetadata Metadata { get; }
    public BitmapPalette Palette { get; }
    public int PixelHeight { get; }
    public int PixelWidth { get; }
    public double Width { get; }
    public virtual double get_DpiX();
    public virtual double get_DpiY();
    public virtual PixelFormat get_Format();
    public virtual double get_Height();
    public virtual bool get_IsDownloading();
    public virtual ImageMetadata get_Metadata();
    public virtual BitmapPalette get_Palette();
    public virtual int get_PixelHeight();
    public virtual int get_PixelWidth();
    public virtual double get_Width();
    public virtual void add_DecodeFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void remove_DecodeFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void add_DownloadCompleted(EventHandler value);
    public virtual void remove_DownloadCompleted(EventHandler value);
    public virtual void add_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void remove_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void add_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    public virtual void remove_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    protected void CheckIfSiteOfOrigin();
    public BitmapSource Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public BitmapSource CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public virtual void CopyPixels(Array pixels, int stride, int offset);
    public virtual void CopyPixels(Int32Rect sourceRect, Array pixels, int stride, int offset);
    public virtual void CopyPixels(Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);
    public static BitmapSource Create(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, Array pixels, int stride);
    public static BitmapSource Create(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, IntPtr buffer, int bufferSize, int stride);
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
public class System.Windows.Media.Imaging.BmpBitmapDecoder : BitmapDecoder {
    public BmpBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public BmpBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.BmpBitmapEncoder : BitmapEncoder {
}
public class System.Windows.Media.Imaging.CachedBitmap : BitmapSource {
    public CachedBitmap(BitmapSource source, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public CachedBitmap Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public CachedBitmap CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
public class System.Windows.Media.Imaging.ColorConvertedBitmap : BitmapSource {
    public static DependencyProperty DestinationColorContextProperty;
    public static DependencyProperty DestinationFormatProperty;
    public static DependencyProperty SourceColorContextProperty;
    public static DependencyProperty SourceProperty;
    public ColorContext DestinationColorContext { get; public set; }
    public PixelFormat DestinationFormat { get; public set; }
    public BitmapSource Source { get; public set; }
    public ColorContext SourceColorContext { get; public set; }
    public ColorConvertedBitmap(BitmapSource source, ColorContext sourceColorContext, ColorContext destinationColorContext, PixelFormat format);
    public ColorContext get_DestinationColorContext();
    public void set_DestinationColorContext(ColorContext value);
    public PixelFormat get_DestinationFormat();
    public void set_DestinationFormat(PixelFormat value);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public ColorContext get_SourceColorContext();
    public void set_SourceColorContext(ColorContext value);
    public sealed virtual void BeginInit();
    public ColorConvertedBitmap Clone();
    protected virtual void CloneCore(Freezable source);
    public ColorConvertedBitmap CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual Freezable CreateInstanceCore();
    public sealed virtual void EndInit();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.CroppedBitmap : BitmapSource {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty SourceRectProperty;
    public BitmapSource Source { get; public set; }
    public Int32Rect SourceRect { get; public set; }
    public CroppedBitmap(BitmapSource source, Int32Rect sourceRect);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public Int32Rect get_SourceRect();
    public void set_SourceRect(Int32Rect value);
    public sealed virtual void BeginInit();
    public CroppedBitmap Clone();
    protected virtual void CloneCore(Freezable source);
    public CroppedBitmap CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual Freezable CreateInstanceCore();
    public sealed virtual void EndInit();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.DownloadProgressEventArgs : EventArgs {
    public int Progress { get; }
    public int get_Progress();
}
public class System.Windows.Media.Imaging.FormatConvertedBitmap : BitmapSource {
    public static DependencyProperty AlphaThresholdProperty;
    public static DependencyProperty DestinationFormatProperty;
    public static DependencyProperty DestinationPaletteProperty;
    public static DependencyProperty SourceProperty;
    public double AlphaThreshold { get; public set; }
    public PixelFormat DestinationFormat { get; public set; }
    public BitmapPalette DestinationPalette { get; public set; }
    public BitmapSource Source { get; public set; }
    public FormatConvertedBitmap(BitmapSource source, PixelFormat destinationFormat, BitmapPalette destinationPalette, double alphaThreshold);
    public double get_AlphaThreshold();
    public void set_AlphaThreshold(double value);
    public PixelFormat get_DestinationFormat();
    public void set_DestinationFormat(PixelFormat value);
    public BitmapPalette get_DestinationPalette();
    public void set_DestinationPalette(BitmapPalette value);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public sealed virtual void BeginInit();
    public FormatConvertedBitmap Clone();
    protected virtual void CloneCore(Freezable source);
    public FormatConvertedBitmap CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual Freezable CreateInstanceCore();
    public sealed virtual void EndInit();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.GifBitmapDecoder : BitmapDecoder {
    public GifBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public GifBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.GifBitmapEncoder : BitmapEncoder {
}
public class System.Windows.Media.Imaging.IconBitmapDecoder : BitmapDecoder {
    public IconBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public IconBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.InPlaceBitmapMetadataWriter : BitmapMetadata {
    public InPlaceBitmapMetadataWriter Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public bool TrySave();
}
public class System.Windows.Media.Imaging.JpegBitmapDecoder : BitmapDecoder {
    public JpegBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public JpegBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.JpegBitmapEncoder : BitmapEncoder {
    public bool FlipHorizontal { get; public set; }
    public bool FlipVertical { get; public set; }
    public int QualityLevel { get; public set; }
    public Rotation Rotation { get; public set; }
    public bool get_FlipHorizontal();
    public void set_FlipHorizontal(bool value);
    public bool get_FlipVertical();
    public void set_FlipVertical(bool value);
    public int get_QualityLevel();
    public void set_QualityLevel(int value);
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
}
public class System.Windows.Media.Imaging.LateBoundBitmapDecoder : BitmapDecoder {
    public BitmapCodecInfo CodecInfo { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public BitmapDecoder Decoder { get; }
    public ReadOnlyCollection`1<BitmapFrame> Frames { get; }
    public bool IsDownloading { get; }
    public BitmapPalette Palette { get; }
    public BitmapSource Preview { get; }
    public BitmapSource Thumbnail { get; }
    public virtual BitmapCodecInfo get_CodecInfo();
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public BitmapDecoder get_Decoder();
    public virtual ReadOnlyCollection`1<BitmapFrame> get_Frames();
    public virtual bool get_IsDownloading();
    public virtual BitmapPalette get_Palette();
    public virtual BitmapSource get_Preview();
    public virtual BitmapSource get_Thumbnail();
}
public class System.Windows.Media.Imaging.PngBitmapDecoder : BitmapDecoder {
    public PngBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public PngBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.PngBitmapEncoder : BitmapEncoder {
    public PngInterlaceOption Interlace { get; public set; }
    public PngInterlaceOption get_Interlace();
    public void set_Interlace(PngInterlaceOption value);
}
public enum System.Windows.Media.Imaging.PngInterlaceOption : Enum {
    public int value__;
    public static PngInterlaceOption Default;
    public static PngInterlaceOption On;
    public static PngInterlaceOption Off;
}
public class System.Windows.Media.Imaging.RenderTargetBitmap : BitmapSource {
    public RenderTargetBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat);
    public void Clear();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public void Render(Visual visual);
}
public enum System.Windows.Media.Imaging.Rotation : Enum {
    public int value__;
    public static Rotation Rotate0;
    public static Rotation Rotate90;
    public static Rotation Rotate180;
    public static Rotation Rotate270;
}
public class System.Windows.Media.Imaging.TiffBitmapDecoder : BitmapDecoder {
    public TiffBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public TiffBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.TiffBitmapEncoder : BitmapEncoder {
    public TiffCompressOption Compression { get; public set; }
    public TiffCompressOption get_Compression();
    public void set_Compression(TiffCompressOption value);
}
public enum System.Windows.Media.Imaging.TiffCompressOption : Enum {
    public int value__;
    public static TiffCompressOption Default;
    public static TiffCompressOption None;
    public static TiffCompressOption Ccitt3;
    public static TiffCompressOption Ccitt4;
    public static TiffCompressOption Lzw;
    public static TiffCompressOption Rle;
    public static TiffCompressOption Zip;
}
public class System.Windows.Media.Imaging.TransformedBitmap : BitmapSource {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty TransformProperty;
    public BitmapSource Source { get; public set; }
    public Transform Transform { get; public set; }
    public TransformedBitmap(BitmapSource source, Transform newTransform);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public sealed virtual void BeginInit();
    public TransformedBitmap Clone();
    protected virtual void CloneCore(Freezable source);
    public TransformedBitmap CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual Freezable CreateInstanceCore();
    public sealed virtual void EndInit();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.WmpBitmapDecoder : BitmapDecoder {
    public WmpBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public WmpBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.WmpBitmapEncoder : BitmapEncoder {
    public byte AlphaDataDiscardLevel { get; public set; }
    public byte AlphaQualityLevel { get; public set; }
    public bool CompressedDomainTranscode { get; public set; }
    public bool FlipHorizontal { get; public set; }
    public bool FlipVertical { get; public set; }
    public bool FrequencyOrder { get; public set; }
    public short HorizontalTileSlices { get; public set; }
    public bool IgnoreOverlap { get; public set; }
    public byte ImageDataDiscardLevel { get; public set; }
    public float ImageQualityLevel { get; public set; }
    public bool InterleavedAlpha { get; public set; }
    public bool Lossless { get; public set; }
    public byte OverlapLevel { get; public set; }
    public byte QualityLevel { get; public set; }
    public Rotation Rotation { get; public set; }
    public byte SubsamplingLevel { get; public set; }
    public bool UseCodecOptions { get; public set; }
    public short VerticalTileSlices { get; public set; }
    public byte get_AlphaDataDiscardLevel();
    public void set_AlphaDataDiscardLevel(byte value);
    public byte get_AlphaQualityLevel();
    public void set_AlphaQualityLevel(byte value);
    public bool get_CompressedDomainTranscode();
    public void set_CompressedDomainTranscode(bool value);
    public bool get_FlipHorizontal();
    public void set_FlipHorizontal(bool value);
    public bool get_FlipVertical();
    public void set_FlipVertical(bool value);
    public bool get_FrequencyOrder();
    public void set_FrequencyOrder(bool value);
    public short get_HorizontalTileSlices();
    public void set_HorizontalTileSlices(short value);
    public bool get_IgnoreOverlap();
    public void set_IgnoreOverlap(bool value);
    public byte get_ImageDataDiscardLevel();
    public void set_ImageDataDiscardLevel(byte value);
    public float get_ImageQualityLevel();
    public void set_ImageQualityLevel(float value);
    public bool get_InterleavedAlpha();
    public void set_InterleavedAlpha(bool value);
    public bool get_Lossless();
    public void set_Lossless(bool value);
    public byte get_OverlapLevel();
    public void set_OverlapLevel(byte value);
    public byte get_QualityLevel();
    public void set_QualityLevel(byte value);
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
    public byte get_SubsamplingLevel();
    public void set_SubsamplingLevel(byte value);
    public bool get_UseCodecOptions();
    public void set_UseCodecOptions(bool value);
    public short get_VerticalTileSlices();
    public void set_VerticalTileSlices(short value);
}
public class System.Windows.Media.Imaging.WriteableBitmap : BitmapSource {
    public IntPtr BackBuffer { get; }
    public int BackBufferStride { get; }
    public WriteableBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette);
    public WriteableBitmap(BitmapSource source);
    public IntPtr get_BackBuffer();
    public int get_BackBufferStride();
    public void AddDirtyRect(Int32Rect dirtyRect);
    public WriteableBitmap Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public WriteableBitmap CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public void Lock();
    public bool TryLock(Duration timeout);
    public void Unlock();
    public void WritePixels(Int32Rect sourceRect, Array pixels, int stride, int offset);
    public void WritePixels(Int32Rect sourceRect, Array sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);
    public void WritePixels(Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);
    public void WritePixels(Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.Int32CollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.Int32CollectionValueSerializer")]
public class System.Windows.Media.Int32Collection : Freezable {
    public int Count { get; }
    public int Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Int32>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Int32Collection(IEnumerable`1<int> collection);
    public Int32Collection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual int get_Item(int index);
    public sealed virtual void set_Item(int index, int value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Int32>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(int value);
    public sealed virtual void Clear();
    public Int32Collection Clone();
    protected virtual void CloneCore(Freezable source);
    public Int32Collection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(int value);
    public sealed virtual void CopyTo(Int32[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(int value);
    public sealed virtual void Insert(int index, int value);
    public static Int32Collection Parse(string source);
    public sealed virtual bool Remove(int value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<int> System.Collections.Generic.IEnumerable<System.Int32>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.Int32CollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.IntersectionDetail : Enum {
    public int value__;
    public static IntersectionDetail NotCalculated;
    public static IntersectionDetail Empty;
    public static IntersectionDetail FullyInside;
    public static IntersectionDetail FullyContains;
    public static IntersectionDetail Intersects;
}
public class System.Windows.Media.InvalidWmpVersionException : SystemException {
    protected InvalidWmpVersionException(SerializationInfo info, StreamingContext context);
    public InvalidWmpVersionException(string message);
    public InvalidWmpVersionException(string message, Exception innerException);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.LanguageSpecificStringDictionary : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public string Item { get; public set; }
    [CLSCompliantAttribute("False")]
public ICollection`1<XmlLanguage> Keys { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [CLSCompliantAttribute("False")]
public ICollection`1<string> Values { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual string get_Item(XmlLanguage key);
    public sealed virtual void set_Item(XmlLanguage key, string value);
    public sealed virtual ICollection`1<XmlLanguage> get_Keys();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual ICollection`1<string> get_Values();
    [CLSCompliantAttribute("False")]
public sealed virtual void Add(KeyValuePair`2<XmlLanguage, string> item);
    public sealed virtual void Add(XmlLanguage key, string value);
    public sealed virtual void Clear();
    [CLSCompliantAttribute("False")]
public sealed virtual bool Contains(KeyValuePair`2<XmlLanguage, string> item);
    public sealed virtual bool ContainsKey(XmlLanguage key);
    [CLSCompliantAttribute("False")]
public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    [CLSCompliantAttribute("False")]
public sealed virtual IEnumerator`1<KeyValuePair`2<XmlLanguage, string>> GetEnumerator();
    [CLSCompliantAttribute("False")]
public sealed virtual bool Remove(KeyValuePair`2<XmlLanguage, string> item);
    public sealed virtual bool Remove(XmlLanguage key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryGetValue(XmlLanguage key, String& value);
}
public class System.Windows.Media.LinearGradientBrush : GradientBrush {
    public static DependencyProperty EndPointProperty;
    public static DependencyProperty StartPointProperty;
    public Point EndPoint { get; public set; }
    public Point StartPoint { get; public set; }
    public LinearGradientBrush(Color startColor, Color endColor, double angle);
    public LinearGradientBrush(Color startColor, Color endColor, Point startPoint, Point endPoint);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection, double angle);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection, Point startPoint, Point endPoint);
    public Point get_EndPoint();
    public void set_EndPoint(Point value);
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public LinearGradientBrush Clone();
    public LinearGradientBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.LineGeometry : Geometry {
    public static DependencyProperty EndPointProperty;
    public static DependencyProperty StartPointProperty;
    public Rect Bounds { get; }
    public Point EndPoint { get; public set; }
    public Point StartPoint { get; public set; }
    public LineGeometry(Point startPoint, Point endPoint);
    public LineGeometry(Point startPoint, Point endPoint, Transform transform);
    public virtual Rect get_Bounds();
    public Point get_EndPoint();
    public void set_EndPoint(Point value);
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public LineGeometry Clone();
    public LineGeometry CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public virtual double GetArea(double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
}
public class System.Windows.Media.LineSegment : PathSegment {
    public static DependencyProperty PointProperty;
    public Point Point { get; public set; }
    public LineSegment(Point point, bool isStroked);
    public Point get_Point();
    public void set_Point(Point value);
    public LineSegment Clone();
    public LineSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.MatrixTransform : Transform {
    public static DependencyProperty MatrixProperty;
    public Matrix Matrix { get; public set; }
    public Matrix Value { get; }
    public MatrixTransform(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    public MatrixTransform(Matrix matrix);
    public Matrix get_Matrix();
    public void set_Matrix(Matrix value);
    public virtual Matrix get_Value();
    public MatrixTransform Clone();
    public MatrixTransform CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Media3D.AffineTransform3D : Transform3D {
    public bool IsAffine { get; }
    public virtual bool get_IsAffine();
    public AffineTransform3D Clone();
    public AffineTransform3D CloneCurrentValue();
}
public class System.Windows.Media.Media3D.AmbientLight : Light {
    public AmbientLight(Color ambientColor);
    public AmbientLight Clone();
    public AmbientLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.AxisAngleRotation3D : Rotation3D {
    public static DependencyProperty AngleProperty;
    public static DependencyProperty AxisProperty;
    public double Angle { get; public set; }
    public Vector3D Axis { get; public set; }
    public AxisAngleRotation3D(Vector3D axis, double angle);
    public double get_Angle();
    public void set_Angle(double value);
    public Vector3D get_Axis();
    public void set_Axis(Vector3D value);
    public AxisAngleRotation3D Clone();
    public AxisAngleRotation3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Media3D.Camera : Animatable {
    public static DependencyProperty TransformProperty;
    public Transform3D Transform { get; public set; }
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    public Camera Clone();
    public Camera CloneCurrentValue();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.ContainerUIElement3D : UIElement3D {
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    protected int Visual3DChildrenCount { get; }
    public Visual3DCollection get_Children();
    protected virtual int get_Visual3DChildrenCount();
    protected virtual Visual3D GetVisual3DChild(int index);
    protected virtual AutomationPeer OnCreateAutomationPeer();
}
public class System.Windows.Media.Media3D.Converters.Matrix3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point3DCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point4DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.QuaternionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Rect3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Size3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Vector3DCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Vector3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.DiffuseMaterial : Material {
    public static DependencyProperty AmbientColorProperty;
    public static DependencyProperty BrushProperty;
    public static DependencyProperty ColorProperty;
    public Color AmbientColor { get; public set; }
    public Brush Brush { get; public set; }
    public Color Color { get; public set; }
    public DiffuseMaterial(Brush brush);
    public Color get_AmbientColor();
    public void set_AmbientColor(Color value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public Color get_Color();
    public void set_Color(Color value);
    public DiffuseMaterial Clone();
    public DiffuseMaterial CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.DirectionalLight : Light {
    public static DependencyProperty DirectionProperty;
    public Vector3D Direction { get; public set; }
    public DirectionalLight(Color diffuseColor, Vector3D direction);
    public Vector3D get_Direction();
    public void set_Direction(Vector3D value);
    public DirectionalLight Clone();
    public DirectionalLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.EmissiveMaterial : Material {
    public static DependencyProperty BrushProperty;
    public static DependencyProperty ColorProperty;
    public Brush Brush { get; public set; }
    public Color Color { get; public set; }
    public EmissiveMaterial(Brush brush);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public Color get_Color();
    public void set_Color(Color value);
    public EmissiveMaterial Clone();
    public EmissiveMaterial CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.GeneralTransform2DTo3D : Freezable {
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public Point3D Transform(Point point);
    public bool TryTransform(Point inPoint, Point3D& result);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.GeneralTransform3D : Animatable {
    public GeneralTransform3D Inverse { get; }
    public abstract virtual GeneralTransform3D get_Inverse();
    public GeneralTransform3D Clone();
    public GeneralTransform3D CloneCurrentValue();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public Point3D Transform(Point3D point);
    public abstract virtual Rect3D TransformBounds(Rect3D rect);
    public abstract virtual bool TryTransform(Point3D inPoint, Point3D& result);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.GeneralTransform3DCollection : Animatable {
    public int Count { get; }
    public GeneralTransform3D Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.GeneralTransform3D>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public GeneralTransform3DCollection(IEnumerable`1<GeneralTransform3D> collection);
    public GeneralTransform3DCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual GeneralTransform3D get_Item(int index);
    public sealed virtual void set_Item(int index, GeneralTransform3D value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.GeneralTransform3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(GeneralTransform3D value);
    public sealed virtual void Clear();
    public GeneralTransform3DCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public GeneralTransform3DCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(GeneralTransform3D value);
    public sealed virtual void CopyTo(GeneralTransform3D[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(GeneralTransform3D value);
    public sealed virtual void Insert(int index, GeneralTransform3D value);
    public sealed virtual bool Remove(GeneralTransform3D value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<GeneralTransform3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.GeneralTransform3D>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[LocalizabilityAttribute("0")]
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.GeneralTransform3DGroup : GeneralTransform3D {
    public static DependencyProperty ChildrenProperty;
    public GeneralTransform3DCollection Children { get; public set; }
    public GeneralTransform3D Inverse { get; }
    public GeneralTransform3DCollection get_Children();
    public void set_Children(GeneralTransform3DCollection value);
    public virtual GeneralTransform3D get_Inverse();
    public GeneralTransform3DGroup Clone();
    public GeneralTransform3DGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public virtual Rect3D TransformBounds(Rect3D rect);
    public virtual bool TryTransform(Point3D inPoint, Point3D& result);
}
public class System.Windows.Media.Media3D.GeneralTransform3DTo2D : Freezable {
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public Point Transform(Point3D point);
    public Rect TransformBounds(Rect3D rect3D);
    public bool TryTransform(Point3D inPoint, Point& result);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Geometry3D : Animatable {
    public Rect3D Bounds { get; }
    public abstract virtual Rect3D get_Bounds();
    public Geometry3D Clone();
    public Geometry3D CloneCurrentValue();
}
public class System.Windows.Media.Media3D.GeometryModel3D : Model3D {
    public static DependencyProperty BackMaterialProperty;
    public static DependencyProperty GeometryProperty;
    public static DependencyProperty MaterialProperty;
    public Material BackMaterial { get; public set; }
    public Geometry3D Geometry { get; public set; }
    public Material Material { get; public set; }
    public GeometryModel3D(Geometry3D geometry, Material material);
    public Material get_BackMaterial();
    public void set_BackMaterial(Material value);
    public Geometry3D get_Geometry();
    public void set_Geometry(Geometry3D value);
    public Material get_Material();
    public void set_Material(Material value);
    public GeometryModel3D Clone();
    public GeometryModel3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Media3D.HitTestParameters3D : object {
}
public abstract class System.Windows.Media.Media3D.Light : Model3D {
    public static DependencyProperty ColorProperty;
    public Color Color { get; public set; }
    public Color get_Color();
    public void set_Color(Color value);
    public Light Clone();
    public Light CloneCurrentValue();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Material : Animatable {
    public Material Clone();
    public Material CloneCurrentValue();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.MaterialCollection : Animatable {
    public int Count { get; }
    public Material Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Material>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public MaterialCollection(IEnumerable`1<Material> collection);
    public MaterialCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual Material get_Item(int index);
    public sealed virtual void set_Item(int index, Material value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Material>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Material value);
    public sealed virtual void Clear();
    public MaterialCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public MaterialCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(Material value);
    public sealed virtual void CopyTo(Material[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Material value);
    public sealed virtual void Insert(int index, Material value);
    public sealed virtual bool Remove(Material value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<Material> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Material>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.MaterialGroup : Material {
    public static DependencyProperty ChildrenProperty;
    public MaterialCollection Children { get; public set; }
    public MaterialCollection get_Children();
    public void set_Children(MaterialCollection value);
    public MaterialGroup Clone();
    public MaterialGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Matrix3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Matrix3DValueSerializer")]
public class System.Windows.Media.Media3D.Matrix3D : ValueType {
    public double Determinant { get; }
    public bool HasInverse { get; }
    public static Matrix3D Identity { get; }
    public bool IsAffine { get; }
    public bool IsIdentity { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M13 { get; public set; }
    public double M14 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double M23 { get; public set; }
    public double M24 { get; public set; }
    public double M31 { get; public set; }
    public double M32 { get; public set; }
    public double M33 { get; public set; }
    public double M34 { get; public set; }
    public double M44 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public double OffsetZ { get; public set; }
    public Matrix3D(double m11, double m12, double m13, double m14, double m21, double m22, double m23, double m24, double m31, double m32, double m33, double m34, double offsetX, double offsetY, double offsetZ, double m44);
    public double get_Determinant();
    public bool get_HasInverse();
    public static Matrix3D get_Identity();
    public bool get_IsAffine();
    public bool get_IsIdentity();
    public double get_M11();
    public void set_M11(double value);
    public double get_M12();
    public void set_M12(double value);
    public double get_M13();
    public void set_M13(double value);
    public double get_M14();
    public void set_M14(double value);
    public double get_M21();
    public void set_M21(double value);
    public double get_M22();
    public void set_M22(double value);
    public double get_M23();
    public void set_M23(double value);
    public double get_M24();
    public void set_M24(double value);
    public double get_M31();
    public void set_M31(double value);
    public double get_M32();
    public void set_M32(double value);
    public double get_M33();
    public void set_M33(double value);
    public double get_M34();
    public void set_M34(double value);
    public double get_M44();
    public void set_M44(double value);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    public double get_OffsetZ();
    public void set_OffsetZ(double value);
    public void Append(Matrix3D matrix);
    public virtual bool Equals(object o);
    public bool Equals(Matrix3D value);
    public static bool Equals(Matrix3D matrix1, Matrix3D matrix2);
    public virtual int GetHashCode();
    public void Invert();
    public static Matrix3D Multiply(Matrix3D matrix1, Matrix3D matrix2);
    public static bool op_Equality(Matrix3D matrix1, Matrix3D matrix2);
    public static bool op_Inequality(Matrix3D matrix1, Matrix3D matrix2);
    public static Matrix3D op_Multiply(Matrix3D matrix1, Matrix3D matrix2);
    public static Matrix3D Parse(string source);
    public void Prepend(Matrix3D matrix);
    public void Rotate(Quaternion quaternion);
    public void RotateAt(Quaternion quaternion, Point3D center);
    public void RotateAtPrepend(Quaternion quaternion, Point3D center);
    public void RotatePrepend(Quaternion quaternion);
    public void Scale(Vector3D scale);
    public void ScaleAt(Vector3D scale, Point3D center);
    public void ScaleAtPrepend(Vector3D scale, Point3D center);
    public void ScalePrepend(Vector3D scale);
    public void SetIdentity();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public Point3D Transform(Point3D point);
    public void Transform(Point3D[] points);
    public Point4D Transform(Point4D point);
    public void Transform(Point4D[] points);
    public Vector3D Transform(Vector3D vector);
    public void Transform(Vector3D[] vectors);
    public void Translate(Vector3D offset);
    public void TranslatePrepend(Vector3D offset);
}
public class System.Windows.Media.Media3D.Matrix3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.MatrixCamera : Camera {
    public static DependencyProperty ProjectionMatrixProperty;
    public static DependencyProperty ViewMatrixProperty;
    public Matrix3D ProjectionMatrix { get; public set; }
    public Matrix3D ViewMatrix { get; public set; }
    public MatrixCamera(Matrix3D viewMatrix, Matrix3D projectionMatrix);
    public Matrix3D get_ProjectionMatrix();
    public void set_ProjectionMatrix(Matrix3D value);
    public Matrix3D get_ViewMatrix();
    public void set_ViewMatrix(Matrix3D value);
    public MatrixCamera Clone();
    public MatrixCamera CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.MatrixTransform3D : Transform3D {
    public static DependencyProperty MatrixProperty;
    public bool IsAffine { get; }
    public Matrix3D Matrix { get; public set; }
    public Matrix3D Value { get; }
    public MatrixTransform3D(Matrix3D matrix);
    public virtual bool get_IsAffine();
    public Matrix3D get_Matrix();
    public void set_Matrix(Matrix3D value);
    public virtual Matrix3D get_Value();
    public MatrixTransform3D Clone();
    public MatrixTransform3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.MeshGeometry3D : Geometry3D {
    public static DependencyProperty NormalsProperty;
    public static DependencyProperty PositionsProperty;
    public static DependencyProperty TextureCoordinatesProperty;
    public static DependencyProperty TriangleIndicesProperty;
    public Rect3D Bounds { get; }
    public Vector3DCollection Normals { get; public set; }
    public Point3DCollection Positions { get; public set; }
    public PointCollection TextureCoordinates { get; public set; }
    public Int32Collection TriangleIndices { get; public set; }
    public virtual Rect3D get_Bounds();
    public Vector3DCollection get_Normals();
    public void set_Normals(Vector3DCollection value);
    public Point3DCollection get_Positions();
    public void set_Positions(Point3DCollection value);
    public PointCollection get_TextureCoordinates();
    public void set_TextureCoordinates(PointCollection value);
    public Int32Collection get_TriangleIndices();
    public void set_TriangleIndices(Int32Collection value);
    public MeshGeometry3D Clone();
    public MeshGeometry3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Model3D : Animatable {
    public static DependencyProperty TransformProperty;
    public Rect3D Bounds { get; }
    public Transform3D Transform { get; public set; }
    public Rect3D get_Bounds();
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    public Model3D Clone();
    public Model3D CloneCurrentValue();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Model3DCollection : Animatable {
    public int Count { get; }
    public Model3D Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Model3D>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Model3DCollection(IEnumerable`1<Model3D> collection);
    public Model3DCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual Model3D get_Item(int index);
    public sealed virtual void set_Item(int index, Model3D value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Model3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Model3D value);
    public sealed virtual void Clear();
    public Model3DCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public Model3DCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(Model3D value);
    public sealed virtual void CopyTo(Model3D[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Model3D value);
    public sealed virtual void Insert(int index, Model3D value);
    public sealed virtual bool Remove(Model3D value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<Model3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Model3D>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Model3DGroup : Model3D {
    public static DependencyProperty ChildrenProperty;
    public Model3DCollection Children { get; public set; }
    public Model3DCollection get_Children();
    public void set_Children(Model3DCollection value);
    public Model3DGroup Clone();
    public Model3DGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[ContentPropertyAttribute("Model")]
public class System.Windows.Media.Media3D.ModelUIElement3D : UIElement3D {
    public static DependencyProperty ModelProperty;
    public Model3D Model { get; public set; }
    public Model3D get_Model();
    public void set_Model(Model3D value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.ModelVisual3D : Visual3D {
    public static DependencyProperty ContentProperty;
    public static DependencyProperty TransformProperty;
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    public Model3D Content { get; public set; }
    public Transform3D Transform { get; public set; }
    protected int Visual3DChildrenCount { get; }
    public Visual3DCollection get_Children();
    public Model3D get_Content();
    public void set_Content(Model3D value);
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    protected sealed virtual int get_Visual3DChildrenCount();
    protected sealed virtual Visual3D GetVisual3DChild(int index);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
}
public class System.Windows.Media.Media3D.OrthographicCamera : ProjectionCamera {
    public static DependencyProperty WidthProperty;
    public double Width { get; public set; }
    public OrthographicCamera(Point3D position, Vector3D lookDirection, Vector3D upDirection, double width);
    public double get_Width();
    public void set_Width(double value);
    public OrthographicCamera Clone();
    public OrthographicCamera CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.PerspectiveCamera : ProjectionCamera {
    public static DependencyProperty FieldOfViewProperty;
    public double FieldOfView { get; public set; }
    public PerspectiveCamera(Point3D position, Vector3D lookDirection, Vector3D upDirection, double fieldOfView);
    public double get_FieldOfView();
    public void set_FieldOfView(double value);
    public PerspectiveCamera Clone();
    public PerspectiveCamera CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Point3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point3DValueSerializer")]
public class System.Windows.Media.Media3D.Point3D : ValueType {
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Point3D(double x, double y, double z);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public static Point3D Add(Point3D point, Vector3D vector);
    public virtual bool Equals(object o);
    public bool Equals(Point3D value);
    public static bool Equals(Point3D point1, Point3D point2);
    public virtual int GetHashCode();
    public static Point3D Multiply(Point3D point, Matrix3D matrix);
    public void Offset(double offsetX, double offsetY, double offsetZ);
    public static Point3D op_Addition(Point3D point, Vector3D vector);
    public static bool op_Equality(Point3D point1, Point3D point2);
    public static Point4D op_Explicit(Point3D point);
    public static Vector3D op_Explicit(Point3D point);
    public static bool op_Inequality(Point3D point1, Point3D point2);
    public static Point3D op_Multiply(Point3D point, Matrix3D matrix);
    public static Vector3D op_Subtraction(Point3D point1, Point3D point2);
    public static Point3D op_Subtraction(Point3D point, Vector3D vector);
    public static Point3D Parse(string source);
    public static Vector3D Subtract(Point3D point1, Point3D point2);
    public static Point3D Subtract(Point3D point, Vector3D vector);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Point3DCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point3DCollectionValueSerializer")]
public class System.Windows.Media.Media3D.Point3DCollection : Freezable {
    public int Count { get; }
    public Point3D Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Point3D>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Point3DCollection(IEnumerable`1<Point3D> collection);
    public Point3DCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual Point3D get_Item(int index);
    public sealed virtual void set_Item(int index, Point3D value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Point3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Point3D value);
    public sealed virtual void Clear();
    public Point3DCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public Point3DCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(Point3D value);
    public sealed virtual void CopyTo(Point3D[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Point3D value);
    public sealed virtual void Insert(int index, Point3D value);
    public static Point3DCollection Parse(string source);
    public sealed virtual bool Remove(Point3D value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<Point3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Point3D>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Point3DCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.Point3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Point4DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point4DValueSerializer")]
public class System.Windows.Media.Media3D.Point4D : ValueType {
    public double W { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Point4D(double x, double y, double z, double w);
    public double get_W();
    public void set_W(double value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public static Point4D Add(Point4D point1, Point4D point2);
    public virtual bool Equals(object o);
    public bool Equals(Point4D value);
    public static bool Equals(Point4D point1, Point4D point2);
    public virtual int GetHashCode();
    public static Point4D Multiply(Point4D point, Matrix3D matrix);
    public void Offset(double deltaX, double deltaY, double deltaZ, double deltaW);
    public static Point4D op_Addition(Point4D point1, Point4D point2);
    public static bool op_Equality(Point4D point1, Point4D point2);
    public static bool op_Inequality(Point4D point1, Point4D point2);
    public static Point4D op_Multiply(Point4D point, Matrix3D matrix);
    public static Point4D op_Subtraction(Point4D point1, Point4D point2);
    public static Point4D Parse(string source);
    public static Point4D Subtract(Point4D point1, Point4D point2);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Point4DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.PointLight : PointLightBase {
    public PointLight(Color diffuseColor, Point3D position);
    public PointLight Clone();
    public PointLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Media3D.PointLightBase : Light {
    public static DependencyProperty ConstantAttenuationProperty;
    public static DependencyProperty LinearAttenuationProperty;
    public static DependencyProperty PositionProperty;
    public static DependencyProperty QuadraticAttenuationProperty;
    public static DependencyProperty RangeProperty;
    public double ConstantAttenuation { get; public set; }
    public double LinearAttenuation { get; public set; }
    public Point3D Position { get; public set; }
    public double QuadraticAttenuation { get; public set; }
    public double Range { get; public set; }
    public double get_ConstantAttenuation();
    public void set_ConstantAttenuation(double value);
    public double get_LinearAttenuation();
    public void set_LinearAttenuation(double value);
    public Point3D get_Position();
    public void set_Position(Point3D value);
    public double get_QuadraticAttenuation();
    public void set_QuadraticAttenuation(double value);
    public double get_Range();
    public void set_Range(double value);
    public PointLightBase Clone();
    public PointLightBase CloneCurrentValue();
}
public abstract class System.Windows.Media.Media3D.ProjectionCamera : Camera {
    public static DependencyProperty FarPlaneDistanceProperty;
    public static DependencyProperty LookDirectionProperty;
    public static DependencyProperty NearPlaneDistanceProperty;
    public static DependencyProperty PositionProperty;
    public static DependencyProperty UpDirectionProperty;
    public double FarPlaneDistance { get; public set; }
    public Vector3D LookDirection { get; public set; }
    public double NearPlaneDistance { get; public set; }
    public Point3D Position { get; public set; }
    public Vector3D UpDirection { get; public set; }
    public double get_FarPlaneDistance();
    public void set_FarPlaneDistance(double value);
    public Vector3D get_LookDirection();
    public void set_LookDirection(Vector3D value);
    public double get_NearPlaneDistance();
    public void set_NearPlaneDistance(double value);
    public Point3D get_Position();
    public void set_Position(Point3D value);
    public Vector3D get_UpDirection();
    public void set_UpDirection(Vector3D value);
    public ProjectionCamera Clone();
    public ProjectionCamera CloneCurrentValue();
}
[TypeConverterAttribute("System.Windows.Media.Media3D.QuaternionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.QuaternionValueSerializer")]
public class System.Windows.Media.Media3D.Quaternion : ValueType {
    public double Angle { get; }
    public Vector3D Axis { get; }
    public static Quaternion Identity { get; }
    public bool IsIdentity { get; }
    public bool IsNormalized { get; }
    public double W { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Quaternion(double x, double y, double z, double w);
    public Quaternion(Vector3D axisOfRotation, double angleInDegrees);
    public double get_Angle();
    public Vector3D get_Axis();
    public static Quaternion get_Identity();
    public bool get_IsIdentity();
    public bool get_IsNormalized();
    public double get_W();
    public void set_W(double value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public static Quaternion Add(Quaternion left, Quaternion right);
    public void Conjugate();
    public virtual bool Equals(object o);
    public bool Equals(Quaternion value);
    public static bool Equals(Quaternion quaternion1, Quaternion quaternion2);
    public virtual int GetHashCode();
    public void Invert();
    public static Quaternion Multiply(Quaternion left, Quaternion right);
    public void Normalize();
    public static Quaternion op_Addition(Quaternion left, Quaternion right);
    public static bool op_Equality(Quaternion quaternion1, Quaternion quaternion2);
    public static bool op_Inequality(Quaternion quaternion1, Quaternion quaternion2);
    public static Quaternion op_Multiply(Quaternion left, Quaternion right);
    public static Quaternion op_Subtraction(Quaternion left, Quaternion right);
    public static Quaternion Parse(string source);
    public static Quaternion Slerp(Quaternion from, Quaternion to, double t);
    public static Quaternion Slerp(Quaternion from, Quaternion to, double t, bool useShortestPath);
    public static Quaternion Subtract(Quaternion left, Quaternion right);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.Media3D.QuaternionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.QuaternionRotation3D : Rotation3D {
    public static DependencyProperty QuaternionProperty;
    public Quaternion Quaternion { get; public set; }
    public QuaternionRotation3D(Quaternion quaternion);
    public Quaternion get_Quaternion();
    public void set_Quaternion(Quaternion value);
    public QuaternionRotation3D Clone();
    public QuaternionRotation3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.RayHitTestParameters : HitTestParameters3D {
    public Vector3D Direction { get; }
    public Point3D Origin { get; }
    public RayHitTestParameters(Point3D origin, Vector3D direction);
    public Vector3D get_Direction();
    public Point3D get_Origin();
}
public abstract class System.Windows.Media.Media3D.RayHitTestResult : HitTestResult {
    public double DistanceToRayOrigin { get; }
    public Model3D ModelHit { get; }
    public Point3D PointHit { get; }
    public Visual3D VisualHit { get; }
    public abstract virtual double get_DistanceToRayOrigin();
    public Model3D get_ModelHit();
    public abstract virtual Point3D get_PointHit();
    public Visual3D get_VisualHit();
}
public class System.Windows.Media.Media3D.RayMeshGeometry3DHitTestResult : RayHitTestResult {
    public double DistanceToRayOrigin { get; }
    public MeshGeometry3D MeshHit { get; }
    public Point3D PointHit { get; }
    public int VertexIndex1 { get; }
    public int VertexIndex2 { get; }
    public int VertexIndex3 { get; }
    public double VertexWeight1 { get; }
    public double VertexWeight2 { get; }
    public double VertexWeight3 { get; }
    public virtual double get_DistanceToRayOrigin();
    public MeshGeometry3D get_MeshHit();
    public virtual Point3D get_PointHit();
    public int get_VertexIndex1();
    public int get_VertexIndex2();
    public int get_VertexIndex3();
    public double get_VertexWeight1();
    public double get_VertexWeight2();
    public double get_VertexWeight3();
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Rect3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Rect3DValueSerializer")]
public class System.Windows.Media.Media3D.Rect3D : ValueType {
    public static Rect3D Empty { get; }
    public bool IsEmpty { get; }
    public Point3D Location { get; public set; }
    public Size3D Size { get; public set; }
    public double SizeX { get; public set; }
    public double SizeY { get; public set; }
    public double SizeZ { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Rect3D(double x, double y, double z, double sizeX, double sizeY, double sizeZ);
    public Rect3D(Point3D location, Size3D size);
    public static Rect3D get_Empty();
    public bool get_IsEmpty();
    public Point3D get_Location();
    public void set_Location(Point3D value);
    public Size3D get_Size();
    public void set_Size(Size3D value);
    public double get_SizeX();
    public void set_SizeX(double value);
    public double get_SizeY();
    public void set_SizeY(double value);
    public double get_SizeZ();
    public void set_SizeZ(double value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public bool Contains(double x, double y, double z);
    public bool Contains(Point3D point);
    public bool Contains(Rect3D rect);
    public virtual bool Equals(object o);
    public bool Equals(Rect3D value);
    public static bool Equals(Rect3D rect1, Rect3D rect2);
    public virtual int GetHashCode();
    public void Intersect(Rect3D rect);
    public static Rect3D Intersect(Rect3D rect1, Rect3D rect2);
    public bool IntersectsWith(Rect3D rect);
    public void Offset(double offsetX, double offsetY, double offsetZ);
    public static Rect3D Offset(Rect3D rect, double offsetX, double offsetY, double offsetZ);
    public static Rect3D Offset(Rect3D rect, Vector3D offsetVector);
    public void Offset(Vector3D offsetVector);
    public static bool op_Equality(Rect3D rect1, Rect3D rect2);
    public static bool op_Inequality(Rect3D rect1, Rect3D rect2);
    public static Rect3D Parse(string source);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public void Union(Point3D point);
    public void Union(Rect3D rect);
    public static Rect3D Union(Rect3D rect, Point3D point);
    public static Rect3D Union(Rect3D rect1, Rect3D rect2);
}
public class System.Windows.Media.Media3D.Rect3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.RotateTransform3D : AffineTransform3D {
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public static DependencyProperty CenterZProperty;
    public static DependencyProperty RotationProperty;
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double CenterZ { get; public set; }
    public Rotation3D Rotation { get; public set; }
    public Matrix3D Value { get; }
    public RotateTransform3D(Rotation3D rotation);
    public RotateTransform3D(Rotation3D rotation, double centerX, double centerY, double centerZ);
    public RotateTransform3D(Rotation3D rotation, Point3D center);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_CenterZ();
    public void set_CenterZ(double value);
    public Rotation3D get_Rotation();
    public void set_Rotation(Rotation3D value);
    public virtual Matrix3D get_Value();
    public RotateTransform3D Clone();
    public RotateTransform3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Media3D.Rotation3D : Animatable {
    public static Rotation3D Identity { get; }
    public static Rotation3D get_Identity();
    public Rotation3D Clone();
    public Rotation3D CloneCurrentValue();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.Media3D.ScaleTransform3D : AffineTransform3D {
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public static DependencyProperty CenterZProperty;
    public static DependencyProperty ScaleXProperty;
    public static DependencyProperty ScaleYProperty;
    public static DependencyProperty ScaleZProperty;
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double CenterZ { get; public set; }
    public double ScaleX { get; public set; }
    public double ScaleY { get; public set; }
    public double ScaleZ { get; public set; }
    public Matrix3D Value { get; }
    public ScaleTransform3D(double scaleX, double scaleY, double scaleZ);
    public ScaleTransform3D(double scaleX, double scaleY, double scaleZ, double centerX, double centerY, double centerZ);
    public ScaleTransform3D(Vector3D scale);
    public ScaleTransform3D(Vector3D scale, Point3D center);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_CenterZ();
    public void set_CenterZ(double value);
    public double get_ScaleX();
    public void set_ScaleX(double value);
    public double get_ScaleY();
    public void set_ScaleY(double value);
    public double get_ScaleZ();
    public void set_ScaleZ(double value);
    public virtual Matrix3D get_Value();
    public ScaleTransform3D Clone();
    public ScaleTransform3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Size3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Size3DValueSerializer")]
public class System.Windows.Media.Media3D.Size3D : ValueType {
    public static Size3D Empty { get; }
    public bool IsEmpty { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Size3D(double x, double y, double z);
    public static Size3D get_Empty();
    public bool get_IsEmpty();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public virtual bool Equals(object o);
    public bool Equals(Size3D value);
    public static bool Equals(Size3D size1, Size3D size2);
    public virtual int GetHashCode();
    public static bool op_Equality(Size3D size1, Size3D size2);
    public static Point3D op_Explicit(Size3D size);
    public static Vector3D op_Explicit(Size3D size);
    public static bool op_Inequality(Size3D size1, Size3D size2);
    public static Size3D Parse(string source);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Size3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.SpecularMaterial : Material {
    public static DependencyProperty BrushProperty;
    public static DependencyProperty ColorProperty;
    public static DependencyProperty SpecularPowerProperty;
    public Brush Brush { get; public set; }
    public Color Color { get; public set; }
    public double SpecularPower { get; public set; }
    public SpecularMaterial(Brush brush, double specularPower);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public Color get_Color();
    public void set_Color(Color value);
    public double get_SpecularPower();
    public void set_SpecularPower(double value);
    public SpecularMaterial Clone();
    public SpecularMaterial CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.SpotLight : PointLightBase {
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty InnerConeAngleProperty;
    public static DependencyProperty OuterConeAngleProperty;
    public Vector3D Direction { get; public set; }
    public double InnerConeAngle { get; public set; }
    public double OuterConeAngle { get; public set; }
    public SpotLight(Color diffuseColor, Point3D position, Vector3D direction, double outerConeAngle, double innerConeAngle);
    public Vector3D get_Direction();
    public void set_Direction(Vector3D value);
    public double get_InnerConeAngle();
    public void set_InnerConeAngle(double value);
    public double get_OuterConeAngle();
    public void set_OuterConeAngle(double value);
    public SpotLight Clone();
    public SpotLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Transform3D : GeneralTransform3D {
    public static Transform3D Identity { get; }
    public GeneralTransform3D Inverse { get; }
    public bool IsAffine { get; }
    public Matrix3D Value { get; }
    public static Transform3D get_Identity();
    public virtual GeneralTransform3D get_Inverse();
    public abstract virtual bool get_IsAffine();
    public abstract virtual Matrix3D get_Value();
    public Transform3D Clone();
    public Transform3D CloneCurrentValue();
    public Point3D Transform(Point3D point);
    public void Transform(Point3D[] points);
    public Point4D Transform(Point4D point);
    public void Transform(Point4D[] points);
    public Vector3D Transform(Vector3D vector);
    public void Transform(Vector3D[] vectors);
    public virtual Rect3D TransformBounds(Rect3D rect);
    public virtual bool TryTransform(Point3D inPoint, Point3D& result);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Transform3DCollection : Animatable {
    public int Count { get; }
    public Transform3D Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Transform3D>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Transform3DCollection(IEnumerable`1<Transform3D> collection);
    public Transform3DCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual Transform3D get_Item(int index);
    public sealed virtual void set_Item(int index, Transform3D value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Transform3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Transform3D value);
    public sealed virtual void Clear();
    public Transform3DCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public Transform3DCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(Transform3D value);
    public sealed virtual void CopyTo(Transform3D[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Transform3D value);
    public sealed virtual void Insert(int index, Transform3D value);
    public sealed virtual bool Remove(Transform3D value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<Transform3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Transform3D>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Transform3DGroup : Transform3D {
    public static DependencyProperty ChildrenProperty;
    public Transform3DCollection Children { get; public set; }
    public bool IsAffine { get; }
    public Matrix3D Value { get; }
    public Transform3DCollection get_Children();
    public void set_Children(Transform3DCollection value);
    public virtual bool get_IsAffine();
    public virtual Matrix3D get_Value();
    public Transform3DGroup Clone();
    public Transform3DGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.TranslateTransform3D : AffineTransform3D {
    public static DependencyProperty OffsetXProperty;
    public static DependencyProperty OffsetYProperty;
    public static DependencyProperty OffsetZProperty;
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public double OffsetZ { get; public set; }
    public Matrix3D Value { get; }
    public TranslateTransform3D(double offsetX, double offsetY, double offsetZ);
    public TranslateTransform3D(Vector3D offset);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    public double get_OffsetZ();
    public void set_OffsetZ(double value);
    public virtual Matrix3D get_Value();
    public TranslateTransform3D Clone();
    public TranslateTransform3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Vector3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Vector3DValueSerializer")]
public class System.Windows.Media.Media3D.Vector3D : ValueType {
    public double Length { get; }
    public double LengthSquared { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Vector3D(double x, double y, double z);
    public double get_Length();
    public double get_LengthSquared();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public static Point3D Add(Vector3D vector, Point3D point);
    public static Vector3D Add(Vector3D vector1, Vector3D vector2);
    public static double AngleBetween(Vector3D vector1, Vector3D vector2);
    public static Vector3D CrossProduct(Vector3D vector1, Vector3D vector2);
    public static Vector3D Divide(Vector3D vector, double scalar);
    public static double DotProduct(Vector3D vector1, Vector3D vector2);
    public virtual bool Equals(object o);
    public bool Equals(Vector3D value);
    public static bool Equals(Vector3D vector1, Vector3D vector2);
    public virtual int GetHashCode();
    public static Vector3D Multiply(double scalar, Vector3D vector);
    public static Vector3D Multiply(Vector3D vector, double scalar);
    public static Vector3D Multiply(Vector3D vector, Matrix3D matrix);
    public void Negate();
    public void Normalize();
    public static Point3D op_Addition(Vector3D vector, Point3D point);
    public static Vector3D op_Addition(Vector3D vector1, Vector3D vector2);
    public static Vector3D op_Division(Vector3D vector, double scalar);
    public static bool op_Equality(Vector3D vector1, Vector3D vector2);
    public static Point3D op_Explicit(Vector3D vector);
    public static Size3D op_Explicit(Vector3D vector);
    public static bool op_Inequality(Vector3D vector1, Vector3D vector2);
    public static Vector3D op_Multiply(double scalar, Vector3D vector);
    public static Vector3D op_Multiply(Vector3D vector, double scalar);
    public static Vector3D op_Multiply(Vector3D vector, Matrix3D matrix);
    public static Point3D op_Subtraction(Vector3D vector, Point3D point);
    public static Vector3D op_Subtraction(Vector3D vector1, Vector3D vector2);
    public static Vector3D op_UnaryNegation(Vector3D vector);
    public static Vector3D Parse(string source);
    public static Point3D Subtract(Vector3D vector, Point3D point);
    public static Vector3D Subtract(Vector3D vector1, Vector3D vector2);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Vector3DCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Vector3DCollectionValueSerializer")]
public class System.Windows.Media.Media3D.Vector3DCollection : Freezable {
    public int Count { get; }
    public Vector3D Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Vector3D>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Vector3DCollection(IEnumerable`1<Vector3D> collection);
    public Vector3DCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual Vector3D get_Item(int index);
    public sealed virtual void set_Item(int index, Vector3D value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Vector3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Vector3D value);
    public sealed virtual void Clear();
    public Vector3DCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public Vector3DCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(Vector3D value);
    public sealed virtual void CopyTo(Vector3D[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Vector3D value);
    public sealed virtual void Insert(int index, Vector3D value);
    public static Vector3DCollection Parse(string source);
    public sealed virtual bool Remove(Vector3D value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<Vector3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Vector3D>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Vector3DCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.Vector3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Visual")]
public class System.Windows.Media.Media3D.Viewport2DVisual3D : Visual3D {
    public static DependencyProperty CacheModeProperty;
    public static DependencyProperty GeometryProperty;
    public static DependencyProperty IsVisualHostMaterialProperty;
    public static DependencyProperty MaterialProperty;
    public static DependencyProperty VisualProperty;
    public CacheMode CacheMode { get; public set; }
    public Geometry3D Geometry { get; public set; }
    public Material Material { get; public set; }
    public Visual Visual { get; public set; }
    protected int Visual3DChildrenCount { get; }
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    public Geometry3D get_Geometry();
    public void set_Geometry(Geometry3D value);
    public Material get_Material();
    public void set_Material(Material value);
    public Visual get_Visual();
    public void set_Visual(Visual value);
    protected virtual int get_Visual3DChildrenCount();
    public static bool GetIsVisualHostMaterial(Material element);
    protected virtual Visual3D GetVisual3DChild(int index);
    public static void SetIsVisualHostMaterial(Material element, bool value);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Viewport3DVisual : Visual {
    public static DependencyProperty CameraProperty;
    public static DependencyProperty ViewportProperty;
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public Camera Camera { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    public Geometry Clip { get; public set; }
    public Rect ContentBounds { get; }
    public Rect DescendantBounds { get; }
    public Vector Offset { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    public DependencyObject Parent { get; }
    public Transform Transform { get; public set; }
    public Rect Viewport { get; public set; }
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public Camera get_Camera();
    public void set_Camera(Camera value);
    public Visual3DCollection get_Children();
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public Rect get_ContentBounds();
    public Rect get_DescendantBounds();
    public Vector get_Offset();
    public void set_Offset(Vector value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public DependencyObject get_Parent();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Rect get_Viewport();
    public void set_Viewport(Rect value);
    public void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    public HitTestResult HitTest(Point point);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
}
public abstract class System.Windows.Media.Media3D.Visual3D : DependencyObject {
    public static DependencyProperty TransformProperty;
    public bool HasAnimatedProperties { get; }
    public Transform3D Transform { get; public set; }
    protected int Visual3DChildrenCount { get; }
    protected Model3D Visual3DModel { get; protected set; }
    public sealed virtual bool get_HasAnimatedProperties();
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    protected virtual int get_Visual3DChildrenCount();
    protected Model3D get_Visual3DModel();
    protected void set_Visual3DModel(Model3D value);
    protected void AddVisual3DChild(Visual3D child);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual);
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    protected virtual Visual3D GetVisual3DChild(int index);
    public bool IsAncestorOf(DependencyObject descendant);
    public bool IsDescendantOf(DependencyObject ancestor);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    protected void RemoveVisual3DChild(Visual3D child);
    public GeneralTransform3D TransformToAncestor(Visual3D ancestor);
    public GeneralTransform3DTo2D TransformToAncestor(Visual ancestor);
    public GeneralTransform3D TransformToDescendant(Visual3D descendant);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Visual3DCollection : object {
    public int Count { get; }
    public Visual3D Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Visual3D>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public sealed virtual Visual3D get_Item(int index);
    public sealed virtual void set_Item(int index, Visual3D value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Visual3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Visual3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Visual3D value);
    public sealed virtual void CopyTo(Visual3D[] array, int index);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Visual3D value);
    public sealed virtual void Insert(int index, Visual3D value);
    public sealed virtual bool Remove(Visual3D value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<Visual3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Visual3D>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public class System.Windows.Media.MediaClock : Clock {
    public MediaTimeline Timeline { get; }
    protected internal MediaClock(MediaTimeline media);
    public MediaTimeline get_Timeline();
    protected virtual void DiscontinuousTimeMovement();
    protected virtual bool GetCanSlip();
    protected virtual TimeSpan GetCurrentTimeCore();
    protected virtual void SpeedChanged();
    protected virtual void Stopped();
}
public class System.Windows.Media.MediaPlayer : Animatable {
    public double Balance { get; public set; }
    public double BufferingProgress { get; }
    public bool CanPause { get; }
    public MediaClock Clock { get; public set; }
    public double DownloadProgress { get; }
    public bool HasAudio { get; }
    public bool HasVideo { get; }
    public bool IsBuffering { get; }
    public bool IsMuted { get; public set; }
    public Duration NaturalDuration { get; }
    public int NaturalVideoHeight { get; }
    public int NaturalVideoWidth { get; }
    public TimeSpan Position { get; public set; }
    public bool ScrubbingEnabled { get; public set; }
    public Uri Source { get; }
    public double SpeedRatio { get; public set; }
    public double Volume { get; public set; }
    public double get_Balance();
    public void set_Balance(double value);
    public double get_BufferingProgress();
    public bool get_CanPause();
    public MediaClock get_Clock();
    public void set_Clock(MediaClock value);
    public double get_DownloadProgress();
    public bool get_HasAudio();
    public bool get_HasVideo();
    public bool get_IsBuffering();
    public bool get_IsMuted();
    public void set_IsMuted(bool value);
    public Duration get_NaturalDuration();
    public int get_NaturalVideoHeight();
    public int get_NaturalVideoWidth();
    public TimeSpan get_Position();
    public void set_Position(TimeSpan value);
    public bool get_ScrubbingEnabled();
    public void set_ScrubbingEnabled(bool value);
    public Uri get_Source();
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    public double get_Volume();
    public void set_Volume(double value);
    public void add_BufferingEnded(EventHandler value);
    public void remove_BufferingEnded(EventHandler value);
    public void add_BufferingStarted(EventHandler value);
    public void remove_BufferingStarted(EventHandler value);
    public void add_MediaEnded(EventHandler value);
    public void remove_MediaEnded(EventHandler value);
    public void add_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    public void remove_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    public void add_MediaOpened(EventHandler value);
    public void remove_MediaOpened(EventHandler value);
    public void add_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    public void remove_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public void Close();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    public void Open(Uri source);
    public void Pause();
    public void Play();
    protected void ReadPreamble();
    public void Stop();
    protected void WritePreamble();
}
public class System.Windows.Media.MediaScriptCommandEventArgs : EventArgs {
    public string ParameterType { get; }
    public string ParameterValue { get; }
    public string get_ParameterType();
    public string get_ParameterValue();
}
public class System.Windows.Media.MediaTimeline : Timeline {
    public static DependencyProperty SourceProperty;
    public Uri Source { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    public MediaTimeline(Nullable`1<TimeSpan> beginTime);
    public MediaTimeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    public MediaTimeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    public MediaTimeline(Uri source);
    public Uri get_Source();
    public void set_Source(Uri value);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected internal virtual Clock AllocateClock();
    public MediaTimeline Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public MediaTimeline CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    public MediaClock CreateClock();
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual Duration GetNaturalDurationCore(Clock clock);
    public virtual string ToString();
}
public enum System.Windows.Media.NumberCultureSource : Enum {
    public int value__;
    public static NumberCultureSource Text;
    public static NumberCultureSource User;
    public static NumberCultureSource Override;
}
public class System.Windows.Media.NumberSubstitution : object {
    public static DependencyProperty CultureOverrideProperty;
    public static DependencyProperty CultureSourceProperty;
    public static DependencyProperty SubstitutionProperty;
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo CultureOverride { get; public set; }
    public NumberCultureSource CultureSource { get; public set; }
    public NumberSubstitutionMethod Substitution { get; public set; }
    public NumberSubstitution(NumberCultureSource source, CultureInfo cultureOverride, NumberSubstitutionMethod substitution);
    public CultureInfo get_CultureOverride();
    public void set_CultureOverride(CultureInfo value);
    public NumberCultureSource get_CultureSource();
    public void set_CultureSource(NumberCultureSource value);
    public NumberSubstitutionMethod get_Substitution();
    public void set_Substitution(NumberSubstitutionMethod value);
    public virtual bool Equals(object obj);
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static CultureInfo GetCultureOverride(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static NumberCultureSource GetCultureSource(DependencyObject target);
    public virtual int GetHashCode();
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static NumberSubstitutionMethod GetSubstitution(DependencyObject target);
    public static void SetCultureOverride(DependencyObject target, CultureInfo value);
    public static void SetCultureSource(DependencyObject target, NumberCultureSource value);
    public static void SetSubstitution(DependencyObject target, NumberSubstitutionMethod value);
}
public enum System.Windows.Media.NumberSubstitutionMethod : Enum {
    public int value__;
    public static NumberSubstitutionMethod AsCulture;
    public static NumberSubstitutionMethod Context;
    public static NumberSubstitutionMethod European;
    public static NumberSubstitutionMethod NativeNational;
    public static NumberSubstitutionMethod Traditional;
}
[LocalizabilityAttribute("0")]
[ContentPropertyAttribute("Segments")]
public class System.Windows.Media.PathFigure : Animatable {
    public static DependencyProperty IsClosedProperty;
    public static DependencyProperty IsFilledProperty;
    public static DependencyProperty SegmentsProperty;
    public static DependencyProperty StartPointProperty;
    public bool IsClosed { get; public set; }
    public bool IsFilled { get; public set; }
    public PathSegmentCollection Segments { get; public set; }
    public Point StartPoint { get; public set; }
    public PathFigure(Point start, IEnumerable`1<PathSegment> segments, bool closed);
    public bool get_IsClosed();
    public void set_IsClosed(bool value);
    public bool get_IsFilled();
    public void set_IsFilled(bool value);
    public PathSegmentCollection get_Segments();
    public void set_Segments(PathSegmentCollection value);
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public PathFigure Clone();
    public PathFigure CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public PathFigure GetFlattenedPathFigure();
    public PathFigure GetFlattenedPathFigure(double tolerance, ToleranceType type);
    public bool MayHaveCurves();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.PathFigureCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.PathFigureCollectionValueSerializer")]
public class System.Windows.Media.PathFigureCollection : Animatable {
    public int Count { get; }
    public PathFigure Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.PathFigure>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public PathFigureCollection(IEnumerable`1<PathFigure> collection);
    public PathFigureCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual PathFigure get_Item(int index);
    public sealed virtual void set_Item(int index, PathFigure value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.PathFigure>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(PathFigure value);
    public sealed virtual void Clear();
    public PathFigureCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public PathFigureCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(PathFigure value);
    public sealed virtual void CopyTo(PathFigure[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(PathFigure value);
    public sealed virtual void Insert(int index, PathFigure value);
    public static PathFigureCollection Parse(string source);
    public sealed virtual bool Remove(PathFigure value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<PathFigure> System.Collections.Generic.IEnumerable<System.Windows.Media.PathFigure>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.PathFigureCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Figures")]
public class System.Windows.Media.PathGeometry : Geometry {
    public static DependencyProperty FiguresProperty;
    public static DependencyProperty FillRuleProperty;
    public Rect Bounds { get; }
    public PathFigureCollection Figures { get; public set; }
    public FillRule FillRule { get; public set; }
    public PathGeometry(IEnumerable`1<PathFigure> figures);
    public PathGeometry(IEnumerable`1<PathFigure> figures, FillRule fillRule, Transform transform);
    public virtual Rect get_Bounds();
    public PathFigureCollection get_Figures();
    public void set_Figures(PathFigureCollection value);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    public void AddGeometry(Geometry geometry);
    public void Clear();
    public PathGeometry Clone();
    public PathGeometry CloneCurrentValue();
    public static PathGeometry CreateFromGeometry(Geometry geometry);
    protected virtual Freezable CreateInstanceCore();
    public void GetPointAtFractionLength(double progress, Point& point, Point& tangent);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    protected virtual void OnChanged();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.PathSegment : Animatable {
    public static DependencyProperty IsSmoothJoinProperty;
    public static DependencyProperty IsStrokedProperty;
    public bool IsSmoothJoin { get; public set; }
    public bool IsStroked { get; public set; }
    public bool get_IsSmoothJoin();
    public void set_IsSmoothJoin(bool value);
    public bool get_IsStroked();
    public void set_IsStroked(bool value);
    public PathSegment Clone();
    public PathSegment CloneCurrentValue();
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.PathSegmentCollection : Animatable {
    public int Count { get; }
    public PathSegment Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.PathSegment>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public PathSegmentCollection(IEnumerable`1<PathSegment> collection);
    public PathSegmentCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual PathSegment get_Item(int index);
    public sealed virtual void set_Item(int index, PathSegment value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.PathSegment>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(PathSegment value);
    public sealed virtual void Clear();
    public PathSegmentCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public PathSegmentCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(PathSegment value);
    public sealed virtual void CopyTo(PathSegment[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(PathSegment value);
    public sealed virtual void Insert(int index, PathSegment value);
    public sealed virtual bool Remove(PathSegment value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<PathSegment> System.Collections.Generic.IEnumerable<System.Windows.Media.PathSegment>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.Pen : Animatable {
    public static DependencyProperty BrushProperty;
    public static DependencyProperty DashCapProperty;
    public static DependencyProperty DashStyleProperty;
    public static DependencyProperty EndLineCapProperty;
    public static DependencyProperty LineJoinProperty;
    public static DependencyProperty MiterLimitProperty;
    public static DependencyProperty StartLineCapProperty;
    public static DependencyProperty ThicknessProperty;
    public Brush Brush { get; public set; }
    public PenLineCap DashCap { get; public set; }
    public DashStyle DashStyle { get; public set; }
    public PenLineCap EndLineCap { get; public set; }
    public PenLineJoin LineJoin { get; public set; }
    public double MiterLimit { get; public set; }
    public PenLineCap StartLineCap { get; public set; }
    public double Thickness { get; public set; }
    public Pen(Brush brush, double thickness);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public PenLineCap get_DashCap();
    public void set_DashCap(PenLineCap value);
    public DashStyle get_DashStyle();
    public void set_DashStyle(DashStyle value);
    public PenLineCap get_EndLineCap();
    public void set_EndLineCap(PenLineCap value);
    public PenLineJoin get_LineJoin();
    public void set_LineJoin(PenLineJoin value);
    public double get_MiterLimit();
    public void set_MiterLimit(double value);
    public PenLineCap get_StartLineCap();
    public void set_StartLineCap(PenLineCap value);
    public double get_Thickness();
    public void set_Thickness(double value);
    public Pen Clone();
    public Pen CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.PenDashCap : Enum {
    public int value__;
    public static PenDashCap Flat;
    public static PenDashCap Round;
    public static PenDashCap Triangle;
}
public enum System.Windows.Media.PenLineCap : Enum {
    public int value__;
    public static PenLineCap Flat;
    public static PenLineCap Square;
    public static PenLineCap Round;
    public static PenLineCap Triangle;
}
public enum System.Windows.Media.PenLineJoin : Enum {
    public int value__;
    public static PenLineJoin Miter;
    public static PenLineJoin Bevel;
    public static PenLineJoin Round;
}
[TypeConverterAttribute("System.Windows.Media.PixelFormatConverter")]
public class System.Windows.Media.PixelFormat : ValueType {
    public int BitsPerPixel { get; }
    public IList`1<PixelFormatChannelMask> Masks { get; }
    public int get_BitsPerPixel();
    public IList`1<PixelFormatChannelMask> get_Masks();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PixelFormat pixelFormat);
    public static bool Equals(PixelFormat left, PixelFormat right);
    public virtual int GetHashCode();
    public static bool op_Equality(PixelFormat left, PixelFormat right);
    public static bool op_Inequality(PixelFormat left, PixelFormat right);
    public virtual string ToString();
}
public class System.Windows.Media.PixelFormatChannelMask : ValueType {
    public IList`1<byte> Mask { get; }
    public IList`1<byte> get_Mask();
    public virtual bool Equals(object obj);
    public static bool Equals(PixelFormatChannelMask left, PixelFormatChannelMask right);
    public virtual int GetHashCode();
    public static bool op_Equality(PixelFormatChannelMask left, PixelFormatChannelMask right);
    public static bool op_Inequality(PixelFormatChannelMask left, PixelFormatChannelMask right);
}
public class System.Windows.Media.PixelFormatConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object o);
    public object ConvertFromString(string value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Media.PixelFormats : object {
    public static PixelFormat Bgr101010 { get; }
    public static PixelFormat Bgr24 { get; }
    public static PixelFormat Bgr32 { get; }
    public static PixelFormat Bgr555 { get; }
    public static PixelFormat Bgr565 { get; }
    public static PixelFormat Bgra32 { get; }
    public static PixelFormat BlackWhite { get; }
    public static PixelFormat Cmyk32 { get; }
    public static PixelFormat Default { get; }
    public static PixelFormat Gray16 { get; }
    public static PixelFormat Gray2 { get; }
    public static PixelFormat Gray32Float { get; }
    public static PixelFormat Gray4 { get; }
    public static PixelFormat Gray8 { get; }
    public static PixelFormat Indexed1 { get; }
    public static PixelFormat Indexed2 { get; }
    public static PixelFormat Indexed4 { get; }
    public static PixelFormat Indexed8 { get; }
    public static PixelFormat Pbgra32 { get; }
    public static PixelFormat Prgba128Float { get; }
    public static PixelFormat Prgba64 { get; }
    public static PixelFormat Rgb128Float { get; }
    public static PixelFormat Rgb24 { get; }
    public static PixelFormat Rgb48 { get; }
    public static PixelFormat Rgba128Float { get; }
    public static PixelFormat Rgba64 { get; }
    public static PixelFormat get_Bgr101010();
    public static PixelFormat get_Bgr24();
    public static PixelFormat get_Bgr32();
    public static PixelFormat get_Bgr555();
    public static PixelFormat get_Bgr565();
    public static PixelFormat get_Bgra32();
    public static PixelFormat get_BlackWhite();
    public static PixelFormat get_Cmyk32();
    public static PixelFormat get_Default();
    public static PixelFormat get_Gray16();
    public static PixelFormat get_Gray2();
    public static PixelFormat get_Gray32Float();
    public static PixelFormat get_Gray4();
    public static PixelFormat get_Gray8();
    public static PixelFormat get_Indexed1();
    public static PixelFormat get_Indexed2();
    public static PixelFormat get_Indexed4();
    public static PixelFormat get_Indexed8();
    public static PixelFormat get_Pbgra32();
    public static PixelFormat get_Prgba128Float();
    public static PixelFormat get_Prgba64();
    public static PixelFormat get_Rgb128Float();
    public static PixelFormat get_Rgb24();
    public static PixelFormat get_Rgb48();
    public static PixelFormat get_Rgba128Float();
    public static PixelFormat get_Rgba64();
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.PointCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.PointCollectionValueSerializer")]
public class System.Windows.Media.PointCollection : Freezable {
    public int Count { get; }
    public Point Item { get; public set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Point>.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public PointCollection(IEnumerable`1<Point> collection);
    public PointCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual Point get_Item(int index);
    public sealed virtual void set_Item(int index, Point value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Point>.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Point value);
    public sealed virtual void Clear();
    public PointCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public PointCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(Point value);
    public sealed virtual void CopyTo(Point[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Point value);
    public sealed virtual void Insert(int index, Point value);
    public static PointCollection Parse(string source);
    public sealed virtual bool Remove(Point value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<Point> System.Collections.Generic.IEnumerable<System.Windows.Point>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.PointCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.PointHitTestParameters : HitTestParameters {
    public Point HitPoint { get; }
    public PointHitTestParameters(Point point);
    public Point get_HitPoint();
}
public class System.Windows.Media.PointHitTestResult : HitTestResult {
    public Point PointHit { get; }
    public Visual VisualHit { get; }
    public PointHitTestResult(Visual visualHit, Point pointHit);
    public Point get_PointHit();
    public Visual get_VisualHit();
}
public class System.Windows.Media.PolyBezierSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    public PointCollection Points { get; public set; }
    public PolyBezierSegment(IEnumerable`1<Point> points, bool isStroked);
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    public PolyBezierSegment Clone();
    public PolyBezierSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.PolyLineSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    public PointCollection Points { get; public set; }
    public PolyLineSegment(IEnumerable`1<Point> points, bool isStroked);
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    public PolyLineSegment Clone();
    public PolyLineSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.PolyQuadraticBezierSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    public PointCollection Points { get; public set; }
    public PolyQuadraticBezierSegment(IEnumerable`1<Point> points, bool isStroked);
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    public PolyQuadraticBezierSegment Clone();
    public PolyQuadraticBezierSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.QuadraticBezierSegment : PathSegment {
    public static DependencyProperty Point1Property;
    public static DependencyProperty Point2Property;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    public QuadraticBezierSegment(Point point1, Point point2, bool isStroked);
    public Point get_Point1();
    public void set_Point1(Point value);
    public Point get_Point2();
    public void set_Point2(Point value);
    public QuadraticBezierSegment Clone();
    public QuadraticBezierSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.RadialGradientBrush : GradientBrush {
    public static DependencyProperty CenterProperty;
    public static DependencyProperty GradientOriginProperty;
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public Point Center { get; public set; }
    public Point GradientOrigin { get; public set; }
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public RadialGradientBrush(Color startColor, Color endColor);
    public RadialGradientBrush(GradientStopCollection gradientStopCollection);
    public Point get_Center();
    public void set_Center(Point value);
    public Point get_GradientOrigin();
    public void set_GradientOrigin(Point value);
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public RadialGradientBrush Clone();
    public RadialGradientBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.RectangleGeometry : Geometry {
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public static DependencyProperty RectProperty;
    public Rect Bounds { get; }
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Rect Rect { get; public set; }
    public RectangleGeometry(Rect rect);
    public RectangleGeometry(Rect rect, double radiusX, double radiusY);
    public RectangleGeometry(Rect rect, double radiusX, double radiusY, Transform transform);
    public virtual Rect get_Bounds();
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    public RectangleGeometry Clone();
    public RectangleGeometry CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public virtual double GetArea(double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
}
public static class System.Windows.Media.RenderCapability : object {
    [ObsoleteAttribute("IsShaderEffectSoftwareRenderingSupported property is deprecated.  Use IsPixelShaderVersionSupportedInSoftware static method instead.")]
public static bool IsShaderEffectSoftwareRenderingSupported { get; }
    public static Size MaxHardwareTextureSize { get; }
    public static int Tier { get; }
    public static bool get_IsShaderEffectSoftwareRenderingSupported();
    public static Size get_MaxHardwareTextureSize();
    public static int get_Tier();
    public static void add_TierChanged(EventHandler value);
    public static void remove_TierChanged(EventHandler value);
    public static bool IsPixelShaderVersionSupported(short majorVersionRequested, short minorVersionRequested);
    public static bool IsPixelShaderVersionSupportedInSoftware(short majorVersionRequested, short minorVersionRequested);
    public static int MaxPixelShaderInstructionSlots(short majorVersionRequested, short minorVersionRequested);
}
public class System.Windows.Media.RenderingEventArgs : EventArgs {
    public TimeSpan RenderingTime { get; }
    public TimeSpan get_RenderingTime();
}
public static class System.Windows.Media.RenderOptions : object {
    public static DependencyProperty BitmapScalingModeProperty;
    public static DependencyProperty CacheInvalidationThresholdMaximumProperty;
    public static DependencyProperty CacheInvalidationThresholdMinimumProperty;
    public static DependencyProperty CachingHintProperty;
    public static DependencyProperty ClearTypeHintProperty;
    public static DependencyProperty EdgeModeProperty;
    public static RenderMode ProcessRenderMode { get; public set; }
    public static RenderMode get_ProcessRenderMode();
    public static void set_ProcessRenderMode(RenderMode value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static BitmapScalingMode GetBitmapScalingMode(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static double GetCacheInvalidationThresholdMaximum(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static double GetCacheInvalidationThresholdMinimum(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static CachingHint GetCachingHint(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ClearTypeHint GetClearTypeHint(DependencyObject target);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static EdgeMode GetEdgeMode(DependencyObject target);
    public static void SetBitmapScalingMode(DependencyObject target, BitmapScalingMode bitmapScalingMode);
    public static void SetCacheInvalidationThresholdMaximum(DependencyObject target, double cacheInvalidationThresholdMaximum);
    public static void SetCacheInvalidationThresholdMinimum(DependencyObject target, double cacheInvalidationThresholdMinimum);
    public static void SetCachingHint(DependencyObject target, CachingHint cachingHint);
    public static void SetClearTypeHint(DependencyObject target, ClearTypeHint clearTypeHint);
    public static void SetEdgeMode(DependencyObject target, EdgeMode edgeMode);
}
public class System.Windows.Media.RequestCachePolicyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.Media.RotateTransform : Transform {
    public static DependencyProperty AngleProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public double Angle { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public Matrix Value { get; }
    public RotateTransform(double angle);
    public RotateTransform(double angle, double centerX, double centerY);
    public double get_Angle();
    public void set_Angle(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public virtual Matrix get_Value();
    public RotateTransform Clone();
    public RotateTransform CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.ScaleTransform : Transform {
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public static DependencyProperty ScaleXProperty;
    public static DependencyProperty ScaleYProperty;
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double ScaleX { get; public set; }
    public double ScaleY { get; public set; }
    public Matrix Value { get; }
    public ScaleTransform(double scaleX, double scaleY);
    public ScaleTransform(double scaleX, double scaleY, double centerX, double centerY);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_ScaleX();
    public void set_ScaleX(double value);
    public double get_ScaleY();
    public void set_ScaleY(double value);
    public virtual Matrix get_Value();
    public ScaleTransform Clone();
    public ScaleTransform CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.SkewTransform : Transform {
    public static DependencyProperty AngleXProperty;
    public static DependencyProperty AngleYProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public double AngleX { get; public set; }
    public double AngleY { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public Matrix Value { get; }
    public SkewTransform(double angleX, double angleY);
    public SkewTransform(double angleX, double angleY, double centerX, double centerY);
    public double get_AngleX();
    public void set_AngleX(double value);
    public double get_AngleY();
    public void set_AngleY(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public virtual Matrix get_Value();
    public SkewTransform Clone();
    public SkewTransform CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.SolidColorBrush : Brush {
    public static DependencyProperty ColorProperty;
    public Color Color { get; public set; }
    public SolidColorBrush(Color color);
    public Color get_Color();
    public void set_Color(Color value);
    public SolidColorBrush Clone();
    public SolidColorBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public static object DeserializeFrom(BinaryReader reader);
}
[TypeConverterAttribute("System.Windows.Media.GeometryConverter")]
public class System.Windows.Media.StreamGeometry : Geometry {
    public static DependencyProperty FillRuleProperty;
    public Rect Bounds { get; }
    public FillRule FillRule { get; public set; }
    public virtual Rect get_Bounds();
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    public void Clear();
    public StreamGeometry Clone();
    protected virtual void CloneCore(Freezable source);
    public StreamGeometry CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    protected virtual void OnChanged();
    public StreamGeometryContext Open();
}
public abstract class System.Windows.Media.StreamGeometryContext : DispatcherObject {
    public abstract virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
    public abstract virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    public abstract virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public virtual void Close();
    public abstract virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    private sealed virtual override void System.IDisposable.Dispose();
}
public enum System.Windows.Media.Stretch : Enum {
    public int value__;
    public static Stretch None;
    public static Stretch Fill;
    public static Stretch Uniform;
    public static Stretch UniformToFill;
}
[FlagsAttribute]
public enum System.Windows.Media.StyleSimulations : Enum {
    public int value__;
    public static StyleSimulations None;
    public static StyleSimulations BoldSimulation;
    public static StyleSimulations ItalicSimulation;
    public static StyleSimulations BoldItalicSimulation;
}
public enum System.Windows.Media.SweepDirection : Enum {
    public int value__;
    public static SweepDirection Counterclockwise;
    public static SweepDirection Clockwise;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.TextEffect : Animatable {
    public static DependencyProperty ClipProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty PositionCountProperty;
    public static DependencyProperty PositionStartProperty;
    public static DependencyProperty TransformProperty;
    public Geometry Clip { get; public set; }
    public Brush Foreground { get; public set; }
    public int PositionCount { get; public set; }
    public int PositionStart { get; public set; }
    public Transform Transform { get; public set; }
    public TextEffect(Transform transform, Brush foreground, Geometry clip, int positionStart, int positionCount);
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public int get_PositionCount();
    public void set_PositionCount(int value);
    public int get_PositionStart();
    public void set_PositionStart(int value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public TextEffect Clone();
    public TextEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.TextEffectCollection : Animatable {
    public int Count { get; }
    public TextEffect Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.TextEffect>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public TextEffectCollection(IEnumerable`1<TextEffect> collection);
    public TextEffectCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual TextEffect get_Item(int index);
    public sealed virtual void set_Item(int index, TextEffect value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.TextEffect>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(TextEffect value);
    public sealed virtual void Clear();
    public TextEffectCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public TextEffectCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(TextEffect value);
    public sealed virtual void CopyTo(TextEffect[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(TextEffect value);
    public sealed virtual void Insert(int index, TextEffect value);
    public sealed virtual bool Remove(TextEffect value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<TextEffect> System.Collections.Generic.IEnumerable<System.Windows.Media.TextEffect>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public class System.Windows.Media.TextFormatting.CharacterBufferRange : ValueType {
    public CharacterBufferReference CharacterBufferReference { get; }
    public static CharacterBufferRange Empty { get; }
    public int Length { get; }
    [CLSCompliantAttribute("False")]
public CharacterBufferRange(Char* unsafeCharacterString, int characterLength);
    public CharacterBufferRange(Char[] characterArray, int offsetToFirstChar, int characterLength);
    public CharacterBufferRange(string characterString, int offsetToFirstChar, int characterLength);
    public CharacterBufferReference get_CharacterBufferReference();
    public static CharacterBufferRange get_Empty();
    public int get_Length();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CharacterBufferRange value);
    public virtual int GetHashCode();
    public static bool op_Equality(CharacterBufferRange left, CharacterBufferRange right);
    public static bool op_Inequality(CharacterBufferRange left, CharacterBufferRange right);
}
public class System.Windows.Media.TextFormatting.CharacterBufferReference : ValueType {
    [CLSCompliantAttribute("False")]
public CharacterBufferReference(Char* unsafeCharacterString, int characterLength);
    public CharacterBufferReference(Char[] characterArray, int offsetToFirstChar);
    public CharacterBufferReference(string characterString, int offsetToFirstChar);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CharacterBufferReference value);
    public virtual int GetHashCode();
    public static bool op_Equality(CharacterBufferReference left, CharacterBufferReference right);
    public static bool op_Inequality(CharacterBufferReference left, CharacterBufferReference right);
}
public class System.Windows.Media.TextFormatting.CharacterHit : ValueType {
    public int FirstCharacterIndex { get; }
    public int TrailingLength { get; }
    public CharacterHit(int firstCharacterIndex, int trailingLength);
    public int get_FirstCharacterIndex();
    public int get_TrailingLength();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CharacterHit obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CharacterHit left, CharacterHit right);
    public static bool op_Inequality(CharacterHit left, CharacterHit right);
}
public class System.Windows.Media.TextFormatting.CultureSpecificCharacterBufferRange : object {
    public CharacterBufferRange CharacterBufferRange { get; }
    public CultureInfo CultureInfo { get; }
    public CultureSpecificCharacterBufferRange(CultureInfo culture, CharacterBufferRange characterBufferRange);
    public CharacterBufferRange get_CharacterBufferRange();
    public CultureInfo get_CultureInfo();
}
public class System.Windows.Media.TextFormatting.IndexedGlyphRun : object {
    public GlyphRun GlyphRun { get; }
    public int TextSourceCharacterIndex { get; }
    public int TextSourceLength { get; }
    public GlyphRun get_GlyphRun();
    public int get_TextSourceCharacterIndex();
    public int get_TextSourceLength();
}
[FlagsAttribute]
public enum System.Windows.Media.TextFormatting.InvertAxes : Enum {
    public int value__;
    public static InvertAxes None;
    public static InvertAxes Horizontal;
    public static InvertAxes Vertical;
    public static InvertAxes Both;
}
public class System.Windows.Media.TextFormatting.MinMaxParagraphWidth : ValueType {
    public double MaxWidth { get; }
    public double MinWidth { get; }
    public double get_MaxWidth();
    public double get_MinWidth();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MinMaxParagraphWidth value);
    public virtual int GetHashCode();
    public static bool op_Equality(MinMaxParagraphWidth left, MinMaxParagraphWidth right);
    public static bool op_Inequality(MinMaxParagraphWidth left, MinMaxParagraphWidth right);
}
public class System.Windows.Media.TextFormatting.TextBounds : object {
    public FlowDirection FlowDirection { get; }
    public Rect Rectangle { get; }
    public IList`1<TextRunBounds> TextRunBounds { get; }
    public FlowDirection get_FlowDirection();
    public Rect get_Rectangle();
    public IList`1<TextRunBounds> get_TextRunBounds();
}
public class System.Windows.Media.TextFormatting.TextCharacters : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    [CLSCompliantAttribute("False")]
public TextCharacters(Char* unsafeCharacterString, int length, TextRunProperties textRunProperties);
    public TextCharacters(Char[] characterArray, int offsetToFirstChar, int length, TextRunProperties textRunProperties);
    public TextCharacters(string characterString, int offsetToFirstChar, int length, TextRunProperties textRunProperties);
    public TextCharacters(string characterString, TextRunProperties textRunProperties);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public class System.Windows.Media.TextFormatting.TextCollapsedRange : object {
    public int Length { get; }
    public int TextSourceCharacterIndex { get; }
    public double Width { get; }
    public int get_Length();
    public int get_TextSourceCharacterIndex();
    public double get_Width();
}
public abstract class System.Windows.Media.TextFormatting.TextCollapsingProperties : object {
    public TextCollapsingStyle Style { get; }
    public TextRun Symbol { get; }
    public double Width { get; }
    public abstract virtual TextCollapsingStyle get_Style();
    public abstract virtual TextRun get_Symbol();
    public abstract virtual double get_Width();
}
public enum System.Windows.Media.TextFormatting.TextCollapsingStyle : Enum {
    public int value__;
    public static TextCollapsingStyle TrailingCharacter;
    public static TextCollapsingStyle TrailingWord;
}
public abstract class System.Windows.Media.TextFormatting.TextEmbeddedObject : TextRun {
    public LineBreakCondition BreakAfter { get; }
    public LineBreakCondition BreakBefore { get; }
    public bool HasFixedSize { get; }
    public abstract virtual LineBreakCondition get_BreakAfter();
    public abstract virtual LineBreakCondition get_BreakBefore();
    public abstract virtual bool get_HasFixedSize();
    public abstract virtual Rect ComputeBoundingBox(bool rightToLeft, bool sideways);
    public abstract virtual void Draw(DrawingContext drawingContext, Point origin, bool rightToLeft, bool sideways);
    public abstract virtual TextEmbeddedObjectMetrics Format(double remainingParagraphWidth);
}
public class System.Windows.Media.TextFormatting.TextEmbeddedObjectMetrics : object {
    public double Baseline { get; }
    public double Height { get; }
    public double Width { get; }
    public TextEmbeddedObjectMetrics(double width, double height, double baseline);
    public double get_Baseline();
    public double get_Height();
    public double get_Width();
}
public class System.Windows.Media.TextFormatting.TextEndOfLine : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextEndOfLine(int length);
    public TextEndOfLine(int length, TextRunProperties textRunProperties);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public class System.Windows.Media.TextFormatting.TextEndOfParagraph : TextEndOfLine {
    public TextEndOfParagraph(int length);
    public TextEndOfParagraph(int length, TextRunProperties textRunProperties);
}
public class System.Windows.Media.TextFormatting.TextEndOfSegment : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextEndOfSegment(int length);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public abstract class System.Windows.Media.TextFormatting.TextFormatter : object {
    public static TextFormatter Create();
    public static TextFormatter Create(TextFormattingMode textFormattingMode);
    public virtual void Dispose();
    public abstract virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak);
    public abstract virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    public abstract virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties);
    public abstract virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties, TextRunCache textRunCache);
    internal abstract virtual TextLine RecreateLine(TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
}
public class System.Windows.Media.TextFormatting.TextHidden : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextHidden(int length);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public abstract class System.Windows.Media.TextFormatting.TextLine : object {
    public double Baseline { get; }
    public int DependentLength { get; }
    public double Extent { get; }
    public bool HasCollapsed { get; }
    public bool HasOverflowed { get; }
    public double Height { get; }
    public bool IsTruncated { get; }
    public int Length { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    public int NewlineLength { get; }
    public double OverhangAfter { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double PixelsPerDip { get; public set; }
    public double Start { get; }
    public double TextBaseline { get; }
    public double TextHeight { get; }
    public int TrailingWhitespaceLength { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    protected TextLine(double pixelsPerDip);
    public abstract virtual double get_Baseline();
    public abstract virtual int get_DependentLength();
    public abstract virtual double get_Extent();
    public abstract virtual bool get_HasCollapsed();
    public abstract virtual bool get_HasOverflowed();
    public abstract virtual double get_Height();
    public virtual bool get_IsTruncated();
    public abstract virtual int get_Length();
    public abstract virtual double get_MarkerBaseline();
    public abstract virtual double get_MarkerHeight();
    public abstract virtual int get_NewlineLength();
    public abstract virtual double get_OverhangAfter();
    public abstract virtual double get_OverhangLeading();
    public abstract virtual double get_OverhangTrailing();
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
    public abstract virtual double get_Start();
    public abstract virtual double get_TextBaseline();
    public abstract virtual double get_TextHeight();
    public abstract virtual int get_TrailingWhitespaceLength();
    public abstract virtual double get_Width();
    public abstract virtual double get_WidthIncludingTrailingWhitespace();
    public abstract virtual TextLine Collapse(TextCollapsingProperties[] collapsingPropertiesList);
    public abstract virtual void Dispose();
    public abstract virtual void Draw(DrawingContext drawingContext, Point origin, InvertAxes inversion);
    public abstract virtual CharacterHit GetBackspaceCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetCharacterHitFromDistance(double distance);
    public abstract virtual double GetDistanceFromCharacterHit(CharacterHit characterHit);
    public abstract virtual IEnumerable`1<IndexedGlyphRun> GetIndexedGlyphRuns();
    public abstract virtual CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual IList`1<TextBounds> GetTextBounds(int firstTextSourceCharacterIndex, int textLength);
    public abstract virtual IList`1<TextCollapsedRange> GetTextCollapsedRanges();
    public abstract virtual TextLineBreak GetTextLineBreak();
    public abstract virtual IList`1<TextSpan`1<TextRun>> GetTextRunSpans();
}
public class System.Windows.Media.TextFormatting.TextLineBreak : object {
    public TextLineBreak Clone();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
public abstract class System.Windows.Media.TextFormatting.TextMarkerProperties : object {
    public double Offset { get; }
    public TextSource TextSource { get; }
    public abstract virtual double get_Offset();
    public abstract virtual TextSource get_TextSource();
}
public abstract class System.Windows.Media.TextFormatting.TextModifier : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public FlowDirection FlowDirection { get; }
    public bool HasDirectionalEmbedding { get; }
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public abstract virtual FlowDirection get_FlowDirection();
    public abstract virtual bool get_HasDirectionalEmbedding();
    public abstract virtual TextRunProperties ModifyProperties(TextRunProperties properties);
}
public abstract class System.Windows.Media.TextFormatting.TextParagraphProperties : object {
    public bool AlwaysCollapsible { get; }
    public double DefaultIncrementalTab { get; }
    public TextRunProperties DefaultTextRunProperties { get; }
    public bool FirstLineInParagraph { get; }
    public FlowDirection FlowDirection { get; }
    public double Indent { get; }
    public double LineHeight { get; }
    public double ParagraphIndent { get; }
    public IList`1<TextTabProperties> Tabs { get; }
    public TextAlignment TextAlignment { get; }
    public TextDecorationCollection TextDecorations { get; }
    public TextMarkerProperties TextMarkerProperties { get; }
    public TextWrapping TextWrapping { get; }
    public virtual bool get_AlwaysCollapsible();
    public virtual double get_DefaultIncrementalTab();
    public abstract virtual TextRunProperties get_DefaultTextRunProperties();
    public abstract virtual bool get_FirstLineInParagraph();
    public abstract virtual FlowDirection get_FlowDirection();
    public abstract virtual double get_Indent();
    public abstract virtual double get_LineHeight();
    public virtual double get_ParagraphIndent();
    public virtual IList`1<TextTabProperties> get_Tabs();
    public abstract virtual TextAlignment get_TextAlignment();
    public virtual TextDecorationCollection get_TextDecorations();
    public abstract virtual TextMarkerProperties get_TextMarkerProperties();
    public abstract virtual TextWrapping get_TextWrapping();
}
public abstract class System.Windows.Media.TextFormatting.TextRun : object {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public abstract virtual CharacterBufferReference get_CharacterBufferReference();
    public abstract virtual int get_Length();
    public abstract virtual TextRunProperties get_Properties();
}
public class System.Windows.Media.TextFormatting.TextRunBounds : object {
    public int Length { get; }
    public Rect Rectangle { get; }
    public TextRun TextRun { get; }
    public int TextSourceCharacterIndex { get; }
    public int get_Length();
    public Rect get_Rectangle();
    public TextRun get_TextRun();
    public int get_TextSourceCharacterIndex();
}
public class System.Windows.Media.TextFormatting.TextRunCache : object {
    public void Change(int textSourceCharacterIndex, int addition, int removal);
    public void Invalidate();
}
public abstract class System.Windows.Media.TextFormatting.TextRunProperties : object {
    public Brush BackgroundBrush { get; }
    public BaselineAlignment BaselineAlignment { get; }
    public CultureInfo CultureInfo { get; }
    public double FontHintingEmSize { get; }
    public double FontRenderingEmSize { get; }
    public Brush ForegroundBrush { get; }
    public NumberSubstitution NumberSubstitution { get; }
    public double PixelsPerDip { get; public set; }
    public TextDecorationCollection TextDecorations { get; }
    public TextEffectCollection TextEffects { get; }
    public Typeface Typeface { get; }
    public TextRunTypographyProperties TypographyProperties { get; }
    public abstract virtual Brush get_BackgroundBrush();
    public virtual BaselineAlignment get_BaselineAlignment();
    public abstract virtual CultureInfo get_CultureInfo();
    public abstract virtual double get_FontHintingEmSize();
    public abstract virtual double get_FontRenderingEmSize();
    public abstract virtual Brush get_ForegroundBrush();
    public virtual NumberSubstitution get_NumberSubstitution();
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
    public abstract virtual TextDecorationCollection get_TextDecorations();
    public abstract virtual TextEffectCollection get_TextEffects();
    public abstract virtual Typeface get_Typeface();
    public virtual TextRunTypographyProperties get_TypographyProperties();
}
public abstract class System.Windows.Media.TextFormatting.TextRunTypographyProperties : object {
    public int AnnotationAlternates { get; }
    public FontCapitals Capitals { get; }
    public bool CapitalSpacing { get; }
    public bool CaseSensitiveForms { get; }
    public bool ContextualAlternates { get; }
    public bool ContextualLigatures { get; }
    public int ContextualSwashes { get; }
    public bool DiscretionaryLigatures { get; }
    public bool EastAsianExpertForms { get; }
    public FontEastAsianLanguage EastAsianLanguage { get; }
    public FontEastAsianWidths EastAsianWidths { get; }
    public FontFraction Fraction { get; }
    public bool HistoricalForms { get; }
    public bool HistoricalLigatures { get; }
    public bool Kerning { get; }
    public bool MathematicalGreek { get; }
    public FontNumeralAlignment NumeralAlignment { get; }
    public FontNumeralStyle NumeralStyle { get; }
    public bool SlashedZero { get; }
    public bool StandardLigatures { get; }
    public int StandardSwashes { get; }
    public int StylisticAlternates { get; }
    public bool StylisticSet1 { get; }
    public bool StylisticSet10 { get; }
    public bool StylisticSet11 { get; }
    public bool StylisticSet12 { get; }
    public bool StylisticSet13 { get; }
    public bool StylisticSet14 { get; }
    public bool StylisticSet15 { get; }
    public bool StylisticSet16 { get; }
    public bool StylisticSet17 { get; }
    public bool StylisticSet18 { get; }
    public bool StylisticSet19 { get; }
    public bool StylisticSet2 { get; }
    public bool StylisticSet20 { get; }
    public bool StylisticSet3 { get; }
    public bool StylisticSet4 { get; }
    public bool StylisticSet5 { get; }
    public bool StylisticSet6 { get; }
    public bool StylisticSet7 { get; }
    public bool StylisticSet8 { get; }
    public bool StylisticSet9 { get; }
    public FontVariants Variants { get; }
    public abstract virtual int get_AnnotationAlternates();
    public abstract virtual FontCapitals get_Capitals();
    public abstract virtual bool get_CapitalSpacing();
    public abstract virtual bool get_CaseSensitiveForms();
    public abstract virtual bool get_ContextualAlternates();
    public abstract virtual bool get_ContextualLigatures();
    public abstract virtual int get_ContextualSwashes();
    public abstract virtual bool get_DiscretionaryLigatures();
    public abstract virtual bool get_EastAsianExpertForms();
    public abstract virtual FontEastAsianLanguage get_EastAsianLanguage();
    public abstract virtual FontEastAsianWidths get_EastAsianWidths();
    public abstract virtual FontFraction get_Fraction();
    public abstract virtual bool get_HistoricalForms();
    public abstract virtual bool get_HistoricalLigatures();
    public abstract virtual bool get_Kerning();
    public abstract virtual bool get_MathematicalGreek();
    public abstract virtual FontNumeralAlignment get_NumeralAlignment();
    public abstract virtual FontNumeralStyle get_NumeralStyle();
    public abstract virtual bool get_SlashedZero();
    public abstract virtual bool get_StandardLigatures();
    public abstract virtual int get_StandardSwashes();
    public abstract virtual int get_StylisticAlternates();
    public abstract virtual bool get_StylisticSet1();
    public abstract virtual bool get_StylisticSet10();
    public abstract virtual bool get_StylisticSet11();
    public abstract virtual bool get_StylisticSet12();
    public abstract virtual bool get_StylisticSet13();
    public abstract virtual bool get_StylisticSet14();
    public abstract virtual bool get_StylisticSet15();
    public abstract virtual bool get_StylisticSet16();
    public abstract virtual bool get_StylisticSet17();
    public abstract virtual bool get_StylisticSet18();
    public abstract virtual bool get_StylisticSet19();
    public abstract virtual bool get_StylisticSet2();
    public abstract virtual bool get_StylisticSet20();
    public abstract virtual bool get_StylisticSet3();
    public abstract virtual bool get_StylisticSet4();
    public abstract virtual bool get_StylisticSet5();
    public abstract virtual bool get_StylisticSet6();
    public abstract virtual bool get_StylisticSet7();
    public abstract virtual bool get_StylisticSet8();
    public abstract virtual bool get_StylisticSet9();
    public abstract virtual FontVariants get_Variants();
    protected void OnPropertiesChanged();
}
public class System.Windows.Media.TextFormatting.TextSimpleMarkerProperties : TextMarkerProperties {
    public double Offset { get; }
    public TextSource TextSource { get; }
    public TextSimpleMarkerProperties(TextMarkerStyle style, double offset, int autoNumberingIndex, TextParagraphProperties textParagraphProperties);
    public sealed virtual double get_Offset();
    public sealed virtual TextSource get_TextSource();
}
public abstract class System.Windows.Media.TextFormatting.TextSource : object {
    public double PixelsPerDip { get; public set; }
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
    public abstract virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int textSourceCharacterIndexLimit);
    public abstract virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
    public abstract virtual TextRun GetTextRun(int textSourceCharacterIndex);
}
public class System.Windows.Media.TextFormatting.TextSpan`1 : object {
    public int Length { get; }
    public T Value { get; }
    public TextSpan`1(int length, T value);
    public int get_Length();
    public T get_Value();
}
public enum System.Windows.Media.TextFormatting.TextTabAlignment : Enum {
    public int value__;
    public static TextTabAlignment Left;
    public static TextTabAlignment Center;
    public static TextTabAlignment Right;
    public static TextTabAlignment Character;
}
public class System.Windows.Media.TextFormatting.TextTabProperties : object {
    public int AligningCharacter { get; }
    public TextTabAlignment Alignment { get; }
    public double Location { get; }
    public int TabLeader { get; }
    public TextTabProperties(TextTabAlignment alignment, double location, int tabLeader, int aligningChar);
    public int get_AligningCharacter();
    public TextTabAlignment get_Alignment();
    public double get_Location();
    public int get_TabLeader();
}
public class System.Windows.Media.TextFormatting.TextTrailingCharacterEllipsis : TextCollapsingProperties {
    public TextCollapsingStyle Style { get; }
    public TextRun Symbol { get; }
    public double Width { get; }
    public TextTrailingCharacterEllipsis(double width, TextRunProperties textRunProperties);
    public sealed virtual TextCollapsingStyle get_Style();
    public sealed virtual TextRun get_Symbol();
    public sealed virtual double get_Width();
}
public class System.Windows.Media.TextFormatting.TextTrailingWordEllipsis : TextCollapsingProperties {
    public TextCollapsingStyle Style { get; }
    public TextRun Symbol { get; }
    public double Width { get; }
    public TextTrailingWordEllipsis(double width, TextRunProperties textRunProperties);
    public sealed virtual TextCollapsingStyle get_Style();
    public sealed virtual TextRun get_Symbol();
    public sealed virtual double get_Width();
}
public enum System.Windows.Media.TextHintingMode : Enum {
    public int value__;
    public static TextHintingMode Auto;
    public static TextHintingMode Fixed;
    public static TextHintingMode Animated;
}
public enum System.Windows.Media.TextRenderingMode : Enum {
    public int value__;
    public static TextRenderingMode Auto;
    public static TextRenderingMode Aliased;
    public static TextRenderingMode Grayscale;
    public static TextRenderingMode ClearType;
}
public abstract class System.Windows.Media.TileBrush : Brush {
    public static DependencyProperty AlignmentXProperty;
    public static DependencyProperty AlignmentYProperty;
    public static DependencyProperty StretchProperty;
    public static DependencyProperty TileModeProperty;
    public static DependencyProperty ViewboxProperty;
    public static DependencyProperty ViewboxUnitsProperty;
    public static DependencyProperty ViewportProperty;
    public static DependencyProperty ViewportUnitsProperty;
    public AlignmentX AlignmentX { get; public set; }
    public AlignmentY AlignmentY { get; public set; }
    public Stretch Stretch { get; public set; }
    public TileMode TileMode { get; public set; }
    public Rect Viewbox { get; public set; }
    public BrushMappingMode ViewboxUnits { get; public set; }
    public Rect Viewport { get; public set; }
    public BrushMappingMode ViewportUnits { get; public set; }
    public AlignmentX get_AlignmentX();
    public void set_AlignmentX(AlignmentX value);
    public AlignmentY get_AlignmentY();
    public void set_AlignmentY(AlignmentY value);
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public TileMode get_TileMode();
    public void set_TileMode(TileMode value);
    public Rect get_Viewbox();
    public void set_Viewbox(Rect value);
    public BrushMappingMode get_ViewboxUnits();
    public void set_ViewboxUnits(BrushMappingMode value);
    public Rect get_Viewport();
    public void set_Viewport(Rect value);
    public BrushMappingMode get_ViewportUnits();
    public void set_ViewportUnits(BrushMappingMode value);
    public TileBrush Clone();
    public TileBrush CloneCurrentValue();
    protected abstract virtual void GetContentBounds(Rect& contentBounds);
}
public enum System.Windows.Media.TileMode : Enum {
    public int value__;
    public static TileMode None;
    public static TileMode FlipX;
    public static TileMode FlipY;
    public static TileMode FlipXY;
    public static TileMode Tile;
}
public enum System.Windows.Media.ToleranceType : Enum {
    public int value__;
    public static ToleranceType Absolute;
    public static ToleranceType Relative;
}
[TypeConverterAttribute("System.Windows.Media.TransformConverter")]
[LocalizabilityAttribute("0")]
[ValueSerializerAttribute("System.Windows.Media.Converters.TransformValueSerializer")]
public abstract class System.Windows.Media.Transform : GeneralTransform {
    public static Transform Identity { get; }
    public GeneralTransform Inverse { get; }
    public Matrix Value { get; }
    public static Transform get_Identity();
    public virtual GeneralTransform get_Inverse();
    public abstract virtual Matrix get_Value();
    public Transform Clone();
    public Transform CloneCurrentValue();
    public static Transform Parse(string source);
    public virtual Rect TransformBounds(Rect rect);
    public virtual bool TryTransform(Point inPoint, Point& result);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.TransformCollection : Animatable {
    public int Count { get; }
    public Transform Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Transform>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public TransformCollection(IEnumerable`1<Transform> collection);
    public TransformCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual Transform get_Item(int index);
    public sealed virtual void set_Item(int index, Transform value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Transform>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Transform value);
    public sealed virtual void Clear();
    public TransformCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public TransformCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(Transform value);
    public sealed virtual void CopyTo(Transform[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Transform value);
    public sealed virtual void Insert(int index, Transform value);
    public sealed virtual bool Remove(Transform value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<Transform> System.Collections.Generic.IEnumerable<System.Windows.Media.Transform>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public class System.Windows.Media.TransformConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.TransformGroup : Transform {
    public static DependencyProperty ChildrenProperty;
    public TransformCollection Children { get; public set; }
    public Matrix Value { get; }
    public TransformCollection get_Children();
    public void set_Children(TransformCollection value);
    public virtual Matrix get_Value();
    public TransformGroup Clone();
    public TransformGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.TranslateTransform : Transform {
    public static DependencyProperty XProperty;
    public static DependencyProperty YProperty;
    public Matrix Value { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public TranslateTransform(double offsetX, double offsetY);
    public virtual Matrix get_Value();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public TranslateTransform Clone();
    public TranslateTransform CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Typeface : object {
    public double CapsHeight { get; }
    public LanguageSpecificStringDictionary FaceNames { get; }
    public FontFamily FontFamily { get; }
    public bool IsBoldSimulated { get; }
    public bool IsObliqueSimulated { get; }
    public FontStretch Stretch { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public FontStyle Style { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public FontWeight Weight { get; }
    public double XHeight { get; }
    public Typeface(string typefaceName);
    public Typeface(FontFamily fontFamily, FontStyle style, FontWeight weight, FontStretch stretch);
    public Typeface(FontFamily fontFamily, FontStyle style, FontWeight weight, FontStretch stretch, FontFamily fallbackFontFamily);
    public double get_CapsHeight();
    public LanguageSpecificStringDictionary get_FaceNames();
    public FontFamily get_FontFamily();
    public bool get_IsBoldSimulated();
    public bool get_IsObliqueSimulated();
    public FontStretch get_Stretch();
    public double get_StrikethroughPosition();
    public double get_StrikethroughThickness();
    public FontStyle get_Style();
    public double get_UnderlinePosition();
    public double get_UnderlineThickness();
    public FontWeight get_Weight();
    public double get_XHeight();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public bool TryGetGlyphTypeface(GlyphTypeface& glyphTypeface);
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.VectorCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.VectorCollectionValueSerializer")]
public class System.Windows.Media.VectorCollection : Freezable {
    public int Count { get; }
    public Vector Item { get; public set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Vector>.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public VectorCollection(IEnumerable`1<Vector> collection);
    public VectorCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual Vector get_Item(int index);
    public sealed virtual void set_Item(int index, Vector value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Vector>.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Vector value);
    public sealed virtual void Clear();
    public VectorCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public VectorCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(Vector value);
    public sealed virtual void CopyTo(Vector[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(Vector value);
    public sealed virtual void Insert(int index, Vector value);
    public static VectorCollection Parse(string source);
    public sealed virtual bool Remove(Vector value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<Vector> System.Collections.Generic.IEnumerable<System.Windows.Vector>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Media.VectorCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.VideoDrawing : Drawing {
    public static DependencyProperty PlayerProperty;
    public static DependencyProperty RectProperty;
    public MediaPlayer Player { get; public set; }
    public Rect Rect { get; public set; }
    public MediaPlayer get_Player();
    public void set_Player(MediaPlayer value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    public VideoDrawing Clone();
    public VideoDrawing CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Visual : DependencyObject {
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected internal BitmapEffect VisualBitmapEffect { get; protected set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected internal BitmapEffectInput VisualBitmapEffectInput { get; protected set; }
    protected internal BitmapScalingMode VisualBitmapScalingMode { get; protected set; }
    protected internal CacheMode VisualCacheMode { get; protected set; }
    protected int VisualChildrenCount { get; }
    protected internal ClearTypeHint VisualClearTypeHint { get; protected internal set; }
    protected internal Geometry VisualClip { get; protected set; }
    protected internal EdgeMode VisualEdgeMode { get; protected set; }
    protected internal Effect VisualEffect { get; protected set; }
    protected internal Vector VisualOffset { get; protected set; }
    protected internal double VisualOpacity { get; protected set; }
    protected internal Brush VisualOpacityMask { get; protected set; }
    protected DependencyObject VisualParent { get; }
    protected internal Nullable`1<Rect> VisualScrollableAreaClip { get; protected set; }
    protected internal TextHintingMode VisualTextHintingMode { get; protected internal set; }
    protected internal TextRenderingMode VisualTextRenderingMode { get; protected internal set; }
    protected internal Transform VisualTransform { get; protected set; }
    protected internal DoubleCollection VisualXSnappingGuidelines { get; protected set; }
    protected internal DoubleCollection VisualYSnappingGuidelines { get; protected set; }
    protected internal BitmapEffect get_VisualBitmapEffect();
    protected void set_VisualBitmapEffect(BitmapEffect value);
    protected internal BitmapEffectInput get_VisualBitmapEffectInput();
    protected void set_VisualBitmapEffectInput(BitmapEffectInput value);
    protected internal BitmapScalingMode get_VisualBitmapScalingMode();
    protected void set_VisualBitmapScalingMode(BitmapScalingMode value);
    protected internal CacheMode get_VisualCacheMode();
    protected void set_VisualCacheMode(CacheMode value);
    protected virtual int get_VisualChildrenCount();
    protected internal ClearTypeHint get_VisualClearTypeHint();
    protected internal void set_VisualClearTypeHint(ClearTypeHint value);
    protected internal Geometry get_VisualClip();
    protected void set_VisualClip(Geometry value);
    protected internal EdgeMode get_VisualEdgeMode();
    protected void set_VisualEdgeMode(EdgeMode value);
    protected internal Effect get_VisualEffect();
    protected void set_VisualEffect(Effect value);
    protected internal Vector get_VisualOffset();
    protected void set_VisualOffset(Vector value);
    protected internal double get_VisualOpacity();
    protected void set_VisualOpacity(double value);
    protected internal Brush get_VisualOpacityMask();
    protected void set_VisualOpacityMask(Brush value);
    protected DependencyObject get_VisualParent();
    protected internal Nullable`1<Rect> get_VisualScrollableAreaClip();
    protected void set_VisualScrollableAreaClip(Nullable`1<Rect> value);
    protected internal TextHintingMode get_VisualTextHintingMode();
    protected internal void set_VisualTextHintingMode(TextHintingMode value);
    protected internal TextRenderingMode get_VisualTextRenderingMode();
    protected internal void set_VisualTextRenderingMode(TextRenderingMode value);
    protected internal Transform get_VisualTransform();
    protected void set_VisualTransform(Transform value);
    protected internal DoubleCollection get_VisualXSnappingGuidelines();
    protected void set_VisualXSnappingGuidelines(DoubleCollection value);
    protected internal DoubleCollection get_VisualYSnappingGuidelines();
    protected void set_VisualYSnappingGuidelines(DoubleCollection value);
    protected void AddVisualChild(Visual child);
    public DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual);
    protected virtual Visual GetVisualChild(int index);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    public bool IsAncestorOf(DependencyObject descendant);
    public bool IsDescendantOf(DependencyObject ancestor);
    protected virtual void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    public Point PointFromScreen(Point point);
    public Point PointToScreen(Point point);
    protected void RemoveVisualChild(Visual child);
    public GeneralTransform2DTo3D TransformToAncestor(Visual3D ancestor);
    public GeneralTransform TransformToAncestor(Visual ancestor);
    public GeneralTransform TransformToDescendant(Visual descendant);
    public GeneralTransform TransformToVisual(Visual visual);
}
public class System.Windows.Media.VisualBrush : TileBrush {
    public static DependencyProperty AutoLayoutContentProperty;
    public static DependencyProperty VisualProperty;
    public bool AutoLayoutContent { get; public set; }
    public Visual Visual { get; public set; }
    public VisualBrush(Visual visual);
    public bool get_AutoLayoutContent();
    public void set_AutoLayoutContent(bool value);
    public Visual get_Visual();
    public void set_Visual(Visual value);
    public VisualBrush Clone();
    public VisualBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetContentBounds(Rect& contentBounds);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.VisualCollection : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Visual Item { get; public set; }
    public object SyncRoot { get; }
    public VisualCollection(Visual parent);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public Visual get_Item(int index);
    public void set_Item(int index, Visual value);
    public sealed virtual object get_SyncRoot();
    public int Add(Visual visual);
    public void Clear();
    public bool Contains(Visual visual);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Visual[] array, int index);
    public Enumerator GetEnumerator();
    public int IndexOf(Visual visual);
    public void Insert(int index, Visual visual);
    public void Remove(Visual visual);
    public void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Media.VisualTarget : CompositionTarget {
    public Matrix TransformFromDevice { get; }
    public Matrix TransformToDevice { get; }
    public VisualTarget(HostVisual hostVisual);
    public virtual Matrix get_TransformFromDevice();
    public virtual Matrix get_TransformToDevice();
    public virtual void Dispose();
}
public static class System.Windows.Media.VisualTreeHelper : object {
    public static BitmapEffect GetBitmapEffect(Visual reference);
    public static BitmapEffectInput GetBitmapEffectInput(Visual reference);
    public static CacheMode GetCacheMode(Visual reference);
    public static DependencyObject GetChild(DependencyObject reference, int childIndex);
    public static int GetChildrenCount(DependencyObject reference);
    public static Geometry GetClip(Visual reference);
    public static Rect3D GetContentBounds(Visual3D reference);
    public static Rect GetContentBounds(Visual reference);
    public static Rect3D GetDescendantBounds(Visual3D reference);
    public static Rect GetDescendantBounds(Visual reference);
    public static DpiScale GetDpi(Visual visual);
    public static DrawingGroup GetDrawing(Visual reference);
    public static EdgeMode GetEdgeMode(Visual reference);
    public static Effect GetEffect(Visual reference);
    public static Vector GetOffset(Visual reference);
    public static double GetOpacity(Visual reference);
    public static Brush GetOpacityMask(Visual reference);
    public static DependencyObject GetParent(DependencyObject reference);
    public static Transform GetTransform(Visual reference);
    public static DoubleCollection GetXSnappingGuidelines(Visual reference);
    public static DoubleCollection GetYSnappingGuidelines(Visual reference);
    public static void HitTest(Visual3D reference, HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters3D hitTestParameters);
    public static void HitTest(Visual reference, HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    public static HitTestResult HitTest(Visual reference, Point point);
    public static void SetRootDpi(Visual visual, DpiScale dpiInfo);
}
public enum System.Windows.Modifiability : Enum {
    public int value__;
    public static Modifiability Unmodifiable;
    public static Modifiability Modifiable;
    public static Modifiability Inherit;
}
public static class System.Windows.Navigation.BaseUriHelper : object {
    public static DependencyProperty BaseUriProperty;
    public static Uri GetBaseUri(DependencyObject element);
}
public abstract class System.Windows.PresentationSource : DispatcherObject {
    public CompositionTarget CompositionTarget { get; }
    public static IEnumerable CurrentSources { get; }
    public bool IsDisposed { get; }
    public Visual RootVisual { get; public set; }
    public CompositionTarget get_CompositionTarget();
    public static IEnumerable get_CurrentSources();
    public abstract virtual bool get_IsDisposed();
    public abstract virtual Visual get_RootVisual();
    public abstract virtual void set_RootVisual(Visual value);
    public void add_ContentRendered(EventHandler value);
    public void remove_ContentRendered(EventHandler value);
    protected void AddSource();
    public static void AddSourceChangedHandler(IInputElement element, SourceChangedEventHandler handler);
    protected void ClearContentRenderedListeners();
    public static PresentationSource FromDependencyObject(DependencyObject dependencyObject);
    public static PresentationSource FromVisual(Visual visual);
    protected abstract virtual CompositionTarget GetCompositionTargetCore();
    protected void RemoveSource();
    public static void RemoveSourceChangedHandler(IInputElement e, SourceChangedEventHandler handler);
    protected void RootChanged(Visual oldRoot, Visual newRoot);
}
public class System.Windows.QueryContinueDragEventArgs : RoutedEventArgs {
    public DragAction Action { get; public set; }
    public bool EscapePressed { get; }
    public DragDropKeyStates KeyStates { get; }
    public DragAction get_Action();
    public void set_Action(DragAction value);
    public bool get_EscapePressed();
    public DragDropKeyStates get_KeyStates();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.QueryContinueDragEventHandler : MulticastDelegate {
    public QueryContinueDragEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, QueryContinueDragEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, QueryContinueDragEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Readability : Enum {
    public int value__;
    public static Readability Unreadable;
    public static Readability Readable;
    public static Readability Inherit;
}
[AttributeUsageAttribute("1")]
public class System.Windows.Resources.AssemblyAssociatedContentFileAttribute : Attribute {
    public string RelativeContentFilePath { get; }
    public AssemblyAssociatedContentFileAttribute(string relativeContentFilePath);
    public string get_RelativeContentFilePath();
}
[TypeConverterAttribute("System.Windows.Markup.RoutedEventConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[ValueSerializerAttribute("System.Windows.Markup.RoutedEventValueSerializer, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.RoutedEvent : object {
    public Type HandlerType { get; }
    public string Name { get; }
    public Type OwnerType { get; }
    public RoutingStrategy RoutingStrategy { get; }
    public Type get_HandlerType();
    public string get_Name();
    public Type get_OwnerType();
    public RoutingStrategy get_RoutingStrategy();
    public RoutedEvent AddOwner(Type ownerType);
    public virtual string ToString();
}
public class System.Windows.RoutedEventArgs : EventArgs {
    public bool Handled { get; public set; }
    public object OriginalSource { get; }
    public RoutedEvent RoutedEvent { get; public set; }
    public object Source { get; public set; }
    public RoutedEventArgs(RoutedEvent routedEvent);
    public RoutedEventArgs(RoutedEvent routedEvent, object source);
    public bool get_Handled();
    public void set_Handled(bool value);
    public object get_OriginalSource();
    public RoutedEvent get_RoutedEvent();
    public void set_RoutedEvent(RoutedEvent value);
    public object get_Source();
    public void set_Source(object value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    protected virtual void OnSetSource(object source);
}
public class System.Windows.RoutedEventHandler : MulticastDelegate {
    public RoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.RoutedEventHandlerInfo : ValueType {
    public Delegate Handler { get; }
    public bool InvokeHandledEventsToo { get; }
    public Delegate get_Handler();
    public bool get_InvokeHandledEventsToo();
    public virtual bool Equals(object obj);
    public bool Equals(RoutedEventHandlerInfo handlerInfo);
    public virtual int GetHashCode();
    public static bool op_Equality(RoutedEventHandlerInfo handlerInfo1, RoutedEventHandlerInfo handlerInfo2);
    public static bool op_Inequality(RoutedEventHandlerInfo handlerInfo1, RoutedEventHandlerInfo handlerInfo2);
}
public enum System.Windows.RoutingStrategy : Enum {
    public int value__;
    public static RoutingStrategy Tunnel;
    public static RoutingStrategy Bubble;
    public static RoutingStrategy Direct;
}
public class System.Windows.SizeChangedInfo : object {
    public bool HeightChanged { get; }
    public Size NewSize { get; }
    public Size PreviousSize { get; }
    public bool WidthChanged { get; }
    public SizeChangedInfo(UIElement element, Size previousSize, bool widthChanged, bool heightChanged);
    public bool get_HeightChanged();
    public Size get_NewSize();
    public Size get_PreviousSize();
    public bool get_WidthChanged();
}
[LocalizabilityAttribute("0")]
public enum System.Windows.SizeToContent : Enum {
    public int value__;
    public static SizeToContent Manual;
    public static SizeToContent Width;
    public static SizeToContent Height;
    public static SizeToContent WidthAndHeight;
}
public class System.Windows.SourceChangedEventArgs : RoutedEventArgs {
    public IInputElement Element { get; }
    public PresentationSource NewSource { get; }
    public IInputElement OldParent { get; }
    public PresentationSource OldSource { get; }
    public SourceChangedEventArgs(PresentationSource oldSource, PresentationSource newSource);
    public SourceChangedEventArgs(PresentationSource oldSource, PresentationSource newSource, IInputElement element, IInputElement oldParent);
    public IInputElement get_Element();
    public PresentationSource get_NewSource();
    public IInputElement get_OldParent();
    public PresentationSource get_OldSource();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.SourceChangedEventHandler : MulticastDelegate {
    public SourceChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SourceChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SourceChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.StrokeCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextAlignment : Enum {
    public int value__;
    public static TextAlignment Left;
    public static TextAlignment Right;
    public static TextAlignment Center;
    public static TextAlignment Justify;
}
public enum System.Windows.TextDataFormat : Enum {
    public int value__;
    public static TextDataFormat Text;
    public static TextDataFormat UnicodeText;
    public static TextDataFormat Rtf;
    public static TextDataFormat Html;
    public static TextDataFormat CommaSeparatedValue;
    public static TextDataFormat Xaml;
}
[LocalizabilityAttribute("0")]
public class System.Windows.TextDecoration : Animatable {
    public static DependencyProperty LocationProperty;
    public static DependencyProperty PenOffsetProperty;
    public static DependencyProperty PenOffsetUnitProperty;
    public static DependencyProperty PenProperty;
    public static DependencyProperty PenThicknessUnitProperty;
    public TextDecorationLocation Location { get; public set; }
    public Pen Pen { get; public set; }
    public double PenOffset { get; public set; }
    public TextDecorationUnit PenOffsetUnit { get; public set; }
    public TextDecorationUnit PenThicknessUnit { get; public set; }
    public TextDecoration(TextDecorationLocation location, Pen pen, double penOffset, TextDecorationUnit penOffsetUnit, TextDecorationUnit penThicknessUnit);
    public TextDecorationLocation get_Location();
    public void set_Location(TextDecorationLocation value);
    public Pen get_Pen();
    public void set_Pen(Pen value);
    public double get_PenOffset();
    public void set_PenOffset(double value);
    public TextDecorationUnit get_PenOffsetUnit();
    public void set_PenOffsetUnit(TextDecorationUnit value);
    public TextDecorationUnit get_PenThicknessUnit();
    public void set_PenThicknessUnit(TextDecorationUnit value);
    public TextDecoration Clone();
    public TextDecoration CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.TextDecorationCollectionConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.TextDecorationCollection : Animatable {
    public int Count { get; }
    public TextDecoration Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Windows.TextDecoration>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public TextDecorationCollection(IEnumerable`1<TextDecoration> collection);
    public TextDecorationCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual TextDecoration get_Item(int index);
    public sealed virtual void set_Item(int index, TextDecoration value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.TextDecoration>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    [CLSCompliantAttribute("False")]
public void Add(IEnumerable`1<TextDecoration> textDecorations);
    public sealed virtual void Add(TextDecoration value);
    public sealed virtual void Clear();
    public TextDecorationCollection Clone();
    protected virtual void CloneCore(Freezable source);
    public TextDecorationCollection CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable source);
    public sealed virtual bool Contains(TextDecoration value);
    public sealed virtual void CopyTo(TextDecoration[] array, int index);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public Enumerator GetEnumerator();
    public sealed virtual int IndexOf(TextDecoration value);
    public sealed virtual void Insert(int index, TextDecoration value);
    public sealed virtual bool Remove(TextDecoration value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<TextDecoration> System.Collections.Generic.IEnumerable<System.Windows.TextDecoration>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public bool TryRemove(IEnumerable`1<TextDecoration> textDecorations, TextDecorationCollection& result);
}
public class System.Windows.TextDecorationCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object input);
    public static TextDecorationCollection ConvertFromString(string text);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.TextDecorationLocation : Enum {
    public int value__;
    public static TextDecorationLocation Underline;
    public static TextDecorationLocation OverLine;
    public static TextDecorationLocation Strikethrough;
    public static TextDecorationLocation Baseline;
}
public static class System.Windows.TextDecorations : object {
    public static TextDecorationCollection Baseline { get; }
    public static TextDecorationCollection OverLine { get; }
    public static TextDecorationCollection Strikethrough { get; }
    public static TextDecorationCollection Underline { get; }
    public static TextDecorationCollection get_Baseline();
    public static TextDecorationCollection get_OverLine();
    public static TextDecorationCollection get_Strikethrough();
    public static TextDecorationCollection get_Underline();
}
public enum System.Windows.TextDecorationUnit : Enum {
    public int value__;
    public static TextDecorationUnit FontRecommended;
    public static TextDecorationUnit FontRenderingEmSize;
    public static TextDecorationUnit Pixel;
}
public enum System.Windows.TextMarkerStyle : Enum {
    public int value__;
    public static TextMarkerStyle None;
    public static TextMarkerStyle Disc;
    public static TextMarkerStyle Circle;
    public static TextMarkerStyle Square;
    public static TextMarkerStyle Box;
    public static TextMarkerStyle LowerRoman;
    public static TextMarkerStyle UpperRoman;
    public static TextMarkerStyle LowerLatin;
    public static TextMarkerStyle UpperLatin;
    public static TextMarkerStyle Decimal;
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextTrimming : Enum {
    public int value__;
    public static TextTrimming None;
    public static TextTrimming CharacterEllipsis;
    public static TextTrimming WordEllipsis;
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextWrapping : Enum {
    public int value__;
    public static TextWrapping WrapWithOverflow;
    public static TextWrapping NoWrap;
    public static TextWrapping Wrap;
}
[UidPropertyAttribute("Uid")]
public class System.Windows.UIElement : Visual {
    public static DependencyProperty AllowDropProperty;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    public static DependencyProperty AreAnyTouchesOverProperty;
    public static DependencyProperty BitmapEffectInputProperty;
    public static DependencyProperty BitmapEffectProperty;
    public static DependencyProperty CacheModeProperty;
    public static DependencyProperty ClipProperty;
    public static DependencyProperty ClipToBoundsProperty;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent DropEvent;
    public static DependencyProperty EffectProperty;
    public static DependencyProperty FocusableProperty;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty IsFocusedProperty;
    public static DependencyProperty IsHitTestVisibleProperty;
    public static DependencyProperty IsKeyboardFocusedProperty;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    public static DependencyProperty IsManipulationEnabledProperty;
    public static DependencyProperty IsMouseCapturedProperty;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    public static DependencyProperty IsMouseOverProperty;
    public static DependencyProperty IsStylusCapturedProperty;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    public static DependencyProperty IsStylusOverProperty;
    public static DependencyProperty IsVisibleProperty;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent LostFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent ManipulationBoundaryFeedbackEvent;
    public static RoutedEvent ManipulationCompletedEvent;
    public static RoutedEvent ManipulationDeltaEvent;
    public static RoutedEvent ManipulationInertiaStartingEvent;
    public static RoutedEvent ManipulationStartedEvent;
    public static RoutedEvent ManipulationStartingEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent MouseWheelEvent;
    public static DependencyProperty OpacityMaskProperty;
    public static DependencyProperty OpacityProperty;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent QueryCursorEvent;
    public static DependencyProperty RenderTransformOriginProperty;
    public static DependencyProperty RenderTransformProperty;
    public static DependencyProperty SnapsToDevicePixelsProperty;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent TouchUpEvent;
    public static DependencyProperty UidProperty;
    public static DependencyProperty VisibilityProperty;
    public bool AllowDrop { get; public set; }
    public bool AreAnyTouchesCaptured { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesOver { get; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public CacheMode CacheMode { get; public set; }
    public Geometry Clip { get; public set; }
    public bool ClipToBounds { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    public Size DesiredSize { get; }
    public Effect Effect { get; public set; }
    public bool Focusable { get; public set; }
    public bool HasAnimatedProperties { get; }
    protected internal bool HasEffectiveKeyboardFocus { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    public bool IsArrangeValid { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool IsFocused { get; }
    public bool IsHitTestVisible { get; public set; }
    public bool IsInputMethodEnabled { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsManipulationEnabled { get; public set; }
    public bool IsMeasureValid { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusOver { get; }
    public bool IsVisible { get; }
    [LocalizabilityAttribute("0")]
public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("PersistId is an obsolete property and may be removed in a future release.  The value of this property is not defined.")]
public int PersistId { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public Size RenderSize { get; public set; }
    public Transform RenderTransform { get; public set; }
    public Point RenderTransformOrigin { get; public set; }
    public bool SnapsToDevicePixels { get; public set; }
    protected StylusPlugInCollection StylusPlugIns { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    public string Uid { get; public set; }
    [LocalizabilityAttribute("0")]
public Visibility Visibility { get; public set; }
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    public bool get_AreAnyTouchesCaptured();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesOver();
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public bool get_ClipToBounds();
    public void set_ClipToBounds(bool value);
    public CommandBindingCollection get_CommandBindings();
    public Size get_DesiredSize();
    public Effect get_Effect();
    public void set_Effect(Effect value);
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public sealed virtual bool get_HasAnimatedProperties();
    protected internal virtual bool get_HasEffectiveKeyboardFocus();
    public InputBindingCollection get_InputBindings();
    public bool get_IsArrangeValid();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    protected virtual bool get_IsEnabledCore();
    public bool get_IsFocused();
    public bool get_IsHitTestVisible();
    public void set_IsHitTestVisible(bool value);
    public bool get_IsInputMethodEnabled();
    public sealed virtual bool get_IsKeyboardFocused();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public bool get_IsManipulationEnabled();
    public void set_IsManipulationEnabled(bool value);
    public bool get_IsMeasureValid();
    public sealed virtual bool get_IsMouseCaptured();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsMouseDirectlyOver();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusCaptured();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    public sealed virtual bool get_IsStylusOver();
    public bool get_IsVisible();
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public int get_PersistId();
    public Size get_RenderSize();
    public void set_RenderSize(Size value);
    public Transform get_RenderTransform();
    public void set_RenderTransform(Transform value);
    public Point get_RenderTransformOrigin();
    public void set_RenderTransformOrigin(Point value);
    public bool get_SnapsToDevicePixels();
    public void set_SnapsToDevicePixels(bool value);
    protected StylusPlugInCollection get_StylusPlugIns();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public string get_Uid();
    public void set_Uid(string value);
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    public void add_DragEnter(DragEventHandler value);
    public void remove_DragEnter(DragEventHandler value);
    public void add_DragLeave(DragEventHandler value);
    public void remove_DragLeave(DragEventHandler value);
    public void add_DragOver(DragEventHandler value);
    public void remove_DragOver(DragEventHandler value);
    public void add_Drop(DragEventHandler value);
    public void remove_Drop(DragEventHandler value);
    public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void add_GiveFeedback(GiveFeedbackEventHandler value);
    public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    public void add_GotFocus(RoutedEventHandler value);
    public void remove_GotFocus(RoutedEventHandler value);
    public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    public sealed virtual void add_KeyDown(KeyEventHandler value);
    public sealed virtual void remove_KeyDown(KeyEventHandler value);
    public sealed virtual void add_KeyUp(KeyEventHandler value);
    public sealed virtual void remove_KeyUp(KeyEventHandler value);
    public void add_LayoutUpdated(EventHandler value);
    public void remove_LayoutUpdated(EventHandler value);
    public void add_LostFocus(RoutedEventHandler value);
    public void remove_LostFocus(RoutedEventHandler value);
    public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void add_ManipulationBoundaryFeedback(EventHandler`1<ManipulationBoundaryFeedbackEventArgs> value);
    public void remove_ManipulationBoundaryFeedback(EventHandler`1<ManipulationBoundaryFeedbackEventArgs> value);
    public void add_ManipulationCompleted(EventHandler`1<ManipulationCompletedEventArgs> value);
    public void remove_ManipulationCompleted(EventHandler`1<ManipulationCompletedEventArgs> value);
    public void add_ManipulationDelta(EventHandler`1<ManipulationDeltaEventArgs> value);
    public void remove_ManipulationDelta(EventHandler`1<ManipulationDeltaEventArgs> value);
    public void add_ManipulationInertiaStarting(EventHandler`1<ManipulationInertiaStartingEventArgs> value);
    public void remove_ManipulationInertiaStarting(EventHandler`1<ManipulationInertiaStartingEventArgs> value);
    public void add_ManipulationStarted(EventHandler`1<ManipulationStartedEventArgs> value);
    public void remove_ManipulationStarted(EventHandler`1<ManipulationStartedEventArgs> value);
    public void add_ManipulationStarting(EventHandler`1<ManipulationStartingEventArgs> value);
    public void remove_ManipulationStarting(EventHandler`1<ManipulationStartingEventArgs> value);
    public void add_MouseDown(MouseButtonEventHandler value);
    public void remove_MouseDown(MouseButtonEventHandler value);
    public sealed virtual void add_MouseEnter(MouseEventHandler value);
    public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    public sealed virtual void add_MouseLeave(MouseEventHandler value);
    public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void add_MouseMove(MouseEventHandler value);
    public sealed virtual void remove_MouseMove(MouseEventHandler value);
    public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    public void add_MouseUp(MouseButtonEventHandler value);
    public void remove_MouseUp(MouseButtonEventHandler value);
    public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    public void add_PreviewDragEnter(DragEventHandler value);
    public void remove_PreviewDragEnter(DragEventHandler value);
    public void add_PreviewDragLeave(DragEventHandler value);
    public void remove_PreviewDragLeave(DragEventHandler value);
    public void add_PreviewDragOver(DragEventHandler value);
    public void remove_PreviewDragOver(DragEventHandler value);
    public void add_PreviewDrop(DragEventHandler value);
    public void remove_PreviewDrop(DragEventHandler value);
    public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public void add_PreviewMouseDown(MouseButtonEventHandler value);
    public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public void add_PreviewMouseUp(MouseButtonEventHandler value);
    public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void add_QueryCursor(QueryCursorEventHandler value);
    public void remove_QueryCursor(QueryCursorEventHandler value);
    public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    public sealed virtual void add_StylusEnter(StylusEventHandler value);
    public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void add_StylusInRange(StylusEventHandler value);
    public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    public sealed virtual void add_StylusLeave(StylusEventHandler value);
    public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    public sealed virtual void add_StylusMove(StylusEventHandler value);
    public sealed virtual void remove_StylusMove(StylusEventHandler value);
    public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void add_StylusUp(StylusEventHandler value);
    public sealed virtual void remove_StylusUp(StylusEventHandler value);
    public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public void Arrange(Rect finalRect);
    protected virtual void ArrangeCore(Rect finalRect);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual bool CaptureMouse();
    public sealed virtual bool CaptureStylus();
    public bool CaptureTouch(TouchDevice touchDevice);
    public sealed virtual bool Focus();
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    protected internal virtual DependencyObject GetUIParentCore();
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    public IInputElement InputHitTest(Point point);
    public void InvalidateArrange();
    public void InvalidateMeasure();
    public void InvalidateVisual();
    public void Measure(Size availableSize);
    protected virtual Size MeasureCore(Size availableSize);
    public virtual bool MoveFocus(TraversalRequest request);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    protected virtual void OnChildDesiredSizeChanged(UIElement child);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnDragEnter(DragEventArgs e);
    protected virtual void OnDragLeave(DragEventArgs e);
    protected virtual void OnDragOver(DragEventArgs e);
    protected virtual void OnDrop(DragEventArgs e);
    protected virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnGotMouseCapture(MouseEventArgs e);
    protected virtual void OnGotStylusCapture(StylusEventArgs e);
    protected virtual void OnGotTouchCapture(TouchEventArgs e);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    protected virtual void OnLostStylusCapture(StylusEventArgs e);
    protected virtual void OnLostTouchCapture(TouchEventArgs e);
    protected virtual void OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs e);
    protected virtual void OnManipulationCompleted(ManipulationCompletedEventArgs e);
    protected virtual void OnManipulationDelta(ManipulationDeltaEventArgs e);
    protected virtual void OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs e);
    protected virtual void OnManipulationStarted(ManipulationStartedEventArgs e);
    protected virtual void OnManipulationStarting(ManipulationStartingEventArgs e);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnPreviewDragEnter(DragEventArgs e);
    protected virtual void OnPreviewDragLeave(DragEventArgs e);
    protected virtual void OnPreviewDragOver(DragEventArgs e);
    protected virtual void OnPreviewDrop(DragEventArgs e);
    protected virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    protected virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnPreviewKeyUp(KeyEventArgs e);
    protected virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseMove(MouseEventArgs e);
    protected virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    protected virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    protected virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    protected virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    protected virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    protected virtual void OnPreviewStylusInRange(StylusEventArgs e);
    protected virtual void OnPreviewStylusMove(StylusEventArgs e);
    protected virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    protected virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected virtual void OnPreviewStylusUp(StylusEventArgs e);
    protected virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    protected virtual void OnPreviewTouchDown(TouchEventArgs e);
    protected virtual void OnPreviewTouchMove(TouchEventArgs e);
    protected virtual void OnPreviewTouchUp(TouchEventArgs e);
    protected virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    protected virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected virtual void OnRender(DrawingContext drawingContext);
    protected internal virtual void OnRenderSizeChanged(SizeChangedInfo info);
    protected virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    protected virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    protected virtual void OnStylusDown(StylusDownEventArgs e);
    protected virtual void OnStylusEnter(StylusEventArgs e);
    protected virtual void OnStylusInAirMove(StylusEventArgs e);
    protected virtual void OnStylusInRange(StylusEventArgs e);
    protected virtual void OnStylusLeave(StylusEventArgs e);
    protected virtual void OnStylusMove(StylusEventArgs e);
    protected virtual void OnStylusOutOfRange(StylusEventArgs e);
    protected virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected virtual void OnStylusUp(StylusEventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void OnTouchDown(TouchEventArgs e);
    protected virtual void OnTouchEnter(TouchEventArgs e);
    protected virtual void OnTouchLeave(TouchEventArgs e);
    protected virtual void OnTouchMove(TouchEventArgs e);
    protected virtual void OnTouchUp(TouchEventArgs e);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    public void ReleaseAllTouchCaptures();
    public sealed virtual void ReleaseMouseCapture();
    public sealed virtual void ReleaseStylusCapture();
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
    public Point TranslatePoint(Point point, UIElement relativeTo);
    public void UpdateLayout();
}
public abstract class System.Windows.UIElement3D : Visual3D {
    public static DependencyProperty AllowDropProperty;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    public static DependencyProperty AreAnyTouchesOverProperty;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent DropEvent;
    public static DependencyProperty FocusableProperty;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty IsFocusedProperty;
    public static DependencyProperty IsHitTestVisibleProperty;
    public static DependencyProperty IsKeyboardFocusedProperty;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    public static DependencyProperty IsMouseCapturedProperty;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    public static DependencyProperty IsMouseOverProperty;
    public static DependencyProperty IsStylusCapturedProperty;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    public static DependencyProperty IsStylusOverProperty;
    public static DependencyProperty IsVisibleProperty;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent LostFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent QueryCursorEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent TouchUpEvent;
    public static DependencyProperty VisibilityProperty;
    public bool AllowDrop { get; public set; }
    public bool AreAnyTouchesCaptured { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesOver { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    public bool Focusable { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool IsFocused { get; }
    public bool IsHitTestVisible { get; public set; }
    public bool IsInputMethodEnabled { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusOver { get; }
    public bool IsVisible { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    [LocalizabilityAttribute("0")]
public Visibility Visibility { get; public set; }
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    public bool get_AreAnyTouchesCaptured();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesOver();
    public CommandBindingCollection get_CommandBindings();
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public InputBindingCollection get_InputBindings();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    protected virtual bool get_IsEnabledCore();
    public bool get_IsFocused();
    public bool get_IsHitTestVisible();
    public void set_IsHitTestVisible(bool value);
    public bool get_IsInputMethodEnabled();
    public sealed virtual bool get_IsKeyboardFocused();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public sealed virtual bool get_IsMouseCaptured();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsMouseDirectlyOver();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusCaptured();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    public sealed virtual bool get_IsStylusOver();
    public bool get_IsVisible();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    public void add_DragEnter(DragEventHandler value);
    public void remove_DragEnter(DragEventHandler value);
    public void add_DragLeave(DragEventHandler value);
    public void remove_DragLeave(DragEventHandler value);
    public void add_DragOver(DragEventHandler value);
    public void remove_DragOver(DragEventHandler value);
    public void add_Drop(DragEventHandler value);
    public void remove_Drop(DragEventHandler value);
    public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void add_GiveFeedback(GiveFeedbackEventHandler value);
    public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    public void add_GotFocus(RoutedEventHandler value);
    public void remove_GotFocus(RoutedEventHandler value);
    public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void add_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    public sealed virtual void add_KeyDown(KeyEventHandler value);
    public sealed virtual void remove_KeyDown(KeyEventHandler value);
    public sealed virtual void add_KeyUp(KeyEventHandler value);
    public sealed virtual void remove_KeyUp(KeyEventHandler value);
    public void add_LostFocus(RoutedEventHandler value);
    public void remove_LostFocus(RoutedEventHandler value);
    public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void add_MouseDown(MouseButtonEventHandler value);
    public void remove_MouseDown(MouseButtonEventHandler value);
    public sealed virtual void add_MouseEnter(MouseEventHandler value);
    public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    public sealed virtual void add_MouseLeave(MouseEventHandler value);
    public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void add_MouseMove(MouseEventHandler value);
    public sealed virtual void remove_MouseMove(MouseEventHandler value);
    public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    public void add_MouseUp(MouseButtonEventHandler value);
    public void remove_MouseUp(MouseButtonEventHandler value);
    public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    public void add_PreviewDragEnter(DragEventHandler value);
    public void remove_PreviewDragEnter(DragEventHandler value);
    public void add_PreviewDragLeave(DragEventHandler value);
    public void remove_PreviewDragLeave(DragEventHandler value);
    public void add_PreviewDragOver(DragEventHandler value);
    public void remove_PreviewDragOver(DragEventHandler value);
    public void add_PreviewDrop(DragEventHandler value);
    public void remove_PreviewDrop(DragEventHandler value);
    public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public void add_PreviewMouseDown(MouseButtonEventHandler value);
    public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public void add_PreviewMouseUp(MouseButtonEventHandler value);
    public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void add_QueryCursor(QueryCursorEventHandler value);
    public void remove_QueryCursor(QueryCursorEventHandler value);
    public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    public sealed virtual void add_StylusEnter(StylusEventHandler value);
    public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void add_StylusInRange(StylusEventHandler value);
    public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    public sealed virtual void add_StylusLeave(StylusEventHandler value);
    public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    public sealed virtual void add_StylusMove(StylusEventHandler value);
    public sealed virtual void remove_StylusMove(StylusEventHandler value);
    public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void add_StylusUp(StylusEventHandler value);
    public sealed virtual void remove_StylusUp(StylusEventHandler value);
    public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    public sealed virtual bool CaptureMouse();
    public sealed virtual bool CaptureStylus();
    public bool CaptureTouch(TouchDevice touchDevice);
    public sealed virtual bool Focus();
    protected internal DependencyObject GetUIParentCore();
    public void InvalidateModel();
    public virtual bool MoveFocus(TraversalRequest request);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected internal virtual void OnDragEnter(DragEventArgs e);
    protected internal virtual void OnDragLeave(DragEventArgs e);
    protected internal virtual void OnDragOver(DragEventArgs e);
    protected internal virtual void OnDrop(DragEventArgs e);
    protected internal virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected internal virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnGotMouseCapture(MouseEventArgs e);
    protected internal virtual void OnGotStylusCapture(StylusEventArgs e);
    protected internal virtual void OnGotTouchCapture(TouchEventArgs e);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected internal virtual void OnKeyDown(KeyEventArgs e);
    protected internal virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    protected internal virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnLostMouseCapture(MouseEventArgs e);
    protected internal virtual void OnLostStylusCapture(StylusEventArgs e);
    protected internal virtual void OnLostTouchCapture(TouchEventArgs e);
    protected internal virtual void OnMouseDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseEnter(MouseEventArgs e);
    protected internal virtual void OnMouseLeave(MouseEventArgs e);
    protected internal virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnMouseMove(MouseEventArgs e);
    protected internal virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnMouseUp(MouseButtonEventArgs e);
    protected internal virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected internal virtual void OnPreviewDragEnter(DragEventArgs e);
    protected internal virtual void OnPreviewDragLeave(DragEventArgs e);
    protected internal virtual void OnPreviewDragOver(DragEventArgs e);
    protected internal virtual void OnPreviewDrop(DragEventArgs e);
    protected internal virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    protected internal virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected internal virtual void OnPreviewKeyUp(KeyEventArgs e);
    protected internal virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseMove(MouseEventArgs e);
    protected internal virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    protected internal virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    protected internal virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    protected internal virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    protected internal virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    protected internal virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusInRange(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusMove(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected internal virtual void OnPreviewStylusUp(StylusEventArgs e);
    protected internal virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    protected internal virtual void OnPreviewTouchDown(TouchEventArgs e);
    protected internal virtual void OnPreviewTouchMove(TouchEventArgs e);
    protected internal virtual void OnPreviewTouchUp(TouchEventArgs e);
    protected internal virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    protected internal virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected internal virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    protected internal virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    protected internal virtual void OnStylusDown(StylusDownEventArgs e);
    protected internal virtual void OnStylusEnter(StylusEventArgs e);
    protected internal virtual void OnStylusInAirMove(StylusEventArgs e);
    protected internal virtual void OnStylusInRange(StylusEventArgs e);
    protected internal virtual void OnStylusLeave(StylusEventArgs e);
    protected internal virtual void OnStylusMove(StylusEventArgs e);
    protected internal virtual void OnStylusOutOfRange(StylusEventArgs e);
    protected internal virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected internal virtual void OnStylusUp(StylusEventArgs e);
    protected internal virtual void OnTextInput(TextCompositionEventArgs e);
    protected internal virtual void OnTouchDown(TouchEventArgs e);
    protected internal virtual void OnTouchEnter(TouchEventArgs e);
    protected internal virtual void OnTouchLeave(TouchEventArgs e);
    protected internal virtual void OnTouchMove(TouchEventArgs e);
    protected internal virtual void OnTouchUp(TouchEventArgs e);
    protected virtual void OnUpdateModel();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    public void ReleaseAllTouchCaptures();
    public sealed virtual void ReleaseMouseCapture();
    public sealed virtual void ReleaseStylusCapture();
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
}
public class System.Windows.UIPropertyMetadata : PropertyMetadata {
    public bool IsAnimationProhibited { get; public set; }
    public UIPropertyMetadata(object defaultValue);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);
    public UIPropertyMetadata(PropertyChangedCallback propertyChangedCallback);
    public bool get_IsAnimationProhibited();
    public void set_IsAnimationProhibited(bool value);
}
public enum System.Windows.Visibility : Enum {
    public byte value__;
    public static Visibility Visible;
    public static Visibility Hidden;
    public static Visibility Collapsed;
}
