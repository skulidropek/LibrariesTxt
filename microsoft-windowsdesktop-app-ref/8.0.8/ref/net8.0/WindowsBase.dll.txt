internal static class MS.Internal.WindowsBase.BuildInfo : object {
    internal static string WCP_VERSION;
    internal static string WCP_VERSION_SUFFIX;
    internal static string MIL_VERSION_SUFFIX;
    internal static string WCP_PUBLIC_KEY_TOKEN;
    internal static string WCP_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_TOKEN;
    internal static string DirectWriteForwarder;
    internal static string PresentationCore;
    internal static string PresentationCFFRasterizer;
    internal static string PresentationFramework;
    internal static string PresentationUI;
    internal static string PresentationFrameworkLuna;
    internal static string PresentationFrameworkRoyale;
    internal static string PresentationFrameworkAero;
    internal static string PresentationFrameworkAero2;
    internal static string PresentationFrameworkAeroLite;
    internal static string PresentationFrameworkClassic;
    internal static string PresentationFrameworkSystemCore;
    internal static string PresentationFrameworkSystemData;
    internal static string PresentationFrameworkSystemDrawing;
    internal static string PresentationFrameworkSystemXml;
    internal static string PresentationFrameworkSystemXmlLinq;
    internal static string ReachFramework;
    internal static string SystemPrinting;
    internal static string SystemXaml;
    internal static string WindowsFormsIntegration;
    internal static string SystemWindowsPresentation;
    internal static string SystemWindowsControlsRibbon;
}
internal static class MS.Internal.WindowsBase.DllImport : object {
    internal static string PresentationNative;
    internal static string PresentationCFFRasterizerNative;
    internal static string MilCore;
    internal static string UIAutomationCore;
    internal static string Wininet;
    internal static string WindowsCodecs;
    internal static string WindowsCodecsExt;
    internal static string Mscms;
    internal static string PrntvPt;
    internal static string Ole32;
    internal static string User32;
    internal static string NInput;
    internal static string ApiSetWinRT;
    internal static string ApiSetWinRTString;
}
public class System.Collections.Specialized.CollectionChangedEventManager : WeakEventManager {
    public static void AddHandler(INotifyCollectionChanged source, EventHandler`1<NotifyCollectionChangedEventArgs> handler);
    public static void AddListener(INotifyCollectionChanged source, IWeakEventListener listener);
    protected virtual ListenerList NewListenerList();
    public static void RemoveHandler(INotifyCollectionChanged source, EventHandler`1<NotifyCollectionChangedEventArgs> handler);
    public static void RemoveListener(INotifyCollectionChanged source, IWeakEventListener listener);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public class System.ComponentModel.CurrentChangedEventManager : WeakEventManager {
    public static void AddHandler(ICollectionView source, EventHandler`1<EventArgs> handler);
    public static void AddListener(ICollectionView source, IWeakEventListener listener);
    protected virtual ListenerList NewListenerList();
    public static void RemoveHandler(ICollectionView source, EventHandler`1<EventArgs> handler);
    public static void RemoveListener(ICollectionView source, IWeakEventListener listener);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public class System.ComponentModel.CurrentChangingEventArgs : EventArgs {
    public bool Cancel { get; public set; }
    public bool IsCancelable { get; }
    public CurrentChangingEventArgs(bool isCancelable);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public bool get_IsCancelable();
}
public class System.ComponentModel.CurrentChangingEventHandler : MulticastDelegate {
    public CurrentChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CurrentChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CurrentChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.CurrentChangingEventManager : WeakEventManager {
    public static void AddHandler(ICollectionView source, EventHandler`1<CurrentChangingEventArgs> handler);
    public static void AddListener(ICollectionView source, IWeakEventListener listener);
    protected virtual ListenerList NewListenerList();
    public static void RemoveHandler(ICollectionView source, EventHandler`1<CurrentChangingEventArgs> handler);
    public static void RemoveListener(ICollectionView source, IWeakEventListener listener);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public class System.ComponentModel.DependencyPropertyDescriptor : PropertyDescriptor {
    public AttributeCollection Attributes { get; }
    public string Category { get; }
    public Type ComponentType { get; }
    public TypeConverter Converter { get; }
    public DependencyProperty DependencyProperty { get; }
    public string Description { get; }
    public CoerceValueCallback DesignerCoerceValueCallback { get; public set; }
    public bool DesignTimeOnly { get; }
    public string DisplayName { get; }
    public bool IsAttached { get; }
    public bool IsBrowsable { get; }
    public bool IsLocalizable { get; }
    public bool IsReadOnly { get; }
    public PropertyMetadata Metadata { get; }
    public Type PropertyType { get; }
    public bool SupportsChangeEvents { get; }
    public virtual AttributeCollection get_Attributes();
    public virtual string get_Category();
    public virtual Type get_ComponentType();
    public virtual TypeConverter get_Converter();
    public DependencyProperty get_DependencyProperty();
    public virtual string get_Description();
    public CoerceValueCallback get_DesignerCoerceValueCallback();
    public void set_DesignerCoerceValueCallback(CoerceValueCallback value);
    public virtual bool get_DesignTimeOnly();
    public virtual string get_DisplayName();
    public bool get_IsAttached();
    public virtual bool get_IsBrowsable();
    public virtual bool get_IsLocalizable();
    public virtual bool get_IsReadOnly();
    public PropertyMetadata get_Metadata();
    public virtual Type get_PropertyType();
    public virtual bool get_SupportsChangeEvents();
    public virtual void AddValueChanged(object component, EventHandler handler);
    public virtual bool CanResetValue(object component);
    public virtual bool Equals(object obj);
    public static DependencyPropertyDescriptor FromName(string name, Type ownerType, Type targetType);
    public static DependencyPropertyDescriptor FromName(string name, Type ownerType, Type targetType, bool ignorePropertyType);
    public static DependencyPropertyDescriptor FromProperty(PropertyDescriptor property);
    public static DependencyPropertyDescriptor FromProperty(DependencyProperty dependencyProperty, Type targetType);
    public virtual PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter);
    public virtual object GetEditor(Type editorBaseType);
    public virtual int GetHashCode();
    public virtual object GetValue(object component);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual string ToString();
}
public class System.ComponentModel.ErrorsChangedEventManager : WeakEventManager {
    public static void AddHandler(INotifyDataErrorInfo source, EventHandler`1<DataErrorsChangedEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    public static void RemoveHandler(INotifyDataErrorInfo source, EventHandler`1<DataErrorsChangedEventArgs> handler);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public abstract class System.ComponentModel.GroupDescription : object {
    public IComparer CustomSort { get; public set; }
    public ObservableCollection`1<object> GroupNames { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public IComparer get_CustomSort();
    public void set_CustomSort(IComparer value);
    public ObservableCollection`1<object> get_GroupNames();
    public SortDescriptionCollection get_SortDescriptions();
    protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    public abstract virtual object GroupNameFromItem(object item, int level, CultureInfo culture);
    public virtual bool NamesMatch(object groupName, object itemName);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeGroupNames();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSortDescriptions();
}
public interface System.ComponentModel.ICollectionView {
    public bool CanFilter { get; }
    public bool CanGroup { get; }
    public bool CanSort { get; }
    public CultureInfo Culture { get; public set; }
    public object CurrentItem { get; }
    public int CurrentPosition { get; }
    public Predicate`1<object> Filter { get; public set; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public bool IsEmpty { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public IEnumerable SourceCollection { get; }
    public abstract virtual bool get_CanFilter();
    public abstract virtual bool get_CanGroup();
    public abstract virtual bool get_CanSort();
    public abstract virtual CultureInfo get_Culture();
    public abstract virtual void set_Culture(CultureInfo value);
    public abstract virtual object get_CurrentItem();
    public abstract virtual int get_CurrentPosition();
    public abstract virtual Predicate`1<object> get_Filter();
    public abstract virtual void set_Filter(Predicate`1<object> value);
    public abstract virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public abstract virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public abstract virtual bool get_IsCurrentAfterLast();
    public abstract virtual bool get_IsCurrentBeforeFirst();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual SortDescriptionCollection get_SortDescriptions();
    public abstract virtual IEnumerable get_SourceCollection();
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentChanging(CurrentChangingEventHandler value);
    public abstract virtual bool Contains(object item);
    public abstract virtual IDisposable DeferRefresh();
    public abstract virtual bool MoveCurrentTo(object item);
    public abstract virtual bool MoveCurrentToFirst();
    public abstract virtual bool MoveCurrentToLast();
    public abstract virtual bool MoveCurrentToNext();
    public abstract virtual bool MoveCurrentToPosition(int position);
    public abstract virtual bool MoveCurrentToPrevious();
    public abstract virtual void Refresh();
}
public interface System.ComponentModel.ICollectionViewFactory {
    public abstract virtual ICollectionView CreateView();
}
public interface System.ComponentModel.ICollectionViewLiveShaping {
    public bool CanChangeLiveFiltering { get; }
    public bool CanChangeLiveGrouping { get; }
    public bool CanChangeLiveSorting { get; }
    public Nullable`1<bool> IsLiveFiltering { get; public set; }
    public Nullable`1<bool> IsLiveGrouping { get; public set; }
    public Nullable`1<bool> IsLiveSorting { get; public set; }
    public ObservableCollection`1<string> LiveFilteringProperties { get; }
    public ObservableCollection`1<string> LiveGroupingProperties { get; }
    public ObservableCollection`1<string> LiveSortingProperties { get; }
    public abstract virtual bool get_CanChangeLiveFiltering();
    public abstract virtual bool get_CanChangeLiveGrouping();
    public abstract virtual bool get_CanChangeLiveSorting();
    public abstract virtual Nullable`1<bool> get_IsLiveFiltering();
    public abstract virtual void set_IsLiveFiltering(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_IsLiveGrouping();
    public abstract virtual void set_IsLiveGrouping(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_IsLiveSorting();
    public abstract virtual void set_IsLiveSorting(Nullable`1<bool> value);
    public abstract virtual ObservableCollection`1<string> get_LiveFilteringProperties();
    public abstract virtual ObservableCollection`1<string> get_LiveGroupingProperties();
    public abstract virtual ObservableCollection`1<string> get_LiveSortingProperties();
}
public interface System.ComponentModel.IEditableCollectionView {
    public bool CanAddNew { get; }
    public bool CanCancelEdit { get; }
    public bool CanRemove { get; }
    public object CurrentAddItem { get; }
    public object CurrentEditItem { get; }
    public bool IsAddingNew { get; }
    public bool IsEditingItem { get; }
    public NewItemPlaceholderPosition NewItemPlaceholderPosition { get; public set; }
    public abstract virtual bool get_CanAddNew();
    public abstract virtual bool get_CanCancelEdit();
    public abstract virtual bool get_CanRemove();
    public abstract virtual object get_CurrentAddItem();
    public abstract virtual object get_CurrentEditItem();
    public abstract virtual bool get_IsAddingNew();
    public abstract virtual bool get_IsEditingItem();
    public abstract virtual NewItemPlaceholderPosition get_NewItemPlaceholderPosition();
    public abstract virtual void set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
    public abstract virtual object AddNew();
    public abstract virtual void CancelEdit();
    public abstract virtual void CancelNew();
    public abstract virtual void CommitEdit();
    public abstract virtual void CommitNew();
    public abstract virtual void EditItem(object item);
    public abstract virtual void Remove(object item);
    public abstract virtual void RemoveAt(int index);
}
public interface System.ComponentModel.IEditableCollectionViewAddNewItem {
    public bool CanAddNewItem { get; }
    public abstract virtual bool get_CanAddNewItem();
    public abstract virtual object AddNewItem(object newItem);
}
public interface System.ComponentModel.IItemProperties {
    public ReadOnlyCollection`1<ItemPropertyInfo> ItemProperties { get; }
    public abstract virtual ReadOnlyCollection`1<ItemPropertyInfo> get_ItemProperties();
}
public class System.ComponentModel.ItemPropertyInfo : object {
    public object Descriptor { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public ItemPropertyInfo(string name, Type type, object descriptor);
    public object get_Descriptor();
    public string get_Name();
    public Type get_PropertyType();
}
public enum System.ComponentModel.NewItemPlaceholderPosition : Enum {
    public int value__;
    public static NewItemPlaceholderPosition None;
    public static NewItemPlaceholderPosition AtBeginning;
    public static NewItemPlaceholderPosition AtEnd;
}
public class System.ComponentModel.PropertyChangedEventManager : WeakEventManager {
    public static void AddHandler(INotifyPropertyChanged source, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    public static void AddListener(INotifyPropertyChanged source, IWeakEventListener listener, string propertyName);
    protected virtual ListenerList NewListenerList();
    protected virtual bool Purge(object source, object data, bool purgeAll);
    public static void RemoveHandler(INotifyPropertyChanged source, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    public static void RemoveListener(INotifyPropertyChanged source, IWeakEventListener listener, string propertyName);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
[AttributeUsageAttribute("192")]
public class System.ComponentModel.PropertyFilterAttribute : Attribute {
    public static PropertyFilterAttribute Default;
    public PropertyFilterOptions Filter { get; }
    public PropertyFilterAttribute(PropertyFilterOptions filter);
    public PropertyFilterOptions get_Filter();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool Match(object value);
}
[FlagsAttribute]
public enum System.ComponentModel.PropertyFilterOptions : Enum {
    public int value__;
    public static PropertyFilterOptions None;
    public static PropertyFilterOptions Invalid;
    public static PropertyFilterOptions SetValues;
    public static PropertyFilterOptions UnsetValues;
    public static PropertyFilterOptions Valid;
    public static PropertyFilterOptions All;
}
public class System.ComponentModel.SortDescription : ValueType {
    public ListSortDirection Direction { get; public set; }
    public bool IsSealed { get; }
    public string PropertyName { get; public set; }
    public SortDescription(string propertyName, ListSortDirection direction);
    public ListSortDirection get_Direction();
    public void set_Direction(ListSortDirection value);
    public bool get_IsSealed();
    public string get_PropertyName();
    public void set_PropertyName(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SortDescription sd1, SortDescription sd2);
    public static bool op_Inequality(SortDescription sd1, SortDescription sd2);
}
public class System.ComponentModel.SortDescriptionCollection : Collection`1<SortDescription> {
    public static SortDescriptionCollection Empty;
    protected void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, SortDescription item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, SortDescription item);
}
public enum System.Diagnostics.PresentationTraceLevel : Enum {
    public int value__;
    public static PresentationTraceLevel None;
    public static PresentationTraceLevel Low;
    public static PresentationTraceLevel Medium;
    public static PresentationTraceLevel High;
}
public static class System.Diagnostics.PresentationTraceSources : object {
    public static DependencyProperty TraceLevelProperty;
    public static TraceSource AnimationSource { get; }
    public static TraceSource DataBindingSource { get; }
    public static TraceSource DependencyPropertySource { get; }
    public static TraceSource DocumentsSource { get; }
    public static TraceSource FreezableSource { get; }
    public static TraceSource HwndHostSource { get; }
    public static TraceSource MarkupSource { get; }
    public static TraceSource NameScopeSource { get; }
    public static TraceSource ResourceDictionarySource { get; }
    public static TraceSource RoutedEventSource { get; }
    public static TraceSource ShellSource { get; }
    public static TraceSource get_AnimationSource();
    public static TraceSource get_DataBindingSource();
    public static TraceSource get_DependencyPropertySource();
    public static TraceSource get_DocumentsSource();
    public static TraceSource get_FreezableSource();
    public static TraceSource get_HwndHostSource();
    public static TraceSource get_MarkupSource();
    public static TraceSource get_NameScopeSource();
    public static TraceSource get_ResourceDictionarySource();
    public static TraceSource get_RoutedEventSource();
    public static TraceSource get_ShellSource();
    public static PresentationTraceLevel GetTraceLevel(object element);
    public static void Refresh();
    public static void SetTraceLevel(object element, PresentationTraceLevel traceLevel);
}
public enum System.IO.Packaging.CertificateEmbeddingOption : Enum {
    public int value__;
    public static CertificateEmbeddingOption InCertificatePart;
    public static CertificateEmbeddingOption InSignaturePart;
    public static CertificateEmbeddingOption NotEmbedded;
}
public class System.IO.Packaging.EncryptedPackageEnvelope : object {
    public FileAccess FileOpenAccess { get; }
    public PackageProperties PackageProperties { get; }
    public RightsManagementInformation RightsManagementInformation { get; }
    public StorageInfo StorageInfo { get; }
    public FileAccess get_FileOpenAccess();
    public PackageProperties get_PackageProperties();
    public RightsManagementInformation get_RightsManagementInformation();
    public StorageInfo get_StorageInfo();
    public void Close();
    public static EncryptedPackageEnvelope Create(Stream envelopeStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope Create(string envelopeFileName, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope CreateFromPackage(Stream envelopeStream, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope CreateFromPackage(string envelopeFileName, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Flush();
    public Package GetPackage();
    public static bool IsEncryptedPackageEnvelope(Stream stream);
    public static bool IsEncryptedPackageEnvelope(string fileName);
    public static EncryptedPackageEnvelope Open(Stream envelopeStream);
    public static EncryptedPackageEnvelope Open(string envelopeFileName);
    public static EncryptedPackageEnvelope Open(string envelopeFileName, FileAccess access);
    public static EncryptedPackageEnvelope Open(string envelopeFileName, FileAccess access, FileShare sharing);
}
public class System.IO.Packaging.InvalidSignatureEventHandler : MulticastDelegate {
    public InvalidSignatureEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SignatureVerificationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SignatureVerificationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.IO.Packaging.PackageDigitalSignature : object {
    public CertificateEmbeddingOption CertificateEmbeddingOption { get; }
    public Signature Signature { get; public set; }
    public PackagePart SignaturePart { get; }
    public string SignatureType { get; }
    public Byte[] SignatureValue { get; }
    public ReadOnlyCollection`1<Uri> SignedParts { get; }
    public ReadOnlyCollection`1<PackageRelationshipSelector> SignedRelationshipSelectors { get; }
    public X509Certificate Signer { get; }
    public DateTime SigningTime { get; }
    public string TimeFormat { get; }
    public CertificateEmbeddingOption get_CertificateEmbeddingOption();
    public Signature get_Signature();
    public void set_Signature(Signature value);
    public PackagePart get_SignaturePart();
    public string get_SignatureType();
    public Byte[] get_SignatureValue();
    public ReadOnlyCollection`1<Uri> get_SignedParts();
    public ReadOnlyCollection`1<PackageRelationshipSelector> get_SignedRelationshipSelectors();
    public X509Certificate get_Signer();
    public DateTime get_SigningTime();
    public string get_TimeFormat();
    public List`1<string> GetPartTransformList(Uri partName);
    public VerifyResult Verify();
    public VerifyResult Verify(X509Certificate signingCertificate);
}
public class System.IO.Packaging.PackageDigitalSignatureManager : object {
    public CertificateEmbeddingOption CertificateOption { get; public set; }
    public static string DefaultHashAlgorithm { get; }
    public string HashAlgorithm { get; public set; }
    public bool IsSigned { get; }
    public IntPtr ParentWindow { get; public set; }
    public Uri SignatureOrigin { get; }
    public static string SignatureOriginRelationshipType { get; }
    public ReadOnlyCollection`1<PackageDigitalSignature> Signatures { get; }
    public string TimeFormat { get; public set; }
    public Dictionary`2<string, string> TransformMapping { get; }
    public PackageDigitalSignatureManager(Package package);
    public CertificateEmbeddingOption get_CertificateOption();
    public void set_CertificateOption(CertificateEmbeddingOption value);
    public static string get_DefaultHashAlgorithm();
    public string get_HashAlgorithm();
    public void set_HashAlgorithm(string value);
    public bool get_IsSigned();
    public IntPtr get_ParentWindow();
    public void set_ParentWindow(IntPtr value);
    public Uri get_SignatureOrigin();
    public static string get_SignatureOriginRelationshipType();
    public ReadOnlyCollection`1<PackageDigitalSignature> get_Signatures();
    public string get_TimeFormat();
    public void set_TimeFormat(string value);
    public Dictionary`2<string, string> get_TransformMapping();
    public void add_InvalidSignatureEvent(InvalidSignatureEventHandler value);
    public void remove_InvalidSignatureEvent(InvalidSignatureEventHandler value);
    public PackageDigitalSignature Countersign();
    public PackageDigitalSignature Countersign(X509Certificate certificate);
    public PackageDigitalSignature Countersign(X509Certificate certificate, IEnumerable`1<Uri> signatures);
    public PackageDigitalSignature GetSignature(Uri signatureUri);
    public void RemoveAllSignatures();
    public void RemoveSignature(Uri signatureUri);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, string signatureId);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, string signatureId, IEnumerable`1<DataObject> signatureObjects, IEnumerable`1<Reference> objectReferences);
    public static X509ChainStatusFlags VerifyCertificate(X509Certificate certificate);
    public VerifyResult VerifySignatures(bool exitOnFailure);
}
public class System.IO.Packaging.RightsManagementInformation : object {
    public CryptoProvider CryptoProvider { get; public set; }
    public CryptoProvider get_CryptoProvider();
    public void set_CryptoProvider(CryptoProvider value);
    public void DeleteUseLicense(ContentUser userKey);
    public IDictionary`2<ContentUser, UseLicense> GetEmbeddedUseLicenses();
    public PublishLicense LoadPublishLicense();
    public UseLicense LoadUseLicense(ContentUser userKey);
    public void SavePublishLicense(PublishLicense publishLicense);
    public void SaveUseLicense(ContentUser userKey, UseLicense useLicense);
}
public class System.IO.Packaging.SignatureVerificationEventArgs : EventArgs {
    public PackageDigitalSignature Signature { get; }
    public VerifyResult VerifyResult { get; }
    public PackageDigitalSignature get_Signature();
    public VerifyResult get_VerifyResult();
}
public class System.IO.Packaging.StorageInfo : object {
    public string Name { get; }
    public string get_Name();
    public StreamInfo CreateStream(string name);
    public StreamInfo CreateStream(string name, CompressionOption compressionOption, EncryptionOption encryptionOption);
    public StorageInfo CreateSubStorage(string name);
    public void DeleteStream(string name);
    public void DeleteSubStorage(string name);
    public StreamInfo GetStreamInfo(string name);
    public StreamInfo[] GetStreams();
    public StorageInfo GetSubStorageInfo(string name);
    public StorageInfo[] GetSubStorages();
    public bool StreamExists(string name);
    public bool SubStorageExists(string name);
}
public class System.IO.Packaging.StreamInfo : object {
    public CompressionOption CompressionOption { get; }
    public EncryptionOption EncryptionOption { get; }
    public string Name { get; }
    public CompressionOption get_CompressionOption();
    public EncryptionOption get_EncryptionOption();
    public string get_Name();
    public Stream GetStream();
    public Stream GetStream(FileMode mode);
    public Stream GetStream(FileMode mode, FileAccess access);
}
public enum System.IO.Packaging.VerifyResult : Enum {
    public int value__;
    public static VerifyResult Success;
    public static VerifyResult InvalidSignature;
    public static VerifyResult CertificateRequired;
    public static VerifyResult InvalidCertificate;
    public static VerifyResult ReferenceNotFound;
    public static VerifyResult NotSigned;
}
public enum System.Security.RightsManagement.AuthenticationType : Enum {
    public int value__;
    public static AuthenticationType Windows;
    public static AuthenticationType Passport;
    public static AuthenticationType WindowsPassport;
    public static AuthenticationType Internal;
}
public class System.Security.RightsManagement.ContentGrant : object {
    public ContentRight Right { get; }
    public ContentUser User { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidUntil { get; }
    public ContentGrant(ContentUser user, ContentRight right);
    public ContentGrant(ContentUser user, ContentRight right, DateTime validFrom, DateTime validUntil);
    public ContentRight get_Right();
    public ContentUser get_User();
    public DateTime get_ValidFrom();
    public DateTime get_ValidUntil();
}
public enum System.Security.RightsManagement.ContentRight : Enum {
    public int value__;
    public static ContentRight View;
    public static ContentRight Edit;
    public static ContentRight Print;
    public static ContentRight Extract;
    public static ContentRight ObjectModel;
    public static ContentRight Owner;
    public static ContentRight ViewRightsData;
    public static ContentRight Forward;
    public static ContentRight Reply;
    public static ContentRight ReplyAll;
    public static ContentRight Sign;
    public static ContentRight DocumentEdit;
    public static ContentRight Export;
}
public class System.Security.RightsManagement.ContentUser : object {
    public static ContentUser AnyoneUser { get; }
    public AuthenticationType AuthenticationType { get; }
    public string Name { get; }
    public static ContentUser OwnerUser { get; }
    public ContentUser(string name, AuthenticationType authenticationType);
    public static ContentUser get_AnyoneUser();
    public AuthenticationType get_AuthenticationType();
    public string get_Name();
    public static ContentUser get_OwnerUser();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IsAuthenticated();
}
public class System.Security.RightsManagement.CryptoProvider : object {
    public int BlockSize { get; }
    public ReadOnlyCollection`1<ContentGrant> BoundGrants { get; }
    public bool CanDecrypt { get; }
    public bool CanEncrypt { get; }
    public bool CanMergeBlocks { get; }
    public int get_BlockSize();
    public ReadOnlyCollection`1<ContentGrant> get_BoundGrants();
    public bool get_CanDecrypt();
    public bool get_CanEncrypt();
    public bool get_CanMergeBlocks();
    public Byte[] Decrypt(Byte[] cryptoText);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public Byte[] Encrypt(Byte[] clearText);
    protected virtual override void Finalize();
}
public class System.Security.RightsManagement.LocalizedNameDescriptionPair : object {
    public string Description { get; }
    public string Name { get; }
    public LocalizedNameDescriptionPair(string name, string description);
    public string get_Description();
    public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Security.RightsManagement.PublishLicense : object {
    public Guid ContentId { get; }
    public string ReferralInfoName { get; }
    public Uri ReferralInfoUri { get; }
    public Uri UseLicenseAcquisitionUrl { get; }
    public PublishLicense(string signedPublishLicense);
    public Guid get_ContentId();
    public string get_ReferralInfoName();
    public Uri get_ReferralInfoUri();
    public Uri get_UseLicenseAcquisitionUrl();
    public UseLicense AcquireUseLicense(SecureEnvironment secureEnvironment);
    public UseLicense AcquireUseLicenseNoUI(SecureEnvironment secureEnvironment);
    public UnsignedPublishLicense DecryptUnsignedPublishLicense(CryptoProvider cryptoProvider);
    public virtual string ToString();
}
public class System.Security.RightsManagement.RightsManagementException : Exception {
    public RightsManagementFailureCode FailureCode { get; }
    protected RightsManagementException(SerializationInfo info, StreamingContext context);
    public RightsManagementException(RightsManagementFailureCode failureCode);
    public RightsManagementException(RightsManagementFailureCode failureCode, Exception innerException);
    public RightsManagementException(RightsManagementFailureCode failureCode, string message);
    public RightsManagementException(RightsManagementFailureCode failureCode, string message, Exception innerException);
    public RightsManagementException(string message);
    public RightsManagementException(string message, Exception innerException);
    public RightsManagementFailureCode get_FailureCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.Security.RightsManagement.RightsManagementFailureCode : Enum {
    public int value__;
    public static RightsManagementFailureCode ManifestPolicyViolation;
    public static RightsManagementFailureCode InvalidLicense;
    public static RightsManagementFailureCode InfoNotInLicense;
    public static RightsManagementFailureCode InvalidLicenseSignature;
    public static RightsManagementFailureCode EncryptionNotPermitted;
    public static RightsManagementFailureCode RightNotGranted;
    public static RightsManagementFailureCode InvalidVersion;
    public static RightsManagementFailureCode InvalidEncodingType;
    public static RightsManagementFailureCode InvalidNumericalValue;
    public static RightsManagementFailureCode InvalidAlgorithmType;
    public static RightsManagementFailureCode EnvironmentNotLoaded;
    public static RightsManagementFailureCode EnvironmentCannotLoad;
    public static RightsManagementFailureCode TooManyLoadedEnvironments;
    public static RightsManagementFailureCode IncompatibleObjects;
    public static RightsManagementFailureCode LibraryFail;
    public static RightsManagementFailureCode EnablingPrincipalFailure;
    public static RightsManagementFailureCode InfoNotPresent;
    public static RightsManagementFailureCode BadGetInfoQuery;
    public static RightsManagementFailureCode KeyTypeUnsupported;
    public static RightsManagementFailureCode CryptoOperationUnsupported;
    public static RightsManagementFailureCode ClockRollbackDetected;
    public static RightsManagementFailureCode QueryReportsNoResults;
    public static RightsManagementFailureCode UnexpectedException;
    public static RightsManagementFailureCode BindValidityTimeViolated;
    public static RightsManagementFailureCode BrokenCertChain;
    public static RightsManagementFailureCode BindPolicyViolation;
    public static RightsManagementFailureCode BindRevokedLicense;
    public static RightsManagementFailureCode BindRevokedIssuer;
    public static RightsManagementFailureCode BindRevokedPrincipal;
    public static RightsManagementFailureCode BindRevokedResource;
    public static RightsManagementFailureCode BindRevokedModule;
    public static RightsManagementFailureCode BindContentNotInEndUseLicense;
    public static RightsManagementFailureCode BindAccessPrincipalNotEnabling;
    public static RightsManagementFailureCode BindAccessUnsatisfied;
    public static RightsManagementFailureCode BindIndicatedPrincipalMissing;
    public static RightsManagementFailureCode BindMachineNotFoundInGroupIdentity;
    public static RightsManagementFailureCode LibraryUnsupportedPlugIn;
    public static RightsManagementFailureCode BindRevocationListStale;
    public static RightsManagementFailureCode BindNoApplicableRevocationList;
    public static RightsManagementFailureCode InvalidHandle;
    public static RightsManagementFailureCode BindIntervalTimeViolated;
    public static RightsManagementFailureCode BindNoSatisfiedRightsGroup;
    public static RightsManagementFailureCode BindSpecifiedWorkMissing;
    public static RightsManagementFailureCode NoMoreData;
    public static RightsManagementFailureCode LicenseAcquisitionFailed;
    public static RightsManagementFailureCode IdMismatch;
    public static RightsManagementFailureCode TooManyCertificates;
    public static RightsManagementFailureCode NoDistributionPointUrlFound;
    public static RightsManagementFailureCode AlreadyInProgress;
    public static RightsManagementFailureCode GroupIdentityNotSet;
    public static RightsManagementFailureCode RecordNotFound;
    public static RightsManagementFailureCode NoConnect;
    public static RightsManagementFailureCode NoLicense;
    public static RightsManagementFailureCode NeedsMachineActivation;
    public static RightsManagementFailureCode NeedsGroupIdentityActivation;
    public static RightsManagementFailureCode ActivationFailed;
    public static RightsManagementFailureCode Aborted;
    public static RightsManagementFailureCode OutOfQuota;
    public static RightsManagementFailureCode AuthenticationFailed;
    public static RightsManagementFailureCode ServerError;
    public static RightsManagementFailureCode InstallationFailed;
    public static RightsManagementFailureCode HidCorrupted;
    public static RightsManagementFailureCode InvalidServerResponse;
    public static RightsManagementFailureCode ServiceNotFound;
    public static RightsManagementFailureCode UseDefault;
    public static RightsManagementFailureCode ServerNotFound;
    public static RightsManagementFailureCode InvalidEmail;
    public static RightsManagementFailureCode ValidityTimeViolation;
    public static RightsManagementFailureCode OutdatedModule;
    public static RightsManagementFailureCode NotSet;
    public static RightsManagementFailureCode MetadataNotSet;
    public static RightsManagementFailureCode RevocationInfoNotSet;
    public static RightsManagementFailureCode InvalidTimeInfo;
    public static RightsManagementFailureCode RightNotSet;
    public static RightsManagementFailureCode LicenseBindingToWindowsIdentityFailed;
    public static RightsManagementFailureCode InvalidIssuanceLicenseTemplate;
    public static RightsManagementFailureCode InvalidKeyLength;
    public static RightsManagementFailureCode ExpiredOfficialIssuanceLicenseTemplate;
    public static RightsManagementFailureCode InvalidClientLicensorCertificate;
    public static RightsManagementFailureCode HidInvalid;
    public static RightsManagementFailureCode EmailNotVerified;
    public static RightsManagementFailureCode ServiceMoved;
    public static RightsManagementFailureCode ServiceGone;
    public static RightsManagementFailureCode AdEntryNotFound;
    public static RightsManagementFailureCode NotAChain;
    public static RightsManagementFailureCode RequestDenied;
    public static RightsManagementFailureCode DebuggerDetected;
    public static RightsManagementFailureCode InvalidLockboxType;
    public static RightsManagementFailureCode InvalidLockboxPath;
    public static RightsManagementFailureCode InvalidRegistryPath;
    public static RightsManagementFailureCode NoAesCryptoProvider;
    public static RightsManagementFailureCode GlobalOptionAlreadySet;
    public static RightsManagementFailureCode OwnerLicenseNotFound;
    public static RightsManagementFailureCode Success;
}
public class System.Security.RightsManagement.SecureEnvironment : object {
    public string ApplicationManifest { get; }
    public ContentUser User { get; }
    public string get_ApplicationManifest();
    public ContentUser get_User();
    public static SecureEnvironment Create(string applicationManifest, AuthenticationType authentication, UserActivationMode userActivationMode);
    public static SecureEnvironment Create(string applicationManifest, ContentUser user);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static ReadOnlyCollection`1<ContentUser> GetActivatedUsers();
    public static bool IsUserActivated(ContentUser user);
    public static void RemoveActivatedUser(ContentUser user);
}
public class System.Security.RightsManagement.UnsignedPublishLicense : object {
    public Guid ContentId { get; public set; }
    public ICollection`1<ContentGrant> Grants { get; }
    public IDictionary`2<int, LocalizedNameDescriptionPair> LocalizedNameDescriptionDictionary { get; }
    public ContentUser Owner { get; public set; }
    public string ReferralInfoName { get; public set; }
    public Uri ReferralInfoUri { get; public set; }
    public UnsignedPublishLicense(string publishLicenseTemplate);
    public Guid get_ContentId();
    public void set_ContentId(Guid value);
    public ICollection`1<ContentGrant> get_Grants();
    public IDictionary`2<int, LocalizedNameDescriptionPair> get_LocalizedNameDescriptionDictionary();
    public ContentUser get_Owner();
    public void set_Owner(ContentUser value);
    public string get_ReferralInfoName();
    public void set_ReferralInfoName(string value);
    public Uri get_ReferralInfoUri();
    public void set_ReferralInfoUri(Uri value);
    public PublishLicense Sign(SecureEnvironment secureEnvironment, UseLicense& authorUseLicense);
    public virtual string ToString();
}
public class System.Security.RightsManagement.UseLicense : object {
    public IDictionary`2<string, string> ApplicationData { get; }
    public Guid ContentId { get; }
    public ContentUser Owner { get; }
    public UseLicense(string useLicense);
    public IDictionary`2<string, string> get_ApplicationData();
    public Guid get_ContentId();
    public ContentUser get_Owner();
    public CryptoProvider Bind(SecureEnvironment secureEnvironment);
    public virtual bool Equals(object x);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum System.Security.RightsManagement.UserActivationMode : Enum {
    public int value__;
    public static UserActivationMode Permanent;
    public static UserActivationMode Temporary;
}
public abstract class System.Windows.AttachedPropertyBrowsableAttribute : Attribute {
    internal abstract virtual bool IsBrowsable(DependencyObject d, DependencyProperty dp);
}
[AttributeUsageAttribute("64")]
public class System.Windows.AttachedPropertyBrowsableForTypeAttribute : AttachedPropertyBrowsableAttribute {
    public Type TargetType { get; }
    public object TypeId { get; }
    public AttachedPropertyBrowsableForTypeAttribute(Type targetType);
    public Type get_TargetType();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool IsBrowsable(DependencyObject d, DependencyProperty dp);
}
[AttributeUsageAttribute("64")]
public class System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute : AttachedPropertyBrowsableAttribute {
    public Type AttributeType { get; }
    public AttachedPropertyBrowsableWhenAttributePresentAttribute(Type attributeType);
    public Type get_AttributeType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool IsBrowsable(DependencyObject d, DependencyProperty dp);
}
public static class System.Windows.BaseCompatibilityPreferences : object {
    public static bool FlowDispatcherSynchronizationContextPriority { get; public set; }
    public static HandleDispatcherRequestProcessingFailureOptions HandleDispatcherRequestProcessingFailure { get; public set; }
    public static bool InlineDispatcherSynchronizationContextSend { get; public set; }
    public static bool ReuseDispatcherSynchronizationContextInstance { get; public set; }
    public static bool get_FlowDispatcherSynchronizationContextPriority();
    public static void set_FlowDispatcherSynchronizationContextPriority(bool value);
    public static HandleDispatcherRequestProcessingFailureOptions get_HandleDispatcherRequestProcessingFailure();
    public static void set_HandleDispatcherRequestProcessingFailure(HandleDispatcherRequestProcessingFailureOptions value);
    public static bool get_InlineDispatcherSynchronizationContextSend();
    public static void set_InlineDispatcherSynchronizationContextSend(bool value);
    public static bool get_ReuseDispatcherSynchronizationContextInstance();
    public static void set_ReuseDispatcherSynchronizationContextInstance(bool value);
}
public class System.Windows.CoerceValueCallback : MulticastDelegate {
    public CoerceValueCallback(object object, IntPtr method);
    public virtual object Invoke(DependencyObject d, object baseValue);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, object baseValue, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class System.Windows.Converters.Int32RectValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.PointValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.RectValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.SizeValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.VectorValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public abstract class System.Windows.Data.DataSourceProvider : object {
    [DesignerSerializationVisibilityAttribute("0")]
public object Data { get; }
    protected Dispatcher Dispatcher { get; protected set; }
    public Exception Error { get; }
    [DefaultValueAttribute("True")]
public bool IsInitialLoadEnabled { get; public set; }
    protected bool IsRefreshDeferred { get; }
    public object get_Data();
    protected Dispatcher get_Dispatcher();
    protected void set_Dispatcher(Dispatcher value);
    public Exception get_Error();
    public bool get_IsInitialLoadEnabled();
    public void set_IsInitialLoadEnabled(bool value);
    protected bool get_IsRefreshDeferred();
    public void add_DataChanged(EventHandler value);
    public void remove_DataChanged(EventHandler value);
    protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void BeginInit();
    protected virtual void BeginQuery();
    public virtual IDisposable DeferRefresh();
    protected virtual void EndInit();
    public void InitialLoad();
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected void OnQueryFinished(object newData);
    protected virtual void OnQueryFinished(object newData, Exception error, DispatcherOperationCallback completionWork, object callbackArguments);
    public void Refresh();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
[NameScopePropertyAttribute("NameScope", "System.Windows.NameScope")]
public class System.Windows.DependencyObject : DispatcherObject {
    public DependencyObjectType DependencyObjectType { get; }
    public bool IsSealed { get; }
    public DependencyObjectType get_DependencyObjectType();
    public bool get_IsSealed();
    public void ClearValue(DependencyProperty dp);
    public void ClearValue(DependencyPropertyKey key);
    public void CoerceValue(DependencyProperty dp);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public LocalValueEnumerator GetLocalValueEnumerator();
    public object GetValue(DependencyProperty dp);
    public void InvalidateProperty(DependencyProperty dp);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    public object ReadLocalValue(DependencyProperty dp);
    public void SetCurrentValue(DependencyProperty dp, object value);
    public void SetValue(DependencyProperty dp, object value);
    public void SetValue(DependencyPropertyKey key, object value);
    protected internal virtual bool ShouldSerializeProperty(DependencyProperty dp);
}
public class System.Windows.DependencyObjectType : object {
    public DependencyObjectType BaseType { get; }
    public int Id { get; }
    public string Name { get; }
    public Type SystemType { get; }
    public DependencyObjectType get_BaseType();
    public int get_Id();
    public string get_Name();
    public Type get_SystemType();
    public static DependencyObjectType FromSystemType(Type systemType);
    public virtual int GetHashCode();
    public bool IsInstanceOfType(DependencyObject dependencyObject);
    public bool IsSubclassOf(DependencyObjectType dependencyObjectType);
}
[TypeConverterAttribute("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.DependencyProperty : object {
    public static object UnsetValue;
    public PropertyMetadata DefaultMetadata { get; }
    public int GlobalIndex { get; }
    public string Name { get; }
    public Type OwnerType { get; }
    public Type PropertyType { get; }
    public bool ReadOnly { get; }
    public ValidateValueCallback ValidateValueCallback { get; }
    public PropertyMetadata get_DefaultMetadata();
    public int get_GlobalIndex();
    public string get_Name();
    public Type get_OwnerType();
    public Type get_PropertyType();
    public bool get_ReadOnly();
    public ValidateValueCallback get_ValidateValueCallback();
    public DependencyProperty AddOwner(Type ownerType);
    public DependencyProperty AddOwner(Type ownerType, PropertyMetadata typeMetadata);
    public virtual int GetHashCode();
    public PropertyMetadata GetMetadata(Type forType);
    public PropertyMetadata GetMetadata(DependencyObject dependencyObject);
    public PropertyMetadata GetMetadata(DependencyObjectType dependencyObjectType);
    public bool IsValidType(object value);
    public bool IsValidValue(object value);
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata);
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata, DependencyPropertyKey key);
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType);
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata);
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyPropertyKey RegisterAttachedReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata);
    public static DependencyPropertyKey RegisterAttachedReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyPropertyKey RegisterReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata);
    public static DependencyPropertyKey RegisterReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, ValidateValueCallback validateValueCallback);
    public virtual string ToString();
}
public class System.Windows.DependencyPropertyChangedEventArgs : ValueType {
    public object NewValue { get; }
    public object OldValue { get; }
    public DependencyProperty Property { get; }
    public DependencyPropertyChangedEventArgs(DependencyProperty property, object oldValue, object newValue);
    public object get_NewValue();
    public object get_OldValue();
    public DependencyProperty get_Property();
    public virtual bool Equals(object obj);
    public bool Equals(DependencyPropertyChangedEventArgs args);
    public virtual int GetHashCode();
    public static bool op_Equality(DependencyPropertyChangedEventArgs left, DependencyPropertyChangedEventArgs right);
    public static bool op_Inequality(DependencyPropertyChangedEventArgs left, DependencyPropertyChangedEventArgs right);
}
public class System.Windows.DependencyPropertyChangedEventHandler : MulticastDelegate {
    public DependencyPropertyChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DependencyPropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DependencyPropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DependencyPropertyKey : object {
    public DependencyProperty DependencyProperty { get; }
    public DependencyProperty get_DependencyProperty();
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata);
}
[TypeConverterAttribute("System.Windows.ExpressionConverter")]
public class System.Windows.Expression : object {
}
public class System.Windows.ExpressionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public abstract class System.Windows.Freezable : DependencyObject {
    public bool CanFreeze { get; }
    public bool IsFrozen { get; }
    public bool get_CanFreeze();
    public bool get_IsFrozen();
    public void add_Changed(EventHandler value);
    public void remove_Changed(EventHandler value);
    public Freezable Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public Freezable CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected Freezable CreateInstance();
    protected abstract virtual Freezable CreateInstanceCore();
    public void Freeze();
    protected internal static bool Freeze(Freezable freezable, bool isChecking);
    protected virtual bool FreezeCore(bool isChecking);
    public Freezable GetAsFrozen();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    public Freezable GetCurrentValueAsFrozen();
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual void OnChanged();
    protected void OnFreezablePropertyChanged(DependencyObject oldValue, DependencyObject newValue);
    protected void OnFreezablePropertyChanged(DependencyObject oldValue, DependencyObject newValue, DependencyProperty property);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected void ReadPreamble();
    protected void WritePostscript();
    protected void WritePreamble();
}
public enum System.Windows.Input.FocusNavigationDirection : Enum {
    public int value__;
    public static FocusNavigationDirection Next;
    public static FocusNavigationDirection Previous;
    public static FocusNavigationDirection First;
    public static FocusNavigationDirection Last;
    public static FocusNavigationDirection Left;
    public static FocusNavigationDirection Right;
    public static FocusNavigationDirection Up;
    public static FocusNavigationDirection Down;
}
[TypeConverterAttribute("System.Windows.Input.KeyConverter")]
[ValueSerializerAttribute("System.Windows.Input.KeyValueSerializer")]
public enum System.Windows.Input.Key : Enum {
    public int value__;
    public static Key None;
    public static Key Cancel;
    public static Key Back;
    public static Key Tab;
    public static Key LineFeed;
    public static Key Clear;
    public static Key Enter;
    public static Key Return;
    public static Key Pause;
    public static Key Capital;
    public static Key CapsLock;
    public static Key HangulMode;
    public static Key KanaMode;
    public static Key JunjaMode;
    public static Key FinalMode;
    public static Key HanjaMode;
    public static Key KanjiMode;
    public static Key Escape;
    public static Key ImeConvert;
    public static Key ImeNonConvert;
    public static Key ImeAccept;
    public static Key ImeModeChange;
    public static Key Space;
    public static Key PageUp;
    public static Key Prior;
    public static Key Next;
    public static Key PageDown;
    public static Key End;
    public static Key Home;
    public static Key Left;
    public static Key Up;
    public static Key Right;
    public static Key Down;
    public static Key Select;
    public static Key Print;
    public static Key Execute;
    public static Key PrintScreen;
    public static Key Snapshot;
    public static Key Insert;
    public static Key Delete;
    public static Key Help;
    public static Key D0;
    public static Key D1;
    public static Key D2;
    public static Key D3;
    public static Key D4;
    public static Key D5;
    public static Key D6;
    public static Key D7;
    public static Key D8;
    public static Key D9;
    public static Key A;
    public static Key B;
    public static Key C;
    public static Key D;
    public static Key E;
    public static Key F;
    public static Key G;
    public static Key H;
    public static Key I;
    public static Key J;
    public static Key K;
    public static Key L;
    public static Key M;
    public static Key N;
    public static Key O;
    public static Key P;
    public static Key Q;
    public static Key R;
    public static Key S;
    public static Key T;
    public static Key U;
    public static Key V;
    public static Key W;
    public static Key X;
    public static Key Y;
    public static Key Z;
    public static Key LWin;
    public static Key RWin;
    public static Key Apps;
    public static Key Sleep;
    public static Key NumPad0;
    public static Key NumPad1;
    public static Key NumPad2;
    public static Key NumPad3;
    public static Key NumPad4;
    public static Key NumPad5;
    public static Key NumPad6;
    public static Key NumPad7;
    public static Key NumPad8;
    public static Key NumPad9;
    public static Key Multiply;
    public static Key Add;
    public static Key Separator;
    public static Key Subtract;
    public static Key Decimal;
    public static Key Divide;
    public static Key F1;
    public static Key F2;
    public static Key F3;
    public static Key F4;
    public static Key F5;
    public static Key F6;
    public static Key F7;
    public static Key F8;
    public static Key F9;
    public static Key F10;
    public static Key F11;
    public static Key F12;
    public static Key F13;
    public static Key F14;
    public static Key F15;
    public static Key F16;
    public static Key F17;
    public static Key F18;
    public static Key F19;
    public static Key F20;
    public static Key F21;
    public static Key F22;
    public static Key F23;
    public static Key F24;
    public static Key NumLock;
    public static Key Scroll;
    public static Key LeftShift;
    public static Key RightShift;
    public static Key LeftCtrl;
    public static Key RightCtrl;
    public static Key LeftAlt;
    public static Key RightAlt;
    public static Key BrowserBack;
    public static Key BrowserForward;
    public static Key BrowserRefresh;
    public static Key BrowserStop;
    public static Key BrowserSearch;
    public static Key BrowserFavorites;
    public static Key BrowserHome;
    public static Key VolumeMute;
    public static Key VolumeDown;
    public static Key VolumeUp;
    public static Key MediaNextTrack;
    public static Key MediaPreviousTrack;
    public static Key MediaStop;
    public static Key MediaPlayPause;
    public static Key LaunchMail;
    public static Key SelectMedia;
    public static Key LaunchApplication1;
    public static Key LaunchApplication2;
    public static Key Oem1;
    public static Key OemSemicolon;
    public static Key OemPlus;
    public static Key OemComma;
    public static Key OemMinus;
    public static Key OemPeriod;
    public static Key Oem2;
    public static Key OemQuestion;
    public static Key Oem3;
    public static Key OemTilde;
    public static Key AbntC1;
    public static Key AbntC2;
    public static Key Oem4;
    public static Key OemOpenBrackets;
    public static Key Oem5;
    public static Key OemPipe;
    public static Key Oem6;
    public static Key OemCloseBrackets;
    public static Key Oem7;
    public static Key OemQuotes;
    public static Key Oem8;
    public static Key Oem102;
    public static Key OemBackslash;
    public static Key ImeProcessed;
    public static Key System;
    public static Key DbeAlphanumeric;
    public static Key OemAttn;
    public static Key DbeKatakana;
    public static Key OemFinish;
    public static Key DbeHiragana;
    public static Key OemCopy;
    public static Key DbeSbcsChar;
    public static Key OemAuto;
    public static Key DbeDbcsChar;
    public static Key OemEnlw;
    public static Key DbeRoman;
    public static Key OemBackTab;
    public static Key Attn;
    public static Key DbeNoRoman;
    public static Key CrSel;
    public static Key DbeEnterWordRegisterMode;
    public static Key DbeEnterImeConfigureMode;
    public static Key ExSel;
    public static Key DbeFlushString;
    public static Key EraseEof;
    public static Key DbeCodeInput;
    public static Key Play;
    public static Key DbeNoCodeInput;
    public static Key Zoom;
    public static Key DbeDetermineString;
    public static Key NoName;
    public static Key DbeEnterDialogConversionMode;
    public static Key Pa1;
    public static Key OemClear;
    public static Key DeadCharProcessed;
}
public class System.Windows.Input.KeyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Input.KeyInterop : object {
    public static Key KeyFromVirtualKey(int virtualKey);
    public static int VirtualKeyFromKey(Key key);
}
public class System.Windows.Input.KeyValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[TypeConverterAttribute("System.Windows.Input.ModifierKeysConverter")]
[FlagsAttribute]
[ValueSerializerAttribute("System.Windows.Input.ModifierKeysValueSerializer")]
public enum System.Windows.Input.ModifierKeys : Enum {
    public int value__;
    public static ModifierKeys None;
    public static ModifierKeys Alt;
    public static ModifierKeys Control;
    public static ModifierKeys Shift;
    public static ModifierKeys Windows;
}
public class System.Windows.Input.ModifierKeysConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public static bool IsDefinedModifierKeys(ModifierKeys modifierKeys);
}
public class System.Windows.Input.ModifierKeysValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.TraversalRequest : object {
    public FocusNavigationDirection FocusNavigationDirection { get; }
    public bool Wrapped { get; public set; }
    public TraversalRequest(FocusNavigationDirection focusNavigationDirection);
    public FocusNavigationDirection get_FocusNavigationDirection();
    public bool get_Wrapped();
    public void set_Wrapped(bool value);
}
[TypeConverterAttribute("System.Windows.Int32RectConverter")]
[ValueSerializerAttribute("System.Windows.Converters.Int32RectValueSerializer")]
public class System.Windows.Int32Rect : ValueType {
    public static Int32Rect Empty { get; }
    public bool HasArea { get; }
    public int Height { get; public set; }
    public bool IsEmpty { get; }
    public int Width { get; public set; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public Int32Rect(int x, int y, int width, int height);
    public static Int32Rect get_Empty();
    public bool get_HasArea();
    public int get_Height();
    public void set_Height(int value);
    public bool get_IsEmpty();
    public int get_Width();
    public void set_Width(int value);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public virtual bool Equals(object o);
    public bool Equals(Int32Rect value);
    public static bool Equals(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public virtual int GetHashCode();
    public static bool op_Equality(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public static bool op_Inequality(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public static Int32Rect Parse(string source);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.Int32RectConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Interop.ComponentDispatcher : object {
    public static MSG CurrentKeyboardMessage { get; }
    public static bool IsThreadModal { get; }
    public static MSG get_CurrentKeyboardMessage();
    public static bool get_IsThreadModal();
    public static void add_EnterThreadModal(EventHandler value);
    public static void remove_EnterThreadModal(EventHandler value);
    public static void add_LeaveThreadModal(EventHandler value);
    public static void remove_LeaveThreadModal(EventHandler value);
    public static void add_ThreadFilterMessage(ThreadMessageEventHandler value);
    public static void remove_ThreadFilterMessage(ThreadMessageEventHandler value);
    public static void add_ThreadIdle(EventHandler value);
    public static void remove_ThreadIdle(EventHandler value);
    public static void add_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    public static void remove_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    public static void PopModal();
    public static void PushModal();
    public static void RaiseIdle();
    public static bool RaiseThreadMessage(MSG& msg);
}
public interface System.Windows.Interop.IKeyboardInputSink {
    public IKeyboardInputSite KeyboardInputSite { get; public set; }
    public abstract virtual IKeyboardInputSite get_KeyboardInputSite();
    public abstract virtual void set_KeyboardInputSite(IKeyboardInputSite value);
    public abstract virtual bool HasFocusWithin();
    public abstract virtual bool OnMnemonic(MSG& msg, ModifierKeys modifiers);
    public abstract virtual IKeyboardInputSite RegisterKeyboardInputSink(IKeyboardInputSink sink);
    public abstract virtual bool TabInto(TraversalRequest request);
    public abstract virtual bool TranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    public abstract virtual bool TranslateChar(MSG& msg, ModifierKeys modifiers);
}
public interface System.Windows.Interop.IKeyboardInputSite {
    public IKeyboardInputSink Sink { get; }
    public abstract virtual IKeyboardInputSink get_Sink();
    public abstract virtual bool OnNoMoreTabStops(TraversalRequest request);
    public abstract virtual void Unregister();
}
public class System.Windows.Interop.MSG : ValueType {
    public IntPtr hwnd { get; public set; }
    public IntPtr lParam { get; public set; }
    public int message { get; public set; }
    public int pt_x { get; public set; }
    public int pt_y { get; public set; }
    public int time { get; public set; }
    public IntPtr wParam { get; public set; }
    public IntPtr get_hwnd();
    public void set_hwnd(IntPtr value);
    public IntPtr get_lParam();
    public void set_lParam(IntPtr value);
    public int get_message();
    public void set_message(int value);
    public int get_pt_x();
    public void set_pt_x(int value);
    public int get_pt_y();
    public void set_pt_y(int value);
    public int get_time();
    public void set_time(int value);
    public IntPtr get_wParam();
    public void set_wParam(IntPtr value);
}
public class System.Windows.Interop.ThreadMessageEventHandler : MulticastDelegate {
    public ThreadMessageEventHandler(object object, IntPtr method);
    public virtual void Invoke(MSG& msg, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(MSG& msg, Boolean& handled, AsyncCallback callback, object object);
    public virtual void EndInvoke(MSG& msg, Boolean& handled, IAsyncResult result);
}
public interface System.Windows.IWeakEventListener {
    public abstract virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
}
public class System.Windows.LocalValueEntry : ValueType {
    public DependencyProperty Property { get; }
    public object Value { get; }
    public DependencyProperty get_Property();
    public object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(LocalValueEntry obj1, LocalValueEntry obj2);
    public static bool op_Inequality(LocalValueEntry obj1, LocalValueEntry obj2);
}
public class System.Windows.LocalValueEnumerator : ValueType {
    public int Count { get; }
    public LocalValueEntry Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public int get_Count();
    public LocalValueEntry get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool MoveNext();
    public static bool op_Equality(LocalValueEnumerator obj1, LocalValueEnumerator obj2);
    public static bool op_Inequality(LocalValueEnumerator obj1, LocalValueEnumerator obj2);
    public sealed virtual void Reset();
}
[FlagsAttribute]
public enum System.Windows.Markup.DesignerSerializationOptions : Enum {
    public int value__;
    public static DesignerSerializationOptions SerializeAsAttribute;
}
[AttributeUsageAttribute("448")]
public class System.Windows.Markup.DesignerSerializationOptionsAttribute : Attribute {
    public DesignerSerializationOptions DesignerSerializationOptions { get; }
    public DesignerSerializationOptionsAttribute(DesignerSerializationOptions designerSerializationOptions);
    public DesignerSerializationOptions get_DesignerSerializationOptions();
}
[EditorBrowsableAttribute("1")]
public abstract class System.Windows.Markup.InternalTypeHelper : object {
    protected internal abstract virtual void AddEventHandler(EventInfo eventInfo, object target, Delegate handler);
    protected internal abstract virtual Delegate CreateDelegate(Type delegateType, object target, string handler);
    protected internal abstract virtual object CreateInstance(Type type, CultureInfo culture);
    protected internal abstract virtual object GetPropertyValue(PropertyInfo propertyInfo, object target, CultureInfo culture);
    protected internal abstract virtual void SetPropertyValue(PropertyInfo propertyInfo, object target, object value, CultureInfo culture);
}
[ObsoleteAttribute("IReceiveMarkupExtension has been deprecated. This interface is no longer in use.")]
public interface System.Windows.Markup.IReceiveMarkupExtension {
    public abstract virtual void ReceiveMarkupExtension(string property, MarkupExtension markupExtension, IServiceProvider serviceProvider);
}
public abstract class System.Windows.Markup.Primitives.MarkupObject : object {
    public AttributeCollection Attributes { get; }
    public object Instance { get; }
    public Type ObjectType { get; }
    public IEnumerable`1<MarkupProperty> Properties { get; }
    public abstract virtual AttributeCollection get_Attributes();
    public abstract virtual object get_Instance();
    public abstract virtual Type get_ObjectType();
    public virtual IEnumerable`1<MarkupProperty> get_Properties();
    public abstract virtual void AssignRootContext(IValueSerializerContext context);
}
public abstract class System.Windows.Markup.Primitives.MarkupProperty : object {
    public AttributeCollection Attributes { get; }
    public DependencyProperty DependencyProperty { get; }
    public bool IsAttached { get; }
    public bool IsComposite { get; }
    public bool IsConstructorArgument { get; }
    public bool IsContent { get; }
    public bool IsKey { get; }
    public bool IsValueAsString { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public string Name { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public Type PropertyType { get; }
    public string StringValue { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    public object Value { get; }
    public abstract virtual AttributeCollection get_Attributes();
    public virtual DependencyProperty get_DependencyProperty();
    public virtual bool get_IsAttached();
    public virtual bool get_IsComposite();
    public virtual bool get_IsConstructorArgument();
    public virtual bool get_IsContent();
    public virtual bool get_IsKey();
    public virtual bool get_IsValueAsString();
    public abstract virtual IEnumerable`1<MarkupObject> get_Items();
    public abstract virtual string get_Name();
    public virtual PropertyDescriptor get_PropertyDescriptor();
    public abstract virtual Type get_PropertyType();
    public abstract virtual string get_StringValue();
    public abstract virtual IEnumerable`1<Type> get_TypeReferences();
    public abstract virtual object get_Value();
}
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public class System.Windows.Markup.ServiceProviders : object {
    public void AddService(Type serviceType, object service);
    public sealed virtual object GetService(Type serviceType);
}
public class System.Windows.Media.Converters.MatrixValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[AttributeUsageAttribute("1")]
public class System.Windows.Media.DisableDpiAwarenessAttribute : Attribute {
}
[TypeConverterAttribute("System.Windows.Media.MatrixConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.MatrixValueSerializer")]
public class System.Windows.Media.Matrix : ValueType {
    public double Determinant { get; }
    public bool HasInverse { get; }
    public static Matrix Identity { get; }
    public bool IsIdentity { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public Matrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    public double get_Determinant();
    public bool get_HasInverse();
    public static Matrix get_Identity();
    public bool get_IsIdentity();
    public double get_M11();
    public void set_M11(double value);
    public double get_M12();
    public void set_M12(double value);
    public double get_M21();
    public void set_M21(double value);
    public double get_M22();
    public void set_M22(double value);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    public void Append(Matrix matrix);
    public virtual bool Equals(object o);
    public bool Equals(Matrix value);
    public static bool Equals(Matrix matrix1, Matrix matrix2);
    public virtual int GetHashCode();
    public void Invert();
    public static Matrix Multiply(Matrix trans1, Matrix trans2);
    public static bool op_Equality(Matrix matrix1, Matrix matrix2);
    public static bool op_Inequality(Matrix matrix1, Matrix matrix2);
    public static Matrix op_Multiply(Matrix trans1, Matrix trans2);
    public static Matrix Parse(string source);
    public void Prepend(Matrix matrix);
    public void Rotate(double angle);
    public void RotateAt(double angle, double centerX, double centerY);
    public void RotateAtPrepend(double angle, double centerX, double centerY);
    public void RotatePrepend(double angle);
    public void Scale(double scaleX, double scaleY);
    public void ScaleAt(double scaleX, double scaleY, double centerX, double centerY);
    public void ScaleAtPrepend(double scaleX, double scaleY, double centerX, double centerY);
    public void ScalePrepend(double scaleX, double scaleY);
    public void SetIdentity();
    public void Skew(double skewX, double skewY);
    public void SkewPrepend(double skewX, double skewY);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public Point Transform(Point point);
    public void Transform(Point[] points);
    public Vector Transform(Vector vector);
    public void Transform(Vector[] vectors);
    public void Translate(double offsetX, double offsetY);
    public void TranslatePrepend(double offsetX, double offsetY);
}
public class System.Windows.Media.MatrixConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.TextFormattingMode : Enum {
    public int value__;
    public static TextFormattingMode Ideal;
    public static TextFormattingMode Display;
}
[DefaultMemberAttribute("Item")]
public class System.Windows.NameScope : object {
    public static DependencyProperty NameScopeProperty;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual object FindName(string name);
    [DesignerSerializationVisibilityAttribute("0")]
public static INameScope GetNameScope(DependencyObject dependencyObject);
    public sealed virtual void RegisterName(string name, object scopedElement);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual bool Remove(string key);
    public static void SetNameScope(DependencyObject dependencyObject, INameScope value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual void UnregisterName(string name);
}
[TypeConverterAttribute("System.Windows.PointConverter")]
[ValueSerializerAttribute("System.Windows.Converters.PointValueSerializer")]
public class System.Windows.Point : ValueType {
    public double X { get; public set; }
    public double Y { get; public set; }
    public Point(double x, double y);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public static Point Add(Point point, Vector vector);
    public virtual bool Equals(object o);
    public bool Equals(Point value);
    public static bool Equals(Point point1, Point point2);
    public virtual int GetHashCode();
    public static Point Multiply(Point point, Matrix matrix);
    public void Offset(double offsetX, double offsetY);
    public static Point op_Addition(Point point, Vector vector);
    public static bool op_Equality(Point point1, Point point2);
    public static Size op_Explicit(Point point);
    public static Vector op_Explicit(Point point);
    public static bool op_Inequality(Point point1, Point point2);
    public static Point op_Multiply(Point point, Matrix matrix);
    public static Vector op_Subtraction(Point point1, Point point2);
    public static Point op_Subtraction(Point point, Vector vector);
    public static Point Parse(string source);
    public static Vector Subtract(Point point1, Point point2);
    public static Point Subtract(Point point, Vector vector);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.PointConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.PropertyChangedCallback : MulticastDelegate {
    public PropertyChangedCallback(object object, IntPtr method);
    public virtual void Invoke(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, DependencyPropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.PropertyMetadata : object {
    public CoerceValueCallback CoerceValueCallback { get; public set; }
    public object DefaultValue { get; public set; }
    protected bool IsSealed { get; }
    public PropertyChangedCallback PropertyChangedCallback { get; public set; }
    public PropertyMetadata(object defaultValue);
    public PropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback);
    public PropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    public PropertyMetadata(PropertyChangedCallback propertyChangedCallback);
    public CoerceValueCallback get_CoerceValueCallback();
    public void set_CoerceValueCallback(CoerceValueCallback value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    protected bool get_IsSealed();
    public PropertyChangedCallback get_PropertyChangedCallback();
    public void set_PropertyChangedCallback(PropertyChangedCallback value);
    protected virtual void Merge(PropertyMetadata baseMetadata, DependencyProperty dp);
    protected virtual void OnApply(DependencyProperty dp, Type targetType);
}
[TypeConverterAttribute("System.Windows.RectConverter")]
[ValueSerializerAttribute("System.Windows.Converters.RectValueSerializer")]
public class System.Windows.Rect : ValueType {
    public double Bottom { get; }
    public Point BottomLeft { get; }
    public Point BottomRight { get; }
    public static Rect Empty { get; }
    public double Height { get; public set; }
    public bool IsEmpty { get; }
    public double Left { get; }
    public Point Location { get; public set; }
    public double Right { get; }
    public Size Size { get; public set; }
    public double Top { get; }
    public Point TopLeft { get; }
    public Point TopRight { get; }
    public double Width { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public Rect(double x, double y, double width, double height);
    public Rect(Point point1, Point point2);
    public Rect(Point location, Size size);
    public Rect(Point point, Vector vector);
    public Rect(Size size);
    public double get_Bottom();
    public Point get_BottomLeft();
    public Point get_BottomRight();
    public static Rect get_Empty();
    public double get_Height();
    public void set_Height(double value);
    public bool get_IsEmpty();
    public double get_Left();
    public Point get_Location();
    public void set_Location(Point value);
    public double get_Right();
    public Size get_Size();
    public void set_Size(Size value);
    public double get_Top();
    public Point get_TopLeft();
    public Point get_TopRight();
    public double get_Width();
    public void set_Width(double value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public bool Contains(double x, double y);
    public bool Contains(Point point);
    public bool Contains(Rect rect);
    public virtual bool Equals(object o);
    public bool Equals(Rect value);
    public static bool Equals(Rect rect1, Rect rect2);
    public virtual int GetHashCode();
    public void Inflate(double width, double height);
    public static Rect Inflate(Rect rect, double width, double height);
    public static Rect Inflate(Rect rect, Size size);
    public void Inflate(Size size);
    public void Intersect(Rect rect);
    public static Rect Intersect(Rect rect1, Rect rect2);
    public bool IntersectsWith(Rect rect);
    public void Offset(double offsetX, double offsetY);
    public static Rect Offset(Rect rect, double offsetX, double offsetY);
    public static Rect Offset(Rect rect, Vector offsetVector);
    public void Offset(Vector offsetVector);
    public static bool op_Equality(Rect rect1, Rect rect2);
    public static bool op_Inequality(Rect rect1, Rect rect2);
    public static Rect Parse(string source);
    public void Scale(double scaleX, double scaleY);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public void Transform(Matrix matrix);
    public static Rect Transform(Rect rect, Matrix matrix);
    public void Union(Point point);
    public void Union(Rect rect);
    public static Rect Union(Rect rect, Point point);
    public static Rect Union(Rect rect1, Rect rect2);
}
public class System.Windows.RectConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[TypeConverterAttribute("System.Windows.SizeConverter")]
[ValueSerializerAttribute("System.Windows.Converters.SizeValueSerializer")]
public class System.Windows.Size : ValueType {
    public static Size Empty { get; }
    public double Height { get; public set; }
    public bool IsEmpty { get; }
    public double Width { get; public set; }
    public Size(double width, double height);
    public static Size get_Empty();
    public double get_Height();
    public void set_Height(double value);
    public bool get_IsEmpty();
    public double get_Width();
    public void set_Width(double value);
    public virtual bool Equals(object o);
    public bool Equals(Size value);
    public static bool Equals(Size size1, Size size2);
    public virtual int GetHashCode();
    public static bool op_Equality(Size size1, Size size2);
    public static Point op_Explicit(Size size);
    public static Vector op_Explicit(Size size);
    public static bool op_Inequality(Size size1, Size size2);
    public static Size Parse(string source);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.SizeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.SplashScreen : object {
    public SplashScreen(Assembly resourceAssembly, string resourceName);
    public SplashScreen(string resourceName);
    public void Close(TimeSpan fadeoutDuration);
    public void Show(bool autoClose);
    public void Show(bool autoClose, bool topMost);
}
public class System.Windows.Threading.Dispatcher : object {
    public static Dispatcher CurrentDispatcher { get; }
    public bool HasShutdownFinished { get; }
    public bool HasShutdownStarted { get; }
    [EditorBrowsableAttribute("2")]
public DispatcherHooks Hooks { get; }
    public Thread Thread { get; }
    public static Dispatcher get_CurrentDispatcher();
    public bool get_HasShutdownFinished();
    public bool get_HasShutdownStarted();
    public DispatcherHooks get_Hooks();
    public Thread get_Thread();
    public void add_ShutdownFinished(EventHandler value);
    public void remove_ShutdownFinished(EventHandler value);
    public void add_ShutdownStarted(EventHandler value);
    public void remove_ShutdownStarted(EventHandler value);
    public void add_UnhandledException(DispatcherUnhandledExceptionEventHandler value);
    public void remove_UnhandledException(DispatcherUnhandledExceptionEventHandler value);
    public void add_UnhandledExceptionFilter(DispatcherUnhandledExceptionFilterEventHandler value);
    public void remove_UnhandledExceptionFilter(DispatcherUnhandledExceptionFilterEventHandler value);
    public DispatcherOperation BeginInvoke(Delegate method, Object[] args);
    public DispatcherOperation BeginInvoke(Delegate method, DispatcherPriority priority, Object[] args);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method, object arg, Object[] args);
    public void BeginInvokeShutdown(DispatcherPriority priority);
    [EditorBrowsableAttribute("1")]
public bool CheckAccess();
    public DispatcherProcessingDisabled DisableProcessing();
    public static void ExitAllFrames();
    public static Dispatcher FromThread(Thread thread);
    public void Invoke(Action callback);
    public void Invoke(Action callback, DispatcherPriority priority);
    public void Invoke(Action callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public void Invoke(Action callback, DispatcherPriority priority, CancellationToken cancellationToken, TimeSpan timeout);
    public object Invoke(Delegate method, Object[] args);
    public object Invoke(Delegate method, TimeSpan timeout, Object[] args);
    public object Invoke(Delegate method, TimeSpan timeout, DispatcherPriority priority, Object[] args);
    public object Invoke(Delegate method, DispatcherPriority priority, Object[] args);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method, object arg, Object[] args);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, Object[] args);
    public DispatcherOperation InvokeAsync(Action callback);
    public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority);
    public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback);
    public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback, DispatcherPriority priority);
    public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public void InvokeShutdown();
    public TResult Invoke(Func`1<TResult> callback);
    public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority);
    public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken, TimeSpan timeout);
    public static void PushFrame(DispatcherFrame frame);
    public static void Run();
    public static void ValidatePriority(DispatcherPriority priority, string parameterName);
    [EditorBrowsableAttribute("1")]
public void VerifyAccess();
    public static DispatcherPriorityAwaitable Yield();
    public static DispatcherPriorityAwaitable Yield(DispatcherPriority priority);
}
public class System.Windows.Threading.DispatcherEventArgs : EventArgs {
    public Dispatcher Dispatcher { get; }
    public Dispatcher get_Dispatcher();
}
public class System.Windows.Threading.DispatcherFrame : DispatcherObject {
    public bool Continue { get; public set; }
    public DispatcherFrame(bool exitWhenRequested);
    public bool get_Continue();
    public void set_Continue(bool value);
}
public class System.Windows.Threading.DispatcherHookEventArgs : EventArgs {
    public Dispatcher Dispatcher { get; }
    public DispatcherOperation Operation { get; }
    public DispatcherHookEventArgs(DispatcherOperation operation);
    public Dispatcher get_Dispatcher();
    public DispatcherOperation get_Operation();
}
public class System.Windows.Threading.DispatcherHookEventHandler : MulticastDelegate {
    public DispatcherHookEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherHookEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherHookEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Threading.DispatcherHooks : object {
    public void add_DispatcherInactive(EventHandler value);
    public void remove_DispatcherInactive(EventHandler value);
    public void add_OperationAborted(DispatcherHookEventHandler value);
    public void remove_OperationAborted(DispatcherHookEventHandler value);
    public void add_OperationCompleted(DispatcherHookEventHandler value);
    public void remove_OperationCompleted(DispatcherHookEventHandler value);
    public void add_OperationPosted(DispatcherHookEventHandler value);
    public void remove_OperationPosted(DispatcherHookEventHandler value);
    public void add_OperationPriorityChanged(DispatcherHookEventHandler value);
    public void remove_OperationPriorityChanged(DispatcherHookEventHandler value);
    public void add_OperationStarted(DispatcherHookEventHandler value);
    public void remove_OperationStarted(DispatcherHookEventHandler value);
}
public abstract class System.Windows.Threading.DispatcherObject : object {
    [EditorBrowsableAttribute("2")]
public Dispatcher Dispatcher { get; }
    public Dispatcher get_Dispatcher();
    [EditorBrowsableAttribute("1")]
public bool CheckAccess();
    [EditorBrowsableAttribute("1")]
public void VerifyAccess();
}
public class System.Windows.Threading.DispatcherOperation : object {
    public Dispatcher Dispatcher { get; }
    public DispatcherPriority Priority { get; public set; }
    public object Result { get; }
    public DispatcherOperationStatus Status { get; }
    public Task Task { get; }
    public Dispatcher get_Dispatcher();
    public DispatcherPriority get_Priority();
    public void set_Priority(DispatcherPriority value);
    public object get_Result();
    public DispatcherOperationStatus get_Status();
    public Task get_Task();
    public void add_Aborted(EventHandler value);
    public void remove_Aborted(EventHandler value);
    public void add_Completed(EventHandler value);
    public void remove_Completed(EventHandler value);
    public bool Abort();
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public TaskAwaiter GetAwaiter();
    protected virtual object InvokeDelegateCore();
    public DispatcherOperationStatus Wait();
    public DispatcherOperationStatus Wait(TimeSpan timeout);
}
public class System.Windows.Threading.DispatcherOperation`1 : DispatcherOperation {
    public TResult Result { get; }
    public Task`1<TResult> Task { get; }
    public TResult get_Result();
    public Task`1<TResult> get_Task();
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public TaskAwaiter`1<TResult> GetAwaiter();
    protected virtual object InvokeDelegateCore();
}
public class System.Windows.Threading.DispatcherOperationCallback : MulticastDelegate {
    public DispatcherOperationCallback(object object, IntPtr method);
    public virtual object Invoke(object arg);
    public virtual IAsyncResult BeginInvoke(object arg, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public enum System.Windows.Threading.DispatcherOperationStatus : Enum {
    public int value__;
    public static DispatcherOperationStatus Pending;
    public static DispatcherOperationStatus Aborted;
    public static DispatcherOperationStatus Completed;
    public static DispatcherOperationStatus Executing;
}
public enum System.Windows.Threading.DispatcherPriority : Enum {
    public int value__;
    public static DispatcherPriority Invalid;
    public static DispatcherPriority Inactive;
    public static DispatcherPriority SystemIdle;
    public static DispatcherPriority ApplicationIdle;
    public static DispatcherPriority ContextIdle;
    public static DispatcherPriority Background;
    public static DispatcherPriority Input;
    public static DispatcherPriority Loaded;
    public static DispatcherPriority Render;
    public static DispatcherPriority DataBind;
    public static DispatcherPriority Normal;
    public static DispatcherPriority Send;
}
public class System.Windows.Threading.DispatcherPriorityAwaitable : ValueType {
    public DispatcherPriorityAwaiter GetAwaiter();
}
public class System.Windows.Threading.DispatcherPriorityAwaiter : ValueType {
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
}
public class System.Windows.Threading.DispatcherProcessingDisabled : ValueType {
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DispatcherProcessingDisabled left, DispatcherProcessingDisabled right);
    public static bool op_Inequality(DispatcherProcessingDisabled left, DispatcherProcessingDisabled right);
}
public class System.Windows.Threading.DispatcherSynchronizationContext : SynchronizationContext {
    public DispatcherSynchronizationContext(Dispatcher dispatcher);
    public DispatcherSynchronizationContext(Dispatcher dispatcher, DispatcherPriority priority);
    public virtual SynchronizationContext CreateCopy();
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void Send(SendOrPostCallback d, object state);
    [PrePrepareMethodAttribute]
public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
}
public class System.Windows.Threading.DispatcherTimer : object {
    public Dispatcher Dispatcher { get; }
    public TimeSpan Interval { get; public set; }
    public bool IsEnabled { get; public set; }
    public object Tag { get; public set; }
    public DispatcherTimer(TimeSpan interval, DispatcherPriority priority, EventHandler callback, Dispatcher dispatcher);
    public DispatcherTimer(DispatcherPriority priority);
    public DispatcherTimer(DispatcherPriority priority, Dispatcher dispatcher);
    public Dispatcher get_Dispatcher();
    public TimeSpan get_Interval();
    public void set_Interval(TimeSpan value);
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public object get_Tag();
    public void set_Tag(object value);
    public void add_Tick(EventHandler value);
    public void remove_Tick(EventHandler value);
    public void Start();
    public void Stop();
}
public class System.Windows.Threading.DispatcherUnhandledExceptionEventArgs : DispatcherEventArgs {
    public Exception Exception { get; }
    public bool Handled { get; public set; }
    public Exception get_Exception();
    public bool get_Handled();
    public void set_Handled(bool value);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler : MulticastDelegate {
    public DispatcherUnhandledExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherUnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherUnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs : DispatcherEventArgs {
    public Exception Exception { get; }
    public bool RequestCatch { get; public set; }
    public Exception get_Exception();
    public bool get_RequestCatch();
    public void set_RequestCatch(bool value);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler : MulticastDelegate {
    public DispatcherUnhandledExceptionFilterEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherUnhandledExceptionFilterEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherUnhandledExceptionFilterEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.ValidateValueCallback : MulticastDelegate {
    public ValidateValueCallback(object object, IntPtr method);
    public virtual bool Invoke(object value);
    public virtual IAsyncResult BeginInvoke(object value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.VectorConverter")]
[ValueSerializerAttribute("System.Windows.Converters.VectorValueSerializer")]
public class System.Windows.Vector : ValueType {
    public double Length { get; }
    public double LengthSquared { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public Vector(double x, double y);
    public double get_Length();
    public double get_LengthSquared();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public static Point Add(Vector vector, Point point);
    public static Vector Add(Vector vector1, Vector vector2);
    public static double AngleBetween(Vector vector1, Vector vector2);
    public static double CrossProduct(Vector vector1, Vector vector2);
    public static double Determinant(Vector vector1, Vector vector2);
    public static Vector Divide(Vector vector, double scalar);
    public virtual bool Equals(object o);
    public bool Equals(Vector value);
    public static bool Equals(Vector vector1, Vector vector2);
    public virtual int GetHashCode();
    public static Vector Multiply(double scalar, Vector vector);
    public static Vector Multiply(Vector vector, double scalar);
    public static Vector Multiply(Vector vector, Matrix matrix);
    public static double Multiply(Vector vector1, Vector vector2);
    public void Negate();
    public void Normalize();
    public static Point op_Addition(Vector vector, Point point);
    public static Vector op_Addition(Vector vector1, Vector vector2);
    public static Vector op_Division(Vector vector, double scalar);
    public static bool op_Equality(Vector vector1, Vector vector2);
    public static Point op_Explicit(Vector vector);
    public static Size op_Explicit(Vector vector);
    public static bool op_Inequality(Vector vector1, Vector vector2);
    public static Vector op_Multiply(double scalar, Vector vector);
    public static Vector op_Multiply(Vector vector, double scalar);
    public static Vector op_Multiply(Vector vector, Matrix matrix);
    public static double op_Multiply(Vector vector1, Vector vector2);
    public static Vector op_Subtraction(Vector vector1, Vector vector2);
    public static Vector op_UnaryNegation(Vector vector);
    public static Vector Parse(string source);
    public static Vector Subtract(Vector vector1, Vector vector2);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
public class System.Windows.VectorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Windows.WeakEventManager : DispatcherObject {
    protected object Item { get; protected set; }
    protected IDisposable ReadLock { get; }
    protected IDisposable WriteLock { get; }
    protected object get_Item(object source);
    protected void set_Item(object source, object value);
    protected IDisposable get_ReadLock();
    protected IDisposable get_WriteLock();
    protected void DeliverEvent(object sender, EventArgs args);
    protected void DeliverEventToList(object sender, EventArgs args, ListenerList list);
    protected static WeakEventManager GetCurrentManager(Type managerType);
    protected virtual ListenerList NewListenerList();
    protected void ProtectedAddHandler(object source, Delegate handler);
    protected void ProtectedAddListener(object source, IWeakEventListener listener);
    protected void ProtectedRemoveHandler(object source, Delegate handler);
    protected void ProtectedRemoveListener(object source, IWeakEventListener listener);
    protected virtual bool Purge(object source, object data, bool purgeAll);
    protected void Remove(object source);
    protected void ScheduleCleanup();
    protected static void SetCurrentManager(Type managerType, WeakEventManager manager);
    protected abstract virtual void StartListening(object source);
    protected abstract virtual void StopListening(object source);
}
public class System.Windows.WeakEventManager`2 : WeakEventManager {
    public static void AddHandler(TEventSource source, string eventName, EventHandler`1<TEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    public static void RemoveHandler(TEventSource source, string eventName, EventHandler`1<TEventArgs> handler);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
