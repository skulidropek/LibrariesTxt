internal static class FxResources.WindowsBase.SR : object {
}
internal static class Interop : object {
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.AssemblyHelper : object {
    private static SystemDrawingExtensionMethods _systemDrawingExtensionMethods;
    private static SystemXmlExtensionMethods _systemXmlExtensionMethods;
    private static SystemXmlLinqExtensionMethods _systemXmlLinqExtensionMethods;
    private static SystemDataExtensionMethods _systemDataExtensionMethods;
    private static SystemCoreExtensionMethods _systemCoreExtensionMethods;
    private static AssemblyRecord[] _records;
    private static AssemblyHelper();
    [FriendAccessAllowedAttribute]
internal static bool IsLoaded(UncommonAssembly assemblyEnum);
    internal static SystemDrawingExtensionMethods ExtensionsForSystemDrawing(bool force);
    internal static SystemXmlExtensionMethods ExtensionsForSystemXml(bool force);
    internal static SystemXmlLinqExtensionMethods ExtensionsForSystemXmlLinq(bool force);
    internal static SystemDataExtensionMethods ExtensionsForSystemData(bool force);
    internal static SystemCoreExtensionMethods ExtensionsForSystemCore(bool force);
    private static object LoadExtensionFor(string name);
    private static void OnAssemblyLoad(object sender, AssemblyLoadEventArgs args);
    private static void OnLoaded(Assembly assembly);
}
internal class MS.Internal.AvTrace : object {
    [CompilerGeneratedAttribute]
private AvTraceEventHandler TraceExtraMessages;
    private bool _isEnabled;
    private bool _enabledByDebugger;
    private bool _suppressGeneratedParameters;
    private static bool _hasBeenRefreshed;
    private GetTraceSourceDelegate _getTraceSourceDelegate;
    private ClearTraceSourceDelegate _clearTraceSourceDelegate;
    private TraceSource _traceSource;
    private static Nullable`1<bool> _enabledInRegistry;
    private static Char[] FormatChars;
    public bool IsEnabled { get; }
    public bool SuppressGeneratedParameters { get; public set; }
    public bool IsEnabledOverride { get; }
    public bool EnabledByDebugger { get; public set; }
    public AvTrace(GetTraceSourceDelegate getTraceSourceDelegate, ClearTraceSourceDelegate clearTraceSourceDelegate);
    private static AvTrace();
    public void Refresh();
    public bool get_IsEnabled();
    public bool get_SuppressGeneratedParameters();
    public void set_SuppressGeneratedParameters(bool value);
    public bool get_IsEnabledOverride();
    public bool get_EnabledByDebugger();
    public void set_EnabledByDebugger(bool value);
    public static void OnRefresh();
    [CompilerGeneratedAttribute]
public void add_TraceExtraMessages(AvTraceEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_TraceExtraMessages(AvTraceEventHandler value);
    private void Initialize();
    private static bool ShouldCreateTraceSources();
    [FriendAccessAllowedAttribute]
internal static bool IsWpfTracingEnabledInRegistry();
    internal static bool IsDebuggerAttached();
    public string Trace(TraceEventType type, int eventId, string message, String[] labels, Object[] parameters);
    public void TraceStartStop(int eventID, string message, String[] labels, Object[] parameters);
    public static string ToStringHelper(object value);
    public static string AntiFormat(string s);
    public static string TypeName(object value);
    public static int GetHashCodeHelper(object value);
    public static Type GetTypeHelper(object value);
}
internal class MS.Internal.AvTraceBuilder : object {
    private StringBuilder _sb;
    public AvTraceBuilder(string message);
    public void Append(string message);
    public void AppendFormat(string message, Object[] args);
    public void AppendFormat(string message, object arg1);
    public void AppendFormat(string message, object arg1, object arg2);
    public void AppendFormat(string message, string arg1);
    public void AppendFormat(string message, string arg1, string arg2);
    public virtual string ToString();
}
internal class MS.Internal.AvTraceDetails : object {
    private int _id;
    private String[] _labels;
    public int Id { get; }
    public string Message { get; }
    public String[] Labels { get; }
    public AvTraceDetails(int id, String[] labels);
    public int get_Id();
    public virtual string get_Message();
    public String[] get_Labels();
}
internal class MS.Internal.AvTraceEventHandler : MulticastDelegate {
    public AvTraceEventHandler(object object, IntPtr method);
    public virtual void Invoke(AvTraceBuilder traceBuilder, Object[] parameters, int start);
    public virtual IAsyncResult BeginInvoke(AvTraceBuilder traceBuilder, Object[] parameters, int start, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.AvTraceFormat : AvTraceDetails {
    private string _message;
    public string Message { get; }
    public AvTraceFormat(AvTraceDetails details, Object[] args);
    public virtual string get_Message();
}
internal static class MS.Internal.BaseAppContextSwitches : object {
    internal static string SwitchDoNotUseCulturePreservingDispatcherOperations;
    private static int _doNotUseCulturePreservingDispatcherOperations;
    internal static string SwitchUseSha1AsDefaultHashAlgorithmForDigitalSignatures;
    private static int _useSha1AsDefaultHashAlgorithmForDigitalSignatures;
    internal static string SwitchDoNotInvokeInWeakEventTableShutdownListener;
    private static int _doNotInvokeInWeakEventTableShutdownListener;
    internal static string SwitchEnableWeakEventMemoryImprovements;
    private static int _enableWeakEventMemoryImprovements;
    internal static string SwitchEnableCleanupSchedulingImprovements;
    private static int _enableCleanupSchedulingImprovements;
    public static bool DoNotUseCulturePreservingDispatcherOperations { get; }
    public static bool UseSha1AsDefaultHashAlgorithmForDigitalSignatures { get; }
    public static bool DoNotInvokeInWeakEventTableShutdownListener { get; }
    public static bool EnableWeakEventMemoryImprovements { get; }
    public static bool EnableCleanupSchedulingImprovements { get; }
    public static bool get_DoNotUseCulturePreservingDispatcherOperations();
    public static bool get_UseSha1AsDefaultHashAlgorithmForDigitalSignatures();
    public static bool get_DoNotInvokeInWeakEventTableShutdownListener();
    public static bool get_EnableWeakEventMemoryImprovements();
    public static bool get_EnableCleanupSchedulingImprovements();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.BaseHashHelper : object {
    private static HybridDictionary _table;
    private static BaseHashHelper();
    [FriendAccessAllowedAttribute]
internal static void RegisterTypes(Assembly assembly, Type[] types);
    [FriendAccessAllowedAttribute]
internal static bool HasReliableHashCode(object item);
    private static HybridDictionary DictionaryFromList(Type[] types);
}
internal class MS.Internal.CleanupHelper : DispatcherObject {
    private DispatcherTimer _cleanupTimer;
    private DispatcherTimer _starvationTimer;
    private DispatcherTimer _defaultCleanupTimer;
    private DispatcherPriority _cleanupTimerPriority;
    private int _cleanupRequests;
    private bool _waitingForGC;
    private Func`2<bool, bool> _cleanupCallback;
    private TimeSpan _basePollingInterval;
    private TimeSpan _maxPollingInterval;
    internal CleanupHelper(Func`2<bool, bool> callback, int pollingInterval, int promotionInterval, int maxInterval);
    internal void ScheduleCleanup();
    internal bool DoCleanup(bool forceCleanup);
    private void OnCleanupTick(object sender, EventArgs e);
    private void OnStarvationTick(object sender, EventArgs e);
}
internal class MS.Internal.ClearTraceSourceDelegate : MulticastDelegate {
    public ClearTraceSourceDelegate(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.ComponentModel.APCustomTypeDescriptor : ValueType {
    private ICustomTypeDescriptor _parent;
    private DependencyObject _instance;
    private static object _syncLock;
    private static int _dpCacheCount;
    private static DependencyProperty[] _dpCacheArray;
    internal APCustomTypeDescriptor(ICustomTypeDescriptor parent, object instance);
    private static APCustomTypeDescriptor();
    public sealed virtual PropertyDescriptorCollection GetProperties();
    public sealed virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public sealed virtual AttributeCollection GetAttributes();
    public sealed virtual string GetClassName();
    public sealed virtual string GetComponentName();
    public sealed virtual TypeConverter GetConverter();
    public sealed virtual EventDescriptor GetDefaultEvent();
    public sealed virtual PropertyDescriptor GetDefaultProperty();
    public sealed virtual object GetEditor(Type editorBaseType);
    public sealed virtual EventDescriptorCollection GetEvents();
    public sealed virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public sealed virtual object GetPropertyOwner(PropertyDescriptor property);
    private bool CanAttachProperty(DependencyProperty dp, DependencyObject instance);
    private static DependencyObject FromObj(object value);
    private DependencyProperty[] GetRegisteredProperties();
}
internal class MS.Internal.ComponentModel.AttachedPropertyMethodSelector : Binder {
    public virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    private static bool ParametersMatch(ParameterInfo[] parameters, Type[] types);
    public virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    public virtual object ChangeType(object value, Type type, CultureInfo culture);
    public virtual void ReorderArgumentArray(Object[]& args, object state);
    public virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
}
internal class MS.Internal.ComponentModel.AttachInfo : object {
    private DependencyProperty _dp;
    private MethodInfo _getMethod;
    private AttachedPropertyBrowsableAttribute[] _attributes;
    private AttachedPropertyBrowsableAttribute _paramTypeAttribute;
    private bool _attributesChecked;
    private bool _getMethodChecked;
    private bool _paramTypeAttributeChecked;
    private MethodInfo AttachMethod { get; }
    private AttachedPropertyBrowsableAttribute[] Attributes { get; }
    private AttachedPropertyBrowsableAttribute ParameterTypeAttribute { get; }
    internal AttachInfo(DependencyProperty dp);
    private MethodInfo get_AttachMethod();
    private AttachedPropertyBrowsableAttribute[] get_Attributes();
    private AttachedPropertyBrowsableAttribute get_ParameterTypeAttribute();
    internal bool CanAttach(DependencyObject instance);
}
internal class MS.Internal.ComponentModel.DependencyObjectPropertyDescriptor : PropertyDescriptor {
    private static Binder _dpBinder;
    private static object _nullMethodSentinel;
    private static Hashtable _getMethodCache;
    private static Hashtable _setMethodCache;
    private static object _attributeSyncLock;
    private PropertyDescriptor _property;
    private DependencyProperty _dp;
    private Type _componentType;
    private PropertyMetadata _metadata;
    private bool _queriedShouldSerializeMethod;
    private bool _queriedResetMethod;
    private Dictionary`2<DependencyObject, PropertyChangeTracker> _trackers;
    private MethodInfo _shouldSerializeMethod;
    private MethodInfo _resetMethod;
    private static Type[] _dpType;
    private static Type _boolType;
    private static Type _attributeType;
    private static Type _attachedPropertyBrowsableType;
    public AttributeCollection Attributes { get; }
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public bool SupportsChangeEvents { get; }
    internal DependencyProperty DependencyProperty { get; }
    internal bool IsAttached { get; }
    internal PropertyMetadata Metadata { get; }
    internal static Type AttachedPropertyBrowsableAttributeType { get; }
    private static Type AttributeType { get; }
    private static Type BoolType { get; }
    private static Type[] DpType { get; }
    internal DependencyObjectPropertyDescriptor(PropertyDescriptor property, DependencyProperty dp, Type objectType);
    internal DependencyObjectPropertyDescriptor(DependencyProperty dp, Type ownerType);
    private static DependencyObjectPropertyDescriptor();
    public virtual bool CanResetValue(object component);
    public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual void AddValueChanged(object component, EventHandler handler);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
    public virtual AttributeCollection get_Attributes();
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    public virtual bool get_SupportsChangeEvents();
    internal DependencyProperty get_DependencyProperty();
    internal bool get_IsAttached();
    internal PropertyMetadata get_Metadata();
    internal static void ClearCache();
    internal static MethodInfo GetAttachedPropertyMethod(DependencyProperty dp);
    protected virtual AttributeCollection CreateAttributeCollection();
    private static DependencyObject FromObj(object value);
    private AttributeCollection GetAttachedPropertyAttributes();
    private static MethodInfo GetAttachedPropertySetMethod(DependencyProperty dp);
    private MethodInfo GetSpecialMethod(string methodPrefix);
    private void MergeAttributes();
    internal static Type get_AttachedPropertyBrowsableAttributeType();
    private static Type get_AttributeType();
    private static Type get_BoolType();
    private static Type[] get_DpType();
}
internal class MS.Internal.ComponentModel.DependencyObjectProvider : TypeDescriptionProvider {
    private static UncommonField`1<IDictionary> _cacheSlot;
    private static Dictionary`2<PropertyKey, DependencyObjectPropertyDescriptor> _propertyMap;
    private static Dictionary`2<PropertyKey, DependencyPropertyKind> _propertyKindMap;
    private static Hashtable _attachInfoMap;
    private static DependencyObjectProvider();
    public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance);
    public virtual ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance);
    public virtual IDictionary GetCache(object instance);
    private static void ClearCache();
    internal static AttachInfo GetAttachInfo(DependencyProperty dp);
    internal static DependencyObjectPropertyDescriptor GetAttachedPropertyDescriptor(DependencyProperty dp, Type targetType);
    internal static DependencyPropertyKind GetDependencyPropertyKind(DependencyProperty dp, Type targetType);
}
[AttributeUsageAttribute("64")]
internal class MS.Internal.ComponentModel.DependencyPropertyAttribute : Attribute {
    private DependencyProperty _dp;
    private bool _isAttached;
    public object TypeId { get; }
    internal bool IsAttached { get; }
    internal DependencyProperty DependencyProperty { get; }
    internal DependencyPropertyAttribute(DependencyProperty dependencyProperty, bool isAttached);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual object get_TypeId();
    internal bool get_IsAttached();
    internal DependencyProperty get_DependencyProperty();
}
internal class MS.Internal.ComponentModel.DependencyPropertyKind : object {
    private DependencyProperty _dp;
    private Type _targetType;
    private bool _isAttached;
    private bool _isAttachedChecked;
    private bool _isInternal;
    private bool _isInternalChecked;
    private bool _isDirect;
    private bool _isDirectChecked;
    internal bool IsInternal { get; }
    internal bool IsAttached { get; }
    internal bool IsDirect { get; }
    internal DependencyPropertyKind(DependencyProperty dp, Type targetType);
    internal bool get_IsInternal();
    internal bool get_IsAttached();
    internal bool get_IsDirect();
}
internal class MS.Internal.ComponentModel.DPCustomTypeDescriptor : ValueType {
    private ICustomTypeDescriptor _parent;
    private Type _objectType;
    private object _instance;
    private static Dictionary`2<PropertyDescriptor, DependencyObjectPropertyDescriptor> _propertyMap;
    private static Hashtable _typeProperties;
    private static PropertyFilterOptions _anySet;
    private static PropertyFilterOptions _anyValid;
    internal DPCustomTypeDescriptor(ICustomTypeDescriptor parent, Type objectType, object instance);
    private static DPCustomTypeDescriptor();
    public sealed virtual string GetComponentName();
    public sealed virtual PropertyDescriptorCollection GetProperties();
    public sealed virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public sealed virtual AttributeCollection GetAttributes();
    public sealed virtual string GetClassName();
    public sealed virtual TypeConverter GetConverter();
    public sealed virtual EventDescriptor GetDefaultEvent();
    public sealed virtual PropertyDescriptor GetDefaultProperty();
    public sealed virtual object GetEditor(Type editorBaseType);
    public sealed virtual EventDescriptorCollection GetEvents();
    public sealed virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public sealed virtual object GetPropertyOwner(PropertyDescriptor property);
    internal static void ClearCache();
    private PropertyDescriptorCollection CreateProperties();
}
internal class MS.Internal.ComponentModel.PropertyChangeTracker : Expression {
    internal EventHandler Changed;
    private DependencyObject _object;
    private DependencyProperty _property;
    internal bool CanClose { get; }
    internal PropertyChangeTracker(DependencyObject obj, DependencyProperty property);
    internal virtual void OnPropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    internal void Close();
    internal bool get_CanClose();
}
internal class MS.Internal.ComponentModel.PropertyDescriptorComparer : object {
    public sealed virtual bool Equals(PropertyDescriptor p1, PropertyDescriptor p2);
    public sealed virtual int GetHashCode(PropertyDescriptor p);
}
internal class MS.Internal.ComponentModel.PropertyKey : ValueType {
    internal DependencyProperty DependencyProperty;
    internal Type AttachedType;
    private int _hashCode;
    internal PropertyKey(Type attachedType, DependencyProperty prop);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PropertyKey key);
    public static bool op_Equality(PropertyKey key1, PropertyKey key2);
    public static bool op_Inequality(PropertyKey key1, PropertyKey key2);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.ContentType : object {
    private string _contentType;
    private string _type;
    private string _subType;
    private string _originalString;
    private Dictionary`2<string, string> _parameterDictionary;
    private bool _isInitialized;
    private static string _quote;
    private static char _semicolonSeparator;
    private static char _equalSeparator;
    private static Char[] _allowedCharacters;
    private static Char[] _LinearWhiteSpaceChars;
    private static ContentType _emptyContentType;
    internal string TypeComponent { get; }
    internal string SubTypeComponent { get; }
    internal Enumerator<string, string> ParameterValuePairs { get; }
    internal static ContentType Empty { get; }
    internal string OriginalString { get; }
    internal ContentType(string contentType);
    private static ContentType();
    internal string get_TypeComponent();
    internal string get_SubTypeComponent();
    internal Enumerator<string, string> get_ParameterValuePairs();
    internal static ContentType get_Empty();
    internal string get_OriginalString();
    internal bool AreTypeAndSubTypeEqual(ContentType contentType);
    internal bool AreTypeAndSubTypeEqual(ContentType contentType, bool allowParameterValuePairs);
    public virtual string ToString();
    private static void ValidateCarriageReturns(string contentType);
    private void ParseTypeAndSubType(ReadOnlySpan`1<char> typeAndSubType);
    private void ParseParameterAndValue(ReadOnlySpan`1<char> parameterAndValue);
    private static int GetLengthOfParameterValue(ReadOnlySpan`1<char> s, int startIndex);
    private static string ValidateToken(string token);
    private static string ValidateQuotedStringOrToken(string parameterValue);
    private static void ValidateQuotedText(ReadOnlySpan`1<char> quotedText);
    private static bool IsAllowedCharacter(char character);
    private static bool IsAsciiLetterOrDigit(char character);
    private static bool IsLinearWhiteSpaceChar(char ch);
    private void EnsureParameterDictionary();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.CopyOnWriteList : object {
    private object _syncRoot;
    private ArrayList _LiveList;
    private ArrayList _readonlyWrapper;
    public ArrayList List { get; }
    protected object SyncRoot { get; }
    protected ArrayList LiveList { get; }
    public CopyOnWriteList(object syncRoot);
    public ArrayList get_List();
    public virtual bool Add(object obj);
    public virtual bool Remove(object obj);
    protected object get_SyncRoot();
    protected ArrayList get_LiveList();
    protected bool Internal_Add(object obj);
    protected bool Internal_Insert(int index, object obj);
    private int Find(object obj);
    protected bool RemoveAt(int index);
    protected void DoCopyOnWriteCheck();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.CriticalExceptions : object {
    [FriendAccessAllowedAttribute]
internal static bool IsCriticalException(Exception ex);
    [FriendAccessAllowedAttribute]
internal static bool IsCriticalApplicationException(Exception ex);
    [FriendAccessAllowedAttribute]
internal static Exception Unwrap(Exception ex);
}
internal class MS.Internal.CulturePreservingExecutionContext : object {
    private bool _disposed;
    private ExecutionContext _context;
    private CultureAndContextManager _cultureAndContext;
    private static ContextCallback CallbackWrapperDelegate;
    private static CulturePreservingExecutionContext();
    public static CulturePreservingExecutionContext Capture();
    public static void Run(CulturePreservingExecutionContext executionContext, ContextCallback callback, object state);
    private static void CallbackWrapper(object obj);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[FriendAccessAllowedAttribute]
internal abstract class MS.Internal.DefaultValueFactory : object {
    internal object DefaultValue { get; }
    internal abstract virtual object get_DefaultValue();
    internal abstract virtual object CreateDefaultValue(DependencyObject owner, DependencyProperty property);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.DoubleUtil : object {
    internal static double DBL_EPSILON;
    internal static float FLT_MIN;
    public static bool AreClose(double value1, double value2);
    public static bool LessThan(double value1, double value2);
    public static bool GreaterThan(double value1, double value2);
    public static bool GreaterThanZero(double value);
    public static bool LessThanOrClose(double value1, double value2);
    public static bool GreaterThanOrClose(double value1, double value2);
    public static bool IsOne(double value);
    public static bool IsZero(double value);
    public static bool AreClose(Point point1, Point point2);
    public static bool AreClose(Size size1, Size size2);
    public static bool AreClose(Vector vector1, Vector vector2);
    public static bool AreClose(Rect rect1, Rect rect2);
    public static bool IsBetweenZeroAndOne(double val);
    public static int DoubleToInt(double val);
    public static bool RectHasNaN(Rect r);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.FreezableDefaultValueFactory : DefaultValueFactory {
    private Freezable _defaultValuePrototype;
    internal object DefaultValue { get; }
    internal FreezableDefaultValueFactory(Freezable defaultValue);
    internal virtual object get_DefaultValue();
    internal virtual object CreateDefaultValue(DependencyObject owner, DependencyProperty property);
}
internal static class MS.Internal.GenericsInstances : object {
    private static ObservableCollection`1<object> s_OC_Empty;
    private static ReadOnlyObservableCollection`1<object> s_ROOC_Empty;
    private static Predicate`1<object> s_PM_Empty;
    private static GenericsInstances();
    private static bool PredicateMethod(object item);
}
internal class MS.Internal.GetTraceSourceDelegate : MulticastDelegate {
    public GetTraceSourceDelegate(object object, IntPtr method);
    public virtual TraceSource Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TraceSource EndInvoke(IAsyncResult result);
}
internal static class MS.Internal.Hashing.WindowsBase.HashHelper : object {
    private static HashHelper();
    internal static bool HasReliableHashCode(object item);
    internal static void Initialize();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.InheritanceContextChangedEventManager : WeakEventManager {
    private static InheritanceContextChangedEventManager CurrentManager { get; }
    public static void AddListener(DependencyObject source, IWeakEventListener listener);
    public static void RemoveListener(DependencyObject source, IWeakEventListener listener);
    public static void AddHandler(DependencyObject source, EventHandler`1<EventArgs> handler);
    public static void RemoveHandler(DependencyObject source, EventHandler`1<EventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private static InheritanceContextChangedEventManager get_CurrentManager();
    private void OnInheritanceContextChanged(object sender, EventArgs args);
}
internal static class MS.Internal.InheritanceContextHelper : object {
    [FriendAccessAllowedAttribute]
internal static void ProvideContextForObject(DependencyObject context, DependencyObject newValue);
    [FriendAccessAllowedAttribute]
internal static void RemoveContextFromObject(DependencyObject context, DependencyObject oldValue);
    [FriendAccessAllowedAttribute]
internal static void AddInheritanceContext(DependencyObject newInheritanceContext, DependencyObject value, Boolean& hasMultipleInheritanceContexts, DependencyObject& inheritanceContext);
    [FriendAccessAllowedAttribute]
internal static void RemoveInheritanceContext(DependencyObject oldInheritanceContext, DependencyObject value, Boolean& hasMultipleInheritanceContexts, DependencyObject& inheritanceContext);
}
internal enum MS.Internal.Interop.ADLT : Enum {
    public int value__;
    public static ADLT RECENT;
    public static ADLT FREQUENT;
}
internal class MS.Internal.Interop.CHANGEFILTERSTRUCT : ValueType {
    public UInt32 cbSize;
    public MSGFLTINFO ExtStatus;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.DOGIF : Enum {
    public int value__;
    public static DOGIF DEFAULT;
    public static DOGIF TRAVERSE_LINK;
    public static DOGIF NO_HDROP;
    public static DOGIF NO_URL;
    public static DOGIF ONLY_IF_ONE;
}
internal enum MS.Internal.Interop.Facility : Enum {
    public int value__;
    public static Facility Null;
    public static Facility Rpc;
    public static Facility Dispatch;
    public static Facility Storage;
    public static Facility Itf;
    public static Facility Win32;
    public static Facility Windows;
    public static Facility Control;
    public static Facility Ese;
}
internal enum MS.Internal.Interop.FDAP : Enum {
    public UInt32 value__;
    public static FDAP BOTTOM;
    public static FDAP TOP;
}
internal enum MS.Internal.Interop.FDEOR : Enum {
    public int value__;
    public static FDEOR DEFAULT;
    public static FDEOR ACCEPT;
    public static FDEOR REFUSE;
}
internal enum MS.Internal.Interop.FDESVR : Enum {
    public int value__;
    public static FDESVR DEFAULT;
    public static FDESVR ACCEPT;
    public static FDESVR REFUSE;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.FOS : Enum {
    public UInt32 value__;
    public static FOS OVERWRITEPROMPT;
    public static FOS STRICTFILETYPES;
    public static FOS NOCHANGEDIR;
    public static FOS PICKFOLDERS;
    public static FOS FORCEFILESYSTEM;
    public static FOS ALLNONSTORAGEITEMS;
    public static FOS NOVALIDATE;
    public static FOS ALLOWMULTISELECT;
    public static FOS PATHMUSTEXIST;
    public static FOS FILEMUSTEXIST;
    public static FOS CREATEPROMPT;
    public static FOS SHAREAWARE;
    public static FOS NOREADONLYRETURN;
    public static FOS NOTESTFILECREATE;
    public static FOS HIDEMRUPLACES;
    public static FOS HIDEPINNEDPLACES;
    public static FOS NODEREFERENCELINKS;
    public static FOS DONTADDTORECENT;
    public static FOS FORCESHOWHIDDEN;
    public static FOS DEFAULTNOMINIMODE;
    public static FOS FORCEPREVIEWPANEON;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.GPS : Enum {
    public int value__;
    public static GPS DEFAULT;
    public static GPS HANDLERPROPERTIESONLY;
    public static GPS READWRITE;
    public static GPS TEMPORARY;
    public static GPS FASTPROPERTIESONLY;
    public static GPS OPENSLOWITEM;
    public static GPS DELAYCREATION;
    public static GPS BESTEFFORT;
    public static GPS NO_OPLOCK;
    public static GPS MASK_VALID;
}
internal class MS.Internal.Interop.HRESULT : ValueType {
    private UInt32 _value;
    public static HRESULT S_OK;
    public static HRESULT S_FALSE;
    public static HRESULT E_NOTIMPL;
    public static HRESULT E_NOINTERFACE;
    public static HRESULT E_POINTER;
    public static HRESULT E_ABORT;
    public static HRESULT E_FAIL;
    public static HRESULT E_UNEXPECTED;
    public static HRESULT DISP_E_MEMBERNOTFOUND;
    public static HRESULT DISP_E_TYPEMISMATCH;
    public static HRESULT DISP_E_UNKNOWNNAME;
    public static HRESULT DISP_E_EXCEPTION;
    public static HRESULT DISP_E_OVERFLOW;
    public static HRESULT DISP_E_BADINDEX;
    public static HRESULT DISP_E_BADPARAMCOUNT;
    public static HRESULT DISP_E_PARAMNOTOPTIONAL;
    public static HRESULT SCRIPT_E_REPORTED;
    public static HRESULT STG_E_INVALIDFUNCTION;
    public static HRESULT DESTS_E_NO_MATCHING_ASSOC_HANDLER;
    public static HRESULT E_ACCESSDENIED;
    public static HRESULT E_OUTOFMEMORY;
    public static HRESULT E_INVALIDARG;
    public static HRESULT COR_E_OBJECTDISPOSED;
    public static HRESULT WC_E_GREATERTHAN;
    public static HRESULT WC_E_SYNTAX;
    public Facility Facility { get; }
    public int Code { get; }
    public bool Succeeded { get; }
    public bool Failed { get; }
    public HRESULT(UInt32 i);
    private static HRESULT();
    public static HRESULT Make(bool severe, Facility facility, int code);
    public Facility get_Facility();
    public static Facility GetFacility(int errorCode);
    public int get_Code();
    public static int GetCode(int error);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HRESULT hrLeft, HRESULT hrRight);
    public static bool op_Inequality(HRESULT hrLeft, HRESULT hrRight);
    public bool get_Succeeded();
    public bool get_Failed();
    public void ThrowIfFailed();
    public void ThrowIfFailed(string message);
    public Exception GetException();
    public Exception GetException(string message);
}
internal enum MS.Internal.Interop.KDC : Enum {
    public int value__;
    public static KDC FREQUENT;
    public static KDC RECENT;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.KF_FLAG : Enum {
    public UInt32 value__;
    public static KF_FLAG DEFAULT;
    public static KF_FLAG CREATE;
    public static KF_FLAG DONT_VERIFY;
    public static KF_FLAG DONT_UNEXPAND;
    public static KF_FLAG NO_ALIAS;
    public static KF_FLAG INIT;
    public static KF_FLAG DEFAULT_PATH;
    public static KF_FLAG NOT_PARENT_RELATIVE;
    public static KF_FLAG SIMPLE_IDLIST;
    public static KF_FLAG ALIAS_ONLY;
}
internal enum MS.Internal.Interop.MSGFLT : Enum {
    public int value__;
    public static MSGFLT RESET;
    public static MSGFLT ALLOW;
    public static MSGFLT DISALLOW;
}
internal enum MS.Internal.Interop.MSGFLTINFO : Enum {
    public int value__;
    public static MSGFLTINFO NONE;
    public static MSGFLTINFO ALREADYALLOWED_FORWND;
    public static MSGFLTINFO ALREADYDISALLOWED_FORWND;
    public static MSGFLTINFO ALLOWED_HIGHER;
}
internal class MS.Internal.Interop.PROPVARIANT : object {
    private ushort vt;
    private IntPtr pointerVal;
    private byte byteVal;
    private long longVal;
    private short boolVal;
    public VarEnum VarType { get; }
    public VarEnum get_VarType();
    public string GetValue();
    public void SetValue(bool f);
    public void SetValue(string val);
    public void Clear();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Dispose(bool disposing);
}
[FlagsAttribute]
internal enum MS.Internal.Interop.SFGAO : Enum {
    public UInt32 value__;
    public static SFGAO CANCOPY;
    public static SFGAO CANMOVE;
    public static SFGAO CANLINK;
    public static SFGAO STORAGE;
    public static SFGAO CANRENAME;
    public static SFGAO CANDELETE;
    public static SFGAO HASPROPSHEET;
    public static SFGAO DROPTARGET;
    public static SFGAO CAPABILITYMASK;
    public static SFGAO ENCRYPTED;
    public static SFGAO ISSLOW;
    public static SFGAO GHOSTED;
    public static SFGAO LINK;
    public static SFGAO SHARE;
    public static SFGAO READONLY;
    public static SFGAO HIDDEN;
    public static SFGAO DISPLAYATTRMASK;
    public static SFGAO FILESYSANCESTOR;
    public static SFGAO FOLDER;
    public static SFGAO FILESYSTEM;
    public static SFGAO HASSUBFOLDER;
    public static SFGAO CONTENTSMASK;
    public static SFGAO VALIDATE;
    public static SFGAO REMOVABLE;
    public static SFGAO COMPRESSED;
    public static SFGAO BROWSABLE;
    public static SFGAO NONENUMERATED;
    public static SFGAO NEWCONTENT;
    public static SFGAO CANMONIKER;
    public static SFGAO HASSTORAGE;
    public static SFGAO STREAM;
    public static SFGAO STORAGEANCESTOR;
    public static SFGAO STORAGECAPMASK;
    public static SFGAO PKEYSFGAOMASK;
}
internal enum MS.Internal.Interop.SHARD : Enum {
    public int value__;
    public static SHARD PIDL;
    public static SHARD PATHA;
    public static SHARD PATHW;
    public static SHARD APPIDINFO;
    public static SHARD APPIDINFOIDLIST;
    public static SHARD LINK;
    public static SHARD APPIDINFOLINK;
    public static SHARD SHELLITEM;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.SHCONTF : Enum {
    public int value__;
    public static SHCONTF CHECKING_FOR_CHILDREN;
    public static SHCONTF FOLDERS;
    public static SHCONTF NONFOLDERS;
    public static SHCONTF INCLUDEHIDDEN;
    public static SHCONTF INIT_ON_FIRST_NEXT;
    public static SHCONTF NETPRINTERSRCH;
    public static SHCONTF SHAREABLE;
    public static SHCONTF STORAGE;
    public static SHCONTF NAVIGATION_ENUM;
    public static SHCONTF FASTITEMS;
    public static SHCONTF FLATLIST;
    public static SHCONTF ENABLE_ASYNC;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.SHGDN : Enum {
    public int value__;
    public static SHGDN SHGDN_NORMAL;
    public static SHGDN SHGDN_INFOLDER;
    public static SHGDN SHGDN_FOREDITING;
    public static SHGDN SHGDN_FORADDRESSBAR;
    public static SHGDN SHGDN_FORPARSING;
}
internal enum MS.Internal.Interop.SIATTRIBFLAGS : Enum {
    public int value__;
    public static SIATTRIBFLAGS AND;
    public static SIATTRIBFLAGS OR;
    public static SIATTRIBFLAGS APPCOMPAT;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.SICHINT : Enum {
    public UInt32 value__;
    public static SICHINT DISPLAY;
    public static SICHINT ALLFIELDS;
    public static SICHINT CANONICAL;
    public static SICHINT TEST_FILESYSPATH_IF_NOT_EQUAL;
}
internal enum MS.Internal.Interop.SIGDN : Enum {
    public UInt32 value__;
    public static SIGDN NORMALDISPLAY;
    public static SIGDN PARENTRELATIVEPARSING;
    public static SIGDN DESKTOPABSOLUTEPARSING;
    public static SIGDN PARENTRELATIVEEDITING;
    public static SIGDN DESKTOPABSOLUTEEDITING;
    public static SIGDN FILESYSPATH;
    public static SIGDN URL;
    public static SIGDN PARENTRELATIVEFORADDRESSBAR;
    public static SIGDN PARENTRELATIVE;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.SLGP : Enum {
    public int value__;
    public static SLGP SHORTPATH;
    public static SLGP UNCPRIORITY;
    public static SLGP RAWPATH;
}
internal enum MS.Internal.Interop.SM : Enum {
    public int value__;
    public static SM CXSCREEN;
    public static SM CYSCREEN;
    public static SM CXVSCROLL;
    public static SM CYHSCROLL;
    public static SM CYCAPTION;
    public static SM CXBORDER;
    public static SM CYBORDER;
    public static SM CXFIXEDFRAME;
    public static SM CYFIXEDFRAME;
    public static SM CYVTHUMB;
    public static SM CXHTHUMB;
    public static SM CXICON;
    public static SM CYICON;
    public static SM CXCURSOR;
    public static SM CYCURSOR;
    public static SM CYMENU;
    public static SM CXFULLSCREEN;
    public static SM CYFULLSCREEN;
    public static SM CYKANJIWINDOW;
    public static SM MOUSEPRESENT;
    public static SM CYVSCROLL;
    public static SM CXHSCROLL;
    public static SM DEBUG;
    public static SM SWAPBUTTON;
    public static SM CXMIN;
    public static SM CYMIN;
    public static SM CXSIZE;
    public static SM CYSIZE;
    public static SM CXFRAME;
    public static SM CXSIZEFRAME;
    public static SM CYFRAME;
    public static SM CYSIZEFRAME;
    public static SM CXMINTRACK;
    public static SM CYMINTRACK;
    public static SM CXDOUBLECLK;
    public static SM CYDOUBLECLK;
    public static SM CXICONSPACING;
    public static SM CYICONSPACING;
    public static SM MENUDROPALIGNMENT;
    public static SM PENWINDOWS;
    public static SM DBCSENABLED;
    public static SM CMOUSEBUTTONS;
    public static SM SECURE;
    public static SM CXEDGE;
    public static SM CYEDGE;
    public static SM CXMINSPACING;
    public static SM CYMINSPACING;
    public static SM CXSMICON;
    public static SM CYSMICON;
    public static SM CYSMCAPTION;
    public static SM CXSMSIZE;
    public static SM CYSMSIZE;
    public static SM CXMENUSIZE;
    public static SM CYMENUSIZE;
    public static SM ARRANGE;
    public static SM CXMINIMIZED;
    public static SM CYMINIMIZED;
    public static SM CXMAXTRACK;
    public static SM CYMAXTRACK;
    public static SM CXMAXIMIZED;
    public static SM CYMAXIMIZED;
    public static SM NETWORK;
    public static SM CLEANBOOT;
    public static SM CXDRAG;
    public static SM CYDRAG;
    public static SM SHOWSOUNDS;
    public static SM CXMENUCHECK;
    public static SM CYMENUCHECK;
    public static SM SLOWMACHINE;
    public static SM MIDEASTENABLED;
    public static SM MOUSEWHEELPRESENT;
    public static SM XVIRTUALSCREEN;
    public static SM YVIRTUALSCREEN;
    public static SM CXVIRTUALSCREEN;
    public static SM CYVIRTUALSCREEN;
    public static SM CMONITORS;
    public static SM SAMEDISPLAYFORMAT;
    public static SM IMMENABLED;
    public static SM CXFOCUSBORDER;
    public static SM CYFOCUSBORDER;
    public static SM TABLETPC;
    public static SM MEDIACENTER;
    public static SM REMOTESESSION;
    public static SM REMOTECONTROL;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.STPF : Enum {
    public int value__;
    public static STPF NONE;
    public static STPF USEAPPTHUMBNAILALWAYS;
    public static STPF USEAPPTHUMBNAILWHENACTIVE;
    public static STPF USEAPPPEEKALWAYS;
    public static STPF USEAPPPEEKWHENACTIVE;
}
internal static class MS.Internal.Interop.STR_GPS : object {
    public static string HANDLERPROPERTIESONLY;
    public static string FASTPROPERTIESONLY;
    public static string OPENSLOWITEM;
    public static string DELAYCREATION;
    public static string BESTEFFORT;
    public static string NO_OPLOCK;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.TBPF : Enum {
    public int value__;
    public static TBPF NOPROGRESS;
    public static TBPF INDETERMINATE;
    public static TBPF NORMAL;
    public static TBPF ERROR;
    public static TBPF PAUSED;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.THB : Enum {
    public UInt32 value__;
    public static THB BITMAP;
    public static THB ICON;
    public static THB TOOLTIP;
    public static THB FLAGS;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.THBF : Enum {
    public UInt32 value__;
    public static THBF ENABLED;
    public static THBF DISABLED;
    public static THBF DISMISSONCLICK;
    public static THBF NOBACKGROUND;
    public static THBF HIDDEN;
    public static THBF NONINTERACTIVE;
}
[BestFitMappingAttribute("False")]
internal class MS.Internal.Interop.WIN32_FIND_DATAW : object {
    public FileAttributes dwFileAttributes;
    public FILETIME ftCreationTime;
    public FILETIME ftLastAccessTime;
    public FILETIME ftLastWriteTime;
    public int nFileSizeHigh;
    public int nFileSizeLow;
    public int dwReserved0;
    public int dwReserved1;
    public string cFileName;
    public string cAlternateFileName;
}
internal static class MS.Internal.Interop.Win32Constant : object {
    internal static int MAX_PATH;
    internal static int INFOTIPSIZE;
    internal static int TRUE;
    internal static int FALSE;
}
internal class MS.Internal.Interop.Win32Error : ValueType {
    private int _value;
    public static Win32Error ERROR_SUCCESS;
    public static Win32Error ERROR_INVALID_FUNCTION;
    public static Win32Error ERROR_FILE_NOT_FOUND;
    public static Win32Error ERROR_PATH_NOT_FOUND;
    public static Win32Error ERROR_TOO_MANY_OPEN_FILES;
    public static Win32Error ERROR_ACCESS_DENIED;
    public static Win32Error ERROR_INVALID_HANDLE;
    public static Win32Error ERROR_OUTOFMEMORY;
    public static Win32Error ERROR_NO_MORE_FILES;
    public static Win32Error ERROR_SHARING_VIOLATION;
    public static Win32Error ERROR_INVALID_PARAMETER;
    public static Win32Error ERROR_INSUFFICIENT_BUFFER;
    public static Win32Error ERROR_NESTING_NOT_ALLOWED;
    public static Win32Error ERROR_KEY_DELETED;
    public static Win32Error ERROR_NO_MATCH;
    public static Win32Error ERROR_BAD_DEVICE;
    public static Win32Error ERROR_CANCELLED;
    public static Win32Error ERROR_INVALID_WINDOW_HANDLE;
    public static Win32Error ERROR_TIMEOUT;
    public static Win32Error ERROR_INVALID_DATATYPE;
    public Win32Error(int i);
    private static Win32Error();
    public static HRESULT op_Explicit(Win32Error error);
    public HRESULT ToHRESULT();
    public static Win32Error GetLastError();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Win32Error errLeft, Win32Error errRight);
    public static bool op_Inequality(Win32Error errLeft, Win32Error errRight);
}
internal enum MS.Internal.Interop.WindowMessage : Enum {
    public int value__;
    public static WindowMessage WM_NULL;
    public static WindowMessage WM_CREATE;
    public static WindowMessage WM_DESTROY;
    public static WindowMessage WM_MOVE;
    public static WindowMessage WM_SIZE;
    public static WindowMessage WM_ACTIVATE;
    public static WindowMessage WM_SETFOCUS;
    public static WindowMessage WM_KILLFOCUS;
    public static WindowMessage WM_ENABLE;
    public static WindowMessage WM_SETREDRAW;
    public static WindowMessage WM_SETTEXT;
    public static WindowMessage WM_GETTEXT;
    public static WindowMessage WM_GETTEXTLENGTH;
    public static WindowMessage WM_PAINT;
    public static WindowMessage WM_CLOSE;
    public static WindowMessage WM_QUERYENDSESSION;
    public static WindowMessage WM_QUIT;
    public static WindowMessage WM_QUERYOPEN;
    public static WindowMessage WM_ERASEBKGND;
    public static WindowMessage WM_SYSCOLORCHANGE;
    public static WindowMessage WM_ENDSESSION;
    public static WindowMessage WM_SHOWWINDOW;
    public static WindowMessage WM_CTLCOLOR;
    public static WindowMessage WM_WININICHANGE;
    public static WindowMessage WM_SETTINGCHANGE;
    public static WindowMessage WM_DEVMODECHANGE;
    public static WindowMessage WM_ACTIVATEAPP;
    public static WindowMessage WM_FONTCHANGE;
    public static WindowMessage WM_TIMECHANGE;
    public static WindowMessage WM_CANCELMODE;
    public static WindowMessage WM_SETCURSOR;
    public static WindowMessage WM_MOUSEACTIVATE;
    public static WindowMessage WM_CHILDACTIVATE;
    public static WindowMessage WM_QUEUESYNC;
    public static WindowMessage WM_GETMINMAXINFO;
    public static WindowMessage WM_PAINTICON;
    public static WindowMessage WM_ICONERASEBKGND;
    public static WindowMessage WM_NEXTDLGCTL;
    public static WindowMessage WM_SPOOLERSTATUS;
    public static WindowMessage WM_DRAWITEM;
    public static WindowMessage WM_MEASUREITEM;
    public static WindowMessage WM_DELETEITEM;
    public static WindowMessage WM_VKEYTOITEM;
    public static WindowMessage WM_CHARTOITEM;
    public static WindowMessage WM_SETFONT;
    public static WindowMessage WM_GETFONT;
    public static WindowMessage WM_SETHOTKEY;
    public static WindowMessage WM_GETHOTKEY;
    public static WindowMessage WM_QUERYDRAGICON;
    public static WindowMessage WM_COMPAREITEM;
    public static WindowMessage WM_GETOBJECT;
    public static WindowMessage WM_COMPACTING;
    public static WindowMessage WM_COMMNOTIFY;
    public static WindowMessage WM_WINDOWPOSCHANGING;
    public static WindowMessage WM_WINDOWPOSCHANGED;
    public static WindowMessage WM_POWER;
    public static WindowMessage WM_COPYDATA;
    public static WindowMessage WM_CANCELJOURNAL;
    public static WindowMessage WM_NOTIFY;
    public static WindowMessage WM_INPUTLANGCHANGEREQUEST;
    public static WindowMessage WM_INPUTLANGCHANGE;
    public static WindowMessage WM_TCARD;
    public static WindowMessage WM_HELP;
    public static WindowMessage WM_USERCHANGED;
    public static WindowMessage WM_NOTIFYFORMAT;
    public static WindowMessage WM_CONTEXTMENU;
    public static WindowMessage WM_STYLECHANGING;
    public static WindowMessage WM_STYLECHANGED;
    public static WindowMessage WM_DISPLAYCHANGE;
    public static WindowMessage WM_GETICON;
    public static WindowMessage WM_SETICON;
    public static WindowMessage WM_NCCREATE;
    public static WindowMessage WM_NCDESTROY;
    public static WindowMessage WM_NCCALCSIZE;
    public static WindowMessage WM_NCHITTEST;
    public static WindowMessage WM_NCPAINT;
    public static WindowMessage WM_NCACTIVATE;
    public static WindowMessage WM_GETDLGCODE;
    public static WindowMessage WM_SYNCPAINT;
    public static WindowMessage WM_MOUSEQUERY;
    public static WindowMessage WM_NCMOUSEMOVE;
    public static WindowMessage WM_NCLBUTTONDOWN;
    public static WindowMessage WM_NCLBUTTONUP;
    public static WindowMessage WM_NCLBUTTONDBLCLK;
    public static WindowMessage WM_NCRBUTTONDOWN;
    public static WindowMessage WM_NCRBUTTONUP;
    public static WindowMessage WM_NCRBUTTONDBLCLK;
    public static WindowMessage WM_NCMBUTTONDOWN;
    public static WindowMessage WM_NCMBUTTONUP;
    public static WindowMessage WM_NCMBUTTONDBLCLK;
    public static WindowMessage WM_NCXBUTTONDOWN;
    public static WindowMessage WM_NCXBUTTONUP;
    public static WindowMessage WM_NCXBUTTONDBLCLK;
    public static WindowMessage WM_INPUT;
    public static WindowMessage WM_KEYFIRST;
    public static WindowMessage WM_KEYDOWN;
    public static WindowMessage WM_KEYUP;
    public static WindowMessage WM_CHAR;
    public static WindowMessage WM_DEADCHAR;
    public static WindowMessage WM_SYSKEYDOWN;
    public static WindowMessage WM_SYSKEYUP;
    public static WindowMessage WM_SYSCHAR;
    public static WindowMessage WM_SYSDEADCHAR;
    public static WindowMessage WM_KEYLAST;
    public static WindowMessage WM_IME_STARTCOMPOSITION;
    public static WindowMessage WM_IME_ENDCOMPOSITION;
    public static WindowMessage WM_IME_COMPOSITION;
    public static WindowMessage WM_IME_KEYLAST;
    public static WindowMessage WM_INITDIALOG;
    public static WindowMessage WM_COMMAND;
    public static WindowMessage WM_SYSCOMMAND;
    public static WindowMessage WM_TIMER;
    public static WindowMessage WM_HSCROLL;
    public static WindowMessage WM_VSCROLL;
    public static WindowMessage WM_INITMENU;
    public static WindowMessage WM_INITMENUPOPUP;
    public static WindowMessage WM_MENUSELECT;
    public static WindowMessage WM_MENUCHAR;
    public static WindowMessage WM_ENTERIDLE;
    public static WindowMessage WM_UNINITMENUPOPUP;
    public static WindowMessage WM_CHANGEUISTATE;
    public static WindowMessage WM_UPDATEUISTATE;
    public static WindowMessage WM_QUERYUISTATE;
    public static WindowMessage WM_CTLCOLORMSGBOX;
    public static WindowMessage WM_CTLCOLOREDIT;
    public static WindowMessage WM_CTLCOLORLISTBOX;
    public static WindowMessage WM_CTLCOLORBTN;
    public static WindowMessage WM_CTLCOLORDLG;
    public static WindowMessage WM_CTLCOLORSCROLLBAR;
    public static WindowMessage WM_CTLCOLORSTATIC;
    public static WindowMessage WM_MOUSEMOVE;
    public static WindowMessage WM_MOUSEFIRST;
    public static WindowMessage WM_LBUTTONDOWN;
    public static WindowMessage WM_LBUTTONUP;
    public static WindowMessage WM_LBUTTONDBLCLK;
    public static WindowMessage WM_RBUTTONDOWN;
    public static WindowMessage WM_RBUTTONUP;
    public static WindowMessage WM_RBUTTONDBLCLK;
    public static WindowMessage WM_MBUTTONDOWN;
    public static WindowMessage WM_MBUTTONUP;
    public static WindowMessage WM_MBUTTONDBLCLK;
    public static WindowMessage WM_MOUSEWHEEL;
    public static WindowMessage WM_XBUTTONDOWN;
    public static WindowMessage WM_XBUTTONUP;
    public static WindowMessage WM_XBUTTONDBLCLK;
    public static WindowMessage WM_MOUSEHWHEEL;
    public static WindowMessage WM_MOUSELAST;
    public static WindowMessage WM_PARENTNOTIFY;
    public static WindowMessage WM_ENTERMENULOOP;
    public static WindowMessage WM_EXITMENULOOP;
    public static WindowMessage WM_NEXTMENU;
    public static WindowMessage WM_SIZING;
    public static WindowMessage WM_CAPTURECHANGED;
    public static WindowMessage WM_MOVING;
    public static WindowMessage WM_POWERBROADCAST;
    public static WindowMessage WM_DEVICECHANGE;
    public static WindowMessage WM_POINTERDEVICECHANGE;
    public static WindowMessage WM_POINTERDEVICEINRANGE;
    public static WindowMessage WM_POINTERDEVICEOUTOFRANGE;
    public static WindowMessage WM_POINTERUPDATE;
    public static WindowMessage WM_POINTERDOWN;
    public static WindowMessage WM_POINTERUP;
    public static WindowMessage WM_POINTERENTER;
    public static WindowMessage WM_POINTERLEAVE;
    public static WindowMessage WM_POINTERACTIVATE;
    public static WindowMessage WM_POINTERCAPTURECHANGED;
    public static WindowMessage WM_IME_SETCONTEXT;
    public static WindowMessage WM_IME_NOTIFY;
    public static WindowMessage WM_IME_CONTROL;
    public static WindowMessage WM_IME_COMPOSITIONFULL;
    public static WindowMessage WM_IME_SELECT;
    public static WindowMessage WM_IME_CHAR;
    public static WindowMessage WM_IME_REQUEST;
    public static WindowMessage WM_IME_KEYDOWN;
    public static WindowMessage WM_IME_KEYUP;
    public static WindowMessage WM_MDICREATE;
    public static WindowMessage WM_MDIDESTROY;
    public static WindowMessage WM_MDIACTIVATE;
    public static WindowMessage WM_MDIRESTORE;
    public static WindowMessage WM_MDINEXT;
    public static WindowMessage WM_MDIMAXIMIZE;
    public static WindowMessage WM_MDITILE;
    public static WindowMessage WM_MDICASCADE;
    public static WindowMessage WM_MDIICONARRANGE;
    public static WindowMessage WM_MDIGETACTIVE;
    public static WindowMessage WM_MDISETMENU;
    public static WindowMessage WM_ENTERSIZEMOVE;
    public static WindowMessage WM_EXITSIZEMOVE;
    public static WindowMessage WM_DROPFILES;
    public static WindowMessage WM_MDIREFRESHMENU;
    public static WindowMessage WM_MOUSEHOVER;
    public static WindowMessage WM_NCMOUSELEAVE;
    public static WindowMessage WM_MOUSELEAVE;
    public static WindowMessage WM_WTSSESSION_CHANGE;
    public static WindowMessage WM_TABLET_DEFBASE;
    public static WindowMessage WM_TABLET_MAXOFFSET;
    public static WindowMessage WM_TABLET_ADDED;
    public static WindowMessage WM_TABLET_DELETED;
    public static WindowMessage WM_TABLET_FLICK;
    public static WindowMessage WM_TABLET_QUERYSYSTEMGESTURESTATUS;
    public static WindowMessage WM_DPICHANGED;
    public static WindowMessage WM_DPICHANGED_BEFOREPARENT;
    public static WindowMessage WM_DPICHANGED_AFTERPARENT;
    public static WindowMessage WM_CUT;
    public static WindowMessage WM_COPY;
    public static WindowMessage WM_PASTE;
    public static WindowMessage WM_CLEAR;
    public static WindowMessage WM_UNDO;
    public static WindowMessage WM_RENDERFORMAT;
    public static WindowMessage WM_RENDERALLFORMATS;
    public static WindowMessage WM_DESTROYCLIPBOARD;
    public static WindowMessage WM_DRAWCLIPBOARD;
    public static WindowMessage WM_PAINTCLIPBOARD;
    public static WindowMessage WM_VSCROLLCLIPBOARD;
    public static WindowMessage WM_SIZECLIPBOARD;
    public static WindowMessage WM_ASKCBFORMATNAME;
    public static WindowMessage WM_CHANGECBCHAIN;
    public static WindowMessage WM_HSCROLLCLIPBOARD;
    public static WindowMessage WM_QUERYNEWPALETTE;
    public static WindowMessage WM_PALETTEISCHANGING;
    public static WindowMessage WM_PALETTECHANGED;
    public static WindowMessage WM_HOTKEY;
    public static WindowMessage WM_PRINT;
    public static WindowMessage WM_PRINTCLIENT;
    public static WindowMessage WM_APPCOMMAND;
    public static WindowMessage WM_THEMECHANGED;
    public static WindowMessage WM_DWMCOMPOSITIONCHANGED;
    public static WindowMessage WM_DWMNCRENDERINGCHANGED;
    public static WindowMessage WM_DWMCOLORIZATIONCOLORCHANGED;
    public static WindowMessage WM_DWMWINDOWMAXIMIZEDCHANGE;
    public static WindowMessage WM_HANDHELDFIRST;
    public static WindowMessage WM_HANDHELDLAST;
    public static WindowMessage WM_AFXFIRST;
    public static WindowMessage WM_AFXLAST;
    public static WindowMessage WM_PENWINFIRST;
    public static WindowMessage WM_PENWINLAST;
    public static WindowMessage WM_DWMSENDICONICTHUMBNAIL;
    public static WindowMessage WM_DWMSENDICONICLIVEPREVIEWBITMAP;
    public static WindowMessage WM_USER;
    public static WindowMessage WM_APP;
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.Invariant : object {
    private static bool _strict;
    private static bool _strictDefaultValue;
    internal static bool Strict { get; internal set; }
    private static bool IsDialogOverrideEnabled { get; }
    private static Invariant();
    internal static void Assert(bool condition);
    internal static void Assert(bool condition, string invariantMessage);
    internal static void Assert(bool condition, string invariantMessage, string detailMessage);
    internal static bool get_Strict();
    internal static void set_Strict(bool value);
    private static void FailFast(string message, string detailMessage);
    private static bool get_IsDialogOverrideEnabled();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.BLOB : ValueType {
    public UInt32 cbSize;
    public IntPtr pBlobData;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.BSTRBLOB : ValueType {
    public UInt32 cbSize;
    public IntPtr pData;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.CArray : ValueType {
    public UInt32 cElems;
    public IntPtr pElems;
}
internal class MS.Internal.IO.Packaging.CaseInsensitiveOrdinalStringComparer : object {
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object str);
}
internal class MS.Internal.IO.Packaging.CertificatePart : object {
    private PackagePart _part;
    private X509Certificate2 _certificate;
    private static ContentType _certificatePartContentType;
    private static string _certificatePartNamePrefix;
    private static string _certificatePartNameExtension;
    private static string _certificatePartRelationshipType;
    private static long _maximumCertificateStreamLength;
    internal static string RelationshipType { get; }
    internal static string PartNamePrefix { get; }
    internal static string PartNameExtension { get; }
    internal static ContentType ContentType { get; }
    internal Uri Uri { get; }
    internal CertificatePart(Package container, Uri partName);
    private static CertificatePart();
    internal static string get_RelationshipType();
    internal static string get_PartNamePrefix();
    internal static string get_PartNameExtension();
    internal static ContentType get_ContentType();
    internal Uri get_Uri();
    internal X509Certificate2 GetCertificate();
    internal void SetCertificate(X509Certificate2 certificate);
}
internal class MS.Internal.IO.Packaging.CompoundFile.CFStream : Stream {
    private IStream _safeIStream;
    private FileAccess access;
    private StreamInfo backReference;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool StreamDisposed { get; }
    internal CFStream(IStream underlyingStream, FileAccess openAccess, StreamInfo creator);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    internal void CheckDisposedStatus();
    internal bool get_StreamDisposed();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Packaging.CompoundFile.CompoundFileDeflateTransform : object {
    private Byte[] _headerBuf;
    private static int _defaultBlockSize;
    private static int _maxAllowableBlockSize;
    private static int _ulongSize;
    private static UInt32 _blockHeaderToken;
    private static int _blockHeaderSize;
    private static int DEFAULT_WINDOW_BITS;
    private static int DEFAULT_MEM_LEVEL;
    public sealed virtual void Decompress(Stream source, Stream sink);
    public sealed virtual void Compress(Stream source, Stream sink);
    private static void AllocOrRealloc(int size, Byte[]& buffer, GCHandle& gcHandle);
    private bool ReadBlockHeader(Stream source, Int32& uncompressedSize, Int32& compressedSize);
    private static void ThrowIfZLibError(ErrorCode retVal);
}
internal abstract class MS.Internal.IO.Packaging.CompoundFile.CompoundFileReference : object {
    public string FullName { get; }
    public abstract virtual string get_FullName();
    private sealed virtual override int System.IComparable.CompareTo(object ob);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal static int Save(CompoundFileReference reference, BinaryWriter writer);
    internal static CompoundFileReference Load(BinaryReader reader, Int32& bytesRead);
}
internal class MS.Internal.IO.Packaging.CompoundFile.CompoundFileStorageReference : CompoundFileReference {
    private string _fullName;
    public string FullName { get; }
    public CompoundFileStorageReference(string fullName);
    public virtual string get_FullName();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private sealed virtual override int System.IComparable.CompareTo(object o);
    private void SetFullName(string fullName);
}
internal class MS.Internal.IO.Packaging.CompoundFile.CompoundFileStreamReference : CompoundFileReference {
    private string _fullName;
    public string FullName { get; }
    public CompoundFileStreamReference(string fullName);
    public CompoundFileStreamReference(string storageName, string streamName);
    public virtual string get_FullName();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private sealed virtual override int System.IComparable.CompareTo(object o);
    private void SetFullName(string fullName);
}
internal class MS.Internal.IO.Packaging.CompoundFile.CompressionTransform : object {
    private TransformEnvironment _transformEnvironment;
    private VersionedStreamOwner _versionedStreamOwner;
    private static string _featureName;
    private static VersionPair _currentFeatureVersion;
    private static VersionPair _minimumReaderVersion;
    private static VersionPair _minimumUpdaterVersion;
    private static long _lowWaterMark;
    private static long _highWaterMark;
    public bool IsReady { get; }
    public bool FixedSettings { get; }
    public object TransformIdentifier { get; }
    internal static string ClassTransformIdentifier { get; }
    public CompressionTransform(TransformEnvironment myEnvironment);
    private static CompressionTransform();
    public sealed virtual bool get_IsReady();
    public sealed virtual bool get_FixedSettings();
    public sealed virtual object get_TransformIdentifier();
    internal static string get_ClassTransformIdentifier();
    private sealed virtual override Stream System.IO.Packaging.IDataTransform.GetTransformedStream(Stream encodedStream, IDictionary transformContext);
}
[FriendAccessAllowedAttribute]
[FlagsAttribute]
internal enum MS.Internal.IO.Packaging.CompoundFile.ContainerFlags : Enum {
    public int value__;
    public static ContainerFlags HostInBrowser;
    public static ContainerFlags Writable;
    public static ContainerFlags Metro;
    public static ContainerFlags ExecuteInstrumentation;
}
internal static class MS.Internal.IO.Packaging.CompoundFile.ContainerUtilities : object {
    private static int _int16Size;
    private static int _int32Size;
    private static Byte[] _paddingBuf;
    private static int _int64Size;
    internal static char PathSeparator;
    internal static string PathSeparatorAsString;
    private static CaseInsensitiveOrdinalStringComparer _stringCaseInsensitiveComparer;
    internal static int Int16Size { get; }
    internal static int Int32Size { get; }
    internal static int Int64Size { get; }
    internal static CaseInsensitiveOrdinalStringComparer StringCaseInsensitiveComparer { get; }
    private static ContainerUtilities();
    internal static int get_Int16Size();
    internal static int get_Int32Size();
    internal static int get_Int64Size();
    internal static CaseInsensitiveOrdinalStringComparer get_StringCaseInsensitiveComparer();
    internal static int CalculateDWordPadBytesLength(int length);
    internal static int WriteByteLengthPrefixedDWordPaddedUnicodeString(BinaryWriter writer, string outputString);
    internal static string ReadByteLengthPrefixedDWordPaddedUnicodeString(BinaryReader reader);
    internal static string ReadByteLengthPrefixedDWordPaddedUnicodeString(BinaryReader reader, Int32& bytesRead);
    internal static void CheckAgainstNull(object paramRef, string testStringIdentifier);
    private static int SizeOfInt16();
    private static int SizeOfInt32();
    private static int SizeOfInt64();
    internal static String[] ConvertBackSlashPathToStringArrayPath(string backSlashPath);
    internal static string ConvertStringArrayPathToBackSlashPath(IList arrayPath);
    internal static string ConvertStringArrayPathToBackSlashPath(IList storages, string streamName);
    internal static void CheckStringAgainstNullAndEmpty(string testString, string testStringIdentifier);
    internal static void CheckStringAgainstReservedName(string nameString, string nameStringIdentifier);
    internal static bool IsReservedName(string nameString);
    internal static void CheckStringForEmbeddedPathSeparator(string testString, string testStringIdentifier);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.CompoundFile.FormatVersion : object {
    private VersionPair _reader;
    private VersionPair _updater;
    private VersionPair _writer;
    private string _featureIdentifier;
    public VersionPair ReaderVersion { get; public set; }
    public VersionPair WriterVersion { get; public set; }
    public VersionPair UpdaterVersion { get; public set; }
    public string FeatureIdentifier { get; }
    public FormatVersion(string featureId, VersionPair version);
    public FormatVersion(string featureId, VersionPair writerVersion, VersionPair readerVersion, VersionPair updaterVersion);
    public VersionPair get_ReaderVersion();
    public void set_ReaderVersion(VersionPair value);
    public VersionPair get_WriterVersion();
    public void set_WriterVersion(VersionPair value);
    public VersionPair get_UpdaterVersion();
    public void set_UpdaterVersion(VersionPair value);
    public string get_FeatureIdentifier();
    public static FormatVersion LoadFromStream(Stream stream);
    public int SaveToStream(Stream stream);
    public bool IsReadableBy(VersionPair version);
    public bool IsUpdatableBy(VersionPair version);
    private static FormatVersion LoadFromBinaryReader(BinaryReader reader, Int32& bytesRead);
    internal static FormatVersion LoadFromStream(Stream stream, Int32& bytesRead);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IEnumSTATPROPSETSTG {
    public abstract virtual int Next(UInt32 celt, STATPROPSETSTG rgelt, UInt32& pceltFetched);
    public abstract virtual void Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumSTATPROPSETSTG& ppenum);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IEnumSTATPROPSTG {
    public abstract virtual int Next(UInt32 celt, STATPROPSTG rgelt, UInt32& pceltFetched);
    public abstract virtual void Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumSTATPROPSTG& ppenum);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IEnumSTATSTG {
    public abstract virtual void Next(UInt32 celt, STATSTG& rgelt, UInt32& pceltFetched);
    public abstract virtual void Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumSTATSTG& ppenum);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IPropertySetStorage {
    public abstract virtual void Create(Guid& rfmtid, Guid& pclsid, UInt32 grfFlags, UInt32 grfMode, IPropertyStorage& ppprstg);
    public abstract virtual int Open(Guid& rfmtid, UInt32 grfMode, IPropertyStorage& ppprstg);
    public abstract virtual void Delete(Guid& rfmtid);
    public abstract virtual void Enum(IEnumSTATPROPSETSTG& ppenum);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IPropertyStorage {
    public abstract virtual int ReadMultiple(UInt32 cpspec, PROPSPEC[] rgpspec, PROPVARIANT[] rgpropvar);
    public abstract virtual void WriteMultiple(UInt32 cpspec, PROPSPEC[] rgpspec, PROPVARIANT[] rgpropvar, UInt32 propidNameFirst);
    public abstract virtual void DeleteMultiple(UInt32 cpspec, PROPSPEC[] rgpspec);
    public abstract virtual void ReadPropertyNames(UInt32 cpropid, UInt32[] rgpropid, String[] rglpwstrName);
    public abstract virtual void WritePropertyNames(UInt32 cpropid, UInt32[] rgpropid, String[] rglpwstrName);
    public abstract virtual void DeletePropertyNames(UInt32 cpropid, UInt32[] rgpropid);
    public abstract virtual void Commit(UInt32 grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void Enum(IEnumSTATPROPSTG& ppenum);
    public abstract virtual void SetTimes(FILETIME& pctime, FILETIME& patime, FILETIME& pmtime);
    public abstract virtual void SetClass(Guid& clsid);
    public abstract virtual void Stat(STATPROPSETSTG& pstatpsstg);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IStorage {
    public abstract virtual int CreateStream(string pwcsName, int grfMode, int reserved1, int reserved2, IStream& ppstm);
    public abstract virtual int OpenStream(string pwcsName, int reserved1, int grfMode, int reserved2, IStream& ppstm);
    public abstract virtual int CreateStorage(string pwcsName, int grfMode, int reserved1, int reserved2, IStorage& ppstg);
    public abstract virtual int OpenStorage(string pwcsName, IStorage pstgPriority, int grfMode, IntPtr snbExclude, int reserved, IStorage& ppstg);
    public abstract virtual void CopyTo(int ciidExclude, Guid[] rgiidExclude, IntPtr snbExclude, IStorage ppstg);
    public abstract virtual void MoveElementTo(string pwcsName, IStorage pstgDest, string pwcsNewName, int grfFlags);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void EnumElements(int reserved1, IntPtr reserved2, int reserved3, IEnumSTATSTG& ppEnum);
    public abstract virtual void DestroyElement(string pwcsName);
    public abstract virtual void RenameElement(string pwcsOldName, string pwcsNewName);
    public abstract virtual void SetElementTimes(string pwcsName, FILETIME pctime, FILETIME patime, FILETIME pmtime);
    public abstract virtual void SetClass(Guid& clsid);
    public abstract virtual void SetStateBits(int grfStateBits, int grfMask);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IStream {
    public abstract virtual void Read(Byte[] pv, int cb, Int32& pcbRead);
    public abstract virtual void Write(Byte[] pv, int cb, Int32& pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, Int64& plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(IStream pstm, long cb, Int64& pcbRead, Int64& pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(IStream& ppstm);
}
internal class MS.Internal.IO.Packaging.CompoundFile.RightsManagementEncryptedStream : Stream {
    private Random _random;
    private Stream _baseStream;
    private long _streamCachedLength;
    private long _streamOnDiskLength;
    private long _streamPosition;
    private CryptoProvider _cryptoProvider;
    private static int _prefixLengthSize;
    private Byte[] _randomBuffer;
    private MemoryStreamBlock _comparisonBlock;
    private SparseMemoryStream _readCache;
    private SparseMemoryStream _writeCache;
    private static long _autoFlushHighWaterMark;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal RightsManagementEncryptedStream(Stream baseStream, CryptoProvider cryptoProvider);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private void ParseStreamLength();
    private int InternalRead(long streamPosition, Byte[] buffer, int offset, int count);
    private int ReadFromCache(SparseMemoryStream cache, long start, int count, Byte[] buffer, int bufferOffset);
    private int FindIndexOfBlockAtOffset(SparseMemoryStream cache, long start, Boolean& match);
    private long FindOffsetOfNextAvailableBlockAfter(SparseMemoryStream cache, long start);
    private void FetchBlockIntoReadCache(long start, int count);
    private void FlushLength();
    private static long GetBlockNo(long blockSize, long index);
    private static long GetBlockSpanCount(long blockSize, long index, long size);
    private static void CalcBlockData(long start, long size, bool canMergeBlocks, Int32& blockSize, Int64& firstBlockOffset, Int64& blockCount);
    private void CheckDisposed();
    private void FlushCacheIfNecessary();
    private void FlushCache();
    private int InternalReliableRead(long streamPosition, Byte[] buffer, int offset, int count);
    private void RandomFillUp(Byte[] buffer, int offset, int count);
}
internal class MS.Internal.IO.Packaging.CompoundFile.RightsManagementEncryptionTransform : object {
    private CryptoProvider _cryptoProvider;
    private PublishLicense _publishLicense;
    private bool _fixedSettings;
    private static UnicodeEncoding _unicodeEncoding;
    private VersionedStreamOwner _publishLicenseStream;
    private Byte[] _publishLicenseHeaderExtraBytes;
    private StorageInfo _useLicenseStorage;
    private static string LicenseStreamNamePrefix;
    private static int LicenseStreamNamePrefixLength;
    private static string FeatureName;
    private static int PublishLicenseLengthMax;
    private static int UseLicenseLengthMax;
    private static int UserNameLengthMax;
    private static int UseLicenseStreamLengthMin;
    private static VersionPair CurrentFeatureVersion;
    private static VersionPair MinimumReaderVersion;
    private static VersionPair MinimumUpdaterVersion;
    private static int MaxPublishLicenseHeaderLen;
    private static Char[] Base32EncodingTable;
    private static Byte[] Padding;
    private static int SizeofByte;
    public bool IsReady { get; }
    public bool FixedSettings { get; }
    internal int TransformIdentifierType { get; }
    public object TransformIdentifier { get; }
    internal CryptoProvider CryptoProvider { get; internal set; }
    internal static string ClassTransformIdentifier { get; }
    internal RightsManagementEncryptionTransform(TransformEnvironment transformEnvironment);
    private static RightsManagementEncryptionTransform();
    internal PublishLicense LoadPublishLicense();
    internal void SavePublishLicense(PublishLicense publishLicense);
    internal UseLicense LoadUseLicense(ContentUser user);
    internal void SaveUseLicense(ContentUser user, UseLicense useLicense);
    internal void DeleteUseLicense(ContentUser user);
    internal IDictionary`2<ContentUser, UseLicense> GetEmbeddedUseLicenses();
    public sealed virtual bool get_IsReady();
    public sealed virtual bool get_FixedSettings();
    internal int get_TransformIdentifierType();
    public sealed virtual object get_TransformIdentifier();
    internal CryptoProvider get_CryptoProvider();
    internal void set_CryptoProvider(CryptoProvider value);
    internal static string get_ClassTransformIdentifier();
    private sealed virtual override Stream System.IO.Packaging.IDataTransform.GetTransformedStream(Stream encodedStream, IDictionary transformContext);
    internal void EnumUseLicenseStreams(UseLicenseStreamCallback callback, object param);
    internal UseLicense LoadUseLicenseAndUserFromStream(BinaryReader utf8Reader, ContentUser& user);
    private void LoadUseLicenseForUser(RightsManagementEncryptionTransform rmet, StreamInfo si, object param, Boolean& stop);
    private void DeleteUseLicenseForUser(RightsManagementEncryptionTransform rmet, StreamInfo si, object param, Boolean& stop);
    internal void SaveUseLicenseForUser(ContentUser user, UseLicense useLicense);
    private static Char[] Base32EncodeWithoutPadding(Byte[] bytes);
    private static string MakeUseLicenseStreamName();
    private static string MakeTypePrefixedUserName(ContentUser user);
    private static void ParseTypePrefixedUserName(string typePrefixedUserName, AuthenticationType& authenticationType, String& userName);
    private UseLicense LoadUseLicenseFromStream(BinaryReader utf8Reader);
    private ContentUser LoadUserFromStream(BinaryReader utf8Reader);
    private static string ReadLengthPrefixedString(BinaryReader reader, Encoding encoding, int maxLength);
    private static void SkipDwordPadding(int length, BinaryReader reader);
    private static void WriteDwordPadding(int length, BinaryWriter writer);
    private static void WriteByteLengthPrefixedDwordPaddedString(string s, BinaryWriter writer, Encoding encoding);
}
internal static class MS.Internal.IO.Packaging.CompoundFile.SafeNativeCompoundFileConstants : object {
    internal static int STGM_READ;
    internal static int STGM_WRITE;
    internal static int STGM_READWRITE;
    internal static int STGM_READWRITE_Bits;
    internal static int STGM_SHARE_DENY_NONE;
    internal static int STGM_SHARE_DENY_READ;
    internal static int STGM_SHARE_DENY_WRITE;
    internal static int STGM_SHARE_EXCLUSIVE;
    internal static int STGM_PRIORITY;
    internal static int STGM_CREATE;
    internal static int STGM_CONVERT;
    internal static int STGM_FAILIFTHERE;
    internal static int STGM_DIRECT;
    internal static int STGM_TRANSACTED;
    internal static int STGM_NOSCRATCH;
    internal static int STGM_NOSNAPSHOT;
    internal static int STGM_SIMPLE;
    internal static int STGM_DIRECT_SWMR;
    internal static int STGM_DELETEONRELEASE;
    internal static int STREAM_SEEK_SET;
    internal static int STREAM_SEEK_CUR;
    internal static int STREAM_SEEK_END;
    internal static int STATFLAG_NONAME;
    internal static int STATFLAG_NOOPEN;
    internal static int STGTY_STORAGE;
    internal static int STGTY_STREAM;
    internal static int STGTY_LOCKBYTES;
    internal static int STGTY_PROPERTY;
    internal static UInt32 PROPSETFLAG_ANSI;
    internal static int S_OK;
    internal static int S_FALSE;
    internal static int STG_E_FILENOTFOUND;
    internal static int STG_E_ACCESSDENIED;
    internal static int STG_E_FILEALREADYEXISTS;
    internal static int STG_E_INVALIDNAME;
    internal static int STG_E_INVALIDFLAG;
}
internal static class MS.Internal.IO.Packaging.CompoundFile.SafeNativeCompoundFileMethods : object {
    internal static void UpdateModeFlagFromFileAccess(FileAccess access, Int32& grfMode);
    internal static int SafeStgCreateDocfileOnStream(Stream s, int grfMode, IStorage& ppstgOpen);
    internal static int SafeStgOpenStorageOnStream(Stream s, int grfMode, IStorage& ppstgOpen);
    internal static int SafeStgCreateStorageEx(string pwcsName, int grfMode, int stgfmt, int grfAttrs, IntPtr pStgOptions, IntPtr reserved2, Guid& riid, IStorage& ppObjectOpen);
    internal static int SafeStgOpenStorageEx(string pwcsName, int grfMode, int stgfmt, int grfAttrs, IntPtr pStgOptions, IntPtr reserved2, Guid& riid, IStorage& ppObjectOpen);
    internal static int SafePropVariantClear(PROPVARIANT& pvar);
}
internal class MS.Internal.IO.Packaging.CompoundFile.StreamWithDictionary : Stream {
    private Stream baseStream;
    private IDictionary baseDictionary;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    internal bool Disposed { get; }
    internal StreamWithDictionary(Stream wrappedStream, IDictionary wrappedDictionary);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object val);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object index);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object index, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal bool get_Disposed();
    private void CheckDisposed();
}
internal static class MS.Internal.IO.Packaging.CompoundFile.UnsafeNativeCompoundFileMethods : object {
    internal static int StgCreateDocfileOnILockBytes(UnsafeNativeILockBytes plkbyt, int grfMode, int reserved, UnsafeNativeIStorage& ppstgOpen);
    internal static int StgOpenStorageOnILockBytes(UnsafeNativeILockBytes plkbyt, UnsafeNativeIStorage pStgPriority, int grfMode, IntPtr snbExclude, int reserved, UnsafeNativeIStorage& ppstgOpen);
    internal static int StgCreateStorageEx(string pwcsName, int grfMode, int stgfmt, int grfAttrs, IntPtr pStgOptions, IntPtr reserved2, Guid& riid, UnsafeNativeIStorage& ppObjectOpen);
    internal static int StgOpenStorageEx(string pwcsName, int grfMode, int stgfmt, int grfAttrs, IntPtr pStgOptions, IntPtr reserved2, Guid& riid, UnsafeNativeIStorage& ppObjectOpen);
    internal static int PropVariantClear(PROPVARIANT& pvar);
}
internal class MS.Internal.IO.Packaging.CompoundFile.UserUseLicenseDictionaryLoader : object {
    private Dictionary`2<ContentUser, UseLicense> _dict;
    private UTF8Encoding _utf8Encoding;
    internal Dictionary`2<ContentUser, UseLicense> LoadedDictionary { get; }
    internal UserUseLicenseDictionaryLoader(RightsManagementEncryptionTransform rmet);
    internal Dictionary`2<ContentUser, UseLicense> get_LoadedDictionary();
    private void Load(RightsManagementEncryptionTransform rmet);
    private void AddUseLicenseFromStreamToDictionary(RightsManagementEncryptionTransform rmet, StreamInfo si, object param, Boolean& stop);
}
internal class MS.Internal.IO.Packaging.CompoundFile.VersionedStream : Stream {
    private VersionedStreamOwner _versionOwner;
    private Stream _stream;
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    protected Stream BaseStream { get; }
    internal VersionedStream(Stream baseStream, VersionedStreamOwner versionOwner);
    protected VersionedStream(Stream baseStream);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void WriteByte(byte b);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Flush();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected Stream get_BaseStream();
    protected virtual void Dispose(bool disposing);
    protected void CheckDisposed();
}
internal class MS.Internal.IO.Packaging.CompoundFile.VersionedStreamOwner : VersionedStream {
    private bool _writeOccurred;
    private bool _readOccurred;
    private FormatVersion _codeVersion;
    private FormatVersion _fileVersion;
    private long _dataOffset;
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    internal bool IsUpdatable { get; }
    internal bool IsReadable { get; }
    internal VersionedStreamOwner(Stream baseStream, FormatVersion codeVersion);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void WriteByte(byte b);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Flush();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    internal bool get_IsUpdatable();
    internal bool get_IsReadable();
    internal void WriteAttempt();
    internal void ReadAttempt();
    internal void ReadAttempt(bool throwIfEmpty);
    private void PersistVersion(FormatVersion version);
    private void EnsureParsed();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.CompoundFile.VersionPair : object {
    private short _major;
    private short _minor;
    public short Major { get; }
    public short Minor { get; }
    internal VersionPair(short major, short minor);
    public short get_Major();
    public short get_Minor();
    public virtual string ToString();
    public static bool op_Equality(VersionPair v1, VersionPair v2);
    public static bool op_Inequality(VersionPair v1, VersionPair v2);
    public static bool op_LessThan(VersionPair v1, VersionPair v2);
    public static bool op_GreaterThan(VersionPair v1, VersionPair v2);
    public static bool op_LessThanOrEqual(VersionPair v1, VersionPair v2);
    public static bool op_GreaterThanOrEqual(VersionPair v1, VersionPair v2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
}
internal class MS.Internal.IO.Packaging.CompressEmulationStream : Stream {
    private bool _disposed;
    private bool _dirty;
    protected Stream _baseStream;
    protected Stream _tempStream;
    private IDeflateTransform _transformer;
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    internal CompressEmulationStream(Stream baseStream, Stream tempStream, long position, IDeflateTransform transformer);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    protected void CheckDisposed();
}
internal class MS.Internal.IO.Packaging.CustomSignedXml : SignedXml {
    private static string _NetFxSecurityFullKeyName;
    private static string _NetFxSecurityKey;
    private static bool s_readRequireNCNameIdentifier;
    private static bool s_requireNCNameIdentifier;
    private static Nullable`1<bool> s_allowAmbiguousReferenceTarget;
    private static string _XAdESNameSpace;
    private static string _XAdESTargetType;
    private static CustomSignedXml();
    public virtual XmlElement GetIdElement(XmlDocument document, string idValue);
    private static XmlElement SelectNodeByIdFromObjects(Signature signature, string idValue);
    private static XmlElement SelectSubObjectNodeForXAdES(Signature signature, string idValue);
    private static XmlElement SelectSubObjectNodeForXAdESInDataObjects(Signature signature, string idValue);
    private static long GetNetFxSecurityRegistryValue(string regValueName, long defaultValue);
    private static bool RequireNCNameIdentifier();
    private static bool AllowAmbiguousReferenceTargets();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.CY : ValueType {
    public UInt32 Lo;
    public int Hi;
}
internal class MS.Internal.IO.Packaging.DeflateEmulationTransform : object {
    private Byte[] _buffer;
    private Byte[] Buffer { get; }
    public sealed virtual void Decompress(Stream source, Stream sink);
    public sealed virtual void Compress(Stream source, Stream sink);
    private Byte[] get_Buffer();
}
[ExtensionAttribute]
internal static class MS.Internal.IO.Packaging.Extensions.PackagePartExtensions : object {
    [ExtensionAttribute]
public static ContentType ValidatedContentType(PackagePart packagePart);
}
internal class MS.Internal.IO.Packaging.Extensions.PackageRelationship : object {
    public static Uri ContainerRelationshipPartName { get; }
    public static Uri get_ContainerRelationshipPartName();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.IO.Packaging.FormatId : object {
    internal static Guid SummaryInformation;
    internal static Guid DocumentSummaryInformation;
    private static FormatId();
}
internal interface MS.Internal.IO.Packaging.IDeflateTransform {
    public abstract virtual void Decompress(Stream source, Stream sink);
    public abstract virtual void Compress(Stream source, Stream sink);
}
internal class MS.Internal.IO.Packaging.IgnoreFlushAndCloseStream : Stream {
    private Stream _stream;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal IgnoreFlushAndCloseStream(Stream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buf, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfStreamDisposed();
}
internal static class MS.Internal.IO.Packaging.InternalRelationshipCollection : object {
    private static string RelationshipTagName;
    private static string TargetAttributeName;
    private static string TypeAttributeName;
    private static string IdAttributeName;
    private static string TargetModeAttributeName;
    private static InternalRelationshipCollection();
    internal static void WriteRelationshipsAsXml(XmlWriter writer, IEnumerable`1<PackageRelationship> relationships, bool alwaysWriteTargetModeAttribute, bool inStreamingProduction);
}
internal interface MS.Internal.IO.Packaging.ITrackingMemoryStreamFactory {
    public abstract virtual MemoryStream Create();
    public abstract virtual MemoryStream Create(int capacity);
    public abstract virtual void ReportMemoryUsageDelta(int delta);
}
internal class MS.Internal.IO.Packaging.MemoryStreamBlock : object {
    private MemoryStream _stream;
    private long _offset;
    internal MemoryStream Stream { get; }
    internal long Offset { get; internal set; }
    internal long EndOffset { get; }
    internal MemoryStreamBlock(MemoryStream stream, long offset);
    internal MemoryStream get_Stream();
    internal long get_Offset();
    internal void set_Offset(long value);
    internal long get_EndOffset();
    private sealed virtual override int System.IComparable<MS.Internal.IO.Packaging.MemoryStreamBlock>.CompareTo(MemoryStreamBlock other);
}
[ExtensionAttribute]
[FriendAccessAllowedAttribute]
internal static class MS.Internal.IO.Packaging.PackagePartExtensions : object {
    [ExtensionAttribute]
internal static Stream GetSeekableStream(PackagePart packPart);
    [ExtensionAttribute]
internal static Stream GetSeekableStream(PackagePart packPart, FileMode mode);
    [ExtensionAttribute]
internal static Stream GetSeekableStream(PackagePart packPart, FileMode mode, FileAccess access);
}
internal enum MS.Internal.IO.Packaging.PackageXmlEnum : Enum {
    public int value__;
    public static PackageXmlEnum NotDefined;
    public static PackageXmlEnum XmlSchemaInstanceNamespace;
    public static PackageXmlEnum XmlSchemaInstanceNamespacePrefix;
    public static PackageXmlEnum XmlNamespacePrefix;
    public static PackageXmlEnum PackageCorePropertiesNamespace;
    public static PackageXmlEnum DublinCorePropertiesNamespace;
    public static PackageXmlEnum DublinCoreTermsNamespace;
    public static PackageXmlEnum DublinCorePropertiesNamespacePrefix;
    public static PackageXmlEnum DublincCoreTermsNamespacePrefix;
    public static PackageXmlEnum CoreProperties;
    public static PackageXmlEnum Type;
    public static PackageXmlEnum Creator;
    public static PackageXmlEnum Identifier;
    public static PackageXmlEnum Title;
    public static PackageXmlEnum Subject;
    public static PackageXmlEnum Description;
    public static PackageXmlEnum Language;
    public static PackageXmlEnum Created;
    public static PackageXmlEnum Modified;
    public static PackageXmlEnum ContentType;
    public static PackageXmlEnum Keywords;
    public static PackageXmlEnum Category;
    public static PackageXmlEnum Version;
    public static PackageXmlEnum LastModifiedBy;
    public static PackageXmlEnum ContentStatus;
    public static PackageXmlEnum Revision;
    public static PackageXmlEnum LastPrinted;
}
internal static class MS.Internal.IO.Packaging.PackageXmlStringTable : object {
    private static XmlStringTableStruct[] _xmlstringtable;
    private static NameTable _nameTable;
    internal static NameTable NameTable { get; }
    private static PackageXmlStringTable();
    internal static PackageXmlEnum GetEnumOf(object xmlString);
    internal static string GetXmlString(PackageXmlEnum id);
    internal static object GetXmlStringAsObject(PackageXmlEnum id);
    internal static PackageXmlEnum GetXmlNamespace(PackageXmlEnum id);
    internal static string GetValueType(PackageXmlEnum id);
    internal static NameTable get_NameTable();
    private static void CheckIdRange(PackageXmlEnum id);
    internal static NameTable CloneNameTable();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.IO.Packaging.PackagingUtilities : object {
    internal static string RelationshipNamespaceUri;
    internal static ContentType RelationshipPartContentType;
    internal static string ContainerFileExtension;
    internal static string XamlFileExtension;
    private static object _isoStoreSyncObject;
    private static object _isolatedStorageFileLock;
    private static ReliableIsolatedStorageFileFolder _defaultFile;
    private static string XmlNamespace;
    private static string _encodingAttribute;
    private static string _webNameUTF8;
    private static string _webNameUnicode;
    private static string _profileListKeyName;
    private static string _fullProfileListKeyName;
    internal static object IsoStoreSyncRoot { get; }
    internal static object IsolatedStorageFileLock { get; }
    private static PackagingUtilities();
    internal static void PerformInitailReadAndVerifyEncoding(XmlTextReader reader);
    internal static void VerifyStreamReadArgs(Stream s, Byte[] buffer, int offset, int count);
    internal static void VerifyStreamWriteArgs(Stream s, Byte[] buffer, int offset, int count);
    internal static int ReliableRead(Stream stream, Byte[] buffer, int offset, int count);
    internal static int ReliableRead(Stream stream, Byte[] buffer, int offset, int requestedCount, int requiredCount);
    internal static int ReliableRead(BinaryReader reader, Byte[] buffer, int offset, int count);
    internal static int ReliableRead(BinaryReader reader, Byte[] buffer, int offset, int requestedCount, int requiredCount);
    internal static long CopyStream(Stream sourceStream, Stream targetStream, long bytesToCopy, int bufferSize);
    internal static Stream CreateUserScopedIsolatedStorageFileStreamWithRandomName(int retryCount, String& fileName);
    internal static void CalculateOverlap(long block1Offset, long block1Size, long block2Offset, long block2Size, Int64& overlapBlockOffset, Int64& overlapBlockSize);
    internal static int GetNonXmlnsAttributeCount(XmlReader reader);
    internal static object get_IsoStoreSyncRoot();
    internal static object get_IsolatedStorageFileLock();
    private static void DeleteIsolatedStorageFile(string fileName);
    private static ReliableIsolatedStorageFileFolder GetDefaultIsolatedStorageFile();
    private static bool UserHasProfile();
}
internal static class MS.Internal.IO.Packaging.PackUriHelper : object {
    private static Uri _defaultUri;
    private static Uri _packageRootUri;
    private static string _relationshipPartExtensionName;
    internal static Uri PackageRootUri { get; }
    private static PackUriHelper();
    internal static Uri get_PackageRootUri();
    internal static bool IsPackUri(Uri uri);
    internal static ValidatedPartUri ValidatePartUri(Uri partUri);
    internal static string GetStringForPartUri(Uri partUri);
    private static Exception GetExceptionIfPartUriInvalid(Uri partUri, String& partUriString);
    private static ArgumentException GetExceptionIfAbsoluteUri(Uri uri);
    private static ArgumentException GetExceptionIfFragmentPresent(string partName);
    private static ArgumentException GetExceptionIfPartNameEndsWithSlash(string partName);
    private static ArgumentException GetExceptionIfPartNameStartsWithTwoSlashes(string partName);
    private static string GetStringForPartUriFromAnyUri(Uri partUri);
    private static bool IsPartNameEmpty(string partName);
}
internal class MS.Internal.IO.Packaging.PartManifestEntry : ValueType {
    private Uri _owningPartUri;
    private Uri _uri;
    private ContentType _contentType;
    private string _hashAlgorithm;
    private string _hashValue;
    private List`1<string> _transforms;
    private List`1<PackageRelationshipSelector> _relationshipSelectors;
    internal bool IsRelationshipEntry { get; }
    internal Uri Uri { get; }
    internal ContentType ContentType { get; }
    internal string HashAlgorithm { get; }
    internal string HashValue { get; }
    internal List`1<string> Transforms { get; }
    internal List`1<PackageRelationshipSelector> RelationshipSelectors { get; }
    internal Uri OwningPartUri { get; }
    internal PartManifestEntry(Uri uri, ContentType contentType, string hashAlgorithm, string hashValue, List`1<string> transforms, List`1<PackageRelationshipSelector> relationshipSelectors);
    internal bool get_IsRelationshipEntry();
    internal Uri get_Uri();
    internal ContentType get_ContentType();
    internal string get_HashAlgorithm();
    internal string get_HashValue();
    internal List`1<string> get_Transforms();
    internal List`1<PackageRelationshipSelector> get_RelationshipSelectors();
    internal Uri get_OwningPartUri();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.IO.Packaging.PropertyId : object {
    internal static UInt32 Title;
    internal static UInt32 Subject;
    internal static UInt32 Creator;
    internal static UInt32 Keywords;
    internal static UInt32 Description;
    internal static UInt32 LastModifiedBy;
    internal static UInt32 Revision;
    internal static UInt32 LastPrinted;
    internal static UInt32 DateCreated;
    internal static UInt32 DateModified;
    internal static UInt32 Category;
    internal static UInt32 Identifier;
    internal static UInt32 ContentType;
    internal static UInt32 Language;
    internal static UInt32 Version;
    internal static UInt32 ContentStatus;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.PROPSPEC : ValueType {
    internal UInt32 propType;
    internal PROPSPECunion union;
}
[FriendAccessAllowedAttribute]
internal enum MS.Internal.IO.Packaging.PropSpecType : Enum {
    public int value__;
    public static PropSpecType Name;
    public static PropSpecType Id;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.PROPSPECunion : ValueType {
    internal IntPtr name;
    internal UInt32 propId;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.PROPVARIANT : ValueType {
    internal VARTYPE vt;
    internal ushort wReserved1;
    internal ushort wReserved2;
    internal ushort wReserved3;
    internal PropVariantUnion union;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.PropVariantUnion : ValueType {
    internal sbyte cVal;
    internal byte bVal;
    internal short iVal;
    internal ushort uiVal;
    internal int lVal;
    internal UInt32 ulVal;
    internal int intVal;
    internal UInt32 uintVal;
    internal long hVal;
    internal ulong uhVal;
    internal float fltVal;
    internal double dblVal;
    internal short boolVal;
    internal int scode;
    internal CY cyVal;
    internal double date;
    internal FILETIME filetime;
    internal IntPtr puuid;
    internal IntPtr pclipdata;
    internal IntPtr bstrVal;
    internal BSTRBLOB bstrblobVal;
    internal BLOB blob;
    internal IntPtr pszVal;
    internal IntPtr pwszVal;
    internal IntPtr punkVal;
    internal IntPtr pdispVal;
    internal IntPtr pStream;
    internal IntPtr pStorage;
    internal IntPtr pVersionedStream;
    internal IntPtr parray;
    internal CArray cArray;
    internal IntPtr pcVal;
    internal IntPtr pbVal;
    internal IntPtr piVal;
    internal IntPtr puiVal;
    internal IntPtr plVal;
    internal IntPtr pulVal;
    internal IntPtr pintVal;
    internal IntPtr puintVal;
    internal IntPtr pfltVal;
    internal IntPtr pdblVal;
    internal IntPtr pboolVal;
    internal IntPtr pdecVal;
    internal IntPtr pscode;
    internal IntPtr pcyVal;
    internal IntPtr pdate;
    internal IntPtr pbstrVal;
    internal IntPtr ppunkVal;
    internal IntPtr ppdispVal;
    internal IntPtr pparray;
    internal IntPtr pvarVal;
}
internal class MS.Internal.IO.Packaging.SparseMemoryStream : Stream {
    private TrackingMemoryStreamFactory _trackingMemoryStreamFactory;
    private string _isolatedStorageStreamFileName;
    private Stream _isolatedStorageStream;
    private static int _fixBlockInMemoryOverhead;
    private bool _disposedFlag;
    private bool _isolatedStorageMode;
    private long _currentStreamLength;
    private long _currentStreamPosition;
    private List`1<MemoryStreamBlock> _memoryStreamList;
    private MemoryStreamBlock _searchBlock;
    private long _lowWaterMark;
    private long _highWaterMark;
    private bool _autoCloseSmallBlockGaps;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal List`1<MemoryStreamBlock> MemoryBlockCollection { get; }
    internal long MemoryConsumption { get; }
    internal SparseMemoryStream(long lowWaterMark, long highWaterMark);
    internal SparseMemoryStream(long lowWaterMark, long highWaterMark, bool autoCloseSmallBlockGaps);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long newLength);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    internal void WriteToStream(Stream stream);
    protected virtual void Dispose(bool disposing);
    internal List`1<MemoryStreamBlock> get_MemoryBlockCollection();
    internal long get_MemoryConsumption();
    private void CheckDisposed();
    private MemoryStreamBlock GetSearchBlockForOffset(long offset);
    private bool CanCollapseWithPreviousBlock(MemoryStreamBlock memStreamBlock, long offset, long length);
    private void WriteAndCollapseBlocks(Byte[] buffer, int offset, int count);
    private MemoryStreamBlock ConstructMemoryStreamFromWriteRequest(Byte[] buffer, long writeRequestOffset, int writeRequestSize, int bufferOffset);
    private void SwitchModeIfNecessary();
    private void CopyMemoryBlocksToStream(Stream targetStream);
    private long SkipWrite(Stream targetStream, long currentPos, long offset);
    private void EnsureIsolatedStoreStream();
}
internal class MS.Internal.IO.Packaging.STATPROPSETSTG : ValueType {
    private Guid fmtid;
    private Guid clsid;
    private UInt32 grfFlags;
    private FILETIME mtime;
    private FILETIME ctime;
    private FILETIME atime;
    private UInt32 dwOSVersion;
}
internal class MS.Internal.IO.Packaging.STATPROPSTG : ValueType {
    private string lpwstrName;
    private UInt32 propid;
    private VARTYPE vt;
}
internal class MS.Internal.IO.Packaging.StorageBasedPackageProperties : PackageProperties {
    private bool _disposed;
    private int _grfMode;
    private IPropertySetStorage _pss;
    private IPropertyStorage _psSummInfo;
    private IPropertyStorage _psDocSummInfo;
    public string Title { get; public set; }
    public string Subject { get; public set; }
    public string Creator { get; public set; }
    public string Keywords { get; public set; }
    public string Description { get; public set; }
    public string LastModifiedBy { get; public set; }
    public string Revision { get; public set; }
    public Nullable`1<DateTime> LastPrinted { get; public set; }
    public Nullable`1<DateTime> Created { get; public set; }
    public Nullable`1<DateTime> Modified { get; public set; }
    public string Category { get; public set; }
    public string Identifier { get; public set; }
    public string ContentType { get; public set; }
    public string Language { get; public set; }
    public string Version { get; public set; }
    public string ContentStatus { get; public set; }
    internal StorageBasedPackageProperties(StorageRoot root);
    protected virtual override void Finalize();
    public virtual string get_Title();
    public virtual void set_Title(string value);
    public virtual string get_Subject();
    public virtual void set_Subject(string value);
    public virtual string get_Creator();
    public virtual void set_Creator(string value);
    public virtual string get_Keywords();
    public virtual void set_Keywords(string value);
    public virtual string get_Description();
    public virtual void set_Description(string value);
    public virtual string get_LastModifiedBy();
    public virtual void set_LastModifiedBy(string value);
    public virtual string get_Revision();
    public virtual void set_Revision(string value);
    public virtual Nullable`1<DateTime> get_LastPrinted();
    public virtual void set_LastPrinted(Nullable`1<DateTime> value);
    public virtual Nullable`1<DateTime> get_Created();
    public virtual void set_Created(Nullable`1<DateTime> value);
    public virtual Nullable`1<DateTime> get_Modified();
    public virtual void set_Modified(Nullable`1<DateTime> value);
    public virtual string get_Category();
    public virtual void set_Category(string value);
    public virtual string get_Identifier();
    public virtual void set_Identifier(string value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual string get_Language();
    public virtual void set_Language(string value);
    public virtual string get_Version();
    public virtual void set_Version(string value);
    public virtual string get_ContentStatus();
    public virtual void set_ContentStatus(string value);
    protected virtual void Dispose(bool disposing);
    private object GetOleProperty(Guid fmtid, UInt32 propId);
    private void SetOleProperty(Guid fmtid, UInt32 propId, object propVal);
    private Nullable`1<DateTime> GetDateTimeProperty(Guid fmtid, UInt32 propId);
    private void OpenPropertyStorage(Guid& fmtid, IPropertyStorage& ips);
    private VARTYPE GetVtFromPropId(Guid fmtid, UInt32 propId);
    private void CheckDisposed();
}
internal class MS.Internal.IO.Packaging.TrackingMemoryStream : MemoryStream {
    private ITrackingMemoryStreamFactory _memoryStreamFactory;
    private int _lastReportedHighWaterMark;
    internal TrackingMemoryStream(ITrackingMemoryStreamFactory memoryStreamFactory);
    internal TrackingMemoryStream(ITrackingMemoryStreamFactory memoryStreamFactory, int capacity);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    private void ReportIfNeccessary();
}
internal class MS.Internal.IO.Packaging.TrackingMemoryStreamFactory : object {
    private long _bufferedMemoryConsumption;
    internal long CurrentMemoryConsumption { get; }
    public sealed virtual MemoryStream Create();
    public sealed virtual MemoryStream Create(int capacity);
    public sealed virtual void ReportMemoryUsageDelta(int delta);
    internal long get_CurrentMemoryConsumption();
}
[FriendAccessAllowedAttribute]
internal enum MS.Internal.IO.Packaging.VARTYPE : Enum {
    public short value__;
    public static VARTYPE VT_BSTR;
    public static VARTYPE VT_LPSTR;
    public static VARTYPE VT_FILETIME;
}
internal class MS.Internal.IO.Packaging.XmlDigitalSignatureProcessor : object {
    private PackagePart _signaturePart;
    private X509Certificate2 _certificate;
    private bool _lookForEmbeddedCert;
    private PackageDigitalSignatureManager _manager;
    private PackageDigitalSignature _signature;
    private SignedXml _signedXml;
    private string _hashAlgorithmName;
    private bool _dataObjectParsed;
    private DateTime _signingTime;
    private string _signingTimeFormat;
    private List`1<Uri> _partManifest;
    private List`1<PartManifestEntry> _partEntryManifest;
    private List`1<PackageRelationshipSelector> _relationshipManifest;
    private static ContentType _xmlSignaturePartType;
    private static Dictionary`2<string, string> _rsaSigMethodLookup;
    internal static ContentType ContentType { get; }
    internal PackagePart SignaturePart { get; }
    internal List`1<Uri> PartManifest { get; }
    internal List`1<PackageRelationshipSelector> RelationshipManifest { get; }
    internal X509Certificate2 Signer { get; }
    internal Byte[] SignatureValue { get; }
    internal Signature Signature { get; internal set; }
    internal PackageDigitalSignature PackageSignature { get; }
    internal DateTime SigningTime { get; }
    internal string TimeFormat { get; }
    internal XmlDigitalSignatureProcessor(PackageDigitalSignatureManager manager, PackagePart signaturePart, PackageDigitalSignature packageSignature);
    private XmlDigitalSignatureProcessor(PackageDigitalSignatureManager manager, PackagePart signaturePart);
    private static XmlDigitalSignatureProcessor();
    internal static PackageDigitalSignature Sign(PackageDigitalSignatureManager manager, PackagePart signaturePart, IEnumerable`1<Uri> parts, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, X509Certificate2 signer, string signatureId, bool embedCertificate, IEnumerable`1<DataObject> signatureObjects, IEnumerable`1<Reference> objectReferences);
    internal bool Verify();
    internal bool Verify(X509Certificate2 signer);
    internal List`1<string> GetPartTransformList(Uri partName);
    internal static ContentType get_ContentType();
    internal PackagePart get_SignaturePart();
    internal List`1<Uri> get_PartManifest();
    internal List`1<PackageRelationshipSelector> get_RelationshipManifest();
    internal X509Certificate2 get_Signer();
    internal Byte[] get_SignatureValue();
    internal Signature get_Signature();
    internal void set_Signature(Signature value);
    internal PackageDigitalSignature get_PackageSignature();
    internal DateTime get_SigningTime();
    internal string get_TimeFormat();
    internal static string GenerateDigestValue(Stream s, string transformName, HashAlgorithm hashAlgorithm);
    internal static string GenerateDigestValue(Stream s, List`1<string> transforms, HashAlgorithm hashAlgorithm);
    internal static Stream GenerateRelationshipNodeStream(IEnumerable`1<PackageRelationship> relationships);
    internal static HashAlgorithm GetHashAlgorithm(string hashAlgorithmName);
    private static Transform StringToTransform(string transformName);
    internal static bool IsValidXmlCanonicalizationTransform(string transformName);
    private SignedXml EnsureXmlSignatureParsed();
    private PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, X509Certificate2 signer, string signatureId, bool embedCertificate, IEnumerable`1<DataObject> signatureObjects, IEnumerable`1<Reference> objectReferences);
    private string SelectSignatureMethod(AsymmetricAlgorithm key);
    private static AsymmetricAlgorithm GetPrivateKey(X509Certificate2 cert);
    private Stream GetRelationshipStream(PartManifestEntry partEntry);
    private void AddCustomObjectTags(IEnumerable`1<DataObject> signatureObjects, IEnumerable`1<Reference> objectReferences);
    private void UpdatePartFromSignature(Signature sig);
    private static Byte[] HashStream(HashAlgorithm hashAlgorithm, Stream s);
    private static Stream TransformXml(Transform xForm, object source);
    private void ParsePackageDataObject();
    private DataObject GetPackageDataObject();
    private KeyInfo GenerateKeyInfo(AsymmetricAlgorithm key, X509Certificate2 signer);
    private DataObject GenerateObjectTag(HashAlgorithm hashAlgorithm, IEnumerable`1<Uri> parts, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, string signatureId);
    private static AsymmetricAlgorithm GetPrivateKeyForSigning(X509Certificate2 signer);
    private void ValidateReferences(IEnumerable references, bool allowPackageSpecificReferences);
}
internal static class MS.Internal.IO.Packaging.XmlSignatureManifest : object {
    private static string _contentTypeQueryStringPrefix;
    internal static void ParseManifest(PackageDigitalSignatureManager manager, XmlReader reader, List`1& partManifest, List`1& partEntryManifest, List`1& relationshipManifest);
    private static string ParseDigestAlgorithmTag(XmlReader reader);
    private static string ParseDigestValueTag(XmlReader reader);
    private static Uri ParsePartUri(XmlReader reader, ContentType& contentType);
    private static PartManifestEntry ParseReference(XmlReader reader);
    private static List`1<string> ParseTransformsTag(XmlReader reader, Uri partUri, List`1& relationshipSelectors);
    private static void ParseRelationshipsTransform(XmlReader reader, Uri partUri, List`1& relationshipSelectors);
    internal static XmlNode GenerateManifest(PackageDigitalSignatureManager manager, XmlDocument xDoc, HashAlgorithm hashAlgorithm, IEnumerable`1<Uri> parts, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors);
    private static int GenerateRelationshipSigningReferences(PackageDigitalSignatureManager manager, XmlDocument xDoc, HashAlgorithm hashAlgorithm, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, XmlNode manifest);
    private static Uri ParsePartUriAttribute(string attrValue, ContentType& contentType);
    private static XmlNode GenerateRelationshipSigningReference(PackageDigitalSignatureManager manager, XmlDocument xDoc, HashAlgorithm hashAlgorithm, Uri relationshipPartName, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors);
    private static XmlNode GeneratePartSigningReference(PackageDigitalSignatureManager manager, XmlDocument xDoc, HashAlgorithm hashAlgorithm, Uri partName);
    private static XmlNode GenerateDigestMethod(PackageDigitalSignatureManager manager, XmlDocument xDoc);
    private static XmlNode GenerateDigestValueNode(XmlDocument xDoc, HashAlgorithm hashAlgorithm, Stream s, string transformName);
    private static IEnumerable`1<PackageRelationship> GetRelationships(PackageDigitalSignatureManager manager, IEnumerable`1<PackageRelationshipSelector> relationshipSelectorsWithSameSource);
}
internal static class MS.Internal.IO.Packaging.XmlSignatureProperties : object {
    private static TimeFormatMapEntry[] _dateTimePatternMap;
    internal static string DefaultDateTimeFormat { get; }
    private static XmlSignatureProperties();
    internal static string get_DefaultDateTimeFormat();
    internal static bool LegalFormat(string candidateFormat);
    internal static XmlElement AssembleSignatureProperties(XmlDocument xDoc, DateTime dateTime, string xmlDateTimeFormat, string signatureId);
    internal static DateTime ParseSigningTime(XmlReader reader, string signatureId, String& timeFormat);
    private static DateTime ParseSignatureTimeTag(XmlReader reader, String& timeFormat);
    private static string DateTimeToXmlFormattedTime(DateTime dt, string format);
    private static DateTime XmlFormattedTimeToDateTime(string s, string format);
    private static int GetIndex(string format);
    private static String[] ConvertXmlFormatStringToDateTimeFormatString(string format);
    private static bool VerifyIdAttribute(XmlReader reader);
    private static bool VerifyTargetAttribute(XmlReader reader, string signatureId);
}
internal static class MS.Internal.IO.Packaging.XTable : object {
    private static TableEntry[] _table;
    private static XTable();
    internal static string Get(ID i);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.KnownBoxes.BooleanBoxes : object {
    internal static object TrueBox;
    internal static object FalseBox;
    private static BooleanBoxes();
    internal static object Box(bool value);
    internal static object Box(Nullable`1<bool> value);
}
[FlagsAttribute]
internal enum MS.Internal.MatrixTypes : Enum {
    public int value__;
    public static MatrixTypes TRANSFORM_IS_IDENTITY;
    public static MatrixTypes TRANSFORM_IS_TRANSLATION;
    public static MatrixTypes TRANSFORM_IS_SCALING;
    public static MatrixTypes TRANSFORM_IS_UNKNOWN;
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.MatrixUtil : object {
    internal static void TransformRect(Rect& rect, Matrix& matrix);
    internal static void MultiplyMatrix(Matrix& matrix1, Matrix& matrix2);
    internal static void PrependOffset(Matrix& matrix, double offsetX, double offsetY);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.NamedObject : object {
    private string _name;
    public NamedObject(string name);
    public virtual string ToString();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.ObservableCollectionDefaultValueFactory`1 : DefaultValueFactory {
    private ObservableCollection`1<T> _default;
    internal object DefaultValue { get; }
    internal virtual object get_DefaultValue();
    internal virtual object CreateDefaultValue(DependencyObject owner, DependencyProperty property);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.PlatformCulture : object {
    public static CultureInfo Value { get; }
    public static CultureInfo get_Value();
}
internal class MS.Internal.ReaderWriterLockSlimWrapper : object {
    private ReaderWriterLockSlim _rwLock;
    private LockRecursionPolicy _lockRecursionPolicy;
    private bool _disableDispatcherProcessingWhenNoRecursion;
    private bool _disposed;
    internal ReaderWriterLockSlimWrapper(LockRecursionPolicy recursionPolicy, bool disableDispatcherProcessingWhenNoRecursion);
    internal bool WithReadLock(Action criticalAction);
    internal bool WithReadLock(Action`1<T> criticalAction, T arg);
    internal bool WithReadLock(Func`2<T, TResult> criticalAction, T arg, TResult& result);
    internal bool WithReadLock(Func`3<T1, T2, TResult> criticalAction, T1 arg1, T2 arg2, TResult& result);
    internal bool WithWriteLock(Action criticalAction);
    internal bool WithWriteLock(Action`1<T> criticalAction, T arg);
    internal bool WithWriteLock(Func`2<T, TResult> criticalAction, T arg, TResult& result);
    internal bool WithWriteLock(Func`3<T1, T2, TResult> criticalAction, T1 arg1, T2 arg2, TResult& result);
    private bool ExecuteWithinLockInternal(Action lockAcquire, Action lockRelease, Object& result, Delegate criticalAction, Object[] args);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.ReaderWriterLockWrapper : object {
    private ReaderWriterLockSlim _rwLock;
    private AutoReaderRelease _arr;
    private AutoWriterRelease _awr;
    private AutoReaderReleaseClass _arrc;
    private AutoWriterReleaseClass _awrc;
    private Action _enterReadAction;
    private Action _exitReadAction;
    private Action _enterWriteAction;
    private Action _exitWriteAction;
    private NonPumpingSynchronizationContext _defaultSynchronizationContext;
    internal IDisposable WriteLock { get; }
    internal IDisposable ReadLock { get; }
    private void Initialize(bool useLegacyMemoryBehavior);
    internal IDisposable get_WriteLock();
    internal IDisposable get_ReadLock();
    private void ReleaseWriterLock();
    private void ReleaseReaderLock();
    private void ReleaseWriterLock2();
    private void ReleaseReaderLock2();
    private void CallWithNonPumpingWait(Action callback);
    [CompilerGeneratedAttribute]
private void <get_WriteLock>b__3_0();
    [CompilerGeneratedAttribute]
private void <get_ReadLock>b__5_0();
    [CompilerGeneratedAttribute]
private void <ReleaseWriterLock>b__6_0();
    [CompilerGeneratedAttribute]
private void <ReleaseReaderLock>b__7_0();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.RegistryKeys : object {
    internal static string WPF;
    internal static string WPF_Features;
    internal static string value_MediaImageDisallow;
    internal static string value_MediaVideoDisallow;
    internal static string value_MediaAudioDisallow;
    internal static string value_WebBrowserDisallow;
    internal static string value_ScriptInteropDisallow;
    internal static string value_AutomationWeakReferenceDisallow;
    internal static string WPF_Hosting;
    internal static string value_DisableXbapErrorPage;
    internal static string value_UnblockWebBrowserControl;
    internal static string HKCU_XpsViewer;
    internal static string value_IsolatedStorageUserQuota;
    internal static string HKLM_XpsViewerLocalServer32;
    internal static string HKLM_IetfLanguage;
    internal static string FRAMEWORK_RegKey;
    internal static string FRAMEWORK_RegKey_FullPath;
    internal static string FRAMEWORK_InstallPath_RegValue;
    internal static bool ReadLocalMachineBool(string key, string valueName);
}
internal static class MS.Internal.ResourceIDHelper : object {
    internal static string GetResourceIDFromRelativePath(string relPath);
    private static string GetResourceIDFromUri(Uri baseUri, Uri sourceUri);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.Security.AttachmentService : object {
    private ISecuritySuppressedIAttachmentExecute _native;
    private Guid _clientId;
    internal static void SaveWithUI(IntPtr parent, Uri source, Uri target);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
}
[FlagsAttribute]
internal enum MS.Internal.Security.RightsManagement.AcquireLicenseFlags : Enum {
    public UInt32 value__;
    public static AcquireLicenseFlags NonSilent;
    public static AcquireLicenseFlags NoPersist;
    public static AcquireLicenseFlags Cancel;
    public static AcquireLicenseFlags FetchAdvisory;
    public static AcquireLicenseFlags NoUI;
}
[FlagsAttribute]
internal enum MS.Internal.Security.RightsManagement.ActivationFlags : Enum {
    public UInt32 value__;
    public static ActivationFlags Machine;
    public static ActivationFlags GroupIdentity;
    public static ActivationFlags Temporary;
    public static ActivationFlags Cancel;
    public static ActivationFlags Silent;
    public static ActivationFlags SharedGroupIdentity;
    public static ActivationFlags Delayed;
}
internal class MS.Internal.Security.RightsManagement.ActivationServerInfo : object {
    public UInt32 Version;
    internal string PubKey;
    internal string Url;
}
internal class MS.Internal.Security.RightsManagement.BoundLicenseParams : object {
    internal UInt32 uVersion;
    internal UInt32 hEnablingPrincipal;
    internal UInt32 hSecureStore;
    public string wszRightsRequested;
    public string wszRightsGroup;
    internal UInt32 DRMIDuVersion;
    public string DRMIDIdType;
    public string DRMIDId;
    internal UInt32 cAuthenticatorCount;
    internal IntPtr rghAuthenticators;
    public string wszDefaultEnablingPrincipalCredentials;
    internal UInt32 dwFlags;
}
internal class MS.Internal.Security.RightsManagement.CallbackDelegate : MulticastDelegate {
    public CallbackDelegate(object object, IntPtr method);
    public virtual int Invoke(StatusMessage status, int hr, IntPtr pvParam, IntPtr pvContext);
    public virtual IAsyncResult BeginInvoke(StatusMessage status, int hr, IntPtr pvParam, IntPtr pvContext, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Security.RightsManagement.CallbackHandler : object {
    private CallbackDelegate _callbackDelegate;
    private AutoResetEvent _resetEvent;
    private string _callbackData;
    private int _hr;
    private Exception _exception;
    private static UInt32 S_DRM_COMPLETED;
    internal CallbackDelegate CallbackDelegate { get; }
    internal string CallbackData { get; }
    internal CallbackDelegate get_CallbackDelegate();
    internal string get_CallbackData();
    internal void WaitForCompletion();
    public sealed virtual void Dispose();
    private int OnStatus(StatusMessage status, int hr, IntPtr pvParam, IntPtr pvContext);
    private void Dispose(bool disposing);
}
internal class MS.Internal.Security.RightsManagement.ClientSession : object {
    private static string _defaultUserName;
    private static string _distributionPointLicenseAcquisitionType;
    private static string _distributionPointReferralInfoType;
    private static string _passportActivationRegistryFullKeyName;
    private static string _passportActivationRegistryKeyName;
    private ContentUser _user;
    private CallbackHandler _callbackHandler;
    private SafeRightsManagementSessionHandle _hSession;
    private UserActivationMode _userActivationMode;
    private SafeRightsManagementEnvironmentHandle _envHandle;
    private SafeRightsManagementHandle _defaultLibraryHandle;
    private List`1<CryptoProvider> _cryptoProviderList;
    private static ContentRight[] _rightEnums;
    private static String[] _rightNames;
    private List`1<CryptoProvider> CryptoProviderList { get; }
    internal ClientSession(ContentUser user);
    internal ClientSession(ContentUser user, UserActivationMode userActivationMode);
    private static ClientSession();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal static ClientSession DefaultUserClientSession(AuthenticationType authentication);
    internal bool IsMachineActivated();
    internal void ActivateMachine(AuthenticationType authentication);
    internal bool IsUserActivated();
    internal ContentUser ActivateUser(AuthenticationType authentication, UserActivationMode userActivationMode);
    internal bool IsClientLicensorCertificatePresent();
    internal void AcquireClientLicensorCertificate();
    internal void BuildSecureEnvironment(string applicationManifest);
    private bool IsActivated(ActivationFlags activateFlags);
    internal string GetMachineCert();
    internal List`1<string> EnumerateUsersCertificateIds(ContentUser user, EnumerateLicenseFlags certificateType);
    internal void DeleteLicense(string licenseId);
    internal void RemoveUsersCertificates(EnumerateLicenseFlags certificateType);
    private string GetClientLicensorCert();
    private string GetGroupIdentityCert();
    private string GetLatestCertificate(EnumerateLicenseFlags enumerateLicenseFlags);
    private static ArrayList EnumerateAllValuesOnSession(SafeRightsManagementSessionHandle sessionHandle, EnumerateLicenseFlags enumerateLicenseFlags);
    internal static string GetLicenseOnSession(SafeRightsManagementSessionHandle sessionHandle, EnumerateLicenseFlags enumerateLicenseFlags, int index);
    internal string EnumerateLicense(EnumerateLicenseFlags enumerateLicenseFlags, int index);
    internal PublishLicense SignIssuanceLicense(IssuanceLicense issuanceLicense, UseLicense& authorUseLicense);
    internal UseLicense AcquireUseLicense(string publishLicense, bool noUI);
    private static int FindNewEntryIndex(ArrayList oldList, ArrayList newList);
    private CryptoProvider BindUseLicense(string serializedUseLicense, List`1<RightNameExpirationInfoPair> unboundRightsList, BoundLicenseParams boundLicenseParams, Int32& theFirstHrFailureCode);
    internal CryptoProvider TryBindUseLicenseToAllIdentites(string serializedUseLicense);
    private Uri GetCertificationUrl(AuthenticationType authentication);
    private static Uri GetRegistryPassportCertificationUrl();
    private Uri GetClientLicensorUrl(AuthenticationType authentication);
    private string Activate(ActivationFlags activationFlags, Uri url);
    private Uri GetServiceLocation(ServiceType serviceType, ServiceLocation serviceLocation, string issuanceLicense);
    internal static string GetOwnerLicense(SafeRightsManagementPubHandle issuanceLicenseHandle);
    private static string GetElementFromCertificateChain(string certificateChain, int index);
    private static string GetUnboundLicenseStringAttribute(SafeRightsManagementQueryHandle queryHandle, string attributeType, UInt32 attributeIndex);
    private static DateTime GetUnboundLicenseDateTimeAttribute(SafeRightsManagementQueryHandle queryHandle, string attributeType, UInt32 attributeIndex, DateTime defaultValue);
    internal static ContentUser ExtractUserFromCertificateChain(string certificateChain);
    private static DateTime ExtractIssuedTimeFromCertificateChain(string certificateChain, DateTime defaultValue);
    private static DateTime ExtractIssuedTimeFromCertificate(string certificate, DateTime defaultValue);
    internal static ContentUser ExtractUserFromCertificate(string certificate);
    internal static string ExtractCertificateIdFromCertificateChain(string certificateChain);
    internal static string ExtractCertificateIdFromCertificate(string certificate);
    internal static Dictionary`2<string, string> ExtractApplicationSpecificDataFromLicense(string useLicenseChain);
    internal static void GetContentIdFromLicense(string useLicenseChain, String& contentId, String& contentIdType);
    private static List`1<RightNameExpirationInfoPair> GetRightsInfoFromUseLicense(string useLicenseChain, String& rightGroupName);
    private static RightNameExpirationInfoPair GetRightInfoFromRightGroupQueryHandle(SafeRightsManagementQueryHandle rightGroupQueryHandle, UInt32 rightIndex);
    internal static string GetContentIdFromPublishLicense(string publishLicense);
    internal static Uri GetUseLicenseAcquisitionUriFromPublishLicense(string publishLicense);
    internal static void GetReferralInfoFromPublishLicense(string publishLicense, String& referralInfoName, Uri& referralInfoUri);
    private static void GetDistributionPointInfoFromPublishLicense(string publishLicense, string distributionPointType, String& nameAttributeValue, String& addressAttributeValue);
    internal static string GetSecurityProviderPath();
    internal static Nullable`1<ContentRight> GetRightFromString(string rightName);
    internal static string GetStringFromRight(ContentRight right);
    private List`1<CryptoProvider> get_CryptoProviderList();
    private void CheckDisposed();
}
internal enum MS.Internal.Security.RightsManagement.DistributionPointInfo : Enum {
    public int value__;
    public static DistributionPointInfo LicenseAcquisition;
    public static DistributionPointInfo Publishing;
    public static DistributionPointInfo ReferralInfo;
}
[FlagsAttribute]
internal enum MS.Internal.Security.RightsManagement.EnumerateLicenseFlags : Enum {
    public UInt32 value__;
    public static EnumerateLicenseFlags Machine;
    public static EnumerateLicenseFlags GroupIdentity;
    public static EnumerateLicenseFlags GroupIdentityName;
    public static EnumerateLicenseFlags GroupIdentityLid;
    public static EnumerateLicenseFlags SpecifiedGroupIdentity;
    public static EnumerateLicenseFlags Eul;
    public static EnumerateLicenseFlags EulLid;
    public static EnumerateLicenseFlags ClientLicensor;
    public static EnumerateLicenseFlags ClientLicensorLid;
    public static EnumerateLicenseFlags SpecifiedClientLicensor;
    public static EnumerateLicenseFlags RevocationList;
    public static EnumerateLicenseFlags RevocationListLid;
    public static EnumerateLicenseFlags Expired;
}
internal static class MS.Internal.Security.RightsManagement.Errors : object {
    internal static string GetLocalizedFailureCodeMessageWithDefault(RightsManagementFailureCode failureCode);
    internal static void ThrowOnErrorCode(int hr);
    private static string GetLocalizedFailureCodeMessage(RightsManagementFailureCode failureCode);
}
internal class MS.Internal.Security.RightsManagement.IssuanceLicense : object {
    private List`1<SafeRightsManagementPubHandle> _pubHandlesList;
    private SafeRightsManagementPubHandle _issuanceLicenseHandle;
    private static string DefaultContentType;
    private static string UnspecifiedAuthenticationType;
    internal SafeRightsManagementPubHandle Handle { get; }
    internal IssuanceLicense(DateTime validFrom, DateTime validUntil, string referralInfoName, Uri referralInfoUri, ContentUser owner, string issuanceLicense, SafeRightsManagementHandle boundLicenseHandle, Guid contentId, ICollection`1<ContentGrant> grantCollection, IDictionary`2<int, LocalizedNameDescriptionPair> localizedNameDescriptionDictionary, IDictionary`2<string, string> applicationSpecificDataDictionary, int rightValidityIntervalDays, RevocationPoint revocationPoint);
    private void Initialize(DateTime validFrom, DateTime validUntil, string referralInfoName, Uri referralInfoUri, ContentUser owner, string issuanceLicense, SafeRightsManagementHandle boundLicenseHandle, Guid contentId, ICollection`1<ContentGrant> grantCollection, IDictionary`2<int, LocalizedNameDescriptionPair> localizedNameDescriptionDictionary, IDictionary`2<string, string> applicationSpecificDataDictionary, int rightValidityIntervalDays, RevocationPoint revocationPoint);
    internal SafeRightsManagementPubHandle get_Handle();
    public virtual string ToString();
    internal void UpdateUnsignedPublishLicense(UnsignedPublishLicense unsignedPublishLicense);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void AddGrant(ContentGrant grant);
    private void AddNameDescription(int localeId, LocalizedNameDescriptionPair nameDescription);
    private void AddApplicationSpecificData(string name, string value);
    private SafeRightsManagementPubHandle GetRightHandle(ContentGrant grant);
    private SafeRightsManagementPubHandle GetHandleFromUser(ContentUser user);
    private static Nullable`1<ContentRight> GetRightFromHandle(SafeRightsManagementPubHandle rightHandle, DateTime& validFrom, DateTime& validUntil);
    private static ContentUser GetUserFromHandle(SafeRightsManagementPubHandle userHandle);
    private ContentUser GetIssuanceLicenseUser(int index, SafeRightsManagementPubHandle& userHandle);
    private LocalizedNameDescriptionPair GetLocalizedNameDescriptionPair(int index, Int32& localeId);
    private Nullable`1<KeyValuePair`2<string, string>> GetApplicationSpecificData(int index);
    private Nullable`1<ContentRight> GetIssuanceLicenseUserRight(SafeRightsManagementPubHandle userHandle, int index, SafeRightsManagementPubHandle& rightHandle, DateTime& validFrom, DateTime& validUntil);
    private void GetIssuanceLicenseInfo(DateTime& timeFrom, DateTime& timeUntil, DistributionPointInfo distributionPointInfo, String& distributionPointName, String& distributionPointUri, ContentUser& owner, Boolean& officialFlag);
    private void SetRevocationPoint(RevocationPoint revocationPoint);
    private RevocationPoint GetRevocationPoint();
    private void CheckDisposed();
    private string ConvertAuthenticationTypeToString(ContentUser user);
}
internal enum MS.Internal.Security.RightsManagement.LicenseAttributeEncoding : Enum {
    public int value__;
    public static LicenseAttributeEncoding Base64;
    public static LicenseAttributeEncoding String;
    public static LicenseAttributeEncoding Long;
    public static LicenseAttributeEncoding Time;
    public static LicenseAttributeEncoding UInt;
    public static LicenseAttributeEncoding Raw;
}
internal static class MS.Internal.Security.RightsManagement.NativeConstants : object {
    public static UInt32 DrmCallbackVersion;
    internal static string TAG_ASCII;
    internal static string TAG_XRML;
    internal static string TAG_FILENAME;
    internal static string TAG_MSGUID;
    internal static string PLUG_STANDARDENABLINGPRINCIPAL;
    internal static string PLUG_STANDARDRIGHTSINTERPRETER;
    internal static string PLUG_STANDARDEBDECRYPTOR;
    internal static string PLUG_STANDARDEBENCRYPTOR;
    internal static string PLUG_STANDARDEBCRYPTOPROVIDER;
    internal static string PLUG_STANDARDLIBRARY;
    internal static string ALGORITHMID_DES;
    internal static string ALGORITHMID_COCKTAIL;
    internal static string ALGORITHMID_AES;
    internal static string ALGORITHMID_RC4;
    internal static string QUERY_OBJECTIDTYPE;
    internal static string QUERY_OBJECTID;
    internal static string QUERY_NAME;
    internal static string QUERY_CONTENTIDTYPE;
    internal static string QUERY_CONTENTIDVALUE;
    internal static string QUERY_CONTENTSKUTYPE;
    internal static string QUERY_CONTENTSKUVALUE;
    internal static string QUERY_MANIFESTSOURCE;
    internal static string QUERY_MACHINECERTSOURCE;
    internal static string QUERY_APIVERSION;
    internal static string QUERY_SECREPVERSION;
    internal static string QUERY_BLOCKSIZE;
    internal static string QUERY_ACCESSCONDITION;
    internal static string QUERY_ADDRESSTYPE;
    internal static string QUERY_ADDRESSVALUE;
    internal static string QUERY_APPDATANAME;
    internal static string QUERY_APPDATAVALUE;
    internal static string QUERY_CONDITIONLIST;
    internal static string QUERY_DISTRIBUTIONPOINT;
    internal static string QUERY_OBJECTTYPE;
    internal static string QUERY_ENABLINGPRINCIPALIDTYPE;
    internal static string QUERY_ENABLINGPRINCIPALIDVALUE;
    internal static string QUERY_GROUPIDENTITYPRINCIPAL;
    internal static string QUERY_FIRSTUSETAG;
    internal static string QUERY_FROMTIME;
    internal static string QUERY_IDTYPE;
    internal static string QUERY_IDVALUE;
    internal static string QUERY_ISSUEDPRINCIPAL;
    internal static string QUERY_ISSUEDTIME;
    internal static string QUERY_ISSUER;
    internal static string QUERY_OWNER;
    internal static string QUERY_PRINCIPAL;
    internal static string QUERY_PRINCIPALIDVALUE;
    internal static string QUERY_PRINCIPALIDTYPE;
    internal static string QUERY_RANGETIMECONDITION;
    internal static string QUERY_OSEXCLUSIONCONDITION;
    internal static string QUERY_INTERVALTIMECONDITION;
    internal static string QUERY_INTERVALTIMEINTERVAL;
    internal static string QUERY_MAXVERSION;
    internal static string QUERY_MINVERSION;
    internal static string QUERY_REFRESHPERIOD;
    internal static string QUERY_REVOCATIONCONDITION;
    internal static string QUERY_RIGHT;
    internal static string QUERY_RIGHTSGROUP;
    internal static string QUERY_RIGHTSPARAMETERNAME;
    internal static string QUERY_RIGHTSPARAMETERVALUE;
    internal static string QUERY_SKUTYPE;
    internal static string QUERY_SKUVALUE;
    internal static string QUERY_TIMEINTERVAL;
    internal static string QUERY_UNTILTIME;
    internal static string QUERY_VALIDITYFROMTIME;
    internal static string QUERY_VALIDITYUNTILTIME;
    internal static string QUERY_WORK;
}
internal class MS.Internal.Security.RightsManagement.RevocationPoint : object {
    private string _id;
    private string _idType;
    private Uri _url;
    private SystemTime _frequency;
    private string _name;
    private string _publicKey;
    internal string Id { get; internal set; }
    internal string IdType { get; internal set; }
    internal Uri Url { get; internal set; }
    internal SystemTime Frequency { get; internal set; }
    internal string Name { get; internal set; }
    internal string PublicKey { get; internal set; }
    internal string get_Id();
    internal void set_Id(string value);
    internal string get_IdType();
    internal void set_IdType(string value);
    internal Uri get_Url();
    internal void set_Url(Uri value);
    internal SystemTime get_Frequency();
    internal void set_Frequency(SystemTime value);
    internal string get_Name();
    internal void set_Name(string value);
    internal string get_PublicKey();
    internal void set_PublicKey(string value);
}
internal class MS.Internal.Security.RightsManagement.RightNameExpirationInfoPair : object {
    private string _rightName;
    private DateTime _validFrom;
    private DateTime _validUntil;
    internal string RightName { get; }
    internal DateTime ValidFrom { get; }
    internal DateTime ValidUntil { get; }
    internal RightNameExpirationInfoPair(string rightName, DateTime validFrom, DateTime validUntil);
    internal string get_RightName();
    internal DateTime get_ValidFrom();
    internal DateTime get_ValidUntil();
}
internal static class MS.Internal.Security.RightsManagement.SafeNativeMethods : object {
    internal static int DRMCreateClientSession(CallbackDelegate pfnCallback, UInt32 uCallbackVersion, string GroupIDProviderType, string GroupID, SafeRightsManagementSessionHandle& phSession);
    internal static int DRMCloseSession(UInt32 sessionHandle);
    internal static int DRMCloseHandle(UInt32 handle);
    internal static int DRMCloseQueryHandle(UInt32 queryHandle);
    internal static int DRMCloseEnvironmentHandle(UInt32 envHandle);
    internal static int DRMInitEnvironment(UInt32 eSecurityProviderType, UInt32 eSpecification, string securityProvider, string manifestCredentials, string machineCredentials, SafeRightsManagementEnvironmentHandle& environmentHandle, SafeRightsManagementHandle& defaultLibrary);
    internal static int DRMIsActivated(SafeRightsManagementSessionHandle hSession, UInt32 uFlags, ActivationServerInfo activationServerInfo);
    internal static int DRMActivate(SafeRightsManagementSessionHandle hSession, UInt32 uFlags, UInt32 uLangID, ActivationServerInfo activationServerInfo, IntPtr context, IntPtr parentWindowHandle);
    internal static int DRMCreateLicenseStorageSession(SafeRightsManagementEnvironmentHandle hEnv, SafeRightsManagementHandle hDefLib, SafeRightsManagementSessionHandle hClientSession, UInt32 uFlags, string IssuanceLicense, SafeRightsManagementSessionHandle& phLicenseStorageSession);
    internal static int DRMAcquireLicense(SafeRightsManagementSessionHandle hSession, UInt32 uFlags, string GroupIdentityCredential, string RequestedRights, string CustomData, string url, IntPtr context);
    internal static int DRMEnumerateLicense(SafeRightsManagementSessionHandle hSession, UInt32 uFlags, UInt32 uIndex, Boolean& pfSharedFlag, UInt32& puCertDataLen, StringBuilder wszCertificateData);
    internal static int DRMGetServiceLocation(SafeRightsManagementSessionHandle clientSessionHandle, UInt32 serviceType, UInt32 serviceLocation, string issuanceLicense, UInt32& serviceUrlLength, StringBuilder serviceUrl);
    internal static int DRMDeconstructCertificateChain(string chain, UInt32 index, UInt32& certificateLength, StringBuilder certificate);
    internal static int DRMParseUnboundLicense(string certificate, SafeRightsManagementQueryHandle& queryRootHandle);
    internal static int DRMGetUnboundLicenseObjectCount(SafeRightsManagementQueryHandle queryRootHandle, string subObjectType, UInt32& objectCount);
    internal static int DRMGetBoundLicenseObject(SafeRightsManagementHandle queryRootHandle, string subObjectType, UInt32 index, SafeRightsManagementHandle& subQueryHandle);
    internal static int DRMGetUnboundLicenseObject(SafeRightsManagementQueryHandle queryRootHandle, string subObjectType, UInt32 index, SafeRightsManagementQueryHandle& subQueryHandle);
    internal static int DRMGetUnboundLicenseAttribute(SafeRightsManagementQueryHandle queryRootHandle, string attributeType, UInt32 index, UInt32& encodingType, UInt32& bufferSize, Byte[] buffer);
    internal static int DRMGetBoundLicenseAttribute(SafeRightsManagementHandle queryRootHandle, string attributeType, UInt32 index, UInt32& encodingType, UInt32& bufferSize, Byte[] buffer);
    internal static int DRMCreateIssuanceLicense(SystemTime timeFrom, SystemTime timeUntil, string referralInfoName, string referralInfoUrl, SafeRightsManagementPubHandle ownerUserHandle, string issuanceLicense, SafeRightsManagementHandle boundLicenseHandle, SafeRightsManagementPubHandle& issuanceLicenseHandle);
    internal static int DRMCreateUser(string userName, string userId, string userIdType, SafeRightsManagementPubHandle& userHandle);
    internal static int DRMGetUsers(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32 index, SafeRightsManagementPubHandle& userHandle);
    internal static int DRMGetUserRights(SafeRightsManagementPubHandle issuanceLicenseHandle, SafeRightsManagementPubHandle userHandle, UInt32 index, SafeRightsManagementPubHandle& rightHandle);
    internal static int DRMGetUserInfo(SafeRightsManagementPubHandle userHandle, UInt32& userNameLength, StringBuilder userName, UInt32& userIdLength, StringBuilder userId, UInt32& userIdTypeLength, StringBuilder userIdType);
    internal static int DRMGetRightInfo(SafeRightsManagementPubHandle rightHandle, UInt32& rightNameLength, StringBuilder rightName, SystemTime timeFrom, SystemTime timeUntil);
    internal static int DRMCreateRight(string rightName, SystemTime timeFrom, SystemTime timeUntil, UInt32 countExtendedInfo, String[] extendedInfoNames, String[] extendedInfoValues, SafeRightsManagementPubHandle& rightHandle);
    internal static int DRMGetIssuanceLicenseTemplate(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32& issuanceLicenseTemplateLength, StringBuilder issuanceLicenseTemplate);
    internal static int DRMClosePubHandle(UInt32 pubHandle);
    internal static int DRMAddRightWithUser(SafeRightsManagementPubHandle issuanceLicenseHandle, SafeRightsManagementPubHandle rightHandle, SafeRightsManagementPubHandle userHandle);
    internal static int DRMSetMetaData(SafeRightsManagementPubHandle issuanceLicenseHandle, string contentId, string contentIdType, string SkuId, string SkuIdType, string contentType, string contentName);
    internal static int DRMGetIssuanceLicenseInfo(SafeRightsManagementPubHandle issuanceLicenseHandle, SystemTime timeFrom, SystemTime timeUntil, UInt32 flags, UInt32& distributionPointNameLength, StringBuilder DistributionPointName, UInt32& distributionPointUriLength, StringBuilder DistributionPointUri, SafeRightsManagementPubHandle& ownerHandle, Boolean& officialFlag);
    internal static int DRMGetSecurityProvider(UInt32 flags, UInt32& typeLength, StringBuilder type, UInt32& pathLength, StringBuilder path);
    internal static int DRMDeleteLicense(SafeRightsManagementSessionHandle hSession, string wszLicenseId);
    internal static int DRMSetNameAndDescription(SafeRightsManagementPubHandle issuanceLicenseHandle, bool flagDelete, UInt32 localeId, string name, string description);
    internal static int DRMGetNameAndDescription(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32 uIndex, UInt32& localeId, UInt32& nameLength, StringBuilder name, UInt32& descriptionLength, StringBuilder description);
    internal static int DRMGetSignedIssuanceLicense(SafeRightsManagementEnvironmentHandle environmentHandle, SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32 flags, Byte[] symmetricKey, UInt32 symmetricKeyByteCount, string symmetricKeyType, string clientLicensorCertificate, CallbackDelegate pfnCallback, string Url, UInt32 context);
    internal static int DRMGetOwnerLicense(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32& ownerLicenseLength, StringBuilder ownerLicense);
    internal static int DRMCreateBoundLicense(SafeRightsManagementEnvironmentHandle environmentHandle, BoundLicenseParams boundLicenseParams, string licenseChain, SafeRightsManagementHandle& boundLicenseHandle, UInt32& errorLogHandle);
    internal static int DRMCreateEnablingBitsDecryptor(SafeRightsManagementHandle boundLicenseHandle, string right, UInt32 auxLibrary, string auxPlugin, SafeRightsManagementHandle& decryptorHandle);
    internal static int DRMCreateEnablingBitsEncryptor(SafeRightsManagementHandle boundLicenseHandle, string right, UInt32 auxLibrary, string auxPlugin, SafeRightsManagementHandle& encryptorHandle);
    internal static int DRMDecrypt(SafeRightsManagementHandle cryptoProvHandle, UInt32 position, UInt32 inputByteCount, Byte[] inputBuffer, UInt32& outputByteCount, Byte[] outputBuffer);
    internal static int DRMEncrypt(SafeRightsManagementHandle cryptoProvHandle, UInt32 position, UInt32 inputByteCount, Byte[] inputBuffer, UInt32& outputByteCount, Byte[] outputBuffer);
    internal static int DRMGetInfo(SafeRightsManagementHandle handle, string attributeType, UInt32& encodingType, UInt32& outputByteCount, Byte[] outputBuffer);
    internal static int DRMGetApplicationSpecificData(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32 index, UInt32& nameLength, StringBuilder name, UInt32& valueLength, StringBuilder value);
    internal static int DRMSetApplicationSpecificData(SafeRightsManagementPubHandle issuanceLicenseHandle, bool flagDelete, string name, string value);
    internal static int DRMGetIntervalTime(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32& days);
    internal static int DRMSetIntervalTime(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32 days);
    internal static int DRMGetRevocationPoint(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32& idLength, StringBuilder id, UInt32& idTypeLength, StringBuilder idType, UInt32& urlLength, StringBuilder url, SystemTime frequency, UInt32& nameLength, StringBuilder name, UInt32& publicKeyLength, StringBuilder publicKey);
    internal static int DRMSetRevocationPoint(SafeRightsManagementPubHandle issuanceLicenseHandle, bool flagDelete, string id, string idType, string url, SystemTime frequency, string name, string publicKey);
}
internal class MS.Internal.Security.RightsManagement.SafeRightsManagementEnvironmentHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeRightsManagementEnvironmentHandle(UInt32 handle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class MS.Internal.Security.RightsManagement.SafeRightsManagementHandle : SafeHandle {
    private static SafeRightsManagementHandle _invalidHandle;
    public bool IsInvalid { get; }
    internal static SafeRightsManagementHandle InvalidHandle { get; }
    internal SafeRightsManagementHandle(UInt32 handle);
    private static SafeRightsManagementHandle();
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    internal static SafeRightsManagementHandle get_InvalidHandle();
}
internal class MS.Internal.Security.RightsManagement.SafeRightsManagementPubHandle : SafeHandle {
    private static SafeRightsManagementPubHandle _invalidHandle;
    public bool IsInvalid { get; }
    internal static SafeRightsManagementPubHandle InvalidHandle { get; }
    internal SafeRightsManagementPubHandle(UInt32 handle);
    private static SafeRightsManagementPubHandle();
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    internal static SafeRightsManagementPubHandle get_InvalidHandle();
}
internal class MS.Internal.Security.RightsManagement.SafeRightsManagementQueryHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeRightsManagementQueryHandle(UInt32 handle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class MS.Internal.Security.RightsManagement.SafeRightsManagementSessionHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeRightsManagementSessionHandle(UInt32 handle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal enum MS.Internal.Security.RightsManagement.SecurityProviderType : Enum {
    public UInt32 value__;
    public static SecurityProviderType SoftwareSecRep;
}
internal enum MS.Internal.Security.RightsManagement.ServiceLocation : Enum {
    public UInt32 value__;
    public static ServiceLocation Internet;
    public static ServiceLocation Enterprise;
}
[FlagsAttribute]
internal enum MS.Internal.Security.RightsManagement.ServiceType : Enum {
    public UInt32 value__;
    public static ServiceType Activation;
    public static ServiceType Certification;
    public static ServiceType Publishing;
    public static ServiceType ClientLicensor;
}
[FlagsAttribute]
internal enum MS.Internal.Security.RightsManagement.SignIssuanceLicenseFlags : Enum {
    public UInt32 value__;
    public static SignIssuanceLicenseFlags Online;
    public static SignIssuanceLicenseFlags Offline;
    public static SignIssuanceLicenseFlags Cancel;
    public static SignIssuanceLicenseFlags ServerIssuanceLicense;
    public static SignIssuanceLicenseFlags AutoGenerateKey;
    public static SignIssuanceLicenseFlags OwnerLicenseNoPersist;
}
internal enum MS.Internal.Security.RightsManagement.SpecType : Enum {
    public UInt32 value__;
    public static SpecType Unknown;
    public static SpecType FileName;
}
internal enum MS.Internal.Security.RightsManagement.StatusMessage : Enum {
    public UInt32 value__;
    public static StatusMessage ActivateMachine;
    public static StatusMessage ActivateGroupIdentity;
    public static StatusMessage AcquireLicense;
    public static StatusMessage AcquireAdvisory;
    public static StatusMessage SignIssuanceLicense;
    public static StatusMessage AcquireClientLicensor;
}
internal class MS.Internal.Security.RightsManagement.SystemTime : object {
    private ushort Year;
    private ushort Month;
    private ushort DayOfWeek;
    private ushort Day;
    private ushort Hour;
    private ushort Minute;
    private ushort Second;
    private ushort Milliseconds;
    internal static UInt32 Size { get; }
    internal SystemTime(DateTime dateTime);
    internal SystemTime(Byte[] dataBuffer);
    internal static UInt32 get_Size();
    internal DateTime GetDateTime(DateTime defaultValue);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.SecurityCriticalData`1 : ValueType {
    private T _value;
    internal T Value { get; }
    internal SecurityCriticalData`1(T value);
    internal T get_Value();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.SecurityCriticalDataClass`1 : object {
    private T _value;
    internal T Value { get; }
    internal SecurityCriticalDataClass`1(T value);
    internal T get_Value();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.SecurityCriticalDataForSet`1 : ValueType {
    private T _value;
    internal T Value { get; internal set; }
    internal SecurityCriticalDataForSet`1(T value);
    internal T get_Value();
    internal void set_Value(T value);
}
[FriendAccessAllowedAttribute]
[FlagsAttribute]
internal enum MS.Internal.ShutDownEvents : Enum {
    public ushort value__;
    public static ShutDownEvents DomainUnload;
    public static ShutDownEvents ProcessExit;
    public static ShutDownEvents DispatcherShutdown;
    public static ShutDownEvents AppDomain;
    public static ShutDownEvents All;
}
[FriendAccessAllowedAttribute]
internal abstract class MS.Internal.ShutDownListener : WeakReference {
    private PrivateFlags _flags;
    private WeakReference _dispatcherWR;
    private int _inShutDown;
    internal ShutDownListener(object target);
    internal ShutDownListener(object target, ShutDownEvents events);
    internal abstract virtual void OnShutDown(object target, object sender, EventArgs e);
    internal void StopListening();
    private void HandleShutDown(object sender, EventArgs e);
}
internal abstract class MS.Internal.SystemCoreExtensionMethods : object {
    internal abstract virtual bool IsIDynamicMetaObjectProvider(object item);
    internal abstract virtual object NewDynamicPropertyAccessor(Type ownerType, string propertyName);
    internal abstract virtual object GetIndexerAccessor(int rank);
}
internal abstract class MS.Internal.SystemDataExtensionMethods : object {
    internal abstract virtual bool IsDataView(IBindingList list);
    internal abstract virtual bool IsDataRowView(object item);
    internal abstract virtual bool IsSqlNull(object value);
    internal abstract virtual bool IsSqlNullableType(Type type);
    internal abstract virtual bool IsDataSetCollectionProperty(PropertyDescriptor pd);
    internal abstract virtual object GetValue(object item, PropertyDescriptor pd, bool useFollowParent);
    internal abstract virtual bool DetermineWhetherDBNullIsValid(object item, string columnName, object arg);
}
internal abstract class MS.Internal.SystemDrawingExtensionMethods : object {
    internal abstract virtual bool IsBitmap(object data);
    internal abstract virtual bool IsImage(object data);
    internal abstract virtual bool IsMetafile(object data);
    internal abstract virtual IntPtr GetHandleFromMetafile(object data);
    internal abstract virtual object GetMetafileFromHemf(IntPtr hMetafile);
    internal abstract virtual object GetBitmap(object data);
    internal abstract virtual IntPtr GetHBitmap(object data, Int32& width, Int32& height);
    internal abstract virtual IntPtr GetHBitmapFromBitmap(object data);
    internal abstract virtual IntPtr ConvertMetafileToHBitmap(IntPtr handle);
    internal abstract virtual Stream GetCommentFromGifStream(Stream stream);
    internal abstract virtual void SaveMetafileToImageStream(MemoryStream metafileStream, Stream imageStream);
    internal abstract virtual object GetBitmapFromBitmapSource(object source);
}
internal abstract class MS.Internal.SystemXmlExtensionMethods : object {
    internal abstract virtual bool IsXmlNode(object item);
    internal abstract virtual bool IsXmlNamespaceManager(object item);
    internal abstract virtual bool TryGetValueFromXmlNode(object item, string name, Object& value);
    internal abstract virtual IComparer PrepareXmlComparer(IEnumerable collection, SortDescriptionCollection sort, CultureInfo culture);
    internal abstract virtual bool IsEmptyXmlDataCollection(object parent);
    internal abstract virtual string GetXmlTagName(object item, DependencyObject target);
    internal abstract virtual object FindXmlNodeWithInnerText(IEnumerable items, object innerText, Int32& index);
    internal abstract virtual object GetInnerText(object item);
}
internal abstract class MS.Internal.SystemXmlLinqExtensionMethods : object {
    internal abstract virtual bool IsXElement(object item);
    internal abstract virtual string GetXElementTagName(object item);
    internal abstract virtual bool IsXLinqCollectionProperty(PropertyDescriptor pd);
    internal abstract virtual bool IsXLinqNonIdempotentProperty(PropertyDescriptor pd);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.TextServicesLoader : object {
    private static int CLSIDLength;
    private static int LANGIDLength;
    private static InstallState s_servicesInstalled;
    private static object s_servicesInstalledLock;
    internal static bool ServicesInstalled { get; }
    private static TextServicesLoader();
    internal static ITfThreadMgr Load();
    internal static bool get_ServicesInstalled();
    private static bool TIPsWantToRun();
    private static EnableState SingleTIPWantsToRun(RegistryKey keyLocalMachine, string subKeyName, bool localMachine);
    private static EnableState IsLangidEnabled(RegistryKey key, string subKeyName, bool localMachine);
    private static EnableState IsAssemblyEnabled(RegistryKey key, string subKeyName, bool localMachine);
    private static EnableState IterateSubKeys(RegistryKey keyBase, string subKey, IterateHandler handler, bool localMachine);
}
internal class MS.Internal.Threading.CatchExceptionDelegate : MulticastDelegate {
    public CatchExceptionDelegate(object object, IntPtr method);
    public virtual bool Invoke(object source, Exception e, Delegate catchHandler);
    public virtual IAsyncResult BeginInvoke(object source, Exception e, Delegate catchHandler, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Threading.ExceptionFilterHelper : object {
    private InternalRealCallDelegate _internalRealCall;
    private FilterExceptionDelegate _filterException;
    private CatchExceptionDelegate _catchException;
    internal ExceptionFilterHelper(InternalRealCallDelegate internalRealCall, FilterExceptionDelegate filterException, CatchExceptionDelegate catchException);
    internal object TryCatchWhen(object source, Delegate method, object args, int numArgs, Delegate catchHandler);
}
internal class MS.Internal.Threading.FilterExceptionDelegate : MulticastDelegate {
    public FilterExceptionDelegate(object object, IntPtr method);
    public virtual bool Invoke(object source, Exception e);
    public virtual IAsyncResult BeginInvoke(object source, Exception e, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Threading.InternalRealCallDelegate : MulticastDelegate {
    public InternalRealCallDelegate(object object, IntPtr method);
    public virtual object Invoke(Delegate method, object args, int numArgs);
    public virtual IAsyncResult BeginInvoke(Delegate method, object args, int numArgs, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.TokenizerHelper : object {
    private char _quoteChar;
    private char _argSeparator;
    private string _str;
    private int _strLen;
    private int _charIndex;
    internal int _currentTokenIndex;
    internal int _currentTokenLength;
    private bool _foundSeparator;
    internal bool FoundSeparator { get; }
    internal TokenizerHelper(string str, IFormatProvider formatProvider);
    internal TokenizerHelper(string str, char quoteChar, char separator);
    private void Initialize(string str, char quoteChar, char separator);
    internal string GetCurrentToken();
    internal void LastTokenRequired();
    internal bool NextToken();
    internal string NextTokenRequired();
    internal string NextTokenRequired(bool allowQuotedToken);
    internal bool NextToken(bool allowQuotedToken);
    internal bool NextToken(bool allowQuotedToken, char separator);
    private void ScanToNextToken(char separator);
    internal static char GetNumericListSeparator(IFormatProvider provider);
    internal bool get_FoundSeparator();
}
internal static class MS.Internal.TraceDependencyProperty : object {
    private static AvTrace _avTrace;
    private static AvTraceDetails _ApplyTemplateContent;
    private static AvTraceDetails _Register;
    private static AvTraceDetails _UpdateEffectiveValueStart;
    private static AvTraceDetails _UpdateEffectiveValueStop;
    public static AvTraceDetails ApplyTemplateContent { get; }
    public static AvTraceDetails Register { get; }
    public static AvTraceDetails UpdateEffectiveValueStart { get; }
    public static AvTraceDetails UpdateEffectiveValueStop { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceDependencyProperty();
    public static AvTraceDetails get_ApplyTemplateContent();
    public static AvTraceDetails get_Register();
    public static AvTraceDetails get_UpdateEffectiveValueStart();
    public static AvTraceDetails get_UpdateEffectiveValueStop();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceFreezable : object {
    private static AvTrace _avTrace;
    private static AvTraceDetails _UnableToFreezeExpression;
    private static AvTraceDetails _UnableToFreezeDispatcherObjectWithThreadAffinity;
    private static AvTraceDetails _UnableToFreezeFreezableSubProperty;
    private static AvTraceDetails _UnableToFreezeAnimatedProperties;
    public static AvTraceDetails UnableToFreezeExpression { get; }
    public static AvTraceDetails UnableToFreezeDispatcherObjectWithThreadAffinity { get; }
    public static AvTraceDetails UnableToFreezeFreezableSubProperty { get; }
    public static AvTraceDetails UnableToFreezeAnimatedProperties { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceFreezable();
    public static AvTraceDetails get_UnableToFreezeExpression();
    public static AvTraceDetails get_UnableToFreezeDispatcherObjectWithThreadAffinity();
    public static AvTraceDetails get_UnableToFreezeFreezableSubProperty();
    public static AvTraceDetails get_UnableToFreezeAnimatedProperties();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceLevelStore : object {
    private static Dictionary`2<Key, PresentationTraceLevel> _dictionary;
    private static TraceLevelStore();
    internal static PresentationTraceLevel GetTraceLevel(object element);
    internal static void SetTraceLevel(object element, PresentationTraceLevel traceLevel);
}
internal static class MS.Internal.TraceNameScope : object {
    private static AvTrace _avTrace;
    private static AvTraceDetails _RegisterName;
    private static AvTraceDetails _UnregisterName;
    public static AvTraceDetails RegisterName { get; }
    public static AvTraceDetails UnregisterName { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceNameScope();
    public static AvTraceDetails get_RegisterName();
    public static AvTraceDetails get_UnregisterName();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
[FriendAccessAllowedAttribute]
internal enum MS.Internal.UncommonAssembly : Enum {
    public int value__;
    public static UncommonAssembly System_Drawing_Common;
    public static UncommonAssembly System_Private_Xml;
    public static UncommonAssembly System_Private_Xml_Linq;
    public static UncommonAssembly System_Data_Common;
    public static UncommonAssembly System_Linq_Expressions;
}
internal static class MS.Internal.Utilities : object {
    private static Version _osVersion;
    internal static bool IsOSVistaOrNewer { get; }
    internal static bool IsOSWindows7OrNewer { get; }
    internal static bool IsOSWindows8OrNewer { get; }
    internal static bool IsCompositionEnabled { get; }
    private static Utilities();
    internal static bool get_IsOSVistaOrNewer();
    internal static bool get_IsOSWindows7OrNewer();
    internal static bool get_IsOSWindows8OrNewer();
    internal static bool get_IsCompositionEnabled();
    internal static void SafeDispose(T& disposable);
    internal static void SafeRelease(T& comObject);
}
internal class MS.Internal.Utility.WeakReferenceKey`1 : object {
    private WeakReference _item;
    private int _hashCode;
    public T Item { get; }
    public WeakReferenceKey`1(T item);
    public T get_Item();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal static class MS.Internal.Verify : object {
    public static void IsApartmentState(ApartmentState requiredState);
    public static void IsNeitherNullNorEmpty(string value, string name);
    public static void IsNotNull(T obj, string name);
    public static void IsTrue(bool expression, string name, string message);
    public static void AreNotEqual(T actual, T notExpected, string parameterName, string message);
    public static void FileExists(string filePath, string parameterName);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.WeakEventTable : DispatcherObject {
    private Hashtable _managerTable;
    private Hashtable _dataTable;
    private Hashtable _eventNameTable;
    private ReaderWriterLockWrapper _lock;
    private int _cleanupRequests;
    private bool _cleanupEnabled;
    private CleanupHelper _cleanupHelper;
    private bool _inPurge;
    private List`1<EventKey> _toRemove;
    [ThreadStaticAttribute]
private static WeakEventTable _currentTable;
    internal static WeakEventTable CurrentWeakEventTable { get; }
    internal IDisposable ReadLock { get; }
    internal IDisposable WriteLock { get; }
    internal WeakEventManager Item { get; internal set; }
    internal WeakEventManager Item { get; internal set; }
    internal object Item { get; internal set; }
    internal bool IsCleanupEnabled { get; internal set; }
    internal static WeakEventTable get_CurrentWeakEventTable();
    internal IDisposable get_ReadLock();
    internal IDisposable get_WriteLock();
    internal WeakEventManager get_Item(Type managerType);
    internal void set_Item(Type managerType, WeakEventManager value);
    internal WeakEventManager get_Item(Type eventSourceType, string eventName);
    internal void set_Item(Type eventSourceType, string eventName, WeakEventManager value);
    internal object get_Item(WeakEventManager manager, object source);
    internal void set_Item(WeakEventManager manager, object source, object value);
    internal bool get_IsCleanupEnabled();
    internal void set_IsCleanupEnabled(bool value);
    internal void Remove(WeakEventManager manager, object source);
    internal void ScheduleCleanup();
    internal static bool Cleanup();
    private bool DoCleanup(bool forceCleanup);
    private object CleanupOperation(object arg);
    private bool Purge(bool purgeAll);
    private void OnShutDown();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.WeakReferenceList : CopyOnWriteList {
    public int Count { get; }
    public WeakReferenceList(object syncRoot);
    public WeakReferenceListEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool Contains(object item);
    public int get_Count();
    public virtual bool Add(object obj);
    public bool Add(object obj, bool skipFind);
    public virtual bool Remove(object obj);
    public bool Insert(int index, object obj);
    private int FindWeakReference(object obj);
    private void Purge();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.WeakReferenceListEnumerator : ValueType {
    private int _i;
    private ArrayList _List;
    private object _StrongReference;
    private object System.Collections.IEnumerator.Current { get; }
    public object Current { get; }
    public WeakReferenceListEnumerator(ArrayList List);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal static class MS.Internal.WindowsBase.BuildInfo : object {
    internal static string WCP_VERSION;
    internal static string WCP_VERSION_SUFFIX;
    internal static string MIL_VERSION_SUFFIX;
    internal static string WCP_PUBLIC_KEY_TOKEN;
    internal static string WCP_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_TOKEN;
    internal static string DirectWriteForwarder;
    internal static string PresentationCore;
    internal static string PresentationCFFRasterizer;
    internal static string PresentationFramework;
    internal static string PresentationUI;
    internal static string PresentationFrameworkLuna;
    internal static string PresentationFrameworkRoyale;
    internal static string PresentationFrameworkAero;
    internal static string PresentationFrameworkAero2;
    internal static string PresentationFrameworkAeroLite;
    internal static string PresentationFrameworkClassic;
    internal static string PresentationFrameworkSystemCore;
    internal static string PresentationFrameworkSystemData;
    internal static string PresentationFrameworkSystemDrawing;
    internal static string PresentationFrameworkSystemXml;
    internal static string PresentationFrameworkSystemXmlLinq;
    internal static string ReachFramework;
    internal static string SystemPrinting;
    internal static string SystemXaml;
    internal static string WindowsFormsIntegration;
    internal static string SystemWindowsPresentation;
    internal static string SystemWindowsControlsRibbon;
}
internal static class MS.Internal.WindowsBase.DllImport : object {
    internal static string PresentationNative;
    internal static string PresentationCFFRasterizerNative;
    internal static string MilCore;
    internal static string UIAutomationCore;
    internal static string Wininet;
    internal static string WindowsCodecs;
    internal static string WindowsCodecsExt;
    internal static string Mscms;
    internal static string PrntvPt;
    internal static string Ole32;
    internal static string User32;
    internal static string NInput;
    internal static string ApiSetWinRT;
    internal static string ApiSetWinRTString;
}
[AttributeUsageAttribute("5628")]
internal class MS.Internal.WindowsBase.FriendAccessAllowedAttribute : Attribute {
}
internal class MS.Internal.WindowsBase.GCNotificationToken : object {
    private WaitCallback callback;
    private object state;
    private GCNotificationToken(WaitCallback callback, object state);
    protected virtual override void Finalize();
    internal static void RegisterCallback(WaitCallback callback, object state);
}
internal enum MS.Internal.WindowsBase.Interop.OperatingSystemVersion : Enum {
    public int value__;
    public static OperatingSystemVersion WindowsXPSP2;
    public static OperatingSystemVersion WindowsXPSP3;
    public static OperatingSystemVersion WindowsVista;
    public static OperatingSystemVersion WindowsVistaSP1;
    public static OperatingSystemVersion WindowsVistaSP2;
    public static OperatingSystemVersion Windows7;
    public static OperatingSystemVersion Windows7SP1;
    public static OperatingSystemVersion Windows8;
    public static OperatingSystemVersion Windows8Point1;
    public static OperatingSystemVersion Windows10;
    public static OperatingSystemVersion Windows10TH2;
    public static OperatingSystemVersion Windows10RS1;
    public static OperatingSystemVersion Windows10RS2;
    public static OperatingSystemVersion Windows10RS3;
    public static OperatingSystemVersion Windows10RS4;
    public static OperatingSystemVersion Windows10RS5;
}
internal static class MS.Internal.WindowsBase.Interop.OSVersionHelper : object {
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS5OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS4OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS3OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10TH2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10TH1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows8Point1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows8OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows7SP1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows7OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsVistaSP2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsVistaSP1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsVistaOrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPSP3OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPSP2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPSP1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPOrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsServer>k__BackingField;
    internal static bool IsOsWindows10RS5OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS4OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS3OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS2OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS1OrGreater { get; internal set; }
    internal static bool IsOsWindows10TH2OrGreater { get; internal set; }
    internal static bool IsOsWindows10TH1OrGreater { get; internal set; }
    internal static bool IsOsWindows10OrGreater { get; internal set; }
    internal static bool IsOsWindows8Point1OrGreater { get; internal set; }
    internal static bool IsOsWindows8OrGreater { get; internal set; }
    internal static bool IsOsWindows7SP1OrGreater { get; internal set; }
    internal static bool IsOsWindows7OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaSP2OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaSP1OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaOrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP3OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP2OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP1OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPOrGreater { get; internal set; }
    internal static bool IsOsWindowsServer { get; internal set; }
    private static OSVersionHelper();
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS5OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS5OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS4OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS4OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS3OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS3OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10TH2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10TH2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10TH1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10TH1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows8Point1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows8Point1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows8OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows8OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows7SP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows7SP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows7OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows7OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaSP2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaSP2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaSP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaSP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaOrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaOrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP3OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP3OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPOrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPOrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsServer();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsServer(bool value);
    private static bool IsWindows10RS5OrGreater();
    private static bool IsWindows10RS4OrGreater();
    private static bool IsWindows10RS3OrGreater();
    private static bool IsWindows10RS2OrGreater();
    private static bool IsWindows10RS1OrGreater();
    private static bool IsWindows10TH2OrGreater();
    private static bool IsWindows10TH1OrGreater();
    private static bool IsWindows10OrGreater();
    private static bool IsWindows8Point1OrGreater();
    private static bool IsWindows8OrGreater();
    private static bool IsWindows7SP1OrGreater();
    private static bool IsWindows7OrGreater();
    private static bool IsWindowsVistaSP2OrGreater();
    private static bool IsWindowsVistaSP1OrGreater();
    private static bool IsWindowsVistaOrGreater();
    private static bool IsWindowsXPSP3OrGreater();
    private static bool IsWindowsXPSP2OrGreater();
    private static bool IsWindowsXPSP1OrGreater();
    private static bool IsWindowsXPOrGreater();
    private static bool IsWindowsServer();
    internal static bool IsOsVersionOrGreater(OperatingSystemVersion osVer);
    internal static OperatingSystemVersion GetOsVersion();
}
internal static class MS.Internal.WindowsBase.NativeMethodsSetLastError : object {
    private static string PresentationNativeDll;
    public static bool EnableWindow(HandleRef hWnd, bool enable);
    public static IntPtr GetAncestor(IntPtr hwnd, int gaFlags);
    public static int GetKeyboardLayoutList(int size, IntPtr[] hkls);
    public static IntPtr GetParent(HandleRef hWnd);
    public static IntPtr GetWindow(IntPtr hWnd, int uCmd);
    public static int GetWindowLong(HandleRef hWnd, int nIndex);
    public static int GetWindowLong(IntPtr hWnd, int nIndex);
    public static WndProc GetWindowLongWndProc(HandleRef hWnd, int nIndex);
    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex);
    public static IntPtr GetWindowLongPtr(HandleRef hWnd, int nIndex);
    public static WndProc GetWindowLongPtrWndProc(HandleRef hWnd, int nIndex);
    public static int GetWindowText(HandleRef hWnd, StringBuilder lpString, int nMaxCount);
    public static int GetWindowTextLength(HandleRef hWnd);
    public static int MapWindowPoints(HandleRef hWndFrom, HandleRef hWndTo, RECT& rect, int cPoints);
    public static IntPtr SetFocus(HandleRef hWnd);
    public static int SetWindowLong(HandleRef hWnd, int nIndex, int dwNewLong);
    public static int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);
    public static int SetWindowLongWndProc(HandleRef hWnd, int nIndex, WndProc dwNewLong);
    public static IntPtr SetWindowLongPtr(HandleRef hWnd, int nIndex, IntPtr dwNewLong);
    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    public static IntPtr SetWindowLongPtrWndProc(HandleRef hWnd, int nIndex, WndProc dwNewLong);
}
internal static class MS.Internal.WindowsBase.SafeSecurityHelper : object {
    private static Dictionary`2<object, AssemblyName> _assemblies;
    private static object syncObject;
    private static bool _isGCCallbackPending;
    private static WaitCallback _cleanupCollectedAssemblies;
    internal static string IMAGE;
    private static SafeSecurityHelper();
    internal static Assembly GetLoadedAssembly(AssemblyName assemblyName);
    private static AssemblyName GetAssemblyName(Assembly assembly);
    private static void CleanupCollectedAssemblies(object state);
    private static bool IsSameKeyToken(Byte[] reqKeyToken, Byte[] curKeyToken);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.WindowsBase.SecurityHelper : object {
    internal static void RunClassConstructor(Type t);
    internal static Exception GetExceptionForHR(int hr);
    internal static void ThrowExceptionForHR(int hr);
    internal static int GetHRForException(Exception exception);
    internal static bool AreStringTypesEqual(string m1, string m2);
    internal static object ReadRegistryValue(RegistryKey baseRegistryKey, string keyName, string valueName);
}
internal static class MS.Internal.WindowsBase.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string WPF_UILanguage { get; }
    internal static string Rect_CannotModifyEmptyRect { get; }
    internal static string Rect_CannotCallMethod { get; }
    internal static string Size_WidthAndHeightCannotBeNegative { get; }
    internal static string Size_WidthCannotBeNegative { get; }
    internal static string Size_HeightCannotBeNegative { get; }
    internal static string Size_CannotModifyEmptySize { get; }
    internal static string Transform_NotInvertible { get; }
    internal static string General_Expected_Type { get; }
    internal static string ReferenceIsNull { get; }
    internal static string ParameterMustBeBetween { get; }
    internal static string Freezable_UnregisteredHandler { get; }
    internal static string Freezable_AttemptToUseInnerValueWithDifferentThread { get; }
    internal static string Freezable_CantFreeze { get; }
    internal static string Freezable_NotAContext { get; }
    internal static string FrugalList_TargetMapCannotHoldAllData { get; }
    internal static string FrugalList_CannotPromoteBeyondArray { get; }
    internal static string FrugalMap_TargetMapCannotHoldAllData { get; }
    internal static string FrugalMap_CannotPromoteBeyondHashtable { get; }
    internal static string Unsupported_Key { get; }
    internal static string InvalidPriority { get; }
    internal static string InvalidPriorityRangeOrder { get; }
    internal static string DispatcherHasShutdown { get; }
    internal static string ThreadMayNotWaitOnOperationsAlreadyExecutingOnTheSameThread { get; }
    internal static string VerifyAccess { get; }
    internal static string MismatchedDispatchers { get; }
    internal static string DispatcherProcessingDisabledButStillPumping { get; }
    internal static string DispatcherProcessingDisabled { get; }
    internal static string DispatcherPriorityAwaiterInvalid { get; }
    internal static string DispatcherYieldNoAvailableDispatcher { get; }
    internal static string DispatcherRequestProcessingFailed { get; }
    internal static string ExceptionFilterCodeNotPresent { get; }
    internal static string Unsupported_Modifier { get; }
    internal static string TimeSpanPeriodOutOfRange_TooSmall { get; }
    internal static string TimeSpanPeriodOutOfRange_TooLarge { get; }
    internal static string ClearOnReadOnlyObjectNotAllowed { get; }
    internal static string DefaultValueAutoAssignFailed { get; }
    internal static string DefaultValueMayNotBeExpression { get; }
    internal static string DefaultValueMayNotBeUnset { get; }
    internal static string DefaultValueMustBeFreeThreaded { get; }
    internal static string DefaultValuePropertyTypeMismatch { get; }
    internal static string DefaultValueInvalid { get; }
    internal static string DTypeNotSupportForSystemType { get; }
    internal static string InvalidPropertyValue { get; }
    internal static string LocalValueEnumerationOutOfBounds { get; }
    internal static string LocalValueEnumerationReset { get; }
    internal static string LocalValueEnumerationInvalidated { get; }
    internal static string MissingCreateDefaultValue { get; }
    internal static string OverridingMetadataDoesNotMatchBaseMetadataType { get; }
    internal static string PropertyAlreadyRegistered { get; }
    internal static string PropertyNotReadOnly { get; }
    internal static string ReadOnlyChangeNotAllowed { get; }
    internal static string ReadOnlyKeyNotAuthorized { get; }
    internal static string ReadOnlyOverrideNotAllowed { get; }
    internal static string ReadOnlyOverrideKeyNotAuthorized { get; }
    internal static string ReadOnlyDesignerCoersionNotAllowed { get; }
    internal static string SetOnReadOnlyObjectNotAllowed { get; }
    internal static string ShareableExpressionsCannotChangeSources { get; }
    internal static string SharingNonSharableExpression { get; }
    internal static string SpecialMethodMustBePublic { get; }
    internal static string SourcesMustBeInSameThread { get; }
    internal static string SourceChangeExpressionMismatch { get; }
    internal static string TooManyDependencyProperties { get; }
    internal static string TypeMetadataAlreadyInUse { get; }
    internal static string TypeMetadataAlreadyRegistered { get; }
    internal static string TypeMustBeDependencyObjectDerived { get; }
    internal static string UnknownExpressionMode { get; }
    internal static string BufferTooSmall { get; }
    internal static string BufferOffsetNegative { get; }
    internal static string CompoundFilePathNullEmpty { get; }
    internal static string CanNotCreateContainerOnReadOnlyStream { get; }
    internal static string CanNotCreateAsReadOnly { get; }
    internal static string CanNotCreateInReadOnly { get; }
    internal static string CanNotCreateStorageRootOnNonReadableStream { get; }
    internal static string CanNotDelete { get; }
    internal static string CanNotDeleteAccessDenied { get; }
    internal static string CanNotCreateAccessDenied { get; }
    internal static string CanNotDeleteInReadOnly { get; }
    internal static string CanNotDeleteNonEmptyStorage { get; }
    internal static string CanNotDeleteRoot { get; }
    internal static string CanNotOnNonExistStorage { get; }
    internal static string CanNotOpenStorage { get; }
    internal static string ContainerNotFound { get; }
    internal static string ContainerCanNotOpen { get; }
    internal static string CreateModeMustBeCreateOrOpen { get; }
    internal static string CFAPIFailure { get; }
    internal static string DataSpaceLabelInUse { get; }
    internal static string DataSpaceLabelInvalidEmpty { get; }
    internal static string DataSpaceLabelUndefined { get; }
    internal static string DataSpaceManagerDisposed { get; }
    internal static string DataSpaceMapEntryInvalid { get; }
    internal static string FileAccessInvalid { get; }
    internal static string FileAlreadyExists { get; }
    internal static string FileModeUnsupported { get; }
    internal static string FileModeInvalid { get; }
    internal static string FileShareUnsupported { get; }
    internal static string FileShareInvalid { get; }
    internal static string ILockBytesStreamMustSeek { get; }
    internal static string InvalidArgumentValue { get; }
    internal static string InvalidCondition01 { get; }
    internal static string InvalidStringFormat { get; }
    internal static string InvalidTableType { get; }
    internal static string MoveToDestNotExist { get; }
    internal static string MoveToNYI { get; }
    internal static string NameAlreadyInUse { get; }
    internal static string NameCanNotHaveDelimiter { get; }
    internal static string NamedAPIFailure { get; }
    internal static string NameTableCorruptStg { get; }
    internal static string NameTableCorruptMem { get; }
    internal static string NameTableVersionMismatchRead { get; }
    internal static string NameTableVersionMismatchWrite { get; }
    internal static string NYIDefault { get; }
    internal static string PathHasEmptyElement { get; }
    internal static string ReadCountNegative { get; }
    internal static string SeekFailed { get; }
    internal static string SeekNegative { get; }
    internal static string SeekOriginInvalid { get; }
    internal static string StorageFlagsUnsupported { get; }
    internal static string StorageAlreadyExist { get; }
    internal static string StreamAlreadyExist { get; }
    internal static string StorageInfoDisposed { get; }
    internal static string StorageNotExist { get; }
    internal static string StorageRootDisposed { get; }
    internal static string StreamInfoDisposed { get; }
    internal static string StreamLengthNegative { get; }
    internal static string StreamNotExist { get; }
    internal static string StreamNameNotValid { get; }
    internal static string StreamTimeStampNotImplemented { get; }
    internal static string StringCanNotBeReservedName { get; }
    internal static string TimeStampNotAvailable { get; }
    internal static string TransformLabelInUse { get; }
    internal static string TransformLabelUndefined { get; }
    internal static string TransformObjectConstructorParam { get; }
    internal static string TransformObjectImplementIDataTransform { get; }
    internal static string TransformObjectInitFailed { get; }
    internal static string TransformTypeUnsupported { get; }
    internal static string TransformStackValid { get; }
    internal static string UnableToCreateOnStream { get; }
    internal static string UnableToCreateStorage { get; }
    internal static string UnableToCreateStream { get; }
    internal static string UnableToOpenStream { get; }
    internal static string UnsupportedTypeEncounteredWhenBuildingStgEnum { get; }
    internal static string WriteFailure { get; }
    internal static string WriteOnlyUnsupported { get; }
    internal static string WriteSizeNegative { get; }
    internal static string CFM_CorruptMetadataStream { get; }
    internal static string CFM_CorruptMetadataStream_Root { get; }
    internal static string CFM_CorruptMetadataStream_DuplicateKey { get; }
    internal static string CFM_ObjectMustBeCompoundFileMetadataKey { get; }
    internal static string CFM_ReadOnlyContainer { get; }
    internal static string CFM_TypeTableFormat { get; }
    internal static string CFM_UnicodeCharInvalid { get; }
    internal static string CFM_ValueMustBeString { get; }
    internal static string CFM_XMLCharInvalid { get; }
    internal static string CanNotCompareDiffTypes { get; }
    internal static string CFRCorrupt { get; }
    internal static string CFRCorruptMultiStream { get; }
    internal static string CFRCorruptStgFollowStm { get; }
    internal static string DelimiterLeading { get; }
    internal static string DelimiterTrailing { get; }
    internal static string OffsetNegative { get; }
    internal static string UnknownReferenceComponentType { get; }
    internal static string UnknownReferenceSerialize { get; }
    internal static string MalformedCompoundFilePath { get; }
    internal static string CannotMakeStreamLengthNegative { get; }
    internal static string CorruptStream { get; }
    internal static string LengthNotSupported { get; }
    internal static string ReadBufferTooSmall { get; }
    internal static string ReadNotSupported { get; }
    internal static string SeekNotSupported { get; }
    internal static string SetLengthNotSupported { get; }
    internal static string SetPositionNotSupported { get; }
    internal static string StreamPositionNegative { get; }
    internal static string TransformParametersFixed { get; }
    internal static string WriteBufferTooSmall { get; }
    internal static string WriteCountNegative { get; }
    internal static string WriteNotSupported { get; }
    internal static string ZLibVersionError { get; }
    internal static string ExpectedVersionPairObject { get; }
    internal static string VersionNumberComponentNegative { get; }
    internal static string ZeroLengthFeatureID { get; }
    internal static string VersionStreamMissing { get; }
    internal static string VersionUpdateFailure { get; }
    internal static string CannotRemoveSignatureFromReadOnlyFile { get; }
    internal static string CannotSignReadOnlyFile { get; }
    internal static string DigSigCannotLocateCertificate { get; }
    internal static string DigSigDuplicateCertificate { get; }
    internal static string CertSelectionDialogTitle { get; }
    internal static string CertSelectionDialogMessage { get; }
    internal static string DuplicateSignature { get; }
    internal static string XmlSignatureParseError { get; }
    internal static string RequiredXmlAttributeMissing { get; }
    internal static string UnexpectedXmlTag { get; }
    internal static string RequiredTagNotFound { get; }
    internal static string PackageSignatureObjectTagRequired { get; }
    internal static string PackageSignatureReferenceTagRequired { get; }
    internal static string MoreThanOnePackageSpecificReference { get; }
    internal static string InvalidUriAttribute { get; }
    internal static string NoCounterSignUnsignedContainer { get; }
    internal static string BadSignatureTimeFormatString { get; }
    internal static string PackageSignatureCorruption { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string RelationshipTransformNotFollowedByCanonicalizationTransform { get; }
    internal static string MultipleRelationshipTransformsFound { get; }
    internal static string UnsupportedTransformAlgorithm { get; }
    internal static string UnsupportedCanonicalizationMethod { get; }
    internal static string HashAlgorithmMustBeReusable { get; }
    internal static string PartReferenceUriMalformed { get; }
    internal static string SignatureOriginNotFound { get; }
    internal static string MultipleSignatureOrigins { get; }
    internal static string NothingToSign { get; }
    internal static string EmptySignatureId { get; }
    internal static string SignatureDeleted { get; }
    internal static string SignaturePackageObjectTagMustBeUnique { get; }
    internal static string PackageSpecificReferenceTagMustBeUnique { get; }
    internal static string SignatureObjectIdMustBeUnique { get; }
    internal static string CanOnlyCounterSignSignatureParts { get; }
    internal static string CertificatePartContentTypeMismatch { get; }
    internal static string CertificateKeyTypeNotSupported { get; }
    internal static string PartToSignMissing { get; }
    internal static string DuplicateObjectId { get; }
    internal static string CallbackParameterInvalid { get; }
    internal static string CannotChangePublishLicense { get; }
    internal static string CannotChangeCryptoProvider { get; }
    internal static string ExcessiveLengthPrefix { get; }
    internal static string GetOlePropertyFailed { get; }
    internal static string InvalidAuthenticationTypeString { get; }
    internal static string InvalidDocumentPropertyType { get; }
    internal static string InvalidDocumentPropertyVariantType { get; }
    internal static string InvalidTypePrefixedUserName { get; }
    internal static string InvalidTransformFeatureName { get; }
    internal static string PackageNotFound { get; }
    internal static string NoPublishLicenseStream { get; }
    internal static string NoUseLicenseStorage { get; }
    internal static string ReaderVersionError { get; }
    internal static string PublishLicenseStreamCorrupt { get; }
    internal static string PublishLicenseNotFound { get; }
    internal static string RightsManagementEncryptionTransformNotFound { get; }
    internal static string MultipleRightsManagementEncryptionTransformFound { get; }
    internal static string StreamNeedsReadWriteAccess { get; }
    internal static string CryptoProviderCanNotDecrypt { get; }
    internal static string CryptoProviderCanNotMergeBlocks { get; }
    internal static string EncryptedPackageEnvelopeDisposed { get; }
    internal static string CryptoProviderDisposed { get; }
    internal static string UpdaterVersionError { get; }
    internal static string DictionaryIsReadOnly { get; }
    internal static string CryptoProviderIsNotReady { get; }
    internal static string UseLicenseStreamCorrupt { get; }
    internal static string EncryptedDataStreamCorrupt { get; }
    internal static string UnknownDocumentProperty { get; }
    internal static string WrongDocumentPropertyVariantType { get; }
    internal static string UserIsNotActivated { get; }
    internal static string UserHasNoClientLicensorCert { get; }
    internal static string EncryptionRightIsNotGranted { get; }
    internal static string DecryptionRightIsNotGranted { get; }
    internal static string NoPrivilegesForPublishLicenseDecryption { get; }
    internal static string InvalidPublishLicense { get; }
    internal static string PublishLicenseStreamHeaderTooLong { get; }
    internal static string OnlyPassportOrWindowsAuthenticatedUsersAreAllowed { get; }
    internal static string RmExceptionGenericMessage { get; }
    internal static string RmExceptionInvalidLicense { get; }
    internal static string RmExceptionInfoNotInLicense { get; }
    internal static string RmExceptionInvalidLicenseSignature { get; }
    internal static string RmExceptionEncryptionNotPermitted { get; }
    internal static string RmExceptionRightNotGranted { get; }
    internal static string RmExceptionInvalidVersion { get; }
    internal static string RmExceptionInvalidEncodingType { get; }
    internal static string RmExceptionInvalidNumericalValue { get; }
    internal static string RmExceptionInvalidAlgorithmType { get; }
    internal static string RmExceptionEnvironmentNotLoaded { get; }
    internal static string RmExceptionEnvironmentCannotLoad { get; }
    internal static string RmExceptionTooManyLoadedEnvironments { get; }
    internal static string RmExceptionIncompatibleObjects { get; }
    internal static string RmExceptionLibraryFail { get; }
    internal static string RmExceptionEnablingPrincipalFailure { get; }
    internal static string RmExceptionInfoNotPresent { get; }
    internal static string RmExceptionBadGetInfoQuery { get; }
    internal static string RmExceptionKeyTypeUnsupported { get; }
    internal static string RmExceptionCryptoOperationUnsupported { get; }
    internal static string RmExceptionClockRollbackDetected { get; }
    internal static string RmExceptionQueryReportsNoResults { get; }
    internal static string RmExceptionUnexpectedException { get; }
    internal static string RmExceptionBindValidityTimeViolated { get; }
    internal static string RmExceptionBrokenCertChain { get; }
    internal static string RmExceptionBindPolicyViolation { get; }
    internal static string RmExceptionManifestPolicyViolation { get; }
    internal static string RmExceptionBindRevokedLicense { get; }
    internal static string RmExceptionBindRevokedIssuer { get; }
    internal static string RmExceptionBindRevokedPrincipal { get; }
    internal static string RmExceptionBindRevokedResource { get; }
    internal static string RmExceptionBindRevokedModule { get; }
    internal static string RmExceptionBindContentNotInEndUseLicense { get; }
    internal static string RmExceptionBindAccessPrincipalNotEnabling { get; }
    internal static string RmExceptionBindAccessUnsatisfied { get; }
    internal static string RmExceptionBindIndicatedPrincipalMissing { get; }
    internal static string RmExceptionBindMachineNotFoundInGroupIdentity { get; }
    internal static string RmExceptionLibraryUnsupportedPlugIn { get; }
    internal static string RmExceptionBindRevocationListStale { get; }
    internal static string RmExceptionBindNoApplicableRevocationList { get; }
    internal static string RmExceptionInvalidHandle { get; }
    internal static string RmExceptionBindIntervalTimeViolated { get; }
    internal static string RmExceptionBindNoSatisfiedRightsGroup { get; }
    internal static string RmExceptionBindSpecifiedWorkMissing { get; }
    internal static string RmExceptionNoMoreData { get; }
    internal static string RmExceptionLicenseAcquisitionFailed { get; }
    internal static string RmExceptionIdMismatch { get; }
    internal static string RmExceptionTooManyCertificates { get; }
    internal static string RmExceptionNoDistributionPointUrlFound { get; }
    internal static string RmExceptionAlreadyInProgress { get; }
    internal static string RmExceptionGroupIdentityNotSet { get; }
    internal static string RmExceptionRecordNotFound { get; }
    internal static string RmExceptionNoConnect { get; }
    internal static string RmExceptionNoLicense { get; }
    internal static string RmExceptionNeedsMachineActivation { get; }
    internal static string RmExceptionNeedsGroupIdentityActivation { get; }
    internal static string RmExceptionActivationFailed { get; }
    internal static string RmExceptionAborted { get; }
    internal static string RmExceptionOutOfQuota { get; }
    internal static string RmExceptionAuthenticationFailed { get; }
    internal static string RmExceptionServerError { get; }
    internal static string RmExceptionInstallationFailed { get; }
    internal static string RmExceptionHidCorrupted { get; }
    internal static string RmExceptionInvalidServerResponse { get; }
    internal static string RmExceptionServiceNotFound { get; }
    internal static string RmExceptionUseDefault { get; }
    internal static string RmExceptionServerNotFound { get; }
    internal static string RmExceptionInvalidEmail { get; }
    internal static string RmExceptionValidityTimeViolation { get; }
    internal static string RmExceptionOutdatedModule { get; }
    internal static string RmExceptionServiceMoved { get; }
    internal static string RmExceptionServiceGone { get; }
    internal static string RmExceptionAdEntryNotFound { get; }
    internal static string RmExceptionNotAChain { get; }
    internal static string RmExceptionRequestDenied { get; }
    internal static string RmExceptionNotSet { get; }
    internal static string RmExceptionMetadataNotSet { get; }
    internal static string RmExceptionRevocationInfoNotSet { get; }
    internal static string RmExceptionInvalidTimeInfo { get; }
    internal static string RmExceptionRightNotSet { get; }
    internal static string RmExceptionLicenseBindingToWindowsIdentityFailed { get; }
    internal static string RmExceptionInvalidIssuanceLicenseTemplate { get; }
    internal static string RmExceptionInvalidKeyLength { get; }
    internal static string RmExceptionExpiredOfficialIssuanceLicenseTemplate { get; }
    internal static string RmExceptionInvalidClientLicensorCertificate { get; }
    internal static string RmExceptionHidInvalid { get; }
    internal static string RmExceptionEmailNotVerified { get; }
    internal static string RmExceptionDebuggerDetected { get; }
    internal static string RmExceptionInvalidLockboxType { get; }
    internal static string RmExceptionInvalidLockboxPath { get; }
    internal static string RmExceptionInvalidRegistryPath { get; }
    internal static string RmExceptionNoAesCryptoProvider { get; }
    internal static string RmExceptionGlobalOptionAlreadySet { get; }
    internal static string RmExceptionOwnerLicenseNotFound { get; }
    internal static string ZipZeroSizeFileIsNotValidArchive { get; }
    internal static string CanNotWriteInReadOnlyMode { get; }
    internal static string CanNotReadInWriteOnlyMode { get; }
    internal static string CanNotReadWriteInReadOnlyWriteOnlyMode { get; }
    internal static string AttemptedToCreateDuplicateFileName { get; }
    internal static string FileDoesNotExists { get; }
    internal static string TruncateAppendModesNotSupported { get; }
    internal static string OnlyFileShareReadAndFileShareNoneSupported { get; }
    internal static string CanNotReadDataFromStreamWhichDoesNotSupportReading { get; }
    internal static string CanNotWriteDataToStreamWhichDoesNotSupportWriting { get; }
    internal static string CanNotOperateOnStreamWhichDoesNotSupportSeeking { get; }
    internal static string UnsupportedCombinationOfModeAccessShareStreaming { get; }
    internal static string CorruptedData { get; }
    internal static string NotSupportedMultiDisk { get; }
    internal static string ZipArchiveDisposed { get; }
    internal static string ZipFileItemDisposed { get; }
    internal static string NotSupportedVersionNeededToExtract { get; }
    internal static string Zip64StructuresTooLarge { get; }
    internal static string ZipNotSupportedEncryptedArchive { get; }
    internal static string ZipNotSupportedSignedArchive { get; }
    internal static string ZipNotSupportedCompressionMethod { get; }
    internal static string CompressLengthMismatch { get; }
    internal static string CreateNewOnNonEmptyStream { get; }
    internal static string PartDoesNotExist { get; }
    internal static string PartAlreadyExists { get; }
    internal static string PartNamePrefixExists { get; }
    internal static string IncompatibleModeOrAccess { get; }
    internal static string URIShouldNotBeAbsolute { get; }
    internal static string UriShouldBeAbsolute { get; }
    internal static string ContainerAndPartModeIncompatible { get; }
    internal static string UnsupportedCombinationOfModeAccess { get; }
    internal static string NullStreamReturned { get; }
    internal static string ObjectDisposed { get; }
    internal static string ReadOnlyStream { get; }
    internal static string WriteOnlyStream { get; }
    internal static string ParentContainerClosed { get; }
    internal static string PackagePartDeleted { get; }
    internal static string RelationshipToRelationshipIllegal { get; }
    internal static string RelationshipPartsCannotHaveRelationships { get; }
    internal static string RelationshipPartIncorrectContentType { get; }
    internal static string PackageRelationshipDoesNotExist { get; }
    internal static string PackagePartRelationshipDoesNotExist { get; }
    internal static string RelationshipTargetMustBeRelative { get; }
    internal static string RequiredRelationshipAttributeMissing { get; }
    internal static string RelationshipTagDoesntMatchSchema { get; }
    internal static string RelationshipsTagHasExtraAttributes { get; }
    internal static string UnknownTagEncountered { get; }
    internal static string ExpectedRelationshipsElementTag { get; }
    internal static string InvalidXmlBaseAttributePresent { get; }
    internal static string NotAUniqueRelationshipId { get; }
    internal static string NotAValidXmlIdString { get; }
    internal static string InvalidValueForTheAttribute { get; }
    internal static string InvalidRelationshipType { get; }
    internal static string PartUriShouldStartWithForwardSlash { get; }
    internal static string PartUriShouldNotEndWithForwardSlash { get; }
    internal static string UriShouldBePackScheme { get; }
    internal static string PartUriIsEmpty { get; }
    internal static string InvalidPartUri { get; }
    internal static string RelationshipPartUriNotExpected { get; }
    internal static string RelationshipPartUriExpected { get; }
    internal static string NotAValidRelationshipPartUri { get; }
    internal static string FragmentMustStartWithHash { get; }
    internal static string PartUriCannotHaveAFragment { get; }
    internal static string PartUriShouldNotStartWithTwoForwardSlashes { get; }
    internal static string InnerPackageUriHasFragment { get; }
    internal static string StreamObjectDisposed { get; }
    internal static string NullContentTypeProvided { get; }
    internal static string GetContentTypeCoreNotImplemented { get; }
    internal static string RequiredAttributeMissing { get; }
    internal static string RequiredAttributeEmpty { get; }
    internal static string TypesTagHasExtraAttributes { get; }
    internal static string TypesElementExpected { get; }
    internal static string TypesXmlDoesNotMatchSchema { get; }
    internal static string DefaultTagDoesNotMatchSchema { get; }
    internal static string OverrideTagDoesNotMatchSchema { get; }
    internal static string ElementIsNotEmptyElement { get; }
    internal static string BadPackageFormat { get; }
    internal static string StreamingModeNotSupportedForConsumption { get; }
    internal static string StreamingPackageProductionImpliesWriteOnlyAccess { get; }
    internal static string StreamingPackageProductionRequiresSingleWriter { get; }
    internal static string MethodAvailableOnlyInStreamingCreation { get; }
    internal static string OperationIsNotSupportedInStreamingProduction { get; }
    internal static string OnlyWriteOperationsAreSupportedInStreamingCreation { get; }
    internal static string OperationViolatesWriteOnceSemantics { get; }
    internal static string OnlyStreamingProductionIsSupported { get; }
    internal static string IOBufferOverflow { get; }
    internal static string StreamDoesNotSupportWrite { get; }
    internal static string MoreThanOneMetadataRelationships { get; }
    internal static string NoExternalTargetForMetadataRelationship { get; }
    internal static string CorePropertiesElementExpected { get; }
    internal static string NoStructuredContentInsideProperties { get; }
    internal static string UnknownNamespaceInCorePropertiesPart { get; }
    internal static string InvalidPropertyNameInCorePropertiesPart { get; }
    internal static string PropertyStartTagExpected { get; }
    internal static string XsdDateTimeExpected { get; }
    internal static string DanglingMetadataRelationship { get; }
    internal static string WrongContentTypeForPropertyPart { get; }
    internal static string PropertyWrongNumbOfAttribsDefinedOn { get; }
    internal static string UnknownDCDateTimeXsiType { get; }
    internal static string DuplicateCorePropertyName { get; }
    internal static string StorageBasedPackagePropertiesDiposed { get; }
    internal static string EncodingNotSupported { get; }
    internal static string DuplicatePiecesFound { get; }
    internal static string PieceDoesNotExist { get; }
    internal static string ServiceTypeAlreadyAdded { get; }
    internal static string ParserAttributeArgsHigh { get; }
    internal static string ParserAttributeArgsLow { get; }
    internal static string ParserAssemblyLoadVersionMismatch { get; }
    internal static string ToStringNull { get; }
    internal static string ConvertToException { get; }
    internal static string ConvertFromException { get; }
    internal static string SortDescriptionPropertyNameCannotBeEmpty { get; }
    internal static string CannotChangeAfterSealed { get; }
    internal static string BadPropertyForGroup { get; }
    internal static string CurrentChangingCannotBeCanceled { get; }
    internal static string NotSupported_ReadOnlyCollection { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Argument_InvalidArrayType { get; }
    internal static string ReachOutOfRange { get; }
    internal static string InvalidPermissionState { get; }
    internal static string TargetNotWebBrowserPermissionLevel { get; }
    internal static string TargetNotMediaPermissionLevel { get; }
    internal static string BadXml { get; }
    internal static string InvalidPermissionLevel { get; }
    internal static string XCRChoiceOnlyInAC { get; }
    internal static string XCRChoiceAfterFallback { get; }
    internal static string XCRRequiresAttribNotFound { get; }
    internal static string XCRInvalidRequiresAttribute { get; }
    internal static string XCRFallbackOnlyInAC { get; }
    internal static string XCRChoiceNotFound { get; }
    internal static string XCRMultipleFallbackFound { get; }
    internal static string XCRInvalidAttribInElement { get; }
    internal static string XCRUnknownCompatElement { get; }
    internal static string XCRInvalidACChild { get; }
    internal static string XCRInvalidFormat { get; }
    internal static string XCRUndefinedPrefix { get; }
    internal static string XCRUnknownCompatAttrib { get; }
    internal static string XCRNSProcessContentNotIgnorable { get; }
    internal static string XCRDuplicateProcessContent { get; }
    internal static string XCRInvalidProcessContent { get; }
    internal static string XCRDuplicateWildcardProcessContent { get; }
    internal static string XCRMustUnderstandFailed { get; }
    internal static string XCRNSPreserveNotIgnorable { get; }
    internal static string XCRDuplicatePreserve { get; }
    internal static string XCRInvalidPreserve { get; }
    internal static string XCRDuplicateWildcardPreserve { get; }
    internal static string XCRInvalidXMLName { get; }
    internal static string XCRCompatCycle { get; }
    internal static string EventNotFound { get; }
    internal static string ListenerDidNotHandleEvent { get; }
    internal static string ListenerDidNotHandleEventDetail { get; }
    internal static string NoMulticastHandlers { get; }
    internal static string InvariantFailure { get; }
    internal static string ContentTypeCannotHaveLeadingTrailingLWS { get; }
    internal static string InvalidTypeSubType { get; }
    internal static string ExpectingParameterValuePairs { get; }
    internal static string InvalidParameterValuePair { get; }
    internal static string InvalidToken { get; }
    internal static string InvalidParameterValue { get; }
    internal static string InvalidLinearWhiteSpaceCharacter { get; }
    internal static string ExpectingSemicolon { get; }
    internal static string HwndSubclassMultipleAttach { get; }
    internal static string UnableToLocateResource { get; }
    internal static string SplashScreenIsLoading { get; }
    internal static string NameScopeNameNotEmptyString { get; }
    internal static string NameScopeNameNotFound { get; }
    internal static string NameScopeDuplicateNamesNotAllowed { get; }
    internal static string NameScopeNotFound { get; }
    internal static string NameScopeInvalidIdentifierName { get; }
    internal static string NoDependencyProperty { get; }
    internal static string MarkupExtensionArrayType { get; }
    internal static string MarkupExtensionArrayBadType { get; }
    internal static string MarkupExtensionNoContext { get; }
    internal static string MarkupExtensionBadStatic { get; }
    internal static string MarkupExtensionStaticMember { get; }
    internal static string MarkupExtensionTypeName { get; }
    internal static string MarkupExtensionTypeNameBad { get; }
    internal static string MustBeOfType { get; }
    internal static string Verify_ApartmentState { get; }
    internal static string Verify_NeitherNullNorEmpty { get; }
    internal static string Verify_AreNotEqual { get; }
    internal static string Verify_FileExists { get; }
    internal static string InvalidEvent { get; }
    internal static string CompatibilityPreferencesSealed { get; }
    internal static string CombinationOfAccessibilitySwitchesNotSupported { get; }
    internal static string AccessibilitySwitchDependencyNotSatisfied { get; }
    internal static string TokenizerHelperExtraDataEncountered { get; }
    internal static string TokenizerHelperPrematureStringTermination { get; }
    internal static string TokenizerHelperMissingEndQuote { get; }
    internal static string TokenizerHelperEmptyToken { get; }
    internal static string Enumerator_VerifyContext { get; }
    internal static string InvalidPermissionStateValue { get; }
    internal static string InvalidPermissionType { get; }
    internal static string StringEmpty { get; }
    internal static string ParameterCannotBeNegative { get; }
    internal static string Freezable_CantBeFrozen { get; }
    internal static string TypeMetadataCannotChangeAfterUse { get; }
    internal static string Enum_Invalid { get; }
    internal static string CannotConvertStringToType { get; }
    internal static string CannotModifyReadOnlyContainer { get; }
    internal static string CannotRetrievePartsOfWriteOnlyContainer { get; }
    internal static string FileFormatExceptionWithFileName { get; }
    internal static string FileFormatException { get; }
    internal static string Cryptography_InvalidHandle { get; }
    internal static string WpfDllConsistencyErrorData { get; }
    internal static string WpfDllConsistencyErrorHeader { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    public static string Get(string name);
    public static string Get(string name, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_WPF_UILanguage();
    internal static string get_Rect_CannotModifyEmptyRect();
    internal static string get_Rect_CannotCallMethod();
    internal static string get_Size_WidthAndHeightCannotBeNegative();
    internal static string get_Size_WidthCannotBeNegative();
    internal static string get_Size_HeightCannotBeNegative();
    internal static string get_Size_CannotModifyEmptySize();
    internal static string get_Transform_NotInvertible();
    internal static string get_General_Expected_Type();
    internal static string get_ReferenceIsNull();
    internal static string get_ParameterMustBeBetween();
    internal static string get_Freezable_UnregisteredHandler();
    internal static string get_Freezable_AttemptToUseInnerValueWithDifferentThread();
    internal static string get_Freezable_CantFreeze();
    internal static string get_Freezable_NotAContext();
    internal static string get_FrugalList_TargetMapCannotHoldAllData();
    internal static string get_FrugalList_CannotPromoteBeyondArray();
    internal static string get_FrugalMap_TargetMapCannotHoldAllData();
    internal static string get_FrugalMap_CannotPromoteBeyondHashtable();
    internal static string get_Unsupported_Key();
    internal static string get_InvalidPriority();
    internal static string get_InvalidPriorityRangeOrder();
    internal static string get_DispatcherHasShutdown();
    internal static string get_ThreadMayNotWaitOnOperationsAlreadyExecutingOnTheSameThread();
    internal static string get_VerifyAccess();
    internal static string get_MismatchedDispatchers();
    internal static string get_DispatcherProcessingDisabledButStillPumping();
    internal static string get_DispatcherProcessingDisabled();
    internal static string get_DispatcherPriorityAwaiterInvalid();
    internal static string get_DispatcherYieldNoAvailableDispatcher();
    internal static string get_DispatcherRequestProcessingFailed();
    internal static string get_ExceptionFilterCodeNotPresent();
    internal static string get_Unsupported_Modifier();
    internal static string get_TimeSpanPeriodOutOfRange_TooSmall();
    internal static string get_TimeSpanPeriodOutOfRange_TooLarge();
    internal static string get_ClearOnReadOnlyObjectNotAllowed();
    internal static string get_DefaultValueAutoAssignFailed();
    internal static string get_DefaultValueMayNotBeExpression();
    internal static string get_DefaultValueMayNotBeUnset();
    internal static string get_DefaultValueMustBeFreeThreaded();
    internal static string get_DefaultValuePropertyTypeMismatch();
    internal static string get_DefaultValueInvalid();
    internal static string get_DTypeNotSupportForSystemType();
    internal static string get_InvalidPropertyValue();
    internal static string get_LocalValueEnumerationOutOfBounds();
    internal static string get_LocalValueEnumerationReset();
    internal static string get_LocalValueEnumerationInvalidated();
    internal static string get_MissingCreateDefaultValue();
    internal static string get_OverridingMetadataDoesNotMatchBaseMetadataType();
    internal static string get_PropertyAlreadyRegistered();
    internal static string get_PropertyNotReadOnly();
    internal static string get_ReadOnlyChangeNotAllowed();
    internal static string get_ReadOnlyKeyNotAuthorized();
    internal static string get_ReadOnlyOverrideNotAllowed();
    internal static string get_ReadOnlyOverrideKeyNotAuthorized();
    internal static string get_ReadOnlyDesignerCoersionNotAllowed();
    internal static string get_SetOnReadOnlyObjectNotAllowed();
    internal static string get_ShareableExpressionsCannotChangeSources();
    internal static string get_SharingNonSharableExpression();
    internal static string get_SpecialMethodMustBePublic();
    internal static string get_SourcesMustBeInSameThread();
    internal static string get_SourceChangeExpressionMismatch();
    internal static string get_TooManyDependencyProperties();
    internal static string get_TypeMetadataAlreadyInUse();
    internal static string get_TypeMetadataAlreadyRegistered();
    internal static string get_TypeMustBeDependencyObjectDerived();
    internal static string get_UnknownExpressionMode();
    internal static string get_BufferTooSmall();
    internal static string get_BufferOffsetNegative();
    internal static string get_CompoundFilePathNullEmpty();
    internal static string get_CanNotCreateContainerOnReadOnlyStream();
    internal static string get_CanNotCreateAsReadOnly();
    internal static string get_CanNotCreateInReadOnly();
    internal static string get_CanNotCreateStorageRootOnNonReadableStream();
    internal static string get_CanNotDelete();
    internal static string get_CanNotDeleteAccessDenied();
    internal static string get_CanNotCreateAccessDenied();
    internal static string get_CanNotDeleteInReadOnly();
    internal static string get_CanNotDeleteNonEmptyStorage();
    internal static string get_CanNotDeleteRoot();
    internal static string get_CanNotOnNonExistStorage();
    internal static string get_CanNotOpenStorage();
    internal static string get_ContainerNotFound();
    internal static string get_ContainerCanNotOpen();
    internal static string get_CreateModeMustBeCreateOrOpen();
    internal static string get_CFAPIFailure();
    internal static string get_DataSpaceLabelInUse();
    internal static string get_DataSpaceLabelInvalidEmpty();
    internal static string get_DataSpaceLabelUndefined();
    internal static string get_DataSpaceManagerDisposed();
    internal static string get_DataSpaceMapEntryInvalid();
    internal static string get_FileAccessInvalid();
    internal static string get_FileAlreadyExists();
    internal static string get_FileModeUnsupported();
    internal static string get_FileModeInvalid();
    internal static string get_FileShareUnsupported();
    internal static string get_FileShareInvalid();
    internal static string get_ILockBytesStreamMustSeek();
    internal static string get_InvalidArgumentValue();
    internal static string get_InvalidCondition01();
    internal static string get_InvalidStringFormat();
    internal static string get_InvalidTableType();
    internal static string get_MoveToDestNotExist();
    internal static string get_MoveToNYI();
    internal static string get_NameAlreadyInUse();
    internal static string get_NameCanNotHaveDelimiter();
    internal static string get_NamedAPIFailure();
    internal static string get_NameTableCorruptStg();
    internal static string get_NameTableCorruptMem();
    internal static string get_NameTableVersionMismatchRead();
    internal static string get_NameTableVersionMismatchWrite();
    internal static string get_NYIDefault();
    internal static string get_PathHasEmptyElement();
    internal static string get_ReadCountNegative();
    internal static string get_SeekFailed();
    internal static string get_SeekNegative();
    internal static string get_SeekOriginInvalid();
    internal static string get_StorageFlagsUnsupported();
    internal static string get_StorageAlreadyExist();
    internal static string get_StreamAlreadyExist();
    internal static string get_StorageInfoDisposed();
    internal static string get_StorageNotExist();
    internal static string get_StorageRootDisposed();
    internal static string get_StreamInfoDisposed();
    internal static string get_StreamLengthNegative();
    internal static string get_StreamNotExist();
    internal static string get_StreamNameNotValid();
    internal static string get_StreamTimeStampNotImplemented();
    internal static string get_StringCanNotBeReservedName();
    internal static string get_TimeStampNotAvailable();
    internal static string get_TransformLabelInUse();
    internal static string get_TransformLabelUndefined();
    internal static string get_TransformObjectConstructorParam();
    internal static string get_TransformObjectImplementIDataTransform();
    internal static string get_TransformObjectInitFailed();
    internal static string get_TransformTypeUnsupported();
    internal static string get_TransformStackValid();
    internal static string get_UnableToCreateOnStream();
    internal static string get_UnableToCreateStorage();
    internal static string get_UnableToCreateStream();
    internal static string get_UnableToOpenStream();
    internal static string get_UnsupportedTypeEncounteredWhenBuildingStgEnum();
    internal static string get_WriteFailure();
    internal static string get_WriteOnlyUnsupported();
    internal static string get_WriteSizeNegative();
    internal static string get_CFM_CorruptMetadataStream();
    internal static string get_CFM_CorruptMetadataStream_Root();
    internal static string get_CFM_CorruptMetadataStream_DuplicateKey();
    internal static string get_CFM_ObjectMustBeCompoundFileMetadataKey();
    internal static string get_CFM_ReadOnlyContainer();
    internal static string get_CFM_TypeTableFormat();
    internal static string get_CFM_UnicodeCharInvalid();
    internal static string get_CFM_ValueMustBeString();
    internal static string get_CFM_XMLCharInvalid();
    internal static string get_CanNotCompareDiffTypes();
    internal static string get_CFRCorrupt();
    internal static string get_CFRCorruptMultiStream();
    internal static string get_CFRCorruptStgFollowStm();
    internal static string get_DelimiterLeading();
    internal static string get_DelimiterTrailing();
    internal static string get_OffsetNegative();
    internal static string get_UnknownReferenceComponentType();
    internal static string get_UnknownReferenceSerialize();
    internal static string get_MalformedCompoundFilePath();
    internal static string get_CannotMakeStreamLengthNegative();
    internal static string get_CorruptStream();
    internal static string get_LengthNotSupported();
    internal static string get_ReadBufferTooSmall();
    internal static string get_ReadNotSupported();
    internal static string get_SeekNotSupported();
    internal static string get_SetLengthNotSupported();
    internal static string get_SetPositionNotSupported();
    internal static string get_StreamPositionNegative();
    internal static string get_TransformParametersFixed();
    internal static string get_WriteBufferTooSmall();
    internal static string get_WriteCountNegative();
    internal static string get_WriteNotSupported();
    internal static string get_ZLibVersionError();
    internal static string get_ExpectedVersionPairObject();
    internal static string get_VersionNumberComponentNegative();
    internal static string get_ZeroLengthFeatureID();
    internal static string get_VersionStreamMissing();
    internal static string get_VersionUpdateFailure();
    internal static string get_CannotRemoveSignatureFromReadOnlyFile();
    internal static string get_CannotSignReadOnlyFile();
    internal static string get_DigSigCannotLocateCertificate();
    internal static string get_DigSigDuplicateCertificate();
    internal static string get_CertSelectionDialogTitle();
    internal static string get_CertSelectionDialogMessage();
    internal static string get_DuplicateSignature();
    internal static string get_XmlSignatureParseError();
    internal static string get_RequiredXmlAttributeMissing();
    internal static string get_UnexpectedXmlTag();
    internal static string get_RequiredTagNotFound();
    internal static string get_PackageSignatureObjectTagRequired();
    internal static string get_PackageSignatureReferenceTagRequired();
    internal static string get_MoreThanOnePackageSpecificReference();
    internal static string get_InvalidUriAttribute();
    internal static string get_NoCounterSignUnsignedContainer();
    internal static string get_BadSignatureTimeFormatString();
    internal static string get_PackageSignatureCorruption();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_RelationshipTransformNotFollowedByCanonicalizationTransform();
    internal static string get_MultipleRelationshipTransformsFound();
    internal static string get_UnsupportedTransformAlgorithm();
    internal static string get_UnsupportedCanonicalizationMethod();
    internal static string get_HashAlgorithmMustBeReusable();
    internal static string get_PartReferenceUriMalformed();
    internal static string get_SignatureOriginNotFound();
    internal static string get_MultipleSignatureOrigins();
    internal static string get_NothingToSign();
    internal static string get_EmptySignatureId();
    internal static string get_SignatureDeleted();
    internal static string get_SignaturePackageObjectTagMustBeUnique();
    internal static string get_PackageSpecificReferenceTagMustBeUnique();
    internal static string get_SignatureObjectIdMustBeUnique();
    internal static string get_CanOnlyCounterSignSignatureParts();
    internal static string get_CertificatePartContentTypeMismatch();
    internal static string get_CertificateKeyTypeNotSupported();
    internal static string get_PartToSignMissing();
    internal static string get_DuplicateObjectId();
    internal static string get_CallbackParameterInvalid();
    internal static string get_CannotChangePublishLicense();
    internal static string get_CannotChangeCryptoProvider();
    internal static string get_ExcessiveLengthPrefix();
    internal static string get_GetOlePropertyFailed();
    internal static string get_InvalidAuthenticationTypeString();
    internal static string get_InvalidDocumentPropertyType();
    internal static string get_InvalidDocumentPropertyVariantType();
    internal static string get_InvalidTypePrefixedUserName();
    internal static string get_InvalidTransformFeatureName();
    internal static string get_PackageNotFound();
    internal static string get_NoPublishLicenseStream();
    internal static string get_NoUseLicenseStorage();
    internal static string get_ReaderVersionError();
    internal static string get_PublishLicenseStreamCorrupt();
    internal static string get_PublishLicenseNotFound();
    internal static string get_RightsManagementEncryptionTransformNotFound();
    internal static string get_MultipleRightsManagementEncryptionTransformFound();
    internal static string get_StreamNeedsReadWriteAccess();
    internal static string get_CryptoProviderCanNotDecrypt();
    internal static string get_CryptoProviderCanNotMergeBlocks();
    internal static string get_EncryptedPackageEnvelopeDisposed();
    internal static string get_CryptoProviderDisposed();
    internal static string get_UpdaterVersionError();
    internal static string get_DictionaryIsReadOnly();
    internal static string get_CryptoProviderIsNotReady();
    internal static string get_UseLicenseStreamCorrupt();
    internal static string get_EncryptedDataStreamCorrupt();
    internal static string get_UnknownDocumentProperty();
    internal static string get_WrongDocumentPropertyVariantType();
    internal static string get_UserIsNotActivated();
    internal static string get_UserHasNoClientLicensorCert();
    internal static string get_EncryptionRightIsNotGranted();
    internal static string get_DecryptionRightIsNotGranted();
    internal static string get_NoPrivilegesForPublishLicenseDecryption();
    internal static string get_InvalidPublishLicense();
    internal static string get_PublishLicenseStreamHeaderTooLong();
    internal static string get_OnlyPassportOrWindowsAuthenticatedUsersAreAllowed();
    internal static string get_RmExceptionGenericMessage();
    internal static string get_RmExceptionInvalidLicense();
    internal static string get_RmExceptionInfoNotInLicense();
    internal static string get_RmExceptionInvalidLicenseSignature();
    internal static string get_RmExceptionEncryptionNotPermitted();
    internal static string get_RmExceptionRightNotGranted();
    internal static string get_RmExceptionInvalidVersion();
    internal static string get_RmExceptionInvalidEncodingType();
    internal static string get_RmExceptionInvalidNumericalValue();
    internal static string get_RmExceptionInvalidAlgorithmType();
    internal static string get_RmExceptionEnvironmentNotLoaded();
    internal static string get_RmExceptionEnvironmentCannotLoad();
    internal static string get_RmExceptionTooManyLoadedEnvironments();
    internal static string get_RmExceptionIncompatibleObjects();
    internal static string get_RmExceptionLibraryFail();
    internal static string get_RmExceptionEnablingPrincipalFailure();
    internal static string get_RmExceptionInfoNotPresent();
    internal static string get_RmExceptionBadGetInfoQuery();
    internal static string get_RmExceptionKeyTypeUnsupported();
    internal static string get_RmExceptionCryptoOperationUnsupported();
    internal static string get_RmExceptionClockRollbackDetected();
    internal static string get_RmExceptionQueryReportsNoResults();
    internal static string get_RmExceptionUnexpectedException();
    internal static string get_RmExceptionBindValidityTimeViolated();
    internal static string get_RmExceptionBrokenCertChain();
    internal static string get_RmExceptionBindPolicyViolation();
    internal static string get_RmExceptionManifestPolicyViolation();
    internal static string get_RmExceptionBindRevokedLicense();
    internal static string get_RmExceptionBindRevokedIssuer();
    internal static string get_RmExceptionBindRevokedPrincipal();
    internal static string get_RmExceptionBindRevokedResource();
    internal static string get_RmExceptionBindRevokedModule();
    internal static string get_RmExceptionBindContentNotInEndUseLicense();
    internal static string get_RmExceptionBindAccessPrincipalNotEnabling();
    internal static string get_RmExceptionBindAccessUnsatisfied();
    internal static string get_RmExceptionBindIndicatedPrincipalMissing();
    internal static string get_RmExceptionBindMachineNotFoundInGroupIdentity();
    internal static string get_RmExceptionLibraryUnsupportedPlugIn();
    internal static string get_RmExceptionBindRevocationListStale();
    internal static string get_RmExceptionBindNoApplicableRevocationList();
    internal static string get_RmExceptionInvalidHandle();
    internal static string get_RmExceptionBindIntervalTimeViolated();
    internal static string get_RmExceptionBindNoSatisfiedRightsGroup();
    internal static string get_RmExceptionBindSpecifiedWorkMissing();
    internal static string get_RmExceptionNoMoreData();
    internal static string get_RmExceptionLicenseAcquisitionFailed();
    internal static string get_RmExceptionIdMismatch();
    internal static string get_RmExceptionTooManyCertificates();
    internal static string get_RmExceptionNoDistributionPointUrlFound();
    internal static string get_RmExceptionAlreadyInProgress();
    internal static string get_RmExceptionGroupIdentityNotSet();
    internal static string get_RmExceptionRecordNotFound();
    internal static string get_RmExceptionNoConnect();
    internal static string get_RmExceptionNoLicense();
    internal static string get_RmExceptionNeedsMachineActivation();
    internal static string get_RmExceptionNeedsGroupIdentityActivation();
    internal static string get_RmExceptionActivationFailed();
    internal static string get_RmExceptionAborted();
    internal static string get_RmExceptionOutOfQuota();
    internal static string get_RmExceptionAuthenticationFailed();
    internal static string get_RmExceptionServerError();
    internal static string get_RmExceptionInstallationFailed();
    internal static string get_RmExceptionHidCorrupted();
    internal static string get_RmExceptionInvalidServerResponse();
    internal static string get_RmExceptionServiceNotFound();
    internal static string get_RmExceptionUseDefault();
    internal static string get_RmExceptionServerNotFound();
    internal static string get_RmExceptionInvalidEmail();
    internal static string get_RmExceptionValidityTimeViolation();
    internal static string get_RmExceptionOutdatedModule();
    internal static string get_RmExceptionServiceMoved();
    internal static string get_RmExceptionServiceGone();
    internal static string get_RmExceptionAdEntryNotFound();
    internal static string get_RmExceptionNotAChain();
    internal static string get_RmExceptionRequestDenied();
    internal static string get_RmExceptionNotSet();
    internal static string get_RmExceptionMetadataNotSet();
    internal static string get_RmExceptionRevocationInfoNotSet();
    internal static string get_RmExceptionInvalidTimeInfo();
    internal static string get_RmExceptionRightNotSet();
    internal static string get_RmExceptionLicenseBindingToWindowsIdentityFailed();
    internal static string get_RmExceptionInvalidIssuanceLicenseTemplate();
    internal static string get_RmExceptionInvalidKeyLength();
    internal static string get_RmExceptionExpiredOfficialIssuanceLicenseTemplate();
    internal static string get_RmExceptionInvalidClientLicensorCertificate();
    internal static string get_RmExceptionHidInvalid();
    internal static string get_RmExceptionEmailNotVerified();
    internal static string get_RmExceptionDebuggerDetected();
    internal static string get_RmExceptionInvalidLockboxType();
    internal static string get_RmExceptionInvalidLockboxPath();
    internal static string get_RmExceptionInvalidRegistryPath();
    internal static string get_RmExceptionNoAesCryptoProvider();
    internal static string get_RmExceptionGlobalOptionAlreadySet();
    internal static string get_RmExceptionOwnerLicenseNotFound();
    internal static string get_ZipZeroSizeFileIsNotValidArchive();
    internal static string get_CanNotWriteInReadOnlyMode();
    internal static string get_CanNotReadInWriteOnlyMode();
    internal static string get_CanNotReadWriteInReadOnlyWriteOnlyMode();
    internal static string get_AttemptedToCreateDuplicateFileName();
    internal static string get_FileDoesNotExists();
    internal static string get_TruncateAppendModesNotSupported();
    internal static string get_OnlyFileShareReadAndFileShareNoneSupported();
    internal static string get_CanNotReadDataFromStreamWhichDoesNotSupportReading();
    internal static string get_CanNotWriteDataToStreamWhichDoesNotSupportWriting();
    internal static string get_CanNotOperateOnStreamWhichDoesNotSupportSeeking();
    internal static string get_UnsupportedCombinationOfModeAccessShareStreaming();
    internal static string get_CorruptedData();
    internal static string get_NotSupportedMultiDisk();
    internal static string get_ZipArchiveDisposed();
    internal static string get_ZipFileItemDisposed();
    internal static string get_NotSupportedVersionNeededToExtract();
    internal static string get_Zip64StructuresTooLarge();
    internal static string get_ZipNotSupportedEncryptedArchive();
    internal static string get_ZipNotSupportedSignedArchive();
    internal static string get_ZipNotSupportedCompressionMethod();
    internal static string get_CompressLengthMismatch();
    internal static string get_CreateNewOnNonEmptyStream();
    internal static string get_PartDoesNotExist();
    internal static string get_PartAlreadyExists();
    internal static string get_PartNamePrefixExists();
    internal static string get_IncompatibleModeOrAccess();
    internal static string get_URIShouldNotBeAbsolute();
    internal static string get_UriShouldBeAbsolute();
    internal static string get_ContainerAndPartModeIncompatible();
    internal static string get_UnsupportedCombinationOfModeAccess();
    internal static string get_NullStreamReturned();
    internal static string get_ObjectDisposed();
    internal static string get_ReadOnlyStream();
    internal static string get_WriteOnlyStream();
    internal static string get_ParentContainerClosed();
    internal static string get_PackagePartDeleted();
    internal static string get_RelationshipToRelationshipIllegal();
    internal static string get_RelationshipPartsCannotHaveRelationships();
    internal static string get_RelationshipPartIncorrectContentType();
    internal static string get_PackageRelationshipDoesNotExist();
    internal static string get_PackagePartRelationshipDoesNotExist();
    internal static string get_RelationshipTargetMustBeRelative();
    internal static string get_RequiredRelationshipAttributeMissing();
    internal static string get_RelationshipTagDoesntMatchSchema();
    internal static string get_RelationshipsTagHasExtraAttributes();
    internal static string get_UnknownTagEncountered();
    internal static string get_ExpectedRelationshipsElementTag();
    internal static string get_InvalidXmlBaseAttributePresent();
    internal static string get_NotAUniqueRelationshipId();
    internal static string get_NotAValidXmlIdString();
    internal static string get_InvalidValueForTheAttribute();
    internal static string get_InvalidRelationshipType();
    internal static string get_PartUriShouldStartWithForwardSlash();
    internal static string get_PartUriShouldNotEndWithForwardSlash();
    internal static string get_UriShouldBePackScheme();
    internal static string get_PartUriIsEmpty();
    internal static string get_InvalidPartUri();
    internal static string get_RelationshipPartUriNotExpected();
    internal static string get_RelationshipPartUriExpected();
    internal static string get_NotAValidRelationshipPartUri();
    internal static string get_FragmentMustStartWithHash();
    internal static string get_PartUriCannotHaveAFragment();
    internal static string get_PartUriShouldNotStartWithTwoForwardSlashes();
    internal static string get_InnerPackageUriHasFragment();
    internal static string get_StreamObjectDisposed();
    internal static string get_NullContentTypeProvided();
    internal static string get_GetContentTypeCoreNotImplemented();
    internal static string get_RequiredAttributeMissing();
    internal static string get_RequiredAttributeEmpty();
    internal static string get_TypesTagHasExtraAttributes();
    internal static string get_TypesElementExpected();
    internal static string get_TypesXmlDoesNotMatchSchema();
    internal static string get_DefaultTagDoesNotMatchSchema();
    internal static string get_OverrideTagDoesNotMatchSchema();
    internal static string get_ElementIsNotEmptyElement();
    internal static string get_BadPackageFormat();
    internal static string get_StreamingModeNotSupportedForConsumption();
    internal static string get_StreamingPackageProductionImpliesWriteOnlyAccess();
    internal static string get_StreamingPackageProductionRequiresSingleWriter();
    internal static string get_MethodAvailableOnlyInStreamingCreation();
    internal static string get_OperationIsNotSupportedInStreamingProduction();
    internal static string get_OnlyWriteOperationsAreSupportedInStreamingCreation();
    internal static string get_OperationViolatesWriteOnceSemantics();
    internal static string get_OnlyStreamingProductionIsSupported();
    internal static string get_IOBufferOverflow();
    internal static string get_StreamDoesNotSupportWrite();
    internal static string get_MoreThanOneMetadataRelationships();
    internal static string get_NoExternalTargetForMetadataRelationship();
    internal static string get_CorePropertiesElementExpected();
    internal static string get_NoStructuredContentInsideProperties();
    internal static string get_UnknownNamespaceInCorePropertiesPart();
    internal static string get_InvalidPropertyNameInCorePropertiesPart();
    internal static string get_PropertyStartTagExpected();
    internal static string get_XsdDateTimeExpected();
    internal static string get_DanglingMetadataRelationship();
    internal static string get_WrongContentTypeForPropertyPart();
    internal static string get_PropertyWrongNumbOfAttribsDefinedOn();
    internal static string get_UnknownDCDateTimeXsiType();
    internal static string get_DuplicateCorePropertyName();
    internal static string get_StorageBasedPackagePropertiesDiposed();
    internal static string get_EncodingNotSupported();
    internal static string get_DuplicatePiecesFound();
    internal static string get_PieceDoesNotExist();
    internal static string get_ServiceTypeAlreadyAdded();
    internal static string get_ParserAttributeArgsHigh();
    internal static string get_ParserAttributeArgsLow();
    internal static string get_ParserAssemblyLoadVersionMismatch();
    internal static string get_ToStringNull();
    internal static string get_ConvertToException();
    internal static string get_ConvertFromException();
    internal static string get_SortDescriptionPropertyNameCannotBeEmpty();
    internal static string get_CannotChangeAfterSealed();
    internal static string get_BadPropertyForGroup();
    internal static string get_CurrentChangingCannotBeCanceled();
    internal static string get_NotSupported_ReadOnlyCollection();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Argument_InvalidArrayType();
    internal static string get_ReachOutOfRange();
    internal static string get_InvalidPermissionState();
    internal static string get_TargetNotWebBrowserPermissionLevel();
    internal static string get_TargetNotMediaPermissionLevel();
    internal static string get_BadXml();
    internal static string get_InvalidPermissionLevel();
    internal static string get_XCRChoiceOnlyInAC();
    internal static string get_XCRChoiceAfterFallback();
    internal static string get_XCRRequiresAttribNotFound();
    internal static string get_XCRInvalidRequiresAttribute();
    internal static string get_XCRFallbackOnlyInAC();
    internal static string get_XCRChoiceNotFound();
    internal static string get_XCRMultipleFallbackFound();
    internal static string get_XCRInvalidAttribInElement();
    internal static string get_XCRUnknownCompatElement();
    internal static string get_XCRInvalidACChild();
    internal static string get_XCRInvalidFormat();
    internal static string get_XCRUndefinedPrefix();
    internal static string get_XCRUnknownCompatAttrib();
    internal static string get_XCRNSProcessContentNotIgnorable();
    internal static string get_XCRDuplicateProcessContent();
    internal static string get_XCRInvalidProcessContent();
    internal static string get_XCRDuplicateWildcardProcessContent();
    internal static string get_XCRMustUnderstandFailed();
    internal static string get_XCRNSPreserveNotIgnorable();
    internal static string get_XCRDuplicatePreserve();
    internal static string get_XCRInvalidPreserve();
    internal static string get_XCRDuplicateWildcardPreserve();
    internal static string get_XCRInvalidXMLName();
    internal static string get_XCRCompatCycle();
    internal static string get_EventNotFound();
    internal static string get_ListenerDidNotHandleEvent();
    internal static string get_ListenerDidNotHandleEventDetail();
    internal static string get_NoMulticastHandlers();
    internal static string get_InvariantFailure();
    internal static string get_ContentTypeCannotHaveLeadingTrailingLWS();
    internal static string get_InvalidTypeSubType();
    internal static string get_ExpectingParameterValuePairs();
    internal static string get_InvalidParameterValuePair();
    internal static string get_InvalidToken();
    internal static string get_InvalidParameterValue();
    internal static string get_InvalidLinearWhiteSpaceCharacter();
    internal static string get_ExpectingSemicolon();
    internal static string get_HwndSubclassMultipleAttach();
    internal static string get_UnableToLocateResource();
    internal static string get_SplashScreenIsLoading();
    internal static string get_NameScopeNameNotEmptyString();
    internal static string get_NameScopeNameNotFound();
    internal static string get_NameScopeDuplicateNamesNotAllowed();
    internal static string get_NameScopeNotFound();
    internal static string get_NameScopeInvalidIdentifierName();
    internal static string get_NoDependencyProperty();
    internal static string get_MarkupExtensionArrayType();
    internal static string get_MarkupExtensionArrayBadType();
    internal static string get_MarkupExtensionNoContext();
    internal static string get_MarkupExtensionBadStatic();
    internal static string get_MarkupExtensionStaticMember();
    internal static string get_MarkupExtensionTypeName();
    internal static string get_MarkupExtensionTypeNameBad();
    internal static string get_MustBeOfType();
    internal static string get_Verify_ApartmentState();
    internal static string get_Verify_NeitherNullNorEmpty();
    internal static string get_Verify_AreNotEqual();
    internal static string get_Verify_FileExists();
    internal static string get_InvalidEvent();
    internal static string get_CompatibilityPreferencesSealed();
    internal static string get_CombinationOfAccessibilitySwitchesNotSupported();
    internal static string get_AccessibilitySwitchDependencyNotSatisfied();
    internal static string get_TokenizerHelperExtraDataEncountered();
    internal static string get_TokenizerHelperPrematureStringTermination();
    internal static string get_TokenizerHelperMissingEndQuote();
    internal static string get_TokenizerHelperEmptyToken();
    internal static string get_Enumerator_VerifyContext();
    internal static string get_InvalidPermissionStateValue();
    internal static string get_InvalidPermissionType();
    internal static string get_StringEmpty();
    internal static string get_ParameterCannotBeNegative();
    internal static string get_Freezable_CantBeFrozen();
    internal static string get_TypeMetadataCannotChangeAfterUse();
    internal static string get_Enum_Invalid();
    internal static string get_CannotConvertStringToType();
    internal static string get_CannotModifyReadOnlyContainer();
    internal static string get_CannotRetrievePartsOfWriteOnlyContainer();
    internal static string get_FileFormatExceptionWithFileName();
    internal static string get_FileFormatException();
    internal static string get_Cryptography_InvalidHandle();
    internal static string get_WpfDllConsistencyErrorData();
    internal static string get_WpfDllConsistencyErrorHeader();
}
internal class MS.Internal.WindowsBase.WeakRefKey : WeakReference {
    private int _hashCode;
    public WeakRefKey(object target);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(WeakRefKey left, WeakRefKey right);
    public static bool op_Inequality(WeakRefKey left, WeakRefKey right);
}
internal class MS.Utility.ArrayItemList`1 : FrugalListBase`1<T> {
    private static int MINSIZE;
    private static int GROWTH;
    private static int LARGEGROWTH;
    private T[] _entries;
    public int Capacity { get; }
    public ArrayItemList`1(int size);
    public ArrayItemList`1(ICollection collection);
    public ArrayItemList`1(ICollection`1<T> collection);
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SixItemList`1<T> oldList);
    public void Promote(ArrayItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
    public virtual Compacter<T> NewCompacter(int newCount);
}
internal class MS.Utility.ArrayObjectMap : FrugalMapBase {
    private static int MINSIZE;
    private static int MAXSIZE;
    private static int GROWTH;
    private ushort _count;
    private bool _sorted;
    private Entry[] _entries;
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
    private int Compare(int left, int right);
    private int Partition(int left, int right);
    private void QSort(int left, int right);
}
internal class MS.Utility.ClassicTraceProvider : TraceProvider {
    private ulong _traceHandle;
    private static ControlCallback _etwProc;
    internal virtual void Register(Guid providerGuid);
    private UInt32 EtwEnableCallback(WMIDPREQUESTCODE requestCode, IntPtr context, IntPtr bufferSize, WNODE_HEADER* buffer);
    protected virtual override void Finalize();
    internal virtual UInt32 EventWrite(Event eventID, Keyword keywords, Level level, int argc, EventData* argv);
}
internal class MS.Utility.DpiAwarenessContextHandle : SafeHandle {
    [CompilerGeneratedAttribute]
private static DpiAwarenessContextHandle <DPI_AWARENESS_CONTEXT_UNAWARE>k__BackingField;
    [CompilerGeneratedAttribute]
private static DpiAwarenessContextHandle <DPI_AWARENESS_CONTEXT_SYSTEM_AWARE>k__BackingField;
    [CompilerGeneratedAttribute]
private static DpiAwarenessContextHandle <DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE>k__BackingField;
    [CompilerGeneratedAttribute]
private static DpiAwarenessContextHandle <DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2>k__BackingField;
    [CompilerGeneratedAttribute]
private static Dictionary`2<DpiAwarenessContextValue, IntPtr> <WellKnownContextValues>k__BackingField;
    public bool IsInvalid { get; }
    internal static DpiAwarenessContextHandle DPI_AWARENESS_CONTEXT_UNAWARE { get; }
    internal static DpiAwarenessContextHandle DPI_AWARENESS_CONTEXT_SYSTEM_AWARE { get; }
    internal static DpiAwarenessContextHandle DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE { get; }
    internal static DpiAwarenessContextHandle DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 { get; }
    private static Dictionary`2<DpiAwarenessContextValue, IntPtr> WellKnownContextValues { get; }
    private static DpiAwarenessContextHandle();
    internal DpiAwarenessContextHandle(DpiAwarenessContextValue dpiAwarenessContextValue);
    internal DpiAwarenessContextHandle(IntPtr dpiContext);
    protected DpiAwarenessContextHandle(IntPtr invalidHandleValue, bool ownsHandle);
    public virtual bool get_IsInvalid();
    [CompilerGeneratedAttribute]
internal static DpiAwarenessContextHandle get_DPI_AWARENESS_CONTEXT_UNAWARE();
    [CompilerGeneratedAttribute]
internal static DpiAwarenessContextHandle get_DPI_AWARENESS_CONTEXT_SYSTEM_AWARE();
    [CompilerGeneratedAttribute]
internal static DpiAwarenessContextHandle get_DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE();
    [CompilerGeneratedAttribute]
internal static DpiAwarenessContextHandle get_DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2();
    [CompilerGeneratedAttribute]
private static Dictionary`2<DpiAwarenessContextValue, IntPtr> get_WellKnownContextValues();
    public static DpiAwarenessContextValue op_Explicit(DpiAwarenessContextHandle dpiAwarenessContextHandle);
    public sealed virtual bool Equals(DpiAwarenessContextHandle dpiContextHandle);
    public sealed virtual bool Equals(IntPtr dpiContext);
    public sealed virtual bool Equals(DpiAwarenessContextValue dpiContextEnumValue);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual bool ReleaseHandle();
}
internal enum MS.Utility.DpiAwarenessContextValue : Enum {
    public int value__;
    public static DpiAwarenessContextValue Invalid;
    public static DpiAwarenessContextValue Unaware;
    public static DpiAwarenessContextValue SystemAware;
    public static DpiAwarenessContextValue PerMonitorAware;
    public static DpiAwarenessContextValue PerMonitorAwareVersion2;
}
internal class MS.Utility.EventData : ValueType {
    internal ulong Ptr;
    internal UInt32 Size;
    internal UInt32 Reserved;
}
internal static class MS.Utility.EventTrace : object {
    internal static TraceProvider EventProvider;
    private static EventTrace();
    internal static void EasyTraceEvent(Keyword keywords, Event eventID);
    internal static void EasyTraceEvent(Keyword keywords, Level level, Event eventID);
    internal static void EasyTraceEvent(Keyword keywords, Event eventID, T1 param1);
    internal static void EasyTraceEvent(Keyword keywords, Level level, Event eventID, T1 param1);
    internal static void EasyTraceEvent(Keyword keywords, Event eventID, T1 param1, T2 param2);
    internal static void EasyTraceEvent(Keyword keywords, Level level, Event eventID, T1 param1, T2 param2);
    internal static void EasyTraceEvent(Keyword keywords, Event eventID, T1 param1, T2 param2, T3 param3);
    internal static bool IsEnabled(Keyword flag, Level level);
    private static bool IsClassicETWRegistryEnabled();
    internal static Guid GetGuidForEvent(Event arg);
    internal static ushort GetTaskForEvent(Event arg);
    internal static byte GetOpcodeForEvent(Event arg);
    internal static byte GetVersionForEvent(Event arg);
}
internal abstract class MS.Utility.FrugalListBase`1 : object {
    protected int _count;
    public int Count { get; }
    public int Capacity { get; }
    public int get_Count();
    internal void TrustedSetCount(int newCount);
    public abstract virtual int get_Capacity();
    public abstract virtual FrugalListStoreState Add(T value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T value);
    public abstract virtual int IndexOf(T value);
    public abstract virtual void Insert(int index, T value);
    public abstract virtual void SetAt(int index, T value);
    public abstract virtual bool Remove(T value);
    public abstract virtual void RemoveAt(int index);
    public abstract virtual T EntryAt(int index);
    public abstract virtual void Promote(FrugalListBase`1<T> newList);
    public abstract virtual T[] ToArray();
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual object Clone();
    public virtual Compacter<T> NewCompacter(int newCount);
}
internal enum MS.Utility.FrugalListStoreState : Enum {
    public int value__;
    public static FrugalListStoreState Success;
    public static FrugalListStoreState SingleItemList;
    public static FrugalListStoreState ThreeItemList;
    public static FrugalListStoreState SixItemList;
    public static FrugalListStoreState Array;
}
[DefaultMemberAttribute("Item")]
[FriendAccessAllowedAttribute]
internal class MS.Utility.FrugalMap : ValueType {
    internal FrugalMapBase _mapStore;
    public object Item { get; public set; }
    public int Count { get; }
    public object get_Item(int key);
    public void set_Item(int key, object value);
    public void Sort();
    public void GetKeyValuePair(int index, Int32& key, Object& value);
    public void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public int get_Count();
}
internal abstract class MS.Utility.FrugalMapBase : object {
    protected static int INVALIDKEY;
    public int Count { get; }
    public abstract virtual FrugalMapStoreState InsertEntry(int key, object value);
    public abstract virtual void RemoveEntry(int key);
    public abstract virtual object Search(int key);
    public abstract virtual void Sort();
    public abstract virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public abstract virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public abstract virtual void Promote(FrugalMapBase newMap);
    public abstract virtual int get_Count();
}
internal class MS.Utility.FrugalMapIterationCallback : MulticastDelegate {
    public FrugalMapIterationCallback(object object, IntPtr method);
    public virtual void Invoke(ArrayList list, int key, object value);
    public virtual IAsyncResult BeginInvoke(ArrayList list, int key, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum MS.Utility.FrugalMapStoreState : Enum {
    public int value__;
    public static FrugalMapStoreState Success;
    public static FrugalMapStoreState ThreeObjectMap;
    public static FrugalMapStoreState SixObjectMap;
    public static FrugalMapStoreState Array;
    public static FrugalMapStoreState SortedArray;
    public static FrugalMapStoreState Hashtable;
}
[DefaultMemberAttribute("Item")]
[FriendAccessAllowedAttribute]
internal class MS.Utility.FrugalObjectList`1 : object {
    internal FrugalListBase`1<T> _listStore;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public FrugalObjectList`1(int size);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int Add(T value);
    public void Clear();
    public bool Contains(T value);
    public int IndexOf(T value);
    public void Insert(int index, T value);
    public bool Remove(T value);
    public void RemoveAt(int index);
    public void EnsureIndex(int index);
    public T[] ToArray();
    public void CopyTo(T[] array, int index);
    public FrugalObjectList`1<T> Clone();
}
[DefaultMemberAttribute("Item")]
[FriendAccessAllowedAttribute]
internal class MS.Utility.FrugalStructList`1 : ValueType {
    internal FrugalListBase`1<T> _listStore;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public FrugalStructList`1(int size);
    public FrugalStructList`1(ICollection collection);
    public FrugalStructList`1(ICollection`1<T> collection);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int Add(T value);
    public void Clear();
    public bool Contains(T value);
    public int IndexOf(T value);
    public void Insert(int index, T value);
    public bool Remove(T value);
    public void RemoveAt(int index);
    public void EnsureIndex(int index);
    public T[] ToArray();
    public void CopyTo(T[] array, int index);
    public FrugalStructList`1<T> Clone();
}
internal class MS.Utility.HashObjectMap : FrugalMapBase {
    internal static int MINSIZE;
    private static object NullValue;
    internal Dictionary`2<int, object> _entries;
    public int Count { get; }
    private static HashObjectMap();
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
internal class MS.Utility.InsertionSortMap : ValueType {
    internal LargeSortedObjectMap _mapStore;
    public object Item { get; public set; }
    public int Count { get; }
    public object get_Item(int key);
    public void set_Item(int key, object value);
    public void Sort();
    public void GetKeyValuePair(int index, Int32& key, Object& value);
    public void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public int get_Count();
}
[FriendAccessAllowedAttribute]
internal class MS.Utility.ItemStructList`1 : ValueType {
    public T[] List;
    public int Count;
    public ItemStructList`1(int capacity);
    public void EnsureIndex(int index);
    public bool IsValidIndex(int index);
    public int IndexOf(T value);
    public bool Contains(T value);
    public void Add(T item);
    public void Add(T& item);
    public int Add();
    public int Add(int delta);
    private int Add(int delta, bool incrCount);
    public void Sort();
    public void AppendTo(ItemStructList`1& destinationList);
    public T[] ToArray();
    public void Clear();
    public void Remove(T value);
}
internal class MS.Utility.LargeSortedObjectMap : FrugalMapBase {
    private static int MINSIZE;
    internal int _count;
    private int _lastKey;
    private Entry[] _entries;
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    private int FindInsertIndex(int key, Boolean& found);
    public virtual int get_Count();
}
internal class MS.Utility.ManifestTraceProvider : TraceProvider {
    private static EtwEnableCallback _etwEnabledCallback;
    internal virtual void Register(Guid providerGuid);
    private void EtwEnableCallback(Guid& sourceId, int isEnabled, byte level, long matchAnyKeywords, long matchAllKeywords, EVENT_FILTER_DESCRIPTOR* filterData, Void* callbackContext);
    protected virtual override void Finalize();
    internal virtual UInt32 EventWrite(Event eventID, Keyword keywords, Level level, int argc, EventData* argv);
}
internal class MS.Utility.SingleItemList`1 : FrugalListBase`1<T> {
    private static int SIZE;
    private T _loneEntry;
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SingleItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
}
internal class MS.Utility.SingleObjectMap : FrugalMapBase {
    private Entry _loneEntry;
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
}
internal class MS.Utility.SixItemList`1 : FrugalListBase`1<T> {
    private static int SIZE;
    private T _entry0;
    private T _entry1;
    private T _entry2;
    private T _entry3;
    private T _entry4;
    private T _entry5;
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(ThreeItemList`1<T> oldList);
    public void Promote(SixItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
}
internal class MS.Utility.SixObjectMap : FrugalMapBase {
    private static int SIZE;
    private ushort _count;
    private bool _sorted;
    private Entry _entry0;
    private Entry _entry1;
    private Entry _entry2;
    private Entry _entry3;
    private Entry _entry4;
    private Entry _entry5;
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
}
internal class MS.Utility.SortedObjectMap : FrugalMapBase {
    private static int MINSIZE;
    private static int MAXSIZE;
    private static int GROWTH;
    internal int _count;
    private int _lastKey;
    private Entry[] _entries;
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    private int FindInsertIndex(int key, Boolean& found);
    public virtual int get_Count();
}
internal class MS.Utility.ThreeItemList`1 : FrugalListBase`1<T> {
    private static int SIZE;
    private T _entry0;
    private T _entry1;
    private T _entry2;
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SingleItemList`1<T> oldList);
    public void Promote(ThreeItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
}
internal class MS.Utility.ThreeObjectMap : FrugalMapBase {
    private static int SIZE;
    private ushort _count;
    private bool _sorted;
    private Entry _entry0;
    private Entry _entry1;
    private Entry _entry2;
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
}
internal abstract class MS.Utility.TraceProvider : object {
    protected bool _enabled;
    protected Level _level;
    protected Keyword _keywords;
    protected Keyword _matchAllKeyword;
    protected SecurityCriticalDataForSet`1<ulong> _registrationHandle;
    private static int s_basicTypeAllocationBufferSize;
    private static int s_traceEventMaximumSize;
    private static int s_etwMaxNumberArguments;
    private static int s_etwAPIMaxStringCount;
    private static int ErrorEventTooBig;
    internal Keyword Keywords { get; }
    internal Keyword MatchAllKeywords { get; }
    internal Level Level { get; }
    internal abstract virtual void Register(Guid providerGuid);
    internal abstract virtual UInt32 EventWrite(Event eventID, Keyword keywords, Level level, int argc, EventData* argv);
    internal UInt32 TraceEvent(Event eventID, Keyword keywords, Level level);
    internal Keyword get_Keywords();
    internal Keyword get_MatchAllKeywords();
    internal Level get_Level();
    internal bool IsEnabled(Keyword keyword, Level level);
    internal UInt32 TraceEvent(Event eventID, Keyword keywords, Level level, object eventData);
    internal UInt32 TraceEvent(Event eventID, Keyword keywords, Level level, Object[] eventPayload);
    private static string EncodeObject(Object& data, EventData* dataDescriptor, Byte* dataBuffer);
}
internal static class MS.Win32.ClassicEtw : object {
    internal static int WNODE_FLAG_TRACED_GUID;
    internal static int WNODE_FLAG_USE_MOF_PTR;
    internal static int MAX_MOF_FIELDS;
    internal static UInt32 RegisterTraceGuidsW(ControlCallback cbFunc, IntPtr context, Guid& providerGuid, int taskGuidCount, TRACE_GUID_REGISTRATION& taskGuids, string mofImagePath, string mofResourceName, UInt64& regHandle);
    internal static UInt32 UnregisterTraceGuids(ulong regHandle);
    internal static int GetTraceEnableFlags(ulong traceHandle);
    internal static byte GetTraceEnableLevel(ulong traceHandle);
    internal static long GetTraceLoggerHandle(WNODE_HEADER* data);
    internal static UInt32 TraceEvent(ulong traceHandle, EVENT_HEADER* header);
}
internal static class MS.Win32.ExternDll : object {
    public static string Activeds;
    public static string Advapi32;
    public static string Comctl32;
    public static string Comdlg32;
    public static string DwmAPI;
    public static string Gdi32;
    public static string Gdiplus;
    public static string Hhctrl;
    public static string Imm32;
    public static string Kernel32;
    public static string Loadperf;
    public static string Mqrt;
    public static string Mscoree;
    public static string MsDrm;
    public static string Mshwgst;
    public static string Msi;
    public static string NaturalLanguage6;
    public static string Ntdll;
    public static string Ole32;
    public static string Oleacc;
    public static string Oleaut32;
    public static string Olepro32;
    public static string Penimc;
    public static string PresentationCore;
    public static string PresentationFramework;
    public static string PresentationHostDll;
    public static string PresentationNativeDll;
    public static string Psapi;
    public static string Shcore;
    public static string Shell32;
    public static string Shfolder;
    public static string Urlmon;
    public static string User32;
    public static string Uxtheme;
    public static string Version;
    public static string Vsassert;
    public static string WindowsBase;
    public static string Wininet;
    public static string Winmm;
    public static string Winspool;
    public static string Wldp;
    public static string WpfGfx;
    public static string WtsApi32;
}
internal static class MS.Win32.HandleCollector : object {
    private static HandleType[] handleTypes;
    private static int handleTypeCount;
    private static object handleMutex;
    private static HandleCollector();
    internal static IntPtr Add(IntPtr handle, int type);
    internal static SafeHandle Add(SafeHandle handle, int type);
    internal static void Add(int type);
    internal static int RegisterType(string typeName, int expense, int initialThreshold);
    internal static IntPtr Remove(IntPtr handle, int type);
    internal static SafeHandle Remove(SafeHandle handle, int type);
    internal static void Remove(int type);
}
[FriendAccessAllowedAttribute]
internal class MS.Win32.HwndSubclass : object {
    [ThreadStaticAttribute]
private static DispatcherOperationCallbackParameter _paramDispatcherCallbackOperation;
    private DispatcherOperationCallback _dispatcherOperationCallback;
    internal static WindowMessage DetachMessage;
    private static WndProc DefWndProcStub;
    private static IntPtr DefWndProc;
    private IntPtr _hwndAttached;
    private HandleRef _hwndHandleRef;
    private WndProc _attachedWndProc;
    private IntPtr _oldWndProc;
    private Bond _bond;
    private GCHandle _gcHandle;
    private WeakReference _hook;
    private static HwndSubclass();
    internal HwndSubclass(HwndWrapperHook hook);
    public virtual void Dispose();
    private bool DisposeImpl(bool forceUnhook);
    internal IntPtr Attach(IntPtr hwnd);
    internal bool Detach(bool force);
    internal bool CriticalDetach(bool force);
    internal void RequestDetach(bool force);
    internal static void RequestDetach(IntPtr hwnd, IntPtr subclass, bool force);
    internal IntPtr SubclassWndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam);
    internal IntPtr CriticalAttach(IntPtr hwnd);
    private object DispatcherCallbackOperation(object o);
    private IntPtr CallOldWindowProc(IntPtr oldWndProc, IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam);
    private void HookWindowProc(IntPtr hwnd, WndProc newWndProc, IntPtr oldWndProc);
    private bool UnhookWindowProc(bool force);
    private static IntPtr DefWndProcWrapper(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam);
}
[FriendAccessAllowedAttribute]
internal class MS.Win32.HwndWrapper : DispatcherObject {
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    private SecurityCriticalDataClass`1<IntPtr> _handle;
    private ushort _classAtom;
    private SecurityCriticalDataClass`1<WeakReferenceList> _hooks;
    private SecurityCriticalDataForSet`1<int> _ownerThreadID;
    private SecurityCriticalData`1<HwndWrapperHook> _wndProc;
    private bool _isDisposed;
    private bool _isInCreateWindow;
    private static WindowMessage s_msgGCMemory;
    public IntPtr Handle { get; }
    private static HwndWrapper();
    public HwndWrapper(int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent, HwndWrapperHook[] hooks);
    protected virtual override void Finalize();
    public virtual void Dispose();
    private void Dispose(bool disposing, bool isHwndBeingDestroyed);
    public IntPtr get_Handle();
    [CompilerGeneratedAttribute]
public void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(EventHandler value);
    public void AddHook(HwndWrapperHook hook);
    internal void AddHookLast(HwndWrapperHook hook);
    public void RemoveHook(HwndWrapperHook hook);
    private IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private void CheckForCreateWindowFailure(IntPtr result, bool handled);
    internal static object DestroyWindow(object args);
    internal static object UnregisterClass(object arg);
}
[FriendAccessAllowedAttribute]
internal class MS.Win32.HwndWrapperHook : MulticastDelegate {
    public HwndWrapperHook(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
internal static class MS.Win32.ManagedWndProcTracker : object {
    private static IntPtr _cachedDefWindowProcA;
    private static IntPtr _cachedDefWindowProcW;
    private static Hashtable _hwndList;
    private static bool _exiting;
    private static ManagedWndProcTracker();
    internal static void TrackHwndSubclass(HwndSubclass subclass, IntPtr hwnd);
    internal static void UnhookHwndSubclass(HwndSubclass subclass);
    private static void OnAppDomainProcessExit();
    private static void HookUpDefWindowProc(IntPtr hwnd);
    private static IntPtr GetDefWindowProcAddress(IntPtr hwnd);
    private static IntPtr GetUser32ProcAddress(string export);
}
internal static class MS.Win32.ManifestEtw : object {
    internal static UInt32 EventRegister(Guid& providerId, EtwEnableCallback enableCallback, Void* callbackContext, UInt64& registrationHandle);
    internal static UInt32 EventUnregister(ulong registrationHandle);
    internal static UInt32 EventWrite(ulong registrationHandle, EventDescriptor& eventDescriptor, UInt32 userDataCount, EventData* userData);
}
internal class MS.Win32.MessageOnlyHwndWrapper : HwndWrapper {
}
[FriendAccessAllowedAttribute]
internal class MS.Win32.NativeMethods : object {
    public static IntPtr InvalidIntPtr;
    public static IntPtr LPSTR_TEXTCALLBACK;
    public static HandleRef NullHandleRef;
    public static int ERROR;
    public static int BITMAPINFO_MAX_COLORSIZE;
    public static int PAGE_READWRITE;
    public static int FILE_MAP_READ;
    public static int APPCOMMAND_BROWSER_BACKWARD;
    public static int APPCOMMAND_BROWSER_FORWARD;
    public static int APPCOMMAND_BROWSER_REFRESH;
    public static int APPCOMMAND_BROWSER_STOP;
    public static int APPCOMMAND_BROWSER_SEARCH;
    public static int APPCOMMAND_BROWSER_FAVORITES;
    public static int APPCOMMAND_BROWSER_HOME;
    public static int APPCOMMAND_VOLUME_MUTE;
    public static int APPCOMMAND_VOLUME_DOWN;
    public static int APPCOMMAND_VOLUME_UP;
    public static int APPCOMMAND_MEDIA_NEXTTRACK;
    public static int APPCOMMAND_MEDIA_PREVIOUSTRACK;
    public static int APPCOMMAND_MEDIA_STOP;
    public static int APPCOMMAND_MEDIA_PLAY_PAUSE;
    public static int APPCOMMAND_LAUNCH_MAIL;
    public static int APPCOMMAND_LAUNCH_MEDIA_SELECT;
    public static int APPCOMMAND_LAUNCH_APP1;
    public static int APPCOMMAND_LAUNCH_APP2;
    public static int APPCOMMAND_BASS_DOWN;
    public static int APPCOMMAND_BASS_BOOST;
    public static int APPCOMMAND_BASS_UP;
    public static int APPCOMMAND_TREBLE_DOWN;
    public static int APPCOMMAND_TREBLE_UP;
    public static int APPCOMMAND_MICROPHONE_VOLUME_MUTE;
    public static int APPCOMMAND_MICROPHONE_VOLUME_DOWN;
    public static int APPCOMMAND_MICROPHONE_VOLUME_UP;
    public static int APPCOMMAND_HELP;
    public static int APPCOMMAND_FIND;
    public static int APPCOMMAND_NEW;
    public static int APPCOMMAND_OPEN;
    public static int APPCOMMAND_CLOSE;
    public static int APPCOMMAND_SAVE;
    public static int APPCOMMAND_PRINT;
    public static int APPCOMMAND_UNDO;
    public static int APPCOMMAND_REDO;
    public static int APPCOMMAND_COPY;
    public static int APPCOMMAND_CUT;
    public static int APPCOMMAND_PASTE;
    public static int APPCOMMAND_REPLY_TO_MAIL;
    public static int APPCOMMAND_FORWARD_MAIL;
    public static int APPCOMMAND_SEND_MAIL;
    public static int APPCOMMAND_SPELL_CHECK;
    public static int APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE;
    public static int APPCOMMAND_MIC_ON_OFF_TOGGLE;
    public static int APPCOMMAND_CORRECTION_LIST;
    public static int APPCOMMAND_MEDIA_PLAY;
    public static int APPCOMMAND_MEDIA_PAUSE;
    public static int APPCOMMAND_MEDIA_RECORD;
    public static int APPCOMMAND_MEDIA_FAST_FORWARD;
    public static int APPCOMMAND_MEDIA_REWIND;
    public static int APPCOMMAND_MEDIA_CHANNEL_UP;
    public static int APPCOMMAND_MEDIA_CHANNEL_DOWN;
    public static int FAPPCOMMAND_MOUSE;
    public static int FAPPCOMMAND_KEY;
    public static int FAPPCOMMAND_OEM;
    public static int FAPPCOMMAND_MASK;
    public static int BI_RGB;
    public static int BITSPIXEL;
    public static int cmb4;
    public static int CS_DBLCLKS;
    public static int CS_DROPSHADOW;
    public static int CS_SAVEBITS;
    public static int CF_TEXT;
    public static int CF_BITMAP;
    public static int CF_METAFILEPICT;
    public static int CF_SYLK;
    public static int CF_DIF;
    public static int CF_TIFF;
    public static int CF_OEMTEXT;
    public static int CF_DIB;
    public static int CF_PALETTE;
    public static int CF_PENDATA;
    public static int CF_RIFF;
    public static int CF_WAVE;
    public static int CF_UNICODETEXT;
    public static int CF_ENHMETAFILE;
    public static int CF_HDROP;
    public static int CF_LOCALE;
    public static int CLSCTX_INPROC_SERVER;
    public static int CLSCTX_LOCAL_SERVER;
    public static int CW_USEDEFAULT;
    public static int CWP_SKIPINVISIBLE;
    public static int COLOR_WINDOW;
    public static int CB_ERR;
    public static int CBN_SELCHANGE;
    public static int CBN_DBLCLK;
    public static int CBN_EDITCHANGE;
    public static int CBN_EDITUPDATE;
    public static int CBN_DROPDOWN;
    public static int CBN_CLOSEUP;
    public static int CBN_SELENDOK;
    public static int CBS_SIMPLE;
    public static int CBS_DROPDOWN;
    public static int CBS_DROPDOWNLIST;
    public static int CBS_OWNERDRAWFIXED;
    public static int CBS_OWNERDRAWVARIABLE;
    public static int CBS_AUTOHSCROLL;
    public static int CBS_HASSTRINGS;
    public static int CBS_NOINTEGRALHEIGHT;
    public static int CB_GETEDITSEL;
    public static int CB_LIMITTEXT;
    public static int CB_SETEDITSEL;
    public static int CB_ADDSTRING;
    public static int CB_DELETESTRING;
    public static int CB_GETCURSEL;
    public static int CB_GETLBTEXT;
    public static int CB_GETLBTEXTLEN;
    public static int CB_INSERTSTRING;
    public static int CB_RESETCONTENT;
    public static int CB_FINDSTRING;
    public static int CB_SETCURSEL;
    public static int CB_SHOWDROPDOWN;
    public static int CB_GETITEMDATA;
    public static int CB_SETITEMHEIGHT;
    public static int CB_GETITEMHEIGHT;
    public static int CB_GETDROPPEDSTATE;
    public static int CB_FINDSTRINGEXACT;
    public static int CB_SETDROPPEDWIDTH;
    public static int CDRF_DODEFAULT;
    public static int CDRF_NEWFONT;
    public static int CDRF_SKIPDEFAULT;
    public static int CDRF_NOTIFYPOSTPAINT;
    public static int CDRF_NOTIFYITEMDRAW;
    public static int CDRF_NOTIFYSUBITEMDRAW;
    public static int CDDS_PREPAINT;
    public static int CDDS_POSTPAINT;
    public static int CDDS_ITEM;
    public static int CDDS_SUBITEM;
    public static int CDDS_ITEMPREPAINT;
    public static int CDDS_ITEMPOSTPAINT;
    public static int CDIS_SELECTED;
    public static int CDIS_GRAYED;
    public static int CDIS_DISABLED;
    public static int CDIS_CHECKED;
    public static int CDIS_FOCUS;
    public static int CDIS_DEFAULT;
    public static int CDIS_HOT;
    public static int CDIS_MARKED;
    public static int CDIS_INDETERMINATE;
    public static int CDIS_SHOWKEYBOARDCUES;
    public static int CLR_NONE;
    public static int CLR_DEFAULT;
    public static int CCM_SETVERSION;
    public static int CCM_GETVERSION;
    public static int CCS_NORESIZE;
    public static int CCS_NOPARENTALIGN;
    public static int CCS_NODIVIDER;
    public static int CBEM_INSERTITEMA;
    public static int CBEM_GETITEMA;
    public static int CBEM_SETITEMA;
    public static int CBEM_INSERTITEMW;
    public static int CBEM_SETITEMW;
    public static int CBEM_GETITEMW;
    public static int CBEN_ENDEDITA;
    public static int CBEN_ENDEDITW;
    public static int CONNECT_E_NOCONNECTION;
    public static int CONNECT_E_CANNOTCONNECT;
    public static int CTRLINFO_EATS_RETURN;
    public static int CTRLINFO_EATS_ESCAPE;
    public static int CSIDL_DESKTOP;
    public static int CSIDL_INTERNET;
    public static int CSIDL_PROGRAMS;
    public static int CSIDL_PERSONAL;
    public static int CSIDL_FAVORITES;
    public static int CSIDL_STARTUP;
    public static int CSIDL_RECENT;
    public static int CSIDL_SENDTO;
    public static int CSIDL_STARTMENU;
    public static int CSIDL_DESKTOPDIRECTORY;
    public static int CSIDL_TEMPLATES;
    public static int CSIDL_APPDATA;
    public static int CSIDL_LOCAL_APPDATA;
    public static int CSIDL_INTERNET_CACHE;
    public static int CSIDL_COOKIES;
    public static int CSIDL_HISTORY;
    public static int CSIDL_COMMON_APPDATA;
    public static int CSIDL_SYSTEM;
    public static int CSIDL_PROGRAM_FILES;
    public static int CSIDL_PROGRAM_FILES_COMMON;
    public static int DUPLICATE;
    public static int DISPID_VALUE;
    public static int DISPID_UNKNOWN;
    public static int DISPID_PROPERTYPUT;
    public static int DISPATCH_METHOD;
    public static int DISPATCH_PROPERTYGET;
    public static int DISPATCH_PROPERTYPUT;
    public static int DISPATCH_PROPERTYPUTREF;
    public static int DV_E_DVASPECT;
    public static int DEFAULT_GUI_FONT;
    public static int DIB_RGB_COLORS;
    public static int DRAGDROP_E_NOTREGISTERED;
    public static int DRAGDROP_E_ALREADYREGISTERED;
    public static int DUPLICATE_SAME_ACCESS;
    public static int DFC_CAPTION;
    public static int DFC_MENU;
    public static int DFC_SCROLL;
    public static int DFC_BUTTON;
    public static int DFCS_CAPTIONCLOSE;
    public static int DFCS_CAPTIONMIN;
    public static int DFCS_CAPTIONMAX;
    public static int DFCS_CAPTIONRESTORE;
    public static int DFCS_CAPTIONHELP;
    public static int DFCS_MENUARROW;
    public static int DFCS_MENUCHECK;
    public static int DFCS_MENUBULLET;
    public static int DFCS_SCROLLUP;
    public static int DFCS_SCROLLDOWN;
    public static int DFCS_SCROLLLEFT;
    public static int DFCS_SCROLLRIGHT;
    public static int DFCS_SCROLLCOMBOBOX;
    public static int DFCS_BUTTONCHECK;
    public static int DFCS_BUTTONRADIO;
    public static int DFCS_BUTTON3STATE;
    public static int DFCS_BUTTONPUSH;
    public static int DFCS_INACTIVE;
    public static int DFCS_PUSHED;
    public static int DFCS_CHECKED;
    public static int DFCS_FLAT;
    public static int DT_LEFT;
    public static int DT_RIGHT;
    public static int DT_VCENTER;
    public static int DT_SINGLELINE;
    public static int DT_NOCLIP;
    public static int DT_CALCRECT;
    public static int DT_NOPREFIX;
    public static int DT_EDITCONTROL;
    public static int DT_EXPANDTABS;
    public static int DT_END_ELLIPSIS;
    public static int DT_RTLREADING;
    public static int DT_WORDBREAK;
    public static int DCX_WINDOW;
    public static int DCX_CACHE;
    public static int DCX_LOCKWINDOWUPDATE;
    public static int DI_NORMAL;
    public static int DLGC_WANTARROWS;
    public static int DLGC_WANTTAB;
    public static int DLGC_WANTALLKEYS;
    public static int DLGC_WANTCHARS;
    public static int DTM_GETSYSTEMTIME;
    public static int DTM_SETSYSTEMTIME;
    public static int DTM_SETRANGE;
    public static int DTM_SETFORMATA;
    public static int DTM_SETFORMATW;
    public static int DTM_SETMCCOLOR;
    public static int DTM_SETMCFONT;
    public static int DTS_UPDOWN;
    public static int DTS_SHOWNONE;
    public static int DTS_LONGDATEFORMAT;
    public static int DTS_TIMEFORMAT;
    public static int DTS_RIGHTALIGN;
    public static int DTN_DATETIMECHANGE;
    public static int DTN_USERSTRINGA;
    public static int DTN_USERSTRINGW;
    public static int DTN_WMKEYDOWNA;
    public static int DTN_WMKEYDOWNW;
    public static int DTN_FORMATA;
    public static int DTN_FORMATW;
    public static int DTN_FORMATQUERYA;
    public static int DTN_FORMATQUERYW;
    public static int DTN_DROPDOWN;
    public static int DTN_CLOSEUP;
    public static int DVASPECT_CONTENT;
    public static int DVASPECT_TRANSPARENT;
    public static int DVASPECT_OPAQUE;
    public static int E_NOTIMPL;
    public static int E_OUTOFMEMORY;
    public static int E_INVALIDARG;
    public static int E_NOINTERFACE;
    public static int E_FAIL;
    public static int E_ABORT;
    public static int E_ACCESSDENIED;
    public static int E_UNEXPECTED;
    public static int INET_E_DEFAULT_ACTION;
    public static int ETO_OPAQUE;
    public static int ETO_CLIPPED;
    public static int EMR_POLYTEXTOUTA;
    public static int EMR_POLYTEXTOUTW;
    public static int EDGE_RAISED;
    public static int EDGE_SUNKEN;
    public static int EDGE_ETCHED;
    public static int EDGE_BUMP;
    public static int ES_LEFT;
    public static int ES_CENTER;
    public static int ES_RIGHT;
    public static int ES_MULTILINE;
    public static int ES_UPPERCASE;
    public static int ES_LOWERCASE;
    public static int ES_AUTOVSCROLL;
    public static int ES_AUTOHSCROLL;
    public static int ES_NOHIDESEL;
    public static int ES_READONLY;
    public static int ES_PASSWORD;
    public static int EN_CHANGE;
    public static int EN_UPDATE;
    public static int EN_HSCROLL;
    public static int EN_VSCROLL;
    public static int EN_ALIGN_LTR_EC;
    public static int EN_ALIGN_RTL_EC;
    public static int EC_LEFTMARGIN;
    public static int EC_RIGHTMARGIN;
    public static int EM_GETSEL;
    public static int EM_SETSEL;
    public static int EM_SCROLL;
    public static int EM_SCROLLCARET;
    public static int EM_GETMODIFY;
    public static int EM_SETMODIFY;
    public static int EM_GETLINECOUNT;
    public static int EM_REPLACESEL;
    public static int EM_GETLINE;
    public static int EM_LIMITTEXT;
    public static int EM_CANUNDO;
    public static int EM_UNDO;
    public static int EM_SETPASSWORDCHAR;
    public static int EM_GETPASSWORDCHAR;
    public static int EM_EMPTYUNDOBUFFER;
    public static int EM_SETREADONLY;
    public static int EM_SETMARGINS;
    public static int EM_POSFROMCHAR;
    public static int EM_CHARFROMPOS;
    public static int EM_LINEFROMCHAR;
    public static int EM_LINEINDEX;
    public static int FNERR_SUBCLASSFAILURE;
    public static int FNERR_INVALIDFILENAME;
    public static int FNERR_BUFFERTOOSMALL;
    public static int GMEM_MOVEABLE;
    public static int GMEM_ZEROINIT;
    public static int GMEM_DDESHARE;
    public static int GCL_WNDPROC;
    public static int GWL_WNDPROC;
    public static int GWL_HWNDPARENT;
    public static int GWL_STYLE;
    public static int GWL_EXSTYLE;
    public static int GWL_ID;
    public static int GW_HWNDFIRST;
    public static int GW_HWNDLAST;
    public static int GW_HWNDNEXT;
    public static int GW_HWNDPREV;
    public static int GW_OWNER;
    public static int GW_CHILD;
    public static int GMR_VISIBLE;
    public static int GMR_DAYSTATE;
    public static int GDI_ERROR;
    public static int GDTR_MIN;
    public static int GDTR_MAX;
    public static int GDT_VALID;
    public static int GDT_NONE;
    public static int GA_PARENT;
    public static int GA_ROOT;
    public static int GCS_COMPREADSTR;
    public static int GCS_COMPREADATTR;
    public static int GCS_COMPREADCLAUSE;
    public static int GCS_COMPSTR;
    public static int GCS_COMPATTR;
    public static int GCS_COMPCLAUSE;
    public static int GCS_CURSORPOS;
    public static int GCS_DELTASTART;
    public static int GCS_RESULTREADSTR;
    public static int GCS_RESULTREADCLAUSE;
    public static int GCS_RESULTSTR;
    public static int GCS_RESULTCLAUSE;
    public static int ATTR_INPUT;
    public static int ATTR_TARGET_CONVERTED;
    public static int ATTR_CONVERTED;
    public static int ATTR_TARGET_NOTCONVERTED;
    public static int ATTR_INPUT_ERROR;
    public static int ATTR_FIXEDCONVERTED;
    public static int NI_COMPOSITIONSTR;
    public static int IMN_CLOSESTATUSWINDOW;
    public static int IMN_OPENSTATUSWINDOW;
    public static int IMN_CHANGECANDIDATE;
    public static int IMN_CLOSECANDIDATE;
    public static int IMN_OPENCANDIDATE;
    public static int IMN_SETCONVERSIONMODE;
    public static int IMN_SETSENTENCEMODE;
    public static int IMN_SETOPENSTATUS;
    public static int IMN_SETCANDIDATEPOS;
    public static int IMN_SETCOMPOSITIONFONT;
    public static int IMN_SETCOMPOSITIONWINDOW;
    public static int IMN_SETSTATUSWINDOWPOS;
    public static int IMN_GUIDELINE;
    public static int IMN_PRIVATE;
    public static int CPS_COMPLETE;
    public static int CPS_CANCEL;
    public static int CFS_DEFAULT;
    public static int CFS_RECT;
    public static int CFS_POINT;
    public static int CFS_FORCE_POSITION;
    public static int CFS_CANDIDATEPOS;
    public static int CFS_EXCLUDE;
    public static int IME_CMODE_ALPHANUMERIC;
    public static int IME_CMODE_NATIVE;
    public static int IME_CMODE_CHINESE;
    public static int IME_CMODE_HANGEUL;
    public static int IME_CMODE_HANGUL;
    public static int IME_CMODE_JAPANESE;
    public static int IME_CMODE_KATAKANA;
    public static int IME_CMODE_LANGUAGE;
    public static int IME_CMODE_FULLSHAPE;
    public static int IME_CMODE_ROMAN;
    public static int IME_CMODE_CHARCODE;
    public static int IME_CMODE_HANJACONVERT;
    public static int IME_CMODE_SOFTKBD;
    public static int IME_CMODE_NOCONVERSION;
    public static int IME_CMODE_EUDC;
    public static int IME_CMODE_SYMBOL;
    public static int IME_CMODE_FIXED;
    public static int IME_CMODE_RESERVED;
    public static int IME_SMODE_NONE;
    public static int IME_SMODE_PLAURALCLAUSE;
    public static int IME_SMODE_SINGLECONVERT;
    public static int IME_SMODE_AUTOMATIC;
    public static int IME_SMODE_PHRASEPREDICT;
    public static int IME_SMODE_CONVERSATION;
    public static int IME_SMODE_RESERVED;
    public static int IME_CAND_UNKNOWN;
    public static int IME_CAND_READ;
    public static int IME_CAND_CODE;
    public static int IME_CAND_MEANING;
    public static int IME_CAND_RADICAL;
    public static int IME_CAND_STROKE;
    public static int IMR_COMPOSITIONWINDOW;
    public static int IMR_CANDIDATEWINDOW;
    public static int IMR_COMPOSITIONFONT;
    public static int IMR_RECONVERTSTRING;
    public static int IMR_CONFIRMRECONVERTSTRING;
    public static int IMR_QUERYCHARPOSITION;
    public static int IMR_DOCUMENTFEED;
    public static int IME_CONFIG_GENERAL;
    public static int IME_CONFIG_REGISTERWORD;
    public static int IME_CONFIG_SELECTDICTIONARY;
    public static int IGP_GETIMEVERSION;
    public static int IGP_PROPERTY;
    public static int IGP_CONVERSION;
    public static int IGP_SENTENCE;
    public static int IGP_UI;
    public static int IGP_SETCOMPSTR;
    public static int IGP_SELECT;
    public static int IME_PROP_AT_CARET;
    public static int IME_PROP_SPECIAL_UI;
    public static int IME_PROP_CANDLIST_START_FROM_1;
    public static int IME_PROP_UNICODE;
    public static int IME_PROP_COMPLETE_ON_UNSELECT;
    public static int HC_ACTION;
    public static int HC_GETNEXT;
    public static int HC_SKIP;
    public static int HTNOWHERE;
    public static int HTCLIENT;
    public static int HTBOTTOM;
    public static int HTTRANSPARENT;
    public static int HTBOTTOMLEFT;
    public static int HTBOTTOMRIGHT;
    public static int HELPINFO_WINDOW;
    public static int HCF_HIGHCONTRASTON;
    public static int HDI_ORDER;
    public static int HDI_WIDTH;
    public static int HDM_GETITEMCOUNT;
    public static int HDM_INSERTITEMA;
    public static int HDM_INSERTITEMW;
    public static int HDM_GETITEMA;
    public static int HDM_GETITEMW;
    public static int HDM_SETITEMA;
    public static int HDM_SETITEMW;
    public static int HDN_ITEMCHANGINGA;
    public static int HDN_ITEMCHANGINGW;
    public static int HDN_ITEMCHANGEDA;
    public static int HDN_ITEMCHANGEDW;
    public static int HDN_ITEMCLICKA;
    public static int HDN_ITEMCLICKW;
    public static int HDN_ITEMDBLCLICKA;
    public static int HDN_ITEMDBLCLICKW;
    public static int HDN_DIVIDERDBLCLICKA;
    public static int HDN_DIVIDERDBLCLICKW;
    public static int HDN_BEGINTDRAG;
    public static int HDN_BEGINTRACKA;
    public static int HDN_BEGINTRACKW;
    public static int HDN_ENDDRAG;
    public static int HDN_ENDTRACKA;
    public static int HDN_ENDTRACKW;
    public static int HDN_TRACKA;
    public static int HDN_TRACKW;
    public static int HDN_GETDISPINFOA;
    public static int HDN_GETDISPINFOW;
    public static HandleRef HWND_TOP;
    public static HandleRef HWND_BOTTOM;
    public static HandleRef HWND_TOPMOST;
    public static HandleRef HWND_NOTOPMOST;
    public static int INPLACE_E_NOTOOLSPACE;
    public static int ICON_SMALL;
    public static int ICON_BIG;
    public static int IDC_ARROW;
    public static int IDC_IBEAM;
    public static int IDC_WAIT;
    public static int IDC_CROSS;
    public static int IDC_SIZEALL;
    public static int IDC_SIZENWSE;
    public static int IDC_SIZENESW;
    public static int IDC_SIZEWE;
    public static int IDC_SIZENS;
    public static int IDC_UPARROW;
    public static int IDC_NO;
    public static int IDC_APPSTARTING;
    public static int IDC_HELP;
    public static int IMAGE_ICON;
    public static int IMAGE_CURSOR;
    public static int ICC_LISTVIEW_CLASSES;
    public static int ICC_TREEVIEW_CLASSES;
    public static int ICC_BAR_CLASSES;
    public static int ICC_TAB_CLASSES;
    public static int ICC_PROGRESS_CLASS;
    public static int ICC_DATE_CLASSES;
    public static int ILC_MASK;
    public static int ILC_COLOR;
    public static int ILC_COLOR4;
    public static int ILC_COLOR8;
    public static int ILC_COLOR16;
    public static int ILC_COLOR24;
    public static int ILC_COLOR32;
    public static int ILC_MIRROR;
    public static int ILD_NORMAL;
    public static int ILD_TRANSPARENT;
    public static int ILD_MASK;
    public static int ILD_ROP;
    public static int ILP_NORMAL;
    public static int ILP_DOWNLEVEL;
    public static int ILS_NORMAL;
    public static int ILS_GLOW;
    public static int ILS_SHADOW;
    public static int ILS_SATURATE;
    public static int ILS_ALPHA;
    public static int CSC_NAVIGATEFORWARD;
    public static int CSC_NAVIGATEBACK;
    public static int STG_E_CANTSAVE;
    public static int LOGPIXELSX;
    public static int LOGPIXELSY;
    public static int LB_ERR;
    public static int LB_ERRSPACE;
    public static int LBN_SELCHANGE;
    public static int LBN_DBLCLK;
    public static int LB_ADDSTRING;
    public static int LB_INSERTSTRING;
    public static int LB_DELETESTRING;
    public static int LB_RESETCONTENT;
    public static int LB_SETSEL;
    public static int LB_SETCURSEL;
    public static int LB_GETSEL;
    public static int LB_GETCARETINDEX;
    public static int LB_GETCURSEL;
    public static int LB_GETTEXT;
    public static int LB_GETTEXTLEN;
    public static int LB_GETTOPINDEX;
    public static int LB_FINDSTRING;
    public static int LB_GETSELCOUNT;
    public static int LB_GETSELITEMS;
    public static int LB_SETTABSTOPS;
    public static int LB_SETHORIZONTALEXTENT;
    public static int LB_SETCOLUMNWIDTH;
    public static int LB_SETTOPINDEX;
    public static int LB_GETITEMRECT;
    public static int LB_SETITEMHEIGHT;
    public static int LB_GETITEMHEIGHT;
    public static int LB_FINDSTRINGEXACT;
    public static int LB_ITEMFROMPOINT;
    public static int LB_SETLOCALE;
    public static int LWA_ALPHA;
    public static int MEMBERID_NIL;
    public static int MAX_PATH;
    public static int MA_ACTIVATE;
    public static int MA_ACTIVATEANDEAT;
    public static int MA_NOACTIVATE;
    public static int MA_NOACTIVATEANDEAT;
    public static int MM_TEXT;
    public static int MM_ANISOTROPIC;
    public static int MK_LBUTTON;
    public static int MK_RBUTTON;
    public static int MK_SHIFT;
    public static int MK_CONTROL;
    public static int MK_MBUTTON;
    public static int MNC_EXECUTE;
    public static int MNC_SELECT;
    public static int MIIM_STATE;
    public static int MIIM_ID;
    public static int MIIM_SUBMENU;
    public static int MIIM_TYPE;
    public static int MIIM_DATA;
    public static int MIIM_STRING;
    public static int MIIM_BITMAP;
    public static int MIIM_FTYPE;
    public static int MB_OK;
    public static int MF_BYCOMMAND;
    public static int MF_BYPOSITION;
    public static int MF_ENABLED;
    public static int MF_GRAYED;
    public static int MF_POPUP;
    public static int MF_SYSMENU;
    public static int MFS_DISABLED;
    public static int MFT_MENUBREAK;
    public static int MFT_SEPARATOR;
    public static int MFT_RIGHTORDER;
    public static int MFT_RIGHTJUSTIFY;
    public static int MDIS_ALLCHILDSTYLES;
    public static int MDITILE_VERTICAL;
    public static int MDITILE_HORIZONTAL;
    public static int MDITILE_SKIPDISABLED;
    public static int MCM_SETMAXSELCOUNT;
    public static int MCM_SETSELRANGE;
    public static int MCM_GETMONTHRANGE;
    public static int MCM_GETMINREQRECT;
    public static int MCM_SETCOLOR;
    public static int MCM_SETTODAY;
    public static int MCM_GETTODAY;
    public static int MCM_HITTEST;
    public static int MCM_SETFIRSTDAYOFWEEK;
    public static int MCM_SETRANGE;
    public static int MCM_SETMONTHDELTA;
    public static int MCM_GETMAXTODAYWIDTH;
    public static int MCHT_TITLE;
    public static int MCHT_CALENDAR;
    public static int MCHT_TODAYLINK;
    public static int MCHT_TITLEBK;
    public static int MCHT_TITLEMONTH;
    public static int MCHT_TITLEYEAR;
    public static int MCHT_TITLEBTNNEXT;
    public static int MCHT_TITLEBTNPREV;
    public static int MCHT_CALENDARBK;
    public static int MCHT_CALENDARDATE;
    public static int MCHT_CALENDARDATENEXT;
    public static int MCHT_CALENDARDATEPREV;
    public static int MCHT_CALENDARDAY;
    public static int MCHT_CALENDARWEEKNUM;
    public static int MCSC_TEXT;
    public static int MCSC_TITLEBK;
    public static int MCSC_TITLETEXT;
    public static int MCSC_MONTHBK;
    public static int MCSC_TRAILINGTEXT;
    public static int MCN_SELCHANGE;
    public static int MCN_GETDAYSTATE;
    public static int MCN_SELECT;
    public static int MCS_DAYSTATE;
    public static int MCS_MULTISELECT;
    public static int MCS_WEEKNUMBERS;
    public static int MCS_NOTODAYCIRCLE;
    public static int MCS_NOTODAY;
    public static int MSAA_MENU_SIG;
    public static int OLECONTF_EMBEDDINGS;
    public static int OLECONTF_LINKS;
    public static int OLECONTF_OTHERS;
    public static int OLECONTF_ONLYUSER;
    public static int OLECONTF_ONLYIFRUNNING;
    public static int OLEMISC_RECOMPOSEONRESIZE;
    public static int OLEMISC_INSIDEOUT;
    public static int OLEMISC_ACTIVATEWHENVISIBLE;
    public static int OLEMISC_ACTSLIKEBUTTON;
    public static int OLEMISC_SETCLIENTSITEFIRST;
    public static int OLEIVERB_PRIMARY;
    public static int OLEIVERB_SHOW;
    public static int OLEIVERB_HIDE;
    public static int OLEIVERB_UIACTIVATE;
    public static int OLEIVERB_INPLACEACTIVATE;
    public static int OLEIVERB_DISCARDUNDOSTATE;
    public static int OLEIVERB_PROPERTIES;
    public static int XFORMCOORDS_POSITION;
    public static int XFORMCOORDS_SIZE;
    public static int XFORMCOORDS_HIMETRICTOCONTAINER;
    public static int XFORMCOORDS_CONTAINERTOHIMETRIC;
    public static int OFN_READONLY;
    public static int OFN_OVERWRITEPROMPT;
    public static int OFN_HIDEREADONLY;
    public static int OFN_NOCHANGEDIR;
    public static int OFN_ENABLEHOOK;
    public static int OFN_NOVALIDATE;
    public static int OFN_ALLOWMULTISELECT;
    public static int OFN_PATHMUSTEXIST;
    public static int OFN_FILEMUSTEXIST;
    public static int OFN_CREATEPROMPT;
    public static int OFN_EXPLORER;
    public static int OFN_NODEREFERENCELINKS;
    public static int OFN_ENABLESIZING;
    public static int OFN_USESHELLITEM;
    public static int PDERR_SETUPFAILURE;
    public static int PDERR_PARSEFAILURE;
    public static int PDERR_RETDEFFAILURE;
    public static int PDERR_LOADDRVFAILURE;
    public static int PDERR_GETDEVMODEFAIL;
    public static int PDERR_INITFAILURE;
    public static int PDERR_NODEVICES;
    public static int PDERR_NODEFAULTPRN;
    public static int PDERR_DNDMMISMATCH;
    public static int PDERR_CREATEICFAILURE;
    public static int PDERR_PRINTERNOTFOUND;
    public static int PDERR_DEFAULTDIFFERENT;
    public static int PD_ALLPAGES;
    public static int PD_SELECTION;
    public static int PD_PAGENUMS;
    public static int PD_NOSELECTION;
    public static int PD_NOPAGENUMS;
    public static int PD_COLLATE;
    public static int PD_PRINTTOFILE;
    public static int PD_PRINTSETUP;
    public static int PD_NOWARNING;
    public static int PD_RETURNDC;
    public static int PD_RETURNIC;
    public static int PD_RETURNDEFAULT;
    public static int PD_SHOWHELP;
    public static int PD_ENABLEPRINTHOOK;
    public static int PD_ENABLESETUPHOOK;
    public static int PD_ENABLEPRINTTEMPLATE;
    public static int PD_ENABLESETUPTEMPLATE;
    public static int PD_ENABLEPRINTTEMPLATEHANDLE;
    public static int PD_ENABLESETUPTEMPLATEHANDLE;
    public static int PD_USEDEVMODECOPIES;
    public static int PD_USEDEVMODECOPIESANDCOLLATE;
    public static int PD_DISABLEPRINTTOFILE;
    public static int PD_HIDEPRINTTOFILE;
    public static int PD_NONETWORKBUTTON;
    public static int PD_CURRENTPAGE;
    public static int PD_NOCURRENTPAGE;
    public static int PD_EXCLUSIONFLAGS;
    public static int PD_USELARGETEMPLATE;
    public static int PSD_MINMARGINS;
    public static int PSD_MARGINS;
    public static int PSD_INHUNDREDTHSOFMILLIMETERS;
    public static int PSD_DISABLEMARGINS;
    public static int PSD_DISABLEPRINTER;
    public static int PSD_DISABLEORIENTATION;
    public static int PSD_DISABLEPAPER;
    public static int PSD_SHOWHELP;
    public static int PSD_ENABLEPAGESETUPHOOK;
    public static int PSD_NONETWORKBUTTON;
    public static int PS_SOLID;
    public static int PS_DOT;
    public static int PLANES;
    public static int PRF_CHECKVISIBLE;
    public static int PRF_NONCLIENT;
    public static int PRF_CLIENT;
    public static int PRF_ERASEBKGND;
    public static int PRF_CHILDREN;
    public static int PM_NOREMOVE;
    public static int PM_REMOVE;
    public static int PM_NOYIELD;
    public static int PBM_SETRANGE;
    public static int PBM_SETPOS;
    public static int PBM_SETSTEP;
    public static int PBM_SETRANGE32;
    public static int PBM_SETBARCOLOR;
    public static int PBM_SETBKCOLOR;
    public static int PSM_SETTITLEA;
    public static int PSM_SETTITLEW;
    public static int PSM_SETFINISHTEXTA;
    public static int PSM_SETFINISHTEXTW;
    public static int PATCOPY;
    public static int PATINVERT;
    public static int QS_KEY;
    public static int QS_MOUSEMOVE;
    public static int QS_MOUSEBUTTON;
    public static int QS_POSTMESSAGE;
    public static int QS_TIMER;
    public static int QS_PAINT;
    public static int QS_SENDMESSAGE;
    public static int QS_HOTKEY;
    public static int QS_ALLPOSTMESSAGE;
    public static int QS_MOUSE;
    public static int QS_INPUT;
    public static int QS_ALLEVENTS;
    public static int QS_ALLINPUT;
    public static int RDW_INVALIDATE;
    public static int RDW_ALLCHILDREN;
    public static int stc4;
    public static int SHGFP_TYPE_CURRENT;
    public static int STGM_READ;
    public static int STGM_WRITE;
    public static int STGM_READWRITE;
    public static int STGM_SHARE_EXCLUSIVE;
    public static int STGM_CREATE;
    public static int STGM_TRANSACTED;
    public static int STGM_CONVERT;
    public static int STGM_DELETEONRELEASE;
    public static int STGTY_STORAGE;
    public static int STGTY_STREAM;
    public static int STGTY_LOCKBYTES;
    public static int STGTY_PROPERTY;
    public static int STARTF_USESHOWWINDOW;
    public static int SB_HORZ;
    public static int SB_VERT;
    public static int SB_CTL;
    public static int SB_LINEUP;
    public static int SB_LINELEFT;
    public static int SB_LINEDOWN;
    public static int SB_LINERIGHT;
    public static int SB_PAGEUP;
    public static int SB_PAGELEFT;
    public static int SB_PAGEDOWN;
    public static int SB_PAGERIGHT;
    public static int SB_THUMBPOSITION;
    public static int SB_THUMBTRACK;
    public static int SB_LEFT;
    public static int SB_RIGHT;
    public static int SB_ENDSCROLL;
    public static int SB_TOP;
    public static int SB_BOTTOM;
    public static int SIZE_MAXIMIZED;
    public static int ESB_ENABLE_BOTH;
    public static int ESB_DISABLE_BOTH;
    public static int SORT_DEFAULT;
    public static int SUBLANG_DEFAULT;
    public static int SW_HIDE;
    public static int SW_NORMAL;
    public static int SW_SHOWMINIMIZED;
    public static int SW_SHOWMAXIMIZED;
    public static int SW_MAXIMIZE;
    public static int SW_SHOWNOACTIVATE;
    public static int SW_SHOW;
    public static int SW_MINIMIZE;
    public static int SW_SHOWMINNOACTIVE;
    public static int SW_SHOWNA;
    public static int SW_RESTORE;
    public static int SW_MAX;
    public static int SWP_NOSIZE;
    public static int SWP_NOMOVE;
    public static int SWP_NOZORDER;
    public static int SWP_NOACTIVATE;
    public static int SWP_SHOWWINDOW;
    public static int SWP_HIDEWINDOW;
    public static int SWP_DRAWFRAME;
    public static int MB_ICONHAND;
    public static int MB_ICONQUESTION;
    public static int MB_ICONEXCLAMATION;
    public static int MB_ICONASTERISK;
    public static int SW_SCROLLCHILDREN;
    public static int SW_INVALIDATE;
    public static int SW_ERASE;
    public static int SW_SMOOTHSCROLL;
    public static int SC_SIZE;
    public static int SC_MINIMIZE;
    public static int SC_MAXIMIZE;
    public static int SC_CLOSE;
    public static int SC_KEYMENU;
    public static int SC_RESTORE;
    public static int SC_MOVE;
    public static int SS_LEFT;
    public static int SS_CENTER;
    public static int SS_RIGHT;
    public static int SS_OWNERDRAW;
    public static int SS_NOPREFIX;
    public static int SS_SUNKEN;
    public static int SBS_HORZ;
    public static int SBS_VERT;
    public static int SIF_RANGE;
    public static int SIF_PAGE;
    public static int SIF_POS;
    public static int SIF_TRACKPOS;
    public static int SIF_ALL;
    public static int SPI_GETFONTSMOOTHING;
    public static int SPI_GETDROPSHADOW;
    public static int SPI_GETFLATMENU;
    public static int SPI_GETFONTSMOOTHINGTYPE;
    public static int SPI_GETFONTSMOOTHINGCONTRAST;
    public static int SPI_ICONHORIZONTALSPACING;
    public static int SPI_ICONVERTICALSPACING;
    public static int SPI_GETICONMETRICS;
    public static int SPI_GETICONTITLEWRAP;
    public static int SPI_GETICONTITLELOGFONT;
    public static int SPI_GETKEYBOARDCUES;
    public static int SPI_GETKEYBOARDDELAY;
    public static int SPI_GETKEYBOARDPREF;
    public static int SPI_GETKEYBOARDSPEED;
    public static int SPI_GETMOUSEHOVERWIDTH;
    public static int SPI_GETMOUSEHOVERHEIGHT;
    public static int SPI_GETMOUSEHOVERTIME;
    public static int SPI_GETMOUSESPEED;
    public static int SPI_GETMENUDROPALIGNMENT;
    public static int SPI_GETMENUFADE;
    public static int SPI_GETMENUSHOWDELAY;
    public static int SPI_GETCOMBOBOXANIMATION;
    public static int SPI_GETCLIENTAREAANIMATION;
    public static int SPI_GETGRADIENTCAPTIONS;
    public static int SPI_GETHOTTRACKING;
    public static int SPI_GETLISTBOXSMOOTHSCROLLING;
    public static int SPI_GETMENUANIMATION;
    public static int SPI_GETSELECTIONFADE;
    public static int SPI_GETTOOLTIPANIMATION;
    public static int SPI_GETUIEFFECTS;
    public static int SPI_GETACTIVEWINDOWTRACKING;
    public static int SPI_GETACTIVEWNDTRKTIMEOUT;
    public static int SPI_GETANIMATION;
    public static int SPI_GETBORDER;
    public static int SPI_GETCARETWIDTH;
    public static int SPI_GETMOUSEVANISH;
    public static int SPI_GETDRAGFULLWINDOWS;
    public static int SPI_GETNONCLIENTMETRICS;
    public static int SPI_GETWORKAREA;
    public static int SPI_GETHIGHCONTRAST;
    public static int SPI_GETDEFAULTINPUTLANG;
    public static int SPI_GETSNAPTODEFBUTTON;
    public static int SPI_GETWHEELSCROLLLINES;
    public static int SBARS_SIZEGRIP;
    public static int SB_SETTEXTA;
    public static int SB_SETTEXTW;
    public static int SB_GETTEXTA;
    public static int SB_GETTEXTW;
    public static int SB_GETTEXTLENGTHA;
    public static int SB_GETTEXTLENGTHW;
    public static int SB_SETPARTS;
    public static int SB_SIMPLE;
    public static int SB_GETRECT;
    public static int SB_SETICON;
    public static int SB_SETTIPTEXTA;
    public static int SB_SETTIPTEXTW;
    public static int SB_GETTIPTEXTA;
    public static int SB_GETTIPTEXTW;
    public static int SBT_OWNERDRAW;
    public static int SBT_NOBORDERS;
    public static int SBT_POPOUT;
    public static int SBT_RTLREADING;
    public static int SRCCOPY;
    public static int SRCAND;
    public static int SRCPAINT;
    public static int NOTSRCCOPY;
    public static int STATFLAG_DEFAULT;
    public static int STATFLAG_NONAME;
    public static int STATFLAG_NOOPEN;
    public static int STGC_DEFAULT;
    public static int STGC_OVERWRITE;
    public static int STGC_ONLYIFCURRENT;
    public static int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE;
    public static int STREAM_SEEK_SET;
    public static int STREAM_SEEK_CUR;
    public static int STREAM_SEEK_END;
    public static int S_OK;
    public static int S_FALSE;
    public static int TRANSPARENT;
    public static int OPAQUE;
    public static int TME_HOVER;
    public static int TME_LEAVE;
    public static int TPM_LEFTBUTTON;
    public static int TPM_RIGHTBUTTON;
    public static int TPM_LEFTALIGN;
    public static int TPM_RIGHTALIGN;
    public static int TPM_VERTICAL;
    public static int TV_FIRST;
    public static int TBSTATE_CHECKED;
    public static int TBSTATE_ENABLED;
    public static int TBSTATE_HIDDEN;
    public static int TBSTATE_INDETERMINATE;
    public static int TBSTYLE_BUTTON;
    public static int TBSTYLE_SEP;
    public static int TBSTYLE_CHECK;
    public static int TBSTYLE_DROPDOWN;
    public static int TBSTYLE_TOOLTIPS;
    public static int TBSTYLE_FLAT;
    public static int TBSTYLE_LIST;
    public static int TBSTYLE_EX_DRAWDDARROWS;
    public static int TB_ENABLEBUTTON;
    public static int TB_ISBUTTONCHECKED;
    public static int TB_ISBUTTONINDETERMINATE;
    public static int TB_ADDBUTTONSA;
    public static int TB_ADDBUTTONSW;
    public static int TB_INSERTBUTTONA;
    public static int TB_INSERTBUTTONW;
    public static int TB_DELETEBUTTON;
    public static int TB_GETBUTTON;
    public static int TB_SAVERESTOREA;
    public static int TB_SAVERESTOREW;
    public static int TB_ADDSTRINGA;
    public static int TB_ADDSTRINGW;
    public static int TB_BUTTONSTRUCTSIZE;
    public static int TB_SETBUTTONSIZE;
    public static int TB_AUTOSIZE;
    public static int TB_GETROWS;
    public static int TB_GETBUTTONTEXTA;
    public static int TB_GETBUTTONTEXTW;
    public static int TB_SETIMAGELIST;
    public static int TB_GETRECT;
    public static int TB_GETBUTTONSIZE;
    public static int TB_GETBUTTONINFOW;
    public static int TB_SETBUTTONINFOW;
    public static int TB_GETBUTTONINFOA;
    public static int TB_SETBUTTONINFOA;
    public static int TB_MAPACCELERATORA;
    public static int TB_SETEXTENDEDSTYLE;
    public static int TB_MAPACCELERATORW;
    public static int TB_GETTOOLTIPS;
    public static int TB_SETTOOLTIPS;
    public static int TBIF_IMAGE;
    public static int TBIF_TEXT;
    public static int TBIF_STATE;
    public static int TBIF_STYLE;
    public static int TBIF_COMMAND;
    public static int TBIF_SIZE;
    public static int TBN_GETBUTTONINFOA;
    public static int TBN_GETBUTTONINFOW;
    public static int TBN_QUERYINSERT;
    public static int TBN_DROPDOWN;
    public static int TBN_HOTITEMCHANGE;
    public static int TBN_GETDISPINFOA;
    public static int TBN_GETDISPINFOW;
    public static int TBN_GETINFOTIPA;
    public static int TBN_GETINFOTIPW;
    public static int TTS_ALWAYSTIP;
    public static int TTS_NOPREFIX;
    public static int TTS_NOANIMATE;
    public static int TTS_NOFADE;
    public static int TTS_BALLOON;
    public static int TTI_WARNING;
    public static int TTF_IDISHWND;
    public static int TTF_RTLREADING;
    public static int TTF_TRACK;
    public static int TTF_CENTERTIP;
    public static int TTF_SUBCLASS;
    public static int TTF_TRANSPARENT;
    public static int TTF_ABSOLUTE;
    public static int TTDT_AUTOMATIC;
    public static int TTDT_RESHOW;
    public static int TTDT_AUTOPOP;
    public static int TTDT_INITIAL;
    public static int TTM_TRACKACTIVATE;
    public static int TTM_TRACKPOSITION;
    public static int TTM_ACTIVATE;
    public static int TTM_POP;
    public static int TTM_ADJUSTRECT;
    public static int TTM_SETDELAYTIME;
    public static int TTM_SETTITLEA;
    public static int TTM_SETTITLEW;
    public static int TTM_ADDTOOLA;
    public static int TTM_ADDTOOLW;
    public static int TTM_DELTOOLA;
    public static int TTM_DELTOOLW;
    public static int TTM_NEWTOOLRECTA;
    public static int TTM_NEWTOOLRECTW;
    public static int TTM_RELAYEVENT;
    public static int TTM_GETTIPBKCOLOR;
    public static int TTM_SETTIPBKCOLOR;
    public static int TTM_SETTIPTEXTCOLOR;
    public static int TTM_GETTIPTEXTCOLOR;
    public static int TTM_GETTOOLINFOA;
    public static int TTM_GETTOOLINFOW;
    public static int TTM_SETTOOLINFOA;
    public static int TTM_SETTOOLINFOW;
    public static int TTM_HITTESTA;
    public static int TTM_HITTESTW;
    public static int TTM_GETTEXTA;
    public static int TTM_GETTEXTW;
    public static int TTM_UPDATE;
    public static int TTM_UPDATETIPTEXTA;
    public static int TTM_UPDATETIPTEXTW;
    public static int TTM_ENUMTOOLSA;
    public static int TTM_ENUMTOOLSW;
    public static int TTM_GETCURRENTTOOLA;
    public static int TTM_GETCURRENTTOOLW;
    public static int TTM_WINDOWFROMPOINT;
    public static int TTM_GETDELAYTIME;
    public static int TTM_SETMAXTIPWIDTH;
    public static int TTN_GETDISPINFOA;
    public static int TTN_GETDISPINFOW;
    public static int TTN_SHOW;
    public static int TTN_POP;
    public static int TTN_NEEDTEXTA;
    public static int TTN_NEEDTEXTW;
    public static int TBS_AUTOTICKS;
    public static int TBS_VERT;
    public static int TBS_TOP;
    public static int TBS_BOTTOM;
    public static int TBS_BOTH;
    public static int TBS_NOTICKS;
    public static int TBM_GETPOS;
    public static int TBM_SETTIC;
    public static int TBM_SETPOS;
    public static int TBM_SETRANGE;
    public static int TBM_SETRANGEMIN;
    public static int TBM_SETRANGEMAX;
    public static int TBM_SETTICFREQ;
    public static int TBM_SETPAGESIZE;
    public static int TBM_SETLINESIZE;
    public static int TB_LINEUP;
    public static int TB_LINEDOWN;
    public static int TB_PAGEUP;
    public static int TB_PAGEDOWN;
    public static int TB_THUMBPOSITION;
    public static int TB_THUMBTRACK;
    public static int TB_TOP;
    public static int TB_BOTTOM;
    public static int TB_ENDTRACK;
    public static int TVS_HASBUTTONS;
    public static int TVS_HASLINES;
    public static int TVS_LINESATROOT;
    public static int TVS_EDITLABELS;
    public static int TVS_SHOWSELALWAYS;
    public static int TVS_RTLREADING;
    public static int TVS_CHECKBOXES;
    public static int TVS_TRACKSELECT;
    public static int TVS_FULLROWSELECT;
    public static int TVS_NONEVENHEIGHT;
    public static int TVS_INFOTIP;
    public static int TVS_NOTOOLTIPS;
    public static int TVIF_TEXT;
    public static int TVIF_IMAGE;
    public static int TVIF_PARAM;
    public static int TVIF_STATE;
    public static int TVIF_HANDLE;
    public static int TVIF_SELECTEDIMAGE;
    public static int TVIS_SELECTED;
    public static int TVIS_EXPANDED;
    public static int TVIS_EXPANDEDONCE;
    public static int TVIS_STATEIMAGEMASK;
    public static int TVI_ROOT;
    public static int TVI_FIRST;
    public static int TVM_INSERTITEMA;
    public static int TVM_INSERTITEMW;
    public static int TVM_DELETEITEM;
    public static int TVM_EXPAND;
    public static int TVE_COLLAPSE;
    public static int TVE_EXPAND;
    public static int TVM_GETITEMRECT;
    public static int TVM_GETINDENT;
    public static int TVM_SETINDENT;
    public static int TVM_SETIMAGELIST;
    public static int TVM_GETNEXTITEM;
    public static int TVGN_NEXT;
    public static int TVGN_PREVIOUS;
    public static int TVGN_FIRSTVISIBLE;
    public static int TVGN_NEXTVISIBLE;
    public static int TVGN_PREVIOUSVISIBLE;
    public static int TVGN_CARET;
    public static int TVM_SELECTITEM;
    public static int TVM_GETITEMA;
    public static int TVM_GETITEMW;
    public static int TVM_SETITEMA;
    public static int TVM_SETITEMW;
    public static int TVM_EDITLABELA;
    public static int TVM_EDITLABELW;
    public static int TVM_GETEDITCONTROL;
    public static int TVM_GETVISIBLECOUNT;
    public static int TVM_HITTEST;
    public static int TVM_ENSUREVISIBLE;
    public static int TVM_ENDEDITLABELNOW;
    public static int TVM_GETISEARCHSTRINGA;
    public static int TVM_GETISEARCHSTRINGW;
    public static int TVM_SETITEMHEIGHT;
    public static int TVM_GETITEMHEIGHT;
    public static int TVN_SELCHANGINGA;
    public static int TVN_SELCHANGINGW;
    public static int TVN_GETINFOTIPA;
    public static int TVN_GETINFOTIPW;
    public static int TVN_SELCHANGEDA;
    public static int TVN_SELCHANGEDW;
    public static int TVC_UNKNOWN;
    public static int TVC_BYMOUSE;
    public static int TVC_BYKEYBOARD;
    public static int TVN_GETDISPINFOA;
    public static int TVN_GETDISPINFOW;
    public static int TVN_SETDISPINFOA;
    public static int TVN_SETDISPINFOW;
    public static int TVN_ITEMEXPANDINGA;
    public static int TVN_ITEMEXPANDINGW;
    public static int TVN_ITEMEXPANDEDA;
    public static int TVN_ITEMEXPANDEDW;
    public static int TVN_BEGINDRAGA;
    public static int TVN_BEGINDRAGW;
    public static int TVN_BEGINRDRAGA;
    public static int TVN_BEGINRDRAGW;
    public static int TVN_BEGINLABELEDITA;
    public static int TVN_BEGINLABELEDITW;
    public static int TVN_ENDLABELEDITA;
    public static int TVN_ENDLABELEDITW;
    public static int TCS_BOTTOM;
    public static int TCS_RIGHT;
    public static int TCS_FLATBUTTONS;
    public static int TCS_HOTTRACK;
    public static int TCS_VERTICAL;
    public static int TCS_TABS;
    public static int TCS_BUTTONS;
    public static int TCS_MULTILINE;
    public static int TCS_RIGHTJUSTIFY;
    public static int TCS_FIXEDWIDTH;
    public static int TCS_RAGGEDRIGHT;
    public static int TCS_OWNERDRAWFIXED;
    public static int TCS_TOOLTIPS;
    public static int TCM_SETIMAGELIST;
    public static int TCIF_TEXT;
    public static int TCIF_IMAGE;
    public static int TCM_GETITEMA;
    public static int TCM_GETITEMW;
    public static int TCM_SETITEMA;
    public static int TCM_SETITEMW;
    public static int TCM_INSERTITEMA;
    public static int TCM_INSERTITEMW;
    public static int TCM_DELETEITEM;
    public static int TCM_DELETEALLITEMS;
    public static int TCM_GETITEMRECT;
    public static int TCM_GETCURSEL;
    public static int TCM_SETCURSEL;
    public static int TCM_ADJUSTRECT;
    public static int TCM_SETITEMSIZE;
    public static int TCM_SETPADDING;
    public static int TCM_GETROWCOUNT;
    public static int TCM_GETTOOLTIPS;
    public static int TCM_SETTOOLTIPS;
    public static int TCN_SELCHANGE;
    public static int TCN_SELCHANGING;
    public static int TBSTYLE_WRAPPABLE;
    public static int TVM_SETBKCOLOR;
    public static int TVM_SETTEXTCOLOR;
    public static int TYMED_NULL;
    public static int TVM_GETLINECOLOR;
    public static int TVM_SETLINECOLOR;
    public static int TVM_SETTOOLTIPS;
    public static int TVSIL_STATE;
    public static int TVM_SORTCHILDRENCB;
    public static int UIS_SET;
    public static int UIS_CLEAR;
    public static int UIS_INITIALIZE;
    public static int UISF_HIDEFOCUS;
    public static int UISF_HIDEACCEL;
    public static int UISF_ACTIVE;
    public static int VK_TAB;
    public static int VK_SHIFT;
    public static int VK_CONTROL;
    public static int VK_MENU;
    public static int WH_JOURNALPLAYBACK;
    public static int WH_GETMESSAGE;
    public static int WH_MOUSE;
    public static int WSF_VISIBLE;
    public static int WA_INACTIVE;
    public static int WA_ACTIVE;
    public static int WA_CLICKACTIVE;
    public static int WHEEL_DELTA;
    public static int WM_REFLECT;
    public static int WM_CHOOSEFONT_GETLOGFONT;
    public static int WS_OVERLAPPED;
    public static int WS_POPUP;
    public static int WS_CHILD;
    public static int WS_MINIMIZE;
    public static int WS_VISIBLE;
    public static int WS_DISABLED;
    public static int WS_CLIPSIBLINGS;
    public static int WS_CLIPCHILDREN;
    public static int WS_MAXIMIZE;
    public static int WS_CAPTION;
    public static int WS_BORDER;
    public static int WS_DLGFRAME;
    public static int WS_VSCROLL;
    public static int WS_HSCROLL;
    public static int WS_SYSMENU;
    public static int WS_THICKFRAME;
    public static int WS_TABSTOP;
    public static int WS_MINIMIZEBOX;
    public static int WS_MAXIMIZEBOX;
    public static int WS_EX_DLGMODALFRAME;
    public static int WS_EX_TRANSPARENT;
    public static int WS_EX_MDICHILD;
    public static int WS_EX_TOOLWINDOW;
    public static int WS_EX_WINDOWEDGE;
    public static int WS_EX_CLIENTEDGE;
    public static int WS_EX_CONTEXTHELP;
    public static int WS_EX_RIGHT;
    public static int WS_EX_LEFT;
    public static int WS_EX_RTLREADING;
    public static int WS_EX_LEFTSCROLLBAR;
    public static int WS_EX_CONTROLPARENT;
    public static int WS_EX_STATICEDGE;
    public static int WS_EX_APPWINDOW;
    public static int WS_EX_LAYERED;
    public static int WS_EX_TOPMOST;
    public static int WS_EX_LAYOUTRTL;
    public static int WS_EX_NOINHERITLAYOUT;
    public static int WS_EX_COMPOSITED;
    public static int WPF_SETMINPOSITION;
    public static int WPF_RESTORETOMAXIMIZED;
    public static int WHITE_BRUSH;
    public static int NULL_BRUSH;
    public static int XBUTTON1;
    public static int XBUTTON2;
    public static int CDN_FIRST;
    public static int CDN_INITDONE;
    public static int CDN_SELCHANGE;
    public static int CDN_SHAREVIOLATION;
    public static int CDN_FILEOK;
    public static int CDM_FIRST;
    public static int CDM_GETSPEC;
    public static int CDM_GETFILEPATH;
    public static int DWL_MSGRESULT;
    public static int PBT_APMPOWERSTATUSCHANGE;
    public static int EVENT_SYSTEM_MOVESIZESTART;
    public static int EVENT_SYSTEM_MOVESIZEEND;
    public static int EVENT_OBJECT_STATECHANGE;
    public static int EVENT_OBJECT_FOCUS;
    public static int OBJID_CLIENT;
    public static int WINEVENT_OUTOFCONTEXT;
    public static UInt32 RIDI_DEVICEINFO;
    public static UInt32 RIM_TYPEHID;
    public static ushort HID_USAGE_PAGE_DIGITIZER;
    public static ushort HID_USAGE_DIGITIZER_DIGITIZER;
    public static ushort HID_USAGE_DIGITIZER_PEN;
    public static ushort HID_USAGE_DIGITIZER_LIGHTPEN;
    public static ushort HID_USAGE_DIGITIZER_TOUCHSCREEN;
    public static int AC_SRC_OVER;
    public static int ULW_COLORKEY;
    public static int ULW_ALPHA;
    public static int ULW_OPAQUE;
    public static IntPtr WTS_CURRENT_SERVER_HANDLE;
    public static int WTS_CURRENT_SESSION;
    internal static DpiAwarenessContextHandle DPI_AWARENESS_CONTEXT_UNAWARE;
    internal static DpiAwarenessContextHandle DPI_AWARENESS_CONTEXT_SYSTEM_AWARE;
    internal static DpiAwarenessContextHandle DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE;
    internal static DpiAwarenessContextHandle DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2;
    public static int FEATURE_OBJECT_CACHING;
    public static int FEATURE_ZONE_ELEVATION;
    public static int FEATURE_MIME_HANDLING;
    public static int FEATURE_MIME_SNIFFING;
    public static int FEATURE_WINDOW_RESTRICTIONS;
    public static int FEATURE_WEBOC_POPUPMANAGEMENT;
    public static int FEATURE_BEHAVIORS;
    public static int FEATURE_DISABLE_MK_PROTOCOL;
    public static int FEATURE_LOCALMACHINE_LOCKDOWN;
    public static int FEATURE_SECURITYBAND;
    public static int FEATURE_RESTRICT_ACTIVEXINSTALL;
    public static int FEATURE_VALIDATE_NAVIGATE_URL;
    public static int FEATURE_RESTRICT_FILEDOWNLOAD;
    public static int FEATURE_ADDON_MANAGEMENT;
    public static int FEATURE_PROTOCOL_LOCKDOWN;
    public static int FEATURE_HTTP_USERNAME_PASSWORD_DISABLE;
    public static int FEATURE_SAFE_BINDTOOBJECT;
    public static int FEATURE_UNC_SAVEDFILECHECK;
    public static int FEATURE_GET_URL_DOM_FILEPATH_UNENCODED;
    public static int FEATURE_TABBED_BROWSING;
    public static int FEATURE_SSLUX;
    public static int FEATURE_DISABLE_NAVIGATION_SOUNDS;
    public static int FEATURE_DISABLE_LEGACY_COMPRESSION;
    public static int FEATURE_FORCE_ADDR_AND_STATUS;
    public static int FEATURE_XMLHTTP;
    public static int FEATURE_DISABLE_TELNET_PROTOCOL;
    public static int FEATURE_FEEDS;
    public static int FEATURE_BLOCK_INPUT_PROMPTS;
    public static int GET_FEATURE_FROM_PROCESS;
    public static int SET_FEATURE_ON_PROCESS;
    public static int URLZONE_LOCAL_MACHINE;
    public static int URLZONE_INTRANET;
    public static int URLZONE_TRUSTED;
    public static int URLZONE_INTERNET;
    public static int URLZONE_UNTRUSTED;
    public static byte URLPOLICY_ALLOW;
    public static byte URLPOLICY_QUERY;
    public static byte URLPOLICY_DISALLOW;
    public static int URLACTION_FEATURE_ZONE_ELEVATION;
    public static int PUAF_NOUI;
    public static int MUTZ_NOSAVEDFILECHECK;
    public static int SIZE_RESTORED;
    public static int SIZE_MINIMIZED;
    public static int WS_EX_NOACTIVATE;
    public static int VK_LSHIFT;
    public static int VK_RMENU;
    public static int VK_LMENU;
    public static int VK_LCONTROL;
    public static int VK_RCONTROL;
    public static int VK_LBUTTON;
    public static int VK_RBUTTON;
    public static int VK_MBUTTON;
    public static int VK_XBUTTON1;
    public static int VK_XBUTTON2;
    public static int PM_QS_SENDMESSAGE;
    public static int PM_QS_POSTMESSAGE;
    public static int MWMO_WAITALL;
    public static int MWMO_ALERTABLE;
    public static int MWMO_INPUTAVAILABLE;
    public static IntPtr HWND_MESSAGE;
    internal static UInt32 DELETE;
    internal static UInt32 READ_CONTROL;
    internal static UInt32 WRITE_DAC;
    internal static UInt32 WRITE_OWNER;
    internal static UInt32 SYNCHRONIZE;
    internal static UInt32 STANDARD_RIGHTS_REQUIRED;
    internal static UInt32 STANDARD_RIGHTS_READ;
    internal static UInt32 STANDARD_RIGHTS_WRITE;
    internal static UInt32 STANDARD_RIGHTS_EXECUTE;
    internal static UInt32 STANDARD_RIGHTS_ALL;
    internal static UInt32 SPECIFIC_RIGHTS_ALL;
    internal static UInt32 ACCESS_SYSTEM_SECURITY;
    internal static UInt32 MAXIMUM_ALLOWED;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 GENERIC_WRITE;
    internal static UInt32 GENERIC_EXECUTE;
    internal static UInt32 GENERIC_ALL;
    internal static UInt32 FILE_READ_DATA;
    internal static UInt32 FILE_LIST_DIRECTORY;
    internal static UInt32 FILE_WRITE_DATA;
    internal static UInt32 FILE_ADD_FILE;
    internal static UInt32 FILE_APPEND_DATA;
    internal static UInt32 FILE_ADD_SUBDIRECTORY;
    internal static UInt32 FILE_CREATE_PIPE_INSTANCE;
    internal static UInt32 FILE_READ_EA;
    internal static UInt32 FILE_WRITE_EA;
    internal static UInt32 FILE_EXECUTE;
    internal static UInt32 FILE_TRAVERSE;
    internal static UInt32 FILE_DELETE_CHILD;
    internal static UInt32 FILE_READ_ATTRIBUTES;
    internal static UInt32 FILE_WRITE_ATTRIBUTES;
    internal static UInt32 FILE_ALL_ACCESS;
    internal static UInt32 FILE_GENERIC_READ;
    internal static UInt32 FILE_GENERIC_WRITE;
    internal static UInt32 FILE_GENERIC_EXECUTE;
    internal static UInt32 FILE_SHARE_READ;
    internal static UInt32 FILE_SHARE_WRITE;
    internal static UInt32 FILE_SHARE_DELETE;
    internal static int ERROR_ALREADY_EXISTS;
    internal static int OPEN_EXISTING;
    internal static int PAGE_READONLY;
    internal static int SECTION_MAP_READ;
    internal static int FILE_ATTRIBUTE_NORMAL;
    internal static int FILE_ATTRIBUTE_TEMPORARY;
    internal static int FILE_FLAG_DELETE_ON_CLOSE;
    internal static int CREATE_ALWAYS;
    internal static int PROCESS_ALL_ACCESS;
    public static int QS_EVENT;
    public static int VK_CANCEL;
    public static int VK_BACK;
    public static int VK_CLEAR;
    public static int VK_RETURN;
    public static int VK_PAUSE;
    public static int VK_CAPITAL;
    public static int VK_KANA;
    public static int VK_HANGEUL;
    public static int VK_HANGUL;
    public static int VK_JUNJA;
    public static int VK_FINAL;
    public static int VK_HANJA;
    public static int VK_KANJI;
    public static int VK_ESCAPE;
    public static int VK_CONVERT;
    public static int VK_NONCONVERT;
    public static int VK_ACCEPT;
    public static int VK_MODECHANGE;
    public static int VK_SPACE;
    public static int VK_PRIOR;
    public static int VK_NEXT;
    public static int VK_END;
    public static int VK_HOME;
    public static int VK_LEFT;
    public static int VK_UP;
    public static int VK_RIGHT;
    public static int VK_DOWN;
    public static int VK_SELECT;
    public static int VK_PRINT;
    public static int VK_EXECUTE;
    public static int VK_SNAPSHOT;
    public static int VK_INSERT;
    public static int VK_DELETE;
    public static int VK_HELP;
    public static int VK_0;
    public static int VK_1;
    public static int VK_2;
    public static int VK_3;
    public static int VK_4;
    public static int VK_5;
    public static int VK_6;
    public static int VK_7;
    public static int VK_8;
    public static int VK_9;
    public static int VK_A;
    public static int VK_B;
    public static int VK_C;
    public static int VK_D;
    public static int VK_E;
    public static int VK_F;
    public static int VK_G;
    public static int VK_H;
    public static int VK_I;
    public static int VK_J;
    public static int VK_K;
    public static int VK_L;
    public static int VK_M;
    public static int VK_N;
    public static int VK_O;
    public static int VK_P;
    public static int VK_Q;
    public static int VK_R;
    public static int VK_S;
    public static int VK_T;
    public static int VK_U;
    public static int VK_V;
    public static int VK_W;
    public static int VK_X;
    public static int VK_Y;
    public static int VK_Z;
    public static int VK_LWIN;
    public static int VK_RWIN;
    public static int VK_APPS;
    public static int VK_POWER;
    public static int VK_SLEEP;
    public static int VK_NUMPAD0;
    public static int VK_NUMPAD1;
    public static int VK_NUMPAD2;
    public static int VK_NUMPAD3;
    public static int VK_NUMPAD4;
    public static int VK_NUMPAD5;
    public static int VK_NUMPAD6;
    public static int VK_NUMPAD7;
    public static int VK_NUMPAD8;
    public static int VK_NUMPAD9;
    public static int VK_MULTIPLY;
    public static int VK_ADD;
    public static int VK_SEPARATOR;
    public static int VK_SUBTRACT;
    public static int VK_DECIMAL;
    public static int VK_DIVIDE;
    public static int VK_F1;
    public static int VK_F2;
    public static int VK_F3;
    public static int VK_F4;
    public static int VK_F5;
    public static int VK_F6;
    public static int VK_F7;
    public static int VK_F8;
    public static int VK_F9;
    public static int VK_F10;
    public static int VK_F11;
    public static int VK_F12;
    public static int VK_F13;
    public static int VK_F14;
    public static int VK_F15;
    public static int VK_F16;
    public static int VK_F17;
    public static int VK_F18;
    public static int VK_F19;
    public static int VK_F20;
    public static int VK_F21;
    public static int VK_F22;
    public static int VK_F23;
    public static int VK_F24;
    public static int VK_NUMLOCK;
    public static int VK_SCROLL;
    public static int VK_RSHIFT;
    public static int VK_BROWSER_BACK;
    public static int VK_BROWSER_FORWARD;
    public static int VK_BROWSER_REFRESH;
    public static int VK_BROWSER_STOP;
    public static int VK_BROWSER_SEARCH;
    public static int VK_BROWSER_FAVORITES;
    public static int VK_BROWSER_HOME;
    public static int VK_VOLUME_MUTE;
    public static int VK_VOLUME_DOWN;
    public static int VK_VOLUME_UP;
    public static int VK_MEDIA_NEXT_TRACK;
    public static int VK_MEDIA_PREV_TRACK;
    public static int VK_MEDIA_STOP;
    public static int VK_MEDIA_PLAY_PAUSE;
    public static int VK_LAUNCH_MAIL;
    public static int VK_LAUNCH_MEDIA_SELECT;
    public static int VK_LAUNCH_APP1;
    public static int VK_LAUNCH_APP2;
    public static int VK_PROCESSKEY;
    public static int VK_PACKET;
    public static int VK_ATTN;
    public static int VK_CRSEL;
    public static int VK_EXSEL;
    public static int VK_EREOF;
    public static int VK_PLAY;
    public static int VK_ZOOM;
    public static int VK_NONAME;
    public static int VK_PA1;
    public static int VK_OEM_CLEAR;
    internal static int ENDSESSION_LOGOFF;
    internal static int ERROR_SUCCESS;
    public static int LOCALE_FONTSIGNATURE;
    public static int SWP_NOREDRAW;
    public static int SWP_FRAMECHANGED;
    public static int SWP_NOCOPYBITS;
    public static int SWP_NOOWNERZORDER;
    public static int SWP_NOSENDCHANGING;
    public static int SWP_NOREPOSITION;
    public static int SWP_DEFERERASE;
    public static int SWP_ASYNCWINDOWPOS;
    public static int SPI_GETCURSORSHADOW;
    public static int SPI_SETCURSORSHADOW;
    public static int SPI_GETFOCUSBORDERWIDTH;
    public static int SPI_SETFOCUSBORDERWIDTH;
    public static int SPI_GETFOCUSBORDERHEIGHT;
    public static int SPI_SETFOCUSBORDERHEIGHT;
    public static int SPI_GETSTYLUSHOTTRACKING;
    public static int SPI_SETSTYLUSHOTTRACKING;
    public static int SPI_GETTOOLTIPFADE;
    public static int SPI_SETTOOLTIPFADE;
    public static int SPI_GETFOREGROUNDFLASHCOUNT;
    public static int SPI_SETFOREGROUNDFLASHCOUNT;
    public static int SPI_SETCARETWIDTH;
    public static int SPI_SETMOUSEVANISH;
    public static int SPI_SETHIGHCONTRAST;
    public static int SPI_SETKEYBOARDPREF;
    public static int SPI_SETFLATMENU;
    public static int SPI_SETDROPSHADOW;
    public static int SPI_SETWORKAREA;
    public static int SPI_SETICONMETRICS;
    public static int SPI_SETDRAGWIDTH;
    public static int SPI_SETDRAGHEIGHT;
    public static int SPI_SETPENWINDOWS;
    public static int SPI_SETMOUSEBUTTONSWAP;
    public static int SPI_SETSHOWSOUNDS;
    public static int SPI_SETKEYBOARDCUES;
    public static int SPI_SETKEYBOARDDELAY;
    public static int SPI_SETSNAPTODEFBUTTON;
    public static int SPI_SETWHEELSCROLLLINES;
    public static int SPI_SETMOUSEHOVERWIDTH;
    public static int SPI_SETMOUSEHOVERHEIGHT;
    public static int SPI_SETMOUSEHOVERTIME;
    public static int SPI_SETMENUDROPALIGNMENT;
    public static int SPI_SETMENUFADE;
    public static int SPI_SETMENUSHOWDELAY;
    public static int SPI_SETCOMBOBOXANIMATION;
    public static int SPI_SETCLIENTAREAANIMATION;
    public static int SPI_SETGRADIENTCAPTIONS;
    public static int SPI_SETHOTTRACKING;
    public static int SPI_SETLISTBOXSMOOTHSCROLLING;
    public static int SPI_SETMENUANIMATION;
    public static int SPI_SETSELECTIONFADE;
    public static int SPI_SETTOOLTIPANIMATION;
    public static int SPI_SETUIEFFECTS;
    public static int SPI_SETANIMATION;
    public static int SPI_SETDRAGFULLWINDOWS;
    public static int SPI_SETBORDER;
    public static int SPI_SETNONCLIENTMETRICS;
    public static int LANG_KOREAN;
    public static int MB_YESNO;
    public static int MB_SYSTEMMODAL;
    public static int IDYES;
    public static int PM_QS_INPUT;
    public static int PM_QS_PAINT;
    public static int SW_PARENTCLOSING;
    public static int SW_PARENTOPENING;
    public static int SC_MOUSEMOVE;
    public static int SPI_SETKEYBOARDSPEED;
    internal static int TYMED_HGLOBAL;
    internal static int TYMED_FILE;
    internal static int TYMED_ISTREAM;
    internal static int TYMED_ISTORAGE;
    internal static int TYMED_GDI;
    internal static int TYMED_MFPICT;
    internal static int TYMED_ENHMF;
    public static int WS_OVERLAPPEDWINDOW;
    public static int KEYEVENTF_EXTENDEDKEY;
    public static int KEYEVENTF_KEYUP;
    public static int KEYEVENTF_UNICODE;
    public static int KEYEVENTF_SCANCODE;
    public static int MOUSEEVENTF_MOVE;
    public static int MOUSEEVENTF_LEFTDOWN;
    public static int MOUSEEVENTF_LEFTUP;
    public static int MOUSEEVENTF_RIGHTDOWN;
    public static int MOUSEEVENTF_RIGHTUP;
    public static int MOUSEEVENTF_MIDDLEDOWN;
    public static int MOUSEEVENTF_MIDDLEUP;
    public static int MOUSEEVENTF_XDOWN;
    public static int MOUSEEVENTF_XUP;
    public static int MOUSEEVENTF_WHEEL;
    public static int MOUSEEVENTF_VIRTUALDESK;
    public static int MOUSEEVENTF_ABSOLUTE;
    public static int MOUSEEVENTF_ACTUAL;
    public static int GWL_HINSTANCE;
    public static int GWL_USERDATA;
    public static int GCL_MENUNAME;
    public static int GCL_HBRBACKGROUND;
    public static int GCL_HCURSOR;
    public static int GCL_HICON;
    public static int GCL_HMODULE;
    public static int GCL_CBWNDEXTRA;
    public static int GCL_CBCLSEXTRA;
    public static int GCL_STYLE;
    public static int GCW_ATOM;
    public static int GCL_HICONSM;
    public static int MONITOR_DEFAULTTONULL;
    public static int MONITOR_DEFAULTTOPRIMARY;
    public static int MONITOR_DEFAULTTONEAREST;
    public static UInt32 WTNCA_NODRAWCAPTION;
    public static UInt32 WTNCA_NODRAWICON;
    public static UInt32 WTNCA_NOSYSMENU;
    public static UInt32 WTNCA_VALIDBITS;
    internal static int NO_ERROR;
    public static int VK_OEM_1;
    public static int VK_OEM_PLUS;
    public static int VK_OEM_COMMA;
    public static int VK_OEM_MINUS;
    public static int VK_OEM_PERIOD;
    public static int VK_OEM_2;
    public static int VK_OEM_3;
    public static int VK_C1;
    public static int VK_C2;
    public static int VK_OEM_4;
    public static int VK_OEM_5;
    public static int VK_OEM_6;
    public static int VK_OEM_7;
    public static int VK_OEM_8;
    public static int VK_OEM_AX;
    public static int VK_OEM_102;
    public static int VK_OEM_RESET;
    public static int VK_OEM_JUMP;
    public static int VK_OEM_PA1;
    public static int VK_OEM_PA2;
    public static int VK_OEM_PA3;
    public static int VK_OEM_WSCTRL;
    public static int VK_OEM_CUSEL;
    public static int VK_OEM_ATTN;
    public static int VK_OEM_FINISH;
    public static int VK_OEM_COPY;
    public static int VK_OEM_AUTO;
    public static int VK_OEM_ENLW;
    public static int VK_OEM_BACKTAB;
    public static int DRAGDROP_S_DROP;
    public static int DRAGDROP_S_CANCEL;
    public static int DRAGDROP_S_USEDEFAULTCURSORS;
    public static int TME_CANCEL;
    public static int IDC_HAND;
    public static int DM_ORIENTATION;
    public static int DM_PAPERSIZE;
    public static int DM_PAPERLENGTH;
    public static int DM_PAPERWIDTH;
    public static int DM_PRINTQUALITY;
    public static int DM_YRESOLUTION;
    public static int MM_ISOTROPIC;
    public static int DM_OUT_BUFFER;
    public static int E_HANDLE;
    public static int SPI_SETFONTSMOOTHING;
    public static int SPI_SETFONTSMOOTHINGTYPE;
    public static int SPI_SETFONTSMOOTHINGCONTRAST;
    public static int SPI_SETFONTSMOOTHINGORIENTATION;
    public static int SPI_SETDISPLAYPIXELSTRUCTURE;
    public static int SPI_SETDISPLAYGAMMA;
    public static int SPI_SETDISPLAYCLEARTYPELEVEL;
    public static int SPI_SETDISPLAYTEXTCONTRASTLEVEL;
    public static int GMMP_USE_DISPLAY_POINTS;
    public static int GMMP_USE_HIGH_RESOLUTION_POINTS;
    public static int ERROR_FILE_NOT_FOUND;
    public static int ERROR_PATH_NOT_FOUND;
    public static int ERROR_ACCESS_DENIED;
    public static int ERROR_INVALID_DRIVE;
    public static int ERROR_SHARING_VIOLATION;
    public static int ERROR_FILE_EXISTS;
    public static int ERROR_INVALID_PARAMETER;
    public static int ERROR_FILENAME_EXCED_RANGE;
    public static int ERROR_NO_MORE_ITEMS;
    public static int ERROR_OPERATION_ABORTED;
    public static int LR_DEFAULTCOLOR;
    public static int LR_MONOCHROME;
    public static int LR_COLOR;
    public static int LR_COPYRETURNORG;
    public static int LR_COPYDELETEORG;
    public static int LR_LOADFROMFILE;
    public static int LR_LOADTRANSPARENT;
    public static int LR_DEFAULTSIZE;
    public static int LR_VGACOLOR;
    public static int LR_LOADMAP3DCOLORS;
    public static int LR_CREATEDIBSECTION;
    public static int LR_COPYFROMRESOURCE;
    public static int LR_SHARED;
    public static int WTS_CONSOLE_CONNECT;
    public static int WTS_CONSOLE_DISCONNECT;
    public static int WTS_REMOTE_CONNECT;
    public static int WTS_REMOTE_DISCONNECT;
    public static int WTS_SESSION_LOCK;
    public static int WTS_SESSION_UNLOCK;
    public static UInt32 NOTIFY_FOR_THIS_SESSION;
    public static int PBT_APMSUSPEND;
    public static int PBT_APMRESUMECRITICAL;
    public static int PBT_APMRESUMESUSPEND;
    public static int PBT_APMRESUMEAUTOMATIC;
    public static int PBT_POWERSETTINGCHANGE;
    public static Guid GUID_MONITOR_POWER_ON;
    public static UInt32 PROFILE_READ;
    private static NativeMethods();
    public static bool Succeeded(int hr);
    public static bool Failed(int hr);
    public static int SignedHIWORD(int n);
    public static int SignedLOWORD(int n);
    public static int MakeHRFromErrorCode(int errorCode);
    internal static IntPtr SetEnhMetaFileBits(UInt32 cbBuffer, Byte[] buffer);
    public static int SignedHIWORD(IntPtr intPtr);
    public static int SignedLOWORD(IntPtr intPtr);
    public static int IntPtrToInt32(IntPtr intPtr);
    public static int EndDoc(HDC hdc);
    public static int ExtEscape(HDC hdc, int nEscape, int cbInput, PrinterEscape* lpvInData, int cbOutput, Void* lpvOutData);
    public static int StartDoc(HDC hdc, DocInfo& docInfo);
    public static int OpenPrinterA(string printerName, IntPtr* phPrinter, Void* pDefaults);
    public static int ClosePrinter(IntPtr hPrinter);
    public static int EndPage(HDC hdc);
    public static int StartPage(HDC hdc);
}
[FriendAccessAllowedAttribute]
internal static class MS.Win32.SafeNativeMethods : object {
    public static UInt32 CT_CTYPE1;
    public static UInt32 CT_CTYPE2;
    public static UInt32 CT_CTYPE3;
    public static ushort C1_SPACE;
    public static ushort C1_PUNCT;
    public static ushort C1_BLANK;
    public static ushort C3_NONSPACING;
    public static ushort C3_DIACRITIC;
    public static ushort C3_VOWELMARK;
    public static ushort C3_KATAKANA;
    public static ushort C3_HIRAGANA;
    public static ushort C3_HALFWIDTH;
    public static ushort C3_FULLWIDTH;
    public static ushort C3_IDEOGRAPH;
    public static ushort C3_KASHIDA;
    public static int GetMessagePos();
    public static IntPtr GetKeyboardLayout(int dwLayout);
    public static IntPtr ActivateKeyboardLayout(HandleRef hkl, int uFlags);
    public static int GetKeyboardLayoutList(int size, IntPtr[] hkls);
    internal static void GetMonitorInfo(HandleRef hmonitor, MONITORINFOEX info);
    public static IntPtr MonitorFromPoint(POINT pt, int flags);
    public static IntPtr MonitorFromRect(RECT& rect, int flags);
    public static IntPtr MonitorFromWindow(HandleRef handle, int flags);
    public static CursorHandle LoadCursor(HandleRef hInst, IntPtr iconId);
    public static IntPtr GetCursor();
    public static int ShowCursor(bool show);
    internal static bool AdjustWindowRectEx(RECT& lpRect, int dwStyle, bool bMenu, int dwExStyle);
    internal static void GetClientRect(HandleRef hWnd, RECT& rect);
    internal static RECT GetClientRect(HandleRef hWnd);
    internal static void GetWindowRect(HandleRef hWnd, RECT& rect);
    public static int GetDoubleClickTime();
    public static bool IsWindowEnabled(HandleRef hWnd);
    public static bool IsWindowVisible(HandleRef hWnd);
    internal static bool ReleaseCapture();
    public static bool TrackMouseEvent(TRACKMOUSEEVENT tme);
    public static void SetTimer(HandleRef hWnd, int nIDEvent, int uElapse);
    public static bool TrySetTimer(HandleRef hWnd, int nIDEvent, int uElapse);
    public static bool KillTimer(HandleRef hwnd, int idEvent);
    public static int GetTickCount();
    public static int MessageBeep(int uType);
    public static bool IsWindowUnicode(HandleRef hWnd);
    public static IntPtr SetCursor(HandleRef hcursor);
    public static IntPtr SetCursor(SafeHandle hcursor);
    public static void ScreenToClient(HandleRef hWnd, POINT& pt);
    public static int GetCurrentProcessId();
    public static int GetCurrentThreadId();
    public static Nullable`1<int> GetCurrentSessionId();
    public static IntPtr GetCapture();
    public static IntPtr SetCapture(HandleRef hwnd);
    internal static int MapVirtualKey(int nVirtKey, int nMapType);
    public static bool IsCurrentSessionConnectStateWTSActive(Nullable`1<int> SessionId, bool defaultResult);
    internal static PROCESS_DPI_AWARENESS GetProcessDpiAwareness(HandleRef hProcess);
    internal static DpiAwarenessContextHandle GetWindowDpiAwarenessContext(IntPtr hwnd);
    internal static bool AreDpiAwarenessContextsEqual(IntPtr dpiContextA, IntPtr dpiContextB);
    internal static UInt32 GetDpiForWindow(HandleRef hwnd);
    internal static UInt32 GetDpiForSystem();
    internal static DPI_HOSTING_BEHAVIOR GetWindowDpiHostingBehavior(IntPtr hWnd);
    internal static DPI_HOSTING_BEHAVIOR GetThreadDpiHostingBehavior();
    internal static bool AdjustWindowRectExForDpi(RECT& lpRect, int dwStyle, bool bMenu, int dwExStyle, int dpi);
    internal static bool LogicalToPhysicalPointForPerMonitorDPI(HandleRef hWnd, POINT& lpPoint);
    internal static bool PhysicalToLogicalPointForPerMonitorDPI(HandleRef hWnd, POINT& lpPoint);
    internal static bool InSendMessage();
    public static bool IsUxThemeActive();
    public static bool SetCaretPos(int x, int y);
    public static bool DestroyCaret();
    public static int GetCaretBlinkTime();
    public static bool GetStringTypeEx(UInt32 locale, UInt32 infoType, Char[] sourceString, int count, UInt16[] charTypes);
    public static int GetSysColor(int nIndex);
    public static bool IsClipboardFormatAvailable(int format);
    public static bool IsDebuggerPresent();
    public static void QueryPerformanceCounter(Int64& lpPerformanceCount);
    public static void QueryPerformanceFrequency(Int64& lpFrequency);
    internal static int GetMessageTime();
    internal static int GetWindowStyle(HandleRef hWnd, bool exStyle);
}
[FriendAccessAllowedAttribute]
internal class MS.Win32.UnsafeNativeMethods : object {
    public static int MB_PRECOMPOSED;
    public static int MB_COMPOSITE;
    public static int MB_USEGLYPHCHARS;
    public static int MB_ERR_INVALID_CHARS;
    public static int WAIT_FAILED;
    internal static UInt32 INTERNET_COOKIE_THIRD_PARTY;
    internal static UInt32 INTERNET_COOKIE_EVALUATE_P3P;
    internal static UInt32 INTERNET_COOKIE_IS_RESTRICTED;
    internal static UInt32 COOKIE_STATE_REJECT;
    public static int PROCESS_VM_READ;
    public static int PROCESS_QUERY_INFORMATION;
    internal static IntPtr INVALID_HANDLE_VALUE;
    internal static int PAGE_NOACCESS;
    internal static int PAGE_READONLY;
    internal static int PAGE_READWRITE;
    internal static int PAGE_WRITECOPY;
    internal static int PAGE_EXECUTE;
    internal static int PAGE_EXECUTE_READ;
    internal static int PAGE_EXECUTE_READWRITE;
    internal static int PAGE_EXECUTE_WRITECOPY;
    internal static int PAGE_GUARD;
    internal static int PAGE_NOCACHE;
    internal static int PAGE_WRITECOMBINE;
    internal static int MEM_COMMIT;
    internal static int MEM_RESERVE;
    internal static int MEM_DECOMMIT;
    internal static int MEM_RELEASE;
    internal static int MEM_FREE;
    internal static int MEM_PRIVATE;
    internal static int MEM_MAPPED;
    internal static int MEM_RESET;
    internal static int MEM_TOP_DOWN;
    internal static int MEM_WRITE_WATCH;
    internal static int MEM_PHYSICAL;
    internal static int MEM_4MB_PAGES;
    internal static int SEC_FILE;
    internal static int SEC_IMAGE;
    internal static int SEC_RESERVE;
    internal static int SEC_COMMIT;
    internal static int SEC_NOCACHE;
    internal static int MEM_IMAGE;
    internal static int WRITE_WATCH_FLAG_RESET;
    internal static int SECTION_ALL_ACCESS;
    internal static int STANDARD_RIGHTS_REQUIRED;
    internal static int SECTION_QUERY;
    internal static int SECTION_MAP_WRITE;
    internal static int SECTION_MAP_READ;
    internal static int SECTION_MAP_EXECUTE;
    internal static int SECTION_EXTEND_SIZE;
    internal static int FILE_MAP_COPY;
    internal static int FILE_MAP_WRITE;
    internal static int FILE_MAP_READ;
    internal static int FILE_MAP_ALL_ACCESS;
    internal static int SDDL_REVISION_1;
    internal static int SDDL_REVISION;
    public static int EventObjectUIFragmentCreate;
    internal static int STATUS_SUCCESS;
    internal static int STATUS_TIMEOUT;
    internal static int STATUS_BUFFER_TOO_SMALL;
    public static int DUPLICATE_CLOSE_SOURCE;
    public static int DUPLICATE_SAME_ACCESS;
    public static int TF_CLIENTID_NULL;
    public static char TS_CHAR_EMBEDDED;
    public static char TS_CHAR_REGION;
    public static char TS_CHAR_REPLACEMENT;
    public static int TS_DEFAULT_SELECTION;
    public static int TS_S_ASYNC;
    public static int TS_E_NOSELECTION;
    public static int TS_E_NOLAYOUT;
    public static int TS_E_INVALIDPOINT;
    public static int TS_E_SYNCHRONOUS;
    public static int TS_E_READONLY;
    public static int TS_E_FORMAT;
    public static int TF_INVALID_COOKIE;
    public static int TF_DICTATION_ON;
    public static int TF_COMMANDING_ON;
    public static Guid IID_ITextStoreACPSink;
    public static Guid IID_ITfThreadFocusSink;
    public static Guid IID_ITfTextEditSink;
    public static Guid IID_ITfLanguageProfileNotifySink;
    public static Guid IID_ITfCompartmentEventSink;
    public static Guid IID_ITfTransitoryExtensionSink;
    public static Guid GUID_TFCAT_TIP_KEYBOARD;
    public static Guid GUID_PROP_ATTRIBUTE;
    public static Guid GUID_PROP_LANGID;
    public static Guid GUID_PROP_READING;
    public static Guid GUID_PROP_INPUTSCOPE;
    public static Guid GUID_COMPARTMENT_KEYBOARD_DISABLED;
    public static Guid GUID_COMPARTMENT_KEYBOARD_OPENCLOSE;
    public static Guid GUID_COMPARTMENT_HANDWRITING_OPENCLOSE;
    public static Guid GUID_COMPARTMENT_SPEECH_DISABLED;
    public static Guid GUID_COMPARTMENT_SPEECH_OPENCLOSE;
    public static Guid GUID_COMPARTMENT_SPEECH_GLOBALSTATE;
    public static Guid GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION;
    public static Guid GUID_COMPARTMENT_KEYBOARD_INPUTMODE_SENTENCE;
    public static Guid GUID_COMPARTMENT_TRANSITORYEXTENSION;
    public static Guid GUID_COMPARTMENT_TRANSITORYEXTENSION_DOCUMENTMANAGER;
    public static Guid GUID_COMPARTMENT_TRANSITORYEXTENSION_PARENT;
    public static Guid Clsid_SpeechTip;
    public static Guid Guid_Null;
    public static Guid IID_ITfFnCustomSpeechCommand;
    public static Guid IID_ITfFnReconversion;
    public static Guid IID_ITfFnConfigure;
    public static Guid IID_ITfFnConfigureRegisterWord;
    public static Guid TSATTRID_Font_FaceName;
    public static Guid TSATTRID_Font_SizePts;
    public static Guid TSATTRID_Font_Style_Height;
    public static Guid TSATTRID_Text_VerticalWriting;
    public static Guid TSATTRID_Text_Orientation;
    public static Guid TSATTRID_Text_ReadOnly;
    public static Guid GUID_SYSTEM_FUNCTIONPROVIDER;
    private static UnsafeNativeMethods();
    public static int OleGetClipboard(IDataObject& data);
    public static int OleSetClipboard(IDataObject pDataObj);
    public static int OleFlushClipboard();
    public static int GetCurrentThemeName(StringBuilder pszThemeFileName, int dwMaxNameChars, StringBuilder pszColorBuff, int dwMaxColorChars, StringBuilder pszSizeBuff, int cchMaxSizeChars);
    public static int DwmIsCompositionEnabled(Int32& enabled);
    public static IntPtr GetCurrentThread();
    public static WindowMessage RegisterWindowMessage(string msg);
    public static bool SetWindowPos(HandleRef hWnd, HandleRef hWndInsertAfter, int x, int y, int cx, int cy, int flags);
    public static IntPtr GetWindow(HandleRef hWnd, int uCmd);
    public static UInt32 GetDpiForMonitor(HandleRef hMonitor, MONITOR_DPI_TYPE dpiType, UInt32& dpiX, UInt32& dpiY);
    internal static bool IsProcessDPIAware();
    public static IntPtr OpenProcess(int dwDesiredAccess, bool fInherit, int dwProcessId);
    public static bool EnableNonClientDpiScaling(HandleRef hWnd);
    public static int GetClassName(HandleRef hwnd, StringBuilder lpClassName, int nMaxCount);
    public static int MessageBox(HandleRef hWnd, string text, string caption, int type);
    public static int CriticalSetWindowTheme(HandleRef hWnd, string subAppName, string subIdList);
    public static IntPtr CreateCompatibleBitmap(HandleRef hDC, int width, int height);
    public static IntPtr CriticalCreateCompatibleBitmap(HandleRef hDC, int width, int height);
    public static IntPtr CriticalGetStockObject(int stockObject);
    public static int CriticalFillRect(IntPtr hdc, RECT& rcFill, IntPtr brush);
    public static int GetBitmapBits(HandleRef hbmp, int cbBuffer, Byte[] lpvBits);
    public static bool ShowWindow(HandleRef hWnd, int nCmdShow);
    public static void DeleteObject(HandleRef hObject);
    public static bool DeleteObjectNoThrow(HandleRef hObject);
    public static bool IntDeleteObject(HandleRef hObject);
    public static IntPtr SelectObject(HandleRef hdc, IntPtr obj);
    public static IntPtr SelectObject(HandleRef hdc, BitmapHandle obj);
    public static IntPtr CriticalSelectObject(HandleRef hdc, IntPtr obj);
    public static int GetClipboardFormatName(int format, StringBuilder lpString, int cchMax);
    public static int RegisterClipboardFormat(string format);
    public static bool BitBlt(HandleRef hDC, int x, int y, int nWidth, int nHeight, HandleRef hSrcDC, int xSrc, int ySrc, int dwRop);
    public static bool CriticalPrintWindow(HandleRef hWnd, HandleRef hDC, int flags);
    public static bool CriticalRedrawWindow(HandleRef hWnd, IntPtr lprcUpdate, IntPtr hrgnUpdate, int flags);
    public static int DragQueryFile(HandleRef hDrop, int iFile, StringBuilder lpszFile, int cch);
    public static IntPtr ShellExecute(HandleRef hwnd, string lpOperation, string lpFile, string lpParameters, string lpDirectory, int nShowCmd);
    internal static bool ShellExecuteEx(ShellExecuteInfo lpExecInfo);
    public static int MultiByteToWideChar(int CodePage, int dwFlags, Byte[] lpMultiByteStr, int cchMultiByte, StringBuilder lpWideCharStr, int cchWideChar);
    public static int WideCharToMultiByte(int codePage, int flags, string wideStr, int chars, Byte[] pOutBytes, int bufferBytes, IntPtr defaultChar, IntPtr pDefaultUsed);
    public static void CopyMemoryW(IntPtr pdst, string psrc, int cb);
    public static void CopyMemoryW(IntPtr pdst, Char[] psrc, int cb);
    public static void CopyMemory(IntPtr pdst, Byte[] psrc, int cb);
    private static int IntGetKeyboardState(Byte[] keystate);
    public static void GetKeyboardState(Byte[] keystate);
    private static int IntGetModuleFileName(HandleRef hModule, StringBuilder buffer, int length);
    internal static string GetModuleFileName(HandleRef hModule);
    public static bool TranslateMessage(MSG& msg);
    public static IntPtr DispatchMessage(MSG& msg);
    private static int IntPostThreadMessage(int id, int msg, IntPtr wparam, IntPtr lparam);
    public static void PostThreadMessage(int id, int msg, IntPtr wparam, IntPtr lparam);
    internal static int ObjectFromLresult(IntPtr lResult, Guid& iid, IntPtr wParam, IAccessible& ppvObject);
    internal static bool IsWinEventHookInstalled(int winevent);
    private static int IntOleInitialize(IntPtr val);
    public static int OleInitialize();
    public static int CoRegisterPSClsid(Guid& riid, Guid& rclsid);
    public static bool EnumThreadWindows(int dwThreadId, EnumThreadWindowsCallback lpfn, HandleRef lParam);
    public static int OleUninitialize();
    private static bool IntCloseHandle(HandleRef handle);
    public static bool CloseHandleNoThrow(HandleRef handle);
    public static int CreateStreamOnHGlobal(IntPtr hGlobal, bool fDeleteOnRelease, IStream& istream);
    private static IntPtr IntCreateCompatibleDC(HandleRef hDC);
    public static IntPtr CriticalCreateCompatibleDC(HandleRef hDC);
    public static IntPtr CreateCompatibleDC(HandleRef hDC);
    private static bool IntUnmapViewOfFile(HandleRef pvBaseAddress);
    public static bool UnmapViewOfFileNoThrow(HandleRef pvBaseAddress);
    public static bool EnableWindow(HandleRef hWnd, bool enable);
    public static bool EnableWindowNoThrow(HandleRef hWnd, bool enable);
    public static int GetObject(HandleRef hObject, int nSize, BITMAP bm);
    public static IntPtr GetFocus();
    private static bool IntGetCursorPos(POINT& pt);
    internal static bool GetCursorPos(POINT& pt);
    private static bool IntTryGetCursorPos(POINT& pt);
    internal static bool TryGetCursorPos(POINT& pt);
    public static int GetWindowThreadProcessId(HandleRef hWnd, Int32& lpdwProcessId);
    public static short GetKeyState(int keyCode);
    public static void DoDragDrop(IDataObject dataObject, IOleDropSource dropSource, int allowedEffects, Int32[] finalEffect);
    internal static void ReleaseStgMedium(STGMEDIUM& medium);
    public static bool InvalidateRect(HandleRef hWnd, IntPtr rect, bool erase);
    internal static int GetWindowText(HandleRef hWnd, StringBuilder lpString, int nMaxCount);
    internal static int GetWindowTextLength(HandleRef hWnd);
    public static IntPtr GlobalAlloc(int uFlags, IntPtr dwBytes);
    public static IntPtr GlobalReAlloc(HandleRef handle, IntPtr bytes, int flags);
    public static IntPtr GlobalLock(HandleRef handle);
    public static bool GlobalUnlock(HandleRef handle);
    public static IntPtr GlobalFree(HandleRef handle);
    public static IntPtr GlobalSize(HandleRef handle);
    public static bool ImmSetConversionStatus(HandleRef hIMC, int conversion, int sentence);
    public static bool ImmGetConversionStatus(HandleRef hIMC, Int32& conversion, Int32& sentence);
    public static IntPtr ImmGetContext(HandleRef hWnd);
    public static bool ImmReleaseContext(HandleRef hWnd, HandleRef hIMC);
    public static IntPtr ImmAssociateContext(HandleRef hWnd, HandleRef hIMC);
    public static bool ImmSetOpenStatus(HandleRef hIMC, bool open);
    public static bool ImmGetOpenStatus(HandleRef hIMC);
    public static bool ImmNotifyIME(HandleRef hIMC, int dwAction, int dwIndex, int dwValue);
    public static int ImmGetProperty(HandleRef hkl, int flags);
    public static int ImmGetCompositionString(HandleRef hIMC, int dwIndex, Char[] lpBuf, int dwBufLen);
    public static int ImmGetCompositionString(HandleRef hIMC, int dwIndex, Byte[] lpBuf, int dwBufLen);
    public static int ImmGetCompositionString(HandleRef hIMC, int dwIndex, Int32[] lpBuf, int dwBufLen);
    public static int ImmGetCompositionString(HandleRef hIMC, int dwIndex, IntPtr lpBuf, int dwBufLen);
    public static int ImmConfigureIME(HandleRef hkl, HandleRef hwnd, int dwData, IntPtr pvoid);
    public static int ImmConfigureIME(HandleRef hkl, HandleRef hwnd, int dwData, REGISTERWORD& registerWord);
    public static int ImmSetCompositionWindow(HandleRef hIMC, COMPOSITIONFORM& compform);
    public static int ImmSetCandidateWindow(HandleRef hIMC, CANDIDATEFORM& candform);
    public static IntPtr ImmGetDefaultIMEWnd(HandleRef hwnd);
    internal static IntPtr SetFocus(HandleRef hWnd);
    internal static bool TrySetFocus(HandleRef hWnd);
    internal static bool TrySetFocus(HandleRef hWnd, IntPtr& result);
    internal static IntPtr GetParent(HandleRef hWnd);
    public static IntPtr GetAncestor(HandleRef hWnd, int flags);
    public static bool IsChild(HandleRef hWndParent, HandleRef hwnd);
    public static IntPtr SetParent(HandleRef hWnd, HandleRef hWndParent);
    private static IntPtr IntGetModuleHandle(string modName);
    internal static IntPtr GetModuleHandle(string modName);
    public static IntPtr CallWindowProc(IntPtr wndProc, IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
    public static IntPtr DefWindowProc(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);
    public static IntPtr IntGetProcAddress(HandleRef hModule, string lpProcName);
    public static IntPtr GetProcAddress(HandleRef hModule, string lpProcName);
    public static IntPtr GetProcAddressNoThrow(HandleRef hModule, string lpProcName);
    public static IntPtr LoadLibrary(string lpFileName);
    [ObsoleteAttribute("Use LoadLibraryHelper.SafeLoadLibraryEx instead")]
internal static IntPtr LoadLibraryEx(string lpFileName, IntPtr hFile, LoadLibraryFlags dwFlags);
    internal static bool GetModuleHandleEx(GetModuleHandleFlags dwFlags, string lpModuleName, IntPtr& hModule);
    internal static bool FreeLibrary(IntPtr hModule);
    public static int GetSystemMetrics(SM nIndex);
    public static bool SystemParametersInfo(int nAction, int nParam, RECT& rc, int nUpdate);
    public static bool SystemParametersInfo(int nAction, int nParam, Int32& value, int ignore);
    public static bool SystemParametersInfo(int nAction, int nParam, Boolean& value, int ignore);
    public static bool SystemParametersInfo(int nAction, int nParam, HIGHCONTRAST_I& rc, int nUpdate);
    public static bool SystemParametersInfo(int nAction, int nParam, NONCLIENTMETRICS metrics, int nUpdate);
    public static bool GetSystemPowerStatus(SYSTEM_POWER_STATUS& systemPowerStatus);
    private static int IntClientToScreen(HandleRef hWnd, POINT& pt);
    public static void ClientToScreen(HandleRef hWnd, POINT& pt);
    public static IntPtr GetDesktopWindow();
    public static IntPtr GetForegroundWindow();
    public static int RegisterDragDrop(HandleRef hwnd, IOleDropTarget target);
    public static int RevokeDragDrop(HandleRef hwnd);
    public static bool PeekMessage(MSG& msg, HandleRef hwnd, WindowMessage msgMin, WindowMessage msgMax, int remove);
    public static bool SetProp(HandleRef hWnd, string propName, HandleRef data);
    private static bool IntPostMessage(HandleRef hwnd, WindowMessage msg, IntPtr wparam, IntPtr lparam);
    internal static void PostMessage(HandleRef hwnd, WindowMessage msg, IntPtr wparam, IntPtr lparam);
    internal static bool TryPostMessage(HandleRef hwnd, WindowMessage msg, IntPtr wparam, IntPtr lparam);
    public static void NotifyWinEvent(int winEvent, HandleRef hwnd, int objType, int objID);
    private static IntPtr IntBeginPaint(HandleRef hWnd, PAINTSTRUCT& lpPaint);
    public static IntPtr BeginPaint(HandleRef hWnd, PAINTSTRUCT& lpPaint);
    private static bool IntEndPaint(HandleRef hWnd, PAINTSTRUCT& lpPaint);
    public static bool EndPaint(HandleRef hWnd, PAINTSTRUCT& lpPaint);
    private static IntPtr IntGetDC(HandleRef hWnd);
    public static IntPtr GetDC(HandleRef hWnd);
    private static int IntReleaseDC(HandleRef hWnd, HandleRef hDC);
    public static int ReleaseDC(HandleRef hWnd, HandleRef hDC);
    public static int GetDeviceCaps(HandleRef hDC, int nIndex);
    public static IntPtr GetActiveWindow();
    public static bool SetForegroundWindow(HandleRef hWnd);
    internal static int CommDlgExtendedError();
    internal static bool GetOpenFileName(OPENFILENAME_I ofn);
    internal static bool GetSaveFileName(OPENFILENAME_I ofn);
    public static bool SetLayeredWindowAttributes(HandleRef hwnd, int crKey, byte bAlpha, int dwFlags);
    public static bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, POINT* pptDst, POINT* pSizeDst, IntPtr hdcSrc, POINT* pptSrc, int crKey, BLENDFUNCTION& pBlend, int dwFlags);
    public static IntPtr SetActiveWindow(HandleRef hWnd);
    private static bool IntDestroyCursor(IntPtr hCurs);
    public static bool DestroyCursor(IntPtr hCurs);
    private static bool IntDestroyIcon(IntPtr hIcon);
    public static bool DestroyIcon(IntPtr hIcon);
    private static bool IntDeleteObject(IntPtr hObject);
    public static bool DeleteObject(IntPtr hObject);
    private static BitmapHandle PrivateCreateDIBSection(HandleRef hdc, BITMAPINFO& bitmapInfo, int iUsage, IntPtr& ppvBits, SafeFileMappingHandle hSection, int dwOffset);
    internal static BitmapHandle CreateDIBSection(HandleRef hdc, BITMAPINFO& bitmapInfo, int iUsage, IntPtr& ppvBits, SafeFileMappingHandle hSection, int dwOffset);
    private static BitmapHandle PrivateCreateBitmap(int width, int height, int planes, int bitsPerPixel, Byte[] lpvBits);
    internal static BitmapHandle CreateBitmap(int width, int height, int planes, int bitsPerPixel, Byte[] lpvBits);
    private static bool PrivateDestroyIcon(HandleRef handle);
    internal static bool DestroyIcon(HandleRef handle);
    private static IconHandle PrivateCreateIconIndirect(ICONINFO iconInfo);
    internal static IconHandle CreateIconIndirect(ICONINFO iconInfo);
    public static bool IsWindow(HandleRef hWnd);
    private static bool IntDeleteDC(HandleRef hDC);
    public static void DeleteDC(HandleRef hDC);
    private static bool IntCriticalDeleteDC(HandleRef hDC);
    public static void CriticalDeleteDC(HandleRef hDC);
    private static int IntGetMessageW(MSG& msg, HandleRef hWnd, int uMsgFilterMin, int uMsgFilterMax);
    public static bool GetMessageW(MSG& msg, HandleRef hWnd, int uMsgFilterMin, int uMsgFilterMax);
    private static IntPtr IntWindowFromPoint(POINT pt);
    public static IntPtr WindowFromPoint(int x, int y);
    public static IntPtr IntCreateWindowEx(int dwExStyle, string lpszClassName, string lpszWindowName, int style, int x, int y, int width, int height, HandleRef hWndParent, HandleRef hMenu, HandleRef hInst, object pvParam);
    public static IntPtr CreateWindowEx(int dwExStyle, string lpszClassName, string lpszWindowName, int style, int x, int y, int width, int height, HandleRef hWndParent, HandleRef hMenu, HandleRef hInst, object pvParam);
    public static bool IntDestroyWindow(HandleRef hWnd);
    public static void DestroyWindow(HandleRef hWnd);
    internal static IntPtr SetWinEventHook(int eventMin, int eventMax, IntPtr hmodWinEventProc, WinEventProcDef WinEventReentrancyFilter, UInt32 idProcess, UInt32 idThread, int dwFlags);
    internal static bool UnhookWinEvent(IntPtr winEventHook);
    public static void EnumChildWindows(HandleRef hwndParent, EnumChildrenCallback lpEnumFunc, HandleRef lParam);
    private static bool IntEnumChildWindows(HandleRef hwndParent, EnumChildrenCallback lpEnumFunc, HandleRef lParam);
    public static int GetWindowRgn(HandleRef hWnd, HandleRef hRgn);
    public static bool PtInRegion(HandleRef hRgn, int X, int Y);
    public static IntPtr CreateRectRgn(int x1, int y1, int x2, int y2);
    private static int VariantClear(IntPtr pObject);
    public static UInt32 GetRawInputDeviceList(RAWINPUTDEVICELIST[] ridl, UInt32& numDevices, UInt32 sizeInBytes);
    public static UInt32 GetRawInputDeviceInfo(IntPtr hDevice, UInt32 command, RID_DEVICE_INFO& ridInfo, UInt32& sizeInBytes);
    internal static IntPtr GetMenu(HandleRef hWnd);
    internal static DpiAwarenessContextHandle SetThreadDpiAwarenessContext(DpiAwarenessContextHandle dpiContext);
    internal static DpiAwarenessContextHandle GetThreadDpiAwarenessContext();
    internal static bool EnumDisplayMonitors(IntPtr hdc, IntPtr lprcClip, MonitorEnumProc lpfnEnum, IntPtr lParam);
    internal static int WldpIsDynamicCodePolicyEnabled(Boolean& enabled);
    internal static UInt32 _GetTempFileName(string tmpPath, string prefix, UInt32 uniqueIdOrZero, StringBuilder tmpFileName);
    internal static UInt32 GetTempFileName(string tmpPath, string prefix, UInt32 uniqueIdOrZero, StringBuilder tmpFileName);
    internal static int ExtractIconEx(string szExeFileName, int nIconIndex, IconHandle& phiconLarge, IconHandle& phiconSmall, int nIcons);
    internal static IconHandle CreateIcon(IntPtr hInstance, int nWidth, int nHeight, byte cPlanes, byte cBitsPixel, Byte[] lpbANDbits, Byte[] lpbXORbits);
    public static bool CreateCaret(HandleRef hwnd, BitmapHandle hbitmap, int width, int height);
    public static bool ShowCaret(HandleRef hwnd);
    public static bool HideCaret(HandleRef hwnd);
    public static bool ShowWindowAsync(HandleRef hWnd, int nCmdShow);
    internal static IconHandle LoadImageIcon(IntPtr hinst, string stName, int nType, int cxDesired, int cyDesired, int nFlags);
    internal static CursorHandle LoadImageCursor(IntPtr hinst, string stName, int nType, int cxDesired, int cyDesired, int nFlags);
    internal static int CoInternetIsFeatureEnabled(int featureEntry, int dwFlags);
    internal static int CoInternetSetFeatureEnabled(int featureEntry, int dwFlags, bool fEnable);
    internal static int CoInternetIsFeatureZoneElevationEnabled(string szFromURL, string szToURL, IInternetSecurityManager secMgr, int dwFlags);
    internal static void ProcessUnhandledException_DLL(string errMsg);
    internal static bool GetVersionEx(OSVERSIONINFOEX ver);
    internal static int CoInternetCreateSecurityManager(object pIServiceProvider, Object& ppISecurityManager, int dwReserved);
    internal static IntPtr LocalFree(IntPtr hMem);
    internal static SafeFileHandle CreateFile(string lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, SECURITY_ATTRIBUTES lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static IntPtr GetMessageExtraInfo();
    internal static IntPtr SetMessageExtraInfo(IntPtr lParam);
    private static int IntWaitForMultipleObjectsEx(int nCount, IntPtr[] pHandles, bool bWaitAll, int dwMilliseconds, bool bAlertable);
    internal static int WaitForMultipleObjectsEx(int nCount, IntPtr[] pHandles, bool bWaitAll, int dwMilliseconds, bool bAlertable);
    private static int IntMsgWaitForMultipleObjectsEx(int nCount, IntPtr[] pHandles, int dwMilliseconds, int dwWakeMask, int dwFlags);
    internal static int MsgWaitForMultipleObjectsEx(int nCount, IntPtr[] pHandles, int dwMilliseconds, int dwWakeMask, int dwFlags);
    internal static ushort IntRegisterClassEx(WNDCLASSEX_D wc_d);
    internal static ushort RegisterClassEx(WNDCLASSEX_D wc_d);
    internal static int IntUnregisterClass(IntPtr atomString, IntPtr hInstance);
    internal static void UnregisterClass(IntPtr atomString, IntPtr hInstance);
    private static bool IntChangeWindowMessageFilter(WindowMessage message, MSGFLT dwFlag);
    private static bool IntChangeWindowMessageFilterEx(IntPtr hwnd, WindowMessage message, MSGFLT action, CHANGEFILTERSTRUCT& pChangeFilterStruct);
    internal static HRESULT ChangeWindowMessageFilterEx(IntPtr hwnd, WindowMessage message, MSGFLT action, MSGFLTINFO& extStatus);
    private static HRESULT ObtainUserAgentString(int dwOption, StringBuilder userAgent, Int32& length);
    internal static string ObtainUserAgentString();
    internal static IntPtr SendMessage(IntPtr hWnd, WindowMessage msg, IntPtr wParam, IntPtr lParam);
    internal static IntPtr UnsafeSendMessage(IntPtr hWnd, WindowMessage msg, IntPtr wParam, IntPtr lParam);
    internal static IntPtr RegisterPowerSettingNotification(IntPtr hRecipient, Guid* pGuid, int Flags);
    internal static IntPtr UnregisterPowerSettingNotification(IntPtr hPowerNotify);
    internal static IntPtr SendMessage(HandleRef hWnd, WindowMessage msg, IntPtr wParam, IconHandle iconHandle);
    internal static void SetLastError(int dwErrorCode);
    public static bool GetLayeredWindowAttributes(HandleRef hwnd, IntPtr pcrKey, IntPtr pbAlpha, IntPtr pdwFlags);
    internal static SafeFileMappingHandle CreateFileMapping(SafeFileHandle hFile, SECURITY_ATTRIBUTES lpFileMappingAttributes, int flProtect, UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, string lpName);
    internal static SafeViewOfFileHandle MapViewOfFileEx(SafeFileMappingHandle hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, IntPtr dwNumberOfBytesToMap, IntPtr lpBaseAddress);
    internal static IntPtr SetWindowLong(HandleRef hWnd, int nIndex, IntPtr dwNewLong);
    internal static IntPtr CriticalSetWindowLong(HandleRef hWnd, int nIndex, IntPtr dwNewLong);
    internal static IntPtr CriticalSetWindowLong(HandleRef hWnd, int nIndex, WndProc dwNewLong);
    internal static IntPtr GetWindowLongPtr(HandleRef hWnd, int nIndex);
    internal static int GetWindowLong(HandleRef hWnd, int nIndex);
    internal static WndProc GetWindowLongWndProc(HandleRef hWnd);
    internal static bool PlaySound(string soundName, IntPtr hmod, PlaySoundFlags soundFlags);
    internal static bool InternetGetCookieEx(string Url, string cookieName, StringBuilder cookieData, UInt32& pchCookieData, UInt32 flags, IntPtr reserved);
    internal static UInt32 InternetSetCookieEx(string Url, string CookieName, string cookieData, UInt32 flags, string p3pHeader);
    internal static int GetLocaleInfoW(int locale, int type, string data, int dataSize);
    internal static int FindNLSString(int locale, UInt32 flags, string sourceString, int sourceCount, string findString, int findCount, Int32& found);
    private static bool IntSetWindowText(HandleRef hWnd, string text);
    internal static void SetWindowText(HandleRef hWnd, string text);
    private static bool GetIconInfoImpl(HandleRef hIcon, ICONINFO_IMPL piconinfo);
    internal static void GetIconInfo(HandleRef hIcon, ICONINFO& piconinfo);
    private static bool IntGetWindowPlacement(HandleRef hWnd, WINDOWPLACEMENT& placement);
    internal static void GetWindowPlacement(HandleRef hWnd, WINDOWPLACEMENT& placement);
    private static bool IntSetWindowPlacement(HandleRef hWnd, WINDOWPLACEMENT& placement);
    internal static void SetWindowPlacement(HandleRef hWnd, WINDOWPLACEMENT& placement);
    internal static bool SystemParametersInfo(int nAction, int nParam, ANIMATIONINFO anim, int nUpdate);
    internal static bool SystemParametersInfo(int nAction, int nParam, ICONMETRICS metrics, int nUpdate);
    public static bool BeginPanningFeedback(HandleRef hwnd);
    public static bool UpdatePanningFeedback(HandleRef hwnd, int lTotalOverpanOffsetX, int lTotalOverpanOffsetY, bool fInInertia);
    public static bool EndPanningFeedback(HandleRef hwnd, bool fAnimateBack);
    public static bool SetEvent(IntPtr hEvent);
    public static int SetEvent(SafeWaitHandle hHandle);
    public static int WaitForSingleObject(SafeWaitHandle hHandle, int dwMilliseconds);
    internal static int GetMouseMovePointsEx(UInt32 cbSize, MOUSEMOVEPOINT& pointsIn, MOUSEMOVEPOINT[] pointsBufferOut, int nBufPoints, UInt32 resolution);
    internal static bool GetFileSizeEx(SafeFileHandle hFile, LARGE_INTEGER& lpFileSize);
    internal static bool ConvertStringSecurityDescriptorToSecurityDescriptor(string stringSecurityDescriptor, int stringSDRevision, IntPtr& securityDescriptor, IntPtr securityDescriptorSize);
    internal static SafeFileMappingHandle OpenFileMapping(int dwDesiredAccess, bool bInheritHandle, string lpName);
    internal static IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, int flAllocationType, int flProtect);
    public static int OleIsCurrentClipboard(IDataObject pDataObj);
    internal static int GetOEMCP();
    internal static int RtlNtStatusToDosError(int Status);
    internal static bool NtSuccess(int err);
    internal static void NtCheck(int err);
    internal static int SafeReleaseComObject(object o);
    internal static bool GetUrlCacheConfigInfo(InternetCacheConfigInfo& pInternetCacheConfigInfo, UInt32& cbCacheConfigInfo, UInt32 fieldControl);
    public static bool WTSRegisterSessionNotification(IntPtr hwnd, UInt32 dwFlags);
    public static bool WTSUnRegisterSessionNotification(IntPtr hwnd);
    public static IntPtr GetCurrentProcess();
    public static bool DuplicateHandle(IntPtr hSourceProcess, SafeWaitHandle hSourceHandle, IntPtr hTargetProcessHandle, IntPtr& hTargetHandle, UInt32 dwDesiredAccess, bool fInheritHandle, UInt32 dwOptions);
    public static bool IsIconic(IntPtr hWnd);
    public static HandleRef SetWindowsHookEx(HookType idHook, HookProc lpfn, IntPtr hMod, int dwThreadId);
    private static IntPtr IntSetWindowsHookEx(HookType idHook, HookProc lpfn, IntPtr hMod, int dwThreadId);
    public static bool UnhookWindowsHookEx(HandleRef hhk);
    public static IntPtr CallNextHookEx(HandleRef hhk, int nCode, IntPtr wParam, IntPtr lParam);
    internal static int TF_CreateThreadMgr(ITfThreadMgr& threadManager);
    public static int TF_CreateInputProcessorProfiles(ITfInputProcessorProfiles& profiles);
    public static int TF_CreateDisplayAttributeMgr(ITfDisplayAttributeMgr& dam);
    public static int TF_CreateCategoryMgr(ITfCategoryMgr& catmgr);
}
internal static class System.AppContextDefaultValues : object {
    public static void PopulateDefaultValues();
    private static void ParseTargetFrameworkName(String& identifier, String& profile, Int32& version);
    private static string GetTargetFrameworkMoniker();
    private static bool TryParseFrameworkName(string frameworkName, String& identifier, Int32& version, String& profile);
    private static void PopulateDefaultValuesPartial(string platformIdentifier, string profile, int targetFrameworkVersion);
    private static void InitializeNetFxSwitchDefaultsForNetCoreRuntime();
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Count = {Count}")]
[FriendAccessAllowedAttribute]
internal class System.Collections.ObjectModel.WeakReadOnlyCollection`1 : object {
    private IList`1<WeakReference> list;
    private object _syncRoot;
    public int Count { get; }
    public T Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public WeakReadOnlyCollection`1(IList`1<WeakReference> list);
    public sealed virtual int get_Count();
    public T get_Item(int index);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private static bool IsCompatibleObject(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private IList`1<T> CreateDereferencedList();
}
public class System.Collections.Specialized.CollectionChangedEventManager : WeakEventManager {
    private static CollectionChangedEventManager CurrentManager { get; }
    public static void AddListener(INotifyCollectionChanged source, IWeakEventListener listener);
    public static void RemoveListener(INotifyCollectionChanged source, IWeakEventListener listener);
    public static void AddHandler(INotifyCollectionChanged source, EventHandler`1<NotifyCollectionChangedEventArgs> handler);
    public static void RemoveHandler(INotifyCollectionChanged source, EventHandler`1<NotifyCollectionChangedEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private static CollectionChangedEventManager get_CurrentManager();
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs args);
}
public class System.ComponentModel.CurrentChangedEventManager : WeakEventManager {
    private static CurrentChangedEventManager CurrentManager { get; }
    public static void AddListener(ICollectionView source, IWeakEventListener listener);
    public static void RemoveListener(ICollectionView source, IWeakEventListener listener);
    public static void AddHandler(ICollectionView source, EventHandler`1<EventArgs> handler);
    public static void RemoveHandler(ICollectionView source, EventHandler`1<EventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private static CurrentChangedEventManager get_CurrentManager();
    private void OnCurrentChanged(object sender, EventArgs args);
}
public class System.ComponentModel.CurrentChangingEventArgs : EventArgs {
    private bool _cancel;
    private bool _isCancelable;
    public bool IsCancelable { get; }
    public bool Cancel { get; public set; }
    public CurrentChangingEventArgs(bool isCancelable);
    private void Initialize(bool isCancelable);
    public bool get_IsCancelable();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class System.ComponentModel.CurrentChangingEventHandler : MulticastDelegate {
    public CurrentChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CurrentChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CurrentChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.CurrentChangingEventManager : WeakEventManager {
    private static CurrentChangingEventManager CurrentManager { get; }
    public static void AddListener(ICollectionView source, IWeakEventListener listener);
    public static void RemoveListener(ICollectionView source, IWeakEventListener listener);
    public static void AddHandler(ICollectionView source, EventHandler`1<CurrentChangingEventArgs> handler);
    public static void RemoveHandler(ICollectionView source, EventHandler`1<CurrentChangingEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private static CurrentChangingEventManager get_CurrentManager();
    private void OnCurrentChanging(object sender, CurrentChangingEventArgs args);
}
public class System.ComponentModel.DependencyPropertyDescriptor : PropertyDescriptor {
    private PropertyDescriptor _property;
    private Type _componentType;
    private DependencyProperty _dp;
    private bool _isAttached;
    private PropertyMetadata _metadata;
    private static Dictionary`2<object, DependencyPropertyDescriptor> _cache;
    private static Dictionary`2<object, DependencyPropertyDescriptor> _ignorePropertyTypeCache;
    public DependencyProperty DependencyProperty { get; }
    public bool IsAttached { get; }
    public PropertyMetadata Metadata { get; }
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public AttributeCollection Attributes { get; }
    public string Category { get; }
    public string Description { get; }
    public bool DesignTimeOnly { get; }
    public string DisplayName { get; }
    public TypeConverter Converter { get; }
    public bool IsBrowsable { get; }
    public bool IsLocalizable { get; }
    public bool SupportsChangeEvents { get; }
    public CoerceValueCallback DesignerCoerceValueCallback { get; public set; }
    private PropertyDescriptor Property { get; }
    private DependencyPropertyDescriptor(PropertyDescriptor property, string name, Type componentType, DependencyProperty dp, bool isAttached);
    private static DependencyPropertyDescriptor();
    public static DependencyPropertyDescriptor FromProperty(PropertyDescriptor property);
    internal static DependencyPropertyDescriptor FromProperty(DependencyProperty dependencyProperty, Type ownerType, Type targetType, bool ignorePropertyType);
    public static DependencyPropertyDescriptor FromProperty(DependencyProperty dependencyProperty, Type targetType);
    public static DependencyPropertyDescriptor FromName(string name, Type ownerType, Type targetType);
    public static DependencyPropertyDescriptor FromName(string name, Type ownerType, Type targetType, bool ignorePropertyType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool CanResetValue(object component);
    public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual void AddValueChanged(object component, EventHandler handler);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
    public virtual PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter);
    public virtual object GetEditor(Type editorBaseType);
    public DependencyProperty get_DependencyProperty();
    public bool get_IsAttached();
    public PropertyMetadata get_Metadata();
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    public virtual AttributeCollection get_Attributes();
    public virtual string get_Category();
    public virtual string get_Description();
    public virtual bool get_DesignTimeOnly();
    public virtual string get_DisplayName();
    public virtual TypeConverter get_Converter();
    public virtual bool get_IsBrowsable();
    public virtual bool get_IsLocalizable();
    public virtual bool get_SupportsChangeEvents();
    public CoerceValueCallback get_DesignerCoerceValueCallback();
    public void set_DesignerCoerceValueCallback(CoerceValueCallback value);
    internal static void ClearCache();
    private PropertyDescriptor get_Property();
}
public class System.ComponentModel.ErrorsChangedEventManager : WeakEventManager {
    private static ErrorsChangedEventManager CurrentManager { get; }
    public static void AddHandler(INotifyDataErrorInfo source, EventHandler`1<DataErrorsChangedEventArgs> handler);
    public static void RemoveHandler(INotifyDataErrorInfo source, EventHandler`1<DataErrorsChangedEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private static ErrorsChangedEventManager get_CurrentManager();
    private void OnErrorsChanged(object sender, DataErrorsChangedEventArgs args);
}
public abstract class System.ComponentModel.GroupDescription : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    private ObservableCollection`1<object> _explicitGroupNames;
    private SortDescriptionCollection _sort;
    private IComparer _customSort;
    public ObservableCollection`1<object> GroupNames { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public IComparer CustomSort { get; public set; }
    internal SortDescriptionCollection SortDescriptionsInternal { get; }
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    public ObservableCollection`1<object> get_GroupNames();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeGroupNames();
    public SortDescriptionCollection get_SortDescriptions();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSortDescriptions();
    public IComparer get_CustomSort();
    public void set_CustomSort(IComparer value);
    public abstract virtual object GroupNameFromItem(object item, int level, CultureInfo culture);
    public virtual bool NamesMatch(object groupName, object itemName);
    internal SortDescriptionCollection get_SortDescriptionsInternal();
    private void OnGroupNamesChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void SetSortDescriptions(SortDescriptionCollection descriptions);
    private void SortDescriptionsChanged(object sender, NotifyCollectionChangedEventArgs e);
}
public interface System.ComponentModel.ICollectionView {
    public CultureInfo Culture { get; public set; }
    public IEnumerable SourceCollection { get; }
    public Predicate`1<object> Filter { get; public set; }
    public bool CanFilter { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public bool IsEmpty { get; }
    public object CurrentItem { get; }
    public int CurrentPosition { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public abstract virtual CultureInfo get_Culture();
    public abstract virtual void set_Culture(CultureInfo value);
    public abstract virtual bool Contains(object item);
    public abstract virtual IEnumerable get_SourceCollection();
    public abstract virtual Predicate`1<object> get_Filter();
    public abstract virtual void set_Filter(Predicate`1<object> value);
    public abstract virtual bool get_CanFilter();
    public abstract virtual SortDescriptionCollection get_SortDescriptions();
    public abstract virtual bool get_CanSort();
    public abstract virtual bool get_CanGroup();
    public abstract virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public abstract virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual void Refresh();
    public abstract virtual IDisposable DeferRefresh();
    public abstract virtual object get_CurrentItem();
    public abstract virtual int get_CurrentPosition();
    public abstract virtual bool get_IsCurrentAfterLast();
    public abstract virtual bool get_IsCurrentBeforeFirst();
    public abstract virtual bool MoveCurrentToFirst();
    public abstract virtual bool MoveCurrentToLast();
    public abstract virtual bool MoveCurrentToNext();
    public abstract virtual bool MoveCurrentToPrevious();
    public abstract virtual bool MoveCurrentTo(object item);
    public abstract virtual bool MoveCurrentToPosition(int position);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentChanged(EventHandler value);
}
public interface System.ComponentModel.ICollectionViewFactory {
    public abstract virtual ICollectionView CreateView();
}
public interface System.ComponentModel.ICollectionViewLiveShaping {
    public bool CanChangeLiveSorting { get; }
    public bool CanChangeLiveFiltering { get; }
    public bool CanChangeLiveGrouping { get; }
    public Nullable`1<bool> IsLiveSorting { get; public set; }
    public Nullable`1<bool> IsLiveFiltering { get; public set; }
    public Nullable`1<bool> IsLiveGrouping { get; public set; }
    public ObservableCollection`1<string> LiveSortingProperties { get; }
    public ObservableCollection`1<string> LiveFilteringProperties { get; }
    public ObservableCollection`1<string> LiveGroupingProperties { get; }
    public abstract virtual bool get_CanChangeLiveSorting();
    public abstract virtual bool get_CanChangeLiveFiltering();
    public abstract virtual bool get_CanChangeLiveGrouping();
    public abstract virtual Nullable`1<bool> get_IsLiveSorting();
    public abstract virtual void set_IsLiveSorting(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_IsLiveFiltering();
    public abstract virtual void set_IsLiveFiltering(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_IsLiveGrouping();
    public abstract virtual void set_IsLiveGrouping(Nullable`1<bool> value);
    public abstract virtual ObservableCollection`1<string> get_LiveSortingProperties();
    public abstract virtual ObservableCollection`1<string> get_LiveFilteringProperties();
    public abstract virtual ObservableCollection`1<string> get_LiveGroupingProperties();
}
public interface System.ComponentModel.IEditableCollectionView {
    public NewItemPlaceholderPosition NewItemPlaceholderPosition { get; public set; }
    public bool CanAddNew { get; }
    public bool IsAddingNew { get; }
    public object CurrentAddItem { get; }
    public bool CanRemove { get; }
    public bool CanCancelEdit { get; }
    public bool IsEditingItem { get; }
    public object CurrentEditItem { get; }
    public abstract virtual NewItemPlaceholderPosition get_NewItemPlaceholderPosition();
    public abstract virtual void set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
    public abstract virtual bool get_CanAddNew();
    public abstract virtual object AddNew();
    public abstract virtual void CommitNew();
    public abstract virtual void CancelNew();
    public abstract virtual bool get_IsAddingNew();
    public abstract virtual object get_CurrentAddItem();
    public abstract virtual bool get_CanRemove();
    public abstract virtual void RemoveAt(int index);
    public abstract virtual void Remove(object item);
    public abstract virtual void EditItem(object item);
    public abstract virtual void CommitEdit();
    public abstract virtual void CancelEdit();
    public abstract virtual bool get_CanCancelEdit();
    public abstract virtual bool get_IsEditingItem();
    public abstract virtual object get_CurrentEditItem();
}
public interface System.ComponentModel.IEditableCollectionViewAddNewItem {
    public bool CanAddNewItem { get; }
    public abstract virtual bool get_CanAddNewItem();
    public abstract virtual object AddNewItem(object newItem);
}
public interface System.ComponentModel.IItemProperties {
    public ReadOnlyCollection`1<ItemPropertyInfo> ItemProperties { get; }
    public abstract virtual ReadOnlyCollection`1<ItemPropertyInfo> get_ItemProperties();
}
public class System.ComponentModel.ItemPropertyInfo : object {
    private string _name;
    private Type _type;
    private object _descriptor;
    public string Name { get; }
    public Type PropertyType { get; }
    public object Descriptor { get; }
    public ItemPropertyInfo(string name, Type type, object descriptor);
    public string get_Name();
    public Type get_PropertyType();
    public object get_Descriptor();
}
public enum System.ComponentModel.NewItemPlaceholderPosition : Enum {
    public int value__;
    public static NewItemPlaceholderPosition None;
    public static NewItemPlaceholderPosition AtBeginning;
    public static NewItemPlaceholderPosition AtEnd;
}
public class System.ComponentModel.PropertyChangedEventManager : WeakEventManager {
    private ListenerList _proposedAllListenersList;
    private List`1<string> _toRemove;
    private static string AllListenersKey;
    private static PropertyChangedEventManager CurrentManager { get; }
    private static PropertyChangedEventManager();
    public static void AddListener(INotifyPropertyChanged source, IWeakEventListener listener, string propertyName);
    public static void RemoveListener(INotifyPropertyChanged source, IWeakEventListener listener, string propertyName);
    public static void AddHandler(INotifyPropertyChanged source, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    public static void RemoveHandler(INotifyPropertyChanged source, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    protected virtual bool Purge(object source, object data, bool purgeAll);
    private static PropertyChangedEventManager get_CurrentManager();
    private void PrivateAddListener(INotifyPropertyChanged source, IWeakEventListener listener, string propertyName);
    private void PrivateRemoveListener(INotifyPropertyChanged source, IWeakEventListener listener, string propertyName);
    private void PrivateAddHandler(INotifyPropertyChanged source, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    private void PrivateRemoveHandler(INotifyPropertyChanged source, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    private void AddListener(INotifyPropertyChanged source, string propertyName, IWeakEventListener listener, EventHandler`1<PropertyChangedEventArgs> handler);
    private void RemoveListener(INotifyPropertyChanged source, string propertyName, IWeakEventListener listener, EventHandler`1<PropertyChangedEventArgs> handler);
    private void OnPropertyChanged(object sender, PropertyChangedEventArgs args);
}
[AttributeUsageAttribute("192")]
public class System.ComponentModel.PropertyFilterAttribute : Attribute {
    public static PropertyFilterAttribute Default;
    private PropertyFilterOptions _filter;
    public PropertyFilterOptions Filter { get; }
    public PropertyFilterAttribute(PropertyFilterOptions filter);
    private static PropertyFilterAttribute();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool Match(object value);
    public PropertyFilterOptions get_Filter();
}
[FlagsAttribute]
public enum System.ComponentModel.PropertyFilterOptions : Enum {
    public int value__;
    public static PropertyFilterOptions None;
    public static PropertyFilterOptions Invalid;
    public static PropertyFilterOptions SetValues;
    public static PropertyFilterOptions UnsetValues;
    public static PropertyFilterOptions Valid;
    public static PropertyFilterOptions All;
}
public class System.ComponentModel.SortDescription : ValueType {
    private string _propertyName;
    private ListSortDirection _direction;
    private bool _sealed;
    public string PropertyName { get; public set; }
    public ListSortDirection Direction { get; public set; }
    public bool IsSealed { get; }
    public SortDescription(string propertyName, ListSortDirection direction);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    public ListSortDirection get_Direction();
    public void set_Direction(ListSortDirection value);
    public bool get_IsSealed();
    public virtual bool Equals(object obj);
    public static bool op_Equality(SortDescription sd1, SortDescription sd2);
    public static bool op_Inequality(SortDescription sd1, SortDescription sd2);
    public virtual int GetHashCode();
    internal void Seal();
}
public class System.ComponentModel.SortDescriptionCollection : Collection`1<SortDescription> {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    public static SortDescriptionCollection Empty;
    private static SortDescriptionCollection();
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, SortDescription item);
    protected virtual void SetItem(int index, SortDescription item);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index);
    private void OnCollectionChanged(NotifyCollectionChangedAction action);
}
public enum System.Diagnostics.PresentationTraceLevel : Enum {
    public int value__;
    public static PresentationTraceLevel None;
    public static PresentationTraceLevel Low;
    public static PresentationTraceLevel Medium;
    public static PresentationTraceLevel High;
}
public static class System.Diagnostics.PresentationTraceSources : object {
    internal static TraceSource _DependencyPropertySource;
    internal static TraceSource _FreezableSource;
    internal static TraceSource _NameScopeSource;
    internal static TraceSource _RoutedEventSource;
    internal static TraceSource _AnimationSource;
    internal static TraceSource _DataBindingSource;
    internal static TraceSource _DocumentsSource;
    internal static TraceSource _ResourceDictionarySource;
    internal static TraceSource _MarkupSource;
    internal static TraceSource _HwndHostSource;
    internal static TraceSource _ShellSource;
    public static DependencyProperty TraceLevelProperty;
    [CompilerGeneratedAttribute]
private static TraceRefreshEventHandler TraceRefresh;
    public static TraceSource DependencyPropertySource { get; }
    public static TraceSource FreezableSource { get; }
    public static TraceSource NameScopeSource { get; }
    public static TraceSource RoutedEventSource { get; }
    public static TraceSource AnimationSource { get; }
    public static TraceSource DataBindingSource { get; }
    public static TraceSource DocumentsSource { get; }
    public static TraceSource ResourceDictionarySource { get; }
    public static TraceSource MarkupSource { get; }
    public static TraceSource HwndHostSource { get; }
    public static TraceSource ShellSource { get; }
    private static PresentationTraceSources();
    public static TraceSource get_DependencyPropertySource();
    public static TraceSource get_FreezableSource();
    public static TraceSource get_NameScopeSource();
    public static TraceSource get_RoutedEventSource();
    public static TraceSource get_AnimationSource();
    public static TraceSource get_DataBindingSource();
    public static TraceSource get_DocumentsSource();
    public static TraceSource get_ResourceDictionarySource();
    public static TraceSource get_MarkupSource();
    public static TraceSource get_HwndHostSource();
    public static TraceSource get_ShellSource();
    public static PresentationTraceLevel GetTraceLevel(object element);
    public static void SetTraceLevel(object element, PresentationTraceLevel traceLevel);
    public static void Refresh();
    [CompilerGeneratedAttribute]
internal static void add_TraceRefresh(TraceRefreshEventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_TraceRefresh(TraceRefreshEventHandler value);
    private static TraceSource CreateTraceSource(string sourceName);
}
internal class System.Diagnostics.TraceRefreshEventHandler : MulticastDelegate {
    public TraceRefreshEventHandler(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.IO.Compression.ZLibNative : object {
    internal static IntPtr ZNullPtr;
    public static int Deflate_DefaultWindowBits;
    public static int GZip_DefaultWindowBits;
    public static int Deflate_DefaultMemLevel;
    public static int Deflate_NoCompressionMemLevel;
    private static ZLibNative();
    public static ErrorCode CreateZLibStreamForDeflate(ZLibStreamHandle& zLibStreamHandle, CompressionLevel level, int windowBits, int memLevel, CompressionStrategy strategy);
    public static ErrorCode CreateZLibStreamForInflate(ZLibStreamHandle& zLibStreamHandle, int windowBits);
}
public enum System.IO.Packaging.CertificateEmbeddingOption : Enum {
    public int value__;
    public static CertificateEmbeddingOption InCertificatePart;
    public static CertificateEmbeddingOption InSignaturePart;
    public static CertificateEmbeddingOption NotEmbedded;
}
internal class System.IO.Packaging.DataSpaceManager : object {
    private static int KnownBytesInMapTableHeader;
    private static int KnownBytesInDataSpaceDefinitionHeader;
    private static int KnownBytesInTransformDefinitionHeader;
    private static int AllowedExtraDataMaximumSize;
    private static string DataSpaceStorageName;
    private static string DataSpaceVersionName;
    private static string DataSpaceMapTableName;
    private static string DataSpaceDefinitionsStorageName;
    private static string TransformDefinitions;
    private static string TransformPrimaryInfo;
    private static string DataSpaceVersionIdentifier;
    private static VersionPair DataSpaceCurrentWriterVersion;
    private static VersionPair DataSpaceCurrentReaderVersion;
    private static VersionPair DataSpaceCurrentUpdaterVersion;
    private FormatVersion _fileFormatVersion;
    private bool _dirtyFlag;
    private StorageRoot _associatedStorage;
    private SortedList _dataSpaceMap;
    private Byte[] _mapTableHeaderPreservation;
    private Hashtable _dataSpaceDefinitions;
    private Hashtable _transformDefinitions;
    private ArrayList _transformedStreams;
    private static Hashtable _transformLookupTable;
    [CompilerGeneratedAttribute]
private TransformInitializeEventHandler OnTransformInitialization;
    internal static int TransformIdentifierTypes_PredefinedTransformName;
    internal int Count { get; }
    private bool DirtyFlag { get; }
    private static DataSpaceManager();
    internal DataSpaceManager(StorageRoot containerInstance);
    internal int get_Count();
    private bool get_DirtyFlag();
    public void Dispose();
    internal void RemoveContainerFromDataSpaceMap(CompoundFileReference target);
    internal void CheckDisposedStatus();
    internal void DefineDataSpace(String[] transformStack, string newDataSpaceLabel);
    internal bool DataSpaceIsDefined(string dataSpaceLabel);
    private void SetDataSpaceDefinition(string dataSpaceLabel, DataSpaceDefinition definition);
    private DataSpaceDefinition GetDataSpaceDefinition(string dataSpaceLabel);
    internal string DataSpaceOf(CompoundFileReference target);
    internal List`1<IDataTransform> GetTransformsForStreamInfo(StreamInfo streamInfo);
    internal string DefineDataSpace(String[] transformStack);
    private IDataTransform InstantiateDataTransformObject(int transformClassType, string transformClassName, TransformEnvironment transformEnvironment);
    internal bool TransformLabelIsDefined(string transformLabel);
    private void SetTransformDefinition(string transformLabel, TransformInstance definition);
    private TransformInstance GetTransformInstanceOf(string transformLabel);
    internal Stream GetPrimaryInstanceStreamOf(string transformLabel);
    internal StorageInfo GetInstanceDataStorageOf(string transformLabel);
    internal IDataTransform GetTransformFromName(string transformLabel);
    internal void DefineTransform(string transformClassName, string newTransformLabel);
    internal string DefineTransform(string transformClassName);
    [CompilerGeneratedAttribute]
internal void add_OnTransformInitialization(TransformInitializeEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_OnTransformInitialization(TransformInitializeEventHandler value);
    internal void CallTransformInitializers(TransformInitializationEventArgs initArguments);
    private void ReadDataSpaceMap();
    private void WriteDataSpaceMap();
    private void ReadDataSpaceDefinitions();
    private void WriteDataSpaceDefinitions();
    private void ReadTransformDefinitions();
    private void WriteTransformDefinitions();
    internal void CreateDataSpaceMapping(CompoundFileReference containerReference, string label);
    internal Stream CreateDataSpaceStream(CompoundFileStreamReference containerReference, Stream rawStream);
    private void ReadDataSpaceVersionInformation(StorageInfo dataSpaceStorage);
    private void EnsureDataSpaceVersionInformation();
    private void ThrowIfIncorrectReaderVersion();
    private void ThrowIfIncorrectUpdaterVersion();
}
public class System.IO.Packaging.EncryptedPackageEnvelope : object {
    private bool _disposed;
    private bool _handedOutPackage;
    private bool _handedOutPackageStream;
    private StorageRoot _root;
    private Package _package;
    private string _dataSpaceName;
    private Stream _packageStream;
    private StorageBasedPackageProperties _packageProperties;
    private RightsManagementInformation _rmi;
    private static string _encryptionTransformName;
    private static string _packageStreamName;
    private static string _dataspaceLabelRMEncryptionNoCompression;
    private static int STG_E_FILEALREADYEXISTS;
    private static FileMode _defaultFileModeForCreate;
    private static FileAccess _defaultFileAccess;
    private static FileShare _defaultFileShare;
    private static FileMode _defaultFileModeForOpen;
    public RightsManagementInformation RightsManagementInformation { get; }
    public PackageProperties PackageProperties { get; }
    public FileAccess FileOpenAccess { get; }
    public StorageInfo StorageInfo { get; }
    internal static string EncryptionTransformName { get; }
    internal static string PackageStreamName { get; }
    internal static string DataspaceLabelRMEncryptionNoCompression { get; }
    internal EncryptedPackageEnvelope(string envelopeFileName, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    internal EncryptedPackageEnvelope(Stream envelopeStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    internal EncryptedPackageEnvelope(string envelopeFileName, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    internal EncryptedPackageEnvelope(Stream envelopeStream, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    internal EncryptedPackageEnvelope(string envelopeFileName, FileAccess access, FileShare sharing);
    internal EncryptedPackageEnvelope(Stream envelopeStream);
    public static EncryptedPackageEnvelope Create(string envelopeFileName, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope Create(Stream envelopeStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope CreateFromPackage(string envelopeFileName, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope CreateFromPackage(Stream envelopeStream, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope Open(string envelopeFileName);
    public static EncryptedPackageEnvelope Open(string envelopeFileName, FileAccess access);
    public static EncryptedPackageEnvelope Open(string envelopeFileName, FileAccess access, FileShare sharing);
    public static EncryptedPackageEnvelope Open(Stream envelopeStream);
    public static bool IsEncryptedPackageEnvelope(string fileName);
    public static bool IsEncryptedPackageEnvelope(Stream stream);
    public void Flush();
    public void Close();
    public sealed virtual void Dispose();
    public RightsManagementInformation get_RightsManagementInformation();
    public PackageProperties get_PackageProperties();
    public FileAccess get_FileOpenAccess();
    public Package GetPackage();
    public StorageInfo get_StorageInfo();
    internal Stream GetPackageStream();
    internal static string get_EncryptionTransformName();
    internal static string get_PackageStreamName();
    internal static string get_DataspaceLabelRMEncryptionNoCompression();
    private void InitializeRMForCreate(PublishLicense publishLicense, CryptoProvider cryptoProvider);
    private void InitForOpen();
    private static bool ContainsEncryptedPackageStream(StorageRoot root);
    private void EnsurePackageStream();
    protected virtual void Dispose(bool disposing);
    private void CheckDisposed();
    private void EmbedPackage(Stream packageStream);
    private void ThrowIfRMEncryptionInfoInvalid(PublishLicense publishLicense, CryptoProvider cryptoProvider);
}
internal interface System.IO.Packaging.IDataTransform {
    public bool IsReady { get; }
    public bool FixedSettings { get; }
    public object TransformIdentifier { get; }
    public abstract virtual bool get_IsReady();
    public abstract virtual bool get_FixedSettings();
    public abstract virtual object get_TransformIdentifier();
    public abstract virtual Stream GetTransformedStream(Stream encodedDataStream, IDictionary transformContext);
}
public class System.IO.Packaging.InvalidSignatureEventHandler : MulticastDelegate {
    public InvalidSignatureEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SignatureVerificationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SignatureVerificationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.IO.Packaging.PackageDigitalSignature : object {
    private PackageDigitalSignatureManager _manager;
    private XmlDigitalSignatureProcessor _processor;
    private CertificatePart _certificatePart;
    private ReadOnlyCollection`1<Uri> _signedParts;
    private ReadOnlyCollection`1<PackageRelationshipSelector> _signedRelationshipSelectors;
    private bool _alreadyLookedForCertPart;
    private bool _invalid;
    public ReadOnlyCollection`1<Uri> SignedParts { get; }
    public ReadOnlyCollection`1<PackageRelationshipSelector> SignedRelationshipSelectors { get; }
    public PackagePart SignaturePart { get; }
    public X509Certificate Signer { get; }
    public DateTime SigningTime { get; }
    public string TimeFormat { get; }
    public Byte[] SignatureValue { get; }
    public string SignatureType { get; }
    public Signature Signature { get; public set; }
    public CertificateEmbeddingOption CertificateEmbeddingOption { get; }
    internal PackageDigitalSignature(PackageDigitalSignatureManager manager, XmlDigitalSignatureProcessor processor);
    internal PackageDigitalSignature(PackageDigitalSignatureManager manager, PackagePart signaturePart);
    public ReadOnlyCollection`1<Uri> get_SignedParts();
    public ReadOnlyCollection`1<PackageRelationshipSelector> get_SignedRelationshipSelectors();
    public PackagePart get_SignaturePart();
    public X509Certificate get_Signer();
    public DateTime get_SigningTime();
    public string get_TimeFormat();
    public Byte[] get_SignatureValue();
    public string get_SignatureType();
    public Signature get_Signature();
    public void set_Signature(Signature value);
    public CertificateEmbeddingOption get_CertificateEmbeddingOption();
    public List`1<string> GetPartTransformList(Uri partName);
    public VerifyResult Verify();
    public VerifyResult Verify(X509Certificate signingCertificate);
    internal void Invalidate();
    internal CertificatePart GetCertificatePart();
    internal void SetCertificatePart(CertificatePart certificatePart);
    private void ThrowIfInvalidated();
}
public class System.IO.Packaging.PackageDigitalSignatureManager : object {
    [CompilerGeneratedAttribute]
private InvalidSignatureEventHandler InvalidSignatureEvent;
    private CertificateEmbeddingOption _certificateEmbeddingOption;
    private Package _container;
    private IntPtr _parentWindow;
    private static Uri _defaultOriginPartName;
    private Uri _originPartName;
    private PackagePart _originPart;
    private string _hashAlgorithmString;
    private string _signatureTimeFormat;
    private List`1<PackageDigitalSignature> _signatures;
    private Dictionary`2<string, string> _transformDictionary;
    private bool _originSearchConducted;
    private bool _originPartExists;
    private ReadOnlyCollection`1<PackageDigitalSignature> _signatureList;
    private static ContentType _originPartContentType;
    private static string _guidStorageFormatString;
    private static string _defaultHashAlgorithm;
    private static string _originRelationshipType;
    private static string _originToSignatureRelationshipType;
    private static string _defaultSignaturePartNamePrefix;
    private static string _defaultSignaturePartNameExtension;
    public bool IsSigned { get; }
    public ReadOnlyCollection`1<PackageDigitalSignature> Signatures { get; }
    public Dictionary`2<string, string> TransformMapping { get; }
    public IntPtr ParentWindow { get; public set; }
    public string HashAlgorithm { get; public set; }
    public CertificateEmbeddingOption CertificateOption { get; public set; }
    public string TimeFormat { get; public set; }
    public Uri SignatureOrigin { get; }
    public static string SignatureOriginRelationshipType { get; }
    public static string DefaultHashAlgorithm { get; }
    internal Package Package { get; }
    private bool ReadOnly { get; }
    private PackagePart OriginPart { get; }
    public PackageDigitalSignatureManager(Package package);
    private static PackageDigitalSignatureManager();
    [CompilerGeneratedAttribute]
public void add_InvalidSignatureEvent(InvalidSignatureEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_InvalidSignatureEvent(InvalidSignatureEventHandler value);
    public bool get_IsSigned();
    public ReadOnlyCollection`1<PackageDigitalSignature> get_Signatures();
    public Dictionary`2<string, string> get_TransformMapping();
    public IntPtr get_ParentWindow();
    public void set_ParentWindow(IntPtr value);
    public string get_HashAlgorithm();
    public void set_HashAlgorithm(string value);
    public CertificateEmbeddingOption get_CertificateOption();
    public void set_CertificateOption(CertificateEmbeddingOption value);
    public string get_TimeFormat();
    public void set_TimeFormat(string value);
    public Uri get_SignatureOrigin();
    public static string get_SignatureOriginRelationshipType();
    public static string get_DefaultHashAlgorithm();
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, string signatureId);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, string signatureId, IEnumerable`1<DataObject> signatureObjects, IEnumerable`1<Reference> objectReferences);
    public PackageDigitalSignature Countersign();
    public PackageDigitalSignature Countersign(X509Certificate certificate);
    public PackageDigitalSignature Countersign(X509Certificate certificate, IEnumerable`1<Uri> signatures);
    public VerifyResult VerifySignatures(bool exitOnFailure);
    public void RemoveSignature(Uri signatureUri);
    public void RemoveAllSignatures();
    public PackageDigitalSignature GetSignature(Uri signatureUri);
    public static X509ChainStatusFlags VerifyCertificate(X509Certificate certificate);
    internal Package get_Package();
    internal static X509Certificate PromptForSigningCertificate(IntPtr hwndParent);
    private void VerifyPartsExist(IEnumerable`1<Uri> parts);
    private void VerifySignArguments(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, string signatureId, IEnumerable`1<DataObject> signatureObjects, IEnumerable`1<Reference> objectReferences);
    private bool EnumeratorEmptyCheck(IEnumerable enumerable);
    private void InternalRemoveSignature(Uri signatureUri, int countOfSignaturesRemaining);
    private void SafeVisitRelationships(PackageRelationshipCollection relationships, RelationshipOperation visit);
    private void SafeVisitRelationships(PackageRelationshipCollection relationships, RelationshipOperation visit, object context);
    private bool DeleteCertificateIfReferenceCountBecomesZeroVisitor(PackageRelationship r, object context);
    private bool DeleteRelationshipOfTypePackageToOriginVisitor(PackageRelationship r, object context);
    private bool DeleteRelationshipToSignature(PackageRelationship r, object signatureUri);
    private void DeleteOriginPart();
    private int GetSignatureIndex(Uri uri);
    private int CertificatePartReferenceCount(Uri certificatePartUri);
    private Uri GenerateSignaturePartName();
    private void EnsureSignatures();
    private bool OriginPartExists();
    private bool get_ReadOnly();
    private PackagePart get_OriginPart();
}
public class System.IO.Packaging.RightsManagementInformation : object {
    private RightsManagementEncryptionTransform _rmet;
    public CryptoProvider CryptoProvider { get; public set; }
    internal RightsManagementInformation(RightsManagementEncryptionTransform rmet);
    public CryptoProvider get_CryptoProvider();
    public void set_CryptoProvider(CryptoProvider value);
    public PublishLicense LoadPublishLicense();
    public void SavePublishLicense(PublishLicense publishLicense);
    public UseLicense LoadUseLicense(ContentUser userKey);
    public void SaveUseLicense(ContentUser userKey, UseLicense useLicense);
    public void DeleteUseLicense(ContentUser userKey);
    public IDictionary`2<ContentUser, UseLicense> GetEmbeddedUseLicenses();
}
public class System.IO.Packaging.SignatureVerificationEventArgs : EventArgs {
    private PackageDigitalSignature _signature;
    private VerifyResult _result;
    public PackageDigitalSignature Signature { get; }
    public VerifyResult VerifyResult { get; }
    internal SignatureVerificationEventArgs(PackageDigitalSignature signature, VerifyResult result);
    public PackageDigitalSignature get_Signature();
    public VerifyResult get_VerifyResult();
}
public class System.IO.Packaging.StorageInfo : object {
    private StorageInfo parentStorage;
    private StorageRoot rootStorage;
    internal StorageInfoCore core;
    private static string sc_compressionTransformName;
    private static string sc_dataspaceLabelNoEncryptionNormalCompression;
    private static string sc_dataspaceLabelRMEncryptionNormalCompression;
    public string Name { get; }
    internal string FullNameInternal { get; }
    internal StorageRoot Root { get; }
    internal bool Exists { get; }
    internal IStorage SafeIStorage { get; }
    internal bool StorageDisposed { get; }
    internal StorageInfo(IStorage safeIStorage);
    internal StorageInfo(StorageInfo parent, string fileName);
    private static StorageInfo();
    private void BuildStorageInfoRelativeToStorage(StorageInfo parent, string fileName);
    private StorageInfoCore CoreForChildStorage(string storageNname);
    internal StreamInfoCore CoreForChildStream(string streamName);
    public string get_Name();
    public StreamInfo CreateStream(string name, CompressionOption compressionOption, EncryptionOption encryptionOption);
    public StreamInfo CreateStream(string name);
    public StreamInfo GetStreamInfo(string name);
    public bool StreamExists(string name);
    public void DeleteStream(string name);
    public StorageInfo CreateSubStorage(string name);
    public StorageInfo GetSubStorageInfo(string name);
    public bool SubStorageExists(string name);
    public void DeleteSubStorage(string name);
    public StreamInfo[] GetStreams();
    public StorageInfo[] GetSubStorages();
    internal string get_FullNameInternal();
    internal StorageRoot get_Root();
    internal bool get_Exists();
    internal void Create();
    private StorageInfo CreateStorage(string name);
    internal bool Delete(bool recursive, string name);
    internal void RemoveSubStorageEntryFromDataSpaceMap(StorageInfo storageInfo);
    internal void DestroyElement(string elementNameInternal);
    internal bool FindStatStgOfName(string streamName, STATSTG& statStg);
    internal bool StorageIsEmpty();
    internal void InvalidateEnumerators();
    private static void InvalidateEnumerators(StorageInfoCore invalidateCore);
    internal ArrayList BuildFullNameFromParentName();
    internal ArrayList BuildFullNameInternalFromParentNameInternal();
    internal IStorage get_SafeIStorage();
    private bool InternalExists();
    private bool InternalExists(string name);
    private bool CanOpenStorage(string nameInternal);
    private void VerifyExists();
    private STATSTG GetStat();
    private DateTime ConvertFILETIMEToDateTime(FILETIME time);
    internal static void RecursiveStorageInfoCoreRelease(StorageInfoCore startCore);
    internal void CheckDisposedStatus();
    internal bool get_StorageDisposed();
    private void EnsureArrayForEnumeration(EnumeratorTypes desiredArrayType);
}
internal class System.IO.Packaging.StorageInfoCore : object {
    internal string storageName;
    internal IStorage safeIStorage;
    internal Hashtable validEnumerators;
    internal Hashtable elementInfoCores;
    internal StorageInfoCore(string nameStorage);
    internal StorageInfoCore(string nameStorage, IStorage storage);
}
internal class System.IO.Packaging.StorageRoot : StorageInfo {
    private static FileMode defaultFileMode;
    private static FileAccess defaultFileAccess;
    private static FileShare defaultFileShare;
    private static int defaultSectorSize;
    private static int stgFormatDocFile;
    private IStorage rootIStorage;
    private DataSpaceManager dataSpaceManager;
    private bool containerIsReadOnly;
    private bool dataSpaceManagerInitializationInProgress;
    internal FileAccess OpenAccess { get; }
    internal bool RootDisposed { get; }
    private StorageRoot(IStorage root, bool readOnly);
    internal FileAccess get_OpenAccess();
    internal static StorageRoot CreateOnStream(Stream baseStream);
    internal static StorageRoot CreateOnStream(Stream baseStream, FileMode mode);
    internal static StorageRoot Open(string path);
    internal static StorageRoot Open(string path, FileMode mode);
    internal static StorageRoot Open(string path, FileMode mode, FileAccess access);
    internal static StorageRoot Open(string path, FileMode mode, FileAccess access, FileShare share);
    internal static StorageRoot Open(string path, FileMode mode, FileAccess access, FileShare share, int sectorSize);
    internal void Close();
    internal void Flush();
    internal DataSpaceManager GetDataSpaceManager();
    internal IStorage GetRootIStorage();
    internal void CheckRootDisposedStatus();
    internal bool get_RootDisposed();
    private static StorageRoot CreateOnIStorage(IStorage root);
}
public class System.IO.Packaging.StreamInfo : object {
    private static FileMode defaultFileOpenMode;
    private static FileMode defaultFileCreateMode;
    private static string defaultDataSpace;
    private StorageInfo parentStorage;
    private StreamInfoCore core;
    private CompoundFileStreamReference _streamReference;
    private FileAccess openFileAccess;
    private CompressionOption _compressionOption;
    private EncryptionOption _encryptionOption;
    private bool _needToGetTransformInfo;
    public CompressionOption CompressionOption { get; }
    public EncryptionOption EncryptionOption { get; }
    public string Name { get; }
    internal bool StreamInfoDisposed { get; }
    internal CompoundFileStreamReference StreamReference { get; }
    private StreamInfo(StorageRoot root, string streamPath);
    internal StreamInfo(StorageInfo parent, string streamName);
    internal StreamInfo(StorageInfo parent, string streamName, CompressionOption compressionOption, EncryptionOption encryptionOption);
    private void BuildStreamInfoRelativeToStorage(StorageInfo parent, string path);
    public CompressionOption get_CompressionOption();
    public EncryptionOption get_EncryptionOption();
    public string get_Name();
    public Stream GetStream();
    public Stream GetStream(FileMode mode);
    public Stream GetStream(FileMode mode, FileAccess access);
    internal Stream Create();
    private Stream Create(FileMode mode);
    internal Stream Create(string dataSpaceLabel);
    private Stream Create(FileMode mode, FileAccess access);
    internal Stream Create(FileMode mode, FileAccess access, string dataSpace);
    private Stream BuildStreamOnUnderlyingIStream(IStream underlyingIStream, FileAccess access, StreamInfo parent);
    private void CreateTimeReadOnlyCheck(FileAccess access);
    private IStream CreateStreamOnParentIStorage(string name, int mode);
    private IStream OpenStreamOnParentIStorage(string name, int mode);
    internal void Delete();
    internal bool InternalExists();
    private void VerifyExists();
    private Stream CFStreamOfClone(FileAccess access);
    internal void CheckDisposedStatus();
    internal bool get_StreamInfoDisposed();
    internal void CheckAccessMode(int grfMode);
    internal CompoundFileStreamReference get_StreamReference();
    private void EnsureTransformInformation();
}
internal class System.IO.Packaging.StreamInfoCore : object {
    internal string streamName;
    internal IStream safeIStream;
    internal string dataSpaceLabel;
    internal object exposedStream;
    internal StreamInfoCore(string nameStream, string label);
    internal StreamInfoCore(string nameStream, string label, IStream s);
}
internal class System.IO.Packaging.TransformEnvironment : object {
    private DataSpaceManager transformHost;
    private string transformLabel;
    internal bool RequireOtherInstanceData { get; internal set; }
    internal bool RequireInstanceDataUnaltered { get; internal set; }
    internal bool DefaultInstanceDataTransform { get; internal set; }
    internal string TransformLabel { get; }
    internal TransformEnvironment(DataSpaceManager host, string instanceLabel);
    internal bool get_RequireOtherInstanceData();
    internal void set_RequireOtherInstanceData(bool value);
    internal bool get_RequireInstanceDataUnaltered();
    internal void set_RequireInstanceDataUnaltered(bool value);
    internal bool get_DefaultInstanceDataTransform();
    internal void set_DefaultInstanceDataTransform(bool value);
    internal string get_TransformLabel();
    internal Stream GetPrimaryInstanceData();
    internal StorageInfo GetInstanceDataStorage();
}
internal class System.IO.Packaging.TransformInitializationEventArgs : EventArgs {
    private IDataTransform dataInstance;
    private string dataSpaceLabel;
    private string streamPath;
    private string transformLabel;
    internal IDataTransform DataTransform { get; }
    internal string DataSpaceLabel { get; }
    internal string Path { get; }
    internal string TransformInstanceLabel { get; }
    internal TransformInitializationEventArgs(IDataTransform instance, string dataSpaceInstanceLabel, string transformedStreamPath, string transformInstanceLabel);
    internal IDataTransform get_DataTransform();
    internal string get_DataSpaceLabel();
    internal string get_Path();
    internal string get_TransformInstanceLabel();
}
public enum System.IO.Packaging.VerifyResult : Enum {
    public int value__;
    public static VerifyResult Success;
    public static VerifyResult InvalidSignature;
    public static VerifyResult CertificateRequired;
    public static VerifyResult InvalidCertificate;
    public static VerifyResult ReferenceNotFound;
    public static VerifyResult NotSigned;
}
internal class System.LocalAppContext : object {
    private static Dictionary`2<string, bool> s_switchMap;
    private static object s_syncLock;
    [CompilerGeneratedAttribute]
private static bool <DisableCaching>k__BackingField;
    private static bool DisableCaching { get; private set; }
    private static LocalAppContext();
    [CompilerGeneratedAttribute]
private static bool get_DisableCaching();
    [CompilerGeneratedAttribute]
private static void set_DisableCaching(bool value);
    public static bool IsSwitchEnabled(string switchName);
    private static bool IsSwitchEnabledLocal(string switchName);
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    private static bool GetCachedSwitchValueInternal(string switchName, Int32& switchValue);
    internal static void DefineSwitchDefault(string switchName, bool initialValue);
}
public enum System.Security.RightsManagement.AuthenticationType : Enum {
    public int value__;
    public static AuthenticationType Windows;
    public static AuthenticationType Passport;
    public static AuthenticationType WindowsPassport;
    public static AuthenticationType Internal;
}
public class System.Security.RightsManagement.ContentGrant : object {
    private ContentUser _user;
    private ContentRight _right;
    private DateTime _validFrom;
    private DateTime _validUntil;
    public ContentUser User { get; }
    public ContentRight Right { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidUntil { get; }
    public ContentGrant(ContentUser user, ContentRight right);
    public ContentGrant(ContentUser user, ContentRight right, DateTime validFrom, DateTime validUntil);
    public ContentUser get_User();
    public ContentRight get_Right();
    public DateTime get_ValidFrom();
    public DateTime get_ValidUntil();
}
public enum System.Security.RightsManagement.ContentRight : Enum {
    public int value__;
    public static ContentRight View;
    public static ContentRight Edit;
    public static ContentRight Print;
    public static ContentRight Extract;
    public static ContentRight ObjectModel;
    public static ContentRight Owner;
    public static ContentRight ViewRightsData;
    public static ContentRight Forward;
    public static ContentRight Reply;
    public static ContentRight ReplyAll;
    public static ContentRight Sign;
    public static ContentRight DocumentEdit;
    public static ContentRight Export;
}
public class System.Security.RightsManagement.ContentUser : object {
    internal static ContentUserComparer _contentUserComparer;
    private static string WindowsAuthProvider;
    private static string PassportAuthProvider;
    private static string OwnerUserName;
    private static ContentUser _ownerUser;
    private static string AnyoneUserName;
    private static ContentUser _anyoneUser;
    private string _name;
    private AuthenticationType _authenticationType;
    private int hashValue;
    private bool hashCalcIsDone;
    public AuthenticationType AuthenticationType { get; }
    public string Name { get; }
    public static ContentUser AnyoneUser { get; }
    public static ContentUser OwnerUser { get; }
    internal string AuthenticationProviderType { get; }
    public ContentUser(string name, AuthenticationType authenticationType);
    private static ContentUser();
    public AuthenticationType get_AuthenticationType();
    public string get_Name();
    public bool IsAuthenticated();
    public virtual bool Equals(object obj);
    public static ContentUser get_AnyoneUser();
    public static ContentUser get_OwnerUser();
    public virtual int GetHashCode();
    internal string get_AuthenticationProviderType();
    internal bool GenericEquals(ContentUser userObj);
    internal static bool CompareToAnyone(string name);
    internal static bool CompareToOwner(string name);
}
public class System.Security.RightsManagement.CryptoProvider : object {
    private int _blockSize;
    private SafeRightsManagementHandle _decryptorHandle;
    private bool _decryptorHandleCalculated;
    private SafeRightsManagementHandle _encryptorHandle;
    private bool _encryptorHandleCalculated;
    private SafeRightsManagementHandle _boundLicenseOwnerViewRightsHandle;
    private bool _boundLicenseOwnerViewRightsHandleCalculated;
    private List`1<SafeRightsManagementHandle> _boundLicenseHandleList;
    private List`1<RightNameExpirationInfoPair> _boundRightsInfoList;
    private ReadOnlyCollection`1<ContentGrant> _boundGrantReadOnlyCollection;
    private ContentUser _owner;
    private bool _disposed;
    public int BlockSize { get; }
    public bool CanMergeBlocks { get; }
    public ReadOnlyCollection`1<ContentGrant> BoundGrants { get; }
    public bool CanEncrypt { get; }
    public bool CanDecrypt { get; }
    private SafeRightsManagementHandle DecryptorHandle { get; }
    private SafeRightsManagementHandle EncryptorHandle { get; }
    private SafeRightsManagementHandle BoundLicenseOwnerViewRightsHandle { get; }
    internal CryptoProvider(List`1<SafeRightsManagementHandle> boundLicenseHandleList, List`1<RightNameExpirationInfoPair> rightsInfoList, ContentUser owner);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public Byte[] Encrypt(Byte[] clearText);
    public Byte[] Decrypt(Byte[] cryptoText);
    protected virtual void Dispose(bool disposing);
    public int get_BlockSize();
    public bool get_CanMergeBlocks();
    public ReadOnlyCollection`1<ContentGrant> get_BoundGrants();
    public bool get_CanEncrypt();
    public bool get_CanDecrypt();
    internal UnsignedPublishLicense DecryptPublishLicense(string serializedPublishLicense);
    private void CheckDisposed();
    private int QueryBlockSize();
    private SafeRightsManagementHandle get_DecryptorHandle();
    private SafeRightsManagementHandle get_EncryptorHandle();
    private SafeRightsManagementHandle get_BoundLicenseOwnerViewRightsHandle();
}
public class System.Security.RightsManagement.LocalizedNameDescriptionPair : object {
    private string _name;
    private string _description;
    public string Name { get; }
    public string Description { get; }
    public LocalizedNameDescriptionPair(string name, string description);
    public string get_Name();
    public string get_Description();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Security.RightsManagement.PublishLicense : object {
    private string _serializedPublishLicense;
    private string _referralInfoName;
    private Uri _referralInfoUri;
    private Guid _contentId;
    private Uri _useLicenseAcquisitionUriFromPublishLicense;
    public string ReferralInfoName { get; }
    public Uri ReferralInfoUri { get; }
    public Guid ContentId { get; }
    public Uri UseLicenseAcquisitionUrl { get; }
    public PublishLicense(string signedPublishLicense);
    public UnsignedPublishLicense DecryptUnsignedPublishLicense(CryptoProvider cryptoProvider);
    public string get_ReferralInfoName();
    public Uri get_ReferralInfoUri();
    public Guid get_ContentId();
    public Uri get_UseLicenseAcquisitionUrl();
    public virtual string ToString();
    public UseLicense AcquireUseLicense(SecureEnvironment secureEnvironment);
    public UseLicense AcquireUseLicenseNoUI(SecureEnvironment secureEnvironment);
}
public class System.Security.RightsManagement.RightsManagementException : Exception {
    private RightsManagementFailureCode _failureCode;
    private static string _serializationFailureCodeAttributeName;
    public RightsManagementFailureCode FailureCode { get; }
    public RightsManagementException(string message);
    public RightsManagementException(string message, Exception innerException);
    public RightsManagementException(RightsManagementFailureCode failureCode);
    public RightsManagementException(RightsManagementFailureCode failureCode, string message);
    public RightsManagementException(RightsManagementFailureCode failureCode, Exception innerException);
    public RightsManagementException(RightsManagementFailureCode failureCode, string message, Exception innerException);
    protected RightsManagementException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public RightsManagementFailureCode get_FailureCode();
}
public enum System.Security.RightsManagement.RightsManagementFailureCode : Enum {
    public int value__;
    public static RightsManagementFailureCode Success;
    public static RightsManagementFailureCode InvalidLicense;
    public static RightsManagementFailureCode InfoNotInLicense;
    public static RightsManagementFailureCode InvalidLicenseSignature;
    public static RightsManagementFailureCode EncryptionNotPermitted;
    public static RightsManagementFailureCode RightNotGranted;
    public static RightsManagementFailureCode InvalidVersion;
    public static RightsManagementFailureCode InvalidEncodingType;
    public static RightsManagementFailureCode InvalidNumericalValue;
    public static RightsManagementFailureCode InvalidAlgorithmType;
    public static RightsManagementFailureCode EnvironmentNotLoaded;
    public static RightsManagementFailureCode EnvironmentCannotLoad;
    public static RightsManagementFailureCode TooManyLoadedEnvironments;
    public static RightsManagementFailureCode IncompatibleObjects;
    public static RightsManagementFailureCode LibraryFail;
    public static RightsManagementFailureCode EnablingPrincipalFailure;
    public static RightsManagementFailureCode InfoNotPresent;
    public static RightsManagementFailureCode BadGetInfoQuery;
    public static RightsManagementFailureCode KeyTypeUnsupported;
    public static RightsManagementFailureCode CryptoOperationUnsupported;
    public static RightsManagementFailureCode ClockRollbackDetected;
    public static RightsManagementFailureCode QueryReportsNoResults;
    public static RightsManagementFailureCode UnexpectedException;
    public static RightsManagementFailureCode BindValidityTimeViolated;
    public static RightsManagementFailureCode BrokenCertChain;
    public static RightsManagementFailureCode BindPolicyViolation;
    public static RightsManagementFailureCode ManifestPolicyViolation;
    public static RightsManagementFailureCode BindRevokedLicense;
    public static RightsManagementFailureCode BindRevokedIssuer;
    public static RightsManagementFailureCode BindRevokedPrincipal;
    public static RightsManagementFailureCode BindRevokedResource;
    public static RightsManagementFailureCode BindRevokedModule;
    public static RightsManagementFailureCode BindContentNotInEndUseLicense;
    public static RightsManagementFailureCode BindAccessPrincipalNotEnabling;
    public static RightsManagementFailureCode BindAccessUnsatisfied;
    public static RightsManagementFailureCode BindIndicatedPrincipalMissing;
    public static RightsManagementFailureCode BindMachineNotFoundInGroupIdentity;
    public static RightsManagementFailureCode LibraryUnsupportedPlugIn;
    public static RightsManagementFailureCode BindRevocationListStale;
    public static RightsManagementFailureCode BindNoApplicableRevocationList;
    public static RightsManagementFailureCode InvalidHandle;
    public static RightsManagementFailureCode BindIntervalTimeViolated;
    public static RightsManagementFailureCode BindNoSatisfiedRightsGroup;
    public static RightsManagementFailureCode BindSpecifiedWorkMissing;
    public static RightsManagementFailureCode NoMoreData;
    public static RightsManagementFailureCode LicenseAcquisitionFailed;
    public static RightsManagementFailureCode IdMismatch;
    public static RightsManagementFailureCode TooManyCertificates;
    public static RightsManagementFailureCode NoDistributionPointUrlFound;
    public static RightsManagementFailureCode AlreadyInProgress;
    public static RightsManagementFailureCode GroupIdentityNotSet;
    public static RightsManagementFailureCode RecordNotFound;
    public static RightsManagementFailureCode NoConnect;
    public static RightsManagementFailureCode NoLicense;
    public static RightsManagementFailureCode NeedsMachineActivation;
    public static RightsManagementFailureCode NeedsGroupIdentityActivation;
    public static RightsManagementFailureCode ActivationFailed;
    public static RightsManagementFailureCode Aborted;
    public static RightsManagementFailureCode OutOfQuota;
    public static RightsManagementFailureCode AuthenticationFailed;
    public static RightsManagementFailureCode ServerError;
    public static RightsManagementFailureCode InstallationFailed;
    public static RightsManagementFailureCode HidCorrupted;
    public static RightsManagementFailureCode InvalidServerResponse;
    public static RightsManagementFailureCode ServiceNotFound;
    public static RightsManagementFailureCode UseDefault;
    public static RightsManagementFailureCode ServerNotFound;
    public static RightsManagementFailureCode InvalidEmail;
    public static RightsManagementFailureCode ValidityTimeViolation;
    public static RightsManagementFailureCode OutdatedModule;
    public static RightsManagementFailureCode ServiceMoved;
    public static RightsManagementFailureCode ServiceGone;
    public static RightsManagementFailureCode AdEntryNotFound;
    public static RightsManagementFailureCode NotAChain;
    public static RightsManagementFailureCode RequestDenied;
    public static RightsManagementFailureCode NotSet;
    public static RightsManagementFailureCode MetadataNotSet;
    public static RightsManagementFailureCode RevocationInfoNotSet;
    public static RightsManagementFailureCode InvalidTimeInfo;
    public static RightsManagementFailureCode RightNotSet;
    public static RightsManagementFailureCode LicenseBindingToWindowsIdentityFailed;
    public static RightsManagementFailureCode InvalidIssuanceLicenseTemplate;
    public static RightsManagementFailureCode InvalidKeyLength;
    public static RightsManagementFailureCode ExpiredOfficialIssuanceLicenseTemplate;
    public static RightsManagementFailureCode InvalidClientLicensorCertificate;
    public static RightsManagementFailureCode HidInvalid;
    public static RightsManagementFailureCode EmailNotVerified;
    public static RightsManagementFailureCode DebuggerDetected;
    public static RightsManagementFailureCode InvalidLockboxType;
    public static RightsManagementFailureCode InvalidLockboxPath;
    public static RightsManagementFailureCode InvalidRegistryPath;
    public static RightsManagementFailureCode NoAesCryptoProvider;
    public static RightsManagementFailureCode GlobalOptionAlreadySet;
    public static RightsManagementFailureCode OwnerLicenseNotFound;
}
public class System.Security.RightsManagement.SecureEnvironment : object {
    private ContentUser _user;
    private string _applicationManifest;
    private ClientSession _clientSession;
    public ContentUser User { get; }
    public string ApplicationManifest { get; }
    internal ClientSession ClientSession { get; }
    private SecureEnvironment(string applicationManifest, ContentUser user, ClientSession clientSession);
    public static SecureEnvironment Create(string applicationManifest, ContentUser user);
    public static SecureEnvironment Create(string applicationManifest, AuthenticationType authentication, UserActivationMode userActivationMode);
    public static bool IsUserActivated(ContentUser user);
    public static void RemoveActivatedUser(ContentUser user);
    public static ReadOnlyCollection`1<ContentUser> GetActivatedUsers();
    public sealed virtual void Dispose();
    public ContentUser get_User();
    public string get_ApplicationManifest();
    protected virtual void Dispose(bool disposing);
    internal ClientSession get_ClientSession();
    private static SecureEnvironment CriticalCreate(string applicationManifest, ContentUser user);
    private static SecureEnvironment CriticalCreate(string applicationManifest, AuthenticationType authentication, UserActivationMode userActivationMode);
    private void CheckDisposed();
}
public class System.Security.RightsManagement.UnsignedPublishLicense : object {
    private Guid _contentId;
    private ContentUser _owner;
    private ICollection`1<ContentGrant> _grantCollection;
    private string _referralInfoName;
    private Uri _referralInfoUri;
    private IDictionary`2<int, LocalizedNameDescriptionPair> _localizedNameDescriptionDictionary;
    private IDictionary`2<string, string> _applicationSpecificDataDictionary;
    private int _rightValidityIntervalDays;
    private RevocationPoint _revocationPoint;
    public ContentUser Owner { get; public set; }
    public string ReferralInfoName { get; public set; }
    public Uri ReferralInfoUri { get; public set; }
    public Guid ContentId { get; public set; }
    public ICollection`1<ContentGrant> Grants { get; }
    public IDictionary`2<int, LocalizedNameDescriptionPair> LocalizedNameDescriptionDictionary { get; }
    internal int RightValidityIntervalDays { get; internal set; }
    internal IDictionary`2<string, string> ApplicationSpecificDataDictionary { get; }
    internal RevocationPoint RevocationPoint { get; internal set; }
    public UnsignedPublishLicense(string publishLicenseTemplate);
    internal UnsignedPublishLicense(SafeRightsManagementHandle boundLicenseHandle, string publishLicenseTemplate);
    public PublishLicense Sign(SecureEnvironment secureEnvironment, UseLicense& authorUseLicense);
    public ContentUser get_Owner();
    public void set_Owner(ContentUser value);
    public string get_ReferralInfoName();
    public void set_ReferralInfoName(string value);
    public Uri get_ReferralInfoUri();
    public void set_ReferralInfoUri(Uri value);
    public Guid get_ContentId();
    public void set_ContentId(Guid value);
    public ICollection`1<ContentGrant> get_Grants();
    public IDictionary`2<int, LocalizedNameDescriptionPair> get_LocalizedNameDescriptionDictionary();
    public virtual string ToString();
    internal int get_RightValidityIntervalDays();
    internal void set_RightValidityIntervalDays(int value);
    internal IDictionary`2<string, string> get_ApplicationSpecificDataDictionary();
    internal RevocationPoint get_RevocationPoint();
    internal void set_RevocationPoint(RevocationPoint value);
}
public class System.Security.RightsManagement.UseLicense : object {
    private string _serializedUseLicense;
    private Guid _contentId;
    private ContentUser _owner;
    private IDictionary`2<string, string> _applicationSpecificDataDictionary;
    public ContentUser Owner { get; }
    public Guid ContentId { get; }
    public IDictionary`2<string, string> ApplicationData { get; }
    public UseLicense(string useLicense);
    public ContentUser get_Owner();
    public Guid get_ContentId();
    public virtual string ToString();
    public CryptoProvider Bind(SecureEnvironment secureEnvironment);
    public IDictionary`2<string, string> get_ApplicationData();
    public virtual bool Equals(object x);
    public virtual int GetHashCode();
}
public enum System.Security.RightsManagement.UserActivationMode : Enum {
    public int value__;
    public static UserActivationMode Permanent;
    public static UserActivationMode Temporary;
}
internal static class System.Windows.AccessibilitySwitches : object {
    private static int EventId;
    private static string EventSource;
    private static int s_DefaultsSet;
    private static int s_SwitchesVerified;
    internal static string UseLegacyAccessibilityFeaturesSwitchName;
    private static int _useLegacyAccessibilityFeatures;
    internal static string UseLegacyAccessibilityFeatures2SwitchName;
    private static int _useLegacyAccessibilityFeatures2;
    internal static string UseLegacyAccessibilityFeatures3SwitchName;
    private static int _useLegacyAccessibilityFeatures3;
    internal static string UseLegacyToolTipDisplaySwitchName;
    private static int _UseLegacyToolTipDisplay;
    internal static string ItemsControlDoesNotSupportAutomationSwitchName;
    private static int _ItemsControlDoesNotSupportAutomation;
    public static bool UseNetFx47CompatibleAccessibilityFeatures { get; }
    public static bool UseNetFx471CompatibleAccessibilityFeatures { get; }
    public static bool UseNetFx472CompatibleAccessibilityFeatures { get; }
    public static bool UseLegacyToolTipDisplay { get; }
    public static bool ItemsControlDoesNotSupportAutomation { get; }
    public static bool get_UseNetFx47CompatibleAccessibilityFeatures();
    public static bool get_UseNetFx471CompatibleAccessibilityFeatures();
    public static bool get_UseNetFx472CompatibleAccessibilityFeatures();
    public static bool get_UseLegacyToolTipDisplay();
    public static bool get_ItemsControlDoesNotSupportAutomation();
    internal static void SetSwitchDefaults(string platformIdentifier, int targetFrameworkVersion);
    internal static void VerifySwitches(Dispatcher dispatcher);
    internal static void VerifyDependencies(Dispatcher dispatcher);
    private static void DispatchOnError(Dispatcher dispatcher, string message);
    private static void WriteEventAndThrow(string message);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.AlternativeExpressionStorageCallback : MulticastDelegate {
    public AlternativeExpressionStorageCallback(object object, IntPtr method);
    public virtual Expression Invoke(DependencyObject d, DependencyProperty dp, PropertyMetadata metadata);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, DependencyProperty dp, PropertyMetadata metadata, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.AttachedPropertyBrowsableAttribute : Attribute {
    internal bool UnionResults { get; }
    internal virtual bool get_UnionResults();
    [FriendAccessAllowedAttribute]
internal abstract virtual bool IsBrowsable(DependencyObject d, DependencyProperty dp);
}
[AttributeUsageAttribute("64")]
public class System.Windows.AttachedPropertyBrowsableForTypeAttribute : AttachedPropertyBrowsableAttribute {
    private Type _targetType;
    private DependencyObjectType _dTargetType;
    private bool _dTargetTypeChecked;
    public Type TargetType { get; }
    public object TypeId { get; }
    internal bool UnionResults { get; }
    public AttachedPropertyBrowsableForTypeAttribute(Type targetType);
    public Type get_TargetType();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool IsBrowsable(DependencyObject d, DependencyProperty dp);
    internal virtual bool get_UnionResults();
}
[AttributeUsageAttribute("64")]
public class System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute : AttachedPropertyBrowsableAttribute {
    private Type _attributeType;
    public Type AttributeType { get; }
    public AttachedPropertyBrowsableWhenAttributePresentAttribute(Type attributeType);
    public Type get_AttributeType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool IsBrowsable(DependencyObject d, DependencyProperty dp);
}
public static class System.Windows.BaseCompatibilityPreferences : object {
    private static bool _reuseDispatcherSynchronizationContextInstance;
    private static bool _flowDispatcherSynchronizationContextPriority;
    private static bool _inlineDispatcherSynchronizationContextSend;
    private static bool _matchPackageSignatureMethodToPackagePartDigestMethod;
    private static string WpfPackagingKey;
    private static string WpfPackagingSubKeyPath;
    private static string MatchPackageSignatureMethodToPackagePartDigestMethodValue;
    private static HandleDispatcherRequestProcessingFailureOptions _handleDispatcherRequestProcessingFailure;
    private static bool _isSealed;
    private static object _lockObject;
    public static bool ReuseDispatcherSynchronizationContextInstance { get; public set; }
    public static bool FlowDispatcherSynchronizationContextPriority { get; public set; }
    public static bool InlineDispatcherSynchronizationContextSend { get; public set; }
    internal static bool MatchPackageSignatureMethodToPackagePartDigestMethod { get; internal set; }
    public static HandleDispatcherRequestProcessingFailureOptions HandleDispatcherRequestProcessingFailure { get; public set; }
    private static BaseCompatibilityPreferences();
    public static bool get_ReuseDispatcherSynchronizationContextInstance();
    public static void set_ReuseDispatcherSynchronizationContextInstance(bool value);
    internal static bool GetReuseDispatcherSynchronizationContextInstance();
    public static bool get_FlowDispatcherSynchronizationContextPriority();
    public static void set_FlowDispatcherSynchronizationContextPriority(bool value);
    internal static bool GetFlowDispatcherSynchronizationContextPriority();
    public static bool get_InlineDispatcherSynchronizationContextSend();
    public static void set_InlineDispatcherSynchronizationContextSend(bool value);
    internal static bool GetInlineDispatcherSynchronizationContextSend();
    internal static bool get_MatchPackageSignatureMethodToPackagePartDigestMethod();
    internal static void set_MatchPackageSignatureMethodToPackagePartDigestMethod(bool value);
    private static void SetMatchPackageSignatureMethodToPackagePartDigestMethod(NameValueCollection appSettings);
    private static bool SetMatchPackageSignatureMethodToPackagePartDigestMethodFromAppSettings(NameValueCollection appSettings);
    private static void SetMatchPackageSignatureMethodToPackagePartDigestMethodFromRegistry();
    public static HandleDispatcherRequestProcessingFailureOptions get_HandleDispatcherRequestProcessingFailure();
    public static void set_HandleDispatcherRequestProcessingFailure(HandleDispatcherRequestProcessingFailureOptions value);
    private static void SetHandleDispatcherRequestProcessingFailureFromAppSettings(NameValueCollection appSettings);
    private static void Seal();
}
[FriendAccessAllowedAttribute]
internal enum System.Windows.BaseValueSourceInternal : Enum {
    public short value__;
    public static BaseValueSourceInternal Unknown;
    public static BaseValueSourceInternal Default;
    public static BaseValueSourceInternal Inherited;
    public static BaseValueSourceInternal ThemeStyle;
    public static BaseValueSourceInternal ThemeStyleTrigger;
    public static BaseValueSourceInternal Style;
    public static BaseValueSourceInternal TemplateTrigger;
    public static BaseValueSourceInternal StyleTrigger;
    public static BaseValueSourceInternal ImplicitReference;
    public static BaseValueSourceInternal ParentTemplate;
    public static BaseValueSourceInternal ParentTemplateTrigger;
    public static BaseValueSourceInternal Local;
}
public class System.Windows.CoerceValueCallback : MulticastDelegate {
    public CoerceValueCallback(object object, IntPtr method);
    public virtual object Invoke(DependencyObject d, object baseValue);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, object baseValue, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class System.Windows.Converters.Int32RectValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.PointValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.RectValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.SizeValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.VectorValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public abstract class System.Windows.Data.DataSourceProvider : object {
    [CompilerGeneratedAttribute]
private EventHandler DataChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    private bool _isInitialLoadEnabled;
    private bool _initialLoadCalled;
    private int _deferLevel;
    private object _data;
    private Exception _error;
    private Dispatcher _dispatcher;
    private static DispatcherOperationCallback UpdateWithNewResultCallback;
    [DefaultValueAttribute("True")]
public bool IsInitialLoadEnabled { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public object Data { get; }
    public Exception Error { get; }
    protected bool IsRefreshDeferred { get; }
    protected Dispatcher Dispatcher { get; protected set; }
    private static DataSourceProvider();
    public void InitialLoad();
    public void Refresh();
    public bool get_IsInitialLoadEnabled();
    public void set_IsInitialLoadEnabled(bool value);
    public object get_Data();
    [CompilerGeneratedAttribute]
public void add_DataChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DataChanged(EventHandler value);
    public Exception get_Error();
    public virtual IDisposable DeferRefresh();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    protected bool get_IsRefreshDeferred();
    protected Dispatcher get_Dispatcher();
    protected void set_Dispatcher(Dispatcher value);
    protected virtual void BeginQuery();
    protected void OnQueryFinished(object newData);
    protected virtual void OnQueryFinished(object newData, Exception error, DispatcherOperationCallback completionWork, object callbackArguments);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected virtual void BeginInit();
    protected virtual void EndInit();
    private void EndDefer();
    private static object UpdateWithNewResult(object arg);
    private void UpdateWithNewResult(Exception error, object newData, DispatcherOperationCallback completionWork, object callbackArgs);
}
internal class System.Windows.DeferredMutableDefaultReference : DeferredReference {
    private PropertyMetadata _sourceMetadata;
    private DependencyObject _sourceObject;
    private DependencyProperty _sourceProperty;
    internal PropertyMetadata SourceMetadata { get; }
    protected DependencyObject SourceObject { get; }
    protected DependencyProperty SourceProperty { get; }
    internal DeferredMutableDefaultReference(PropertyMetadata metadata, DependencyObject d, DependencyProperty dp);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
    internal PropertyMetadata get_SourceMetadata();
    protected DependencyObject get_SourceObject();
    protected DependencyProperty get_SourceProperty();
}
[FriendAccessAllowedAttribute]
internal abstract class System.Windows.DeferredReference : object {
    internal abstract virtual object GetValue(BaseValueSourceInternal valueSource);
    internal abstract virtual Type GetValueType();
}
[TypeDescriptionProviderAttribute("MS.Internal.ComponentModel.DependencyObjectProvider")]
[NameScopePropertyAttribute("NameScope", "System.Windows.NameScope")]
public class System.Windows.DependencyObject : DispatcherObject {
    [FriendAccessAllowedAttribute]
internal static DependencyProperty DirectDependencyProperty;
    private static UncommonField`1<EventHandler> InheritanceContextChangedHandlersField;
    private DependencyObjectType _dType;
    internal object _contextStorage;
    private EffectiveValueEntry[] _effectiveValues;
    private UInt32 _packedData;
    [FriendAccessAllowedAttribute]
internal static object ExpressionInAlternativeStore;
    private static AlternativeExpressionStorageCallback _getExpressionCore;
    internal static UncommonField`1<object> DependentListMapField;
    internal static DependencyObjectType DType;
    private static int NestedOperationMaximum;
    public DependencyObjectType DependencyObjectType { get; }
    public bool IsSealed { get; }
    private bool CanModifyEffectiveValues { get; private set; }
    [FriendAccessAllowedAttribute]
internal bool IsInheritanceContextSealed { get; internal set; }
    private bool DO_Sealed { get; private set; }
    internal bool Freezable_Frozen { get; internal set; }
    internal bool Freezable_HasMultipleInheritanceContexts { get; internal set; }
    internal bool Freezable_UsingHandlerList { get; internal set; }
    internal bool Freezable_UsingContextList { get; internal set; }
    internal bool Freezable_UsingSingletonHandler { get; internal set; }
    internal bool Freezable_UsingSingletonContext { get; internal set; }
    internal bool Animatable_IsResourceInvalidationNecessary { get; internal set; }
    internal bool IAnimatable_HasAnimatedProperties { get; internal set; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal bool CanBeInheritanceContext { get; internal set; }
    internal EffectiveValueEntry[] EffectiveValues { get; }
    internal UInt32 EffectiveValuesCount { get; private set; }
    internal UInt32 InheritableEffectiveValuesCount { get; internal set; }
    private bool IsInPropertyInitialization { get; private set; }
    internal DependencyObject InheritanceParent { get; }
    internal bool IsSelfInheritanceParent { get; }
    [FriendAccessAllowedAttribute]
internal int EffectiveValuesInitialSize { get; }
    private static DependencyObject();
    public DependencyObjectType get_DependencyObjectType();
    private void Initialize();
    [FriendAccessAllowedAttribute]
internal virtual void Seal();
    public bool get_IsSealed();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public object GetValue(DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal EffectiveValueEntry GetValueEntry(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata, RequestFlags requests);
    private EffectiveValueEntry GetEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, RequestFlags requests);
    public void SetValue(DependencyProperty dp, object value);
    public void SetCurrentValue(DependencyProperty dp, object value);
    [FriendAccessAllowedAttribute]
internal void SetValue(DependencyProperty dp, bool value);
    [FriendAccessAllowedAttribute]
internal void SetCurrentValue(DependencyProperty dp, bool value);
    [FriendAccessAllowedAttribute]
internal void SetValueInternal(DependencyProperty dp, object value);
    [FriendAccessAllowedAttribute]
internal void SetCurrentValueInternal(DependencyProperty dp, object value);
    [FriendAccessAllowedAttribute]
internal void SetDeferredValue(DependencyProperty dp, DeferredReference deferredReference);
    [FriendAccessAllowedAttribute]
internal void SetCurrentDeferredValue(DependencyProperty dp, DeferredReference deferredReference);
    [FriendAccessAllowedAttribute]
internal void SetMutableDefaultValue(DependencyProperty dp, object value);
    [FriendAccessAllowedAttribute]
internal void SetValue(DependencyPropertyKey dp, bool value);
    public void SetValue(DependencyPropertyKey key, object value);
    private PropertyMetadata SetupPropertyChange(DependencyProperty dp);
    private PropertyMetadata SetupPropertyChange(DependencyPropertyKey key, DependencyProperty& dp);
    private void SetValueCommon(DependencyProperty dp, object value, PropertyMetadata metadata, bool coerceWithDeferredReference, bool coerceWithCurrentValue, OperationType operationType, bool isInternal);
    [FriendAccessAllowedAttribute]
internal bool ProvideSelfAsInheritanceContext(object value, DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal bool ProvideSelfAsInheritanceContext(DependencyObject doValue, DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal bool RemoveSelfAsInheritanceContext(object value, DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal bool RemoveSelfAsInheritanceContext(DependencyObject doValue, DependencyProperty dp);
    public void ClearValue(DependencyProperty dp);
    public void ClearValue(DependencyPropertyKey key);
    private void ClearValueCommon(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata);
    internal bool ContainsValue(DependencyProperty dp);
    internal static void ChangeExpressionSources(Expression expr, DependencyObject d, DependencyProperty dp, DependencySource[] newSources);
    public void CoerceValue(DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal void InvalidateSubProperty(DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal void NotifySubPropertyChange(DependencyProperty dp);
    public void InvalidateProperty(DependencyProperty dp);
    internal void InvalidateProperty(DependencyProperty dp, bool preserveCurrentValue);
    [FriendAccessAllowedAttribute]
internal UpdateResult UpdateEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry oldEntry, EffectiveValueEntry& newEntry, bool coerceWithDeferredReference, bool coerceWithCurrentValue, OperationType operationType);
    private void ProcessCoerceValue(DependencyProperty dp, PropertyMetadata metadata, EntryIndex& entryIndex, Int32& targetIndex, EffectiveValueEntry& newEntry, EffectiveValueEntry& oldEntry, Object& oldValue, object baseValue, object controlValue, CoerceValueCallback coerceValueCallback, bool coerceWithDeferredReference, bool coerceWithCurrentValue, bool skipBaseValueChecks);
    [FriendAccessAllowedAttribute]
internal void NotifyPropertyChange(DependencyPropertyChangedEventArgs args);
    private EffectiveValueEntry EvaluateExpression(EntryIndex entryIndex, DependencyProperty dp, Expression expr, PropertyMetadata metadata, EffectiveValueEntry oldEntry, EffectiveValueEntry newEntry);
    private EffectiveValueEntry EvaluateEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry oldEntry, EffectiveValueEntry newEntry, OperationType operationType);
    internal virtual void EvaluateBaseValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& newEntry);
    internal virtual void EvaluateAnimatedValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& newEntry);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected internal virtual bool ShouldSerializeProperty(DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal BaseValueSourceInternal GetValueSource(DependencyProperty dp, PropertyMetadata metadata, Boolean& hasModifiers);
    [FriendAccessAllowedAttribute]
internal BaseValueSourceInternal GetValueSource(DependencyProperty dp, PropertyMetadata metadata, Boolean& hasModifiers, Boolean& isExpression, Boolean& isAnimated, Boolean& isCoerced, Boolean& isCurrent);
    public object ReadLocalValue(DependencyProperty dp);
    internal object ReadLocalValueEntry(EntryIndex entryIndex, DependencyProperty dp, bool allowDeferredReferences);
    public LocalValueEnumerator GetLocalValueEnumerator();
    private bool get_CanModifyEffectiveValues();
    private void set_CanModifyEffectiveValues(bool value);
    internal bool get_IsInheritanceContextSealed();
    internal void set_IsInheritanceContextSealed(bool value);
    private bool get_DO_Sealed();
    private void set_DO_Sealed(bool value);
    internal bool get_Freezable_Frozen();
    internal void set_Freezable_Frozen(bool value);
    internal bool get_Freezable_HasMultipleInheritanceContexts();
    internal void set_Freezable_HasMultipleInheritanceContexts(bool value);
    internal bool get_Freezable_UsingHandlerList();
    internal void set_Freezable_UsingHandlerList(bool value);
    internal bool get_Freezable_UsingContextList();
    internal void set_Freezable_UsingContextList(bool value);
    internal bool get_Freezable_UsingSingletonHandler();
    internal void set_Freezable_UsingSingletonHandler(bool value);
    internal bool get_Freezable_UsingSingletonContext();
    internal void set_Freezable_UsingSingletonContext(bool value);
    [FriendAccessAllowedAttribute]
internal bool get_Animatable_IsResourceInvalidationNecessary();
    [FriendAccessAllowedAttribute]
internal void set_Animatable_IsResourceInvalidationNecessary(bool value);
    [FriendAccessAllowedAttribute]
internal bool get_IAnimatable_HasAnimatedProperties();
    [FriendAccessAllowedAttribute]
internal void set_IAnimatable_HasAnimatedProperties(bool value);
    internal static void UpdateSourceDependentLists(DependencyObject d, DependencyProperty dp, DependencySource[] sources, Expression expr, bool add);
    internal static void ValidateSources(DependencyObject d, DependencySource[] newSources, Expression expr);
    [FriendAccessAllowedAttribute]
internal static void RegisterForAlternativeExpressionStorage(AlternativeExpressionStorageCallback getExpressionCore, AlternativeExpressionStorageCallback& getExpression);
    internal bool HasAnyExpression();
    [FriendAccessAllowedAttribute]
internal bool HasExpression(EntryIndex entryIndex, DependencyProperty dp);
    private static Expression GetExpression(DependencyObject d, DependencyProperty dp, PropertyMetadata metadata);
    [FriendAccessAllowedAttribute]
internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool ShouldProvideInheritanceContext(DependencyObject target, DependencyProperty property);
    [FriendAccessAllowedAttribute]
internal void OnInheritanceContextChanged(EventArgs args);
    [FriendAccessAllowedAttribute]
internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    [FriendAccessAllowedAttribute]
internal void add_InheritanceContextChanged(EventHandler value);
    [FriendAccessAllowedAttribute]
internal void remove_InheritanceContextChanged(EventHandler value);
    internal virtual bool get_HasMultipleInheritanceContexts();
    [FriendAccessAllowedAttribute]
internal bool get_CanBeInheritanceContext();
    [FriendAccessAllowedAttribute]
internal void set_CanBeInheritanceContext(bool value);
    [FriendAccessAllowedAttribute]
internal static bool IsTreeWalkOperation(OperationType operation);
    [ConditionalAttribute("DEBUG")]
internal void Debug_AssertNoInheritanceContextListeners();
    [FriendAccessAllowedAttribute]
internal EffectiveValueEntry[] get_EffectiveValues();
    [FriendAccessAllowedAttribute]
internal UInt32 get_EffectiveValuesCount();
    private void set_EffectiveValuesCount(UInt32 value);
    [FriendAccessAllowedAttribute]
internal UInt32 get_InheritableEffectiveValuesCount();
    internal void set_InheritableEffectiveValuesCount(UInt32 value);
    private bool get_IsInPropertyInitialization();
    private void set_IsInPropertyInitialization(bool value);
    [FriendAccessAllowedAttribute]
internal void BeginPropertyInitialization();
    [FriendAccessAllowedAttribute]
internal void EndPropertyInitialization();
    [FriendAccessAllowedAttribute]
internal DependencyObject get_InheritanceParent();
    private void SetInheritanceParent(DependencyObject newParent);
    [FriendAccessAllowedAttribute]
internal bool get_IsSelfInheritanceParent();
    [FriendAccessAllowedAttribute]
internal void SetIsSelfInheritanceParent();
    [FriendAccessAllowedAttribute]
internal void SynchronizeInheritanceParent(DependencyObject parent);
    private void MergeInheritableProperties(DependencyObject inheritanceParent);
    private EntryIndex CheckEntryIndex(EntryIndex entryIndex, int targetIndex);
    [FriendAccessAllowedAttribute]
internal EntryIndex LookupEntry(int targetIndex);
    private void InsertEntry(EffectiveValueEntry entry, UInt32 entryIndex);
    private void RemoveEntry(UInt32 entryIndex, DependencyProperty dp);
    internal virtual int get_EffectiveValuesInitialSize();
    internal void SetEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry newEntry, EffectiveValueEntry oldEntry);
    [FriendAccessAllowedAttribute]
internal void SetEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, int targetIndex, PropertyMetadata metadata, object value, BaseValueSourceInternal valueSource);
    internal void UnsetEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata);
    private void SetExpressionValue(EntryIndex entryIndex, object value, object baseValue);
    private bool Equals(DependencyProperty dp, object value1, object value2);
}
public class System.Windows.DependencyObjectType : object {
    private int _id;
    private Type _systemType;
    private DependencyObjectType _baseDType;
    private static Dictionary`2<Type, DependencyObjectType> DTypeFromCLRType;
    private static int DTypeCount;
    private static object _lock;
    public int Id { get; }
    public Type SystemType { get; }
    public DependencyObjectType BaseType { get; }
    public string Name { get; }
    private static DependencyObjectType();
    public static DependencyObjectType FromSystemType(Type systemType);
    [FriendAccessAllowedAttribute]
internal static DependencyObjectType FromSystemTypeInternal(Type systemType);
    private static DependencyObjectType FromSystemTypeRecursive(Type systemType);
    public int get_Id();
    public Type get_SystemType();
    public DependencyObjectType get_BaseType();
    public string get_Name();
    public bool IsInstanceOfType(DependencyObject dependencyObject);
    public bool IsSubclassOf(DependencyObjectType dependencyObjectType);
    public virtual int GetHashCode();
}
[TypeConverterAttribute("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[ValueSerializerAttribute("System.Windows.DependencyPropertyValueSerializer")]
public class System.Windows.DependencyProperty : object {
    public static object UnsetValue;
    private string _name;
    private Type _propertyType;
    private Type _ownerType;
    private PropertyMetadata _defaultMetadata;
    private ValidateValueCallback _validateValueCallback;
    private DependencyPropertyKey _readOnlyKey;
    private Flags _packedData;
    internal InsertionSortMap _metadataMap;
    private CoerceValueCallback _designerCoerceValueCallback;
    internal static ItemStructList`1<DependencyProperty> RegisteredPropertyList;
    private static Hashtable PropertyFromName;
    private static int GlobalIndexCount;
    internal static object Synchronized;
    private static Type NullableType;
    public string Name { get; }
    public Type PropertyType { get; }
    public Type OwnerType { get; }
    public PropertyMetadata DefaultMetadata { get; }
    public ValidateValueCallback ValidateValueCallback { get; }
    public int GlobalIndex { get; }
    internal bool IsObjectType { get; }
    internal bool IsValueType { get; }
    internal bool IsFreezableType { get; }
    internal bool IsStringType { get; }
    internal bool IsPotentiallyInherited { get; }
    internal bool IsDefaultValueChanged { get; }
    internal bool IsPotentiallyUsingDefaultValueFactory { get; }
    public bool ReadOnly { get; }
    internal DependencyPropertyKey DependencyPropertyKey { get; }
    internal CoerceValueCallback DesignerCoerceValueCallback { get; internal set; }
    internal static int RegisteredPropertyCount { get; }
    internal static IEnumerable RegisteredProperties { get; }
    private DependencyProperty(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, ValidateValueCallback validateValueCallback);
    private static DependencyProperty();
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType);
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata);
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyPropertyKey RegisterReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata);
    public static DependencyPropertyKey RegisterReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyPropertyKey RegisterAttachedReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata);
    public static DependencyPropertyKey RegisterAttachedReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, ValidateValueCallback validateValueCallback);
    private static void RegisterParameterValidation(string name, Type propertyType, Type ownerType);
    private static DependencyProperty RegisterCommon(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, ValidateValueCallback validateValueCallback);
    private static object AutoGenerateDefaultValue(Type propertyType);
    private static PropertyMetadata AutoGeneratePropertyMetadata(Type propertyType, ValidateValueCallback validateValueCallback, string name, Type ownerType);
    private static void ValidateMetadataDefaultValue(PropertyMetadata defaultMetadata, Type propertyType, string propertyName, ValidateValueCallback validateValueCallback);
    internal void ValidateFactoryDefaultValue(object defaultValue);
    private static void ValidateDefaultValueCommon(object defaultValue, Type propertyType, string propertyName, ValidateValueCallback validateValueCallback, bool checkThreadAffinity);
    private void SetupOverrideMetadata(Type forType, PropertyMetadata typeMetadata, DependencyObjectType& dType, PropertyMetadata& baseMetadata);
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata);
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata, DependencyPropertyKey key);
    private void ProcessOverrideMetadata(Type forType, PropertyMetadata typeMetadata, DependencyObjectType dType, PropertyMetadata baseMetadata);
    [FriendAccessAllowedAttribute]
internal object GetDefaultValue(DependencyObjectType dependencyObjectType);
    [FriendAccessAllowedAttribute]
internal object GetDefaultValue(Type forType);
    public PropertyMetadata GetMetadata(Type forType);
    public PropertyMetadata GetMetadata(DependencyObject dependencyObject);
    public PropertyMetadata GetMetadata(DependencyObjectType dependencyObjectType);
    public DependencyProperty AddOwner(Type ownerType);
    public DependencyProperty AddOwner(Type ownerType, PropertyMetadata typeMetadata);
    public string get_Name();
    public Type get_PropertyType();
    public Type get_OwnerType();
    public PropertyMetadata get_DefaultMetadata();
    public ValidateValueCallback get_ValidateValueCallback();
    public int get_GlobalIndex();
    internal bool get_IsObjectType();
    internal bool get_IsValueType();
    internal bool get_IsFreezableType();
    internal bool get_IsStringType();
    internal bool get_IsPotentiallyInherited();
    internal bool get_IsDefaultValueChanged();
    internal bool get_IsPotentiallyUsingDefaultValueFactory();
    public virtual int GetHashCode();
    public bool IsValidType(object value);
    public bool IsValidValue(object value);
    public bool get_ReadOnly();
    internal DependencyPropertyKey get_DependencyPropertyKey();
    internal void VerifyReadOnlyKey(DependencyPropertyKey candidateKey);
    internal bool IsValidValueInternal(object value);
    [FriendAccessAllowedAttribute]
internal static DependencyProperty FromName(string name, Type ownerType);
    public virtual string ToString();
    internal static bool IsValidType(object value, Type propertyType);
    internal static int GetUniqueGlobalIndex(Type ownerType, string name);
    internal CoerceValueCallback get_DesignerCoerceValueCallback();
    internal void set_DesignerCoerceValueCallback(CoerceValueCallback value);
    internal static int get_RegisteredPropertyCount();
    [IteratorStateMachineAttribute("System.Windows.DependencyProperty/<get_RegisteredProperties>d__91")]
internal static IEnumerable get_RegisteredProperties();
}
public class System.Windows.DependencyPropertyChangedEventArgs : ValueType {
    private DependencyProperty _property;
    private PropertyMetadata _metadata;
    private PrivateFlags _flags;
    private EffectiveValueEntry _oldEntry;
    private EffectiveValueEntry _newEntry;
    private OperationType _operationType;
    public DependencyProperty Property { get; }
    [FriendAccessAllowedAttribute]
internal bool IsAValueChange { get; internal set; }
    [FriendAccessAllowedAttribute]
internal bool IsASubPropertyChange { get; internal set; }
    [FriendAccessAllowedAttribute]
internal PropertyMetadata Metadata { get; }
    [FriendAccessAllowedAttribute]
internal OperationType OperationType { get; }
    public object OldValue { get; }
    [FriendAccessAllowedAttribute]
internal EffectiveValueEntry OldEntry { get; }
    [FriendAccessAllowedAttribute]
internal BaseValueSourceInternal OldValueSource { get; }
    [FriendAccessAllowedAttribute]
internal bool IsOldValueModified { get; }
    [FriendAccessAllowedAttribute]
internal bool IsOldValueDeferred { get; }
    public object NewValue { get; }
    [FriendAccessAllowedAttribute]
internal EffectiveValueEntry NewEntry { get; }
    [FriendAccessAllowedAttribute]
internal BaseValueSourceInternal NewValueSource { get; }
    [FriendAccessAllowedAttribute]
internal bool IsNewValueModified { get; }
    [FriendAccessAllowedAttribute]
internal bool IsNewValueDeferred { get; }
    public DependencyPropertyChangedEventArgs(DependencyProperty property, object oldValue, object newValue);
    [FriendAccessAllowedAttribute]
internal DependencyPropertyChangedEventArgs(DependencyProperty property, PropertyMetadata metadata, object oldValue, object newValue);
    internal DependencyPropertyChangedEventArgs(DependencyProperty property, PropertyMetadata metadata, object value);
    internal DependencyPropertyChangedEventArgs(DependencyProperty property, PropertyMetadata metadata, bool isAValueChange, EffectiveValueEntry oldEntry, EffectiveValueEntry newEntry, OperationType operationType);
    public DependencyProperty get_Property();
    internal bool get_IsAValueChange();
    internal void set_IsAValueChange(bool value);
    internal bool get_IsASubPropertyChange();
    internal void set_IsASubPropertyChange(bool value);
    internal PropertyMetadata get_Metadata();
    internal OperationType get_OperationType();
    public object get_OldValue();
    internal EffectiveValueEntry get_OldEntry();
    internal BaseValueSourceInternal get_OldValueSource();
    internal bool get_IsOldValueModified();
    internal bool get_IsOldValueDeferred();
    public object get_NewValue();
    internal EffectiveValueEntry get_NewEntry();
    internal BaseValueSourceInternal get_NewValueSource();
    internal bool get_IsNewValueModified();
    internal bool get_IsNewValueDeferred();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(DependencyPropertyChangedEventArgs args);
    public static bool op_Equality(DependencyPropertyChangedEventArgs left, DependencyPropertyChangedEventArgs right);
    public static bool op_Inequality(DependencyPropertyChangedEventArgs left, DependencyPropertyChangedEventArgs right);
    private void WritePrivateFlag(PrivateFlags bit, bool value);
    private bool ReadPrivateFlag(PrivateFlags bit);
}
public class System.Windows.DependencyPropertyChangedEventHandler : MulticastDelegate {
    public DependencyPropertyChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DependencyPropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DependencyPropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DependencyPropertyKey : object {
    private DependencyProperty _dp;
    public DependencyProperty DependencyProperty { get; }
    internal DependencyPropertyKey(DependencyProperty dp);
    public DependencyProperty get_DependencyProperty();
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata);
    internal void SetDependencyProperty(DependencyProperty dp);
}
internal class System.Windows.DependencyPropertyValueSerializer : ValueSerializer {
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
    public virtual IEnumerable`1<Type> TypeReferences(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
}
internal class System.Windows.DependencySource : object {
    private DependencyObject _d;
    private DependencyProperty _dp;
    public DependencyObject DependencyObject { get; }
    public DependencyProperty DependencyProperty { get; }
    public DependencySource(DependencyObject d, DependencyProperty dp);
    public DependencyObject get_DependencyObject();
    public DependencyProperty get_DependencyProperty();
}
internal class System.Windows.Dependent : ValueType {
    private DependencyProperty _DP;
    private WeakReference _wrDO;
    private WeakReference _wrEX;
    public DependencyObject DO { get; }
    public DependencyProperty DP { get; }
    public Expression Expr { get; }
    public Dependent(DependencyObject o, DependencyProperty p, Expression e);
    public bool IsValid();
    public DependencyObject get_DO();
    public DependencyProperty get_DP();
    public Expression get_Expr();
    public virtual bool Equals(object o);
    public static bool op_Equality(Dependent first, Dependent second);
    public static bool op_Inequality(Dependent first, Dependent second);
    public virtual int GetHashCode();
}
internal class System.Windows.DependentList : FrugalObjectList`1<Dependent> {
    public bool IsEmpty { get; }
    public void Add(DependencyObject d, DependencyProperty dp, Expression expr);
    public void Remove(DependencyObject d, DependencyProperty dp, Expression expr);
    public bool get_IsEmpty();
    public void InvalidateDependents(DependencyObject source, DependencyPropertyChangedEventArgs sourceArgs);
    private void CleanUpDeadWeakReferences();
}
[FriendAccessAllowedAttribute]
internal class System.Windows.EffectiveValueEntry : ValueType {
    private object _value;
    private short _propertyIndex;
    private FullValueSource _source;
    public int PropertyIndex { get; public set; }
    internal object Value { get; internal set; }
    internal BaseValueSourceInternal BaseValueSourceInternal { get; internal set; }
    internal bool IsDeferredReference { get; private set; }
    internal bool IsExpression { get; private set; }
    internal bool IsAnimated { get; private set; }
    internal bool IsCoerced { get; private set; }
    internal bool HasModifiers { get; }
    internal FullValueSource FullValueSource { get; }
    internal bool HasExpressionMarker { get; internal set; }
    internal bool IsCoercedWithCurrentValue { get; internal set; }
    internal object LocalValue { get; internal set; }
    internal ModifiedValue ModifiedValue { get; }
    internal EffectiveValueEntry(DependencyProperty dp);
    internal EffectiveValueEntry(DependencyProperty dp, BaseValueSourceInternal valueSource);
    internal EffectiveValueEntry(DependencyProperty dp, FullValueSource fullValueSource);
    internal static EffectiveValueEntry CreateDefaultValueEntry(DependencyProperty dp, object value);
    internal void SetExpressionValue(object value, object baseValue);
    internal void SetAnimatedValue(object value, object baseValue);
    internal void SetCoercedValue(object value, object baseValue, bool skipBaseValueChecks, bool coerceWithCurrentValue);
    internal void ResetAnimatedValue();
    internal void ResetCoercedValue();
    internal void ResetValue(object value, bool hasExpressionMarker);
    internal void RestoreExpressionMarker();
    private void ComputeIsDeferred();
    public int get_PropertyIndex();
    public void set_PropertyIndex(int value);
    internal object get_Value();
    internal void set_Value(object value);
    internal BaseValueSourceInternal get_BaseValueSourceInternal();
    internal void set_BaseValueSourceInternal(BaseValueSourceInternal value);
    internal bool get_IsDeferredReference();
    private void set_IsDeferredReference(bool value);
    internal bool get_IsExpression();
    private void set_IsExpression(bool value);
    internal bool get_IsAnimated();
    private void set_IsAnimated(bool value);
    internal bool get_IsCoerced();
    private void set_IsCoerced(bool value);
    internal bool get_HasModifiers();
    internal FullValueSource get_FullValueSource();
    internal bool get_HasExpressionMarker();
    internal void set_HasExpressionMarker(bool value);
    internal bool get_IsCoercedWithCurrentValue();
    internal void set_IsCoercedWithCurrentValue(bool value);
    internal EffectiveValueEntry GetFlattenedEntry(RequestFlags requests);
    internal void SetAnimationBaseValue(object animationBaseValue);
    internal void SetCoersionBaseValue(object coersionBaseValue);
    internal object get_LocalValue();
    internal void set_LocalValue(object value);
    internal ModifiedValue get_ModifiedValue();
    private ModifiedValue EnsureModifiedValue(bool useWeakReferenceForBaseValue);
    internal void Clear();
    private void WritePrivateFlag(FullValueSource bit, bool value);
    private bool ReadPrivateFlag(FullValueSource bit);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.EntryIndex : ValueType {
    private UInt32 _store;
    public bool Found { get; }
    public UInt32 Index { get; }
    public EntryIndex(UInt32 index);
    public EntryIndex(UInt32 index, bool found);
    public bool get_Found();
    public UInt32 get_Index();
}
[TypeConverterAttribute("System.Windows.ExpressionConverter")]
public class System.Windows.Expression : object {
    [FriendAccessAllowedAttribute]
internal static object NoValue;
    private InternalFlags _flags;
    internal bool Attachable { get; }
    internal bool Shareable { get; }
    internal bool ForwardsInvalidations { get; }
    internal bool SupportsUnboundSources { get; }
    internal bool HasBeenAttached { get; }
    internal bool HasBeenDetached { get; }
    internal Expression(ExpressionMode mode);
    private static Expression();
    [FriendAccessAllowedAttribute]
internal virtual Expression Copy(DependencyObject targetObject, DependencyProperty targetDP);
    internal virtual DependencySource[] GetSources();
    internal virtual object GetValue(DependencyObject d, DependencyProperty dp);
    internal virtual bool SetValue(DependencyObject d, DependencyProperty dp, object value);
    internal virtual void OnAttach(DependencyObject d, DependencyProperty dp);
    internal virtual void OnDetach(DependencyObject d, DependencyProperty dp);
    internal virtual void OnPropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    internal void ChangeSources(DependencyObject d, DependencyProperty dp, DependencySource[] newSources);
    internal bool get_Attachable();
    internal bool get_Shareable();
    internal bool get_ForwardsInvalidations();
    internal bool get_SupportsUnboundSources();
    internal bool get_HasBeenAttached();
    internal bool get_HasBeenDetached();
    internal void MarkAttached();
    internal void MarkDetached();
}
public class System.Windows.ExpressionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal enum System.Windows.ExpressionMode : Enum {
    public int value__;
    public static ExpressionMode None;
    public static ExpressionMode NonSharable;
    public static ExpressionMode ForwardsInvalidations;
    public static ExpressionMode SupportsUnboundSources;
}
public abstract class System.Windows.Freezable : DependencyObject {
    [ThreadStaticAttribute]
private static EventStorage _eventStorage;
    private DependencyProperty _property;
    private static int INITIAL_EVENTSTORAGE_SIZE;
    public bool CanFreeze { get; }
    public bool IsFrozen { get; }
    internal bool IsFrozenInternal { get; }
    private EventStorage CachedEventStorage { get; }
    private bool System.Windows.ISealable.CanSeal { get; }
    private bool System.Windows.ISealable.IsSealed { get; }
    private FrugalObjectList`1<FreezableContextPair> ContextList { get; private set; }
    private FrugalObjectList`1<EventHandler> HandlerList { get; }
    private EventHandler SingletonHandler { get; }
    private DependencyObject SingletonContext { get; }
    private DependencyProperty SingletonContextProperty { get; }
    private bool HasHandlers { get; }
    private bool HasContextInformation { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    public Freezable Clone();
    public Freezable CloneCurrentValue();
    public Freezable GetAsFrozen();
    public Freezable GetCurrentValueAsFrozen();
    public bool get_CanFreeze();
    public void Freeze();
    public bool get_IsFrozen();
    internal bool get_IsFrozenInternal();
    public void add_Changed(EventHandler value);
    public void remove_Changed(EventHandler value);
    internal void add_ChangedInternal(EventHandler value);
    internal void remove_ChangedInternal(EventHandler value);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected Freezable CreateInstance();
    protected abstract virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    private EventStorage get_CachedEventStorage();
    private EventStorage GetEventStorage();
    protected virtual void OnChanged();
    private void GetChangeHandlersAndInvalidateSubProperties(EventStorage& calledHandlers);
    protected void ReadPreamble();
    protected void WritePreamble();
    protected void WritePostscript();
    protected void OnFreezablePropertyChanged(DependencyObject oldValue, DependencyObject newValue);
    protected void OnFreezablePropertyChanged(DependencyObject oldValue, DependencyObject newValue, DependencyProperty property);
    protected internal static bool Freeze(Freezable freezable, bool isChecking);
    private sealed virtual override bool System.Windows.ISealable.get_CanSeal();
    private sealed virtual override bool System.Windows.ISealable.get_IsSealed();
    private sealed virtual override void System.Windows.ISealable.Seal();
    internal void ClearContextAndHandlers();
    internal void FireChanged();
    internal virtual void Seal();
    internal bool Freeze(bool isChecking);
    private void CloneCoreCommon(Freezable sourceFreezable, bool useCurrentValue, bool cloneFrozenValues);
    private static void EnsureConsistentDispatchers(DependencyObject owner, DependencyObject child);
    private void RemoveContextInformation(DependencyObject context, DependencyProperty property);
    private void RemoveSingletonContext();
    private void RemoveContextList();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal void AddContextInformation(DependencyObject context, DependencyProperty property);
    private void ConvertToContextList();
    private void AddSingletonContext(DependencyObject context, DependencyProperty property);
    private void AddContextToList(DependencyObject context, DependencyProperty property);
    private void PruneContexts(FrugalObjectList`1<FreezableContextPair> oldList, int numDead);
    private void GetHandlers(EventStorage& calledHandlers);
    private void HandlerAdd(EventHandler handler);
    private void HandlerRemove(EventHandler handler);
    private void RemoveSingletonHandler();
    private void RemoveHandlerList();
    private void ConvertToHandlerList();
    private void AddSingletonHandler(EventHandler handler);
    private FrugalObjectList`1<FreezableContextPair> get_ContextList();
    private void set_ContextList(FrugalObjectList`1<FreezableContextPair> value);
    private FrugalObjectList`1<EventHandler> get_HandlerList();
    private EventHandler get_SingletonHandler();
    private DependencyObject get_SingletonContext();
    private DependencyProperty get_SingletonContextProperty();
    private bool get_HasHandlers();
    private bool get_HasContextInformation();
    [FriendAccessAllowedAttribute]
internal virtual DependencyObject get_InheritanceContext();
    [FriendAccessAllowedAttribute]
internal virtual bool get_HasMultipleInheritanceContexts();
    private static void Debug_VerifyCloneCommon(Freezable original, object clone, bool isDeepClone);
    private static void Debug_VerifyInstance(string methodName, Freezable original, Freezable newInstance);
    private void Debug_DetectContextLeaks();
    private void Debug_VerifyContextIsValid(DependencyObject owner, DependencyProperty property);
}
internal class System.Windows.FreezeValueCallback : MulticastDelegate {
    public FreezeValueCallback(object object, IntPtr method);
    public virtual bool Invoke(DependencyObject d, DependencyProperty dp, EntryIndex entryIndex, PropertyMetadata metadata, bool isChecking);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, DependencyProperty dp, EntryIndex entryIndex, PropertyMetadata metadata, bool isChecking, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal enum System.Windows.FullValueSource : Enum {
    public short value__;
    public static FullValueSource ValueSourceMask;
    public static FullValueSource ModifiersMask;
    public static FullValueSource IsExpression;
    public static FullValueSource IsAnimated;
    public static FullValueSource IsCoerced;
    public static FullValueSource IsPotentiallyADeferredReference;
    public static FullValueSource HasExpressionMarker;
    public static FullValueSource IsCoercedWithCurrentValue;
}
[FriendAccessAllowedAttribute]
internal class System.Windows.GetReadOnlyValueCallback : MulticastDelegate {
    public GetReadOnlyValueCallback(object object, IntPtr method);
    public virtual object Invoke(DependencyObject d, BaseValueSourceInternal& source);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, BaseValueSourceInternal& source, AsyncCallback callback, object object);
    public virtual object EndInvoke(BaseValueSourceInternal& source, IAsyncResult result);
}
public enum System.Windows.Input.FocusNavigationDirection : Enum {
    public int value__;
    public static FocusNavigationDirection Next;
    public static FocusNavigationDirection Previous;
    public static FocusNavigationDirection First;
    public static FocusNavigationDirection Last;
    public static FocusNavigationDirection Left;
    public static FocusNavigationDirection Right;
    public static FocusNavigationDirection Up;
    public static FocusNavigationDirection Down;
}
[TypeConverterAttribute("System.Windows.Input.KeyConverter")]
[ValueSerializerAttribute("System.Windows.Input.KeyValueSerializer")]
public enum System.Windows.Input.Key : Enum {
    public int value__;
    public static Key None;
    public static Key Cancel;
    public static Key Back;
    public static Key Tab;
    public static Key LineFeed;
    public static Key Clear;
    public static Key Return;
    public static Key Enter;
    public static Key Pause;
    public static Key Capital;
    public static Key CapsLock;
    public static Key KanaMode;
    public static Key HangulMode;
    public static Key JunjaMode;
    public static Key FinalMode;
    public static Key HanjaMode;
    public static Key KanjiMode;
    public static Key Escape;
    public static Key ImeConvert;
    public static Key ImeNonConvert;
    public static Key ImeAccept;
    public static Key ImeModeChange;
    public static Key Space;
    public static Key Prior;
    public static Key PageUp;
    public static Key Next;
    public static Key PageDown;
    public static Key End;
    public static Key Home;
    public static Key Left;
    public static Key Up;
    public static Key Right;
    public static Key Down;
    public static Key Select;
    public static Key Print;
    public static Key Execute;
    public static Key Snapshot;
    public static Key PrintScreen;
    public static Key Insert;
    public static Key Delete;
    public static Key Help;
    public static Key D0;
    public static Key D1;
    public static Key D2;
    public static Key D3;
    public static Key D4;
    public static Key D5;
    public static Key D6;
    public static Key D7;
    public static Key D8;
    public static Key D9;
    public static Key A;
    public static Key B;
    public static Key C;
    public static Key D;
    public static Key E;
    public static Key F;
    public static Key G;
    public static Key H;
    public static Key I;
    public static Key J;
    public static Key K;
    public static Key L;
    public static Key M;
    public static Key N;
    public static Key O;
    public static Key P;
    public static Key Q;
    public static Key R;
    public static Key S;
    public static Key T;
    public static Key U;
    public static Key V;
    public static Key W;
    public static Key X;
    public static Key Y;
    public static Key Z;
    public static Key LWin;
    public static Key RWin;
    public static Key Apps;
    public static Key Sleep;
    public static Key NumPad0;
    public static Key NumPad1;
    public static Key NumPad2;
    public static Key NumPad3;
    public static Key NumPad4;
    public static Key NumPad5;
    public static Key NumPad6;
    public static Key NumPad7;
    public static Key NumPad8;
    public static Key NumPad9;
    public static Key Multiply;
    public static Key Add;
    public static Key Separator;
    public static Key Subtract;
    public static Key Decimal;
    public static Key Divide;
    public static Key F1;
    public static Key F2;
    public static Key F3;
    public static Key F4;
    public static Key F5;
    public static Key F6;
    public static Key F7;
    public static Key F8;
    public static Key F9;
    public static Key F10;
    public static Key F11;
    public static Key F12;
    public static Key F13;
    public static Key F14;
    public static Key F15;
    public static Key F16;
    public static Key F17;
    public static Key F18;
    public static Key F19;
    public static Key F20;
    public static Key F21;
    public static Key F22;
    public static Key F23;
    public static Key F24;
    public static Key NumLock;
    public static Key Scroll;
    public static Key LeftShift;
    public static Key RightShift;
    public static Key LeftCtrl;
    public static Key RightCtrl;
    public static Key LeftAlt;
    public static Key RightAlt;
    public static Key BrowserBack;
    public static Key BrowserForward;
    public static Key BrowserRefresh;
    public static Key BrowserStop;
    public static Key BrowserSearch;
    public static Key BrowserFavorites;
    public static Key BrowserHome;
    public static Key VolumeMute;
    public static Key VolumeDown;
    public static Key VolumeUp;
    public static Key MediaNextTrack;
    public static Key MediaPreviousTrack;
    public static Key MediaStop;
    public static Key MediaPlayPause;
    public static Key LaunchMail;
    public static Key SelectMedia;
    public static Key LaunchApplication1;
    public static Key LaunchApplication2;
    public static Key Oem1;
    public static Key OemSemicolon;
    public static Key OemPlus;
    public static Key OemComma;
    public static Key OemMinus;
    public static Key OemPeriod;
    public static Key Oem2;
    public static Key OemQuestion;
    public static Key Oem3;
    public static Key OemTilde;
    public static Key AbntC1;
    public static Key AbntC2;
    public static Key Oem4;
    public static Key OemOpenBrackets;
    public static Key Oem5;
    public static Key OemPipe;
    public static Key Oem6;
    public static Key OemCloseBrackets;
    public static Key Oem7;
    public static Key OemQuotes;
    public static Key Oem8;
    public static Key Oem102;
    public static Key OemBackslash;
    public static Key ImeProcessed;
    public static Key System;
    public static Key OemAttn;
    public static Key DbeAlphanumeric;
    public static Key OemFinish;
    public static Key DbeKatakana;
    public static Key OemCopy;
    public static Key DbeHiragana;
    public static Key OemAuto;
    public static Key DbeSbcsChar;
    public static Key OemEnlw;
    public static Key DbeDbcsChar;
    public static Key OemBackTab;
    public static Key DbeRoman;
    public static Key Attn;
    public static Key DbeNoRoman;
    public static Key CrSel;
    public static Key DbeEnterWordRegisterMode;
    public static Key ExSel;
    public static Key DbeEnterImeConfigureMode;
    public static Key EraseEof;
    public static Key DbeFlushString;
    public static Key Play;
    public static Key DbeCodeInput;
    public static Key Zoom;
    public static Key DbeNoCodeInput;
    public static Key NoName;
    public static Key DbeDetermineString;
    public static Key Pa1;
    public static Key DbeEnterDialogConversionMode;
    public static Key OemClear;
    public static Key DeadCharProcessed;
}
public class System.Windows.Input.KeyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    private object GetKey(string keyToken, CultureInfo culture);
    private static string MatchKey(Key key, CultureInfo culture);
}
public static class System.Windows.Input.KeyInterop : object {
    public static Key KeyFromVirtualKey(int virtualKey);
    public static int VirtualKeyFromKey(Key key);
}
public class System.Windows.Input.KeyValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[TypeConverterAttribute("System.Windows.Input.ModifierKeysConverter")]
[ValueSerializerAttribute("System.Windows.Input.ModifierKeysValueSerializer")]
[FlagsAttribute]
public enum System.Windows.Input.ModifierKeys : Enum {
    public int value__;
    public static ModifierKeys None;
    public static ModifierKeys Alt;
    public static ModifierKeys Control;
    public static ModifierKeys Shift;
    public static ModifierKeys Windows;
}
public class System.Windows.Input.ModifierKeysConverter : TypeConverter {
    private static char Modifier_Delimiter;
    private static ModifierKeys ModifierKeysFlag;
    private static ModifierKeysConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    private ModifierKeys GetModifierKeys(string modifiersToken, CultureInfo culture);
    public static bool IsDefinedModifierKeys(ModifierKeys modifierKeys);
    internal static string MatchModifiers(ModifierKeys modifierKeys);
}
public class System.Windows.Input.ModifierKeysValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.TraversalRequest : object {
    private bool _wrapped;
    private FocusNavigationDirection _focusNavigationDirection;
    public bool Wrapped { get; public set; }
    public FocusNavigationDirection FocusNavigationDirection { get; }
    public TraversalRequest(FocusNavigationDirection focusNavigationDirection);
    public bool get_Wrapped();
    public void set_Wrapped(bool value);
    public FocusNavigationDirection get_FocusNavigationDirection();
}
[TypeConverterAttribute("System.Windows.Int32RectConverter")]
[ValueSerializerAttribute("System.Windows.Converters.Int32RectValueSerializer")]
public class System.Windows.Int32Rect : ValueType {
    internal int _x;
    internal int _y;
    internal int _width;
    internal int _height;
    private static Int32Rect s_empty;
    public int X { get; public set; }
    public int Y { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public static Int32Rect Empty { get; }
    public bool IsEmpty { get; }
    public bool HasArea { get; }
    public Int32Rect(int x, int y, int width, int height);
    private static Int32Rect();
    public static bool op_Equality(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public static bool op_Inequality(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public static bool Equals(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public virtual bool Equals(object o);
    public bool Equals(Int32Rect value);
    public virtual int GetHashCode();
    public static Int32Rect Parse(string source);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Int32Rect get_Empty();
    public bool get_IsEmpty();
    public bool get_HasArea();
    internal void ValidateForDirtyRect(string paramName, int width, int height);
}
public class System.Windows.Int32RectConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Interop.ComponentDispatcher : object {
    private static LocalDataStoreSlot _threadSlot;
    private static ComponentDispatcherThread CurrentThreadData { get; }
    public static bool IsThreadModal { get; }
    public static MSG CurrentKeyboardMessage { get; }
    internal static MSG UnsecureCurrentKeyboardMessage { get; internal set; }
    private static ComponentDispatcher();
    private static ComponentDispatcherThread get_CurrentThreadData();
    public static bool get_IsThreadModal();
    public static MSG get_CurrentKeyboardMessage();
    [FriendAccessAllowedAttribute]
internal static MSG get_UnsecureCurrentKeyboardMessage();
    [FriendAccessAllowedAttribute]
internal static void set_UnsecureCurrentKeyboardMessage(MSG value);
    public static void PushModal();
    internal static void CriticalPushModal();
    public static void PopModal();
    internal static void CriticalPopModal();
    public static void RaiseIdle();
    public static bool RaiseThreadMessage(MSG& msg);
    public static void add_ThreadIdle(EventHandler value);
    public static void remove_ThreadIdle(EventHandler value);
    public static void add_ThreadFilterMessage(ThreadMessageEventHandler value);
    public static void remove_ThreadFilterMessage(ThreadMessageEventHandler value);
    public static void add_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    public static void remove_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    internal static void CriticalAddThreadPreprocessMessageHandlerFirst(ThreadMessageEventHandler handler);
    internal static void CriticalRemoveThreadPreprocessMessageHandlerFirst(ThreadMessageEventHandler handler);
    public static void add_EnterThreadModal(EventHandler value);
    public static void remove_EnterThreadModal(EventHandler value);
    public static void add_LeaveThreadModal(EventHandler value);
    public static void remove_LeaveThreadModal(EventHandler value);
}
internal class System.Windows.Interop.ComponentDispatcherThread : object {
    [CompilerGeneratedAttribute]
private EventHandler _threadIdle;
    [CompilerGeneratedAttribute]
private ThreadMessageEventHandler _threadFilterMessage;
    [CompilerGeneratedAttribute]
private ThreadMessageEventHandler _threadPreprocessMessage;
    [CompilerGeneratedAttribute]
private EventHandler _enterThreadModal;
    [CompilerGeneratedAttribute]
private EventHandler _leaveThreadModal;
    private int _modalCount;
    private MSG _currentKeyboardMSG;
    public bool IsThreadModal { get; }
    public MSG CurrentKeyboardMessage { get; public set; }
    public bool get_IsThreadModal();
    public MSG get_CurrentKeyboardMessage();
    public void set_CurrentKeyboardMessage(MSG value);
    public void PushModal();
    public void PopModal();
    public void RaiseIdle();
    public bool RaiseThreadMessage(MSG& msg);
    public void add_ThreadIdle(EventHandler value);
    public void remove_ThreadIdle(EventHandler value);
    [CompilerGeneratedAttribute]
private void add__threadIdle(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove__threadIdle(EventHandler value);
    public void add_ThreadFilterMessage(ThreadMessageEventHandler value);
    public void remove_ThreadFilterMessage(ThreadMessageEventHandler value);
    [CompilerGeneratedAttribute]
private void add__threadFilterMessage(ThreadMessageEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__threadFilterMessage(ThreadMessageEventHandler value);
    public void add_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    public void remove_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    public void AddThreadPreprocessMessageHandlerFirst(ThreadMessageEventHandler handler);
    public void RemoveThreadPreprocessMessageHandlerFirst(ThreadMessageEventHandler handler);
    [CompilerGeneratedAttribute]
private void add__threadPreprocessMessage(ThreadMessageEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__threadPreprocessMessage(ThreadMessageEventHandler value);
    public void add_EnterThreadModal(EventHandler value);
    public void remove_EnterThreadModal(EventHandler value);
    [CompilerGeneratedAttribute]
private void add__enterThreadModal(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove__enterThreadModal(EventHandler value);
    public void add_LeaveThreadModal(EventHandler value);
    public void remove_LeaveThreadModal(EventHandler value);
    [CompilerGeneratedAttribute]
private void add__leaveThreadModal(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove__leaveThreadModal(EventHandler value);
}
public interface System.Windows.Interop.IKeyboardInputSink {
    public IKeyboardInputSite KeyboardInputSite { get; public set; }
    public abstract virtual IKeyboardInputSite RegisterKeyboardInputSink(IKeyboardInputSink sink);
    public abstract virtual bool TranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    public abstract virtual bool TabInto(TraversalRequest request);
    public abstract virtual IKeyboardInputSite get_KeyboardInputSite();
    public abstract virtual void set_KeyboardInputSite(IKeyboardInputSite value);
    public abstract virtual bool OnMnemonic(MSG& msg, ModifierKeys modifiers);
    public abstract virtual bool TranslateChar(MSG& msg, ModifierKeys modifiers);
    public abstract virtual bool HasFocusWithin();
}
public interface System.Windows.Interop.IKeyboardInputSite {
    public IKeyboardInputSink Sink { get; }
    public abstract virtual void Unregister();
    public abstract virtual IKeyboardInputSink get_Sink();
    public abstract virtual bool OnNoMoreTabStops(TraversalRequest request);
}
public class System.Windows.Interop.MSG : ValueType {
    private IntPtr _hwnd;
    private int _message;
    private IntPtr _wParam;
    private IntPtr _lParam;
    private int _time;
    private int _pt_x;
    private int _pt_y;
    public IntPtr hwnd { get; public set; }
    public int message { get; public set; }
    public IntPtr wParam { get; public set; }
    public IntPtr lParam { get; public set; }
    public int time { get; public set; }
    public int pt_x { get; public set; }
    public int pt_y { get; public set; }
    [FriendAccessAllowedAttribute]
internal MSG(IntPtr hwnd, int message, IntPtr wParam, IntPtr lParam, int time, int pt_x, int pt_y);
    public IntPtr get_hwnd();
    public void set_hwnd(IntPtr value);
    public int get_message();
    public void set_message(int value);
    public IntPtr get_wParam();
    public void set_wParam(IntPtr value);
    public IntPtr get_lParam();
    public void set_lParam(IntPtr value);
    public int get_time();
    public void set_time(int value);
    public int get_pt_x();
    public void set_pt_x(int value);
    public int get_pt_y();
    public void set_pt_y(int value);
}
public class System.Windows.Interop.ThreadMessageEventHandler : MulticastDelegate {
    public ThreadMessageEventHandler(object object, IntPtr method);
    public virtual void Invoke(MSG& msg, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(MSG& msg, Boolean& handled, AsyncCallback callback, object object);
    public virtual void EndInvoke(MSG& msg, Boolean& handled, IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal interface System.Windows.ISealable {
    public bool CanSeal { get; }
    public bool IsSealed { get; }
    public abstract virtual bool get_CanSeal();
    public abstract virtual void Seal();
    public abstract virtual bool get_IsSealed();
}
public interface System.Windows.IWeakEventListener {
    public abstract virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
}
public class System.Windows.LocalValueEntry : ValueType {
    internal DependencyProperty _dp;
    internal object _value;
    public DependencyProperty Property { get; }
    public object Value { get; }
    internal LocalValueEntry(DependencyProperty dp, object value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(LocalValueEntry obj1, LocalValueEntry obj2);
    public static bool op_Inequality(LocalValueEntry obj1, LocalValueEntry obj2);
    public DependencyProperty get_Property();
    public object get_Value();
}
public class System.Windows.LocalValueEnumerator : ValueType {
    private int _index;
    private LocalValueEntry[] _snapshot;
    private int _count;
    public LocalValueEntry Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public int Count { get; }
    internal LocalValueEnumerator(LocalValueEntry[] snapshot, int count);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(LocalValueEnumerator obj1, LocalValueEnumerator obj2);
    public static bool op_Inequality(LocalValueEnumerator obj1, LocalValueEnumerator obj2);
    public LocalValueEntry get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public int get_Count();
}
internal class System.Windows.Markup.DateTimeConverter2 : TypeConverter {
    private DateTimeValueSerializer _dateTimeValueSerializer;
    private IValueSerializerContext _valueSerializerContext;
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Windows.Markup.DateTimeValueSerializerContext : object {
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public sealed virtual ValueSerializer GetValueSerializerFor(PropertyDescriptor descriptor);
    public sealed virtual ValueSerializer GetValueSerializerFor(Type type);
    public sealed virtual IContainer get_Container();
    public sealed virtual object get_Instance();
    public sealed virtual void OnComponentChanged();
    public sealed virtual bool OnComponentChanging();
    public sealed virtual PropertyDescriptor get_PropertyDescriptor();
    public sealed virtual object GetService(Type serviceType);
}
[FlagsAttribute]
public enum System.Windows.Markup.DesignerSerializationOptions : Enum {
    public int value__;
    public static DesignerSerializationOptions SerializeAsAttribute;
}
[AttributeUsageAttribute("448")]
public class System.Windows.Markup.DesignerSerializationOptionsAttribute : Attribute {
    private DesignerSerializationOptions _designerSerializationOptions;
    public DesignerSerializationOptions DesignerSerializationOptions { get; }
    public DesignerSerializationOptionsAttribute(DesignerSerializationOptions designerSerializationOptions);
    public DesignerSerializationOptions get_DesignerSerializationOptions();
}
internal class System.Windows.Markup.HandleAttributeCallback : MulticastDelegate {
    public HandleAttributeCallback(object object, IntPtr method);
    public virtual void Invoke(int elementDepth);
    public virtual IAsyncResult BeginInvoke(int elementDepth, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Markup.HandleElementCallback : MulticastDelegate {
    public HandleElementCallback(object object, IntPtr method);
    public virtual void Invoke(int elementDepth, Boolean& more);
    public virtual IAsyncResult BeginInvoke(int elementDepth, Boolean& more, AsyncCallback callback, object object);
    public virtual void EndInvoke(Boolean& more, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public abstract class System.Windows.Markup.InternalTypeHelper : object {
    protected internal abstract virtual object CreateInstance(Type type, CultureInfo culture);
    protected internal abstract virtual object GetPropertyValue(PropertyInfo propertyInfo, object target, CultureInfo culture);
    protected internal abstract virtual void SetPropertyValue(PropertyInfo propertyInfo, object target, object value, CultureInfo culture);
    protected internal abstract virtual Delegate CreateDelegate(Type delegateType, object target, string handler);
    protected internal abstract virtual void AddEventHandler(EventInfo eventInfo, object target, Delegate handler);
}
[ObsoleteAttribute("IReceiveMarkupExtension has been deprecated. This interface is no longer in use.")]
public interface System.Windows.Markup.IReceiveMarkupExtension {
    public abstract virtual void ReceiveMarkupExtension(string property, MarkupExtension markupExtension, IServiceProvider serviceProvider);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Markup.IsXmlNamespaceSupportedCallback : MulticastDelegate {
    public IsXmlNamespaceSupportedCallback(object object, IntPtr method);
    public virtual bool Invoke(string xmlNamespace, String& newXmlNamespace);
    public virtual IAsyncResult BeginInvoke(string xmlNamespace, String& newXmlNamespace, AsyncCallback callback, object object);
    public virtual bool EndInvoke(String& newXmlNamespace, IAsyncResult result);
}
internal static class System.Windows.Markup.NameValidationHelper : object {
    [FriendAccessAllowedAttribute]
internal static bool NameValidationCallback(object candidateName);
    [FriendAccessAllowedAttribute]
internal static bool IsValidIdentifierName(string name);
}
public abstract class System.Windows.Markup.Primitives.MarkupObject : object {
    public Type ObjectType { get; }
    public object Instance { get; }
    public IEnumerable`1<MarkupProperty> Properties { get; }
    public AttributeCollection Attributes { get; }
    public abstract virtual Type get_ObjectType();
    public abstract virtual object get_Instance();
    public virtual IEnumerable`1<MarkupProperty> get_Properties();
    internal abstract virtual IEnumerable`1<MarkupProperty> GetProperties(bool mapToConstructorArgs);
    public abstract virtual void AssignRootContext(IValueSerializerContext context);
    public abstract virtual AttributeCollection get_Attributes();
}
public abstract class System.Windows.Markup.Primitives.MarkupProperty : object {
    public string Name { get; }
    public Type PropertyType { get; }
    internal bool IsCollectionProperty { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public DependencyProperty DependencyProperty { get; }
    public bool IsAttached { get; }
    public bool IsConstructorArgument { get; }
    public bool IsValueAsString { get; }
    public bool IsContent { get; }
    public bool IsKey { get; }
    public bool IsComposite { get; }
    public object Value { get; }
    public string StringValue { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public AttributeCollection Attributes { get; }
    public abstract virtual string get_Name();
    public abstract virtual Type get_PropertyType();
    internal bool get_IsCollectionProperty();
    public virtual PropertyDescriptor get_PropertyDescriptor();
    public virtual DependencyProperty get_DependencyProperty();
    public virtual bool get_IsAttached();
    public virtual bool get_IsConstructorArgument();
    public virtual bool get_IsValueAsString();
    public virtual bool get_IsContent();
    public virtual bool get_IsKey();
    public virtual bool get_IsComposite();
    public abstract virtual object get_Value();
    public abstract virtual string get_StringValue();
    public abstract virtual IEnumerable`1<Type> get_TypeReferences();
    public abstract virtual IEnumerable`1<MarkupObject> get_Items();
    public abstract virtual AttributeCollection get_Attributes();
    internal virtual void VerifyOnlySerializableTypes();
}
internal static class System.Windows.Markup.ReflectionHelper : object {
    private static string SystemReflectionAssemblyName;
    internal static string MscorlibReflectionAssemblyName;
    private static Hashtable _loadedAssembliesHash;
    private static ReflectionHelper();
    internal static Type GetQualifiedType(string typeName);
    internal static bool IsNullableType(Type type);
    internal static bool IsInternalType(Type type);
    internal static bool IsPublicType(Type type);
    internal static Type GetFrameworkType(string assemblyName, Type type);
    internal static Type GetSystemType(Type type);
    internal static Type GetReflectionType(object item);
    internal static string GetTypeConverterAttributeData(Type type, Type& converterType);
    internal static string GetTypeConverterAttributeData(MemberInfo mi, Type& converterType);
    private static string GetCustomAttributeData(MemberInfo mi, Type attrType, Type& typeValue);
    private static string GetCustomAttributeData(IList`1<CustomAttributeData> list, Type attrType, Type& typeValue, bool allowTypeAlso, bool allowZeroArgs);
    internal static string GetCustomAttributeData(Type t, Type attrType, bool allowTypeAlso, Boolean& attributeDataFound, Type& typeValue);
    private static string GetCustomAttributeData(CustomAttributeData cad, Type attrType, Type& typeValue, bool allowTypeAlso, bool noArgs, bool zeroArgsAllowed);
    internal static void ResetCacheForAssembly(string assemblyName);
    internal static Assembly LoadAssembly(string assemblyName, string assemblyPath);
    internal static Assembly GetAlreadyLoadedAssembly(string assemblyNameLookup);
    private static Assembly LoadAssemblyHelper(string assemblyGivenName, string assemblyPath);
}
[EditorBrowsableAttribute("1")]
[BrowsableAttribute("False")]
public class System.Windows.Markup.ServiceProviders : object {
    private Dictionary`2<Type, object> _objDict;
    public sealed virtual object GetService(Type serviceType);
    public void AddService(Type serviceType, object service);
}
internal static class System.Windows.Markup.TypeConverterHelper : object {
    private static CultureInfo invariantEnglishUS;
    internal static CultureInfo InvariantEnglishUS { get; }
    private static TypeConverterHelper();
    internal static CultureInfo get_InvariantEnglishUS();
    internal static MemberInfo GetMemberInfoForPropertyConverter(object dpOrPiOrMi);
    internal static Type GetConverterType(MemberInfo memberInfo);
    internal static Type GetConverterType(Type type);
    private static Type GetConverterTypeFromName(string converterName);
    internal static Type GetCoreConverterTypeFromCustomType(Type type);
    private static TypeConverter GetCoreConverterFromCoreType(Type type);
    internal static TypeConverter GetCoreConverterFromCustomType(Type type);
    internal static TypeConverter GetTypeConverter(Type type);
}
internal class System.Windows.Markup.TypeTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Markup.XmlCompatibilityReader : XmlWrappingReader {
    private bool _inAttribute;
    private string _currentName;
    private IsXmlNamespaceSupportedCallback _namespaceCallback;
    private Dictionary`2<string, object> _knownNamespaces;
    private Dictionary`2<string, string> _namespaceMap;
    private Dictionary`2<string, object> _subsumingNamespaces;
    private Dictionary`2<string, HandleElementCallback> _elementHandler;
    private Dictionary`2<string, HandleAttributeCallback> _attributeHandler;
    private int _depthOffset;
    private int _ignoredAttributeCount;
    private int _attributePosition;
    private string _compatibilityUri;
    private string _alternateContent;
    private string _choice;
    private string _fallback;
    private string _requires;
    private string _ignorable;
    private string _mustUnderstand;
    private string _processContent;
    private string _preserveElements;
    private string _preserveAttributes;
    private CompatibilityScope _compatibilityScope;
    private bool isPreviousElementEmpty;
    private int previousElementDepth;
    private static string XmlnsDeclaration;
    private static string MarkupCompatibilityURI;
    private static String[] _predefinedNamespaces;
    public string Value { get; }
    public string NamespaceURI { get; }
    public int Depth { get; }
    public bool HasAttributes { get; }
    public int AttributeCount { get; }
    unknown bool Normalization {public set; }
    internal Encoding Encoding { get; }
    private CompatibilityScope Scope { get; }
    private string AlternateContent { get; }
    private string Choice { get; }
    private string Fallback { get; }
    private string Requires { get; }
    private string Ignorable { get; }
    private string MustUnderstand { get; }
    private string ProcessContent { get; }
    private string PreserveElements { get; }
    private string PreserveAttributes { get; }
    private string CompatibilityUri { get; }
    public XmlCompatibilityReader(XmlReader baseReader);
    public XmlCompatibilityReader(XmlReader baseReader, IsXmlNamespaceSupportedCallback isXmlNamespaceSupported);
    public XmlCompatibilityReader(XmlReader baseReader, IsXmlNamespaceSupportedCallback isXmlNamespaceSupported, IEnumerable`1<string> supportedNamespaces);
    public XmlCompatibilityReader(XmlReader baseReader, IEnumerable`1<string> supportedNamespaces);
    private static XmlCompatibilityReader();
    public void DeclareNamespaceCompatibility(string newNamespace, string oldNamespace);
    public virtual bool Read();
    private bool ReadStartElement(Boolean& more);
    private bool ReadEndElement(Boolean& more);
    public virtual string GetAttribute(int i);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string localName, string namespaceURI);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual string LookupNamespace(string prefix);
    public virtual string get_Value();
    public virtual string get_NamespaceURI();
    public virtual int get_Depth();
    public virtual bool get_HasAttributes();
    public virtual int get_AttributeCount();
    public void set_Normalization(bool value);
    internal Encoding get_Encoding();
    private void SaveReaderPosition();
    private void RestoreReaderPosition();
    private string GetMappedNamespace(string namespaceName);
    private string MapNewNamespace(string namespaceName);
    private bool IsSubsumingNamespace(string namespaceName);
    private void AddSubsumingNamespace(string namespaceName);
    private bool IsNamespaceKnown(string namespaceName);
    private void AddKnownNamespace(string namespaceName);
    private bool ShouldIgnoreNamespace(string namespaceName);
    [IteratorStateMachineAttribute("System.Windows.Markup.XmlCompatibilityReader/<ParseContentToNamespaceElementPair>d__40")]
private IEnumerable`1<NamespaceElementPair> ParseContentToNamespaceElementPair(string content, string callerContext);
    [IteratorStateMachineAttribute("System.Windows.Markup.XmlCompatibilityReader/<PrefixesToNamespaces>d__41")]
private IEnumerable`1<string> PrefixesToNamespaces(string prefixes);
    private bool SkipToKnownAttribute();
    private void ScanForCompatibility(int elementDepth);
    private void ScanForEndCompatibility(int elementDepth);
    private void PushScope(int elementDepth);
    private void PopScope();
    private void HandleAlternateContent(int elementDepth, Boolean& more);
    private void HandleChoice(int elementDepth, Boolean& more);
    private void HandleFallback(int elementDepth, Boolean& more);
    private void HandleIgnorable(int elementDepth);
    private void HandleMustUnderstand(int elementDepth);
    private void HandleProcessContent(int elementDepth);
    private void HandlePreserveElements(int elementDepth);
    private void HandlePreserveAttributes(int elementDepth);
    private void Error(string message, Object[] args);
    private CompatibilityScope get_Scope();
    private string get_AlternateContent();
    private string get_Choice();
    private string get_Fallback();
    private string get_Requires();
    private string get_Ignorable();
    private string get_MustUnderstand();
    private string get_ProcessContent();
    private string get_PreserveElements();
    private string get_PreserveAttributes();
    private string get_CompatibilityUri();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Markup.XmlWrappingReader : XmlReader {
    protected XmlReader _reader;
    protected IXmlLineInfo _readerAsIXmlLineInfo;
    protected IXmlNamespaceResolver _readerAsResolver;
    public XmlReaderSettings Settings { get; }
    public XmlNodeType NodeType { get; }
    public string Name { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Prefix { get; }
    public bool HasValue { get; }
    public string Value { get; }
    public int Depth { get; }
    public string BaseURI { get; }
    public bool IsEmptyElement { get; }
    public bool IsDefault { get; }
    public char QuoteChar { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public Type ValueType { get; }
    public int AttributeCount { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public bool CanResolveEntity { get; }
    public bool EOF { get; }
    public ReadState ReadState { get; }
    public bool HasAttributes { get; }
    public XmlNameTable NameTable { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    protected XmlReader Reader { get; protected set; }
    internal XmlWrappingReader(XmlReader baseReader);
    public virtual XmlReaderSettings get_Settings();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Name();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Prefix();
    public virtual bool get_HasValue();
    public virtual string get_Value();
    public virtual int get_Depth();
    public virtual string get_BaseURI();
    public virtual bool get_IsEmptyElement();
    public virtual bool get_IsDefault();
    public virtual char get_QuoteChar();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual Type get_ValueType();
    public virtual int get_AttributeCount();
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public virtual bool get_CanResolveEntity();
    public virtual bool get_EOF();
    public virtual ReadState get_ReadState();
    public virtual bool get_HasAttributes();
    public virtual XmlNameTable get_NameTable();
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string GetAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToElement();
    public virtual bool Read();
    public virtual void Close();
    public virtual void Skip();
    public virtual string LookupNamespace(string prefix);
    private sealed virtual override string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName);
    private sealed virtual override IDictionary`2<string, string> System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope);
    public virtual void ResolveEntity();
    public virtual bool ReadAttributeValue();
    protected virtual void Dispose(bool disposing);
    public virtual bool HasLineInfo();
    public virtual int get_LineNumber();
    public virtual int get_LinePosition();
    protected XmlReader get_Reader();
    protected void set_Reader(XmlReader value);
}
public class System.Windows.Media.Converters.MatrixValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[AttributeUsageAttribute("1")]
public class System.Windows.Media.DisableDpiAwarenessAttribute : Attribute {
}
[TypeConverterAttribute("System.Windows.Media.MatrixConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.MatrixValueSerializer")]
public class System.Windows.Media.Matrix : ValueType {
    private static Matrix s_identity;
    private static int c_identityHashCode;
    internal double _m11;
    internal double _m12;
    internal double _m21;
    internal double _m22;
    internal double _offsetX;
    internal double _offsetY;
    internal MatrixTypes _type;
    internal int _padding;
    public static Matrix Identity { get; }
    public bool IsIdentity { get; }
    public double Determinant { get; }
    public bool HasInverse { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    private bool IsDistinguishedIdentity { get; }
    public Matrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    private static Matrix();
    public static Matrix get_Identity();
    public void SetIdentity();
    public bool get_IsIdentity();
    public static Matrix op_Multiply(Matrix trans1, Matrix trans2);
    public static Matrix Multiply(Matrix trans1, Matrix trans2);
    public void Append(Matrix matrix);
    public void Prepend(Matrix matrix);
    public void Rotate(double angle);
    public void RotatePrepend(double angle);
    public void RotateAt(double angle, double centerX, double centerY);
    public void RotateAtPrepend(double angle, double centerX, double centerY);
    public void Scale(double scaleX, double scaleY);
    public void ScalePrepend(double scaleX, double scaleY);
    public void ScaleAt(double scaleX, double scaleY, double centerX, double centerY);
    public void ScaleAtPrepend(double scaleX, double scaleY, double centerX, double centerY);
    public void Skew(double skewX, double skewY);
    public void SkewPrepend(double skewX, double skewY);
    public void Translate(double offsetX, double offsetY);
    public void TranslatePrepend(double offsetX, double offsetY);
    public Point Transform(Point point);
    public void Transform(Point[] points);
    public Vector Transform(Vector vector);
    public void Transform(Vector[] vectors);
    public double get_Determinant();
    public bool get_HasInverse();
    public void Invert();
    public double get_M11();
    public void set_M11(double value);
    public double get_M12();
    public void set_M12(double value);
    public double get_M21();
    public void set_M21(double value);
    public double get_M22();
    public void set_M22(double value);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    internal void MultiplyVector(Double& x, Double& y);
    internal void MultiplyPoint(Double& x, Double& y);
    internal static Matrix CreateRotationRadians(double angle);
    internal static Matrix CreateRotationRadians(double angle, double centerX, double centerY);
    internal static Matrix CreateScaling(double scaleX, double scaleY, double centerX, double centerY);
    internal static Matrix CreateScaling(double scaleX, double scaleY);
    internal static Matrix CreateSkewRadians(double skewX, double skewY);
    internal static Matrix CreateTranslation(double offsetX, double offsetY);
    private static Matrix CreateIdentity();
    private void SetMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY, MatrixTypes type);
    private void DeriveMatrixType();
    [ConditionalAttribute("DEBUG")]
private void Debug_CheckType();
    private bool get_IsDistinguishedIdentity();
    public static bool op_Equality(Matrix matrix1, Matrix matrix2);
    public static bool op_Inequality(Matrix matrix1, Matrix matrix2);
    public static bool Equals(Matrix matrix1, Matrix matrix2);
    public virtual bool Equals(object o);
    public bool Equals(Matrix value);
    public virtual int GetHashCode();
    public static Matrix Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.MatrixConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[TypeForwardedFromAttribute("PresentationCore, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
public enum System.Windows.Media.TextFormattingMode : Enum {
    public int value__;
    public static TextFormattingMode Ideal;
    public static TextFormattingMode Display;
}
[FriendAccessAllowedAttribute]
internal class System.Windows.ModifiedValue : object {
    private object _baseValue;
    private object _expressionValue;
    private object _animatedValue;
    private object _coercedValue;
    internal object BaseValue { get; internal set; }
    internal object ExpressionValue { get; internal set; }
    internal object AnimatedValue { get; internal set; }
    internal object CoercedValue { get; internal set; }
    internal object get_BaseValue();
    internal void set_BaseValue(object value);
    internal object get_ExpressionValue();
    internal void set_ExpressionValue(object value);
    internal object get_AnimatedValue();
    internal void set_AnimatedValue(object value);
    internal object get_CoercedValue();
    internal void set_CoercedValue(object value);
    internal void SetBaseValue(object value, bool useWeakReference);
}
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.NameScope : object {
    public static DependencyProperty NameScopeProperty;
    private HybridDictionary _nameMap;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    private static NameScope();
    public sealed virtual void RegisterName(string name, object scopedElement);
    public sealed virtual void UnregisterName(string name);
    public sealed virtual object FindName(string name);
    internal static INameScope NameScopeFromObject(object obj);
    public static void SetNameScope(DependencyObject dependencyObject, INameScope value);
    [DesignerSerializationVisibilityAttribute("0")]
public static INameScope GetNameScope(DependencyObject dependencyObject);
    private IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
}
[FriendAccessAllowedAttribute]
internal enum System.Windows.OperationType : Enum {
    public byte value__;
    public static OperationType Unknown;
    public static OperationType AddChild;
    public static OperationType RemoveChild;
    public static OperationType Inherit;
    public static OperationType ChangeMutableDefaultValue;
}
[TypeConverterAttribute("System.Windows.PointConverter")]
[ValueSerializerAttribute("System.Windows.Converters.PointValueSerializer")]
public class System.Windows.Point : ValueType {
    internal double _x;
    internal double _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Point(double x, double y);
    public static bool op_Equality(Point point1, Point point2);
    public static bool op_Inequality(Point point1, Point point2);
    public static bool Equals(Point point1, Point point2);
    public virtual bool Equals(object o);
    public bool Equals(Point value);
    public virtual int GetHashCode();
    public static Point Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public void Offset(double offsetX, double offsetY);
    public static Point op_Addition(Point point, Vector vector);
    public static Point Add(Point point, Vector vector);
    public static Point op_Subtraction(Point point, Vector vector);
    public static Point Subtract(Point point, Vector vector);
    public static Vector op_Subtraction(Point point1, Point point2);
    public static Vector Subtract(Point point1, Point point2);
    public static Point op_Multiply(Point point, Matrix matrix);
    public static Point Multiply(Point point, Matrix matrix);
    public static Size op_Explicit(Point point);
    public static Vector op_Explicit(Point point);
}
public class System.Windows.PointConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.PropertyChangedCallback : MulticastDelegate {
    public PropertyChangedCallback(object object, IntPtr method);
    public virtual void Invoke(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, DependencyPropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.PropertyMetadata : object {
    private static FreezeValueCallback _defaultFreezeValueCallback;
    private object _defaultValue;
    private PropertyChangedCallback _propertyChangedCallback;
    private CoerceValueCallback _coerceValueCallback;
    private FreezeValueCallback _freezeValueCallback;
    [FriendAccessAllowedAttribute]
internal MetadataFlags _flags;
    private static UncommonField`1<FrugalMapBase> _defaultValueFactoryCache;
    private static FrugalMapIterationCallback _removalCallback;
    private static FrugalMapIterationCallback _promotionCallback;
    public object DefaultValue { get; public set; }
    internal bool UsingDefaultValueFactory { get; }
    public PropertyChangedCallback PropertyChangedCallback { get; public set; }
    public CoerceValueCallback CoerceValueCallback { get; public set; }
    [FriendAccessAllowedAttribute]
internal GetReadOnlyValueCallback GetReadOnlyValueCallback { get; }
    [FriendAccessAllowedAttribute]
internal FreezeValueCallback FreezeValueCallback { get; internal set; }
    protected bool IsSealed { get; }
    internal bool IsDefaultValueModified { get; }
    internal bool IsInherited { get; internal set; }
    internal bool Sealed { get; internal set; }
    public PropertyMetadata(object defaultValue);
    public PropertyMetadata(PropertyChangedCallback propertyChangedCallback);
    public PropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback);
    public PropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    private static PropertyMetadata();
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal bool get_UsingDefaultValueFactory();
    [FriendAccessAllowedAttribute]
internal object GetDefaultValue(DependencyObject owner, DependencyProperty property);
    private object GetCachedDefaultValue(DependencyObject owner, DependencyProperty property);
    private void SetCachedDefaultValue(DependencyObject owner, DependencyProperty property, object value);
    internal void ClearCachedDefaultValue(DependencyObject owner, DependencyProperty property);
    internal static void PromoteAllCachedDefaultValues(DependencyObject owner);
    internal static void RemoveAllCachedDefaultValues(Freezable owner);
    private static void DefaultValueCacheRemovalCallback(ArrayList list, int key, object value);
    private static void DefaultValueCachePromotionCallback(ArrayList list, int key, object value);
    internal bool DefaultValueWasSet();
    public PropertyChangedCallback get_PropertyChangedCallback();
    public void set_PropertyChangedCallback(PropertyChangedCallback value);
    public CoerceValueCallback get_CoerceValueCallback();
    public void set_CoerceValueCallback(CoerceValueCallback value);
    internal virtual GetReadOnlyValueCallback get_GetReadOnlyValueCallback();
    internal FreezeValueCallback get_FreezeValueCallback();
    internal void set_FreezeValueCallback(FreezeValueCallback value);
    private static bool DefaultFreezeValueCallback(DependencyObject d, DependencyProperty dp, EntryIndex entryIndex, PropertyMetadata metadata, bool isChecking);
    internal virtual PropertyMetadata CreateInstance();
    internal PropertyMetadata Copy(DependencyProperty dp);
    protected virtual void Merge(PropertyMetadata baseMetadata, DependencyProperty dp);
    internal void InvokeMerge(PropertyMetadata baseMetadata, DependencyProperty dp);
    protected virtual void OnApply(DependencyProperty dp, Type targetType);
    protected bool get_IsSealed();
    internal void Seal(DependencyProperty dp, Type targetType);
    internal bool get_IsDefaultValueModified();
    internal bool get_IsInherited();
    internal void set_IsInherited(bool value);
    private void SetModified(MetadataFlags id);
    private bool IsModified(MetadataFlags id);
    [FriendAccessAllowedAttribute]
internal void WriteFlag(MetadataFlags id, bool value);
    [FriendAccessAllowedAttribute]
internal bool ReadFlag(MetadataFlags id);
    [FriendAccessAllowedAttribute]
internal bool get_Sealed();
    internal void set_Sealed(bool value);
}
[TypeConverterAttribute("System.Windows.RectConverter")]
[ValueSerializerAttribute("System.Windows.Converters.RectValueSerializer")]
public class System.Windows.Rect : ValueType {
    internal double _x;
    internal double _y;
    internal double _width;
    internal double _height;
    private static Rect s_empty;
    public static Rect Empty { get; }
    public bool IsEmpty { get; }
    public Point Location { get; public set; }
    public Size Size { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public Point TopLeft { get; }
    public Point TopRight { get; }
    public Point BottomLeft { get; }
    public Point BottomRight { get; }
    public Rect(Point location, Size size);
    public Rect(double x, double y, double width, double height);
    public Rect(Point point1, Point point2);
    public Rect(Point point, Vector vector);
    public Rect(Size size);
    private static Rect();
    public static bool op_Equality(Rect rect1, Rect rect2);
    public static bool op_Inequality(Rect rect1, Rect rect2);
    public static bool Equals(Rect rect1, Rect rect2);
    public virtual bool Equals(object o);
    public bool Equals(Rect value);
    public virtual int GetHashCode();
    public static Rect Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Rect get_Empty();
    public bool get_IsEmpty();
    public Point get_Location();
    public void set_Location(Point value);
    public Size get_Size();
    public void set_Size(Size value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public Point get_TopLeft();
    public Point get_TopRight();
    public Point get_BottomLeft();
    public Point get_BottomRight();
    public bool Contains(Point point);
    public bool Contains(double x, double y);
    public bool Contains(Rect rect);
    public bool IntersectsWith(Rect rect);
    public void Intersect(Rect rect);
    public static Rect Intersect(Rect rect1, Rect rect2);
    public void Union(Rect rect);
    public static Rect Union(Rect rect1, Rect rect2);
    public void Union(Point point);
    public static Rect Union(Rect rect, Point point);
    public void Offset(Vector offsetVector);
    public void Offset(double offsetX, double offsetY);
    public static Rect Offset(Rect rect, Vector offsetVector);
    public static Rect Offset(Rect rect, double offsetX, double offsetY);
    public void Inflate(Size size);
    public void Inflate(double width, double height);
    public static Rect Inflate(Rect rect, Size size);
    public static Rect Inflate(Rect rect, double width, double height);
    public static Rect Transform(Rect rect, Matrix matrix);
    public void Transform(Matrix matrix);
    public void Scale(double scaleX, double scaleY);
    private bool ContainsInternal(double x, double y);
    private static Rect CreateEmptyRect();
}
public class System.Windows.RectConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[FriendAccessAllowedAttribute]
internal enum System.Windows.RequestFlags : Enum {
    public int value__;
    public static RequestFlags FullyResolved;
    public static RequestFlags AnimationBaseValue;
    public static RequestFlags CoercionBaseValue;
    public static RequestFlags DeferredReferences;
    public static RequestFlags SkipDefault;
    public static RequestFlags RawEntry;
}
[TypeConverterAttribute("System.Windows.SizeConverter")]
[ValueSerializerAttribute("System.Windows.Converters.SizeValueSerializer")]
public class System.Windows.Size : ValueType {
    internal double _width;
    internal double _height;
    private static Size s_empty;
    public static Size Empty { get; }
    public bool IsEmpty { get; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public Size(double width, double height);
    private static Size();
    public static bool op_Equality(Size size1, Size size2);
    public static bool op_Inequality(Size size1, Size size2);
    public static bool Equals(Size size1, Size size2);
    public virtual bool Equals(object o);
    public bool Equals(Size value);
    public virtual int GetHashCode();
    public static Size Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Size get_Empty();
    public bool get_IsEmpty();
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public static Vector op_Explicit(Size size);
    public static Point op_Explicit(Size size);
    private static Size CreateEmptySize();
}
public class System.Windows.SizeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.SplashScreen : object {
    private IntPtr _hwnd;
    private string _resourceName;
    private IntPtr _hInstance;
    private BitmapHandle _hBitmap;
    private ushort _wndClass;
    private DispatcherTimer _dt;
    private TimeSpan _fadeoutDuration;
    private DateTime _fadeoutEnd;
    private BLENDFUNCTION _blendFunc;
    private ResourceManager _resourceManager;
    private Dispatcher _dispatcher;
    private static WndProc _defWndProc;
    private static string CLASSNAME;
    public SplashScreen(string resourceName);
    public SplashScreen(Assembly resourceAssembly, string resourceName);
    public void Show(bool autoClose);
    public void Show(bool autoClose, bool topMost);
    private UnmanagedMemoryStream GetResourceStream();
    private IntPtr CreateWindow(BitmapHandle hBitmap, int width, int height, bool topMost);
    public void Close(TimeSpan fadeoutDuration);
    private object CloseInternal(object fadeOutArg);
    private void Fadeout_Tick(object unused, EventArgs args);
    private void DestroyResources();
    private bool CreateLayeredWindowFromImgBuffer(IntPtr pImgBuffer, long cImgBufferLen, bool topMost);
}
public class System.Windows.Threading.Dispatcher : object {
    [CompilerGeneratedAttribute]
private EventHandler ShutdownStarted;
    [CompilerGeneratedAttribute]
private EventHandler ShutdownFinished;
    [CompilerGeneratedAttribute]
private DispatcherUnhandledExceptionEventHandler UnhandledException;
    private static int PROCESS_NONE;
    private static int PROCESS_BACKGROUND;
    private static int PROCESS_FOREGROUND;
    private static int TIMERID_BACKGROUND;
    private static int TIMERID_TIMERS;
    private static int DELTA_BACKGROUND;
    private static List`1<WeakReference> _dispatchers;
    private static WeakReference _possibleDispatcher;
    private static object _globalLock;
    [ThreadStaticAttribute]
private static Dispatcher _tlsDispatcher;
    private Thread _dispatcherThread;
    private int _frameDepth;
    internal bool _exitAllFrames;
    private bool _startingShutdown;
    internal bool _hasShutdownStarted;
    private SecurityCriticalDataClass`1<CulturePreservingExecutionContext> _shutdownExecutionContext;
    internal int _disableProcessingCount;
    private static PriorityRange _foregroundPriorityRange;
    private static PriorityRange _backgroundPriorityRange;
    private static PriorityRange _idlePriorityRange;
    private SecurityCriticalData`1<MessageOnlyHwndWrapper> _window;
    private HwndWrapperHook _hook;
    private int _postedProcessingType;
    private static WindowMessage _msgProcessQueue;
    private static ExceptionWrapper _exceptionWrapper;
    private static object ExceptionDataKey;
    private DispatcherUnhandledExceptionEventArgs _unhandledExceptionEventArgs;
    private DispatcherUnhandledExceptionFilterEventHandler _unhandledExceptionFilter;
    private DispatcherUnhandledExceptionFilterEventArgs _exceptionFilterEventArgs;
    private object _reserved0;
    private object _reserved1;
    private object _reserved2;
    private object _reserved3;
    private object _reserved4;
    private object _reservedPtsCache;
    private object _reservedInputMethod;
    private object _reservedInputManager;
    internal DispatcherSynchronizationContext _defaultDispatcherSynchronizationContext;
    internal object _instanceLock;
    private PriorityQueue`1<DispatcherOperation> _queue;
    private List`1<DispatcherTimer> _timers;
    private long _timersVersion;
    private bool _dueTimeFound;
    private int _dueTimeInTicks;
    private bool _isWin32TimerSet;
    private bool _hasShutdownFinished;
    private bool _isTSFMessagePumpEnabled;
    private bool _hasRequestProcessingFailed;
    private DispatcherHooks _hooks;
    public static Dispatcher CurrentDispatcher { get; }
    public Thread Thread { get; }
    public bool HasShutdownStarted { get; }
    public bool HasShutdownFinished { get; }
    [EditorBrowsableAttribute("2")]
public DispatcherHooks Hooks { get; }
    internal object Reserved0 { get; internal set; }
    internal object Reserved1 { get; internal set; }
    internal object Reserved2 { get; internal set; }
    internal object Reserved3 { get; internal set; }
    internal object Reserved4 { get; internal set; }
    internal object PtsCache { get; internal set; }
    internal object InputMethod { get; internal set; }
    internal object InputManager { get; internal set; }
    [FriendAccessAllowedAttribute]
unknown bool IsTSFMessagePumpEnabled {internal set; }
    private bool HasUnhandledExceptionHandler { get; }
    private static Dispatcher();
    internal Dispatcher(bool isSentinel);
    public static Dispatcher get_CurrentDispatcher();
    public static Dispatcher FromThread(Thread thread);
    public Thread get_Thread();
    [EditorBrowsableAttribute("1")]
public bool CheckAccess();
    [EditorBrowsableAttribute("1")]
public void VerifyAccess();
    public void BeginInvokeShutdown(DispatcherPriority priority);
    public void InvokeShutdown();
    [FriendAccessAllowedAttribute]
internal void CriticalInvokeShutdown();
    public bool get_HasShutdownStarted();
    public bool get_HasShutdownFinished();
    [CompilerGeneratedAttribute]
public void add_ShutdownStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ShutdownStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ShutdownFinished(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ShutdownFinished(EventHandler value);
    public static void Run();
    public static void PushFrame(DispatcherFrame frame);
    public static void ExitAllFrames();
    public static DispatcherPriorityAwaitable Yield();
    public static DispatcherPriorityAwaitable Yield(DispatcherPriority priority);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method, object arg, Object[] args);
    public DispatcherOperation BeginInvoke(Delegate method, Object[] args);
    public DispatcherOperation BeginInvoke(Delegate method, DispatcherPriority priority, Object[] args);
    public void Invoke(Action callback);
    public void Invoke(Action callback, DispatcherPriority priority);
    public void Invoke(Action callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public void Invoke(Action callback, DispatcherPriority priority, CancellationToken cancellationToken, TimeSpan timeout);
    public TResult Invoke(Func`1<TResult> callback);
    public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority);
    public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken, TimeSpan timeout);
    public DispatcherOperation InvokeAsync(Action callback);
    public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority);
    public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback);
    public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback, DispatcherPriority priority);
    public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken);
    private DispatcherOperation LegacyBeginInvokeImpl(DispatcherPriority priority, Delegate method, object args, int numArgs);
    private void InvokeAsyncImpl(DispatcherOperation operation, CancellationToken cancellationToken);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method, object arg, Object[] args);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, Object[] args);
    public object Invoke(Delegate method, Object[] args);
    public object Invoke(Delegate method, DispatcherPriority priority, Object[] args);
    public object Invoke(Delegate method, TimeSpan timeout, Object[] args);
    public object Invoke(Delegate method, TimeSpan timeout, DispatcherPriority priority, Object[] args);
    internal object LegacyInvokeImpl(DispatcherPriority priority, TimeSpan timeout, Delegate method, object args, int numArgs);
    private object InvokeImpl(DispatcherOperation operation, CancellationToken cancellationToken, TimeSpan timeout);
    public DispatcherProcessingDisabled DisableProcessing();
    public static void ValidatePriority(DispatcherPriority priority, string parameterName);
    public DispatcherHooks get_Hooks();
    public void add_UnhandledExceptionFilter(DispatcherUnhandledExceptionFilterEventHandler value);
    public void remove_UnhandledExceptionFilter(DispatcherUnhandledExceptionFilterEventHandler value);
    [CompilerGeneratedAttribute]
public void add_UnhandledException(DispatcherUnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(DispatcherUnhandledExceptionEventHandler value);
    [FriendAccessAllowedAttribute]
internal object get_Reserved0();
    [FriendAccessAllowedAttribute]
internal void set_Reserved0(object value);
    [FriendAccessAllowedAttribute]
internal object get_Reserved1();
    [FriendAccessAllowedAttribute]
internal void set_Reserved1(object value);
    [FriendAccessAllowedAttribute]
internal object get_Reserved2();
    [FriendAccessAllowedAttribute]
internal void set_Reserved2(object value);
    [FriendAccessAllowedAttribute]
internal object get_Reserved3();
    [FriendAccessAllowedAttribute]
internal void set_Reserved3(object value);
    [FriendAccessAllowedAttribute]
internal object get_Reserved4();
    [FriendAccessAllowedAttribute]
internal void set_Reserved4(object value);
    [FriendAccessAllowedAttribute]
internal object get_PtsCache();
    [FriendAccessAllowedAttribute]
internal void set_PtsCache(object value);
    [FriendAccessAllowedAttribute]
internal object get_InputMethod();
    [FriendAccessAllowedAttribute]
internal void set_InputMethod(object value);
    [FriendAccessAllowedAttribute]
internal object get_InputManager();
    [FriendAccessAllowedAttribute]
internal void set_InputManager(object value);
    private void StartShutdownImpl();
    private void ShutdownImpl();
    private void ShutdownImplInSecurityContext(object state);
    internal bool SetPriority(DispatcherOperation operation, DispatcherPriority priority);
    internal bool Abort(DispatcherOperation operation);
    private void ProcessQueue();
    private void ShutdownCallbackInternal();
    private void PushFrameImpl(DispatcherFrame frame);
    private bool GetMessage(MSG& msg, IntPtr hwnd, int minMessage, int maxMessage);
    private ITfMessagePump GetMessagePump();
    internal void set_IsTSFMessagePumpEnabled(bool value);
    private void TranslateAndDispatchMessage(MSG& msg);
    private IntPtr WndProcHook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private bool IsInputPending();
    private bool RequestProcessing();
    internal bool CriticalRequestProcessing(bool force);
    private bool IsWindowNull();
    private bool RequestForegroundProcessing();
    private bool RequestBackgroundProcessing();
    private void OnRequestProcessingFailure(string methodName);
    internal void PromoteTimers(int currentTimeInTicks);
    internal void AddTimer(DispatcherTimer timer);
    internal void RemoveTimer(DispatcherTimer timer);
    internal void UpdateWin32Timer();
    private object UpdateWin32TimerFromDispatcherThread(object unused);
    private void SetWin32Timer(int dueTimeInTicks);
    private void KillWin32Timer();
    private static bool ExceptionFilterStatic(object source, Exception e);
    private bool ExceptionFilter(Exception e);
    private static bool CatchExceptionStatic(object source, Exception e);
    private bool CatchException(Exception e);
    private bool get_HasUnhandledExceptionHandler();
    [FriendAccessAllowedAttribute]
internal object WrappedInvoke(Delegate callback, object args, int numArgs, Delegate catchHandler);
    private Object[] CombineParameters(object arg, Object[] args);
    [CompilerGeneratedAttribute]
[DoesNotReturnAttribute]
internal static void <VerifyAccess>g__ThrowVerifyAccess|7_0();
}
public class System.Windows.Threading.DispatcherEventArgs : EventArgs {
    private Dispatcher _dispatcher;
    public Dispatcher Dispatcher { get; }
    internal DispatcherEventArgs(Dispatcher dispatcher);
    public Dispatcher get_Dispatcher();
}
public class System.Windows.Threading.DispatcherFrame : DispatcherObject {
    private bool _exitWhenRequested;
    private bool _continue;
    public bool Continue { get; public set; }
    private static DispatcherFrame();
    public DispatcherFrame(bool exitWhenRequested);
    public bool get_Continue();
    public void set_Continue(bool value);
}
public class System.Windows.Threading.DispatcherHookEventArgs : EventArgs {
    private DispatcherOperation _operation;
    public Dispatcher Dispatcher { get; }
    public DispatcherOperation Operation { get; }
    public DispatcherHookEventArgs(DispatcherOperation operation);
    public Dispatcher get_Dispatcher();
    public DispatcherOperation get_Operation();
}
public class System.Windows.Threading.DispatcherHookEventHandler : MulticastDelegate {
    public DispatcherHookEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherHookEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherHookEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Threading.DispatcherHooks : object {
    private object _instanceLock;
    private EventHandler _dispatcherInactive;
    private DispatcherHookEventHandler _operationPosted;
    private DispatcherHookEventHandler _operationStarted;
    private DispatcherHookEventHandler _operationCompleted;
    private DispatcherHookEventHandler _operationPriorityChanged;
    private DispatcherHookEventHandler _operationAborted;
    public void add_DispatcherInactive(EventHandler value);
    public void remove_DispatcherInactive(EventHandler value);
    public void add_OperationPosted(DispatcherHookEventHandler value);
    public void remove_OperationPosted(DispatcherHookEventHandler value);
    public void add_OperationStarted(DispatcherHookEventHandler value);
    public void remove_OperationStarted(DispatcherHookEventHandler value);
    public void add_OperationCompleted(DispatcherHookEventHandler value);
    public void remove_OperationCompleted(DispatcherHookEventHandler value);
    public void add_OperationPriorityChanged(DispatcherHookEventHandler value);
    public void remove_OperationPriorityChanged(DispatcherHookEventHandler value);
    public void add_OperationAborted(DispatcherHookEventHandler value);
    public void remove_OperationAborted(DispatcherHookEventHandler value);
    internal void RaiseDispatcherInactive(Dispatcher dispatcher);
    internal void RaiseOperationPosted(Dispatcher dispatcher, DispatcherOperation operation);
    internal void RaiseOperationStarted(Dispatcher dispatcher, DispatcherOperation operation);
    internal void RaiseOperationCompleted(Dispatcher dispatcher, DispatcherOperation operation);
    internal void RaiseOperationPriorityChanged(Dispatcher dispatcher, DispatcherOperation operation);
    internal void RaiseOperationAborted(Dispatcher dispatcher, DispatcherOperation operation);
}
public abstract class System.Windows.Threading.DispatcherObject : object {
    private Dispatcher _dispatcher;
    private static Dispatcher _sentinelDispatcher;
    [EditorBrowsableAttribute("2")]
public Dispatcher Dispatcher { get; }
    public Dispatcher get_Dispatcher();
    [FriendAccessAllowedAttribute]
internal void DetachFromDispatcher();
    [FriendAccessAllowedAttribute]
internal void MakeSentinel();
    private static Dispatcher EnsureSentinelDispatcher();
    [EditorBrowsableAttribute("1")]
public bool CheckAccess();
    [EditorBrowsableAttribute("1")]
public void VerifyAccess();
}
public class System.Windows.Threading.DispatcherOperation : object {
    private CulturePreservingExecutionContext _executionContext;
    private static ContextCallback _invokeInSecurityContext;
    private Dispatcher _dispatcher;
    private DispatcherPriority _priority;
    internal Delegate _method;
    private object _args;
    private int _numArgs;
    internal DispatcherOperationStatus _status;
    private object _result;
    private Exception _exception;
    internal PriorityItem`1<DispatcherOperation> _item;
    private EventHandler _aborted;
    private EventHandler _completed;
    internal DispatcherOperationTaskSource _taskSource;
    private bool _useAsyncSemantics;
    public Dispatcher Dispatcher { get; }
    public DispatcherPriority Priority { get; public set; }
    public DispatcherOperationStatus Status { get; }
    public Task Task { get; }
    internal string Name { get; }
    internal long Id { get; }
    public object Result { get; }
    private object DispatcherLock { get; }
    private static DispatcherOperation();
    internal DispatcherOperation(Dispatcher dispatcher, Delegate method, DispatcherPriority priority, object args, int numArgs, DispatcherOperationTaskSource taskSource, bool useAsyncSemantics);
    internal DispatcherOperation(Dispatcher dispatcher, Delegate method, DispatcherPriority priority, object args, int numArgs);
    internal DispatcherOperation(Dispatcher dispatcher, DispatcherPriority priority, Action action);
    internal DispatcherOperation(Dispatcher dispatcher, DispatcherPriority priority, Delegate method, Object[] args);
    public Dispatcher get_Dispatcher();
    public DispatcherPriority get_Priority();
    public void set_Priority(DispatcherPriority value);
    public DispatcherOperationStatus get_Status();
    public Task get_Task();
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public TaskAwaiter GetAwaiter();
    public DispatcherOperationStatus Wait();
    public DispatcherOperationStatus Wait(TimeSpan timeout);
    public bool Abort();
    internal string get_Name();
    internal long get_Id();
    public object get_Result();
    public void add_Aborted(EventHandler value);
    public void remove_Aborted(EventHandler value);
    public void add_Completed(EventHandler value);
    public void remove_Completed(EventHandler value);
    internal void Invoke();
    internal void InvokeCompletions();
    private static void InvokeInSecurityContext(object state);
    private void InvokeImpl();
    protected virtual object InvokeDelegateCore();
    private object get_DispatcherLock();
}
public class System.Windows.Threading.DispatcherOperation`1 : DispatcherOperation {
    public Task`1<TResult> Task { get; }
    public TResult Result { get; }
    internal DispatcherOperation`1(Dispatcher dispatcher, DispatcherPriority priority, Func`1<TResult> func);
    public Task`1<TResult> get_Task();
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public TaskAwaiter`1<TResult> GetAwaiter();
    public TResult get_Result();
    protected virtual object InvokeDelegateCore();
}
public class System.Windows.Threading.DispatcherOperationCallback : MulticastDelegate {
    public DispatcherOperationCallback(object object, IntPtr method);
    public virtual object Invoke(object arg);
    public virtual IAsyncResult BeginInvoke(object arg, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public enum System.Windows.Threading.DispatcherOperationStatus : Enum {
    public int value__;
    public static DispatcherOperationStatus Pending;
    public static DispatcherOperationStatus Aborted;
    public static DispatcherOperationStatus Completed;
    public static DispatcherOperationStatus Executing;
}
internal class System.Windows.Threading.DispatcherOperationTaskMapping : object {
    [CompilerGeneratedAttribute]
private DispatcherOperation <Operation>k__BackingField;
    public DispatcherOperation Operation { get; private set; }
    public DispatcherOperationTaskMapping(DispatcherOperation operation);
    [CompilerGeneratedAttribute]
public DispatcherOperation get_Operation();
    [CompilerGeneratedAttribute]
private void set_Operation(DispatcherOperation value);
}
internal abstract class System.Windows.Threading.DispatcherOperationTaskSource : object {
    public abstract virtual void Initialize(DispatcherOperation operation);
    public abstract virtual Task GetTask();
    public abstract virtual void SetCanceled();
    public abstract virtual void SetResult(object result);
    public abstract virtual void SetException(Exception exception);
}
internal class System.Windows.Threading.DispatcherOperationTaskSource`1 : DispatcherOperationTaskSource {
    private TaskCompletionSource`1<TResult> _taskCompletionSource;
    public virtual void Initialize(DispatcherOperation operation);
    public virtual Task GetTask();
    public virtual void SetCanceled();
    public virtual void SetResult(object result);
    public virtual void SetException(Exception exception);
}
public enum System.Windows.Threading.DispatcherPriority : Enum {
    public int value__;
    public static DispatcherPriority Invalid;
    public static DispatcherPriority Inactive;
    public static DispatcherPriority SystemIdle;
    public static DispatcherPriority ApplicationIdle;
    public static DispatcherPriority ContextIdle;
    public static DispatcherPriority Background;
    public static DispatcherPriority Input;
    public static DispatcherPriority Loaded;
    public static DispatcherPriority Render;
    public static DispatcherPriority DataBind;
    public static DispatcherPriority Normal;
    public static DispatcherPriority Send;
}
public class System.Windows.Threading.DispatcherPriorityAwaitable : ValueType {
    private Dispatcher _dispatcher;
    private DispatcherPriority _priority;
    internal DispatcherPriorityAwaitable(Dispatcher dispatcher, DispatcherPriority priority);
    public DispatcherPriorityAwaiter GetAwaiter();
}
public class System.Windows.Threading.DispatcherPriorityAwaiter : ValueType {
    private Dispatcher _dispatcher;
    private DispatcherPriority _priority;
    public bool IsCompleted { get; }
    internal DispatcherPriorityAwaiter(Dispatcher dispatcher, DispatcherPriority priority);
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
}
public class System.Windows.Threading.DispatcherProcessingDisabled : ValueType {
    internal Dispatcher _dispatcher;
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DispatcherProcessingDisabled left, DispatcherProcessingDisabled right);
    public static bool op_Inequality(DispatcherProcessingDisabled left, DispatcherProcessingDisabled right);
}
public class System.Windows.Threading.DispatcherSynchronizationContext : SynchronizationContext {
    internal Dispatcher _dispatcher;
    private DispatcherPriority _priority;
    public DispatcherSynchronizationContext(Dispatcher dispatcher);
    public DispatcherSynchronizationContext(Dispatcher dispatcher, DispatcherPriority priority);
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    public virtual SynchronizationContext CreateCopy();
}
public class System.Windows.Threading.DispatcherTimer : object {
    [CompilerGeneratedAttribute]
private EventHandler Tick;
    private object _instanceLock;
    private Dispatcher _dispatcher;
    private DispatcherPriority _priority;
    private TimeSpan _interval;
    private object _tag;
    private DispatcherOperation _operation;
    private bool _isEnabled;
    internal int _dueTimeInTicks;
    public Dispatcher Dispatcher { get; }
    public bool IsEnabled { get; public set; }
    public TimeSpan Interval { get; public set; }
    public object Tag { get; public set; }
    public DispatcherTimer(DispatcherPriority priority);
    public DispatcherTimer(DispatcherPriority priority, Dispatcher dispatcher);
    public DispatcherTimer(TimeSpan interval, DispatcherPriority priority, EventHandler callback, Dispatcher dispatcher);
    public Dispatcher get_Dispatcher();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public TimeSpan get_Interval();
    public void set_Interval(TimeSpan value);
    public void Start();
    public void Stop();
    [CompilerGeneratedAttribute]
public void add_Tick(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Tick(EventHandler value);
    public object get_Tag();
    public void set_Tag(object value);
    private void Initialize(Dispatcher dispatcher, DispatcherPriority priority, TimeSpan interval);
    private void Restart();
    internal void Promote();
    private object FireTick();
}
public class System.Windows.Threading.DispatcherUnhandledExceptionEventArgs : DispatcherEventArgs {
    private Exception _exception;
    private bool _handled;
    public Exception Exception { get; }
    public bool Handled { get; public set; }
    internal DispatcherUnhandledExceptionEventArgs(Dispatcher dispatcher);
    public Exception get_Exception();
    public bool get_Handled();
    public void set_Handled(bool value);
    internal void Initialize(Exception exception, bool handled);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler : MulticastDelegate {
    public DispatcherUnhandledExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherUnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherUnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs : DispatcherEventArgs {
    private Exception _exception;
    private bool _requestCatch;
    public Exception Exception { get; }
    public bool RequestCatch { get; public set; }
    internal DispatcherUnhandledExceptionFilterEventArgs(Dispatcher dispatcher);
    public Exception get_Exception();
    public bool get_RequestCatch();
    public void set_RequestCatch(bool value);
    internal void Initialize(Exception exception, bool requestCatch);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler : MulticastDelegate {
    public DispatcherUnhandledExceptionFilterEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherUnhandledExceptionFilterEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherUnhandledExceptionFilterEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Threading.ExceptionWrapper : object {
    [CompilerGeneratedAttribute]
private CatchHandler Catch;
    [CompilerGeneratedAttribute]
private FilterHandler Filter;
    public object TryCatchWhen(object source, Delegate callback, object args, int numArgs, Delegate catchHandler);
    private object InternalRealCall(Delegate callback, object args, int numArgs);
    private bool FilterException(object source, Exception e);
    private bool CatchException(object source, Exception e, Delegate catchHandler);
    [CompilerGeneratedAttribute]
public void add_Catch(CatchHandler value);
    [CompilerGeneratedAttribute]
public void remove_Catch(CatchHandler value);
    [CompilerGeneratedAttribute]
public void add_Filter(FilterHandler value);
    [CompilerGeneratedAttribute]
public void remove_Filter(FilterHandler value);
}
internal class System.Windows.Threading.PriorityChain`1 : object {
    private PriorityItem`1<T> _head;
    private PriorityItem`1<T> _tail;
    private DispatcherPriority _priority;
    private int _count;
    public DispatcherPriority Priority { get; public set; }
    public int Count { get; public set; }
    public PriorityItem`1<T> Head { get; public set; }
    public PriorityItem`1<T> Tail { get; public set; }
    public PriorityChain`1(DispatcherPriority priority);
    public DispatcherPriority get_Priority();
    public void set_Priority(DispatcherPriority value);
    public int get_Count();
    public void set_Count(int value);
    public PriorityItem`1<T> get_Head();
    public void set_Head(PriorityItem`1<T> value);
    public PriorityItem`1<T> get_Tail();
    public void set_Tail(PriorityItem`1<T> value);
}
internal class System.Windows.Threading.PriorityItem`1 : object {
    private T _data;
    private PriorityItem`1<T> _sequentialPrev;
    private PriorityItem`1<T> _sequentialNext;
    private PriorityChain`1<T> _chain;
    private PriorityItem`1<T> _priorityPrev;
    private PriorityItem`1<T> _priorityNext;
    public T Data { get; }
    public bool IsQueued { get; }
    internal PriorityItem`1<T> SequentialPrev { get; internal set; }
    internal PriorityItem`1<T> SequentialNext { get; internal set; }
    internal PriorityChain`1<T> Chain { get; internal set; }
    internal PriorityItem`1<T> PriorityPrev { get; internal set; }
    internal PriorityItem`1<T> PriorityNext { get; internal set; }
    public PriorityItem`1(T data);
    public T get_Data();
    public bool get_IsQueued();
    internal PriorityItem`1<T> get_SequentialPrev();
    internal void set_SequentialPrev(PriorityItem`1<T> value);
    internal PriorityItem`1<T> get_SequentialNext();
    internal void set_SequentialNext(PriorityItem`1<T> value);
    internal PriorityChain`1<T> get_Chain();
    internal void set_Chain(PriorityChain`1<T> value);
    internal PriorityItem`1<T> get_PriorityPrev();
    internal void set_PriorityPrev(PriorityItem`1<T> value);
    internal PriorityItem`1<T> get_PriorityNext();
    internal void set_PriorityNext(PriorityItem`1<T> value);
}
internal class System.Windows.Threading.PriorityQueue`1 : object {
    private SortedList`2<int, PriorityChain`1<T>> _priorityChains;
    private Stack`1<PriorityChain`1<T>> _cacheReusableChains;
    private PriorityItem`1<T> _head;
    private PriorityItem`1<T> _tail;
    private int _count;
    public DispatcherPriority MaxPriority { get; }
    public DispatcherPriority get_MaxPriority();
    public PriorityItem`1<T> Enqueue(DispatcherPriority priority, T data);
    public T Dequeue();
    public T Peek();
    public void RemoveItem(PriorityItem`1<T> item);
    public void ChangeItemPriority(PriorityItem`1<T> item, DispatcherPriority priority);
    private PriorityChain`1<T> GetChain(DispatcherPriority priority);
    private void InsertItemInPriorityChain(PriorityItem`1<T> item, PriorityChain`1<T> chain);
    internal void InsertItemInPriorityChain(PriorityItem`1<T> item, PriorityChain`1<T> chain, PriorityItem`1<T> after);
    private void RemoveItemFromPriorityChain(PriorityItem`1<T> item);
    internal void InsertItemInSequentialChain(PriorityItem`1<T> item, PriorityItem`1<T> after);
    private void RemoveItemFromSequentialChain(PriorityItem`1<T> item);
}
internal class System.Windows.Threading.PriorityRange : ValueType {
    public static PriorityRange All;
    public static PriorityRange None;
    private DispatcherPriority _min;
    private bool _isMinInclusive;
    private DispatcherPriority _max;
    private bool _isMaxInclusive;
    public DispatcherPriority Min { get; }
    public DispatcherPriority Max { get; }
    public bool IsMinInclusive { get; }
    public bool IsMaxInclusive { get; }
    public bool IsValid { get; }
    public PriorityRange(DispatcherPriority min, DispatcherPriority max);
    public PriorityRange(DispatcherPriority min, bool isMinInclusive, DispatcherPriority max, bool isMaxInclusive);
    private PriorityRange(DispatcherPriority min, DispatcherPriority max, bool ignored);
    private static PriorityRange();
    public DispatcherPriority get_Min();
    public DispatcherPriority get_Max();
    public bool get_IsMinInclusive();
    public bool get_IsMaxInclusive();
    public bool get_IsValid();
    public bool Contains(DispatcherPriority priority);
    public bool Contains(PriorityRange priorityRange);
    public virtual bool Equals(object o);
    public bool Equals(PriorityRange priorityRange);
    public static bool op_Equality(PriorityRange priorityRange1, PriorityRange priorityRange2);
    public static bool op_Inequality(PriorityRange priorityRange1, PriorityRange priorityRange2);
    public virtual int GetHashCode();
    private void Initialize(DispatcherPriority min, bool isMinInclusive, DispatcherPriority max, bool isMaxInclusive);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.UncommonField`1 : object {
    private T _defaultValue;
    private int _globalIndex;
    private bool _hasBeenSet;
    internal int GlobalIndex { get; }
    public UncommonField`1(T defaultValue);
    public void SetValue(DependencyObject instance, T value);
    public T GetValue(DependencyObject instance);
    public void ClearValue(DependencyObject instance);
    internal int get_GlobalIndex();
}
[FriendAccessAllowedAttribute]
internal enum System.Windows.UpdateResult : Enum {
    public int value__;
    public static UpdateResult ValueChanged;
    public static UpdateResult NotificationSent;
    public static UpdateResult InheritedValueOverridden;
}
public class System.Windows.ValidateValueCallback : MulticastDelegate {
    public ValidateValueCallback(object object, IntPtr method);
    public virtual bool Invoke(object value);
    public virtual IAsyncResult BeginInvoke(object value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.VectorConverter")]
[ValueSerializerAttribute("System.Windows.Converters.VectorValueSerializer")]
public class System.Windows.Vector : ValueType {
    internal double _x;
    internal double _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Length { get; }
    public double LengthSquared { get; }
    public Vector(double x, double y);
    public static bool op_Equality(Vector vector1, Vector vector2);
    public static bool op_Inequality(Vector vector1, Vector vector2);
    public static bool Equals(Vector vector1, Vector vector2);
    public virtual bool Equals(object o);
    public bool Equals(Vector value);
    public virtual int GetHashCode();
    public static Vector Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public double get_Length();
    public double get_LengthSquared();
    public void Normalize();
    public static double CrossProduct(Vector vector1, Vector vector2);
    public static double AngleBetween(Vector vector1, Vector vector2);
    public static Vector op_UnaryNegation(Vector vector);
    public void Negate();
    public static Vector op_Addition(Vector vector1, Vector vector2);
    public static Vector Add(Vector vector1, Vector vector2);
    public static Vector op_Subtraction(Vector vector1, Vector vector2);
    public static Vector Subtract(Vector vector1, Vector vector2);
    public static Point op_Addition(Vector vector, Point point);
    public static Point Add(Vector vector, Point point);
    public static Vector op_Multiply(Vector vector, double scalar);
    public static Vector Multiply(Vector vector, double scalar);
    public static Vector op_Multiply(double scalar, Vector vector);
    public static Vector Multiply(double scalar, Vector vector);
    public static Vector op_Division(Vector vector, double scalar);
    public static Vector Divide(Vector vector, double scalar);
    public static Vector op_Multiply(Vector vector, Matrix matrix);
    public static Vector Multiply(Vector vector, Matrix matrix);
    public static double op_Multiply(Vector vector1, Vector vector2);
    public static double Multiply(Vector vector1, Vector vector2);
    public static double Determinant(Vector vector1, Vector vector2);
    public static Size op_Explicit(Vector vector);
    public static Point op_Explicit(Vector vector);
}
public class System.Windows.VectorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Windows.WeakEventManager : DispatcherObject {
    private WeakEventTable _table;
    private static object StaticSource;
    private static MethodInfo s_DeliverEventMethodInfo;
    protected IDisposable ReadLock { get; }
    protected IDisposable WriteLock { get; }
    protected object Item { get; protected set; }
    internal static MethodInfo DeliverEventMethodInfo { get; }
    private WeakEventTable Table { get; }
    private static WeakEventManager();
    protected IDisposable get_ReadLock();
    protected IDisposable get_WriteLock();
    protected object get_Item(object source);
    protected void set_Item(object source, object value);
    internal static MethodInfo get_DeliverEventMethodInfo();
    protected virtual ListenerList NewListenerList();
    protected abstract virtual void StartListening(object source);
    protected abstract virtual void StopListening(object source);
    protected static WeakEventManager GetCurrentManager(Type managerType);
    protected static void SetCurrentManager(Type managerType, WeakEventManager manager);
    internal static WeakEventManager GetCurrentManager(Type eventSourceType, string eventName);
    internal static void SetCurrentManager(Type eventSourceType, string eventName, WeakEventManager manager);
    protected void Remove(object source);
    protected void ProtectedAddListener(object source, IWeakEventListener listener);
    protected void ProtectedRemoveListener(object source, IWeakEventListener listener);
    protected void ProtectedAddHandler(object source, Delegate handler);
    protected void ProtectedRemoveHandler(object source, Delegate handler);
    private void AddListener(object source, IWeakEventListener listener, Delegate handler);
    private void RemoveListener(object source, object target, Delegate handler);
    protected void DeliverEvent(object sender, EventArgs args);
    protected void DeliverEventToList(object sender, EventArgs args, ListenerList list);
    protected void ScheduleCleanup();
    protected virtual bool Purge(object source, object data, bool purgeAll);
    internal bool PurgeInternal(object source, object data, bool purgeAll);
    [FriendAccessAllowedAttribute]
internal static bool Cleanup();
    [FriendAccessAllowedAttribute]
internal static void SetCleanupEnabled(bool value);
    private WeakEventTable get_Table();
}
public class System.Windows.WeakEventManager`2 : WeakEventManager {
    private Delegate _handler;
    private string _eventName;
    private EventInfo _eventInfo;
    private WeakEventManager`2(string eventName);
    public static void AddHandler(TEventSource source, string eventName, EventHandler`1<TEventArgs> handler);
    public static void RemoveHandler(TEventSource source, string eventName, EventHandler`1<TEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private static WeakEventManager`2<TEventSource, TEventArgs> CurrentManager(string eventName);
}
internal class System.Xaml.Replacements.TypeUriConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
}
