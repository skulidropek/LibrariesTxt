public abstract class Microsoft.Xaml.Behaviors.AttachableCollection`1 : FreezableCollection`1<T> {
    private Collection`1<T> snapshot;
    private DependencyObject associatedObject;
    protected DependencyObject AssociatedObject { get; }
    private DependencyObject Microsoft.Xaml.Behaviors.IAttachedObject.AssociatedObject { get; }
    protected DependencyObject get_AssociatedObject();
    protected abstract virtual void OnAttached();
    protected abstract virtual void OnDetaching();
    internal abstract virtual void ItemAdded(T item);
    internal abstract virtual void ItemRemoved(T item);
    [ConditionalAttribute("DEBUG")]
private void VerifySnapshotIntegrity();
    private void VerifyAdd(T item);
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private sealed virtual override DependencyObject Microsoft.Xaml.Behaviors.IAttachedObject.get_AssociatedObject();
    public sealed virtual void Attach(DependencyObject dependencyObject);
    public sealed virtual void Detach();
}
public abstract class Microsoft.Xaml.Behaviors.Behavior : Animatable {
    private Type associatedType;
    private DependencyObject associatedObject;
    [CompilerGeneratedAttribute]
private EventHandler AssociatedObjectChanged;
    protected Type AssociatedType { get; }
    protected DependencyObject AssociatedObject { get; }
    private DependencyObject Microsoft.Xaml.Behaviors.IAttachedObject.AssociatedObject { get; }
    internal Behavior(Type associatedType);
    [CompilerGeneratedAttribute]
internal void add_AssociatedObjectChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_AssociatedObjectChanged(EventHandler value);
    protected Type get_AssociatedType();
    protected DependencyObject get_AssociatedObject();
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    protected virtual Freezable CreateInstanceCore();
    private void OnAssociatedObjectChanged();
    private sealed virtual override DependencyObject Microsoft.Xaml.Behaviors.IAttachedObject.get_AssociatedObject();
    public sealed virtual void Attach(DependencyObject dependencyObject);
    public sealed virtual void Detach();
}
public abstract class Microsoft.Xaml.Behaviors.Behavior`1 : Behavior {
    protected T AssociatedObject { get; }
    protected T get_AssociatedObject();
}
public class Microsoft.Xaml.Behaviors.BehaviorCollection : AttachableCollection`1<Behavior> {
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    internal virtual void ItemAdded(Behavior item);
    internal virtual void ItemRemoved(Behavior item);
    protected virtual Freezable CreateInstanceCore();
}
internal static class Microsoft.Xaml.Behaviors.ComparisonLogic : object {
    internal static bool EvaluateImpl(object leftOperand, ComparisonConditionType operatorType, object rightOperand);
    private static bool EvaluateComparable(IComparable leftOperand, ComparisonConditionType operatorType, IComparable rightOperand);
}
public class Microsoft.Xaml.Behaviors.Core.ActionCommand : object {
    private Action action;
    private Action`1<object> objectAction;
    [CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    public ActionCommand(Action action);
    public ActionCommand(Action`1<object> objectAction);
    [CompilerGeneratedAttribute]
private void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove_CanExecuteChanged(EventHandler value);
    private sealed virtual override void System.Windows.Input.ICommand.add_CanExecuteChanged(EventHandler value);
    private sealed virtual override void System.Windows.Input.ICommand.remove_CanExecuteChanged(EventHandler value);
    private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object parameter);
    public sealed virtual void Execute(object parameter);
}
public class Microsoft.Xaml.Behaviors.Core.ActivateStateAction : PrototypingActionBase {
    public static DependencyProperty TargetScreenProperty;
    public static DependencyProperty TargetStateProperty;
    public string TargetScreen { get; public set; }
    public string TargetState { get; public set; }
    private static ActivateStateAction();
    public string get_TargetScreen();
    public void set_TargetScreen(string value);
    public string get_TargetState();
    public void set_TargetState(string value);
    protected virtual void Invoke(object parameter);
    protected virtual Freezable CreateInstanceCore();
}
public class Microsoft.Xaml.Behaviors.Core.CallMethodAction : TriggerAction`1<DependencyObject> {
    private List`1<MethodDescriptor> methodDescriptors;
    public static DependencyProperty TargetObjectProperty;
    public static DependencyProperty MethodNameProperty;
    public object TargetObject { get; public set; }
    public string MethodName { get; public set; }
    private object Target { get; }
    private static CallMethodAction();
    public object get_TargetObject();
    public void set_TargetObject(object value);
    public string get_MethodName();
    public void set_MethodName(string value);
    private object get_Target();
    protected virtual void Invoke(object parameter);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private MethodDescriptor FindBestMethod(object parameter);
    private void UpdateMethodInfo();
    private bool IsMethodValid(MethodInfo method);
    private static bool AreMethodParamsValid(ParameterInfo[] methodParams);
    private static void OnMethodNameChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    private static void OnTargetObjectChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
}
public class Microsoft.Xaml.Behaviors.Core.ChangePropertyAction : TargetedTriggerAction`1<object> {
    public static DependencyProperty PropertyNameProperty;
    public static DependencyProperty ValueProperty;
    public static DependencyProperty DurationProperty;
    public static DependencyProperty IncrementProperty;
    public string PropertyName { get; public set; }
    public object Value { get; public set; }
    public Duration Duration { get; public set; }
    public bool Increment { get; public set; }
    private static ChangePropertyAction();
    public string get_PropertyName();
    public void set_PropertyName(string value);
    public object get_Value();
    public void set_Value(object value);
    public Duration get_Duration();
    public void set_Duration(Duration value);
    public bool get_Increment();
    public void set_Increment(bool value);
    protected virtual void Invoke(object parameter);
    private void AnimatePropertyChange(PropertyInfo propertyInfo, object fromValue, object newValue);
    private static object GetCurrentPropertyValue(object target, PropertyInfo propertyInfo);
    private void ValidateAnimationPossible(Type targetType);
    private Timeline CreateKeyFrameAnimation(object newValue, object fromValue);
    private Timeline CreatePointAnimation(Point fromValue, Point newValue);
    private Timeline CreateColorAnimation(Color fromValue, Color newValue);
    private Timeline CreateDoubleAnimation(double fromValue, double newValue);
    private void ValidateProperty(PropertyInfo propertyInfo);
    private object IncrementCurrentValue(PropertyInfo propertyInfo);
    private static object TryAddition(object currentValue, object value);
}
public class Microsoft.Xaml.Behaviors.Core.ComparisonCondition : Freezable {
    public static DependencyProperty LeftOperandProperty;
    public static DependencyProperty OperatorProperty;
    public static DependencyProperty RightOperandProperty;
    public object LeftOperand { get; public set; }
    public object RightOperand { get; public set; }
    public ComparisonConditionType Operator { get; public set; }
    private static ComparisonCondition();
    protected virtual Freezable CreateInstanceCore();
    public object get_LeftOperand();
    public void set_LeftOperand(object value);
    public object get_RightOperand();
    public void set_RightOperand(object value);
    public ComparisonConditionType get_Operator();
    public void set_Operator(ComparisonConditionType value);
    public bool Evaluate();
    private void EnsureBindingUpToDate();
}
public enum Microsoft.Xaml.Behaviors.Core.ComparisonConditionType : Enum {
    public int value__;
    public static ComparisonConditionType Equal;
    public static ComparisonConditionType NotEqual;
    public static ComparisonConditionType LessThan;
    public static ComparisonConditionType LessThanOrEqual;
    public static ComparisonConditionType GreaterThan;
    public static ComparisonConditionType GreaterThanOrEqual;
}
[ContentPropertyAttribute("Conditions")]
public class Microsoft.Xaml.Behaviors.Core.ConditionalExpression : Freezable {
    public static DependencyProperty ConditionsProperty;
    public static DependencyProperty ForwardChainingProperty;
    public ForwardChaining ForwardChaining { get; public set; }
    public ConditionCollection Conditions { get; }
    private static ConditionalExpression();
    protected virtual Freezable CreateInstanceCore();
    public ForwardChaining get_ForwardChaining();
    public void set_ForwardChaining(ForwardChaining value);
    public ConditionCollection get_Conditions();
    public sealed virtual bool Evaluate();
}
[ContentPropertyAttribute("Condition")]
public class Microsoft.Xaml.Behaviors.Core.ConditionBehavior : Behavior`1<TriggerBase> {
    public static DependencyProperty ConditionProperty;
    public ICondition Condition { get; public set; }
    private static ConditionBehavior();
    public ICondition get_Condition();
    public void set_Condition(ICondition value);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private void OnPreviewInvoke(object sender, PreviewInvokeEventArgs e);
}
public class Microsoft.Xaml.Behaviors.Core.ConditionCollection : FreezableCollection`1<ComparisonCondition> {
}
public class Microsoft.Xaml.Behaviors.Core.DataStateBehavior : Behavior`1<FrameworkElement> {
    public static DependencyProperty BindingProperty;
    public static DependencyProperty ValueProperty;
    public static DependencyProperty TrueStateProperty;
    public static DependencyProperty FalseStateProperty;
    public object Binding { get; public set; }
    public object Value { get; public set; }
    public string TrueState { get; public set; }
    public string FalseState { get; public set; }
    private FrameworkElement TargetObject { get; }
    private IEnumerable`1<VisualState> TargetedVisualStates { get; }
    private static DataStateBehavior();
    public object get_Binding();
    public void set_Binding(object value);
    public object get_Value();
    public void set_Value(object value);
    public string get_TrueState();
    public void set_TrueState(string value);
    public string get_FalseState();
    public void set_FalseState(string value);
    private FrameworkElement get_TargetObject();
    protected virtual void OnAttached();
    private void ValidateStateNamesDeferred();
    internal static bool IsElementLoaded(FrameworkElement element);
    private void ValidateStateNames();
    private void ValidateStateName(string stateName);
    private IEnumerable`1<VisualState> get_TargetedVisualStates();
    private static void OnBindingChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private static void OnValueChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private static void OnTrueStateChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private static void OnFalseStateChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private void Evaluate();
    [CompilerGeneratedAttribute]
private void <ValidateStateNamesDeferred>b__19_0(object o, RoutedEventArgs e);
}
public class Microsoft.Xaml.Behaviors.Core.DataStoreChangedTrigger : PropertyChangedTrigger {
}
public class Microsoft.Xaml.Behaviors.Core.DataTrigger : PropertyChangedTrigger {
    public static DependencyProperty ValueProperty;
    public static DependencyProperty ComparisonProperty;
    public object Value { get; public set; }
    public ComparisonConditionType Comparison { get; public set; }
    private static DataTrigger();
    public object get_Value();
    public void set_Value(object value);
    public ComparisonConditionType get_Comparison();
    public void set_Comparison(ComparisonConditionType value);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private void OnElementLoaded(object sender, RoutedEventArgs e);
    private void UnsubscribeElementLoadedEvent();
    protected virtual void EvaluateBindingChange(object args);
    private static void OnValueChanged(object sender, DependencyPropertyChangedEventArgs args);
    private static void OnComparisonChanged(object sender, DependencyPropertyChangedEventArgs args);
    private bool Compare();
}
public class Microsoft.Xaml.Behaviors.Core.ExtendedVisualStateManager : VisualStateManager {
    public static DependencyProperty UseFluidLayoutProperty;
    public static DependencyProperty RuntimeVisibilityPropertyProperty;
    internal static DependencyProperty OriginalLayoutValuesProperty;
    internal static DependencyProperty LayoutStoryboardProperty;
    internal static DependencyProperty CurrentStateProperty;
    public static DependencyProperty TransitionEffectProperty;
    internal static DependencyProperty TransitionEffectStoryboardProperty;
    internal static DependencyProperty DidCacheBackgroundProperty;
    internal static DependencyProperty CachedBackgroundProperty;
    internal static DependencyProperty CachedEffectProperty;
    private static List`1<FrameworkElement> MovingElements;
    private static Storyboard LayoutTransitionStoryboard;
    private static List`1<DependencyProperty> LayoutProperties;
    private static List`1<DependencyProperty> ChildAffectingLayoutProperties;
    private bool changingState;
    public static bool IsRunningFluidLayoutTransition { get; }
    private static ExtendedVisualStateManager();
    public static bool get_IsRunningFluidLayoutTransition();
    public static bool GetUseFluidLayout(DependencyObject obj);
    public static void SetUseFluidLayout(DependencyObject obj, bool value);
    public static DependencyProperty GetRuntimeVisibilityProperty(DependencyObject obj);
    public static void SetRuntimeVisibilityProperty(DependencyObject obj, DependencyProperty value);
    internal static List`1<OriginalLayoutValueRecord> GetOriginalLayoutValues(DependencyObject obj);
    internal static void SetOriginalLayoutValues(DependencyObject obj, List`1<OriginalLayoutValueRecord> value);
    internal static Storyboard GetLayoutStoryboard(DependencyObject obj);
    internal static void SetLayoutStoryboard(DependencyObject obj, Storyboard value);
    internal static VisualState GetCurrentState(DependencyObject obj);
    internal static void SetCurrentState(DependencyObject obj, VisualState value);
    public static TransitionEffect GetTransitionEffect(DependencyObject obj);
    public static void SetTransitionEffect(DependencyObject obj, TransitionEffect value);
    internal static Storyboard GetTransitionEffectStoryboard(DependencyObject obj);
    internal static void SetTransitionEffectStoryboard(DependencyObject obj, Storyboard value);
    internal static bool GetDidCacheBackground(DependencyObject obj);
    internal static void SetDidCacheBackground(DependencyObject obj, bool value);
    internal static object GetCachedBackground(DependencyObject obj);
    internal static void SetCachedBackground(DependencyObject obj, object value);
    internal static Effect GetCachedEffect(DependencyObject obj);
    internal static void SetCachedEffect(DependencyObject obj, Effect value);
    private static bool IsVisibilityProperty(DependencyProperty property);
    private static DependencyProperty LayoutPropertyFromTimeline(Timeline timeline, bool forceRuntimeProperty);
    protected virtual bool GoToStateCore(FrameworkElement control, FrameworkElement stateGroupsRoot, string stateName, VisualStateGroup group, VisualState state, bool useTransitions);
    private static void control_LayoutUpdated(object sender, EventArgs e);
    private static void StopAnimations();
    private static bool PrepareTransitionEffectImage(FrameworkElement stateGroupsRoot, bool useTransitions, VisualTransition transition);
    private bool TransitionEffectAwareGoToStateCore(FrameworkElement control, FrameworkElement stateGroupsRoot, string stateName, VisualStateGroup group, VisualState state, bool useTransitions, VisualTransition transition, bool animateWithTransitionEffect, VisualState previousState);
    private static bool FinishesWithZeroOpacity(FrameworkElement control, FrameworkElement stateGroupsRoot, VisualState state, VisualState previousState);
    private static bool TimelineIsAnimatingRootOpacity(Timeline timeline, FrameworkElement control, FrameworkElement stateGroupsRoot);
    private static void AnimateTransitionEffect(FrameworkElement stateGroupsRoot, VisualTransition transition);
    private static void FinishTransitionEffectAnimation(FrameworkElement stateGroupsRoot);
    private static VisualTransition FindTransition(VisualStateGroup group, VisualState previousState, VisualState state);
    private static Storyboard ExtractLayoutStoryboard(VisualState state);
    private static List`1<FrameworkElement> FindTargetElements(FrameworkElement control, FrameworkElement templateRoot, Storyboard layoutStoryboard, List`1<OriginalLayoutValueRecord> originalValueRecords, List`1<FrameworkElement> movingElements);
    private static object GetTimelineTarget(FrameworkElement control, FrameworkElement templateRoot, Timeline timeline);
    private static Dictionary`2<FrameworkElement, Rect> GetRectsOfTargets(List`1<FrameworkElement> targets, List`1<FrameworkElement> movingElements);
    internal static Rect GetLayoutRect(FrameworkElement element);
    private static Dictionary`2<FrameworkElement, double> GetOldOpacities(FrameworkElement control, FrameworkElement templateRoot, Storyboard layoutStoryboard, List`1<OriginalLayoutValueRecord> originalValueRecords, List`1<FrameworkElement> movingElements);
    private static void SetLayoutStoryboardProperties(FrameworkElement control, FrameworkElement templateRoot, Storyboard layoutStoryboard, List`1<OriginalLayoutValueRecord> originalValueRecords);
    private static object GetValueFromTimeline(Timeline timeline, Boolean& gotValue);
    private static void WrapMovingElementsInCanvases(List`1<FrameworkElement> movingElements, Dictionary`2<FrameworkElement, Rect> oldRects, Dictionary`2<FrameworkElement, Rect> newRects);
    private static void UnwrapMovingElementsFromCanvases(List`1<FrameworkElement> movingElements);
    private static void CopyLayoutProperties(FrameworkElement source, FrameworkElement target, bool restoring);
    private static Storyboard CreateLayoutTransitionStoryboard(VisualTransition transition, List`1<FrameworkElement> movingElements, Dictionary`2<FrameworkElement, double> oldOpacities);
    private static void TransferLocalValue(FrameworkElement element, DependencyProperty sourceProperty, DependencyProperty destProperty);
    private static object CacheLocalValueHelper(DependencyObject dependencyObject, DependencyProperty property);
    private static void ReplaceCachedLocalValueHelper(FrameworkElement element, DependencyProperty property, object value);
    private static bool IsClose(double a, double b);
}
public enum Microsoft.Xaml.Behaviors.Core.ForwardChaining : Enum {
    public int value__;
    public static ForwardChaining And;
    public static ForwardChaining Or;
}
public class Microsoft.Xaml.Behaviors.Core.GoToStateAction : TargetedTriggerAction`1<FrameworkElement> {
    public static DependencyProperty UseTransitionsProperty;
    public static DependencyProperty StateNameProperty;
    [CompilerGeneratedAttribute]
private FrameworkElement <StateTarget>k__BackingField;
    public bool UseTransitions { get; public set; }
    public string StateName { get; public set; }
    private FrameworkElement StateTarget { get; private set; }
    private bool IsTargetObjectSet { get; }
    private static GoToStateAction();
    public bool get_UseTransitions();
    public void set_UseTransitions(bool value);
    public string get_StateName();
    public void set_StateName(string value);
    [CompilerGeneratedAttribute]
private FrameworkElement get_StateTarget();
    [CompilerGeneratedAttribute]
private void set_StateTarget(FrameworkElement value);
    private bool get_IsTargetObjectSet();
    protected virtual void OnTargetChanged(FrameworkElement oldTarget, FrameworkElement newTarget);
    protected virtual void Invoke(object parameter);
    internal void InvokeImpl(FrameworkElement stateTarget);
}
public interface Microsoft.Xaml.Behaviors.Core.ICondition {
    public abstract virtual bool Evaluate();
}
public class Microsoft.Xaml.Behaviors.Core.LaunchUriOrFileAction : TriggerAction`1<DependencyObject> {
    public static DependencyProperty PathProperty;
    public string Path { get; public set; }
    private static LaunchUriOrFileAction();
    public string get_Path();
    public void set_Path(string value);
    protected virtual void Invoke(object parameter);
}
public class Microsoft.Xaml.Behaviors.Core.NavigateBackAction : PrototypingActionBase {
    protected virtual void Invoke(object parameter);
    protected virtual Freezable CreateInstanceCore();
}
public class Microsoft.Xaml.Behaviors.Core.NavigateForwardAction : PrototypingActionBase {
    protected virtual void Invoke(object parameter);
    protected virtual Freezable CreateInstanceCore();
}
public class Microsoft.Xaml.Behaviors.Core.NavigateToScreenAction : PrototypingActionBase {
    public static DependencyProperty TargetScreenProperty;
    public string TargetScreen { get; public set; }
    private static NavigateToScreenAction();
    public string get_TargetScreen();
    public void set_TargetScreen(string value);
    protected virtual void Invoke(object parameter);
    protected virtual Freezable CreateInstanceCore();
}
[DefaultTriggerAttribute("System.Windows.FrameworkElement", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
[DefaultTriggerAttribute("System.Windows.Controls.Primitives.ButtonBase", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
public class Microsoft.Xaml.Behaviors.Core.NavigationMenuAction : TargetedTriggerAction`1<FrameworkElement> {
    public static DependencyProperty InactiveStateProperty;
    public static DependencyProperty TargetScreenProperty;
    public static DependencyProperty ActiveStateProperty;
    [CompilerGeneratedAttribute]
private FrameworkElement <StateTarget>k__BackingField;
    public string TargetScreen { get; public set; }
    public string ActiveState { get; public set; }
    public string InactiveState { get; public set; }
    private bool IsTargetObjectSet { get; }
    private FrameworkElement StateTarget { get; private set; }
    private static NavigationMenuAction();
    public string get_TargetScreen();
    public void set_TargetScreen(string value);
    public string get_ActiveState();
    public void set_ActiveState(string value);
    public string get_InactiveState();
    public void set_InactiveState(string value);
    private bool get_IsTargetObjectSet();
    [CompilerGeneratedAttribute]
private FrameworkElement get_StateTarget();
    [CompilerGeneratedAttribute]
private void set_StateTarget(FrameworkElement value);
    protected virtual void OnTargetChanged(FrameworkElement oldTarget, FrameworkElement newTarget);
    protected virtual void Invoke(object parameter);
    internal void InvokeImpl(FrameworkElement stateTarget);
    protected virtual Freezable CreateInstanceCore();
    [CompilerGeneratedAttribute]
private bool <InvokeImpl>b__20_0(UserControl control);
}
public class Microsoft.Xaml.Behaviors.Core.PlaySketchFlowAnimationAction : PrototypingActionBase {
    public static DependencyProperty TargetScreenProperty;
    public static DependencyProperty SketchFlowAnimationProperty;
    public string TargetScreen { get; public set; }
    public string SketchFlowAnimation { get; public set; }
    private static PlaySketchFlowAnimationAction();
    public string get_TargetScreen();
    public void set_TargetScreen(string value);
    public string get_SketchFlowAnimation();
    public void set_SketchFlowAnimation(string value);
    protected virtual void Invoke(object parameter);
    protected virtual Freezable CreateInstanceCore();
}
public class Microsoft.Xaml.Behaviors.Core.PropertyChangedTrigger : TriggerBase`1<DependencyObject> {
    public static DependencyProperty BindingProperty;
    public object Binding { get; public set; }
    private static PropertyChangedTrigger();
    public object get_Binding();
    public void set_Binding(object value);
    protected virtual void EvaluateBindingChange(object args);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private void OnPreviewInvoke(object sender, PreviewInvokeEventArgs e);
    private static void OnBindingChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
}
[DefaultTriggerAttribute("System.Windows.Controls.Primitives.ButtonBase", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
[DefaultTriggerAttribute("System.Windows.Controls.TextBox", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
[DefaultTriggerAttribute("System.Windows.Controls.RichTextBox", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
[DefaultTriggerAttribute("System.Windows.Controls.ListBoxItem", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
[DefaultTriggerAttribute("System.Windows.Controls.TreeViewItem", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
[DefaultTriggerAttribute("System.Windows.Controls.Primitives.Selector", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
[DefaultTriggerAttribute("System.Windows.Controls.TreeView", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
[DefaultTriggerAttribute("System.Windows.Controls.Primitives.RangeBase", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
public abstract class Microsoft.Xaml.Behaviors.Core.PrototypingActionBase : TriggerAction`1<DependencyObject> {
    internal void TestInvoke(object parameter);
    protected UserControl GetContainingScreen();
}
public class Microsoft.Xaml.Behaviors.Core.RemoveElementAction : TargetedTriggerAction`1<FrameworkElement> {
    protected virtual void Invoke(object parameter);
}
public class Microsoft.Xaml.Behaviors.Core.RemoveItemInListBoxAction : TriggerAction`1<FrameworkElement> {
    private ListBoxItem ItemContainer { get; }
    private ItemsControl ItemsControl { get; }
    protected virtual void Invoke(object parameter);
    private ListBoxItem get_ItemContainer();
    private ItemsControl get_ItemsControl();
}
[DefaultTriggerAttribute("System.Windows.UIElement", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
public class Microsoft.Xaml.Behaviors.Core.SetDataStoreValueAction : ChangePropertyAction {
}
public class Microsoft.Xaml.Behaviors.Core.TimerTrigger : EventTrigger {
    public static DependencyProperty MillisecondsPerTickProperty;
    public static DependencyProperty TotalTicksProperty;
    private ITickTimer timer;
    private EventArgs eventArgs;
    private int tickCount;
    public double MillisecondsPerTick { get; public set; }
    public int TotalTicks { get; public set; }
    internal TimerTrigger(ITickTimer timer);
    private static TimerTrigger();
    public double get_MillisecondsPerTick();
    public void set_MillisecondsPerTick(double value);
    public int get_TotalTicks();
    public void set_TotalTicks(int value);
    protected virtual void OnEvent(EventArgs eventArgs);
    protected virtual void OnDetaching();
    internal void StartTimer();
    internal void StopTimer();
    private void OnTimerTick(object sender, EventArgs e);
}
public enum Microsoft.Xaml.Behaviors.CustomPropertyValueEditor : Enum {
    public int value__;
    public static CustomPropertyValueEditor Element;
    public static CustomPropertyValueEditor Storyboard;
    public static CustomPropertyValueEditor StateName;
    public static CustomPropertyValueEditor ElementBinding;
    public static CustomPropertyValueEditor PropertyBinding;
}
[AttributeUsageAttribute("128")]
public class Microsoft.Xaml.Behaviors.CustomPropertyValueEditorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CustomPropertyValueEditor <CustomPropertyValueEditor>k__BackingField;
    public CustomPropertyValueEditor CustomPropertyValueEditor { get; private set; }
    public CustomPropertyValueEditorAttribute(CustomPropertyValueEditor customPropertyValueEditor);
    [CompilerGeneratedAttribute]
public CustomPropertyValueEditor get_CustomPropertyValueEditor();
    [CompilerGeneratedAttribute]
private void set_CustomPropertyValueEditor(CustomPropertyValueEditor value);
}
internal static class Microsoft.Xaml.Behaviors.DataBindingHelper : object {
    private static Dictionary`2<Type, IList`1<DependencyProperty>> DependenciesPropertyCache;
    private static DataBindingHelper();
    public static void EnsureDataBindingUpToDateOnMembers(DependencyObject dpObject);
    public static void EnsureDataBindingOnActionsUpToDate(TriggerBase`1<DependencyObject> trigger);
    public static void EnsureBindingUpToDate(DependencyObject target, DependencyProperty dp);
}
[CLSCompliantAttribute("False")]
[AttributeUsageAttribute("132")]
public class Microsoft.Xaml.Behaviors.DefaultTriggerAttribute : Attribute {
    private Type targetType;
    private Type triggerType;
    private Object[] parameters;
    public Type TargetType { get; }
    public Type TriggerType { get; }
    public IEnumerable Parameters { get; }
    public DefaultTriggerAttribute(Type targetType, Type triggerType, object parameter);
    public DefaultTriggerAttribute(Type targetType, Type triggerType, Object[] parameters);
    public Type get_TargetType();
    public Type get_TriggerType();
    public IEnumerable get_Parameters();
    public TriggerBase Instantiate();
}
[ExtensionAttribute]
public static class Microsoft.Xaml.Behaviors.DependencyObjectHelper : object {
    [IteratorStateMachineAttribute("Microsoft.Xaml.Behaviors.DependencyObjectHelper/<GetSelfAndAncestors>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<DependencyObject> GetSelfAndAncestors(DependencyObject dependencyObject);
}
public class Microsoft.Xaml.Behaviors.EventObserver : object {
    private EventInfo eventInfo;
    private object target;
    private Delegate handler;
    public EventObserver(EventInfo eventInfo, object target, Delegate handler);
    public sealed virtual void Dispose();
}
public class Microsoft.Xaml.Behaviors.EventTrigger : EventTriggerBase`1<object> {
    public static DependencyProperty EventNameProperty;
    public string EventName { get; public set; }
    public EventTrigger(string eventName);
    private static EventTrigger();
    public string get_EventName();
    public void set_EventName(string value);
    protected virtual string GetEventName();
    private static void OnEventNameChanged(object sender, DependencyPropertyChangedEventArgs args);
}
public abstract class Microsoft.Xaml.Behaviors.EventTriggerBase : TriggerBase {
    private Type sourceTypeConstraint;
    private bool isSourceChangedRegistered;
    private NameResolver sourceNameResolver;
    private MethodInfo eventHandlerMethodInfo;
    public static DependencyProperty SourceObjectProperty;
    public static DependencyProperty SourceNameProperty;
    [CompilerGeneratedAttribute]
private bool <IsLoadedRegistered>k__BackingField;
    protected Type AssociatedObjectTypeConstraint { get; }
    protected Type SourceTypeConstraint { get; }
    public object SourceObject { get; public set; }
    public string SourceName { get; public set; }
    public object Source { get; }
    private NameResolver SourceNameResolver { get; }
    private bool IsSourceChangedRegistered { get; private set; }
    private bool IsSourceNameSet { get; }
    private bool IsLoadedRegistered { get; private set; }
    internal EventTriggerBase(Type sourceTypeConstraint);
    private static EventTriggerBase();
    protected sealed virtual Type get_AssociatedObjectTypeConstraint();
    protected Type get_SourceTypeConstraint();
    public object get_SourceObject();
    public void set_SourceObject(object value);
    public string get_SourceName();
    public void set_SourceName(string value);
    public object get_Source();
    private NameResolver get_SourceNameResolver();
    private bool get_IsSourceChangedRegistered();
    private void set_IsSourceChangedRegistered(bool value);
    private bool get_IsSourceNameSet();
    [CompilerGeneratedAttribute]
private bool get_IsLoadedRegistered();
    [CompilerGeneratedAttribute]
private void set_IsLoadedRegistered(bool value);
    protected abstract virtual string GetEventName();
    protected virtual void OnEvent(EventArgs eventArgs);
    private void OnSourceChanged(object oldSource, object newSource);
    internal virtual void OnSourceChangedImpl(object oldSource, object newSource);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private void OnBehaviorHostChanged(object sender, EventArgs e);
    private static void OnSourceObjectChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private static void OnSourceNameChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private void RegisterSourceChanged();
    private void UnregisterSourceChanged();
    private void OnSourceNameResolverElementChanged(object sender, NameResolvedEventArgs e);
    private void RegisterLoaded(FrameworkElement associatedElement);
    protected void UnregisterLoaded(FrameworkElement associatedElement);
    private void RegisterEvent(object obj, string eventName);
    private static bool IsValidEvent(EventInfo eventInfo);
    private void UnregisterEvent(object obj, string eventName);
    private void UnregisterEventImpl(object obj, string eventName);
    private void OnEventImpl(object sender, EventArgs eventArgs);
    internal void OnEventNameChanged(string oldEventName, string newEventName);
}
public abstract class Microsoft.Xaml.Behaviors.EventTriggerBase`1 : EventTriggerBase {
    public T Source { get; }
    public T get_Source();
    internal sealed virtual void OnSourceChangedImpl(object oldSource, object newSource);
    protected virtual void OnSourceChanged(T oldSource, T newSource);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.Xaml.Behaviors.ExceptionStringTable : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CallMethodActionValidMethodNotFoundExceptionMessage { get; }
    internal static string CannotHostBehaviorCollectionMultipleTimesExceptionMessage { get; }
    internal static string CannotHostBehaviorMultipleTimesExceptionMessage { get; }
    internal static string CannotHostTriggerActionMultipleTimesExceptionMessage { get; }
    internal static string CannotHostTriggerCollectionMultipleTimesExceptionMessage { get; }
    internal static string CannotHostTriggerMultipleTimesExceptionMessage { get; }
    internal static string ChangePropertyActionAmbiguousAdditionOperationExceptionMessage { get; }
    internal static string ChangePropertyActionCannotAnimateTargetTypeExceptionMessage { get; }
    internal static string ChangePropertyActionCannotFindPropertyNameExceptionMessage { get; }
    internal static string ChangePropertyActionCannotIncrementAnimatedPropertyChangeExceptionMessage { get; }
    internal static string ChangePropertyActionCannotIncrementWriteOnlyPropertyExceptionMessage { get; }
    internal static string ChangePropertyActionCannotSetValueExceptionMessage { get; }
    internal static string ChangePropertyActionPropertyIsReadOnlyExceptionMessage { get; }
    internal static string CommandDoesNotExistOnBehaviorWarningMessage { get; }
    internal static string DataStateBehaviorStateNameNotFoundExceptionMessage { get; }
    internal static string DefaultTriggerAttributeInvalidTriggerTypeSpecifiedExceptionMessage { get; }
    internal static string DuplicateItemInCollectionExceptionMessage { get; }
    internal static string EventTriggerBaseInvalidEventExceptionMessage { get; }
    internal static string EventTriggerCannotFindEventNameExceptionMessage { get; }
    internal static string GoToStateActionTargetHasNoStateGroups { get; }
    internal static string InvalidLeftOperand { get; }
    internal static string InvalidOperands { get; }
    internal static string InvalidRightOperand { get; }
    internal static string RetargetedTypeConstraintViolatedExceptionMessage { get; }
    internal static string TypeConstraintViolatedExceptionMessage { get; }
    internal static string UnableToResolveTargetNameWarningMessage { get; }
    internal static string UnsupportedRemoveTargetExceptionMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CallMethodActionValidMethodNotFoundExceptionMessage();
    internal static string get_CannotHostBehaviorCollectionMultipleTimesExceptionMessage();
    internal static string get_CannotHostBehaviorMultipleTimesExceptionMessage();
    internal static string get_CannotHostTriggerActionMultipleTimesExceptionMessage();
    internal static string get_CannotHostTriggerCollectionMultipleTimesExceptionMessage();
    internal static string get_CannotHostTriggerMultipleTimesExceptionMessage();
    internal static string get_ChangePropertyActionAmbiguousAdditionOperationExceptionMessage();
    internal static string get_ChangePropertyActionCannotAnimateTargetTypeExceptionMessage();
    internal static string get_ChangePropertyActionCannotFindPropertyNameExceptionMessage();
    internal static string get_ChangePropertyActionCannotIncrementAnimatedPropertyChangeExceptionMessage();
    internal static string get_ChangePropertyActionCannotIncrementWriteOnlyPropertyExceptionMessage();
    internal static string get_ChangePropertyActionCannotSetValueExceptionMessage();
    internal static string get_ChangePropertyActionPropertyIsReadOnlyExceptionMessage();
    internal static string get_CommandDoesNotExistOnBehaviorWarningMessage();
    internal static string get_DataStateBehaviorStateNameNotFoundExceptionMessage();
    internal static string get_DefaultTriggerAttributeInvalidTriggerTypeSpecifiedExceptionMessage();
    internal static string get_DuplicateItemInCollectionExceptionMessage();
    internal static string get_EventTriggerBaseInvalidEventExceptionMessage();
    internal static string get_EventTriggerCannotFindEventNameExceptionMessage();
    internal static string get_GoToStateActionTargetHasNoStateGroups();
    internal static string get_InvalidLeftOperand();
    internal static string get_InvalidOperands();
    internal static string get_InvalidRightOperand();
    internal static string get_RetargetedTypeConstraintViolatedExceptionMessage();
    internal static string get_TypeConstraintViolatedExceptionMessage();
    internal static string get_UnableToResolveTargetNameWarningMessage();
    internal static string get_UnsupportedRemoveTargetExceptionMessage();
}
public interface Microsoft.Xaml.Behaviors.IAttachedObject {
    public DependencyObject AssociatedObject { get; }
    public abstract virtual DependencyObject get_AssociatedObject();
    public abstract virtual void Attach(DependencyObject dependencyObject);
    public abstract virtual void Detach();
}
public class Microsoft.Xaml.Behaviors.Input.KeyTrigger : EventTriggerBase`1<UIElement> {
    public static DependencyProperty KeyProperty;
    public static DependencyProperty ModifiersProperty;
    public static DependencyProperty ActiveOnFocusProperty;
    public static DependencyProperty FiredOnProperty;
    private UIElement targetElement;
    public Key Key { get; public set; }
    public ModifierKeys Modifiers { get; public set; }
    public bool ActiveOnFocus { get; public set; }
    public KeyTriggerFiredOn FiredOn { get; public set; }
    private static KeyTrigger();
    public Key get_Key();
    public void set_Key(Key value);
    public ModifierKeys get_Modifiers();
    public void set_Modifiers(ModifierKeys value);
    public bool get_ActiveOnFocus();
    public void set_ActiveOnFocus(bool value);
    public KeyTriggerFiredOn get_FiredOn();
    public void set_FiredOn(KeyTriggerFiredOn value);
    protected virtual string GetEventName();
    private void OnKeyPress(object sender, KeyEventArgs e);
    private static ModifierKeys GetActualModifiers();
    protected virtual void OnEvent(EventArgs eventArgs);
    protected virtual void OnDetaching();
    private static UIElement GetRoot(DependencyObject current);
}
public enum Microsoft.Xaml.Behaviors.Input.KeyTriggerFiredOn : Enum {
    public int value__;
    public static KeyTriggerFiredOn KeyDown;
    public static KeyTriggerFiredOn KeyUp;
}
public class Microsoft.Xaml.Behaviors.Input.TranslateZoomRotateBehavior : Behavior`1<FrameworkElement> {
    private Transform cachedRenderTransform;
    private bool isDragging;
    private bool isAdjustingTransform;
    private Point lastMousePoint;
    private double lastScaleX;
    private double lastScaleY;
    private static double HardMinimumScale;
    public static DependencyProperty SupportedGesturesProperty;
    public static DependencyProperty TranslateFrictionProperty;
    public static DependencyProperty RotationalFrictionProperty;
    public static DependencyProperty ConstrainToParentBoundsProperty;
    public static DependencyProperty MinimumScaleProperty;
    public static DependencyProperty MaximumScaleProperty;
    public ManipulationModes SupportedGestures { get; public set; }
    public double TranslateFriction { get; public set; }
    public double RotationalFriction { get; public set; }
    public bool ConstrainToParentBounds { get; public set; }
    public double MinimumScale { get; public set; }
    public double MaximumScale { get; public set; }
    private Transform RenderTransform { get; private set; }
    private Point RenderTransformOriginInElementCoordinates { get; }
    private Matrix FullTransformValue { get; }
    private MatrixTransform MatrixTransform { get; }
    private FrameworkElement ParentElement { get; }
    private static TranslateZoomRotateBehavior();
    public ManipulationModes get_SupportedGestures();
    public void set_SupportedGestures(ManipulationModes value);
    public double get_TranslateFriction();
    public void set_TranslateFriction(double value);
    public double get_RotationalFriction();
    public void set_RotationalFriction(double value);
    public bool get_ConstrainToParentBounds();
    public void set_ConstrainToParentBounds(bool value);
    public double get_MinimumScale();
    public void set_MinimumScale(double value);
    public double get_MaximumScale();
    public void set_MaximumScale(double value);
    private static void frictionChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    private static object coerceFriction(DependencyObject sender, object value);
    private Transform get_RenderTransform();
    private void set_RenderTransform(Transform value);
    private Point get_RenderTransformOriginInElementCoordinates();
    private Matrix get_FullTransformValue();
    private MatrixTransform get_MatrixTransform();
    private FrameworkElement get_ParentElement();
    internal void EnsureTransform();
    internal void ApplyRotationTransform(double angle, Point rotationPoint);
    internal void ApplyScaleTransform(double scaleX, double scaleY, Point scalePoint);
    internal void ApplyTranslateTransform(double x, double y);
    private void ManipulationStarting(object sender, ManipulationStartingEventArgs e);
    private void ManipulationInertiaStarting(object sender, ManipulationInertiaStartingEventArgs e);
    private void ManipulationDelta(object sender, ManipulationDeltaEventArgs e);
    private void MouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    private void MouseLeftButtonUp(object sender, MouseButtonEventArgs e);
    private void AssociatedObject_LostMouseCapture(object sender, MouseEventArgs e);
    private void AssociatedObject_MouseMove(object sender, MouseEventArgs e);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
}
public static class Microsoft.Xaml.Behaviors.Interaction : object {
    [CompilerGeneratedAttribute]
private static bool <ShouldRunInDesignMode>k__BackingField;
    private static DependencyProperty TriggersProperty;
    private static DependencyProperty BehaviorsProperty;
    internal static bool ShouldRunInDesignMode { get; internal set; }
    private static Interaction();
    [CompilerGeneratedAttribute]
internal static bool get_ShouldRunInDesignMode();
    [CompilerGeneratedAttribute]
internal static void set_ShouldRunInDesignMode(bool value);
    public static TriggerCollection GetTriggers(DependencyObject obj);
    public static BehaviorCollection GetBehaviors(DependencyObject obj);
    private static void OnBehaviorsChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private static void OnTriggersChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    internal static bool IsElementLoaded(FrameworkElement element);
}
internal static class Microsoft.Xaml.Behaviors.InteractionContext : object {
    private static Assembly runtimeAssembly;
    private static object playerContextInstance;
    private static object activeNavigationViewModelObject;
    private static PropertyInfo libraryNamePropertyInfo;
    private static PropertyInfo activeNavigationViewModelPropertyInfo;
    private static PropertyInfo canGoBackPropertyInfo;
    private static PropertyInfo canGoForwardPropertyInfo;
    private static PropertyInfo sketchFlowAnimationPlayerPropertyInfo;
    private static MethodInfo goBackMethodInfo;
    private static MethodInfo goForwardMethodInfo;
    private static MethodInfo navigateToScreenMethodInfo;
    private static MethodInfo invokeStateChangeMethodInfo;
    private static MethodInfo playSketchFlowAnimationMethodInfo;
    private static NavigationService navigationService;
    private static string LibraryName;
    private static Dictionary`2<string, Data> NavigationData;
    public static object ActiveNavigationViewModelObject { get; internal set; }
    private static bool IsPrototypingRuntimeLoaded { get; }
    private static bool CanGoBack { get; }
    private static bool CanGoForward { get; }
    private static bool PlatformCanGoBack { get; }
    private static bool PlatformCanGoForward { get; }
    private static InteractionContext();
    public static object get_ActiveNavigationViewModelObject();
    internal static void set_ActiveNavigationViewModelObject(object value);
    private static bool get_IsPrototypingRuntimeLoaded();
    private static bool get_CanGoBack();
    private static bool get_CanGoForward();
    public static void GoBack();
    public static void GoForward();
    public static bool IsScreen(string screenName);
    public static void GoToScreen(string screenName, Assembly assembly);
    public static void GoToState(string screen, string state);
    public static void PlaySketchFlowAnimation(string sketchFlowAnimation, string owningScreen);
    private static void InitializeRuntimeNavigation();
    private static Data LoadNavigationData(string assemblyName);
    private static string GetScreenClassName(string screenName);
    private static void InitalizePlatformNavigation();
    private static Assembly FindPlatformRuntimeAssembly();
    public static void PlatformGoBack();
    public static void PlatformGoForward();
    public static void PlatformGoToScreen(string assemblyName, string screen);
    private static bool get_PlatformCanGoBack();
    private static bool get_PlatformCanGoForward();
}
public class Microsoft.Xaml.Behaviors.InvokeCommandAction : TriggerAction`1<DependencyObject> {
    private string commandName;
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty EventArgsConverterProperty;
    public static DependencyProperty EventArgsConverterParameterProperty;
    public static DependencyProperty EventArgsParameterPathProperty;
    [CompilerGeneratedAttribute]
private bool <PassEventArgsToCommand>k__BackingField;
    public string CommandName { get; public set; }
    public ICommand Command { get; public set; }
    public object CommandParameter { get; public set; }
    public IValueConverter EventArgsConverter { get; public set; }
    public object EventArgsConverterParameter { get; public set; }
    public string EventArgsParameterPath { get; public set; }
    public bool PassEventArgsToCommand { get; public set; }
    private static InvokeCommandAction();
    public string get_CommandName();
    public void set_CommandName(string value);
    public ICommand get_Command();
    public void set_Command(ICommand value);
    public object get_CommandParameter();
    public void set_CommandParameter(object value);
    public IValueConverter get_EventArgsConverter();
    public void set_EventArgsConverter(IValueConverter value);
    public object get_EventArgsConverterParameter();
    public void set_EventArgsConverterParameter(object value);
    public string get_EventArgsParameterPath();
    public void set_EventArgsParameterPath(string value);
    [CompilerGeneratedAttribute]
public bool get_PassEventArgsToCommand();
    [CompilerGeneratedAttribute]
public void set_PassEventArgsToCommand(bool value);
    protected virtual void Invoke(object parameter);
    private object GetEventArgsPropertyPathValue(object parameter);
    private ICommand ResolveCommand();
}
internal interface Microsoft.Xaml.Behaviors.ITickTimer {
    public TimeSpan Interval { get; public set; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Tick(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Tick(EventHandler value);
    public abstract virtual void Start();
    public abstract virtual void Stop();
    public abstract virtual TimeSpan get_Interval();
    public abstract virtual void set_Interval(TimeSpan value);
}
public class Microsoft.Xaml.Behaviors.Layout.AdornerContainer : Adorner {
    private UIElement child;
    public UIElement Child { get; public set; }
    protected int VisualChildrenCount { get; }
    public AdornerContainer(UIElement adornedElement);
    protected virtual Size ArrangeOverride(Size finalSize);
    public UIElement get_Child();
    public void set_Child(UIElement value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
}
public class Microsoft.Xaml.Behaviors.Layout.FluidMoveBehavior : FluidMoveBehaviorBase {
    public static DependencyProperty DurationProperty;
    public static DependencyProperty InitialTagProperty;
    public static DependencyProperty InitialTagPathProperty;
    private static DependencyProperty initialIdentityTagProperty;
    public static DependencyProperty FloatAboveProperty;
    public static DependencyProperty EaseXProperty;
    public static DependencyProperty EaseYProperty;
    private static DependencyProperty overlayProperty;
    private static DependencyProperty cacheDuringOverlayProperty;
    private static DependencyProperty hasTransformWrapperProperty;
    private static Dictionary`2<object, Storyboard> transitionStoryboardDictionary;
    public Duration Duration { get; public set; }
    public TagType InitialTag { get; public set; }
    public string InitialTagPath { get; public set; }
    public bool FloatAbove { get; public set; }
    public IEasingFunction EaseX { get; public set; }
    public IEasingFunction EaseY { get; public set; }
    protected bool ShouldSkipInitialLayout { get; }
    private static FluidMoveBehavior();
    public Duration get_Duration();
    public void set_Duration(Duration value);
    public TagType get_InitialTag();
    public void set_InitialTag(TagType value);
    public string get_InitialTagPath();
    public void set_InitialTagPath(string value);
    private static object GetInitialIdentityTag(DependencyObject obj);
    private static void SetInitialIdentityTag(DependencyObject obj, object value);
    public bool get_FloatAbove();
    public void set_FloatAbove(bool value);
    public IEasingFunction get_EaseX();
    public void set_EaseX(IEasingFunction value);
    public IEasingFunction get_EaseY();
    public void set_EaseY(IEasingFunction value);
    private static object GetOverlay(DependencyObject obj);
    private static void SetOverlay(DependencyObject obj, object value);
    private static object GetCacheDuringOverlay(DependencyObject obj);
    private static void SetCacheDuringOverlay(DependencyObject obj, object value);
    private static bool GetHasTransformWrapper(DependencyObject obj);
    private static void SetHasTransformWrapper(DependencyObject obj, bool value);
    protected virtual bool get_ShouldSkipInitialLayout();
    protected virtual void EnsureTags(FrameworkElement child);
    internal virtual void UpdateLayoutTransitionCore(FrameworkElement child, FrameworkElement root, object tag, TagData newTagData);
    private Storyboard CreateTransitionStoryboard(FrameworkElement child, bool usingBeforeLoaded, Rect& layoutRect, Rect& currentRect);
    private static void AddTransform(FrameworkElement child, Transform transform);
    private static Transform GetTransform(FrameworkElement child);
    private static void RemoveTransform(FrameworkElement child);
    private static void TransferLocalValue(FrameworkElement element, DependencyProperty source, DependencyProperty dest);
    private static bool IsClose(double a, double b);
    private static bool IsEmptyRect(Rect rect);
}
public abstract class Microsoft.Xaml.Behaviors.Layout.FluidMoveBehaviorBase : Behavior`1<FrameworkElement> {
    public static DependencyProperty AppliesToProperty;
    public static DependencyProperty IsActiveProperty;
    public static DependencyProperty TagProperty;
    public static DependencyProperty TagPathProperty;
    protected static DependencyProperty IdentityTagProperty;
    internal static Dictionary`2<object, TagData> TagDictionary;
    private static DateTime nextToLastPurgeTick;
    private static DateTime lastPurgeTick;
    private static TimeSpan minTickDelta;
    public FluidMoveScope AppliesTo { get; public set; }
    public bool IsActive { get; public set; }
    public TagType Tag { get; public set; }
    public string TagPath { get; public set; }
    protected bool ShouldSkipInitialLayout { get; }
    private static FluidMoveBehaviorBase();
    public FluidMoveScope get_AppliesTo();
    public void set_AppliesTo(FluidMoveScope value);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    public TagType get_Tag();
    public void set_Tag(TagType value);
    public string get_TagPath();
    public void set_TagPath(string value);
    protected static object GetIdentityTag(DependencyObject obj);
    protected static void SetIdentityTag(DependencyObject obj, object value);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private void AssociatedObject_LayoutUpdated(object sender, EventArgs e);
    private void UpdateLayoutTransition(FrameworkElement child);
    protected virtual bool get_ShouldSkipInitialLayout();
    internal abstract virtual void UpdateLayoutTransitionCore(FrameworkElement child, FrameworkElement root, object tag, TagData newTagData);
    protected virtual void EnsureTags(FrameworkElement child);
    private static FrameworkElement GetVisualRoot(FrameworkElement child);
    internal static Rect TranslateRect(Rect rect, FrameworkElement from, FrameworkElement to);
}
public enum Microsoft.Xaml.Behaviors.Layout.FluidMoveScope : Enum {
    public int value__;
    public static FluidMoveScope Self;
    public static FluidMoveScope Children;
}
public class Microsoft.Xaml.Behaviors.Layout.FluidMoveSetTagBehavior : FluidMoveBehaviorBase {
    internal virtual void UpdateLayoutTransitionCore(FrameworkElement child, FrameworkElement root, object tag, TagData newTagData);
}
public class Microsoft.Xaml.Behaviors.Layout.MouseDragElementBehavior : Behavior`1<FrameworkElement> {
    private bool settingPosition;
    private Point relativePosition;
    private Transform cachedRenderTransform;
    [CompilerGeneratedAttribute]
private MouseEventHandler DragBegun;
    [CompilerGeneratedAttribute]
private MouseEventHandler Dragging;
    [CompilerGeneratedAttribute]
private MouseEventHandler DragFinished;
    public static DependencyProperty XProperty;
    public static DependencyProperty YProperty;
    public static DependencyProperty ConstrainToParentBoundsProperty;
    public double X { get; public set; }
    public double Y { get; public set; }
    public bool ConstrainToParentBounds { get; public set; }
    private Point ActualPosition { get; }
    private Rect ElementBounds { get; }
    private FrameworkElement ParentElement { get; }
    private UIElement RootElement { get; }
    private Transform RenderTransform { get; private set; }
    private static MouseDragElementBehavior();
    [CompilerGeneratedAttribute]
public void add_DragBegun(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DragBegun(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Dragging(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Dragging(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DragFinished(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DragFinished(MouseEventHandler value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public bool get_ConstrainToParentBounds();
    public void set_ConstrainToParentBounds(bool value);
    private static void OnXChanged(object sender, DependencyPropertyChangedEventArgs args);
    private static void OnYChanged(object sender, DependencyPropertyChangedEventArgs args);
    private static void OnConstrainToParentBoundsChanged(object sender, DependencyPropertyChangedEventArgs args);
    private Point get_ActualPosition();
    private Rect get_ElementBounds();
    private FrameworkElement get_ParentElement();
    private UIElement get_RootElement();
    private Transform get_RenderTransform();
    private void set_RenderTransform(Transform value);
    private void UpdatePosition(Point point);
    private void ApplyTranslation(double x, double y);
    internal void ApplyTranslationTransform(double x, double y);
    internal static Transform CloneTransform(Transform transform);
    private void UpdatePosition();
    internal void StartDrag(Point positionInElementCoordinates);
    internal void HandleDrag(Point newPositionInElementCoordinates);
    internal void EndDrag();
    private void OnMouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    private void OnLostMouseCapture(object sender, MouseEventArgs e);
    private void OnMouseLeftButtonUp(object sender, MouseButtonEventArgs e);
    private void OnMouseMove(object sender, MouseEventArgs e);
    private static bool RectContainsRect(Rect rect1, Rect rect2);
    private static Point TransformAsVector(GeneralTransform transform, double x, double y);
    private static Point GetTransformOffset(GeneralTransform transform);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
}
public enum Microsoft.Xaml.Behaviors.Layout.TagType : Enum {
    public int value__;
    public static TagType Element;
    public static TagType DataContext;
}
[CLSCompliantAttribute("False")]
public class Microsoft.Xaml.Behaviors.Media.ControlStoryboardAction : StoryboardAction {
    public static DependencyProperty ControlStoryboardProperty;
    public ControlStoryboardOption ControlStoryboardOption { get; public set; }
    private static ControlStoryboardAction();
    public ControlStoryboardOption get_ControlStoryboardOption();
    public void set_ControlStoryboardOption(ControlStoryboardOption value);
    protected virtual void Invoke(object parameter);
}
public enum Microsoft.Xaml.Behaviors.Media.ControlStoryboardOption : Enum {
    public int value__;
    public static ControlStoryboardOption Play;
    public static ControlStoryboardOption Stop;
    public static ControlStoryboardOption TogglePlayPause;
    public static ControlStoryboardOption Pause;
    public static ControlStoryboardOption Resume;
    public static ControlStoryboardOption SkipToFill;
}
public class Microsoft.Xaml.Behaviors.Media.PlaySoundAction : TriggerAction`1<DependencyObject> {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty VolumeProperty;
    public Uri Source { get; public set; }
    public double Volume { get; public set; }
    private static PlaySoundAction();
    public Uri get_Source();
    public void set_Source(Uri value);
    public double get_Volume();
    public void set_Volume(double value);
    protected virtual void SetMediaElementProperties(MediaElement mediaElement);
    protected virtual void Invoke(object parameter);
}
public abstract class Microsoft.Xaml.Behaviors.Media.StoryboardAction : TriggerAction`1<DependencyObject> {
    public static DependencyProperty StoryboardProperty;
    public Storyboard Storyboard { get; public set; }
    private static StoryboardAction();
    public Storyboard get_Storyboard();
    public void set_Storyboard(Storyboard value);
    private static void OnStoryboardChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnStoryboardChanged(DependencyPropertyChangedEventArgs args);
}
public class Microsoft.Xaml.Behaviors.Media.StoryboardCompletedTrigger : StoryboardTrigger {
    protected virtual void OnDetaching();
    protected virtual void OnStoryboardChanged(DependencyPropertyChangedEventArgs args);
    private void Storyboard_Completed(object sender, EventArgs e);
}
public abstract class Microsoft.Xaml.Behaviors.Media.StoryboardTrigger : TriggerBase`1<DependencyObject> {
    public static DependencyProperty StoryboardProperty;
    public Storyboard Storyboard { get; public set; }
    private static StoryboardTrigger();
    public Storyboard get_Storyboard();
    public void set_Storyboard(Storyboard value);
    private static void OnStoryboardChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnStoryboardChanged(DependencyPropertyChangedEventArgs args);
}
public abstract class Microsoft.Xaml.Behaviors.Media.TransitionEffect : ShaderEffect {
    public static DependencyProperty InputProperty;
    public static DependencyProperty OldImageProperty;
    public static DependencyProperty ProgressProperty;
    public Brush Input { get; public set; }
    public Brush OldImage { get; public set; }
    public double Progress { get; public set; }
    private static TransitionEffect();
    public TransitionEffect CloneCurrentValue();
    protected abstract virtual TransitionEffect DeepCopy();
    public Brush get_Input();
    public void set_Input(Brush value);
    public Brush get_OldImage();
    public void set_OldImage(Brush value);
    public double get_Progress();
    public void set_Progress(double value);
}
internal class Microsoft.Xaml.Behaviors.NameResolvedEventArgs : EventArgs {
    private object oldObject;
    private object newObject;
    public object OldObject { get; }
    public object NewObject { get; }
    public NameResolvedEventArgs(object oldObject, object newObject);
    public object get_OldObject();
    public object get_NewObject();
}
internal class Microsoft.Xaml.Behaviors.NameResolver : object {
    private string name;
    private FrameworkElement nameScopeReferenceElement;
    [CompilerGeneratedAttribute]
private EventHandler`1<NameResolvedEventArgs> ResolvedElementChanged;
    [CompilerGeneratedAttribute]
private DependencyObject <ResolvedObject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PendingReferenceElementLoad>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasAttempedResolve>k__BackingField;
    public string Name { get; public set; }
    public DependencyObject Object { get; }
    public FrameworkElement NameScopeReferenceElement { get; public set; }
    private FrameworkElement ActualNameScopeReferenceElement { get; }
    private DependencyObject ResolvedObject { get; private set; }
    private bool PendingReferenceElementLoad { get; private set; }
    private bool HasAttempedResolve { get; private set; }
    [CompilerGeneratedAttribute]
public void add_ResolvedElementChanged(EventHandler`1<NameResolvedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ResolvedElementChanged(EventHandler`1<NameResolvedEventArgs> value);
    public string get_Name();
    public void set_Name(string value);
    public DependencyObject get_Object();
    public FrameworkElement get_NameScopeReferenceElement();
    public void set_NameScopeReferenceElement(FrameworkElement value);
    private FrameworkElement get_ActualNameScopeReferenceElement();
    [CompilerGeneratedAttribute]
private DependencyObject get_ResolvedObject();
    [CompilerGeneratedAttribute]
private void set_ResolvedObject(DependencyObject value);
    [CompilerGeneratedAttribute]
private bool get_PendingReferenceElementLoad();
    [CompilerGeneratedAttribute]
private void set_PendingReferenceElementLoad(bool value);
    [CompilerGeneratedAttribute]
private bool get_HasAttempedResolve();
    [CompilerGeneratedAttribute]
private void set_HasAttempedResolve(bool value);
    private void OnNameScopeReferenceElementChanged(FrameworkElement oldNameScopeReference);
    private void UpdateObjectFromName(DependencyObject oldObject);
    private void OnObjectChanged(DependencyObject oldTarget, DependencyObject newTarget);
    private FrameworkElement GetActualNameScopeReference(FrameworkElement initialReferenceElement);
    private bool IsNameScope(FrameworkElement frameworkElement);
    private void OnNameScopeReferenceLoaded(object sender, RoutedEventArgs e);
}
public class Microsoft.Xaml.Behaviors.PreviewInvokeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <Cancelling>k__BackingField;
    public bool Cancelling { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Cancelling();
    [CompilerGeneratedAttribute]
public void set_Cancelling(bool value);
}
internal enum Microsoft.Xaml.Behaviors.ScreenType : Enum {
    public int value__;
    public static ScreenType None;
    public static ScreenType Navigation;
    public static ScreenType Composition;
}
internal class Microsoft.Xaml.Behaviors.Serializer : object {
    public static Color HexStringToColor(string value);
    public static string ColorToHexString(Color color);
    public static void Serialize(Data data, Stream stream);
    public static Data Deserialize(string filePath);
    public static Data Deserialize(Stream stream);
    public static Nullable`1<int> GetSchemaVersion(string filePath);
}
public abstract class Microsoft.Xaml.Behaviors.TargetedTriggerAction : TriggerAction {
    private Type targetTypeConstraint;
    private bool isTargetChangedRegistered;
    private NameResolver targetResolver;
    public static DependencyProperty TargetObjectProperty;
    public static DependencyProperty TargetNameProperty;
    public object TargetObject { get; public set; }
    public string TargetName { get; public set; }
    protected object Target { get; }
    protected Type AssociatedObjectTypeConstraint { get; }
    protected Type TargetTypeConstraint { get; }
    private bool IsTargetNameSet { get; }
    private NameResolver TargetResolver { get; }
    private bool IsTargetChangedRegistered { get; private set; }
    internal TargetedTriggerAction(Type targetTypeConstraint);
    private static TargetedTriggerAction();
    public object get_TargetObject();
    public void set_TargetObject(object value);
    public string get_TargetName();
    public void set_TargetName(string value);
    protected object get_Target();
    protected sealed virtual Type get_AssociatedObjectTypeConstraint();
    protected Type get_TargetTypeConstraint();
    private bool get_IsTargetNameSet();
    private NameResolver get_TargetResolver();
    private bool get_IsTargetChangedRegistered();
    private void set_IsTargetChangedRegistered(bool value);
    internal virtual void OnTargetChangedImpl(object oldTarget, object newTarget);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private void OnBehaviorHostChanged(object sender, EventArgs e);
    private void RegisterTargetChanged();
    private void UnregisterTargetChanged();
    private static void OnTargetObjectChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private static void OnTargetNameChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private void OnTargetChanged(object sender, NameResolvedEventArgs e);
}
public abstract class Microsoft.Xaml.Behaviors.TargetedTriggerAction`1 : TargetedTriggerAction {
    protected T Target { get; }
    protected T get_Target();
    internal sealed virtual void OnTargetChangedImpl(object oldTarget, object newTarget);
    protected virtual void OnTargetChanged(T oldTarget, T newTarget);
}
[DefaultTriggerAttribute("System.Windows.UIElement", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
[DefaultTriggerAttribute("System.Windows.Controls.Primitives.ButtonBase", "Microsoft.Xaml.Behaviors.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
public abstract class Microsoft.Xaml.Behaviors.TriggerAction : Animatable {
    private bool isHosted;
    private DependencyObject associatedObject;
    private Type associatedObjectTypeConstraint;
    public static DependencyProperty IsEnabledProperty;
    public bool IsEnabled { get; public set; }
    protected DependencyObject AssociatedObject { get; }
    protected Type AssociatedObjectTypeConstraint { get; }
    internal bool IsHosted { get; internal set; }
    private DependencyObject Microsoft.Xaml.Behaviors.IAttachedObject.AssociatedObject { get; }
    internal TriggerAction(Type associatedObjectTypeConstraint);
    private static TriggerAction();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    protected DependencyObject get_AssociatedObject();
    protected virtual Type get_AssociatedObjectTypeConstraint();
    internal bool get_IsHosted();
    internal void set_IsHosted(bool value);
    internal void CallInvoke(object parameter);
    protected abstract virtual void Invoke(object parameter);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    protected virtual Freezable CreateInstanceCore();
    private sealed virtual override DependencyObject Microsoft.Xaml.Behaviors.IAttachedObject.get_AssociatedObject();
    public sealed virtual void Attach(DependencyObject dependencyObject);
    public sealed virtual void Detach();
}
public abstract class Microsoft.Xaml.Behaviors.TriggerAction`1 : TriggerAction {
    protected T AssociatedObject { get; }
    protected Type AssociatedObjectTypeConstraint { get; }
    protected T get_AssociatedObject();
    protected sealed virtual Type get_AssociatedObjectTypeConstraint();
}
public class Microsoft.Xaml.Behaviors.TriggerActionCollection : AttachableCollection`1<TriggerAction> {
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    internal virtual void ItemAdded(TriggerAction item);
    internal virtual void ItemRemoved(TriggerAction item);
    protected virtual Freezable CreateInstanceCore();
}
[ContentPropertyAttribute("Actions")]
public abstract class Microsoft.Xaml.Behaviors.TriggerBase : Animatable {
    private DependencyObject associatedObject;
    private Type associatedObjectTypeConstraint;
    private static DependencyPropertyKey ActionsPropertyKey;
    public static DependencyProperty ActionsProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<PreviewInvokeEventArgs> PreviewInvoke;
    protected DependencyObject AssociatedObject { get; }
    protected Type AssociatedObjectTypeConstraint { get; }
    public TriggerActionCollection Actions { get; }
    private DependencyObject Microsoft.Xaml.Behaviors.IAttachedObject.AssociatedObject { get; }
    internal TriggerBase(Type associatedObjectTypeConstraint);
    private static TriggerBase();
    protected DependencyObject get_AssociatedObject();
    protected virtual Type get_AssociatedObjectTypeConstraint();
    public TriggerActionCollection get_Actions();
    [CompilerGeneratedAttribute]
public void add_PreviewInvoke(EventHandler`1<PreviewInvokeEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreviewInvoke(EventHandler`1<PreviewInvokeEventArgs> value);
    protected void InvokeActions(object parameter);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    protected virtual Freezable CreateInstanceCore();
    private sealed virtual override DependencyObject Microsoft.Xaml.Behaviors.IAttachedObject.get_AssociatedObject();
    public sealed virtual void Attach(DependencyObject dependencyObject);
    public sealed virtual void Detach();
}
public abstract class Microsoft.Xaml.Behaviors.TriggerBase`1 : TriggerBase {
    protected T AssociatedObject { get; }
    protected Type AssociatedObjectTypeConstraint { get; }
    protected T get_AssociatedObject();
    protected sealed virtual Type get_AssociatedObjectTypeConstraint();
}
public class Microsoft.Xaml.Behaviors.TriggerCollection : AttachableCollection`1<TriggerBase> {
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    internal virtual void ItemAdded(TriggerBase item);
    internal virtual void ItemRemoved(TriggerBase item);
    protected virtual Freezable CreateInstanceCore();
}
[AttributeUsageAttribute("4")]
public class Microsoft.Xaml.Behaviors.TypeConstraintAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Constraint>k__BackingField;
    public Type Constraint { get; private set; }
    public TypeConstraintAttribute(Type constraint);
    [CompilerGeneratedAttribute]
public Type get_Constraint();
    [CompilerGeneratedAttribute]
private void set_Constraint(Type value);
}
internal static class Microsoft.Xaml.Behaviors.TypeConverterHelper : object {
    internal static object DoConversionFrom(TypeConverter converter, object value);
    private static bool ShouldEatException(Exception e);
    internal static TypeConverter GetTypeConverter(Type type);
}
public static class Microsoft.Xaml.Behaviors.VisualStateUtilities : object {
    public static bool GoToState(FrameworkElement element, string stateName, bool useTransitions);
    public static IList GetVisualStateGroups(FrameworkElement targetObject);
    public static bool TryFindNearestStatefulControl(FrameworkElement contextElement, FrameworkElement& resolvedControl);
    private static bool HasVisualStateGroupsDefined(FrameworkElement frameworkElement);
    internal static FrameworkElement FindNearestStatefulControl(FrameworkElement contextElement);
    private static bool ShouldContinueTreeWalk(FrameworkElement element);
    private static FrameworkElement FindTemplatedParent(FrameworkElement parent);
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.3.37.35081")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
