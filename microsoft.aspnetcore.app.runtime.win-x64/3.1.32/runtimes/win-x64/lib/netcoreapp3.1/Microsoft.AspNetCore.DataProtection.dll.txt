[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.ActivatorExtensions : object {
    [ExtensionAttribute]
public static T CreateInstance(IActivator activator, string implementationTypeName);
    [ExtensionAttribute]
public static IActivator GetActivator(IServiceProvider serviceProvider);
}
[AttributeUsageAttribute("128")]
internal class Microsoft.AspNetCore.DataProtection.ApplyPolicyAttribute : Attribute {
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.ArraySegmentExtensions : object {
    [ExtensionAttribute]
public static Byte[] AsStandaloneArray(ArraySegment`1<byte> arraySegment);
    [ExtensionAttribute]
public static void Validate(ArraySegment`1<T> arraySegment);
}
internal static class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.AlgorithmAssert : object {
    private static UInt32 SYMMETRIC_ALG_MIN_BLOCK_SIZE_IN_BITS;
    private static UInt32 SYMMETRIC_ALG_MIN_KEY_LENGTH_IN_BITS;
    private static UInt32 HASH_ALG_MIN_DIGEST_LENGTH_IN_BITS;
    private static UInt32 MAX_SIZE_IN_BITS;
    public static void IsAllowableSymmetricAlgorithmBlockSize(UInt32 blockSizeInBits);
    public static void IsAllowableSymmetricAlgorithmKeySize(UInt32 keySizeInBits);
    public static void IsAllowableValidationAlgorithmDigestSize(UInt32 digestSizeInBits);
    private static bool IsValidCore(UInt32 value, UInt32 minValue);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.AuthenticatedEncryptorExtensions : object {
    [ExtensionAttribute]
public static Byte[] Encrypt(IAuthenticatedEncryptor encryptor, ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData, UInt32 preBufferSize, UInt32 postBufferSize);
    [ExtensionAttribute]
public static void PerformSelfTest(IAuthenticatedEncryptor encryptor);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.AuthenticatedEncryptorFactory : object {
    private ILoggerFactory _loggerFactory;
    public AuthenticatedEncryptorFactory(ILoggerFactory loggerFactory);
    public sealed virtual IAuthenticatedEncryptor CreateEncryptorInstance(IKey key);
    internal IAuthenticatedEncryptor CreateAuthenticatedEncryptorInstance(ISecret secret, AuthenticatedEncryptorConfiguration authenticatedConfiguration);
    internal static bool IsGcmAlgorithm(EncryptionAlgorithm algorithm);
    private static int GetAlgorithmKeySizeInBits(EncryptionAlgorithm algorithm);
    private static string GetBCryptAlgorithmNameFromEncryptionAlgorithm(EncryptionAlgorithm algorithm);
    private static string GetBCryptAlgorithmNameFromValidationAlgorithm(ValidationAlgorithm algorithm);
    private static Type GetManagedTypeFromEncryptionAlgorithm(EncryptionAlgorithm algorithm);
    private static Type GetManagedTypeFromValidationAlgorithm(ValidationAlgorithm algorithm);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngCbcAuthenticatedEncryptorFactory : object {
    private ILogger _logger;
    public CngCbcAuthenticatedEncryptorFactory(ILoggerFactory loggerFactory);
    public sealed virtual IAuthenticatedEncryptor CreateEncryptorInstance(IKey key);
    internal CbcAuthenticatedEncryptor CreateAuthenticatedEncryptorInstance(ISecret secret, CngCbcAuthenticatedEncryptorConfiguration configuration);
    private BCryptAlgorithmHandle GetHmacAlgorithmHandle(CngCbcAuthenticatedEncryptorConfiguration configuration);
    private BCryptAlgorithmHandle GetSymmetricBlockCipherAlgorithmHandle(CngCbcAuthenticatedEncryptorConfiguration configuration);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngGcmAuthenticatedEncryptorFactory : object {
    private ILogger _logger;
    public CngGcmAuthenticatedEncryptorFactory(ILoggerFactory loggerFactory);
    public sealed virtual IAuthenticatedEncryptor CreateEncryptorInstance(IKey key);
    internal GcmAuthenticatedEncryptor CreateAuthenticatedEncryptorInstance(ISecret secret, CngGcmAuthenticatedEncryptorConfiguration configuration);
    private BCryptAlgorithmHandle GetSymmetricBlockCipherAlgorithmHandle(CngGcmAuthenticatedEncryptorConfiguration configuration);
}
public abstract class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration : object {
    internal static int KDK_SIZE_IN_BYTES;
    public abstract virtual IAuthenticatedEncryptorDescriptor CreateNewDescriptor();
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration : AlgorithmConfiguration {
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationAlgorithm <ValidationAlgorithm>k__BackingField;
    public EncryptionAlgorithm EncryptionAlgorithm { get; public set; }
    public ValidationAlgorithm ValidationAlgorithm { get; public set; }
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithm(EncryptionAlgorithm value);
    [CompilerGeneratedAttribute]
public ValidationAlgorithm get_ValidationAlgorithm();
    [CompilerGeneratedAttribute]
public void set_ValidationAlgorithm(ValidationAlgorithm value);
    public virtual IAuthenticatedEncryptorDescriptor CreateNewDescriptor();
    private sealed virtual override IAuthenticatedEncryptorDescriptor Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.CreateDescriptorFromSecret(ISecret secret);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.Validate();
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptor : object {
    [CompilerGeneratedAttribute]
private ISecret <MasterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticatedEncryptorConfiguration <Configuration>k__BackingField;
    internal ISecret MasterKey { get; }
    internal AuthenticatedEncryptorConfiguration Configuration { get; }
    public AuthenticatedEncryptorDescriptor(AuthenticatedEncryptorConfiguration configuration, ISecret masterKey);
    [CompilerGeneratedAttribute]
internal ISecret get_MasterKey();
    [CompilerGeneratedAttribute]
internal AuthenticatedEncryptorConfiguration get_Configuration();
    public sealed virtual XmlSerializedDescriptorInfo ExportToXml();
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptorDeserializer : object {
    public sealed virtual IAuthenticatedEncryptorDescriptor ImportFromXml(XElement element);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration : AlgorithmConfiguration {
    [CompilerGeneratedAttribute]
private string <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionAlgorithmProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EncryptionAlgorithmKeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashAlgorithmProvider>k__BackingField;
    [ApplyPolicyAttribute]
public string EncryptionAlgorithm { get; public set; }
    [ApplyPolicyAttribute]
public string EncryptionAlgorithmProvider { get; public set; }
    [ApplyPolicyAttribute]
public int EncryptionAlgorithmKeySize { get; public set; }
    [ApplyPolicyAttribute]
public string HashAlgorithm { get; public set; }
    [ApplyPolicyAttribute]
public string HashAlgorithmProvider { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionAlgorithmProvider();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmProvider(string value);
    [CompilerGeneratedAttribute]
public int get_EncryptionAlgorithmKeySize();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmKeySize(int value);
    [CompilerGeneratedAttribute]
public string get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_HashAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_HashAlgorithmProvider();
    [CompilerGeneratedAttribute]
public void set_HashAlgorithmProvider(string value);
    public virtual IAuthenticatedEncryptorDescriptor CreateNewDescriptor();
    private sealed virtual override IAuthenticatedEncryptorDescriptor Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.CreateDescriptorFromSecret(ISecret secret);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.Validate();
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorDescriptor : object {
    [CompilerGeneratedAttribute]
private ISecret <MasterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private CngCbcAuthenticatedEncryptorConfiguration <Configuration>k__BackingField;
    internal ISecret MasterKey { get; }
    internal CngCbcAuthenticatedEncryptorConfiguration Configuration { get; }
    public CngCbcAuthenticatedEncryptorDescriptor(CngCbcAuthenticatedEncryptorConfiguration configuration, ISecret masterKey);
    [CompilerGeneratedAttribute]
internal ISecret get_MasterKey();
    [CompilerGeneratedAttribute]
internal CngCbcAuthenticatedEncryptorConfiguration get_Configuration();
    public sealed virtual XmlSerializedDescriptorInfo ExportToXml();
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorDescriptorDeserializer : object {
    public sealed virtual IAuthenticatedEncryptorDescriptor ImportFromXml(XElement element);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration : AlgorithmConfiguration {
    [CompilerGeneratedAttribute]
private string <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionAlgorithmProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EncryptionAlgorithmKeySize>k__BackingField;
    [ApplyPolicyAttribute]
public string EncryptionAlgorithm { get; public set; }
    [ApplyPolicyAttribute]
public string EncryptionAlgorithmProvider { get; public set; }
    [ApplyPolicyAttribute]
public int EncryptionAlgorithmKeySize { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionAlgorithmProvider();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmProvider(string value);
    [CompilerGeneratedAttribute]
public int get_EncryptionAlgorithmKeySize();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmKeySize(int value);
    public virtual IAuthenticatedEncryptorDescriptor CreateNewDescriptor();
    private sealed virtual override IAuthenticatedEncryptorDescriptor Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.CreateDescriptorFromSecret(ISecret secret);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.Validate();
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorDescriptor : object {
    [CompilerGeneratedAttribute]
private ISecret <MasterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private CngGcmAuthenticatedEncryptorConfiguration <Configuration>k__BackingField;
    internal ISecret MasterKey { get; }
    internal CngGcmAuthenticatedEncryptorConfiguration Configuration { get; }
    public CngGcmAuthenticatedEncryptorDescriptor(CngGcmAuthenticatedEncryptorConfiguration configuration, ISecret masterKey);
    [CompilerGeneratedAttribute]
internal ISecret get_MasterKey();
    [CompilerGeneratedAttribute]
internal CngGcmAuthenticatedEncryptorConfiguration get_Configuration();
    public sealed virtual XmlSerializedDescriptorInfo ExportToXml();
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorDescriptorDeserializer : object {
    public sealed virtual IAuthenticatedEncryptorDescriptor ImportFromXml(XElement element);
}
public interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
    public abstract virtual XmlSerializedDescriptorInfo ExportToXml();
}
public interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptorDeserializer {
    public abstract virtual IAuthenticatedEncryptorDescriptor ImportFromXml(XElement element);
}
internal interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration {
    public abstract virtual IAuthenticatedEncryptorDescriptor CreateDescriptorFromSecret(ISecret secret);
    public abstract virtual void Validate();
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration : AlgorithmConfiguration {
    [CompilerGeneratedAttribute]
private Type <EncryptionAlgorithmType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EncryptionAlgorithmKeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ValidationAlgorithmType>k__BackingField;
    [ApplyPolicyAttribute]
public Type EncryptionAlgorithmType { get; public set; }
    [ApplyPolicyAttribute]
public int EncryptionAlgorithmKeySize { get; public set; }
    [ApplyPolicyAttribute]
public Type ValidationAlgorithmType { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_EncryptionAlgorithmType();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmType(Type value);
    [CompilerGeneratedAttribute]
public int get_EncryptionAlgorithmKeySize();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmKeySize(int value);
    [CompilerGeneratedAttribute]
public Type get_ValidationAlgorithmType();
    [CompilerGeneratedAttribute]
public void set_ValidationAlgorithmType(Type value);
    public virtual IAuthenticatedEncryptorDescriptor CreateNewDescriptor();
    private sealed virtual override IAuthenticatedEncryptorDescriptor Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.CreateDescriptorFromSecret(ISecret secret);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.Validate();
    private static string TypeToFriendlyName(Type type);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorDescriptor : object {
    [CompilerGeneratedAttribute]
private ISecret <MasterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedAuthenticatedEncryptorConfiguration <Configuration>k__BackingField;
    internal ISecret MasterKey { get; }
    internal ManagedAuthenticatedEncryptorConfiguration Configuration { get; }
    public ManagedAuthenticatedEncryptorDescriptor(ManagedAuthenticatedEncryptorConfiguration configuration, ISecret masterKey);
    [CompilerGeneratedAttribute]
internal ISecret get_MasterKey();
    [CompilerGeneratedAttribute]
internal ManagedAuthenticatedEncryptorConfiguration get_Configuration();
    public sealed virtual XmlSerializedDescriptorInfo ExportToXml();
    private static string TypeToFriendlyName(Type type);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorDescriptorDeserializer : object {
    public sealed virtual IAuthenticatedEncryptorDescriptor ImportFromXml(XElement element);
    private static Type FriendlyNameToType(string typeName);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.SecretExtensions : object {
    [ExtensionAttribute]
public static XElement ToMasterKeyElement(ISecret secret);
    [ExtensionAttribute]
public static Secret ToSecret(string base64String);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlExtensions : object {
    [ExtensionAttribute]
internal static bool IsMarkedAsRequiringEncryption(XElement element);
    [ExtensionAttribute]
public static void MarkAsRequiresEncryption(XElement element);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo : object {
    [CompilerGeneratedAttribute]
private Type <DeserializerType>k__BackingField;
    [CompilerGeneratedAttribute]
private XElement <SerializedDescriptorElement>k__BackingField;
    public Type DeserializerType { get; }
    public XElement SerializedDescriptorElement { get; }
    public XmlSerializedDescriptorInfo(XElement serializedDescriptorElement, Type deserializerType);
    [CompilerGeneratedAttribute]
public Type get_DeserializerType();
    [CompilerGeneratedAttribute]
public XElement get_SerializedDescriptorElement();
}
public enum Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm : Enum {
    public int value__;
    public static EncryptionAlgorithm AES_128_CBC;
    public static EncryptionAlgorithm AES_192_CBC;
    public static EncryptionAlgorithm AES_256_CBC;
    public static EncryptionAlgorithm AES_128_GCM;
    public static EncryptionAlgorithm AES_192_GCM;
    public static EncryptionAlgorithm AES_256_GCM;
}
public interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor {
    public abstract virtual Byte[] Decrypt(ArraySegment`1<byte> ciphertext, ArraySegment`1<byte> additionalAuthenticatedData);
    public abstract virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData);
}
public interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptorFactory {
    public abstract virtual IAuthenticatedEncryptor CreateEncryptorInstance(IKey key);
}
internal interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IOptimizedAuthenticatedEncryptor {
    public abstract virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData, UInt32 preBufferSize, UInt32 postBufferSize);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ManagedAuthenticatedEncryptorFactory : object {
    private ILogger _logger;
    public ManagedAuthenticatedEncryptorFactory(ILoggerFactory loggerFactory);
    public sealed virtual IAuthenticatedEncryptor CreateEncryptorInstance(IKey key);
    internal ManagedAuthenticatedEncryptor CreateAuthenticatedEncryptorInstance(ISecret secret, ManagedAuthenticatedEncryptorConfiguration configuration);
    private Func`1<KeyedHashAlgorithm> GetKeyedHashAlgorithmFactory(ManagedAuthenticatedEncryptorConfiguration configuration);
    private Func`1<SymmetricAlgorithm> GetSymmetricBlockCipherAlgorithmFactory(ManagedAuthenticatedEncryptorConfiguration configuration);
}
public enum Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm : Enum {
    public int value__;
    public static ValidationAlgorithm HMACSHA256;
    public static ValidationAlgorithm HMACSHA512;
}
internal static class Microsoft.AspNetCore.DataProtection.BitHelpers : object {
    public static void WriteTo(Void* ptr, UInt32 value);
    public static void WriteTo(Byte*& ptr, UInt32 value);
    public static void WriteTo(Byte[] buffer, Int32& idx, int value);
    public static void WriteTo(Byte[] buffer, Int32& idx, UInt32 value);
}
internal class Microsoft.AspNetCore.DataProtection.Cng.BCryptGenRandomImpl : object {
    public static BCryptGenRandomImpl Instance;
    private static BCryptGenRandomImpl();
    public sealed virtual void GenRandom(Byte* pbBuffer, UInt32 cbBuffer);
}
internal class Microsoft.AspNetCore.DataProtection.Cng.CbcAuthenticatedEncryptor : CngAuthenticatedEncryptorBase {
    private static UInt32 KEY_MODIFIER_SIZE_IN_BYTES;
    private Byte[] _contextHeader;
    private IBCryptGenRandom _genRandom;
    private BCryptAlgorithmHandle _hmacAlgorithmHandle;
    private UInt32 _hmacAlgorithmDigestLengthInBytes;
    private UInt32 _hmacAlgorithmSubkeyLengthInBytes;
    private ISP800_108_CTR_HMACSHA512Provider _sp800_108_ctr_hmac_provider;
    private BCryptAlgorithmHandle _symmetricAlgorithmHandle;
    private UInt32 _symmetricAlgorithmBlockSizeInBytes;
    private UInt32 _symmetricAlgorithmSubkeyLengthInBytes;
    public CbcAuthenticatedEncryptor(Secret keyDerivationKey, BCryptAlgorithmHandle symmetricAlgorithmHandle, UInt32 symmetricAlgorithmKeySizeInBytes, BCryptAlgorithmHandle hmacAlgorithmHandle, IBCryptGenRandom genRandom);
    private Byte[] CreateContextHeader();
    protected virtual Byte[] DecryptImpl(Byte* pbCiphertext, UInt32 cbCiphertext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData);
    public virtual void Dispose();
    private Byte[] DoCbcDecrypt(BCryptKeyHandle symmetricKeyHandle, Byte* pbIV, Byte* pbInput, UInt32 cbInput);
    private void DoCbcEncrypt(BCryptKeyHandle symmetricKeyHandle, Byte* pbIV, Byte* pbInput, UInt32 cbInput, Byte* pbOutput, UInt32 cbOutput);
    protected virtual Byte[] EncryptImpl(Byte* pbPlaintext, UInt32 cbPlaintext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData, UInt32 cbPreBuffer, UInt32 cbPostBuffer);
    private UInt32 GetCbcEncryptedOutputSizeWithPadding(BCryptKeyHandle symmetricKeyHandle, Byte* pbInput, UInt32 cbInput);
    private bool ValidateHash(BCryptHashHandle hashHandle, Byte* pbInput, UInt32 cbInput, Byte* pbExpectedDigest);
}
internal static class Microsoft.AspNetCore.DataProtection.Cng.DpapiSecretSerializerHelper : object {
    private static UInt32 NCRYPT_SILENT_FLAG;
    private static UInt32 CRYPTPROTECT_UI_FORBIDDEN;
    private static UInt32 CRYPTPROTECT_LOCAL_MACHINE;
    private static Byte[] _purpose;
    private static DpapiSecretSerializerHelper();
    public static bool CanProtectToCurrentUserAccount();
    public static Byte[] ProtectWithDpapi(ISecret secret, bool protectToLocalMachine);
    internal static Byte[] ProtectWithDpapiCore(Byte* pbSecret, UInt32 cbSecret, Byte* pbOptionalEntropy, UInt32 cbOptionalEntropy, bool fLocalMachine);
    public static Byte[] ProtectWithDpapiNG(ISecret secret, NCryptDescriptorHandle protectionDescriptorHandle);
    private static Byte[] ProtectWithDpapiNGCore(NCryptDescriptorHandle protectionDescriptorHandle, Byte* pbData, UInt32 cbData);
    public static Secret UnprotectWithDpapi(Byte[] protectedSecret);
    internal static Secret UnprotectWithDpapiCore(Byte* pbProtectedData, UInt32 cbProtectedData, Byte* pbOptionalEntropy, UInt32 cbOptionalEntropy);
    public static Secret UnprotectWithDpapiNG(Byte[] protectedData);
    private static Secret UnprotectWithDpapiNGCore(Byte* pbData, UInt32 cbData);
    public static string GetRuleFromDpapiNGProtectedPayload(Byte[] protectedData);
    private static string GetRuleFromDpapiNGProtectedPayloadCore(Byte* pbData, UInt32 cbData);
}
internal class Microsoft.AspNetCore.DataProtection.Cng.GcmAuthenticatedEncryptor : CngAuthenticatedEncryptorBase {
    private static UInt32 KEY_MODIFIER_SIZE_IN_BYTES;
    private static UInt32 NONCE_SIZE_IN_BYTES;
    private static UInt32 TAG_SIZE_IN_BYTES;
    private Byte[] _contextHeader;
    private IBCryptGenRandom _genRandom;
    private ISP800_108_CTR_HMACSHA512Provider _sp800_108_ctr_hmac_provider;
    private BCryptAlgorithmHandle _symmetricAlgorithmHandle;
    private UInt32 _symmetricAlgorithmSubkeyLengthInBytes;
    public GcmAuthenticatedEncryptor(Secret keyDerivationKey, BCryptAlgorithmHandle symmetricAlgorithmHandle, UInt32 symmetricAlgorithmKeySizeInBytes, IBCryptGenRandom genRandom);
    private Byte[] CreateContextHeader();
    protected virtual Byte[] DecryptImpl(Byte* pbCiphertext, UInt32 cbCiphertext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData);
    public virtual void Dispose();
    private void DoGcmEncrypt(Byte* pbKey, UInt32 cbKey, Byte* pbNonce, Byte* pbPlaintextData, UInt32 cbPlaintextData, Byte* pbEncryptedData, Byte* pbTag);
    protected virtual Byte[] EncryptImpl(Byte* pbPlaintext, UInt32 cbPlaintext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData, UInt32 cbPreBuffer, UInt32 cbPostBuffer);
}
internal interface Microsoft.AspNetCore.DataProtection.Cng.IBCryptGenRandom {
    public abstract virtual void GenRandom(Byte* pbBuffer, UInt32 cbBuffer);
}
internal abstract class Microsoft.AspNetCore.DataProtection.Cng.Internal.CngAuthenticatedEncryptorBase : object {
    public sealed virtual Byte[] Decrypt(ArraySegment`1<byte> ciphertext, ArraySegment`1<byte> additionalAuthenticatedData);
    protected abstract virtual Byte[] DecryptImpl(Byte* pbCiphertext, UInt32 cbCiphertext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData);
    public abstract virtual void Dispose();
    public sealed virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData);
    public sealed virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData, UInt32 preBufferSize, UInt32 postBufferSize);
    protected abstract virtual Byte[] EncryptImpl(Byte* pbPlaintext, UInt32 cbPlaintext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData, UInt32 cbPreBuffer, UInt32 cbPostBuffer);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions : object {
    [ExtensionAttribute]
public static IDataProtectionBuilder SetApplicationName(IDataProtectionBuilder builder, string applicationName);
    [ExtensionAttribute]
public static IDataProtectionBuilder AddKeyEscrowSink(IDataProtectionBuilder builder, IKeyEscrowSink sink);
    [ExtensionAttribute]
public static IDataProtectionBuilder AddKeyEscrowSink(IDataProtectionBuilder builder);
    [ExtensionAttribute]
public static IDataProtectionBuilder AddKeyEscrowSink(IDataProtectionBuilder builder, Func`2<IServiceProvider, IKeyEscrowSink> factory);
    [ExtensionAttribute]
public static IDataProtectionBuilder AddKeyManagementOptions(IDataProtectionBuilder builder, Action`1<KeyManagementOptions> setupAction);
    [ExtensionAttribute]
public static IDataProtectionBuilder DisableAutomaticKeyGeneration(IDataProtectionBuilder builder);
    [ExtensionAttribute]
public static IDataProtectionBuilder PersistKeysToFileSystem(IDataProtectionBuilder builder, DirectoryInfo directory);
    [ExtensionAttribute]
public static IDataProtectionBuilder PersistKeysToRegistry(IDataProtectionBuilder builder, RegistryKey registryKey);
    [ExtensionAttribute]
public static IDataProtectionBuilder ProtectKeysWithCertificate(IDataProtectionBuilder builder, X509Certificate2 certificate);
    [ExtensionAttribute]
public static IDataProtectionBuilder ProtectKeysWithCertificate(IDataProtectionBuilder builder, string thumbprint);
    [ExtensionAttribute]
public static IDataProtectionBuilder UnprotectKeysWithAnyCertificate(IDataProtectionBuilder builder, X509Certificate2[] certificates);
    [ExtensionAttribute]
public static IDataProtectionBuilder ProtectKeysWithDpapi(IDataProtectionBuilder builder);
    [ExtensionAttribute]
public static IDataProtectionBuilder ProtectKeysWithDpapi(IDataProtectionBuilder builder, bool protectToLocalMachine);
    [ExtensionAttribute]
public static IDataProtectionBuilder ProtectKeysWithDpapiNG(IDataProtectionBuilder builder);
    [ExtensionAttribute]
public static IDataProtectionBuilder ProtectKeysWithDpapiNG(IDataProtectionBuilder builder, string protectionDescriptorRule, DpapiNGProtectionDescriptorFlags flags);
    [ExtensionAttribute]
public static IDataProtectionBuilder SetDefaultKeyLifetime(IDataProtectionBuilder builder, TimeSpan lifetime);
    [ExtensionAttribute]
public static IDataProtectionBuilder UseCryptographicAlgorithms(IDataProtectionBuilder builder, AuthenticatedEncryptorConfiguration configuration);
    [ExtensionAttribute]
[EditorBrowsableAttribute("2")]
public static IDataProtectionBuilder UseCustomCryptographicAlgorithms(IDataProtectionBuilder builder, CngCbcAuthenticatedEncryptorConfiguration configuration);
    [ExtensionAttribute]
[EditorBrowsableAttribute("2")]
public static IDataProtectionBuilder UseCustomCryptographicAlgorithms(IDataProtectionBuilder builder, CngGcmAuthenticatedEncryptorConfiguration configuration);
    [EditorBrowsableAttribute("2")]
[ExtensionAttribute]
public static IDataProtectionBuilder UseCustomCryptographicAlgorithms(IDataProtectionBuilder builder, ManagedAuthenticatedEncryptorConfiguration configuration);
    private static IDataProtectionBuilder UseCryptographicAlgorithmsCore(IDataProtectionBuilder builder, AlgorithmConfiguration configuration);
    [ExtensionAttribute]
public static IDataProtectionBuilder UseEphemeralDataProtectionProvider(IDataProtectionBuilder builder);
}
public class Microsoft.AspNetCore.DataProtection.DataProtectionOptions : object {
    [CompilerGeneratedAttribute]
private string <ApplicationDiscriminator>k__BackingField;
    public string ApplicationDiscriminator { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ApplicationDiscriminator();
    [CompilerGeneratedAttribute]
public void set_ApplicationDiscriminator(string value);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.DataProtection.DataProtectionUtilityExtensions : object {
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static string GetApplicationUniqueIdentifier(IServiceProvider services);
}
internal static class Microsoft.AspNetCore.DataProtection.EncodingUtil : object {
    public static UTF8Encoding SecureUtf8Encoding;
    private static EncodingUtil();
}
public class Microsoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider : object {
    private KeyRingBasedDataProtectionProvider _dataProtectionProvider;
    public EphemeralDataProtectionProvider(ILoggerFactory loggerFactory);
    public sealed virtual IDataProtector CreateProtector(string purpose);
}
internal static class Microsoft.AspNetCore.DataProtection.Error : object {
    public static InvalidOperationException CertificateXmlEncryptor_CertificateNotFound(string thumbprint);
    public static ArgumentException Common_ArgumentCannotBeNullOrEmpty(string parameterName);
    public static ArgumentException Common_BufferIncorrectlySized(string parameterName, int actualSize, int expectedSize);
    public static CryptographicException CryptCommon_GenericError(Exception inner);
    public static CryptographicException CryptCommon_PayloadInvalid();
    public static InvalidOperationException Common_PropertyCannotBeNullOrEmpty(string propertyName);
    public static InvalidOperationException Common_PropertyMustBeNonNegative(string propertyName);
    public static CryptographicException Common_EncryptionFailed(Exception inner);
    public static CryptographicException Common_KeyNotFound(Guid id);
    public static CryptographicException Common_KeyRevoked(Guid id);
    public static ArgumentOutOfRangeException Common_ValueMustBeNonNegative(string paramName);
    public static CryptographicException DecryptionFailed(Exception inner);
    public static CryptographicException ProtectionProvider_BadMagicHeader();
    public static CryptographicException ProtectionProvider_BadVersion();
    public static InvalidOperationException XmlKeyManager_DuplicateKey(Guid keyId);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.ExceptionExtensions : object {
    [ExtensionAttribute]
public static bool RequiresHomogenization(Exception ex);
}
public interface Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
    public IServiceCollection Services { get; }
    public abstract virtual IServiceCollection get_Services();
}
internal static class Microsoft.AspNetCore.DataProtection.Internal.ContainerUtils : object {
    private static Lazy`1<bool> _isContainer;
    private static string RunningInContainerVariableName;
    private static string DeprecatedRunningInContainerVariableName;
    public static bool IsContainer { get; }
    private static ContainerUtils();
    public static bool get_IsContainer();
    public static bool IsVolumeMountedFolder(DirectoryInfo directory);
    internal static bool IsDirectoryMounted(DirectoryInfo directory, IEnumerable`1<string> fstab);
    private static bool IsProcessRunningInContainer();
    private static bool GetBooleanEnvVar(string envVarName);
}
internal class Microsoft.AspNetCore.DataProtection.Internal.DataProtectionBuilder : object {
    [CompilerGeneratedAttribute]
private IServiceCollection <Services>k__BackingField;
    public IServiceCollection Services { get; }
    public DataProtectionBuilder(IServiceCollection services);
    [CompilerGeneratedAttribute]
public sealed virtual IServiceCollection get_Services();
}
internal class Microsoft.AspNetCore.DataProtection.Internal.DataProtectionHostedService : object {
    private IKeyRingProvider _keyRingProvider;
    private ILogger`1<DataProtectionHostedService> _logger;
    public DataProtectionHostedService(IKeyRingProvider keyRingProvider);
    public DataProtectionHostedService(IKeyRingProvider keyRingProvider, ILoggerFactory loggerFactory);
    public sealed virtual Task StartAsync(CancellationToken token);
    public sealed virtual Task StopAsync(CancellationToken token);
}
internal class Microsoft.AspNetCore.DataProtection.Internal.DataProtectionOptionsSetup : object {
    private IServiceProvider _services;
    public DataProtectionOptionsSetup(IServiceProvider provider);
    public sealed virtual void Configure(DataProtectionOptions options);
}
internal class Microsoft.AspNetCore.DataProtection.Internal.HostingApplicationDiscriminator : object {
    private IHostEnvironment _hosting;
    public string Discriminator { get; }
    public HostingApplicationDiscriminator(IHostEnvironment hosting);
    public sealed virtual string get_Discriminator();
}
public interface Microsoft.AspNetCore.DataProtection.Internal.IActivator {
    public abstract virtual object CreateInstance(Type expectedBaseType, string implementationTypeName);
}
internal class Microsoft.AspNetCore.DataProtection.Internal.KeyManagementOptionsSetup : object {
    private IRegistryPolicyResolver _registryPolicyResolver;
    private ILoggerFactory _loggerFactory;
    public KeyManagementOptionsSetup(ILoggerFactory loggerFactory);
    public KeyManagementOptionsSetup(IRegistryPolicyResolver registryPolicyResolver);
    public KeyManagementOptionsSetup(ILoggerFactory loggerFactory, IRegistryPolicyResolver registryPolicyResolver);
    public sealed virtual void Configure(KeyManagementOptions options);
}
public interface Microsoft.AspNetCore.DataProtection.IPersistedDataProtector {
    public abstract virtual Byte[] DangerousUnprotect(Byte[] protectedData, bool ignoreRevocationErrors, Boolean& requiresMigration, Boolean& wasRevoked);
}
internal interface Microsoft.AspNetCore.DataProtection.IRegistryPolicyResolver {
    public abstract virtual RegistryPolicy ResolvePolicy();
}
public interface Microsoft.AspNetCore.DataProtection.ISecret {
    public int Length { get; }
    public abstract virtual int get_Length();
    public abstract virtual void WriteSecretIntoBuffer(ArraySegment`1<byte> buffer);
}
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.DefaultKeyResolver : object {
    private TimeSpan _keyPropagationWindow;
    private ILogger _logger;
    private TimeSpan _maxServerToServerClockSkew;
    public DefaultKeyResolver(IOptions`1<KeyManagementOptions> keyManagementOptions);
    public DefaultKeyResolver(IOptions`1<KeyManagementOptions> keyManagementOptions, ILoggerFactory loggerFactory);
    private bool CanCreateAuthenticatedEncryptor(IKey key);
    private IKey FindDefaultKey(DateTimeOffset now, IEnumerable`1<IKey> allKeys, IKey& fallbackKey, Boolean& callerShouldGenerateNewKey);
    public sealed virtual DefaultKeyResolution ResolveDefaultKeyPolicy(DateTimeOffset now, IEnumerable`1<IKey> allKeys);
}
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.DeferredKey : KeyBase {
    public DeferredKey(Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate, IInternalXmlKeyManager keyManager, XElement keyElement, IEnumerable`1<IAuthenticatedEncryptorFactory> encryptorFactories);
    private static Func`1<IAuthenticatedEncryptorDescriptor> GetLazyDescriptorDelegate(IInternalXmlKeyManager keyManager, XElement keyElement);
}
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.IKey {
    public DateTimeOffset ActivationDate { get; }
    public DateTimeOffset CreationDate { get; }
    public DateTimeOffset ExpirationDate { get; }
    public bool IsRevoked { get; }
    public Guid KeyId { get; }
    public IAuthenticatedEncryptorDescriptor Descriptor { get; }
    public abstract virtual DateTimeOffset get_ActivationDate();
    public abstract virtual DateTimeOffset get_CreationDate();
    public abstract virtual DateTimeOffset get_ExpirationDate();
    public abstract virtual bool get_IsRevoked();
    public abstract virtual Guid get_KeyId();
    public abstract virtual IAuthenticatedEncryptorDescriptor get_Descriptor();
    public abstract virtual IAuthenticatedEncryptor CreateEncryptor();
}
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink {
    public abstract virtual void Store(Guid keyId, XElement element);
}
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyManager {
    public abstract virtual IKey CreateNewKey(DateTimeOffset activationDate, DateTimeOffset expirationDate);
    public abstract virtual IReadOnlyCollection`1<IKey> GetAllKeys();
    public abstract virtual CancellationToken GetCacheExpirationToken();
    public abstract virtual void RevokeKey(Guid keyId, string reason);
    public abstract virtual void RevokeAllKeys(DateTimeOffset revocationDate, string reason);
}
public class Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.CacheableKeyRing : object {
    private CancellationToken _expirationToken;
    [CompilerGeneratedAttribute]
private DateTime <ExpirationTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyRing <KeyRing>k__BackingField;
    internal DateTime ExpirationTimeUtc { get; }
    internal IKeyRing KeyRing { get; }
    internal CacheableKeyRing(CancellationToken expirationToken, DateTimeOffset expirationTime, IKey defaultKey, IEnumerable`1<IKey> allKeys);
    internal CacheableKeyRing(CancellationToken expirationToken, DateTimeOffset expirationTime, IKeyRing keyRing);
    [CompilerGeneratedAttribute]
internal DateTime get_ExpirationTimeUtc();
    [CompilerGeneratedAttribute]
internal IKeyRing get_KeyRing();
    internal static bool IsValid(CacheableKeyRing keyRing, DateTime utcNow);
    internal CacheableKeyRing WithTemporaryExtendedLifetime(DateTimeOffset now);
}
public class Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.DefaultKeyResolution : ValueType {
    public IKey DefaultKey;
    public IKey FallbackKey;
    public bool ShouldGenerateNewKey;
}
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.ICacheableKeyRingProvider {
    public abstract virtual CacheableKeyRing GetCacheableKeyRing(DateTimeOffset now);
}
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IDefaultKeyResolver {
    public abstract virtual DefaultKeyResolution ResolveDefaultKeyPolicy(DateTimeOffset now, IEnumerable`1<IKey> allKeys);
}
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager {
    public abstract virtual IKey CreateNewKey(Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate);
    public abstract virtual IAuthenticatedEncryptorDescriptor DeserializeDescriptorFromKeyElement(XElement keyElement);
    public abstract virtual void RevokeSingleKey(Guid keyId, DateTimeOffset revocationDate, string reason);
}
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRing {
    public IAuthenticatedEncryptor DefaultAuthenticatedEncryptor { get; }
    public Guid DefaultKeyId { get; }
    public abstract virtual IAuthenticatedEncryptor get_DefaultAuthenticatedEncryptor();
    public abstract virtual Guid get_DefaultKeyId();
    public abstract virtual IAuthenticatedEncryptor GetAuthenticatedEncryptorByKeyId(Guid keyId, Boolean& isRevoked);
}
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRingProvider {
    public abstract virtual IKeyRing GetCurrentKeyRing();
}
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.Key : KeyBase {
    public Key(Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate, IAuthenticatedEncryptorDescriptor descriptor, IEnumerable`1<IAuthenticatedEncryptorFactory> encryptorFactories);
}
internal abstract class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyBase : object {
    private Lazy`1<IAuthenticatedEncryptorDescriptor> _lazyDescriptor;
    private IEnumerable`1<IAuthenticatedEncryptorFactory> _encryptorFactories;
    private IAuthenticatedEncryptor _encryptor;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ActivationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpirationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRevoked>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <KeyId>k__BackingField;
    public DateTimeOffset ActivationDate { get; }
    public DateTimeOffset CreationDate { get; }
    public DateTimeOffset ExpirationDate { get; }
    public bool IsRevoked { get; private set; }
    public Guid KeyId { get; }
    public IAuthenticatedEncryptorDescriptor Descriptor { get; }
    public KeyBase(Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate, Lazy`1<IAuthenticatedEncryptorDescriptor> lazyDescriptor, IEnumerable`1<IAuthenticatedEncryptorFactory> encryptorFactories);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_ActivationDate();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_CreationDate();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_ExpirationDate();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRevoked();
    [CompilerGeneratedAttribute]
private void set_IsRevoked(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_KeyId();
    public sealed virtual IAuthenticatedEncryptorDescriptor get_Descriptor();
    public sealed virtual IAuthenticatedEncryptor CreateEncryptor();
    internal void SetRevoked();
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyEscrowServiceProviderExtensions : object {
    [ExtensionAttribute]
public static IKeyEscrowSink GetKeyEscrowSink(IServiceProvider services);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyExtensions : object {
    [ExtensionAttribute]
public static bool IsExpired(IKey key, DateTimeOffset now);
}
public class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions : object {
    private static TimeSpan _keyPropagationWindow;
    private static TimeSpan _keyRingRefreshPeriod;
    private static TimeSpan _maxServerClockSkew;
    private TimeSpan _newKeyLifetime;
    [CompilerGeneratedAttribute]
private bool <AutoGenerateKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private AlgorithmConfiguration <AuthenticatedEncryptorConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IKeyEscrowSink> <KeyEscrowSinks>k__BackingField;
    [CompilerGeneratedAttribute]
private IXmlRepository <XmlRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private IXmlEncryptor <XmlEncryptor>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAuthenticatedEncryptorFactory> <AuthenticatedEncryptorFactories>k__BackingField;
    public bool AutoGenerateKeys { get; public set; }
    internal TimeSpan KeyPropagationWindow { get; }
    internal TimeSpan KeyRingRefreshPeriod { get; }
    internal TimeSpan MaxServerClockSkew { get; }
    public TimeSpan NewKeyLifetime { get; public set; }
    public AlgorithmConfiguration AuthenticatedEncryptorConfiguration { get; public set; }
    public IList`1<IKeyEscrowSink> KeyEscrowSinks { get; }
    public IXmlRepository XmlRepository { get; public set; }
    public IXmlEncryptor XmlEncryptor { get; public set; }
    public IList`1<IAuthenticatedEncryptorFactory> AuthenticatedEncryptorFactories { get; }
    internal KeyManagementOptions(KeyManagementOptions other);
    private static KeyManagementOptions();
    [CompilerGeneratedAttribute]
public bool get_AutoGenerateKeys();
    [CompilerGeneratedAttribute]
public void set_AutoGenerateKeys(bool value);
    internal TimeSpan get_KeyPropagationWindow();
    internal TimeSpan get_KeyRingRefreshPeriod();
    internal TimeSpan get_MaxServerClockSkew();
    public TimeSpan get_NewKeyLifetime();
    public void set_NewKeyLifetime(TimeSpan value);
    [CompilerGeneratedAttribute]
public AlgorithmConfiguration get_AuthenticatedEncryptorConfiguration();
    [CompilerGeneratedAttribute]
public void set_AuthenticatedEncryptorConfiguration(AlgorithmConfiguration value);
    [CompilerGeneratedAttribute]
public IList`1<IKeyEscrowSink> get_KeyEscrowSinks();
    [CompilerGeneratedAttribute]
public IXmlRepository get_XmlRepository();
    [CompilerGeneratedAttribute]
public void set_XmlRepository(IXmlRepository value);
    [CompilerGeneratedAttribute]
public IXmlEncryptor get_XmlEncryptor();
    [CompilerGeneratedAttribute]
public void set_XmlEncryptor(IXmlEncryptor value);
    [CompilerGeneratedAttribute]
public IList`1<IAuthenticatedEncryptorFactory> get_AuthenticatedEncryptorFactories();
}
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRing : object {
    private KeyHolder _defaultKeyHolder;
    private Dictionary`2<Guid, KeyHolder> _keyIdToKeyHolderMap;
    [CompilerGeneratedAttribute]
private Guid <DefaultKeyId>k__BackingField;
    public IAuthenticatedEncryptor DefaultAuthenticatedEncryptor { get; }
    public Guid DefaultKeyId { get; }
    public KeyRing(IKey defaultKey, IEnumerable`1<IKey> allKeys);
    public sealed virtual IAuthenticatedEncryptor get_DefaultAuthenticatedEncryptor();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_DefaultKeyId();
    public sealed virtual IAuthenticatedEncryptor GetAuthenticatedEncryptorByKeyId(Guid keyId, Boolean& isRevoked);
}
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingBasedDataProtectionProvider : object {
    private IKeyRingProvider _keyRingProvider;
    private ILogger _logger;
    public KeyRingBasedDataProtectionProvider(IKeyRingProvider keyRingProvider, ILoggerFactory loggerFactory);
    public sealed virtual IDataProtector CreateProtector(string purpose);
}
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingBasedDataProtector : object {
    private static UInt32 MAGIC_HEADER_V0;
    private AdditionalAuthenticatedDataTemplate _aadTemplate;
    private IKeyRingProvider _keyRingProvider;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private String[] <Purposes>k__BackingField;
    internal String[] Purposes { get; }
    public KeyRingBasedDataProtector(IKeyRingProvider keyRingProvider, ILogger logger, String[] originalPurposes, string newPurpose);
    [CompilerGeneratedAttribute]
internal String[] get_Purposes();
    private static String[] ConcatPurposes(String[] originalPurposes, string newPurpose);
    public sealed virtual IDataProtector CreateProtector(string purpose);
    private static string JoinPurposesForLog(IEnumerable`1<string> purposes);
    public sealed virtual Byte[] DangerousUnprotect(Byte[] protectedData, bool ignoreRevocationErrors, Boolean& requiresMigration, Boolean& wasRevoked);
    public sealed virtual Byte[] Protect(Byte[] plaintext);
    private static Guid Read32bitAlignedGuid(Void* ptr);
    private static UInt32 ReadBigEndian32BitInteger(Byte* ptr);
    private static bool TryGetVersionFromMagicHeader(UInt32 magicHeader, Int32& version);
    public sealed virtual Byte[] Unprotect(Byte[] protectedData);
    private Byte[] UnprotectCore(Byte[] protectedData, bool allowOperationsOnRevokedKeys, UnprotectStatus& status);
    private static void Write32bitAlignedGuid(Void* ptr, Guid value);
    private static void WriteBigEndianInteger(Byte* ptr, UInt32 value);
}
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingProvider : object {
    private CacheableKeyRing _cacheableKeyRing;
    private object _cacheableKeyRingLockObj;
    private IDefaultKeyResolver _defaultKeyResolver;
    private KeyManagementOptions _keyManagementOptions;
    private IKeyManager _keyManager;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private ICacheableKeyRingProvider <CacheableKeyRingProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <AutoRefreshWindowEnd>k__BackingField;
    internal ICacheableKeyRingProvider CacheableKeyRingProvider { get; internal set; }
    internal DateTime AutoRefreshWindowEnd { get; internal set; }
    public KeyRingProvider(IKeyManager keyManager, IOptions`1<KeyManagementOptions> keyManagementOptions, IDefaultKeyResolver defaultKeyResolver);
    public KeyRingProvider(IKeyManager keyManager, IOptions`1<KeyManagementOptions> keyManagementOptions, IDefaultKeyResolver defaultKeyResolver, ILoggerFactory loggerFactory);
    [CompilerGeneratedAttribute]
internal ICacheableKeyRingProvider get_CacheableKeyRingProvider();
    [CompilerGeneratedAttribute]
internal void set_CacheableKeyRingProvider(ICacheableKeyRingProvider value);
    [CompilerGeneratedAttribute]
internal DateTime get_AutoRefreshWindowEnd();
    [CompilerGeneratedAttribute]
internal void set_AutoRefreshWindowEnd(DateTime value);
    internal bool InAutoRefreshWindow();
    private CacheableKeyRing CreateCacheableKeyRingCore(DateTimeOffset now, IKey keyJustAdded);
    private CacheableKeyRing CreateCacheableKeyRingCoreStep2(DateTimeOffset now, CancellationToken cacheExpirationToken, IKey defaultKey, IEnumerable`1<IKey> allKeys);
    public sealed virtual IKeyRing GetCurrentKeyRing();
    internal IKeyRing RefreshCurrentKeyRing();
    internal IKeyRing GetCurrentKeyRingCore(DateTime utcNow, bool forceRefresh);
    private static TimeSpan GetRefreshPeriodWithJitter(TimeSpan refreshPeriod);
    private static DateTimeOffset Min(DateTimeOffset a, DateTimeOffset b);
    private sealed virtual override CacheableKeyRing Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.ICacheableKeyRingProvider.GetCacheableKeyRing(DateTimeOffset now);
}
public class Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager : object {
    internal static XName KeyElementName;
    internal static XName IdAttributeName;
    internal static XName VersionAttributeName;
    internal static XName CreationDateElementName;
    internal static XName ActivationDateElementName;
    internal static XName ExpirationDateElementName;
    internal static XName DescriptorElementName;
    internal static XName DeserializerTypeAttributeName;
    internal static XName RevocationElementName;
    internal static XName RevocationDateElementName;
    internal static XName ReasonElementName;
    private static string RevokeAllKeysValue;
    private IActivator _activator;
    private AlgorithmConfiguration _authenticatedEncryptorConfiguration;
    private IKeyEscrowSink _keyEscrowSink;
    private IInternalXmlKeyManager _internalKeyManager;
    private ILoggerFactory _loggerFactory;
    private ILogger _logger;
    private IEnumerable`1<IAuthenticatedEncryptorFactory> _encryptorFactories;
    private IDefaultKeyStorageDirectories _keyStorageDirectories;
    private CancellationTokenSource _cacheExpirationTokenSource;
    [CompilerGeneratedAttribute]
private IXmlEncryptor <KeyEncryptor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXmlRepository <KeyRepository>k__BackingField;
    internal IXmlEncryptor KeyEncryptor { get; }
    internal IXmlRepository KeyRepository { get; }
    public XmlKeyManager(IOptions`1<KeyManagementOptions> keyManagementOptions, IActivator activator);
    public XmlKeyManager(IOptions`1<KeyManagementOptions> keyManagementOptions, IActivator activator, ILoggerFactory loggerFactory);
    internal XmlKeyManager(IOptions`1<KeyManagementOptions> keyManagementOptions, IActivator activator, ILoggerFactory loggerFactory, IDefaultKeyStorageDirectories keyStorageDirectories);
    internal XmlKeyManager(IOptions`1<KeyManagementOptions> keyManagementOptions, IActivator activator, ILoggerFactory loggerFactory, IInternalXmlKeyManager internalXmlKeyManager);
    private static XmlKeyManager();
    [CompilerGeneratedAttribute]
internal IXmlEncryptor get_KeyEncryptor();
    [CompilerGeneratedAttribute]
internal IXmlRepository get_KeyRepository();
    public sealed virtual IKey CreateNewKey(DateTimeOffset activationDate, DateTimeOffset expirationDate);
    private static string DateTimeOffsetToFilenameSafeString(DateTimeOffset dateTime);
    public sealed virtual IReadOnlyCollection`1<IKey> GetAllKeys();
    public sealed virtual CancellationToken GetCacheExpirationToken();
    private KeyBase ProcessKeyElement(XElement keyElement);
    private object ProcessRevocationElement(XElement revocationElement);
    public sealed virtual void RevokeAllKeys(DateTimeOffset revocationDate, string reason);
    public sealed virtual void RevokeKey(Guid keyId, string reason);
    private void TriggerAndResetCacheExpirationToken(string opName, bool suppressLogging);
    private void WriteKeyDeserializationErrorToLog(Exception error, XElement keyElement);
    private sealed virtual override IKey Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager.CreateNewKey(Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate);
    private sealed virtual override IAuthenticatedEncryptorDescriptor Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager.DeserializeDescriptorFromKeyElement(XElement keyElement);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager.RevokeSingleKey(Guid keyId, DateTimeOffset revocationDate, string reason);
    internal KeyValuePair`2<IXmlRepository, IXmlEncryptor> GetFallbackKeyRepositoryEncryptorPair();
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.Managed.HashAlgorithmExtensions : object {
    [ExtensionAttribute]
public static int GetDigestSizeInBytes(HashAlgorithm hashAlgorithm);
}
internal interface Microsoft.AspNetCore.DataProtection.Managed.IManagedGenRandom {
    public abstract virtual Byte[] GenRandom(int numBytes);
}
internal class Microsoft.AspNetCore.DataProtection.Managed.ManagedAuthenticatedEncryptor : object {
    private static int KEY_MODIFIER_SIZE_IN_BYTES;
    private static Func`2<Byte[], HashAlgorithm> _kdkPrfFactory;
    private Byte[] _contextHeader;
    private IManagedGenRandom _genRandom;
    private Secret _keyDerivationKey;
    private Func`1<SymmetricAlgorithm> _symmetricAlgorithmFactory;
    private int _symmetricAlgorithmBlockSizeInBytes;
    private int _symmetricAlgorithmSubkeyLengthInBytes;
    private int _validationAlgorithmDigestLengthInBytes;
    private int _validationAlgorithmSubkeyLengthInBytes;
    private Func`1<KeyedHashAlgorithm> _validationAlgorithmFactory;
    public ManagedAuthenticatedEncryptor(Secret keyDerivationKey, Func`1<SymmetricAlgorithm> symmetricAlgorithmFactory, int symmetricAlgorithmKeySizeInBytes, Func`1<KeyedHashAlgorithm> validationAlgorithmFactory, IManagedGenRandom genRandom);
    private static ManagedAuthenticatedEncryptor();
    private Byte[] CreateContextHeader();
    private SymmetricAlgorithm CreateSymmetricAlgorithm();
    private KeyedHashAlgorithm CreateValidationAlgorithm(Byte[] key);
    public sealed virtual Byte[] Decrypt(ArraySegment`1<byte> protectedPayload, ArraySegment`1<byte> additionalAuthenticatedData);
    public sealed virtual void Dispose();
    public sealed virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData);
}
internal class Microsoft.AspNetCore.DataProtection.Managed.ManagedGenRandomImpl : object {
    private static RandomNumberGenerator _rng;
    public static ManagedGenRandomImpl Instance;
    private static ManagedGenRandomImpl();
    public sealed virtual Byte[] GenRandom(int numBytes);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.Managed.SymmetricAlgorithmExtensions : object {
    [ExtensionAttribute]
public static int GetBlockSizeInBytes(SymmetricAlgorithm symmetricAlgorithm);
}
internal static class Microsoft.AspNetCore.DataProtection.MemoryProtection : object {
    private static UInt32 CRYPTPROTECTMEMORY_SAME_PROCESS;
    public static void CryptProtectMemory(SafeHandle pBuffer, UInt32 byteCount);
    public static void CryptUnprotectMemory(Byte* pBuffer, UInt32 byteCount);
    public static void CryptUnprotectMemory(SafeHandle pBuffer, UInt32 byteCount);
}
internal class Microsoft.AspNetCore.DataProtection.RegistryPolicy : object {
    [CompilerGeneratedAttribute]
private AlgorithmConfiguration <EncryptorConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IKeyEscrowSink> <KeyEscrowSinks>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DefaultKeyLifetime>k__BackingField;
    public AlgorithmConfiguration EncryptorConfiguration { get; }
    public IEnumerable`1<IKeyEscrowSink> KeyEscrowSinks { get; }
    public Nullable`1<int> DefaultKeyLifetime { get; }
    public RegistryPolicy(AlgorithmConfiguration configuration, IEnumerable`1<IKeyEscrowSink> keyEscrowSinks, Nullable`1<int> defaultKeyLifetime);
    [CompilerGeneratedAttribute]
public AlgorithmConfiguration get_EncryptorConfiguration();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IKeyEscrowSink> get_KeyEscrowSinks();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DefaultKeyLifetime();
}
internal class Microsoft.AspNetCore.DataProtection.RegistryPolicyResolver : object {
    private Func`1<RegistryKey> _getPolicyRegKey;
    private IActivator _activator;
    public RegistryPolicyResolver(IActivator activator);
    internal RegistryPolicyResolver(RegistryKey policyRegKey, IActivator activator);
    private static void PopulateOptions(object options, RegistryKey key);
    private static List`1<string> ReadKeyEscrowSinks(RegistryKey key);
    public sealed virtual RegistryPolicy ResolvePolicy();
    private RegistryPolicy ResolvePolicyCore(RegistryKey policyRegKey);
    [CompilerGeneratedAttribute]
private IKeyEscrowSink <ResolvePolicyCore>b__7_0(string item);
}
internal class Microsoft.AspNetCore.DataProtection.Repositories.DefaultKeyStorageDirectories : object {
    private static Lazy`1<DirectoryInfo> _defaultDirectoryLazy;
    [CompilerGeneratedAttribute]
private static IDefaultKeyStorageDirectories <Instance>k__BackingField;
    private static string DataProtectionKeysFolderName;
    public static IDefaultKeyStorageDirectories Instance { get; }
    private static DefaultKeyStorageDirectories();
    [CompilerGeneratedAttribute]
public static IDefaultKeyStorageDirectories get_Instance();
    public sealed virtual DirectoryInfo GetKeyStorageDirectory();
    private static DirectoryInfo GetKeyStorageDirectoryImpl();
    public sealed virtual DirectoryInfo GetKeyStorageDirectoryForAzureWebSites();
    private static DirectoryInfo GetKeyStorageDirectoryFromBaseAppDataPath(string basePath);
}
internal class Microsoft.AspNetCore.DataProtection.Repositories.EphemeralXmlRepository : object {
    private List`1<XElement> _storedElements;
    public EphemeralXmlRepository(ILoggerFactory loggerFactory);
    public virtual IReadOnlyCollection`1<XElement> GetAllElements();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.DataProtection.Repositories.EphemeralXmlRepository/<GetAllElementsCore>d__3")]
private IEnumerable`1<XElement> GetAllElementsCore();
    public virtual void StoreElement(XElement element, string friendlyName);
}
public class Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository : object {
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private DirectoryInfo <Directory>k__BackingField;
    public static DirectoryInfo DefaultKeyStorageDirectory { get; }
    public DirectoryInfo Directory { get; }
    public FileSystemXmlRepository(DirectoryInfo directory, ILoggerFactory loggerFactory);
    public static DirectoryInfo get_DefaultKeyStorageDirectory();
    [CompilerGeneratedAttribute]
public DirectoryInfo get_Directory();
    public virtual IReadOnlyCollection`1<XElement> GetAllElements();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository/<GetAllElementsCore>d__8")]
private IEnumerable`1<XElement> GetAllElementsCore();
    private static bool IsSafeFilename(string filename);
    private XElement ReadElementFromFile(string fullPath);
    public virtual void StoreElement(XElement element, string friendlyName);
    private void StoreElementCore(XElement element, string filename);
}
internal interface Microsoft.AspNetCore.DataProtection.Repositories.IDefaultKeyStorageDirectories {
    public abstract virtual DirectoryInfo GetKeyStorageDirectory();
    public abstract virtual DirectoryInfo GetKeyStorageDirectoryForAzureWebSites();
}
public interface Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository {
    public abstract virtual IReadOnlyCollection`1<XElement> GetAllElements();
    public abstract virtual void StoreElement(XElement element, string friendlyName);
}
public class Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository : object {
    private static Lazy`1<RegistryKey> _defaultRegistryKeyLazy;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private RegistryKey <RegistryKey>k__BackingField;
    public static RegistryKey DefaultRegistryKey { get; }
    public RegistryKey RegistryKey { get; }
    public RegistryXmlRepository(RegistryKey registryKey, ILoggerFactory loggerFactory);
    private static RegistryXmlRepository();
    public static RegistryKey get_DefaultRegistryKey();
    [CompilerGeneratedAttribute]
public RegistryKey get_RegistryKey();
    public virtual IReadOnlyCollection`1<XElement> GetAllElements();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository/<GetAllElementsCore>d__9")]
private IEnumerable`1<XElement> GetAllElementsCore();
    private static RegistryKey GetDefaultHklmStorageKey();
    private static bool IsSafeRegistryValueName(string filename);
    private XElement ReadElementFromRegKey(RegistryKey regKey, string valueName);
    public virtual void StoreElement(XElement element, string friendlyName);
    private void StoreElementCore(XElement element, string valueName);
}
internal static class Microsoft.AspNetCore.DataProtection.Resources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string CryptCommon_GenericError { get; }
    internal static string Common_BufferIncorrectlySized { get; }
    internal static string CryptCommon_PayloadInvalid { get; }
    internal static string Common_PropertyCannotBeNullOrEmpty { get; }
    internal static string Common_DecryptionFailed { get; }
    internal static string Common_EncryptionFailed { get; }
    internal static string Common_KeyNotFound { get; }
    internal static string Common_KeyRevoked { get; }
    internal static string ProtectionProvider_BadMagicHeader { get; }
    internal static string ProtectionProvider_BadVersion { get; }
    internal static string Common_ValueMustBeNonNegative { get; }
    internal static string TypeExtensions_BadCast { get; }
    internal static string KeyManagementOptions_MinNewKeyLifetimeViolated { get; }
    internal static string XmlKeyManager_DuplicateKey { get; }
    internal static string Common_ArgumentCannotBeNullOrEmpty { get; }
    internal static string Common_PropertyMustBeNonNegative { get; }
    internal static string Platform_WindowsRequiredForGcm { get; }
    internal static string CertificateXmlEncryptor_CertificateNotFound { get; }
    internal static string EncryptedXmlDecryptor_DoesNotWorkOnCoreClr { get; }
    internal static string AlgorithmAssert_BadBlockSize { get; }
    internal static string AlgorithmAssert_BadDigestSize { get; }
    internal static string AlgorithmAssert_BadKeySize { get; }
    internal static string KeyRingProvider_NoDefaultKey_AutoGenerateDisabled { get; }
    internal static string LifetimeMustNotBeNegative { get; }
    internal static string XmlKeyManager_IXmlRepositoryNotFound { get; }
    internal static string FileSystem_EphemeralKeysLocationInContainer { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_CryptCommon_GenericError();
    internal static string get_Common_BufferIncorrectlySized();
    internal static string FormatCommon_BufferIncorrectlySized(object p0, object p1);
    internal static string get_CryptCommon_PayloadInvalid();
    internal static string get_Common_PropertyCannotBeNullOrEmpty();
    internal static string FormatCommon_PropertyCannotBeNullOrEmpty(object p0);
    internal static string get_Common_DecryptionFailed();
    internal static string get_Common_EncryptionFailed();
    internal static string get_Common_KeyNotFound();
    internal static string get_Common_KeyRevoked();
    internal static string get_ProtectionProvider_BadMagicHeader();
    internal static string get_ProtectionProvider_BadVersion();
    internal static string get_Common_ValueMustBeNonNegative();
    internal static string get_TypeExtensions_BadCast();
    internal static string FormatTypeExtensions_BadCast(object p0, object p1);
    internal static string get_KeyManagementOptions_MinNewKeyLifetimeViolated();
    internal static string get_XmlKeyManager_DuplicateKey();
    internal static string get_Common_ArgumentCannotBeNullOrEmpty();
    internal static string get_Common_PropertyMustBeNonNegative();
    internal static string FormatCommon_PropertyMustBeNonNegative(object p0);
    internal static string get_Platform_WindowsRequiredForGcm();
    internal static string get_CertificateXmlEncryptor_CertificateNotFound();
    internal static string FormatCertificateXmlEncryptor_CertificateNotFound(object p0);
    internal static string get_EncryptedXmlDecryptor_DoesNotWorkOnCoreClr();
    internal static string get_AlgorithmAssert_BadBlockSize();
    internal static string FormatAlgorithmAssert_BadBlockSize(object p0);
    internal static string get_AlgorithmAssert_BadDigestSize();
    internal static string FormatAlgorithmAssert_BadDigestSize(object p0);
    internal static string get_AlgorithmAssert_BadKeySize();
    internal static string FormatAlgorithmAssert_BadKeySize(object p0);
    internal static string get_KeyRingProvider_NoDefaultKey_AutoGenerateDisabled();
    internal static string get_LifetimeMustNotBeNegative();
    internal static string FormatLifetimeMustNotBeNegative(object p0);
    internal static string get_XmlKeyManager_IXmlRepositoryNotFound();
    internal static string FormatXmlKeyManager_IXmlRepositoryNotFound(object p0, object p1);
    internal static string get_FileSystem_EphemeralKeysLocationInContainer();
    internal static string FormatFileSystem_EphemeralKeysLocationInContainer(object path);
}
public class Microsoft.AspNetCore.DataProtection.Secret : object {
    private static UInt32 CRYPTPROTECTMEMORY_BLOCK_SIZE;
    private SecureLocalAllocHandle _localAllocHandle;
    private UInt32 _plaintextLength;
    public int Length { get; }
    public Secret(ArraySegment`1<byte> value);
    public Secret(Byte[] value);
    public Secret(Byte* secret, int secretLength);
    public Secret(ISecret secret);
    public sealed virtual int get_Length();
    public sealed virtual void Dispose();
    private static SecureLocalAllocHandle Protect(ArraySegment`1<byte> plaintext);
    private static SecureLocalAllocHandle Protect(Byte* pbPlaintext, UInt32 cbPlaintext);
    public static Secret Random(int numBytes);
    private void UnprotectInto(Byte* pbBuffer);
    public sealed virtual void WriteSecretIntoBuffer(ArraySegment`1<byte> buffer);
    public void WriteSecretIntoBuffer(Byte* buffer, int bufferLength);
}
internal class Microsoft.AspNetCore.DataProtection.SimpleActivator : object {
    internal static SimpleActivator DefaultWithoutServices;
    private IServiceProvider _services;
    public SimpleActivator(IServiceProvider services);
    private static SimpleActivator();
    public virtual object CreateInstance(Type expectedBaseType, string implementationTypeName);
}
internal interface Microsoft.AspNetCore.DataProtection.SP800_108.ISP800_108_CTR_HMACSHA512Provider {
    public abstract virtual void DeriveKey(Byte* pbLabel, UInt32 cbLabel, Byte* pbContext, UInt32 cbContext, Byte* pbDerivedKey, UInt32 cbDerivedKey);
}
internal static class Microsoft.AspNetCore.DataProtection.SP800_108.ManagedSP800_108_CTR_HMACSHA512 : object {
    public static void DeriveKeys(Byte[] kdk, ArraySegment`1<byte> label, ArraySegment`1<byte> context, Func`2<Byte[], HashAlgorithm> prfFactory, ArraySegment`1<byte> output);
    public static void DeriveKeysWithContextHeader(Byte[] kdk, ArraySegment`1<byte> label, Byte[] contextHeader, ArraySegment`1<byte> context, Func`2<Byte[], HashAlgorithm> prfFactory, ArraySegment`1<byte> output);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.SP800_108.SP800_108_CTR_HMACSHA512Extensions : object {
    [ExtensionAttribute]
public static void DeriveKeyWithContextHeader(ISP800_108_CTR_HMACSHA512Provider provider, Byte* pbLabel, UInt32 cbLabel, Byte[] contextHeader, Byte* pbContext, UInt32 cbContext, Byte* pbDerivedKey, UInt32 cbDerivedKey);
}
internal static class Microsoft.AspNetCore.DataProtection.SP800_108.SP800_108_CTR_HMACSHA512Util : object {
    public static ISP800_108_CTR_HMACSHA512Provider CreateEmptyProvider();
    public static ISP800_108_CTR_HMACSHA512Provider CreateProvider(Byte* pbKdk, UInt32 cbKdk);
    public static ISP800_108_CTR_HMACSHA512Provider CreateProvider(Secret kdk);
}
internal class Microsoft.AspNetCore.DataProtection.SP800_108.Win7SP800_108_CTR_HMACSHA512Provider : object {
    private BCryptHashHandle _hashHandle;
    public Win7SP800_108_CTR_HMACSHA512Provider(Byte* pbKdk, UInt32 cbKdk);
    public sealed virtual void DeriveKey(Byte* pbLabel, UInt32 cbLabel, Byte* pbContext, UInt32 cbContext, Byte* pbDerivedKey, UInt32 cbDerivedKey);
    public sealed virtual void Dispose();
}
internal class Microsoft.AspNetCore.DataProtection.SP800_108.Win8SP800_108_CTR_HMACSHA512Provider : object {
    private BCryptKeyHandle _keyHandle;
    public Win8SP800_108_CTR_HMACSHA512Provider(Byte* pbKdk, UInt32 cbKdk);
    public sealed virtual void DeriveKey(Byte* pbLabel, UInt32 cbLabel, Byte* pbContext, UInt32 cbContext, Byte* pbDerivedKey, UInt32 cbDerivedKey);
    public sealed virtual void Dispose();
    private static BCryptKeyHandle ImportKey(Byte* pbKdk, UInt32 cbKdk);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.TypeExtensions : object {
    [ExtensionAttribute]
public static void AssertIsAssignableFrom(Type expectedBaseType, Type implementationType);
}
internal class Microsoft.AspNetCore.DataProtection.TypeForwardingActivator : SimpleActivator {
    private static string OldNamespace;
    private static string CurrentNamespace;
    private ILogger _logger;
    private static Regex _versionPattern;
    public TypeForwardingActivator(IServiceProvider services);
    public TypeForwardingActivator(IServiceProvider services, ILoggerFactory loggerFactory);
    private static TypeForwardingActivator();
    public virtual object CreateInstance(Type expectedBaseType, string originalTypeName);
    internal object CreateInstance(Type expectedBaseType, string originalTypeName, Boolean& forwarded);
    protected string RemoveVersionFromAssemblyName(string forwardedTypeName);
}
internal static class Microsoft.AspNetCore.DataProtection.XmlConstants : object {
    private static XNamespace RootNamespace;
    internal static XName DecryptorTypeAttributeName;
    internal static XName DeserializerTypeAttributeName;
    internal static XName EncryptedSecretElementName;
    internal static XName RequiresEncryptionAttributeName;
    private static XmlConstants();
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.CertificateResolver : object {
    public virtual X509Certificate2 ResolveCertificate(string thumbprint);
    private static X509Certificate2 GetCertificateFromStore(StoreLocation location, string thumbprint);
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.CertificateXmlEncryptor : object {
    private Func`1<X509Certificate2> _certFactory;
    private IInternalCertificateXmlEncryptor _encryptor;
    private ILogger _logger;
    public CertificateXmlEncryptor(string thumbprint, ICertificateResolver certificateResolver, ILoggerFactory loggerFactory);
    public CertificateXmlEncryptor(X509Certificate2 certificate, ILoggerFactory loggerFactory);
    internal CertificateXmlEncryptor(ILoggerFactory loggerFactory, IInternalCertificateXmlEncryptor encryptor);
    public sealed virtual EncryptedXmlInfo Encrypt(XElement plaintextElement);
    private XElement EncryptElement(XElement plaintextElement);
    private Func`1<X509Certificate2> CreateCertFactory(string thumbprint, ICertificateResolver resolver);
    private sealed virtual override EncryptedData Microsoft.AspNetCore.DataProtection.XmlEncryption.IInternalCertificateXmlEncryptor.PerformEncryption(EncryptedXml encryptedXml, XmlElement elementToEncrypt);
}
[FlagsAttribute]
public enum Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags : Enum {
    public int value__;
    public static DpapiNGProtectionDescriptorFlags None;
    public static DpapiNGProtectionDescriptorFlags NamedDescriptor;
    public static DpapiNGProtectionDescriptorFlags MachineKey;
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlDecryptor : object {
    private ILogger _logger;
    public DpapiNGXmlDecryptor(IServiceProvider services);
    public sealed virtual XElement Decrypt(XElement encryptedElement);
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlEncryptor : object {
    private ILogger _logger;
    private NCryptDescriptorHandle _protectionDescriptorHandle;
    public DpapiNGXmlEncryptor(string protectionDescriptorRule, DpapiNGProtectionDescriptorFlags flags, ILoggerFactory loggerFactory);
    public sealed virtual EncryptedXmlInfo Encrypt(XElement plaintextElement);
    internal static string GetDefaultProtectionDescriptorString();
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlDecryptor : object {
    private ILogger _logger;
    public DpapiXmlDecryptor(IServiceProvider services);
    public sealed virtual XElement Decrypt(XElement encryptedElement);
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlEncryptor : object {
    private ILogger _logger;
    private bool _protectToLocalMachine;
    public DpapiXmlEncryptor(bool protectToLocalMachine, ILoggerFactory loggerFactory);
    public sealed virtual EncryptedXmlInfo Encrypt(XElement plaintextElement);
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlDecryptor : object {
    private IInternalEncryptedXmlDecryptor _decryptor;
    private XmlKeyDecryptionOptions _options;
    public EncryptedXmlDecryptor(IServiceProvider services);
    public sealed virtual XElement Decrypt(XElement encryptedElement);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.XmlEncryption.IInternalEncryptedXmlDecryptor.PerformPreDecryptionSetup(EncryptedXml encryptedXml);
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo : object {
    [CompilerGeneratedAttribute]
private Type <DecryptorType>k__BackingField;
    [CompilerGeneratedAttribute]
private XElement <EncryptedElement>k__BackingField;
    public Type DecryptorType { get; }
    public XElement EncryptedElement { get; }
    public EncryptedXmlInfo(XElement encryptedElement, Type decryptorType);
    [CompilerGeneratedAttribute]
public Type get_DecryptorType();
    [CompilerGeneratedAttribute]
public XElement get_EncryptedElement();
}
public interface Microsoft.AspNetCore.DataProtection.XmlEncryption.ICertificateResolver {
    public abstract virtual X509Certificate2 ResolveCertificate(string thumbprint);
}
internal interface Microsoft.AspNetCore.DataProtection.XmlEncryption.IInternalCertificateXmlEncryptor {
    public abstract virtual EncryptedData PerformEncryption(EncryptedXml encryptedXml, XmlElement elementToEncrypt);
}
internal interface Microsoft.AspNetCore.DataProtection.XmlEncryption.IInternalEncryptedXmlDecryptor {
    public abstract virtual void PerformPreDecryptionSetup(EncryptedXml encryptedXml);
}
public interface Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlDecryptor {
    public abstract virtual XElement Decrypt(XElement encryptedElement);
}
public interface Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlEncryptor {
    public abstract virtual EncryptedXmlInfo Encrypt(XElement plaintextElement);
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.NullXmlDecryptor : object {
    public sealed virtual XElement Decrypt(XElement encryptedElement);
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.NullXmlEncryptor : object {
    private ILogger _logger;
    public NullXmlEncryptor(IServiceProvider services);
    public sealed virtual EncryptedXmlInfo Encrypt(XElement plaintextElement);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.XmlEncryption.XmlEncryptionExtensions : object {
    [ExtensionAttribute]
public static XElement DecryptElement(XElement element, IActivator activator);
    [ExtensionAttribute]
public static XElement EncryptIfNecessary(IXmlEncryptor encryptor, XElement element);
    [ExtensionAttribute]
public static Secret ToSecret(XElement element);
    [ExtensionAttribute]
public static XElement ToXElement(Secret secret);
    private static bool DoesElementOrDescendentRequireDecryption(XElement element);
    private static bool DoesElementOrDescendentRequireEncryption(XElement element);
    private static bool DoesSingleElementRequireEncryption(XElement element);
}
internal class Microsoft.AspNetCore.DataProtection.XmlEncryption.XmlKeyDecryptionOptions : object {
    private Dictionary`2<string, List`1<X509Certificate2>> _certs;
    public int KeyDecryptionCertificateCount { get; }
    public int get_KeyDecryptionCertificateCount();
    public bool TryGetKeyDecryptionCertificates(X509Certificate2 certInfo, IReadOnlyList`1& keyDecryptionCerts);
    public void AddKeyDecryptionCertificate(X509Certificate2 certificate);
    private string GetKey(X509Certificate2 cert);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.XmlExtensions : object {
    [ExtensionAttribute]
public static XElement WithoutChildNodes(XElement element);
}
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.DataProtectionServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IDataProtectionBuilder AddDataProtection(IServiceCollection services);
    [ExtensionAttribute]
public static IDataProtectionBuilder AddDataProtection(IServiceCollection services, Action`1<DataProtectionOptions> setupAction);
    private static void AddDataProtectionServices(IServiceCollection services);
}
[ExtensionAttribute]
internal static class Microsoft.Extensions.Logging.LoggingExtensions : object {
    private static Action`4<ILogger, Guid, DateTimeOffset, Exception> _usingFallbackKeyWithExpirationAsDefaultKey;
    private static Action`3<ILogger, Guid, Exception> _usingKeyAsDefaultKey;
    private static Action`4<ILogger, string, string, Exception> _openingCNGAlgorithmFromProviderWithHMAC;
    private static Action`4<ILogger, string, string, Exception> _openingCNGAlgorithmFromProviderWithChainingModeCBC;
    private static Action`4<ILogger, Guid, string, Exception> _performingUnprotectOperationToKeyWithPurposes;
    private static Action`3<ILogger, Guid, Exception> _keyWasNotFoundInTheKeyRingUnprotectOperationCannotProceed;
    private static Action`3<ILogger, Guid, Exception> _keyWasRevokedCallerRequestedUnprotectOperationProceedRegardless;
    private static Action`3<ILogger, Guid, Exception> _keyWasRevokedUnprotectOperationCannotProceed;
    private static Action`4<ILogger, string, string, Exception> _openingCNGAlgorithmFromProviderWithChainingModeGCM;
    private static Action`3<ILogger, string, Exception> _usingManagedKeyedHashAlgorithm;
    private static Action`3<ILogger, string, Exception> _usingManagedSymmetricAlgorithm;
    private static Action`4<ILogger, Guid, string, Exception> _keyIsIneligibleToBeTheDefaultKeyBecauseItsMethodFailed;
    private static Action`4<ILogger, Guid, DateTimeOffset, Exception> _consideringKeyWithExpirationDateAsDefaultKey;
    private static Action`3<ILogger, Guid, Exception> _keyIsNoLongerUnderConsiderationAsDefault;
    private static Action`3<ILogger, XName, Exception> _unknownElementWithNameFoundInKeyringSkipping;
    private static Action`3<ILogger, Guid, Exception> _markedKeyAsRevokedInTheKeyring;
    private static Action`3<ILogger, Guid, Exception> _triedToProcessRevocationOfKeyButNoSuchKeyWasFound;
    private static Action`3<ILogger, Guid, Exception> _foundKey;
    private static Action`3<ILogger, DateTimeOffset, Exception> _foundRevocationOfAllKeysCreatedPriorTo;
    private static Action`3<ILogger, Guid, Exception> _foundRevocationOfKey;
    private static Action`3<ILogger, XElement, Exception> _exceptionWhileProcessingRevocationElement;
    private static Action`4<ILogger, DateTimeOffset, string, Exception> _revokingAllKeysAsOfForReason;
    private static Action`3<ILogger, string, Exception> _keyCacheExpirationTokenTriggeredByOperation;
    private static Action`3<ILogger, XElement, Exception> _anExceptionOccurredWhileProcessingTheKeyElement;
    private static Action`3<ILogger, XElement, Exception> _anExceptionOccurredWhileProcessingTheKeyElementDebug;
    private static Action`3<ILogger, string, Exception> _encryptingToWindowsDPAPIForCurrentUserAccount;
    private static Action`3<ILogger, string, Exception> _encryptingToWindowsDPAPINGUsingProtectionDescriptorRule;
    private static Action`3<ILogger, string, Exception> _anErrorOccurredWhileEncryptingToX509CertificateWithThumbprint;
    private static Action`3<ILogger, string, Exception> _encryptingToX509CertificateWithThumbprint;
    private static Action`3<ILogger, string, Exception> _exceptionOccurredWhileTryingToResolveCertificateWithThumbprint;
    private static Action`4<ILogger, Guid, string, Exception> _performingProtectOperationToKeyWithPurposes;
    private static Action`6<ILogger, Guid, DateTimeOffset, DateTimeOffset, DateTimeOffset, Exception> _creatingKey;
    private static Action`4<ILogger, Guid, string, Exception> _descriptorDeserializerTypeForKeyIs;
    private static Action`3<ILogger, Guid, Exception> _keyEscrowSinkFoundWritingKeyToEscrow;
    private static Action`3<ILogger, Guid, Exception> _noKeyEscrowSinkFoundNotWritingKeyToEscrow;
    private static Action`3<ILogger, Guid, Exception> _noXMLEncryptorConfiguredKeyMayBePersistedToStorageInUnencryptedForm;
    private static Action`5<ILogger, Guid, DateTimeOffset, string, Exception> _revokingKeyForReason;
    private static Action`3<ILogger, string, Exception> _readingDataFromFile;
    private static Action`4<ILogger, string, string, Exception> _nameIsNotSafeFileName;
    private static Action`3<ILogger, string, Exception> _writingDataToFile;
    private static Action`4<ILogger, RegistryKey, string, Exception> _readingDataFromRegistryKeyValue;
    private static Action`4<ILogger, string, string, Exception> _nameIsNotSafeRegistryValueName;
    private static Action`3<ILogger, string, Exception> _decryptingSecretElementUsingWindowsDPAPING;
    private static Action`2<ILogger, Exception> _exceptionOccurredTryingToDecryptElement;
    private static Action`2<ILogger, Exception> _encryptingUsingNullEncryptor;
    private static Action`2<ILogger, Exception> _usingEphemeralDataProtectionProvider;
    private static Action`2<ILogger, Exception> _existingCachedKeyRingIsExpiredRefreshing;
    private static Action`2<ILogger, Exception> _errorOccurredWhileRefreshingKeyRing;
    private static Action`2<ILogger, Exception> _errorOccurredWhileReadingKeyRing;
    private static Action`2<ILogger, Exception> _keyRingDoesNotContainValidDefaultKey;
    private static Action`2<ILogger, Exception> _usingInmemoryRepository;
    private static Action`2<ILogger, Exception> _decryptingSecretElementUsingWindowsDPAPI;
    private static Action`2<ILogger, Exception> _defaultKeyExpirationImminentAndRepository;
    private static Action`2<ILogger, Exception> _repositoryContainsNoViableDefaultKey;
    private static Action`2<ILogger, Exception> _errorOccurredWhileEncryptingToWindowsDPAPI;
    private static Action`2<ILogger, Exception> _encryptingToWindowsDPAPIForLocalMachineAccount;
    private static Action`2<ILogger, Exception> _errorOccurredWhileEncryptingToWindowsDPAPING;
    private static Action`2<ILogger, Exception> _policyResolutionStatesThatANewKeyShouldBeAddedToTheKeyRing;
    private static Action`3<ILogger, Guid, Exception> _keyRingWasLoadedOnStartup;
    private static Action`2<ILogger, Exception> _keyRingFailedToLoadOnStartup;
    private static Action`2<ILogger, Exception> _usingEphemeralKeyRepository;
    private static Action`3<ILogger, string, Exception> _usingRegistryAsKeyRepositoryWithDPAPI;
    private static Action`3<ILogger, string, Exception> _usingProfileAsKeyRepository;
    private static Action`3<ILogger, string, Exception> _usingProfileAsKeyRepositoryWithDPAPI;
    private static Action`3<ILogger, string, Exception> _usingAzureAsKeyRepository;
    private static Action`3<ILogger, string, Exception> _usingEphemeralFileSystemLocationInContainer;
    private static LoggingExtensions();
    [ExtensionAttribute]
public static bool IsDebugLevelEnabled(ILogger logger);
    [ExtensionAttribute]
public static bool IsErrorLevelEnabled(ILogger logger);
    [ExtensionAttribute]
public static bool IsInformationLevelEnabled(ILogger logger);
    [ExtensionAttribute]
public static bool IsTraceLevelEnabled(ILogger logger);
    [ExtensionAttribute]
public static bool IsWarningLevelEnabled(ILogger logger);
    private static bool IsLogLevelEnabledCore(ILogger logger, LogLevel level);
    [ExtensionAttribute]
public static void UsingFallbackKeyWithExpirationAsDefaultKey(ILogger logger, Guid keyId, DateTimeOffset expirationDate);
    [ExtensionAttribute]
public static void UsingKeyAsDefaultKey(ILogger logger, Guid keyId);
    [ExtensionAttribute]
public static void OpeningCNGAlgorithmFromProviderWithHMAC(ILogger logger, string hashAlgorithm, string hashAlgorithmProvider);
    [ExtensionAttribute]
public static void OpeningCNGAlgorithmFromProviderWithChainingModeCBC(ILogger logger, string encryptionAlgorithm, string encryptionAlgorithmProvider);
    [ExtensionAttribute]
public static void PerformingUnprotectOperationToKeyWithPurposes(ILogger logger, Guid keyIdFromPayload, string p0);
    [ExtensionAttribute]
public static void KeyWasNotFoundInTheKeyRingUnprotectOperationCannotProceed(ILogger logger, Guid keyIdFromPayload);
    [ExtensionAttribute]
public static void KeyWasRevokedCallerRequestedUnprotectOperationProceedRegardless(ILogger logger, Guid keyIdFromPayload);
    [ExtensionAttribute]
public static void KeyWasRevokedUnprotectOperationCannotProceed(ILogger logger, Guid keyIdFromPayload);
    [ExtensionAttribute]
public static void OpeningCNGAlgorithmFromProviderWithChainingModeGCM(ILogger logger, string encryptionAlgorithm, string encryptionAlgorithmProvider);
    [ExtensionAttribute]
public static void UsingManagedKeyedHashAlgorithm(ILogger logger, string fullName);
    [ExtensionAttribute]
public static void UsingManagedSymmetricAlgorithm(ILogger logger, string fullName);
    [ExtensionAttribute]
public static void KeyIsIneligibleToBeTheDefaultKeyBecauseItsMethodFailed(ILogger logger, Guid keyId, string p0, Exception exception);
    [ExtensionAttribute]
public static void ConsideringKeyWithExpirationDateAsDefaultKey(ILogger logger, Guid keyId, DateTimeOffset expirationDate);
    [ExtensionAttribute]
public static void KeyIsNoLongerUnderConsiderationAsDefault(ILogger logger, Guid keyId);
    [ExtensionAttribute]
public static void UnknownElementWithNameFoundInKeyringSkipping(ILogger logger, XName name);
    [ExtensionAttribute]
public static void MarkedKeyAsRevokedInTheKeyring(ILogger logger, Guid revokedKeyId);
    [ExtensionAttribute]
public static void TriedToProcessRevocationOfKeyButNoSuchKeyWasFound(ILogger logger, Guid revokedKeyId);
    [ExtensionAttribute]
public static void FoundKey(ILogger logger, Guid keyId);
    [ExtensionAttribute]
public static void FoundRevocationOfAllKeysCreatedPriorTo(ILogger logger, DateTimeOffset massRevocationDate);
    [ExtensionAttribute]
public static void FoundRevocationOfKey(ILogger logger, Guid keyId);
    [ExtensionAttribute]
public static void ExceptionWhileProcessingRevocationElement(ILogger logger, XElement revocationElement, Exception exception);
    [ExtensionAttribute]
public static void RevokingAllKeysAsOfForReason(ILogger logger, DateTimeOffset revocationDate, string reason);
    [ExtensionAttribute]
public static void KeyCacheExpirationTokenTriggeredByOperation(ILogger logger, string opName);
    [ExtensionAttribute]
public static void ExceptionWhileProcessingKeyElement(ILogger logger, XElement keyElement, Exception exception);
    [ExtensionAttribute]
public static void AnExceptionOccurredWhileProcessingElementDebug(ILogger logger, XElement keyElement, Exception exception);
    [ExtensionAttribute]
public static void EncryptingToWindowsDPAPIForCurrentUserAccount(ILogger logger, string name);
    [ExtensionAttribute]
public static void AnErrorOccurredWhileEncryptingToX509CertificateWithThumbprint(ILogger logger, string thumbprint, Exception exception);
    [ExtensionAttribute]
public static void EncryptingToX509CertificateWithThumbprint(ILogger logger, string thumbprint);
    [ExtensionAttribute]
public static void ExceptionWhileTryingToResolveCertificateWithThumbprint(ILogger logger, string thumbprint, Exception exception);
    [ExtensionAttribute]
public static void PerformingProtectOperationToKeyWithPurposes(ILogger logger, Guid defaultKeyId, string p0);
    [ExtensionAttribute]
public static void DescriptorDeserializerTypeForKeyIs(ILogger logger, Guid keyId, string assemblyQualifiedName);
    [ExtensionAttribute]
public static void KeyEscrowSinkFoundWritingKeyToEscrow(ILogger logger, Guid keyId);
    [ExtensionAttribute]
public static void NoKeyEscrowSinkFoundNotWritingKeyToEscrow(ILogger logger, Guid keyId);
    [ExtensionAttribute]
public static void NoXMLEncryptorConfiguredKeyMayBePersistedToStorageInUnencryptedForm(ILogger logger, Guid keyId);
    [ExtensionAttribute]
public static void RevokingKeyForReason(ILogger logger, Guid keyId, DateTimeOffset revocationDate, string reason);
    [ExtensionAttribute]
public static void ReadingDataFromFile(ILogger logger, string fullPath);
    [ExtensionAttribute]
public static void NameIsNotSafeFileName(ILogger logger, string friendlyName, string newFriendlyName);
    [ExtensionAttribute]
public static void WritingDataToFile(ILogger logger, string finalFilename);
    [ExtensionAttribute]
public static void ReadingDataFromRegistryKeyValue(ILogger logger, RegistryKey regKey, string valueName);
    [ExtensionAttribute]
public static void NameIsNotSafeRegistryValueName(ILogger logger, string friendlyName, string newFriendlyName);
    [ExtensionAttribute]
public static void DecryptingSecretElementUsingWindowsDPAPING(ILogger logger, string protectionDescriptorRule);
    [ExtensionAttribute]
public static void EncryptingToWindowsDPAPINGUsingProtectionDescriptorRule(ILogger logger, string protectionDescriptorRuleString);
    [ExtensionAttribute]
public static void ExceptionOccurredTryingToDecryptElement(ILogger logger, Exception exception);
    [ExtensionAttribute]
public static void EncryptingUsingNullEncryptor(ILogger logger);
    [ExtensionAttribute]
public static void UsingEphemeralDataProtectionProvider(ILogger logger);
    [ExtensionAttribute]
public static void ExistingCachedKeyRingIsExpired(ILogger logger);
    [ExtensionAttribute]
public static void ErrorOccurredWhileRefreshingKeyRing(ILogger logger, Exception exception);
    [ExtensionAttribute]
public static void ErrorOccurredWhileReadingKeyRing(ILogger logger, Exception exception);
    [ExtensionAttribute]
public static void KeyRingDoesNotContainValidDefaultKey(ILogger logger);
    [ExtensionAttribute]
public static void UsingInmemoryRepository(ILogger logger);
    [ExtensionAttribute]
public static void DecryptingSecretElementUsingWindowsDPAPI(ILogger logger);
    [ExtensionAttribute]
public static void DefaultKeyExpirationImminentAndRepository(ILogger logger);
    [ExtensionAttribute]
public static void RepositoryContainsNoViableDefaultKey(ILogger logger);
    [ExtensionAttribute]
public static void ErrorOccurredWhileEncryptingToWindowsDPAPI(ILogger logger, Exception exception);
    [ExtensionAttribute]
public static void EncryptingToWindowsDPAPIForLocalMachineAccount(ILogger logger);
    [ExtensionAttribute]
public static void ErrorOccurredWhileEncryptingToWindowsDPAPING(ILogger logger, Exception exception);
    [ExtensionAttribute]
public static void PolicyResolutionStatesThatANewKeyShouldBeAddedToTheKeyRing(ILogger logger);
    [ExtensionAttribute]
public static void CreatingKey(ILogger logger, Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate);
    [ExtensionAttribute]
public static void UsingEphemeralKeyRepository(ILogger logger);
    [ExtensionAttribute]
public static void UsingRegistryAsKeyRepositoryWithDPAPI(ILogger logger, string name);
    [ExtensionAttribute]
public static void UsingProfileAsKeyRepository(ILogger logger, string fullName);
    [ExtensionAttribute]
public static void UsingProfileAsKeyRepositoryWithDPAPI(ILogger logger, string fullName);
    [ExtensionAttribute]
public static void UsingAzureAsKeyRepository(ILogger logger, string fullName);
    [ExtensionAttribute]
public static void KeyRingWasLoadedOnStartup(ILogger logger, Guid defaultKeyId);
    [ExtensionAttribute]
public static void KeyRingFailedToLoadOnStartup(ILogger logger, Exception innerException);
    [ExtensionAttribute]
public static void UsingEphemeralFileSystemLocationInContainer(ILogger logger, string path);
}
[ExtensionAttribute]
internal static class System.LoggingServiceProviderExtensions : object {
    [ExtensionAttribute]
public static ILogger GetLogger(IServiceProvider services);
    [ExtensionAttribute]
public static ILogger GetLogger(IServiceProvider services, Type type);
}
