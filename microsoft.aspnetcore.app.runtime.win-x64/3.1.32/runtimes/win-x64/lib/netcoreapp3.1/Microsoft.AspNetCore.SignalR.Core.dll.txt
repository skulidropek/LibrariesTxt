internal static class Microsoft.AspNetCore.Internal.TaskCache : object {
    public static Task`1<bool> True;
    public static Task`1<bool> False;
    private static TaskCache();
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.SignalR.ClientProxyExtensions : object {
    [ExtensionAttribute]
public static Task SendAsync(IClientProxy clientProxy, string method, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendAsync(IClientProxy clientProxy, string method, object arg1, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendAsync(IClientProxy clientProxy, string method, object arg1, object arg2, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendAsync(IClientProxy clientProxy, string method, object arg1, object arg2, object arg3, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendAsync(IClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendAsync(IClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendAsync(IClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendAsync(IClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendAsync(IClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendAsync(IClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8, object arg9, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendAsync(IClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8, object arg9, object arg10, CancellationToken cancellationToken);
}
public class Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager`1 : HubLifetimeManager`1<THub> {
    private HubConnectionStore _connections;
    private HubGroupList _groups;
    private ILogger _logger;
    public DefaultHubLifetimeManager`1(ILogger`1<DefaultHubLifetimeManager`1<THub>> logger);
    public virtual Task AddToGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken);
    public virtual Task RemoveFromGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken);
    public virtual Task SendAllAsync(string methodName, Object[] args, CancellationToken cancellationToken);
    private Task SendToAllConnections(string methodName, Object[] args, Func`2<HubConnectionContext, bool> include, CancellationToken cancellationToken);
    private void SendToGroupConnections(string methodName, Object[] args, ConcurrentDictionary`2<string, HubConnectionContext> connections, Func`2<HubConnectionContext, bool> include, List`1& tasks, SerializedHubMessage& message, CancellationToken cancellationToken);
    public virtual Task SendConnectionAsync(string connectionId, string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task SendGroupAsync(string groupName, string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task SendGroupsAsync(IReadOnlyList`1<string> groupNames, string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task SendGroupExceptAsync(string groupName, string methodName, Object[] args, IReadOnlyList`1<string> excludedConnectionIds, CancellationToken cancellationToken);
    private SerializedHubMessage CreateSerializedInvocationMessage(string methodName, Object[] args);
    private HubMessage CreateInvocationMessage(string methodName, Object[] args);
    public virtual Task SendUserAsync(string userId, string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task OnConnectedAsync(HubConnectionContext connection);
    public virtual Task OnDisconnectedAsync(HubConnectionContext connection);
    public virtual Task SendAllExceptAsync(string methodName, Object[] args, IReadOnlyList`1<string> excludedConnectionIds, CancellationToken cancellationToken);
    public virtual Task SendConnectionsAsync(IReadOnlyList`1<string> connectionIds, string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task SendUsersAsync(IReadOnlyList`1<string> userIds, string methodName, Object[] args, CancellationToken cancellationToken);
}
public class Microsoft.AspNetCore.SignalR.DefaultUserIdProvider : object {
    public virtual string GetUserId(HubConnectionContext connection);
}
public abstract class Microsoft.AspNetCore.SignalR.DynamicHub : Hub {
    private DynamicHubClients _clients;
    public DynamicHubClients Clients { get; public set; }
    public DynamicHubClients get_Clients();
    public void set_Clients(DynamicHubClients value);
}
public class Microsoft.AspNetCore.SignalR.DynamicHubClients : object {
    private IHubCallerClients _clients;
    [DynamicAttribute]
public object All { get; }
    [DynamicAttribute]
public object Caller { get; }
    [DynamicAttribute]
public object Others { get; }
    public DynamicHubClients(IHubCallerClients clients);
    public object get_All();
    public object AllExcept(IReadOnlyList`1<string> excludedConnectionIds);
    public object get_Caller();
    public object Client(string connectionId);
    public object Clients(IReadOnlyList`1<string> connectionIds);
    public object Group(string groupName);
    public object Groups(IReadOnlyList`1<string> groupNames);
    public object GroupExcept(string groupName, IReadOnlyList`1<string> excludedConnectionIds);
    public object OthersInGroup(string groupName);
    public object get_Others();
    public object User(string userId);
    public object Users(IReadOnlyList`1<string> userIds);
}
public abstract class Microsoft.AspNetCore.SignalR.Hub : object {
    private bool _disposed;
    private IHubCallerClients _clients;
    private HubCallerContext _context;
    private IGroupManager _groups;
    public IHubCallerClients Clients { get; public set; }
    public HubCallerContext Context { get; public set; }
    public IGroupManager Groups { get; public set; }
    public IHubCallerClients get_Clients();
    public void set_Clients(IHubCallerClients value);
    public HubCallerContext get_Context();
    public void set_Context(HubCallerContext value);
    public IGroupManager get_Groups();
    public void set_Groups(IGroupManager value);
    public virtual Task OnConnectedAsync();
    public virtual Task OnDisconnectedAsync(Exception exception);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private void CheckDisposed();
}
public abstract class Microsoft.AspNetCore.SignalR.Hub`1 : Hub {
    private IHubCallerClients`1<T> _clients;
    public IHubCallerClients`1<T> Clients { get; public set; }
    public IHubCallerClients`1<T> get_Clients();
    public void set_Clients(IHubCallerClients`1<T> value);
}
public abstract class Microsoft.AspNetCore.SignalR.HubCallerContext : object {
    public string ConnectionId { get; }
    public string UserIdentifier { get; }
    public ClaimsPrincipal User { get; }
    public IDictionary`2<object, object> Items { get; }
    public IFeatureCollection Features { get; }
    public CancellationToken ConnectionAborted { get; }
    public abstract virtual string get_ConnectionId();
    public abstract virtual string get_UserIdentifier();
    public abstract virtual ClaimsPrincipal get_User();
    public abstract virtual IDictionary`2<object, object> get_Items();
    public abstract virtual IFeatureCollection get_Features();
    public abstract virtual CancellationToken get_ConnectionAborted();
    public abstract virtual void Abort();
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.SignalR.HubClientsExtensions : object {
    [ExtensionAttribute]
public static T AllExcept(IHubClients`1<T> hubClients, string excludedConnectionId1);
    [ExtensionAttribute]
public static T AllExcept(IHubClients`1<T> hubClients, string excludedConnectionId1, string excludedConnectionId2);
    [ExtensionAttribute]
public static T AllExcept(IHubClients`1<T> hubClients, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3);
    [ExtensionAttribute]
public static T AllExcept(IHubClients`1<T> hubClients, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3, string excludedConnectionId4);
    [ExtensionAttribute]
public static T AllExcept(IHubClients`1<T> hubClients, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3, string excludedConnectionId4, string excludedConnectionId5);
    [ExtensionAttribute]
public static T AllExcept(IHubClients`1<T> hubClients, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3, string excludedConnectionId4, string excludedConnectionId5, string excludedConnectionId6);
    [ExtensionAttribute]
public static T AllExcept(IHubClients`1<T> hubClients, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3, string excludedConnectionId4, string excludedConnectionId5, string excludedConnectionId6, string excludedConnectionId7);
    [ExtensionAttribute]
public static T AllExcept(IHubClients`1<T> hubClients, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3, string excludedConnectionId4, string excludedConnectionId5, string excludedConnectionId6, string excludedConnectionId7, string excludedConnectionId8);
    [ExtensionAttribute]
public static T Clients(IHubClients`1<T> hubClients, string connection1);
    [ExtensionAttribute]
public static T Clients(IHubClients`1<T> hubClients, string connection1, string connection2);
    [ExtensionAttribute]
public static T Clients(IHubClients`1<T> hubClients, string connection1, string connection2, string connection3);
    [ExtensionAttribute]
public static T Clients(IHubClients`1<T> hubClients, string connection1, string connection2, string connection3, string connection4);
    [ExtensionAttribute]
public static T Clients(IHubClients`1<T> hubClients, string connection1, string connection2, string connection3, string connection4, string connection5);
    [ExtensionAttribute]
public static T Clients(IHubClients`1<T> hubClients, string connection1, string connection2, string connection3, string connection4, string connection5, string connection6);
    [ExtensionAttribute]
public static T Clients(IHubClients`1<T> hubClients, string connection1, string connection2, string connection3, string connection4, string connection5, string connection6, string connection7);
    [ExtensionAttribute]
public static T Clients(IHubClients`1<T> hubClients, string connection1, string connection2, string connection3, string connection4, string connection5, string connection6, string connection7, string connection8);
    [ExtensionAttribute]
public static T Groups(IHubClients`1<T> hubClients, string group1);
    [ExtensionAttribute]
public static T Groups(IHubClients`1<T> hubClients, string group1, string group2);
    [ExtensionAttribute]
public static T Groups(IHubClients`1<T> hubClients, string group1, string group2, string group3);
    [ExtensionAttribute]
public static T Groups(IHubClients`1<T> hubClients, string group1, string group2, string group3, string group4);
    [ExtensionAttribute]
public static T Groups(IHubClients`1<T> hubClients, string group1, string group2, string group3, string group4, string group5);
    [ExtensionAttribute]
public static T Groups(IHubClients`1<T> hubClients, string group1, string group2, string group3, string group4, string group5, string group6);
    [ExtensionAttribute]
public static T Groups(IHubClients`1<T> hubClients, string group1, string group2, string group3, string group4, string group5, string group6, string group7);
    [ExtensionAttribute]
public static T Groups(IHubClients`1<T> hubClients, string group1, string group2, string group3, string group4, string group5, string group6, string group7, string group8);
    [ExtensionAttribute]
public static T GroupExcept(IHubClients`1<T> hubClients, string groupName, string excludedConnectionId1);
    [ExtensionAttribute]
public static T GroupExcept(IHubClients`1<T> hubClients, string groupName, string excludedConnectionId1, string excludedConnectionId2);
    [ExtensionAttribute]
public static T GroupExcept(IHubClients`1<T> hubClients, string groupName, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3);
    [ExtensionAttribute]
public static T GroupExcept(IHubClients`1<T> hubClients, string groupName, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3, string excludedConnectionId4);
    [ExtensionAttribute]
public static T GroupExcept(IHubClients`1<T> hubClients, string groupName, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3, string excludedConnectionId4, string excludedConnectionId5);
    [ExtensionAttribute]
public static T GroupExcept(IHubClients`1<T> hubClients, string groupName, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3, string excludedConnectionId4, string excludedConnectionId5, string excludedConnectionId6);
    [ExtensionAttribute]
public static T GroupExcept(IHubClients`1<T> hubClients, string groupName, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3, string excludedConnectionId4, string excludedConnectionId5, string excludedConnectionId6, string excludedConnectionId7);
    [ExtensionAttribute]
public static T GroupExcept(IHubClients`1<T> hubClients, string groupName, string excludedConnectionId1, string excludedConnectionId2, string excludedConnectionId3, string excludedConnectionId4, string excludedConnectionId5, string excludedConnectionId6, string excludedConnectionId7, string excludedConnectionId8);
    [ExtensionAttribute]
public static T Users(IHubClients`1<T> hubClients, string user1);
    [ExtensionAttribute]
public static T Users(IHubClients`1<T> hubClients, string user1, string user2);
    [ExtensionAttribute]
public static T Users(IHubClients`1<T> hubClients, string user1, string user2, string user3);
    [ExtensionAttribute]
public static T Users(IHubClients`1<T> hubClients, string user1, string user2, string user3, string user4);
    [ExtensionAttribute]
public static T Users(IHubClients`1<T> hubClients, string user1, string user2, string user3, string user4, string user5);
    [ExtensionAttribute]
public static T Users(IHubClients`1<T> hubClients, string user1, string user2, string user3, string user4, string user5, string user6);
    [ExtensionAttribute]
public static T Users(IHubClients`1<T> hubClients, string user1, string user2, string user3, string user4, string user5, string user6, string user7);
    [ExtensionAttribute]
public static T Users(IHubClients`1<T> hubClients, string user1, string user2, string user3, string user4, string user5, string user6, string user7, string user8);
}
public class Microsoft.AspNetCore.SignalR.HubConnectionContext : object {
    private static Action`1<object> _cancelReader;
    private static WaitCallback _abortedCallback;
    private ConnectionContext _connectionContext;
    private ILogger _logger;
    private CancellationTokenSource _connectionAbortedTokenSource;
    private TaskCompletionSource`1<object> _abortCompletedTcs;
    private long _keepAliveInterval;
    private long _clientTimeoutInterval;
    private SemaphoreSlim _writeLock;
    private bool _useAbsoluteClientTimeout;
    private object _receiveMessageTimeoutLock;
    private StreamTracker _streamTracker;
    private long _lastSendTimeStamp;
    private long _lastReceivedTimeStamp;
    private bool _receivedMessageThisInterval;
    private ReadOnlyMemory`1<byte> _cachedPingMessage;
    private bool _clientTimeoutActive;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _connectionAborted;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _allowReconnect;
    private int _streamBufferCapacity;
    private Nullable`1<long> _maxMessageSize;
    private bool _receivedMessageTimeoutEnabled;
    private long _receivedMessageElapsedTicks;
    private long _receivedMessageTimestamp;
    [CompilerGeneratedAttribute]
private HubCallerContext <HubCallerContext>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <ConnectionAborted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IHubProtocol <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, CancellationTokenSource> <ActiveRequestCancellationSources>k__BackingField;
    internal StreamTracker StreamTracker { get; }
    internal HubCallerContext HubCallerContext { get; }
    public CancellationToken ConnectionAborted { get; }
    public string ConnectionId { get; }
    public ClaimsPrincipal User { get; }
    public IFeatureCollection Features { get; }
    public IDictionary`2<object, object> Items { get; }
    internal bool AllowReconnect { get; }
    internal PipeReader Input { get; }
    public string UserIdentifier { get; public set; }
    public IHubProtocol Protocol { get; public set; }
    internal ConcurrentDictionary`2<string, CancellationTokenSource> ActiveRequestCancellationSources { get; }
    public HubConnectionContext(ConnectionContext connectionContext, HubConnectionContextOptions contextOptions, ILoggerFactory loggerFactory);
    private static HubConnectionContext();
    internal StreamTracker get_StreamTracker();
    [CompilerGeneratedAttribute]
internal HubCallerContext get_HubCallerContext();
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_ConnectionAborted();
    public virtual string get_ConnectionId();
    public virtual ClaimsPrincipal get_User();
    public virtual IFeatureCollection get_Features();
    public virtual IDictionary`2<object, object> get_Items();
    internal bool get_AllowReconnect();
    internal PipeReader get_Input();
    [CompilerGeneratedAttribute]
public string get_UserIdentifier();
    [CompilerGeneratedAttribute]
public void set_UserIdentifier(string value);
    [CompilerGeneratedAttribute]
public virtual IHubProtocol get_Protocol();
    [CompilerGeneratedAttribute]
public virtual void set_Protocol(IHubProtocol value);
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<string, CancellationTokenSource> get_ActiveRequestCancellationSources();
    public virtual ValueTask WriteAsync(HubMessage message, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(SerializedHubMessage message, CancellationToken cancellationToken);
    private ValueTask`1<FlushResult> WriteCore(HubMessage message, CancellationToken cancellationToken);
    private ValueTask`1<FlushResult> WriteCore(SerializedHubMessage message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionContext/<CompleteWriteAsync>d__60")]
private Task CompleteWriteAsync(ValueTask`1<FlushResult> task);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionContext/<WriteSlowAsync>d__61")]
private Task WriteSlowAsync(HubMessage message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionContext/<WriteSlowAsync>d__62")]
private Task WriteSlowAsync(SerializedHubMessage message, CancellationToken cancellationToken);
    private ValueTask TryWritePingAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionContext/<TryWritePingSlowAsync>d__64")]
private Task TryWritePingSlowAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionContext/<WriteHandshakeResponseAsync>d__65")]
private Task WriteHandshakeResponseAsync(HandshakeResponseMessage message);
    public virtual void Abort();
    private void AbortAllowReconnect();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionContext/<HandshakeAsync>d__68")]
internal Task`1<bool> HandshakeAsync(TimeSpan timeout, IReadOnlyList`1<string> supportedProtocols, IHubProtocolResolver protocolResolver, IUserIdProvider userIdProvider, bool enableDetailedErrors);
    internal Task AbortAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionContext/<AbortAsyncSlow>d__70")]
private Task AbortAsyncSlow();
    private void KeepAliveTick();
    internal void StartClientTimeout();
    private void CheckClientTimeout();
    private static void AbortConnection(object state);
    internal void ResetClientTimeout();
    internal void BeginClientTimeout();
    internal void StopClientTimeout();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionContext/<<AbortConnection>g__InnerAbortConnection|74_0>d")]
[CompilerGeneratedAttribute]
internal static Task <AbortConnection>g__InnerAbortConnection|74_0(HubConnectionContext connection);
}
public class Microsoft.AspNetCore.SignalR.HubConnectionContextOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <KeepAliveInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ClientTimeoutInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StreamBufferCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaximumReceiveMessageSize>k__BackingField;
    public TimeSpan KeepAliveInterval { get; public set; }
    public TimeSpan ClientTimeoutInterval { get; public set; }
    public int StreamBufferCapacity { get; public set; }
    public Nullable`1<long> MaximumReceiveMessageSize { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_KeepAliveInterval();
    [CompilerGeneratedAttribute]
public void set_KeepAliveInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ClientTimeoutInterval();
    [CompilerGeneratedAttribute]
public void set_ClientTimeoutInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_StreamBufferCapacity();
    [CompilerGeneratedAttribute]
public void set_StreamBufferCapacity(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaximumReceiveMessageSize();
    [CompilerGeneratedAttribute]
public void set_MaximumReceiveMessageSize(Nullable`1<long> value);
}
public class Microsoft.AspNetCore.SignalR.HubConnectionHandler`1 : ConnectionHandler {
    private HubLifetimeManager`1<THub> _lifetimeManager;
    private ILoggerFactory _loggerFactory;
    private ILogger`1<HubConnectionHandler`1<THub>> _logger;
    private IHubProtocolResolver _protocolResolver;
    private HubOptions`1<THub> _hubOptions;
    private HubOptions _globalHubOptions;
    private IUserIdProvider _userIdProvider;
    private HubDispatcher`1<THub> _dispatcher;
    private bool _enableDetailedErrors;
    private Nullable`1<long> _maximumMessageSize;
    public HubConnectionHandler`1(HubLifetimeManager`1<THub> lifetimeManager, IHubProtocolResolver protocolResolver, IOptions`1<HubOptions> globalHubOptions, IOptions`1<HubOptions`1<THub>> hubOptions, ILoggerFactory loggerFactory, IUserIdProvider userIdProvider, IServiceScopeFactory serviceScopeFactory);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionHandler`1/<OnConnectedAsync>d__11")]
public virtual Task OnConnectedAsync(ConnectionContext connection);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionHandler`1/<RunHubAsync>d__12")]
private Task RunHubAsync(HubConnectionContext connection);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionHandler`1/<HubOnDisconnectedAsync>d__13")]
private Task HubOnDisconnectedAsync(HubConnectionContext connection, Exception exception);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionHandler`1/<SendCloseAsync>d__14")]
private Task SendCloseAsync(HubConnectionContext connection, Exception exception, bool allowReconnect);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.HubConnectionHandler`1/<DispatchMessagesAsync>d__15")]
private Task DispatchMessagesAsync(HubConnectionContext connection);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.AspNetCore.SignalR.HubConnectionStore : object {
    private ConcurrentDictionary`2<string, HubConnectionContext> _connections;
    public HubConnectionContext Item { get; }
    public int Count { get; }
    public HubConnectionContext get_Item(string connectionId);
    public int get_Count();
    public void Add(HubConnectionContext connection);
    public void Remove(HubConnectionContext connection);
    public Enumerator GetEnumerator();
}
public class Microsoft.AspNetCore.SignalR.HubInvocationContext : object {
    [CompilerGeneratedAttribute]
private HubCallerContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HubMethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<object> <HubMethodArguments>k__BackingField;
    public HubCallerContext Context { get; }
    public string HubMethodName { get; }
    public IReadOnlyList`1<object> HubMethodArguments { get; }
    public HubInvocationContext(HubCallerContext context, string hubMethodName, Object[] hubMethodArguments);
    [CompilerGeneratedAttribute]
public HubCallerContext get_Context();
    [CompilerGeneratedAttribute]
public string get_HubMethodName();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<object> get_HubMethodArguments();
}
public abstract class Microsoft.AspNetCore.SignalR.HubLifetimeManager`1 : object {
    public abstract virtual Task OnConnectedAsync(HubConnectionContext connection);
    public abstract virtual Task OnDisconnectedAsync(HubConnectionContext connection);
    public abstract virtual Task SendAllAsync(string methodName, Object[] args, CancellationToken cancellationToken);
    public abstract virtual Task SendAllExceptAsync(string methodName, Object[] args, IReadOnlyList`1<string> excludedConnectionIds, CancellationToken cancellationToken);
    public abstract virtual Task SendConnectionAsync(string connectionId, string methodName, Object[] args, CancellationToken cancellationToken);
    public abstract virtual Task SendConnectionsAsync(IReadOnlyList`1<string> connectionIds, string methodName, Object[] args, CancellationToken cancellationToken);
    public abstract virtual Task SendGroupAsync(string groupName, string methodName, Object[] args, CancellationToken cancellationToken);
    public abstract virtual Task SendGroupsAsync(IReadOnlyList`1<string> groupNames, string methodName, Object[] args, CancellationToken cancellationToken);
    public abstract virtual Task SendGroupExceptAsync(string groupName, string methodName, Object[] args, IReadOnlyList`1<string> excludedConnectionIds, CancellationToken cancellationToken);
    public abstract virtual Task SendUserAsync(string userId, string methodName, Object[] args, CancellationToken cancellationToken);
    public abstract virtual Task SendUsersAsync(IReadOnlyList`1<string> userIds, string methodName, Object[] args, CancellationToken cancellationToken);
    public abstract virtual Task AddToGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken);
    public abstract virtual Task RemoveFromGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken);
}
public class Microsoft.AspNetCore.SignalR.HubMetadata : object {
    [CompilerGeneratedAttribute]
private Type <HubType>k__BackingField;
    public Type HubType { get; }
    public HubMetadata(Type hubType);
    [CompilerGeneratedAttribute]
public Type get_HubType();
}
[AttributeUsageAttribute("64")]
public class Microsoft.AspNetCore.SignalR.HubMethodNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public HubMethodNameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
public class Microsoft.AspNetCore.SignalR.HubOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <HandshakeTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <KeepAliveInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <ClientTimeoutInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <SupportedProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaximumReceiveMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableDetailedErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <StreamBufferCapacity>k__BackingField;
    public Nullable`1<TimeSpan> HandshakeTimeout { get; public set; }
    public Nullable`1<TimeSpan> KeepAliveInterval { get; public set; }
    public Nullable`1<TimeSpan> ClientTimeoutInterval { get; public set; }
    public IList`1<string> SupportedProtocols { get; public set; }
    public Nullable`1<long> MaximumReceiveMessageSize { get; public set; }
    public Nullable`1<bool> EnableDetailedErrors { get; public set; }
    public Nullable`1<int> StreamBufferCapacity { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_HandshakeTimeout();
    [CompilerGeneratedAttribute]
public void set_HandshakeTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_KeepAliveInterval();
    [CompilerGeneratedAttribute]
public void set_KeepAliveInterval(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_ClientTimeoutInterval();
    [CompilerGeneratedAttribute]
public void set_ClientTimeoutInterval(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_SupportedProtocols();
    [CompilerGeneratedAttribute]
public void set_SupportedProtocols(IList`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaximumReceiveMessageSize();
    [CompilerGeneratedAttribute]
public void set_MaximumReceiveMessageSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableDetailedErrors();
    [CompilerGeneratedAttribute]
public void set_EnableDetailedErrors(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_StreamBufferCapacity();
    [CompilerGeneratedAttribute]
public void set_StreamBufferCapacity(Nullable`1<int> value);
}
public class Microsoft.AspNetCore.SignalR.HubOptions`1 : HubOptions {
    [CompilerGeneratedAttribute]
private bool <UserHasSetValues>k__BackingField;
    internal bool UserHasSetValues { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_UserHasSetValues();
    [CompilerGeneratedAttribute]
internal void set_UserHasSetValues(bool value);
}
public class Microsoft.AspNetCore.SignalR.HubOptionsSetup : object {
    internal static int DefaultMaximumMessageSize;
    internal static int DefaultStreamBufferCapacity;
    private List`1<string> _defaultProtocols;
    internal static TimeSpan DefaultHandshakeTimeout { get; }
    internal static TimeSpan DefaultKeepAliveInterval { get; }
    internal static TimeSpan DefaultClientTimeoutInterval { get; }
    public HubOptionsSetup(IEnumerable`1<IHubProtocol> protocols);
    internal static TimeSpan get_DefaultHandshakeTimeout();
    internal static TimeSpan get_DefaultKeepAliveInterval();
    internal static TimeSpan get_DefaultClientTimeoutInterval();
    public sealed virtual void Configure(HubOptions options);
}
public class Microsoft.AspNetCore.SignalR.HubOptionsSetup`1 : object {
    private HubOptions _hubOptions;
    public HubOptionsSetup`1(IOptions`1<HubOptions> options);
    public sealed virtual void Configure(HubOptions`1<THub> options);
}
public interface Microsoft.AspNetCore.SignalR.IClientProxy {
    public abstract virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
public interface Microsoft.AspNetCore.SignalR.IGroupManager {
    public abstract virtual Task AddToGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken);
    public abstract virtual Task RemoveFromGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken);
}
public interface Microsoft.AspNetCore.SignalR.IHubActivator`1 {
    public abstract virtual THub Create();
    public abstract virtual void Release(THub hub);
}
public interface Microsoft.AspNetCore.SignalR.IHubCallerClients {
}
public interface Microsoft.AspNetCore.SignalR.IHubCallerClients`1 {
    public T Caller { get; }
    public T Others { get; }
    public abstract virtual T get_Caller();
    public abstract virtual T get_Others();
    public abstract virtual T OthersInGroup(string groupName);
}
public interface Microsoft.AspNetCore.SignalR.IHubClients {
}
public interface Microsoft.AspNetCore.SignalR.IHubClients`1 {
    public T All { get; }
    public abstract virtual T get_All();
    public abstract virtual T AllExcept(IReadOnlyList`1<string> excludedConnectionIds);
    public abstract virtual T Client(string connectionId);
    public abstract virtual T Clients(IReadOnlyList`1<string> connectionIds);
    public abstract virtual T Group(string groupName);
    public abstract virtual T Groups(IReadOnlyList`1<string> groupNames);
    public abstract virtual T GroupExcept(string groupName, IReadOnlyList`1<string> excludedConnectionIds);
    public abstract virtual T User(string userId);
    public abstract virtual T Users(IReadOnlyList`1<string> userIds);
}
public interface Microsoft.AspNetCore.SignalR.IHubContext`1 {
    public IHubClients Clients { get; }
    public IGroupManager Groups { get; }
    public abstract virtual IHubClients get_Clients();
    public abstract virtual IGroupManager get_Groups();
}
public interface Microsoft.AspNetCore.SignalR.IHubContext`2 {
    public IHubClients`1<T> Clients { get; }
    public IGroupManager Groups { get; }
    public abstract virtual IHubClients`1<T> get_Clients();
    public abstract virtual IGroupManager get_Groups();
}
public interface Microsoft.AspNetCore.SignalR.IHubProtocolResolver {
    public IReadOnlyList`1<IHubProtocol> AllProtocols { get; }
    public abstract virtual IReadOnlyList`1<IHubProtocol> get_AllProtocols();
    public abstract virtual IHubProtocol GetProtocol(string protocolName, IReadOnlyList`1<string> supportedProtocols);
}
internal class Microsoft.AspNetCore.SignalR.Internal.AllClientProxy`1 : object {
    private HubLifetimeManager`1<THub> _lifetimeManager;
    public AllClientProxy`1(HubLifetimeManager`1<THub> lifetimeManager);
    public sealed virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.SignalR.Internal.AllClientsExceptProxy`1 : object {
    private HubLifetimeManager`1<THub> _lifetimeManager;
    private IReadOnlyList`1<string> _excludedConnectionIds;
    public AllClientsExceptProxy`1(HubLifetimeManager`1<THub> lifetimeManager, IReadOnlyList`1<string> excludedConnectionIds);
    public sealed virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.SignalR.Internal.AsyncDisposableExtensions : object {
    [ExtensionAttribute]
public static ValueTask DisposeAsync(IDisposable disposable);
}
internal static class Microsoft.AspNetCore.SignalR.Internal.AsyncEnumerableAdapters : object {
    public static IAsyncEnumerable`1<object> MakeCancelableAsyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable, CancellationToken cancellationToken);
    public static IAsyncEnumerable`1<T> MakeCancelableTypedAsyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable, CancellationTokenSource cts);
    [AsyncIteratorStateMachineAttribute("Microsoft.AspNetCore.SignalR.Internal.AsyncEnumerableAdapters/<MakeAsyncEnumerableFromChannel>d__2`1")]
public static IAsyncEnumerable`1<object> MakeAsyncEnumerableFromChannel(ChannelReader`1<T> channel, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.SignalR.Internal.DefaultHubActivator`1 : object {
    private static Lazy`1<ObjectFactory> _objectFactory;
    private IServiceProvider _serviceProvider;
    private Nullable`1<bool> _created;
    public DefaultHubActivator`1(IServiceProvider serviceProvider);
    private static DefaultHubActivator`1();
    public virtual THub Create();
    public virtual void Release(THub hub);
}
internal class Microsoft.AspNetCore.SignalR.Internal.DefaultHubCallerContext : HubCallerContext {
    private HubConnectionContext _connection;
    public string ConnectionId { get; }
    public string UserIdentifier { get; }
    public ClaimsPrincipal User { get; }
    public IDictionary`2<object, object> Items { get; }
    public IFeatureCollection Features { get; }
    public CancellationToken ConnectionAborted { get; }
    public DefaultHubCallerContext(HubConnectionContext connection);
    public virtual string get_ConnectionId();
    public virtual string get_UserIdentifier();
    public virtual ClaimsPrincipal get_User();
    public virtual IDictionary`2<object, object> get_Items();
    public virtual IFeatureCollection get_Features();
    public virtual CancellationToken get_ConnectionAborted();
    public virtual void Abort();
}
internal class Microsoft.AspNetCore.SignalR.Internal.DefaultHubDispatcher`1 : HubDispatcher`1<THub> {
    private Dictionary`2<string, HubMethodDescriptor> _methods;
    private IServiceScopeFactory _serviceScopeFactory;
    private IHubContext`1<THub> _hubContext;
    private ILogger`1<HubDispatcher`1<THub>> _logger;
    private bool _enableDetailedErrors;
    public DefaultHubDispatcher`1(IServiceScopeFactory serviceScopeFactory, IHubContext`1<THub> hubContext, bool enableDetailedErrors, ILogger`1<DefaultHubDispatcher`1<THub>> logger);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.Internal.DefaultHubDispatcher`1/<OnConnectedAsync>d__6")]
public virtual Task OnConnectedAsync(HubConnectionContext connection);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.Internal.DefaultHubDispatcher`1/<OnDisconnectedAsync>d__7")]
public virtual Task OnDisconnectedAsync(HubConnectionContext connection, Exception exception);
    public virtual Task DispatchMessageAsync(HubConnectionContext connection, HubMessage hubMessage);
    private Task ProcessInvocationBindingFailure(HubConnectionContext connection, InvocationBindingFailureMessage bindingFailureMessage);
    private Task ProcessStreamBindingFailure(HubConnectionContext connection, StreamBindingFailureMessage bindingFailureMessage);
    private Task ProcessStreamItem(HubConnectionContext connection, StreamItemMessage message);
    private Task ProcessInvocation(HubConnectionContext connection, HubMethodInvocationMessage hubMethodInvocationMessage, bool isStreamResponse);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.Internal.DefaultHubDispatcher`1/<Invoke>d__13")]
private Task Invoke(HubMethodDescriptor descriptor, HubConnectionContext connection, HubMethodInvocationMessage hubMethodInvocationMessage, bool isStreamResponse, bool isStreamCall);
    private ValueTask CleanupInvocation(HubConnectionContext connection, HubMethodInvocationMessage hubMessage, IHubActivator`1<THub> hubActivator, THub hub, IServiceScope scope);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.Internal.DefaultHubDispatcher`1/<StreamResultsAsync>d__15")]
private Task StreamResultsAsync(string invocationId, HubConnectionContext connection, IAsyncEnumerable`1<object> enumerable, IServiceScope scope, IHubActivator`1<THub> hubActivator, THub hub, CancellationTokenSource streamCts, HubMethodInvocationMessage hubMethodInvocationMessage);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.Internal.DefaultHubDispatcher`1/<ExecuteHubMethod>d__16")]
private static Task`1<object> ExecuteHubMethod(ObjectMethodExecutor methodExecutor, THub hub, Object[] arguments);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.Internal.DefaultHubDispatcher`1/<SendInvocationError>d__17")]
private Task SendInvocationError(string invocationId, HubConnectionContext connection, string errorMessage);
    private void InitializeHub(THub hub, HubConnectionContext connection);
    private Task`1<bool> IsHubMethodAuthorized(IServiceProvider provider, HubConnectionContext hubConnectionContext, IList`1<IAuthorizeData> policies, string hubMethodName, Object[] hubMethodArguments);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.Internal.DefaultHubDispatcher`1/<IsHubMethodAuthorizedSlow>d__20")]
private static Task`1<bool> IsHubMethodAuthorizedSlow(IServiceProvider provider, ClaimsPrincipal principal, IList`1<IAuthorizeData> policies, HubInvocationContext resource);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.SignalR.Internal.DefaultHubDispatcher`1/<ValidateInvocationMode>d__21")]
private Task`1<bool> ValidateInvocationMode(HubMethodDescriptor hubMethodDescriptor, bool isStreamResponse, HubMethodInvocationMessage hubMethodInvocationMessage, HubConnectionContext connection);
    private void DiscoverHubMethods();
    public virtual IReadOnlyList`1<Type> GetParameterTypes(string methodName);
}
internal class Microsoft.AspNetCore.SignalR.Internal.DefaultHubProtocolResolver : object {
    private ILogger`1<DefaultHubProtocolResolver> _logger;
    private List`1<IHubProtocol> _hubProtocols;
    private Dictionary`2<string, IHubProtocol> _availableProtocols;
    public IReadOnlyList`1<IHubProtocol> AllProtocols { get; }
    public DefaultHubProtocolResolver(IEnumerable`1<IHubProtocol> availableProtocols, ILogger`1<DefaultHubProtocolResolver> logger);
    public sealed virtual IReadOnlyList`1<IHubProtocol> get_AllProtocols();
    public virtual IHubProtocol GetProtocol(string protocolName, IReadOnlyList`1<string> supportedProtocols);
}
internal class Microsoft.AspNetCore.SignalR.Internal.DynamicClientProxy : DynamicObject {
    private IClientProxy _clientProxy;
    public DynamicClientProxy(IClientProxy clientProxy);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
}
internal static class Microsoft.AspNetCore.SignalR.Internal.ErrorMessageHelper : object {
    internal static string BuildErrorMessage(string message, Exception exception, bool includeExceptionDetails);
}
internal class Microsoft.AspNetCore.SignalR.Internal.GroupConnectionList : ConcurrentDictionary`2<string, HubConnectionContext> {
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.AspNetCore.SignalR.Internal.GroupExceptProxy`1 : object {
    private string _groupName;
    private HubLifetimeManager`1<THub> _lifetimeManager;
    private IReadOnlyList`1<string> _excludedConnectionIds;
    public GroupExceptProxy`1(HubLifetimeManager`1<THub> lifetimeManager, string groupName, IReadOnlyList`1<string> excludedConnectionIds);
    public sealed virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.SignalR.Internal.GroupManager`1 : object {
    private HubLifetimeManager`1<THub> _lifetimeManager;
    public GroupManager`1(HubLifetimeManager`1<THub> lifetimeManager);
    public sealed virtual Task AddToGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken);
    public sealed virtual Task RemoveFromGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.SignalR.Internal.GroupProxy`1 : object {
    private string _groupName;
    private HubLifetimeManager`1<THub> _lifetimeManager;
    public GroupProxy`1(HubLifetimeManager`1<THub> lifetimeManager, string groupName);
    public sealed virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.SignalR.Internal.HubCallerClients : object {
    private string _connectionId;
    private IHubClients _hubClients;
    private String[] _currentConnectionId;
    public IClientProxy Caller { get; }
    public IClientProxy Others { get; }
    public IClientProxy All { get; }
    public HubCallerClients(IHubClients hubClients, string connectionId);
    public sealed virtual IClientProxy get_Caller();
    public sealed virtual IClientProxy get_Others();
    public sealed virtual IClientProxy get_All();
    public sealed virtual IClientProxy AllExcept(IReadOnlyList`1<string> excludedConnectionIds);
    public sealed virtual IClientProxy Client(string connectionId);
    public sealed virtual IClientProxy Group(string groupName);
    public sealed virtual IClientProxy Groups(IReadOnlyList`1<string> groupNames);
    public sealed virtual IClientProxy OthersInGroup(string groupName);
    public sealed virtual IClientProxy GroupExcept(string groupName, IReadOnlyList`1<string> excludedConnectionIds);
    public sealed virtual IClientProxy User(string userId);
    public sealed virtual IClientProxy Clients(IReadOnlyList`1<string> connectionIds);
    public sealed virtual IClientProxy Users(IReadOnlyList`1<string> userIds);
}
internal class Microsoft.AspNetCore.SignalR.Internal.HubClients`1 : object {
    private HubLifetimeManager`1<THub> _lifetimeManager;
    [CompilerGeneratedAttribute]
private IClientProxy <All>k__BackingField;
    public IClientProxy All { get; }
    public HubClients`1(HubLifetimeManager`1<THub> lifetimeManager);
    [CompilerGeneratedAttribute]
public sealed virtual IClientProxy get_All();
    public sealed virtual IClientProxy AllExcept(IReadOnlyList`1<string> excludedConnectionIds);
    public sealed virtual IClientProxy Client(string connectionId);
    public sealed virtual IClientProxy Group(string groupName);
    public sealed virtual IClientProxy GroupExcept(string groupName, IReadOnlyList`1<string> excludedConnectionIds);
    public sealed virtual IClientProxy Clients(IReadOnlyList`1<string> connectionIds);
    public sealed virtual IClientProxy Groups(IReadOnlyList`1<string> groupNames);
    public sealed virtual IClientProxy User(string userId);
    public sealed virtual IClientProxy Users(IReadOnlyList`1<string> userIds);
}
internal class Microsoft.AspNetCore.SignalR.Internal.HubClients`2 : object {
    private HubLifetimeManager`1<THub> _lifetimeManager;
    [CompilerGeneratedAttribute]
private T <All>k__BackingField;
    public T All { get; }
    public HubClients`2(HubLifetimeManager`1<THub> lifetimeManager);
    [CompilerGeneratedAttribute]
public sealed virtual T get_All();
    public sealed virtual T AllExcept(IReadOnlyList`1<string> excludedConnectionIds);
    public virtual T Client(string connectionId);
    public sealed virtual T Clients(IReadOnlyList`1<string> connectionIds);
    public virtual T Group(string groupName);
    public sealed virtual T GroupExcept(string groupName, IReadOnlyList`1<string> excludedConnectionIds);
    public sealed virtual T Groups(IReadOnlyList`1<string> groupNames);
    public virtual T User(string userId);
    public virtual T Users(IReadOnlyList`1<string> userIds);
}
internal class Microsoft.AspNetCore.SignalR.Internal.HubConnectionBinder`1 : object {
    private HubDispatcher`1<THub> _dispatcher;
    private HubConnectionContext _connection;
    public HubConnectionBinder`1(HubDispatcher`1<THub> dispatcher, HubConnectionContext connection);
    public sealed virtual IReadOnlyList`1<Type> GetParameterTypes(string methodName);
    public sealed virtual Type GetReturnType(string invocationId);
    public sealed virtual Type GetStreamItemType(string streamId);
}
internal class Microsoft.AspNetCore.SignalR.Internal.HubContext`1 : object {
    private HubLifetimeManager`1<THub> _lifetimeManager;
    private IHubClients _clients;
    [CompilerGeneratedAttribute]
private IGroupManager <Groups>k__BackingField;
    public IHubClients Clients { get; }
    public IGroupManager Groups { get; }
    public HubContext`1(HubLifetimeManager`1<THub> lifetimeManager);
    public sealed virtual IHubClients get_Clients();
    [CompilerGeneratedAttribute]
public virtual IGroupManager get_Groups();
}
internal class Microsoft.AspNetCore.SignalR.Internal.HubContext`2 : object {
    private HubLifetimeManager`1<THub> _lifetimeManager;
    private IHubClients`1<T> _clients;
    [CompilerGeneratedAttribute]
private IGroupManager <Groups>k__BackingField;
    public IHubClients`1<T> Clients { get; }
    public IGroupManager Groups { get; }
    public HubContext`2(HubLifetimeManager`1<THub> lifetimeManager);
    public sealed virtual IHubClients`1<T> get_Clients();
    [CompilerGeneratedAttribute]
public virtual IGroupManager get_Groups();
}
internal abstract class Microsoft.AspNetCore.SignalR.Internal.HubDispatcher`1 : object {
    public abstract virtual Task OnConnectedAsync(HubConnectionContext connection);
    public abstract virtual Task OnDisconnectedAsync(HubConnectionContext connection, Exception exception);
    public abstract virtual Task DispatchMessageAsync(HubConnectionContext connection, HubMessage hubMessage);
    public abstract virtual IReadOnlyList`1<Type> GetParameterTypes(string name);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.SignalR.Internal.HubGroupList : object {
    private ConcurrentDictionary`2<string, GroupConnectionList> _groups;
    private static GroupConnectionList EmptyGroupConnectionList;
    public ConcurrentDictionary`2<string, HubConnectionContext> Item { get; }
    public int Count { get; }
    private static HubGroupList();
    public ConcurrentDictionary`2<string, HubConnectionContext> get_Item(string groupName);
    public void Add(HubConnectionContext connection, string groupName);
    public void Remove(string connectionId, string groupName);
    public void RemoveDisconnectedConnection(string connectionId);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<ConcurrentDictionary`2<string, HubConnectionContext>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void CreateOrUpdateGroupWithConnection(string groupName, HubConnectionContext connection);
    private static GroupConnectionList AddConnectionToGroup(HubConnectionContext connection, GroupConnectionList group);
}
internal class Microsoft.AspNetCore.SignalR.Internal.HubMethodDescriptor : object {
    private static MethodInfo MakeCancelableAsyncEnumerableMethod;
    private static MethodInfo MakeAsyncEnumerableFromChannelMethod;
    private MethodInfo _makeCancelableEnumerableMethodInfo;
    private Func`3<object, CancellationToken, IAsyncEnumerable`1<object>> _makeCancelableEnumerable;
    [CompilerGeneratedAttribute]
private List`1<Type> <StreamingParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectMethodExecutor <MethodExecutor>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Type> <ParameterTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Type> <OriginalParameterTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <NonAsyncReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StreamReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAuthorizeData> <Policies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSyntheticArguments>k__BackingField;
    public List`1<Type> StreamingParameters { get; private set; }
    public ObjectMethodExecutor MethodExecutor { get; }
    public IReadOnlyList`1<Type> ParameterTypes { get; }
    public IReadOnlyList`1<Type> OriginalParameterTypes { get; }
    public Type NonAsyncReturnType { get; }
    public bool IsStreamResponse { get; }
    public Type StreamReturnType { get; }
    public IList`1<IAuthorizeData> Policies { get; }
    public bool HasSyntheticArguments { get; private set; }
    public HubMethodDescriptor(ObjectMethodExecutor methodExecutor, IEnumerable`1<IAuthorizeData> policies);
    private static HubMethodDescriptor();
    [CompilerGeneratedAttribute]
public List`1<Type> get_StreamingParameters();
    [CompilerGeneratedAttribute]
private void set_StreamingParameters(List`1<Type> value);
    [CompilerGeneratedAttribute]
public ObjectMethodExecutor get_MethodExecutor();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Type> get_ParameterTypes();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Type> get_OriginalParameterTypes();
    [CompilerGeneratedAttribute]
public Type get_NonAsyncReturnType();
    public bool get_IsStreamResponse();
    [CompilerGeneratedAttribute]
public Type get_StreamReturnType();
    [CompilerGeneratedAttribute]
public IList`1<IAuthorizeData> get_Policies();
    [CompilerGeneratedAttribute]
public bool get_HasSyntheticArguments();
    [CompilerGeneratedAttribute]
private void set_HasSyntheticArguments(bool value);
    public IAsyncEnumerable`1<object> FromReturnedStream(object stream, CancellationToken cancellationToken);
    private static Func`3<object, CancellationToken, IAsyncEnumerable`1<object>> CompileConvertToEnumerable(MethodInfo adapterMethodInfo, Type streamReturnType);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__4_0(ParameterInfo p);
}
internal static class Microsoft.AspNetCore.SignalR.Internal.HubReflectionHelper : object {
    private static Type[] _excludeInterfaces;
    private static HubReflectionHelper();
    public static IEnumerable`1<MethodInfo> GetHubMethods(Type hubType);
    private static IEnumerable`1<MethodInfo> GetInterfaceMethods(Type type, Type iface);
    private static bool IsHubMethod(MethodInfo methodInfo);
}
internal class Microsoft.AspNetCore.SignalR.Internal.MultipleClientProxy`1 : object {
    private HubLifetimeManager`1<THub> _lifetimeManager;
    private IReadOnlyList`1<string> _connectionIds;
    public MultipleClientProxy`1(HubLifetimeManager`1<THub> lifetimeManager, IReadOnlyList`1<string> connectionIds);
    public sealed virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.SignalR.Internal.MultipleGroupProxy`1 : object {
    private HubLifetimeManager`1<THub> _lifetimeManager;
    private IReadOnlyList`1<string> _groupNames;
    public MultipleGroupProxy`1(HubLifetimeManager`1<THub> lifetimeManager, IReadOnlyList`1<string> groupNames);
    public sealed virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.SignalR.Internal.MultipleUserProxy`1 : object {
    private IReadOnlyList`1<string> _userIds;
    private HubLifetimeManager`1<THub> _lifetimeManager;
    public MultipleUserProxy`1(HubLifetimeManager`1<THub> lifetimeManager, IReadOnlyList`1<string> userIds);
    public sealed virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.SignalR.Internal.SignalRCoreMarkerService : object {
}
internal class Microsoft.AspNetCore.SignalR.Internal.SignalRServerBuilder : object {
    [CompilerGeneratedAttribute]
private IServiceCollection <Services>k__BackingField;
    public IServiceCollection Services { get; }
    public SignalRServerBuilder(IServiceCollection services);
    [CompilerGeneratedAttribute]
public sealed virtual IServiceCollection get_Services();
}
internal class Microsoft.AspNetCore.SignalR.Internal.SingleClientProxy`1 : object {
    private string _connectionId;
    private HubLifetimeManager`1<THub> _lifetimeManager;
    public SingleClientProxy`1(HubLifetimeManager`1<THub> lifetimeManager, string connectionId);
    public sealed virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.SignalR.Internal.TypeBaseEnumerationExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.SignalR.Internal.TypeBaseEnumerationExtensions/<AllBaseTypes>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<Type> AllBaseTypes(Type type);
}
internal static class Microsoft.AspNetCore.SignalR.Internal.TypedClientBuilder`1 : object {
    private static string ClientModuleName;
    private static Lazy`1<Func`2<IClientProxy, T>> _builder;
    private static PropertyInfo CancellationTokenNoneProperty;
    private static TypedClientBuilder`1();
    public static T Build(IClientProxy proxy);
    public static void Validate();
    private static Func`2<IClientProxy, T> GenerateClientBuilder();
    private static Type GenerateInterfaceImplementation(ModuleBuilder moduleBuilder);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.SignalR.Internal.TypedClientBuilder`1/<GetAllInterfaceMethods>d__7")]
private static IEnumerable`1<MethodInfo> GetAllInterfaceMethods(Type interfaceType);
    private static void BuildConstructor(TypeBuilder type, FieldInfo proxyField);
    private static void BuildMethod(TypeBuilder type, MethodInfo interfaceMethodInfo, FieldInfo proxyField);
    private static void VerifyInterface(Type interfaceType);
    private static void VerifyMethod(Type interfaceType, MethodInfo interfaceMethod);
}
internal class Microsoft.AspNetCore.SignalR.Internal.TypedHubClients`1 : object {
    private IHubCallerClients _hubClients;
    public T All { get; }
    public T Caller { get; }
    public T Others { get; }
    public TypedHubClients`1(IHubCallerClients dynamicContext);
    public sealed virtual T get_All();
    public sealed virtual T get_Caller();
    public sealed virtual T get_Others();
    public sealed virtual T AllExcept(IReadOnlyList`1<string> excludedConnectionIds);
    public sealed virtual T Client(string connectionId);
    public sealed virtual T Group(string groupName);
    public sealed virtual T GroupExcept(string groupName, IReadOnlyList`1<string> excludedConnectionIds);
    public sealed virtual T Clients(IReadOnlyList`1<string> connectionIds);
    public sealed virtual T Groups(IReadOnlyList`1<string> groupNames);
    public sealed virtual T OthersInGroup(string groupName);
    public sealed virtual T User(string userId);
    public sealed virtual T Users(IReadOnlyList`1<string> userIds);
}
internal class Microsoft.AspNetCore.SignalR.Internal.UserProxy`1 : object {
    private string _userId;
    private HubLifetimeManager`1<THub> _lifetimeManager;
    public UserProxy`1(HubLifetimeManager`1<THub> lifetimeManager, string userId);
    public sealed virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
public interface Microsoft.AspNetCore.SignalR.ISignalRServerBuilder {
}
public interface Microsoft.AspNetCore.SignalR.IUserIdProvider {
    public abstract virtual string GetUserId(HubConnectionContext connection);
}
internal static class Microsoft.AspNetCore.SignalR.ReflectionHelper : object {
    public static bool IsStreamingType(Type type, bool mustBeDirectType);
    public static bool IsIAsyncEnumerable(Type type);
}
public class Microsoft.AspNetCore.SignalR.SerializedHubMessage : object {
    private SerializedMessage _cachedItem1;
    private SerializedMessage _cachedItem2;
    private List`1<SerializedMessage> _cachedItems;
    private object _lock;
    [CompilerGeneratedAttribute]
private HubMessage <Message>k__BackingField;
    public HubMessage Message { get; }
    public SerializedHubMessage(IReadOnlyList`1<SerializedMessage> messages);
    public SerializedHubMessage(HubMessage message);
    [CompilerGeneratedAttribute]
public HubMessage get_Message();
    public ReadOnlyMemory`1<byte> GetSerializedMessage(IHubProtocol protocol);
    internal IReadOnlyList`1<SerializedMessage> GetAllSerializations();
    private void SetCacheUnsynchronized(string protocolName, ReadOnlyMemory`1<byte> serialized);
    private bool TryGetCachedUnsynchronized(string protocolName, ReadOnlyMemory`1& result);
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.SignalR.SerializedMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <ProtocolName>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Serialized>k__BackingField;
    public string ProtocolName { get; }
    public ReadOnlyMemory`1<byte> Serialized { get; }
    public SerializedMessage(string protocolName, ReadOnlyMemory`1<byte> serialized);
    [CompilerGeneratedAttribute]
public string get_ProtocolName();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Serialized();
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.SignalR.SignalRConnectionBuilderExtensions : object {
    [ExtensionAttribute]
public static IConnectionBuilder UseHub(IConnectionBuilder connectionBuilder);
}
internal class Microsoft.AspNetCore.SignalR.StreamTracker : object {
    private static MethodInfo _buildConverterMethod;
    private Object[] _streamConverterArgs;
    private ConcurrentDictionary`2<string, IStreamConverter> _lookup;
    public StreamTracker(int streamBufferCapacity);
    private static StreamTracker();
    public object AddStream(string streamId, Type itemType, Type targetType);
    private bool TryGetConverter(string streamId, IStreamConverter& converter);
    public bool TryProcessItem(StreamItemMessage message, Task& task);
    public Type GetStreamItemType(string streamId);
    public bool TryComplete(CompletionMessage message);
    public void CompleteAll(Exception ex);
    private static IStreamConverter BuildStream(int streamBufferCapacity);
}
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.SignalRDependencyInjectionExtensions : object {
    [ExtensionAttribute]
public static ISignalRServerBuilder AddSignalRCore(IServiceCollection services);
}
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Internal.AwaitableInfo : ValueType {
    [CompilerGeneratedAttribute]
private Type <AwaiterType>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <AwaiterIsCompletedProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <AwaiterGetResultMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <AwaiterOnCompletedMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <AwaiterUnsafeOnCompletedMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResultType>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <GetAwaiterMethod>k__BackingField;
    public Type AwaiterType { get; }
    public PropertyInfo AwaiterIsCompletedProperty { get; }
    public MethodInfo AwaiterGetResultMethod { get; }
    public MethodInfo AwaiterOnCompletedMethod { get; }
    public MethodInfo AwaiterUnsafeOnCompletedMethod { get; }
    public Type ResultType { get; }
    public MethodInfo GetAwaiterMethod { get; }
    public AwaitableInfo(Type awaiterType, PropertyInfo awaiterIsCompletedProperty, MethodInfo awaiterGetResultMethod, MethodInfo awaiterOnCompletedMethod, MethodInfo awaiterUnsafeOnCompletedMethod, Type resultType, MethodInfo getAwaiterMethod);
    [CompilerGeneratedAttribute]
public Type get_AwaiterType();
    [CompilerGeneratedAttribute]
public PropertyInfo get_AwaiterIsCompletedProperty();
    [CompilerGeneratedAttribute]
public MethodInfo get_AwaiterGetResultMethod();
    [CompilerGeneratedAttribute]
public MethodInfo get_AwaiterOnCompletedMethod();
    [CompilerGeneratedAttribute]
public MethodInfo get_AwaiterUnsafeOnCompletedMethod();
    [CompilerGeneratedAttribute]
public Type get_ResultType();
    [CompilerGeneratedAttribute]
public MethodInfo get_GetAwaiterMethod();
    public static bool IsTypeAwaitable(Type type, AwaitableInfo& awaitableInfo);
}
internal static class Microsoft.Extensions.Internal.ClosedGenericMatcher : object {
    public static Type ExtractGenericInterface(Type queryType, Type interfaceType);
    private static bool IsGenericInstantiation(Type candidate, Type interfaceType);
    private static Type GetGenericInstantiation(Type queryType, Type interfaceType);
}
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Internal.CoercedAwaitableInfo : ValueType {
    [CompilerGeneratedAttribute]
private AwaitableInfo <AwaitableInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <CoercerExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CoercerResultType>k__BackingField;
    public AwaitableInfo AwaitableInfo { get; }
    public Expression CoercerExpression { get; }
    public Type CoercerResultType { get; }
    public bool RequiresCoercion { get; }
    public CoercedAwaitableInfo(AwaitableInfo awaitableInfo);
    public CoercedAwaitableInfo(Expression coercerExpression, Type coercerResultType, AwaitableInfo coercedAwaitableInfo);
    [CompilerGeneratedAttribute]
public AwaitableInfo get_AwaitableInfo();
    [CompilerGeneratedAttribute]
public Expression get_CoercerExpression();
    [CompilerGeneratedAttribute]
public Type get_CoercerResultType();
    public bool get_RequiresCoercion();
    public static bool IsTypeAwaitable(Type type, CoercedAwaitableInfo& info);
}
internal class Microsoft.Extensions.Internal.ObjectMethodExecutor : object {
    private Object[] _parameterDefaultValues;
    private MethodExecutorAsync _executorAsync;
    private MethodExecutor _executor;
    private static ConstructorInfo _objectMethodExecutorAwaitableConstructor;
    [CompilerGeneratedAttribute]
private MethodInfo <MethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterInfo[] <MethodParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInfo <TargetTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <AsyncResultType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MethodReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMethodAsync>k__BackingField;
    public MethodInfo MethodInfo { get; }
    public ParameterInfo[] MethodParameters { get; }
    public TypeInfo TargetTypeInfo { get; }
    public Type AsyncResultType { get; }
    public Type MethodReturnType { get; internal set; }
    public bool IsMethodAsync { get; }
    private ObjectMethodExecutor(MethodInfo methodInfo, TypeInfo targetTypeInfo, Object[] parameterDefaultValues);
    private static ObjectMethodExecutor();
    [CompilerGeneratedAttribute]
public MethodInfo get_MethodInfo();
    [CompilerGeneratedAttribute]
public ParameterInfo[] get_MethodParameters();
    [CompilerGeneratedAttribute]
public TypeInfo get_TargetTypeInfo();
    [CompilerGeneratedAttribute]
public Type get_AsyncResultType();
    [CompilerGeneratedAttribute]
public Type get_MethodReturnType();
    [CompilerGeneratedAttribute]
internal void set_MethodReturnType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsMethodAsync();
    public static ObjectMethodExecutor Create(MethodInfo methodInfo, TypeInfo targetTypeInfo);
    public static ObjectMethodExecutor Create(MethodInfo methodInfo, TypeInfo targetTypeInfo, Object[] parameterDefaultValues);
    public object Execute(object target, Object[] parameters);
    public ObjectMethodExecutorAwaitable ExecuteAsync(object target, Object[] parameters);
    public object GetDefaultValueForParameter(int index);
    private static MethodExecutor GetExecutor(MethodInfo methodInfo, TypeInfo targetTypeInfo);
    private static MethodExecutor WrapVoidMethod(VoidMethodExecutor executor);
    private static MethodExecutorAsync GetExecutorAsync(MethodInfo methodInfo, TypeInfo targetTypeInfo, CoercedAwaitableInfo coercedAwaitableInfo);
}
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Internal.ObjectMethodExecutorAwaitable : ValueType {
    private object _customAwaitable;
    private Func`2<object, object> _getAwaiterMethod;
    private Func`2<object, bool> _isCompletedMethod;
    private Func`2<object, object> _getResultMethod;
    private Action`2<object, Action> _onCompletedMethod;
    private Action`2<object, Action> _unsafeOnCompletedMethod;
    public ObjectMethodExecutorAwaitable(object customAwaitable, Func`2<object, object> getAwaiterMethod, Func`2<object, bool> isCompletedMethod, Func`2<object, object> getResultMethod, Action`2<object, Action> onCompletedMethod, Action`2<object, Action> unsafeOnCompletedMethod);
    public Awaiter GetAwaiter();
}
internal static class Microsoft.Extensions.Internal.ObjectMethodExecutorFSharpSupport : object {
    private static object _fsharpValuesCacheLock;
    private static Assembly _fsharpCoreAssembly;
    private static MethodInfo _fsharpAsyncStartAsTaskGenericMethod;
    private static PropertyInfo _fsharpOptionOfTaskCreationOptionsNoneProperty;
    private static PropertyInfo _fsharpOptionOfCancellationTokenNoneProperty;
    private static ObjectMethodExecutorFSharpSupport();
    public static bool TryBuildCoercerFromFSharpAsyncToAwaitable(Type possibleFSharpAsyncType, Expression& coerceToAwaitableExpression, Type& awaitableType);
    private static bool IsFSharpAsyncOpenGenericType(Type possibleFSharpAsyncGenericType);
    private static bool TryPopulateFSharpValueCaches(Type possibleFSharpAsyncGenericType);
    private static bool TypesHaveSameIdentity(Type type1, Type type2);
}
