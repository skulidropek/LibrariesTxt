internal static class FxResources.System.Security.Permissions.SR : object {
}
public class System.ApplicationIdentity : object {
    public string FullName { get; }
    public string CodeBase { get; }
    public ApplicationIdentity(string applicationIdentityFullName);
    private ApplicationIdentity(SerializationInfo info, StreamingContext context);
    public string get_FullName();
    public string get_CodeBase();
    public virtual string ToString();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Configuration.ConfigurationPermission : CodeAccessPermission {
    public ConfigurationPermission(PermissionState state);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("32767")]
public class System.Configuration.ConfigurationPermissionAttribute : CodeAccessSecurityAttribute {
    public ConfigurationPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
public abstract class System.Data.Common.DBDataPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private bool <AllowBlankPassword>k__BackingField;
    public bool AllowBlankPassword { get; public set; }
    protected DBDataPermission(DBDataPermission dataPermission);
    protected DBDataPermission(DBDataPermissionAttribute attribute);
    protected DBDataPermission(PermissionState state);
    protected DBDataPermission(PermissionState state, bool blankPassword);
    [CompilerGeneratedAttribute]
public bool get_AllowBlankPassword();
    [CompilerGeneratedAttribute]
public void set_AllowBlankPassword(bool value);
    public virtual void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior);
    protected void Clear();
    protected virtual DBDataPermission CreateInstance();
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement elem);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission other);
}
[AttributeUsageAttribute("109")]
public abstract class System.Data.Common.DBDataPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private bool <AllowBlankPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyRestrictionBehavior <KeyRestrictionBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyRestrictions>k__BackingField;
    public bool AllowBlankPassword { get; public set; }
    public string ConnectionString { get; public set; }
    public KeyRestrictionBehavior KeyRestrictionBehavior { get; public set; }
    public string KeyRestrictions { get; public set; }
    protected DBDataPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public bool get_AllowBlankPassword();
    [CompilerGeneratedAttribute]
public void set_AllowBlankPassword(bool value);
    [CompilerGeneratedAttribute]
public string get_ConnectionString();
    [CompilerGeneratedAttribute]
public void set_ConnectionString(string value);
    [CompilerGeneratedAttribute]
public KeyRestrictionBehavior get_KeyRestrictionBehavior();
    [CompilerGeneratedAttribute]
public void set_KeyRestrictionBehavior(KeyRestrictionBehavior value);
    [CompilerGeneratedAttribute]
public string get_KeyRestrictions();
    [CompilerGeneratedAttribute]
public void set_KeyRestrictions(string value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeConnectionString();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyRestrictions();
}
public class System.Data.Odbc.OdbcPermission : DBDataPermission {
    public OdbcPermission(PermissionState state);
    public OdbcPermission(PermissionState state, bool allowBlankPassword);
    public virtual void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior);
    public virtual IPermission Copy();
}
[AttributeUsageAttribute("109")]
public class System.Data.Odbc.OdbcPermissionAttribute : DBDataPermissionAttribute {
    public OdbcPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
public class System.Data.OleDb.OleDbPermission : DBDataPermission {
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public string Provider { get; public set; }
    public OleDbPermission(PermissionState state);
    public OleDbPermission(PermissionState state, bool allowBlankPassword);
    public string get_Provider();
    public void set_Provider(string value);
    public virtual IPermission Copy();
}
[AttributeUsageAttribute("109")]
public class System.Data.OleDb.OleDbPermissionAttribute : DBDataPermissionAttribute {
    [EditorBrowsableAttribute("1")]
[BrowsableAttribute("False")]
public string Provider { get; public set; }
    public OleDbPermissionAttribute(SecurityAction action);
    public string get_Provider();
    public void set_Provider(string value);
    public virtual IPermission CreatePermission();
}
public class System.Data.OracleClient.OraclePermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private bool <AllowBlankPassword>k__BackingField;
    public bool AllowBlankPassword { get; public set; }
    public OraclePermission(PermissionState state);
    [CompilerGeneratedAttribute]
public bool get_AllowBlankPassword();
    [CompilerGeneratedAttribute]
public void set_AllowBlankPassword(bool value);
    public void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Data.OracleClient.OraclePermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private bool <AllowBlankPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyRestrictionBehavior <KeyRestrictionBehavior>k__BackingField;
    public bool AllowBlankPassword { get; public set; }
    public string ConnectionString { get; public set; }
    public KeyRestrictionBehavior KeyRestrictionBehavior { get; public set; }
    public string KeyRestrictions { get; public set; }
    public OraclePermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public bool get_AllowBlankPassword();
    [CompilerGeneratedAttribute]
public void set_AllowBlankPassword(bool value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    [CompilerGeneratedAttribute]
public KeyRestrictionBehavior get_KeyRestrictionBehavior();
    [CompilerGeneratedAttribute]
public void set_KeyRestrictionBehavior(KeyRestrictionBehavior value);
    public string get_KeyRestrictions();
    public void set_KeyRestrictions(string value);
    public virtual IPermission CreatePermission();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeConnectionString();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyRestrictions();
}
public class System.Data.SqlClient.SqlClientPermission : DBDataPermission {
    public SqlClientPermission(PermissionState state);
    public SqlClientPermission(PermissionState state, bool allowBlankPassword);
    public virtual void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior);
    public virtual IPermission Copy();
}
[AttributeUsageAttribute("109")]
public class System.Data.SqlClient.SqlClientPermissionAttribute : DBDataPermissionAttribute {
    public SqlClientPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
public class System.Diagnostics.EventLogPermission : ResourcePermissionBase {
    [CompilerGeneratedAttribute]
private EventLogPermissionEntryCollection <PermissionEntries>k__BackingField;
    public EventLogPermissionEntryCollection PermissionEntries { get; }
    public EventLogPermission(EventLogPermissionAccess permissionAccess, string machineName);
    public EventLogPermission(EventLogPermissionEntry[] permissionAccessEntries);
    public EventLogPermission(PermissionState state);
    [CompilerGeneratedAttribute]
public EventLogPermissionEntryCollection get_PermissionEntries();
}
[FlagsAttribute]
public enum System.Diagnostics.EventLogPermissionAccess : Enum {
    public int value__;
    public static EventLogPermissionAccess Administer;
    public static EventLogPermissionAccess Audit;
    public static EventLogPermissionAccess Browse;
    public static EventLogPermissionAccess Instrument;
    public static EventLogPermissionAccess None;
    public static EventLogPermissionAccess Write;
}
[AttributeUsageAttribute("621")]
public class System.Diagnostics.EventLogPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private EventLogPermissionAccess <PermissionAccess>k__BackingField;
    public string MachineName { get; public set; }
    public EventLogPermissionAccess PermissionAccess { get; public set; }
    public EventLogPermissionAttribute(SecurityAction action);
    public string get_MachineName();
    public void set_MachineName(string value);
    [CompilerGeneratedAttribute]
public EventLogPermissionAccess get_PermissionAccess();
    [CompilerGeneratedAttribute]
public void set_PermissionAccess(EventLogPermissionAccess value);
    public virtual IPermission CreatePermission();
}
public class System.Diagnostics.EventLogPermissionEntry : object {
    [CompilerGeneratedAttribute]
private EventLogPermissionAccess <PermissionAccess>k__BackingField;
    public string MachineName { get; }
    public EventLogPermissionAccess PermissionAccess { get; }
    public EventLogPermissionEntry(EventLogPermissionAccess permissionAccess, string machineName);
    public string get_MachineName();
    [CompilerGeneratedAttribute]
public EventLogPermissionAccess get_PermissionAccess();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.EventLogPermissionEntryCollection : CollectionBase {
    public EventLogPermissionEntry Item { get; public set; }
    public EventLogPermissionEntry get_Item(int index);
    public void set_Item(int index, EventLogPermissionEntry value);
    public int Add(EventLogPermissionEntry value);
    public void AddRange(EventLogPermissionEntryCollection value);
    public void AddRange(EventLogPermissionEntry[] value);
    public bool Contains(EventLogPermissionEntry value);
    public void CopyTo(EventLogPermissionEntry[] array, int index);
    public int IndexOf(EventLogPermissionEntry value);
    public void Insert(int index, EventLogPermissionEntry value);
    protected virtual void OnClear();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnSet(int index, object oldValue, object newValue);
    public void Remove(EventLogPermissionEntry value);
}
public class System.Diagnostics.PerformanceCounterPermission : ResourcePermissionBase {
    public PerformanceCounterPermissionEntryCollection PermissionEntries { get; }
    public PerformanceCounterPermission(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName);
    public PerformanceCounterPermission(PerformanceCounterPermissionEntry[] permissionAccessEntries);
    public PerformanceCounterPermission(PermissionState state);
    public PerformanceCounterPermissionEntryCollection get_PermissionEntries();
}
[FlagsAttribute]
public enum System.Diagnostics.PerformanceCounterPermissionAccess : Enum {
    public int value__;
    public static PerformanceCounterPermissionAccess Administer;
    public static PerformanceCounterPermissionAccess Browse;
    public static PerformanceCounterPermissionAccess Instrument;
    public static PerformanceCounterPermissionAccess None;
    public static PerformanceCounterPermissionAccess Read;
    public static PerformanceCounterPermissionAccess Write;
}
[AttributeUsageAttribute("621")]
public class System.Diagnostics.PerformanceCounterPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private PerformanceCounterPermissionAccess <PermissionAccess>k__BackingField;
    public string CategoryName { get; public set; }
    public string MachineName { get; public set; }
    public PerformanceCounterPermissionAccess PermissionAccess { get; public set; }
    public PerformanceCounterPermissionAttribute(SecurityAction action);
    public string get_CategoryName();
    public void set_CategoryName(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    [CompilerGeneratedAttribute]
public PerformanceCounterPermissionAccess get_PermissionAccess();
    [CompilerGeneratedAttribute]
public void set_PermissionAccess(PerformanceCounterPermissionAccess value);
    public virtual IPermission CreatePermission();
}
public class System.Diagnostics.PerformanceCounterPermissionEntry : object {
    [CompilerGeneratedAttribute]
private PerformanceCounterPermissionAccess <PermissionAccess>k__BackingField;
    public string CategoryName { get; }
    public string MachineName { get; }
    public PerformanceCounterPermissionAccess PermissionAccess { get; }
    public PerformanceCounterPermissionEntry(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName);
    public string get_CategoryName();
    public string get_MachineName();
    [CompilerGeneratedAttribute]
public PerformanceCounterPermissionAccess get_PermissionAccess();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.PerformanceCounterPermissionEntryCollection : CollectionBase {
    public PerformanceCounterPermissionEntry Item { get; public set; }
    public PerformanceCounterPermissionEntry get_Item(int index);
    public void set_Item(int index, PerformanceCounterPermissionEntry value);
    public int Add(PerformanceCounterPermissionEntry value);
    public void AddRange(PerformanceCounterPermissionEntryCollection value);
    public void AddRange(PerformanceCounterPermissionEntry[] value);
    public bool Contains(PerformanceCounterPermissionEntry value);
    public void CopyTo(PerformanceCounterPermissionEntry[] array, int index);
    public int IndexOf(PerformanceCounterPermissionEntry value);
    public void Insert(int index, PerformanceCounterPermissionEntry value);
    protected virtual void OnClear();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnSet(int index, object oldValue, object newValue);
    public void Remove(PerformanceCounterPermissionEntry value);
}
public class System.Drawing.Printing.PrintingPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private PrintingPermissionLevel <Level>k__BackingField;
    public PrintingPermissionLevel Level { get; public set; }
    public PrintingPermission(PrintingPermissionLevel printingLevel);
    public PrintingPermission(PermissionState state);
    [CompilerGeneratedAttribute]
public PrintingPermissionLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(PrintingPermissionLevel value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement element);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("32767")]
public class System.Drawing.Printing.PrintingPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private PrintingPermissionLevel <Level>k__BackingField;
    public PrintingPermissionLevel Level { get; public set; }
    public PrintingPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public PrintingPermissionLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(PrintingPermissionLevel value);
    public virtual IPermission CreatePermission();
}
public enum System.Drawing.Printing.PrintingPermissionLevel : Enum {
    public int value__;
    public static PrintingPermissionLevel AllPrinting;
    public static PrintingPermissionLevel DefaultPrinting;
    public static PrintingPermissionLevel NoPrinting;
    public static PrintingPermissionLevel SafePrinting;
}
public class System.Net.DnsPermission : CodeAccessPermission {
    public DnsPermission(PermissionState state);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Net.DnsPermissionAttribute : CodeAccessSecurityAttribute {
    public DnsPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
public class System.Net.EndpointPermission : object {
    [CompilerGeneratedAttribute]
private TransportType <Transport>k__BackingField;
    public string Hostname { get; }
    public int Port { get; }
    public TransportType Transport { get; }
    public string get_Hostname();
    public int get_Port();
    [CompilerGeneratedAttribute]
public TransportType get_Transport();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.Net.Mail.SmtpAccess : Enum {
    public int value__;
    public static SmtpAccess Connect;
    public static SmtpAccess ConnectToUnrestrictedPort;
    public static SmtpAccess None;
}
public class System.Net.Mail.SmtpPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private SmtpAccess <Access>k__BackingField;
    public SmtpAccess Access { get; }
    public SmtpPermission(bool unrestricted);
    public SmtpPermission(SmtpAccess access);
    public SmtpPermission(PermissionState state);
    [CompilerGeneratedAttribute]
public SmtpAccess get_Access();
    public void AddPermission(SmtpAccess access);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Net.Mail.SmtpPermissionAttribute : CodeAccessSecurityAttribute {
    public string Access { get; public set; }
    public SmtpPermissionAttribute(SecurityAction action);
    public string get_Access();
    public void set_Access(string value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Net.NetworkAccess : Enum {
    public int value__;
    public static NetworkAccess Accept;
    public static NetworkAccess Connect;
}
[FlagsAttribute]
public enum System.Net.NetworkInformation.NetworkInformationAccess : Enum {
    public int value__;
    public static NetworkInformationAccess None;
    public static NetworkInformationAccess Read;
    public static NetworkInformationAccess Ping;
}
public class System.Net.NetworkInformation.NetworkInformationPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private NetworkInformationAccess <Access>k__BackingField;
    public NetworkInformationAccess Access { get; }
    public NetworkInformationPermission(PermissionState state);
    public NetworkInformationPermission(NetworkInformationAccess access);
    [CompilerGeneratedAttribute]
public NetworkInformationAccess get_Access();
    public void AddPermission(NetworkInformationAccess access);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public class System.Net.NetworkInformation.NetworkInformationPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private string <Access>k__BackingField;
    public string Access { get; public set; }
    public NetworkInformationPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public string get_Access();
    [CompilerGeneratedAttribute]
public void set_Access(string value);
    public virtual IPermission CreatePermission();
}
public class System.Net.PeerToPeer.Collaboration.PeerCollaborationPermission : CodeAccessPermission {
    public PeerCollaborationPermission(PermissionState state);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement e);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Net.PeerToPeer.Collaboration.PeerCollaborationPermissionAttribute : CodeAccessSecurityAttribute {
    public PeerCollaborationPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
public class System.Net.PeerToPeer.PnrpPermission : CodeAccessPermission {
    public PnrpPermission(PermissionState state);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement e);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Net.PeerToPeer.PnrpPermissionAttribute : CodeAccessSecurityAttribute {
    public PnrpPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
public enum System.Net.PeerToPeer.PnrpScope : Enum {
    public int value__;
    public static PnrpScope All;
    public static PnrpScope Global;
    public static PnrpScope LinkLocal;
    public static PnrpScope SiteLocal;
}
public class System.Net.SocketPermission : CodeAccessPermission {
    public static int AllPorts;
    public IEnumerator AcceptList { get; }
    public IEnumerator ConnectList { get; }
    public SocketPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber);
    public SocketPermission(PermissionState state);
    public IEnumerator get_AcceptList();
    public IEnumerator get_ConnectList();
    public void AddPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Net.SocketPermissionAttribute : CodeAccessSecurityAttribute {
    public string Access { get; public set; }
    public string Host { get; public set; }
    public string Port { get; public set; }
    public string Transport { get; public set; }
    public SocketPermissionAttribute(SecurityAction action);
    public string get_Access();
    public void set_Access(string value);
    public string get_Host();
    public void set_Host(string value);
    public string get_Port();
    public void set_Port(string value);
    public string get_Transport();
    public void set_Transport(string value);
    public virtual IPermission CreatePermission();
}
public enum System.Net.TransportType : Enum {
    public int value__;
    public static TransportType All;
    public static TransportType Connectionless;
    public static TransportType ConnectionOriented;
    public static TransportType Tcp;
    public static TransportType Udp;
}
public class System.Net.WebPermission : CodeAccessPermission {
    public IEnumerator AcceptList { get; }
    public IEnumerator ConnectList { get; }
    public WebPermission(NetworkAccess access, string uriString);
    public WebPermission(NetworkAccess access, Regex uriRegex);
    public WebPermission(PermissionState state);
    public IEnumerator get_AcceptList();
    public IEnumerator get_ConnectList();
    public void AddPermission(NetworkAccess access, string uriString);
    public void AddPermission(NetworkAccess access, Regex uriRegex);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Net.WebPermissionAttribute : CodeAccessSecurityAttribute {
    public string Accept { get; public set; }
    public string AcceptPattern { get; public set; }
    public string Connect { get; public set; }
    public string ConnectPattern { get; public set; }
    public WebPermissionAttribute(SecurityAction action);
    public string get_Accept();
    public void set_Accept(string value);
    public string get_AcceptPattern();
    public void set_AcceptPattern(string value);
    public string get_Connect();
    public void set_Connect(string value);
    public string get_ConnectPattern();
    public void set_ConnectPattern(string value);
    public virtual IPermission CreatePermission();
}
public abstract class System.Security.CodeAccessPermission : object {
    public sealed virtual void Assert();
    public abstract virtual IPermission Copy();
    public sealed virtual void Demand();
    [ObsoleteAttribute]
public sealed virtual void Deny();
    public virtual bool Equals(object obj);
    public abstract virtual void FromXml(SecurityElement elem);
    public virtual int GetHashCode();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    public sealed virtual void PermitOnly();
    public static void RevertAll();
    public static void RevertAssert();
    [ObsoleteAttribute]
public static void RevertDeny();
    public static void RevertPermitOnly();
    public virtual string ToString();
    public abstract virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission other);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.HostProtectionException : SystemException {
    private static string ProtectedResourcesName;
    private static string DemandedResourcesName;
    private static int E_HostProtection;
    [CompilerGeneratedAttribute]
private HostProtectionResource <DemandedResources>k__BackingField;
    [CompilerGeneratedAttribute]
private HostProtectionResource <ProtectedResources>k__BackingField;
    public HostProtectionResource DemandedResources { get; }
    public HostProtectionResource ProtectedResources { get; }
    public HostProtectionException(string message);
    public HostProtectionException(string message, Exception e);
    public HostProtectionException(string message, HostProtectionResource protectedResources, HostProtectionResource demandedResources);
    protected HostProtectionException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public HostProtectionResource get_DemandedResources();
    [CompilerGeneratedAttribute]
public HostProtectionResource get_ProtectedResources();
    private void AppendResourceString(string resourceString, object attr, StringBuilder sb);
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Security.HostSecurityManager : object {
    public PolicyLevel DomainPolicy { get; }
    public HostSecurityManagerOptions Flags { get; }
    public virtual PolicyLevel get_DomainPolicy();
    public virtual HostSecurityManagerOptions get_Flags();
    public virtual ApplicationTrust DetermineApplicationTrust(Evidence applicationEvidence, Evidence activatorEvidence, TrustManagerContext context);
    public virtual Evidence ProvideAppDomainEvidence(Evidence inputEvidence);
    public virtual Evidence ProvideAssemblyEvidence(Assembly loadedAssembly, Evidence inputEvidence);
    [ObsoleteAttribute]
public virtual PermissionSet ResolvePolicy(Evidence evidence);
    public virtual EvidenceBase GenerateAppDomainEvidence(Type evidenceType);
    public virtual EvidenceBase GenerateAssemblyEvidence(Type evidenceType, Assembly assembly);
    public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes();
    public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes(Assembly assembly);
}
[FlagsAttribute]
public enum System.Security.HostSecurityManagerOptions : Enum {
    public int value__;
    public static HostSecurityManagerOptions AllFlags;
    public static HostSecurityManagerOptions HostAppDomainEvidence;
    public static HostSecurityManagerOptions HostAssemblyEvidence;
    public static HostSecurityManagerOptions HostDetermineApplicationTrust;
    public static HostSecurityManagerOptions HostPolicyLevel;
    public static HostSecurityManagerOptions HostResolvePolicy;
    public static HostSecurityManagerOptions None;
}
public interface System.Security.IEvidenceFactory {
    public Evidence Evidence { get; }
    public abstract virtual Evidence get_Evidence();
}
public interface System.Security.ISecurityPolicyEncodable {
    public abstract virtual void FromXml(SecurityElement e, PolicyLevel level);
    public abstract virtual SecurityElement ToXml(PolicyLevel level);
}
public class System.Security.NamedPermissionSet : PermissionSet {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Description { get; public set; }
    public string Name { get; public set; }
    public NamedPermissionSet(NamedPermissionSet permSet);
    public NamedPermissionSet(string name);
    public NamedPermissionSet(string name, PermissionState state);
    public NamedPermissionSet(string name, PermissionSet permSet);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual PermissionSet Copy();
    public NamedPermissionSet Copy(string name);
    public virtual bool Equals(object o);
    public virtual void FromXml(SecurityElement et);
    public virtual int GetHashCode();
    public virtual SecurityElement ToXml();
}
public class System.Security.Permissions.DataProtectionPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private DataProtectionPermissionFlags <Flags>k__BackingField;
    public DataProtectionPermissionFlags Flags { get; public set; }
    public DataProtectionPermission(PermissionState state);
    public DataProtectionPermission(DataProtectionPermissionFlags flag);
    public sealed virtual bool IsUnrestricted();
    [CompilerGeneratedAttribute]
public DataProtectionPermissionFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(DataProtectionPermissionFlags value);
    public virtual IPermission Copy();
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.DataProtectionPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private DataProtectionPermissionFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProtectData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnprotectData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProtectMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnprotectMemory>k__BackingField;
    public DataProtectionPermissionFlags Flags { get; public set; }
    public bool ProtectData { get; public set; }
    public bool UnprotectData { get; public set; }
    public bool ProtectMemory { get; public set; }
    public bool UnprotectMemory { get; public set; }
    public DataProtectionPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public DataProtectionPermissionFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(DataProtectionPermissionFlags value);
    [CompilerGeneratedAttribute]
public bool get_ProtectData();
    [CompilerGeneratedAttribute]
public void set_ProtectData(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnprotectData();
    [CompilerGeneratedAttribute]
public void set_UnprotectData(bool value);
    [CompilerGeneratedAttribute]
public bool get_ProtectMemory();
    [CompilerGeneratedAttribute]
public void set_ProtectMemory(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnprotectMemory();
    [CompilerGeneratedAttribute]
public void set_UnprotectMemory(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.DataProtectionPermissionFlags : Enum {
    public int value__;
    public static DataProtectionPermissionFlags NoFlags;
    public static DataProtectionPermissionFlags ProtectData;
    public static DataProtectionPermissionFlags UnprotectData;
    public static DataProtectionPermissionFlags ProtectMemory;
    public static DataProtectionPermissionFlags UnprotectMemory;
    public static DataProtectionPermissionFlags AllFlags;
}
public class System.Security.Permissions.EnvironmentPermission : CodeAccessPermission {
    public EnvironmentPermission(EnvironmentPermissionAccess flag, string pathList);
    public EnvironmentPermission(PermissionState state);
    public void AddPathList(EnvironmentPermissionAccess flag, string pathList);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public string GetPathList(EnvironmentPermissionAccess flag);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public void SetPathList(EnvironmentPermissionAccess flag, string pathList);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission other);
}
[FlagsAttribute]
public enum System.Security.Permissions.EnvironmentPermissionAccess : Enum {
    public int value__;
    public static EnvironmentPermissionAccess AllAccess;
    public static EnvironmentPermissionAccess NoAccess;
    public static EnvironmentPermissionAccess Read;
    public static EnvironmentPermissionAccess Write;
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.EnvironmentPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private string <All>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Read>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Write>k__BackingField;
    public string All { get; public set; }
    public string Read { get; public set; }
    public string Write { get; public set; }
    public EnvironmentPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public string get_All();
    [CompilerGeneratedAttribute]
public void set_All(string value);
    [CompilerGeneratedAttribute]
public string get_Read();
    [CompilerGeneratedAttribute]
public void set_Read(string value);
    [CompilerGeneratedAttribute]
public string get_Write();
    [CompilerGeneratedAttribute]
public void set_Write(string value);
    public virtual IPermission CreatePermission();
}
public class System.Security.Permissions.FileDialogPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private FileDialogPermissionAccess <Access>k__BackingField;
    public FileDialogPermissionAccess Access { get; public set; }
    public FileDialogPermission(FileDialogPermissionAccess access);
    public FileDialogPermission(PermissionState state);
    [CompilerGeneratedAttribute]
public FileDialogPermissionAccess get_Access();
    [CompilerGeneratedAttribute]
public void set_Access(FileDialogPermissionAccess value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[FlagsAttribute]
public enum System.Security.Permissions.FileDialogPermissionAccess : Enum {
    public int value__;
    public static FileDialogPermissionAccess None;
    public static FileDialogPermissionAccess Open;
    public static FileDialogPermissionAccess OpenSave;
    public static FileDialogPermissionAccess Save;
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.FileDialogPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private bool <Open>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Save>k__BackingField;
    public bool Open { get; public set; }
    public bool Save { get; public set; }
    public FileDialogPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public bool get_Open();
    [CompilerGeneratedAttribute]
public void set_Open(bool value);
    [CompilerGeneratedAttribute]
public bool get_Save();
    [CompilerGeneratedAttribute]
public void set_Save(bool value);
    public virtual IPermission CreatePermission();
}
public class System.Security.Permissions.FileIOPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private FileIOPermissionAccess <AllFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private FileIOPermissionAccess <AllLocalFiles>k__BackingField;
    public FileIOPermissionAccess AllFiles { get; public set; }
    public FileIOPermissionAccess AllLocalFiles { get; public set; }
    public FileIOPermission(FileIOPermissionAccess access, string path);
    public FileIOPermission(FileIOPermissionAccess access, String[] pathList);
    public FileIOPermission(FileIOPermissionAccess access, AccessControlActions actions, string path);
    public FileIOPermission(FileIOPermissionAccess access, AccessControlActions actions, String[] pathList);
    public FileIOPermission(PermissionState state);
    [CompilerGeneratedAttribute]
public FileIOPermissionAccess get_AllFiles();
    [CompilerGeneratedAttribute]
public void set_AllFiles(FileIOPermissionAccess value);
    [CompilerGeneratedAttribute]
public FileIOPermissionAccess get_AllLocalFiles();
    [CompilerGeneratedAttribute]
public void set_AllLocalFiles(FileIOPermissionAccess value);
    public void AddPathList(FileIOPermissionAccess access, string path);
    public void AddPathList(FileIOPermissionAccess access, String[] pathList);
    public virtual IPermission Copy();
    public virtual bool Equals(object o);
    public virtual void FromXml(SecurityElement esd);
    public virtual int GetHashCode();
    public String[] GetPathList(FileIOPermissionAccess access);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public void SetPathList(FileIOPermissionAccess access, string path);
    public void SetPathList(FileIOPermissionAccess access, String[] pathList);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission other);
}
[FlagsAttribute]
public enum System.Security.Permissions.FileIOPermissionAccess : Enum {
    public int value__;
    public static FileIOPermissionAccess AllAccess;
    public static FileIOPermissionAccess Append;
    public static FileIOPermissionAccess NoAccess;
    public static FileIOPermissionAccess PathDiscovery;
    public static FileIOPermissionAccess Read;
    public static FileIOPermissionAccess Write;
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.FileIOPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private string <Read>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Write>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Append>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathDiscovery>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ViewAccessControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeAccessControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <All>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ViewAndModify>k__BackingField;
    [CompilerGeneratedAttribute]
private FileIOPermissionAccess <AllFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private FileIOPermissionAccess <AllLocalFiles>k__BackingField;
    public string Read { get; public set; }
    public string Write { get; public set; }
    public string Append { get; public set; }
    public string PathDiscovery { get; public set; }
    public string ViewAccessControl { get; public set; }
    public string ChangeAccessControl { get; public set; }
    [ObsoleteAttribute]
public string All { get; public set; }
    public string ViewAndModify { get; public set; }
    public FileIOPermissionAccess AllFiles { get; public set; }
    public FileIOPermissionAccess AllLocalFiles { get; public set; }
    public FileIOPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public string get_Read();
    [CompilerGeneratedAttribute]
public void set_Read(string value);
    [CompilerGeneratedAttribute]
public string get_Write();
    [CompilerGeneratedAttribute]
public void set_Write(string value);
    [CompilerGeneratedAttribute]
public string get_Append();
    [CompilerGeneratedAttribute]
public void set_Append(string value);
    [CompilerGeneratedAttribute]
public string get_PathDiscovery();
    [CompilerGeneratedAttribute]
public void set_PathDiscovery(string value);
    [CompilerGeneratedAttribute]
public string get_ViewAccessControl();
    [CompilerGeneratedAttribute]
public void set_ViewAccessControl(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeAccessControl();
    [CompilerGeneratedAttribute]
public void set_ChangeAccessControl(string value);
    [CompilerGeneratedAttribute]
public string get_All();
    [CompilerGeneratedAttribute]
public void set_All(string value);
    [CompilerGeneratedAttribute]
public string get_ViewAndModify();
    [CompilerGeneratedAttribute]
public void set_ViewAndModify(string value);
    [CompilerGeneratedAttribute]
public FileIOPermissionAccess get_AllFiles();
    [CompilerGeneratedAttribute]
public void set_AllFiles(FileIOPermissionAccess value);
    [CompilerGeneratedAttribute]
public FileIOPermissionAccess get_AllLocalFiles();
    [CompilerGeneratedAttribute]
public void set_AllLocalFiles(FileIOPermissionAccess value);
    public virtual IPermission CreatePermission();
}
public class System.Security.Permissions.GacIdentityPermission : CodeAccessPermission {
    public GacIdentityPermission(PermissionState state);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.GacIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    public GacIdentityPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
[AttributeUsageAttribute("4205")]
public class System.Security.Permissions.HostProtectionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private bool <ExternalProcessMgmt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExternalThreading>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MayLeakOnAbort>k__BackingField;
    [CompilerGeneratedAttribute]
private HostProtectionResource <Resources>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SecurityInfrastructure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SelfAffectingProcessMgmt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SelfAffectingThreading>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SharedState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Synchronization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UI>k__BackingField;
    public bool ExternalProcessMgmt { get; public set; }
    public bool ExternalThreading { get; public set; }
    public bool MayLeakOnAbort { get; public set; }
    public HostProtectionResource Resources { get; public set; }
    public bool SecurityInfrastructure { get; public set; }
    public bool SelfAffectingProcessMgmt { get; public set; }
    public bool SelfAffectingThreading { get; public set; }
    public bool SharedState { get; public set; }
    public bool Synchronization { get; public set; }
    public bool UI { get; public set; }
    public HostProtectionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public bool get_ExternalProcessMgmt();
    [CompilerGeneratedAttribute]
public void set_ExternalProcessMgmt(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExternalThreading();
    [CompilerGeneratedAttribute]
public void set_ExternalThreading(bool value);
    [CompilerGeneratedAttribute]
public bool get_MayLeakOnAbort();
    [CompilerGeneratedAttribute]
public void set_MayLeakOnAbort(bool value);
    [CompilerGeneratedAttribute]
public HostProtectionResource get_Resources();
    [CompilerGeneratedAttribute]
public void set_Resources(HostProtectionResource value);
    [CompilerGeneratedAttribute]
public bool get_SecurityInfrastructure();
    [CompilerGeneratedAttribute]
public void set_SecurityInfrastructure(bool value);
    [CompilerGeneratedAttribute]
public bool get_SelfAffectingProcessMgmt();
    [CompilerGeneratedAttribute]
public void set_SelfAffectingProcessMgmt(bool value);
    [CompilerGeneratedAttribute]
public bool get_SelfAffectingThreading();
    [CompilerGeneratedAttribute]
public void set_SelfAffectingThreading(bool value);
    [CompilerGeneratedAttribute]
public bool get_SharedState();
    [CompilerGeneratedAttribute]
public void set_SharedState(bool value);
    [CompilerGeneratedAttribute]
public bool get_Synchronization();
    [CompilerGeneratedAttribute]
public void set_Synchronization(bool value);
    [CompilerGeneratedAttribute]
public bool get_UI();
    [CompilerGeneratedAttribute]
public void set_UI(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public enum System.Security.Permissions.HostProtectionResource : Enum {
    public int value__;
    public static HostProtectionResource All;
    public static HostProtectionResource ExternalProcessMgmt;
    public static HostProtectionResource ExternalThreading;
    public static HostProtectionResource MayLeakOnAbort;
    public static HostProtectionResource None;
    public static HostProtectionResource SecurityInfrastructure;
    public static HostProtectionResource SelfAffectingProcessMgmt;
    public static HostProtectionResource SelfAffectingThreading;
    public static HostProtectionResource SharedState;
    public static HostProtectionResource Synchronization;
    public static HostProtectionResource UI;
}
internal class System.Security.Permissions.IDRole : object {
    [CompilerGeneratedAttribute]
private bool <Authenticated>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Role>k__BackingField;
    internal bool Authenticated { get; }
    internal string ID { get; }
    internal string Role { get; }
    internal IDRole(bool authenticated, string id, string role);
    internal IDRole(SecurityElement e);
    [CompilerGeneratedAttribute]
internal bool get_Authenticated();
    [CompilerGeneratedAttribute]
internal string get_ID();
    [CompilerGeneratedAttribute]
internal string get_Role();
    internal SecurityElement ToXml();
    public virtual int GetHashCode();
}
public enum System.Security.Permissions.IsolatedStorageContainment : Enum {
    public int value__;
    public static IsolatedStorageContainment None;
    public static IsolatedStorageContainment DomainIsolationByUser;
    public static IsolatedStorageContainment ApplicationIsolationByUser;
    public static IsolatedStorageContainment AssemblyIsolationByUser;
    public static IsolatedStorageContainment DomainIsolationByMachine;
    public static IsolatedStorageContainment AssemblyIsolationByMachine;
    public static IsolatedStorageContainment ApplicationIsolationByMachine;
    public static IsolatedStorageContainment DomainIsolationByRoamingUser;
    public static IsolatedStorageContainment AssemblyIsolationByRoamingUser;
    public static IsolatedStorageContainment ApplicationIsolationByRoamingUser;
    public static IsolatedStorageContainment AdministerIsolatedStorageByUser;
    public static IsolatedStorageContainment UnrestrictedIsolatedStorage;
}
public class System.Security.Permissions.IsolatedStorageFilePermission : IsolatedStoragePermission {
    public IsolatedStorageFilePermission(PermissionState state);
    public virtual IPermission Union(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.IsolatedStorageFilePermissionAttribute : IsolatedStoragePermissionAttribute {
    public IsolatedStorageFilePermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
public abstract class System.Security.Permissions.IsolatedStoragePermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private long <UserQuota>k__BackingField;
    [CompilerGeneratedAttribute]
private IsolatedStorageContainment <UsageAllowed>k__BackingField;
    public long UserQuota { get; public set; }
    public IsolatedStorageContainment UsageAllowed { get; public set; }
    protected IsolatedStoragePermission(PermissionState state);
    [CompilerGeneratedAttribute]
public long get_UserQuota();
    [CompilerGeneratedAttribute]
public void set_UserQuota(long value);
    [CompilerGeneratedAttribute]
public IsolatedStorageContainment get_UsageAllowed();
    [CompilerGeneratedAttribute]
public void set_UsageAllowed(IsolatedStorageContainment value);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement esd);
}
public abstract class System.Security.Permissions.IsolatedStoragePermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private long <UserQuota>k__BackingField;
    [CompilerGeneratedAttribute]
private IsolatedStorageContainment <UsageAllowed>k__BackingField;
    public long UserQuota { get; public set; }
    public IsolatedStorageContainment UsageAllowed { get; public set; }
    protected IsolatedStoragePermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public long get_UserQuota();
    [CompilerGeneratedAttribute]
public void set_UserQuota(long value);
    [CompilerGeneratedAttribute]
public IsolatedStorageContainment get_UsageAllowed();
    [CompilerGeneratedAttribute]
public void set_UsageAllowed(IsolatedStorageContainment value);
}
public interface System.Security.Permissions.IUnrestrictedPermission {
    public abstract virtual bool IsUnrestricted();
}
public class System.Security.Permissions.KeyContainerPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private KeyContainerPermissionFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyContainerPermissionAccessEntryCollection <AccessEntries>k__BackingField;
    public KeyContainerPermissionFlags Flags { get; }
    public KeyContainerPermissionAccessEntryCollection AccessEntries { get; }
    public KeyContainerPermission(PermissionState state);
    public KeyContainerPermission(KeyContainerPermissionFlags flags);
    public KeyContainerPermission(KeyContainerPermissionFlags flags, KeyContainerPermissionAccessEntry[] accessList);
    [CompilerGeneratedAttribute]
public KeyContainerPermissionFlags get_Flags();
    [CompilerGeneratedAttribute]
public KeyContainerPermissionAccessEntryCollection get_AccessEntries();
    public sealed virtual bool IsUnrestricted();
    private bool IsEmpty();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
}
public class System.Security.Permissions.KeyContainerPermissionAccessEntry : object {
    [CompilerGeneratedAttribute]
private string <KeyStore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProviderType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeySpec>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyContainerPermissionFlags <Flags>k__BackingField;
    public string KeyStore { get; public set; }
    public string ProviderName { get; public set; }
    public int ProviderType { get; public set; }
    public string KeyContainerName { get; public set; }
    public int KeySpec { get; public set; }
    public KeyContainerPermissionFlags Flags { get; public set; }
    public KeyContainerPermissionAccessEntry(string keyContainerName, KeyContainerPermissionFlags flags);
    public KeyContainerPermissionAccessEntry(CspParameters parameters, KeyContainerPermissionFlags flags);
    public KeyContainerPermissionAccessEntry(string keyStore, string providerName, int providerType, string keyContainerName, int keySpec, KeyContainerPermissionFlags flags);
    [CompilerGeneratedAttribute]
public string get_KeyStore();
    [CompilerGeneratedAttribute]
public void set_KeyStore(string value);
    [CompilerGeneratedAttribute]
public string get_ProviderName();
    [CompilerGeneratedAttribute]
public void set_ProviderName(string value);
    [CompilerGeneratedAttribute]
public int get_ProviderType();
    [CompilerGeneratedAttribute]
public void set_ProviderType(int value);
    [CompilerGeneratedAttribute]
public string get_KeyContainerName();
    [CompilerGeneratedAttribute]
public void set_KeyContainerName(string value);
    [CompilerGeneratedAttribute]
public int get_KeySpec();
    [CompilerGeneratedAttribute]
public void set_KeySpec(int value);
    [CompilerGeneratedAttribute]
public KeyContainerPermissionFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(KeyContainerPermissionFlags value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Permissions.KeyContainerPermissionAccessEntryCollection : object {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSynchronized>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SyncRoot>k__BackingField;
    public KeyContainerPermissionAccessEntry Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public KeyContainerPermissionAccessEntry get_Item(int index);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    public int Add(KeyContainerPermissionAccessEntry accessEntry);
    public void Clear();
    public int IndexOf(KeyContainerPermissionAccessEntry accessEntry);
    public void Remove(KeyContainerPermissionAccessEntry accessEntry);
    public KeyContainerPermissionAccessEntryEnumerator GetEnumerator();
    public void CopyTo(KeyContainerPermissionAccessEntry[] array, int index);
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSynchronized();
    [CompilerGeneratedAttribute]
public sealed virtual object get_SyncRoot();
}
public class System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator : object {
    [CompilerGeneratedAttribute]
private KeyContainerPermissionAccessEntry <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private object <System.Collections.IEnumerator.Current>k__BackingField;
    public KeyContainerPermissionAccessEntry Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    [CompilerGeneratedAttribute]
public KeyContainerPermissionAccessEntry get_Current();
    [CompilerGeneratedAttribute]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.KeyContainerPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private string <KeyStore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProviderType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeySpec>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyContainerPermissionFlags <Flags>k__BackingField;
    public string KeyStore { get; public set; }
    public string ProviderName { get; public set; }
    public int ProviderType { get; public set; }
    public string KeyContainerName { get; public set; }
    public int KeySpec { get; public set; }
    public KeyContainerPermissionFlags Flags { get; public set; }
    public KeyContainerPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public string get_KeyStore();
    [CompilerGeneratedAttribute]
public void set_KeyStore(string value);
    [CompilerGeneratedAttribute]
public string get_ProviderName();
    [CompilerGeneratedAttribute]
public void set_ProviderName(string value);
    [CompilerGeneratedAttribute]
public int get_ProviderType();
    [CompilerGeneratedAttribute]
public void set_ProviderType(int value);
    [CompilerGeneratedAttribute]
public string get_KeyContainerName();
    [CompilerGeneratedAttribute]
public void set_KeyContainerName(string value);
    [CompilerGeneratedAttribute]
public int get_KeySpec();
    [CompilerGeneratedAttribute]
public void set_KeySpec(int value);
    [CompilerGeneratedAttribute]
public KeyContainerPermissionFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(KeyContainerPermissionFlags value);
    public virtual IPermission CreatePermission();
}
public enum System.Security.Permissions.KeyContainerPermissionFlags : Enum {
    public int value__;
    public static KeyContainerPermissionFlags NoFlags;
    public static KeyContainerPermissionFlags Create;
    public static KeyContainerPermissionFlags Open;
    public static KeyContainerPermissionFlags Delete;
    public static KeyContainerPermissionFlags Import;
    public static KeyContainerPermissionFlags Export;
    public static KeyContainerPermissionFlags Sign;
    public static KeyContainerPermissionFlags Decrypt;
    public static KeyContainerPermissionFlags ViewAcl;
    public static KeyContainerPermissionFlags ChangeAcl;
    public static KeyContainerPermissionFlags AllFlags;
}
public class System.Security.Permissions.MediaPermission : CodeAccessPermission {
    public MediaPermissionAudio Audio { get; }
    public MediaPermissionVideo Video { get; }
    public MediaPermissionImage Image { get; }
    public MediaPermission(PermissionState state);
    public MediaPermission(MediaPermissionAudio permissionAudio);
    public MediaPermission(MediaPermissionVideo permissionVideo);
    public MediaPermission(MediaPermissionImage permissionImage);
    public MediaPermission(MediaPermissionAudio permissionAudio, MediaPermissionVideo permissionVideo, MediaPermissionImage permissionImage);
    public sealed virtual bool IsUnrestricted();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
    public MediaPermissionAudio get_Audio();
    public MediaPermissionVideo get_Video();
    public MediaPermissionImage get_Image();
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.MediaPermissionAttribute : CodeAccessSecurityAttribute {
    public MediaPermissionAudio Audio { get; public set; }
    public MediaPermissionVideo Video { get; public set; }
    public MediaPermissionImage Image { get; public set; }
    public MediaPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
    public MediaPermissionAudio get_Audio();
    public void set_Audio(MediaPermissionAudio value);
    public MediaPermissionVideo get_Video();
    public void set_Video(MediaPermissionVideo value);
    public MediaPermissionImage get_Image();
    public void set_Image(MediaPermissionImage value);
}
public enum System.Security.Permissions.MediaPermissionAudio : Enum {
    public int value__;
    public static MediaPermissionAudio NoAudio;
    public static MediaPermissionAudio SiteOfOriginAudio;
    public static MediaPermissionAudio SafeAudio;
    public static MediaPermissionAudio AllAudio;
}
public enum System.Security.Permissions.MediaPermissionImage : Enum {
    public int value__;
    public static MediaPermissionImage NoImage;
    public static MediaPermissionImage SiteOfOriginImage;
    public static MediaPermissionImage SafeImage;
    public static MediaPermissionImage AllImage;
}
public enum System.Security.Permissions.MediaPermissionVideo : Enum {
    public int value__;
    public static MediaPermissionVideo NoVideo;
    public static MediaPermissionVideo SiteOfOriginVideo;
    public static MediaPermissionVideo SafeVideo;
    public static MediaPermissionVideo AllVideo;
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.PermissionSetAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnicodeEncoded>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XML>k__BackingField;
    public string File { get; public set; }
    public string Hex { get; public set; }
    public string Name { get; public set; }
    public bool UnicodeEncoded { get; public set; }
    public string XML { get; public set; }
    public PermissionSetAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Hex();
    [CompilerGeneratedAttribute]
public void set_Hex(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_UnicodeEncoded();
    [CompilerGeneratedAttribute]
public void set_UnicodeEncoded(bool value);
    [CompilerGeneratedAttribute]
public string get_XML();
    [CompilerGeneratedAttribute]
public void set_XML(string value);
    public virtual IPermission CreatePermission();
    public PermissionSet CreatePermissionSet();
}
public class System.Security.Permissions.PrincipalPermission : object {
    private IDRole[] _idArray;
    public PrincipalPermission(PermissionState state);
    public PrincipalPermission(string name, string role);
    public PrincipalPermission(string name, string role, bool isAuthenticated);
    private PrincipalPermission(IDRole[] array);
    private bool IsEmpty();
    private bool VerifyType(IPermission perm);
    public sealed virtual bool IsUnrestricted();
    public sealed virtual bool IsSubsetOf(IPermission target);
    public sealed virtual IPermission Intersect(IPermission target);
    public sealed virtual IPermission Union(IPermission other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IPermission Copy();
    public sealed virtual void Demand();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement elem);
    public virtual string ToString();
}
[AttributeUsageAttribute("68")]
public class System.Security.Permissions.PrincipalPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private bool <Authenticated>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Role>k__BackingField;
    public bool Authenticated { get; public set; }
    public string Name { get; public set; }
    public string Role { get; public set; }
    public PrincipalPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public bool get_Authenticated();
    [CompilerGeneratedAttribute]
public void set_Authenticated(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Role();
    [CompilerGeneratedAttribute]
public void set_Role(string value);
    public virtual IPermission CreatePermission();
}
public class System.Security.Permissions.PublisherIdentityPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private X509Certificate <Certificate>k__BackingField;
    public X509Certificate Certificate { get; public set; }
    public PublisherIdentityPermission(X509Certificate certificate);
    public PublisherIdentityPermission(PermissionState state);
    [CompilerGeneratedAttribute]
public X509Certificate get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(X509Certificate value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.PublisherIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private string <CertFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignedFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X509Certificate>k__BackingField;
    public string CertFile { get; public set; }
    public string SignedFile { get; public set; }
    public string X509Certificate { get; public set; }
    public PublisherIdentityPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public string get_CertFile();
    [CompilerGeneratedAttribute]
public void set_CertFile(string value);
    [CompilerGeneratedAttribute]
public string get_SignedFile();
    [CompilerGeneratedAttribute]
public void set_SignedFile(string value);
    [CompilerGeneratedAttribute]
public string get_X509Certificate();
    [CompilerGeneratedAttribute]
public void set_X509Certificate(string value);
    public virtual IPermission CreatePermission();
}
public class System.Security.Permissions.ReflectionPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private ReflectionPermissionFlag <Flags>k__BackingField;
    public ReflectionPermissionFlag Flags { get; public set; }
    public ReflectionPermission(PermissionState state);
    public ReflectionPermission(ReflectionPermissionFlag flag);
    [CompilerGeneratedAttribute]
public ReflectionPermissionFlag get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(ReflectionPermissionFlag value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission other);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.ReflectionPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private ReflectionPermissionFlag <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MemberAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReflectionEmit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestrictedMemberAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TypeInformation>k__BackingField;
    public ReflectionPermissionFlag Flags { get; public set; }
    public bool MemberAccess { get; public set; }
    [ObsoleteAttribute("This permission is no longer used by the CLR.")]
public bool ReflectionEmit { get; public set; }
    public bool RestrictedMemberAccess { get; public set; }
    [ObsoleteAttribute("This API has been deprecated. https://go.microsoft.com/fwlink/?linkid=14202")]
public bool TypeInformation { get; public set; }
    public ReflectionPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public ReflectionPermissionFlag get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(ReflectionPermissionFlag value);
    [CompilerGeneratedAttribute]
public bool get_MemberAccess();
    [CompilerGeneratedAttribute]
public void set_MemberAccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReflectionEmit();
    [CompilerGeneratedAttribute]
public void set_ReflectionEmit(bool value);
    [CompilerGeneratedAttribute]
public bool get_RestrictedMemberAccess();
    [CompilerGeneratedAttribute]
public void set_RestrictedMemberAccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_TypeInformation();
    [CompilerGeneratedAttribute]
public void set_TypeInformation(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.ReflectionPermissionFlag : Enum {
    public int value__;
    [ObsoleteAttribute("This permission has been deprecated. Use PermissionState.Unrestricted to get full access.")]
public static ReflectionPermissionFlag AllFlags;
    public static ReflectionPermissionFlag MemberAccess;
    public static ReflectionPermissionFlag NoFlags;
    [ObsoleteAttribute("This permission is no longer used by the CLR.")]
public static ReflectionPermissionFlag ReflectionEmit;
    public static ReflectionPermissionFlag RestrictedMemberAccess;
    [ObsoleteAttribute("This API has been deprecated. https://go.microsoft.com/fwlink/?linkid=14202")]
public static ReflectionPermissionFlag TypeInformation;
}
public class System.Security.Permissions.RegistryPermission : CodeAccessPermission {
    public RegistryPermission(PermissionState state);
    public RegistryPermission(RegistryPermissionAccess access, AccessControlActions control, string pathList);
    public RegistryPermission(RegistryPermissionAccess access, string pathList);
    public void AddPathList(RegistryPermissionAccess access, string pathList);
    public void AddPathList(RegistryPermissionAccess access, AccessControlActions actions, string pathList);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement elem);
    public string GetPathList(RegistryPermissionAccess access);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public void SetPathList(RegistryPermissionAccess access, string pathList);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission other);
}
[FlagsAttribute]
public enum System.Security.Permissions.RegistryPermissionAccess : Enum {
    public int value__;
    public static RegistryPermissionAccess AllAccess;
    public static RegistryPermissionAccess Create;
    public static RegistryPermissionAccess NoAccess;
    public static RegistryPermissionAccess Read;
    public static RegistryPermissionAccess Write;
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.RegistryPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private string <All>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeAccessControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Create>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Read>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ViewAccessControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ViewAndModify>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Write>k__BackingField;
    [ObsoleteAttribute("Please use the ViewAndModify property instead.")]
public string All { get; public set; }
    public string ChangeAccessControl { get; public set; }
    public string Create { get; public set; }
    public string Read { get; public set; }
    public string ViewAccessControl { get; public set; }
    public string ViewAndModify { get; public set; }
    public string Write { get; public set; }
    public RegistryPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public string get_All();
    [CompilerGeneratedAttribute]
public void set_All(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeAccessControl();
    [CompilerGeneratedAttribute]
public void set_ChangeAccessControl(string value);
    [CompilerGeneratedAttribute]
public string get_Create();
    [CompilerGeneratedAttribute]
public void set_Create(string value);
    [CompilerGeneratedAttribute]
public string get_Read();
    [CompilerGeneratedAttribute]
public void set_Read(string value);
    [CompilerGeneratedAttribute]
public string get_ViewAccessControl();
    [CompilerGeneratedAttribute]
public void set_ViewAccessControl(string value);
    [CompilerGeneratedAttribute]
public string get_ViewAndModify();
    [CompilerGeneratedAttribute]
public void set_ViewAndModify(string value);
    [CompilerGeneratedAttribute]
public string get_Write();
    [CompilerGeneratedAttribute]
public void set_Write(string value);
    public virtual IPermission CreatePermission();
}
public abstract class System.Security.Permissions.ResourcePermissionBase : CodeAccessPermission {
    public static string Any;
    public static string Local;
    [CompilerGeneratedAttribute]
private string <ComputerName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PermissionAccessType>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TagNames>k__BackingField;
    private string ComputerName { get; private set; }
    private bool IsEmpty { get; }
    protected Type PermissionAccessType { get; protected set; }
    protected String[] TagNames { get; protected set; }
    protected ResourcePermissionBase(PermissionState state);
    private static Hashtable CreateHashtable();
    [CompilerGeneratedAttribute]
private string get_ComputerName();
    [CompilerGeneratedAttribute]
private void set_ComputerName(string value);
    [CompilerGeneratedAttribute]
private bool get_IsEmpty();
    [CompilerGeneratedAttribute]
protected Type get_PermissionAccessType();
    [CompilerGeneratedAttribute]
protected void set_PermissionAccessType(Type value);
    [CompilerGeneratedAttribute]
protected String[] get_TagNames();
    [CompilerGeneratedAttribute]
protected void set_TagNames(String[] value);
    protected void AddPermissionAccess(ResourcePermissionBaseEntry entry);
    protected void Clear();
    public virtual IPermission Copy();
    protected ResourcePermissionBaseEntry[] GetPermissionEntries();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    protected void RemovePermissionAccess(ResourcePermissionBaseEntry entry);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
public class System.Security.Permissions.ResourcePermissionBaseEntry : object {
    [CompilerGeneratedAttribute]
private int <PermissionAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PermissionAccessPath>k__BackingField;
    public int PermissionAccess { get; }
    public String[] PermissionAccessPath { get; }
    public ResourcePermissionBaseEntry(int permissionAccess, String[] permissionAccessPath);
    [CompilerGeneratedAttribute]
public int get_PermissionAccess();
    [CompilerGeneratedAttribute]
public String[] get_PermissionAccessPath();
}
public class System.Security.Permissions.SecurityPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private SecurityPermissionFlag <Flags>k__BackingField;
    public SecurityPermissionFlag Flags { get; public set; }
    public SecurityPermission(PermissionState state);
    public SecurityPermission(SecurityPermissionFlag flag);
    [CompilerGeneratedAttribute]
public SecurityPermissionFlag get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(SecurityPermissionFlag value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
public class System.Security.Permissions.SiteIdentityPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private string <Site>k__BackingField;
    public string Site { get; public set; }
    public SiteIdentityPermission(PermissionState state);
    public SiteIdentityPermission(string site);
    [CompilerGeneratedAttribute]
public string get_Site();
    [CompilerGeneratedAttribute]
public void set_Site(string value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.SiteIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private string <Site>k__BackingField;
    public string Site { get; public set; }
    public SiteIdentityPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public string get_Site();
    [CompilerGeneratedAttribute]
public void set_Site(string value);
    public virtual IPermission CreatePermission();
}
public class System.Security.Permissions.StorePermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private StorePermissionFlags <Flags>k__BackingField;
    public StorePermissionFlags Flags { get; public set; }
    public StorePermission(PermissionState state);
    public StorePermission(StorePermissionFlags flag);
    [CompilerGeneratedAttribute]
public StorePermissionFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(StorePermissionFlags value);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Union(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.StorePermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private StorePermissionFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateStore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteStore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnumerateStores>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OpenStore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddToStore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveFromStore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnumerateCertificates>k__BackingField;
    public StorePermissionFlags Flags { get; public set; }
    public bool CreateStore { get; public set; }
    public bool DeleteStore { get; public set; }
    public bool EnumerateStores { get; public set; }
    public bool OpenStore { get; public set; }
    public bool AddToStore { get; public set; }
    public bool RemoveFromStore { get; public set; }
    public bool EnumerateCertificates { get; public set; }
    public StorePermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public StorePermissionFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(StorePermissionFlags value);
    [CompilerGeneratedAttribute]
public bool get_CreateStore();
    [CompilerGeneratedAttribute]
public void set_CreateStore(bool value);
    [CompilerGeneratedAttribute]
public bool get_DeleteStore();
    [CompilerGeneratedAttribute]
public void set_DeleteStore(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnumerateStores();
    [CompilerGeneratedAttribute]
public void set_EnumerateStores(bool value);
    [CompilerGeneratedAttribute]
public bool get_OpenStore();
    [CompilerGeneratedAttribute]
public void set_OpenStore(bool value);
    [CompilerGeneratedAttribute]
public bool get_AddToStore();
    [CompilerGeneratedAttribute]
public void set_AddToStore(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemoveFromStore();
    [CompilerGeneratedAttribute]
public void set_RemoveFromStore(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnumerateCertificates();
    [CompilerGeneratedAttribute]
public void set_EnumerateCertificates(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.StorePermissionFlags : Enum {
    public int value__;
    public static StorePermissionFlags NoFlags;
    public static StorePermissionFlags CreateStore;
    public static StorePermissionFlags DeleteStore;
    public static StorePermissionFlags EnumerateStores;
    public static StorePermissionFlags OpenStore;
    public static StorePermissionFlags AddToStore;
    public static StorePermissionFlags RemoveFromStore;
    public static StorePermissionFlags EnumerateCertificates;
    public static StorePermissionFlags AllFlags;
}
public class System.Security.Permissions.StrongNameIdentityPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private StrongNamePublicKeyBlob <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Name { get; public set; }
    public StrongNamePublicKeyBlob PublicKey { get; public set; }
    public Version Version { get; public set; }
    public StrongNameIdentityPermission(PermissionState state);
    public StrongNameIdentityPermission(StrongNamePublicKeyBlob blob, string name, Version version);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public StrongNamePublicKeyBlob get_PublicKey();
    [CompilerGeneratedAttribute]
public void set_PublicKey(StrongNamePublicKeyBlob value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Version value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement e);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.StrongNameIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Name { get; public set; }
    public string PublicKey { get; public set; }
    public string Version { get; public set; }
    public StrongNameIdentityPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_PublicKey();
    [CompilerGeneratedAttribute]
public void set_PublicKey(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    public virtual IPermission CreatePermission();
}
public class System.Security.Permissions.StrongNamePublicKeyBlob : object {
    public StrongNamePublicKeyBlob(Byte[] publicKey);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Security.Permissions.TypeDescriptorPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private TypeDescriptorPermissionFlags <Flags>k__BackingField;
    public TypeDescriptorPermissionFlags Flags { get; public set; }
    public TypeDescriptorPermission(PermissionState state);
    public TypeDescriptorPermission(TypeDescriptorPermissionFlags flag);
    [CompilerGeneratedAttribute]
public TypeDescriptorPermissionFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(TypeDescriptorPermissionFlags value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.TypeDescriptorPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private TypeDescriptorPermissionFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestrictedRegistrationAccess>k__BackingField;
    public TypeDescriptorPermissionFlags Flags { get; public set; }
    public bool RestrictedRegistrationAccess { get; public set; }
    public TypeDescriptorPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public TypeDescriptorPermissionFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(TypeDescriptorPermissionFlags value);
    [CompilerGeneratedAttribute]
public bool get_RestrictedRegistrationAccess();
    [CompilerGeneratedAttribute]
public void set_RestrictedRegistrationAccess(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.TypeDescriptorPermissionFlags : Enum {
    public int value__;
    public static TypeDescriptorPermissionFlags NoFlags;
    public static TypeDescriptorPermissionFlags RestrictedRegistrationAccess;
}
public class System.Security.Permissions.UIPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private UIPermissionClipboard <Clipboard>k__BackingField;
    [CompilerGeneratedAttribute]
private UIPermissionWindow <Window>k__BackingField;
    public UIPermissionClipboard Clipboard { get; public set; }
    public UIPermissionWindow Window { get; public set; }
    public UIPermission(PermissionState state);
    public UIPermission(UIPermissionClipboard clipboardFlag);
    public UIPermission(UIPermissionWindow windowFlag);
    public UIPermission(UIPermissionWindow windowFlag, UIPermissionClipboard clipboardFlag);
    [CompilerGeneratedAttribute]
public UIPermissionClipboard get_Clipboard();
    [CompilerGeneratedAttribute]
public void set_Clipboard(UIPermissionClipboard value);
    [CompilerGeneratedAttribute]
public UIPermissionWindow get_Window();
    [CompilerGeneratedAttribute]
public void set_Window(UIPermissionWindow value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.UIPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private UIPermissionClipboard <Clipboard>k__BackingField;
    [CompilerGeneratedAttribute]
private UIPermissionWindow <Window>k__BackingField;
    public UIPermissionClipboard Clipboard { get; public set; }
    public UIPermissionWindow Window { get; public set; }
    public UIPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public UIPermissionClipboard get_Clipboard();
    [CompilerGeneratedAttribute]
public void set_Clipboard(UIPermissionClipboard value);
    [CompilerGeneratedAttribute]
public UIPermissionWindow get_Window();
    [CompilerGeneratedAttribute]
public void set_Window(UIPermissionWindow value);
    public virtual IPermission CreatePermission();
}
public enum System.Security.Permissions.UIPermissionClipboard : Enum {
    public int value__;
    public static UIPermissionClipboard AllClipboard;
    public static UIPermissionClipboard NoClipboard;
    public static UIPermissionClipboard OwnClipboard;
}
public enum System.Security.Permissions.UIPermissionWindow : Enum {
    public int value__;
    public static UIPermissionWindow AllWindows;
    public static UIPermissionWindow NoWindows;
    public static UIPermissionWindow SafeSubWindows;
    public static UIPermissionWindow SafeTopLevelWindows;
}
public class System.Security.Permissions.UrlIdentityPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Url { get; public set; }
    public UrlIdentityPermission(PermissionState state);
    public UrlIdentityPermission(string site);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.UrlIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Url { get; public set; }
    public UrlIdentityPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    public virtual IPermission CreatePermission();
}
public class System.Security.Permissions.WebBrowserPermission : CodeAccessPermission {
    public WebBrowserPermissionLevel Level { get; public set; }
    public WebBrowserPermission(PermissionState state);
    public WebBrowserPermission(WebBrowserPermissionLevel webBrowserPermissionLevel);
    public sealed virtual bool IsUnrestricted();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
    public WebBrowserPermissionLevel get_Level();
    public void set_Level(WebBrowserPermissionLevel value);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.WebBrowserPermissionAttribute : CodeAccessSecurityAttribute {
    public WebBrowserPermissionLevel Level { get; public set; }
    public WebBrowserPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
    public WebBrowserPermissionLevel get_Level();
    public void set_Level(WebBrowserPermissionLevel value);
}
public enum System.Security.Permissions.WebBrowserPermissionLevel : Enum {
    public int value__;
    public static WebBrowserPermissionLevel None;
    public static WebBrowserPermissionLevel Safe;
    public static WebBrowserPermissionLevel Unrestricted;
}
public class System.Security.Permissions.ZoneIdentityPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private SecurityZone <SecurityZone>k__BackingField;
    public SecurityZone SecurityZone { get; public set; }
    public ZoneIdentityPermission(PermissionState state);
    public ZoneIdentityPermission(SecurityZone zone);
    [CompilerGeneratedAttribute]
public SecurityZone get_SecurityZone();
    [CompilerGeneratedAttribute]
public void set_SecurityZone(SecurityZone value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.ZoneIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private SecurityZone <Zone>k__BackingField;
    public SecurityZone Zone { get; public set; }
    public ZoneIdentityPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public SecurityZone get_Zone();
    [CompilerGeneratedAttribute]
public void set_Zone(SecurityZone value);
    public virtual IPermission CreatePermission();
}
public class System.Security.Policy.AllMembershipCondition : object {
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
public class System.Security.Policy.ApplicationDirectory : EvidenceBase {
    public string Directory { get; }
    public ApplicationDirectory(string name);
    public string get_Directory();
    public object Copy();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Security.Policy.ApplicationDirectoryMembershipCondition : object {
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
public class System.Security.Policy.ApplicationTrust : EvidenceBase {
    [CompilerGeneratedAttribute]
private ApplicationIdentity <ApplicationIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private PolicyStatement <DefaultGrantSet>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ExtraInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsApplicationTrustedToRun>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Persist>k__BackingField;
    public ApplicationIdentity ApplicationIdentity { get; public set; }
    public PolicyStatement DefaultGrantSet { get; public set; }
    public object ExtraInfo { get; public set; }
    public IList`1<StrongName> FullTrustAssemblies { get; }
    public bool IsApplicationTrustedToRun { get; public set; }
    public bool Persist { get; public set; }
    public ApplicationTrust(ApplicationIdentity identity);
    public ApplicationTrust(PermissionSet defaultGrantSet, IEnumerable`1<StrongName> fullTrustAssemblies);
    [CompilerGeneratedAttribute]
public ApplicationIdentity get_ApplicationIdentity();
    [CompilerGeneratedAttribute]
public void set_ApplicationIdentity(ApplicationIdentity value);
    [CompilerGeneratedAttribute]
public PolicyStatement get_DefaultGrantSet();
    [CompilerGeneratedAttribute]
public void set_DefaultGrantSet(PolicyStatement value);
    [CompilerGeneratedAttribute]
public object get_ExtraInfo();
    [CompilerGeneratedAttribute]
public void set_ExtraInfo(object value);
    public IList`1<StrongName> get_FullTrustAssemblies();
    [CompilerGeneratedAttribute]
public bool get_IsApplicationTrustedToRun();
    [CompilerGeneratedAttribute]
public void set_IsApplicationTrustedToRun(bool value);
    [CompilerGeneratedAttribute]
public bool get_Persist();
    [CompilerGeneratedAttribute]
public void set_Persist(bool value);
    public sealed virtual void FromXml(SecurityElement element);
    public sealed virtual SecurityElement ToXml();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Policy.ApplicationTrustCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public ApplicationTrust Item { get; }
    public ApplicationTrust Item { get; }
    public object SyncRoot { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public ApplicationTrust get_Item(int index);
    public ApplicationTrust get_Item(string appFullName);
    public sealed virtual object get_SyncRoot();
    public int Add(ApplicationTrust trust);
    public void AddRange(ApplicationTrust[] trusts);
    public void AddRange(ApplicationTrustCollection trusts);
    public void Clear();
    public void CopyTo(ApplicationTrust[] array, int index);
    public ApplicationTrustCollection Find(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch);
    public ApplicationTrustEnumerator GetEnumerator();
    public void Remove(ApplicationTrust trust);
    public void Remove(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch);
    public void RemoveRange(ApplicationTrust[] trusts);
    public void RemoveRange(ApplicationTrustCollection trusts);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Policy.ApplicationTrustEnumerator : object {
    public ApplicationTrust Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ApplicationTrust get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Policy.ApplicationVersionMatch : Enum {
    public int value__;
    public static ApplicationVersionMatch MatchAllVersions;
    public static ApplicationVersionMatch MatchExactVersion;
}
public class System.Security.Policy.CodeConnectAccess : object {
    public static string AnyScheme;
    public static int DefaultPort;
    public static int OriginPort;
    public static string OriginScheme;
    public int Port { get; }
    public string Scheme { get; }
    public CodeConnectAccess(string allowScheme, int allowPort);
    public int get_Port();
    public string get_Scheme();
    public static CodeConnectAccess CreateAnySchemeAccess(int allowPort);
    public static CodeConnectAccess CreateOriginSchemeAccess(int allowPort);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class System.Security.Policy.CodeGroup : object {
    [CompilerGeneratedAttribute]
private IList <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private IMembershipCondition <MembershipCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private PolicyStatement <PolicyStatement>k__BackingField;
    public string AttributeString { get; }
    public IList Children { get; public set; }
    public string Description { get; public set; }
    public IMembershipCondition MembershipCondition { get; public set; }
    public string MergeLogic { get; }
    public string Name { get; public set; }
    public string PermissionSetName { get; }
    public PolicyStatement PolicyStatement { get; public set; }
    protected CodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
    public virtual string get_AttributeString();
    [CompilerGeneratedAttribute]
public IList get_Children();
    [CompilerGeneratedAttribute]
public void set_Children(IList value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public IMembershipCondition get_MembershipCondition();
    [CompilerGeneratedAttribute]
public void set_MembershipCondition(IMembershipCondition value);
    public abstract virtual string get_MergeLogic();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual string get_PermissionSetName();
    [CompilerGeneratedAttribute]
public PolicyStatement get_PolicyStatement();
    [CompilerGeneratedAttribute]
public void set_PolicyStatement(PolicyStatement value);
    public void AddChild(CodeGroup group);
    public abstract virtual CodeGroup Copy();
    protected virtual void CreateXml(SecurityElement element, PolicyLevel level);
    public virtual bool Equals(object o);
    public void FromXml(SecurityElement e);
    public void FromXml(SecurityElement e, PolicyLevel level);
    public bool Equals(CodeGroup cg, bool compareChildren);
    public virtual int GetHashCode();
    protected virtual void ParseXml(SecurityElement e, PolicyLevel level);
    public void RemoveChild(CodeGroup group);
    public abstract virtual PolicyStatement Resolve(Evidence evidence);
    public abstract virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    public SecurityElement ToXml();
    public SecurityElement ToXml(PolicyLevel level);
}
public class System.Security.Policy.Evidence : object {
    [CompilerGeneratedAttribute]
private bool <Locked>k__BackingField;
    [ObsoleteAttribute("Evidence should not be treated as an ICollection. Please use GetHostEnumerator and GetAssemblyEnumerator to iterate over the evidence to collect a count.")]
public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public bool Locked { get; public set; }
    public object SyncRoot { get; }
    [ObsoleteAttribute("This constructor is obsolete. Please use the constructor which takes arrays of EvidenceBase instead.")]
public Evidence(Object[] hostEvidence, Object[] assemblyEvidence);
    public Evidence(Evidence evidence);
    public Evidence(EvidenceBase[] hostEvidence, EvidenceBase[] assemblyEvidence);
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    [CompilerGeneratedAttribute]
public bool get_Locked();
    [CompilerGeneratedAttribute]
public void set_Locked(bool value);
    public sealed virtual object get_SyncRoot();
    [ObsoleteAttribute("This method is obsolete. Please use AddAssemblyEvidence instead.")]
public void AddAssembly(object id);
    public void AddAssemblyEvidence(T evidence);
    public void AddHostEvidence(T evidence);
    public T GetAssemblyEvidence();
    public T GetHostEvidence();
    [ObsoleteAttribute("This method is obsolete. Please use AddHostEvidence instead.")]
public void AddHost(object id);
    public void Clear();
    public Evidence Clone();
    [ObsoleteAttribute("Evidence should not be treated as an ICollection. Please use the GetHostEnumerator and GetAssemblyEnumerator methods rather than using CopyTo.")]
public sealed virtual void CopyTo(Array array, int index);
    public IEnumerator GetAssemblyEnumerator();
    [ObsoleteAttribute("GetEnumerator is obsolete. Please use GetAssemblyEnumerator and GetHostEnumerator instead.")]
public sealed virtual IEnumerator GetEnumerator();
    public IEnumerator GetHostEnumerator();
    public void Merge(Evidence evidence);
    public void RemoveType(Type t);
}
public abstract class System.Security.Policy.EvidenceBase : object {
    public virtual EvidenceBase Clone();
}
public class System.Security.Policy.FileCodeGroup : CodeGroup {
    public string AttributeString { get; }
    public string MergeLogic { get; }
    public string PermissionSetName { get; }
    public FileCodeGroup(IMembershipCondition membershipCondition, FileIOPermissionAccess access);
    public virtual string get_AttributeString();
    public virtual string get_MergeLogic();
    public virtual string get_PermissionSetName();
    public virtual CodeGroup Copy();
    protected virtual void CreateXml(SecurityElement element, PolicyLevel level);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    protected virtual void ParseXml(SecurityElement e, PolicyLevel level);
    public virtual PolicyStatement Resolve(Evidence evidence);
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
}
[ObsoleteAttribute("This type is obsolete. See https://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public class System.Security.Policy.FirstMatchCodeGroup : CodeGroup {
    public string MergeLogic { get; }
    public FirstMatchCodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
    public virtual string get_MergeLogic();
    public virtual CodeGroup Copy();
    public virtual PolicyStatement Resolve(Evidence evidence);
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
}
public class System.Security.Policy.GacInstalled : EvidenceBase {
    public object Copy();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Security.Policy.GacMembershipCondition : object {
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
public class System.Security.Policy.Hash : EvidenceBase {
    public Byte[] MD5 { get; }
    public Byte[] SHA1 { get; }
    public Byte[] SHA256 { get; }
    public Hash(Assembly assembly);
    public Byte[] get_MD5();
    public Byte[] get_SHA1();
    public Byte[] get_SHA256();
    public static Hash CreateMD5(Byte[] md5);
    public static Hash CreateSHA1(Byte[] sha1);
    public static Hash CreateSHA256(Byte[] sha256);
    public Byte[] GenerateHash(HashAlgorithm hashAlg);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class System.Security.Policy.HashMembershipCondition : object {
    [CompilerGeneratedAttribute]
private HashAlgorithm <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <HashValue>k__BackingField;
    public HashAlgorithm HashAlgorithm { get; public set; }
    public Byte[] HashValue { get; public set; }
    public HashMembershipCondition(HashAlgorithm hashAlg, Byte[] value);
    [CompilerGeneratedAttribute]
public HashAlgorithm get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_HashAlgorithm(HashAlgorithm value);
    [CompilerGeneratedAttribute]
public Byte[] get_HashValue();
    [CompilerGeneratedAttribute]
public void set_HashValue(Byte[] value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
public interface System.Security.Policy.IIdentityPermissionFactory {
    public abstract virtual IPermission CreateIdentityPermission(Evidence evidence);
}
public interface System.Security.Policy.IMembershipCondition {
    public abstract virtual bool Check(Evidence evidence);
    public abstract virtual IMembershipCondition Copy();
    public abstract virtual bool Equals(object obj);
    public abstract virtual string ToString();
}
public class System.Security.Policy.NetCodeGroup : CodeGroup {
    public static string AbsentOriginScheme;
    public static string AnyOtherOriginScheme;
    public string AttributeString { get; }
    public string MergeLogic { get; }
    public string PermissionSetName { get; }
    public NetCodeGroup(IMembershipCondition membershipCondition);
    public virtual string get_AttributeString();
    public virtual string get_MergeLogic();
    public virtual string get_PermissionSetName();
    public void AddConnectAccess(string originScheme, CodeConnectAccess connectAccess);
    public virtual CodeGroup Copy();
    protected virtual void CreateXml(SecurityElement element, PolicyLevel level);
    public virtual bool Equals(object o);
    public DictionaryEntry[] GetConnectAccessRules();
    public virtual int GetHashCode();
    protected virtual void ParseXml(SecurityElement e, PolicyLevel level);
    public void ResetConnectAccess();
    public virtual PolicyStatement Resolve(Evidence evidence);
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
}
[ObsoleteAttribute("This type is obsolete. See https://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public class System.Security.Policy.PermissionRequestEvidence : EvidenceBase {
    public PermissionSet DeniedPermissions { get; }
    public PermissionSet OptionalPermissions { get; }
    public PermissionSet RequestedPermissions { get; }
    public PermissionRequestEvidence(PermissionSet request, PermissionSet optional, PermissionSet denied);
    public PermissionSet get_DeniedPermissions();
    public PermissionSet get_OptionalPermissions();
    public PermissionSet get_RequestedPermissions();
    public PermissionRequestEvidence Copy();
    public virtual string ToString();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Policy.PolicyException : SystemException {
    protected PolicyException(SerializationInfo info, StreamingContext context);
    public PolicyException(string message);
    public PolicyException(string message, Exception exception);
}
public class System.Security.Policy.PolicyLevel : object {
    [CompilerGeneratedAttribute]
private CodeGroup <RootCodeGroup>k__BackingField;
    [ObsoleteAttribute("Because all GAC assemblies always get full trust, the full trust list is no longer meaningful. You should install any assemblies that are used in security policy in the GAC to ensure they are trusted.")]
public IList FullTrustAssemblies { get; }
    public string Label { get; }
    public IList NamedPermissionSets { get; }
    public CodeGroup RootCodeGroup { get; public set; }
    public string StoreLocation { get; }
    public PolicyLevelType Type { get; }
    public IList get_FullTrustAssemblies();
    public string get_Label();
    public IList get_NamedPermissionSets();
    [CompilerGeneratedAttribute]
public CodeGroup get_RootCodeGroup();
    [CompilerGeneratedAttribute]
public void set_RootCodeGroup(CodeGroup value);
    public string get_StoreLocation();
    public PolicyLevelType get_Type();
    [ObsoleteAttribute("Because all GAC assemblies always get full trust, the full trust list is no longer meaningful. You should install any assemblies that are used in security policy in the GAC to ensure they are trusted.")]
public void AddFullTrustAssembly(StrongName sn);
    [ObsoleteAttribute("Because all GAC assemblies always get full trust, the full trust list is no longer meaningful. You should install any assemblies that are used in security policy in the GAC to ensure they are trusted.")]
public void AddFullTrustAssembly(StrongNameMembershipCondition snMC);
    public void AddNamedPermissionSet(NamedPermissionSet permSet);
    public NamedPermissionSet ChangeNamedPermissionSet(string name, PermissionSet pSet);
    [ObsoleteAttribute("AppDomain policy levels are obsolete. See https://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static PolicyLevel CreateAppDomainLevel();
    public void FromXml(SecurityElement e);
    public NamedPermissionSet GetNamedPermissionSet(string name);
    public void Recover();
    [ObsoleteAttribute("Because all GAC assemblies always get full trust, the full trust list is no longer meaningful. You should install any assemblies that are used in security policy in the GAC to ensure they are trusted.")]
public void RemoveFullTrustAssembly(StrongName sn);
    [ObsoleteAttribute("Because all GAC assemblies always get full trust, the full trust list is no longer meaningful. You should install any assemblies that are used in security policy in the GAC to ensure they are trusted.")]
public void RemoveFullTrustAssembly(StrongNameMembershipCondition snMC);
    public NamedPermissionSet RemoveNamedPermissionSet(NamedPermissionSet permSet);
    public NamedPermissionSet RemoveNamedPermissionSet(string name);
    public void Reset();
    public PolicyStatement Resolve(Evidence evidence);
    public CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    public SecurityElement ToXml();
}
public class System.Security.Policy.PolicyStatement : object {
    [CompilerGeneratedAttribute]
private PolicyStatementAttribute <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private PermissionSet <PermissionSet>k__BackingField;
    public PolicyStatementAttribute Attributes { get; public set; }
    public string AttributeString { get; }
    public PermissionSet PermissionSet { get; public set; }
    public PolicyStatement(PermissionSet permSet);
    public PolicyStatement(PermissionSet permSet, PolicyStatementAttribute attributes);
    [CompilerGeneratedAttribute]
public PolicyStatementAttribute get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(PolicyStatementAttribute value);
    public string get_AttributeString();
    [CompilerGeneratedAttribute]
public PermissionSet get_PermissionSet();
    [CompilerGeneratedAttribute]
public void set_PermissionSet(PermissionSet value);
    public PolicyStatement Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement et);
    public sealed virtual void FromXml(SecurityElement et, PolicyLevel level);
    public virtual int GetHashCode();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
[FlagsAttribute]
public enum System.Security.Policy.PolicyStatementAttribute : Enum {
    public int value__;
    public static PolicyStatementAttribute All;
    public static PolicyStatementAttribute Exclusive;
    public static PolicyStatementAttribute LevelFinal;
    public static PolicyStatementAttribute Nothing;
}
public class System.Security.Policy.Publisher : EvidenceBase {
    public X509Certificate Certificate { get; }
    public Publisher(X509Certificate cert);
    public X509Certificate get_Certificate();
    public object Copy();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Security.Policy.PublisherMembershipCondition : object {
    [CompilerGeneratedAttribute]
private X509Certificate <Certificate>k__BackingField;
    public X509Certificate Certificate { get; public set; }
    public PublisherMembershipCondition(X509Certificate certificate);
    [CompilerGeneratedAttribute]
public X509Certificate get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(X509Certificate value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
public class System.Security.Policy.Site : EvidenceBase {
    public string Name { get; }
    public Site(string name);
    public string get_Name();
    public object Copy();
    public static Site CreateFromUrl(string url);
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Security.Policy.SiteMembershipCondition : object {
    [CompilerGeneratedAttribute]
private string <Site>k__BackingField;
    public string Site { get; public set; }
    public SiteMembershipCondition(string site);
    [CompilerGeneratedAttribute]
public string get_Site();
    [CompilerGeneratedAttribute]
public void set_Site(string value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
public class System.Security.Policy.StrongName : EvidenceBase {
    public string Name { get; }
    public StrongNamePublicKeyBlob PublicKey { get; }
    public Version Version { get; }
    public StrongName(StrongNamePublicKeyBlob blob, string name, Version version);
    public string get_Name();
    public StrongNamePublicKeyBlob get_PublicKey();
    public Version get_Version();
    public object Copy();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Security.Policy.StrongNameMembershipCondition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private StrongNamePublicKeyBlob <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Name { get; public set; }
    public StrongNamePublicKeyBlob PublicKey { get; public set; }
    public Version Version { get; public set; }
    public StrongNameMembershipCondition(StrongNamePublicKeyBlob blob, string name, Version version);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public StrongNamePublicKeyBlob get_PublicKey();
    [CompilerGeneratedAttribute]
public void set_PublicKey(StrongNamePublicKeyBlob value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Version value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
public class System.Security.Policy.TrustManagerContext : object {
    [CompilerGeneratedAttribute]
private bool <IgnorePersistedDecision>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepAlive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoPrompt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Persist>k__BackingField;
    [CompilerGeneratedAttribute]
private TrustManagerUIContext <UIContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ApplicationIdentity <PreviousApplicationIdentity>k__BackingField;
    public bool IgnorePersistedDecision { get; public set; }
    public bool KeepAlive { get; public set; }
    public bool NoPrompt { get; public set; }
    public bool Persist { get; public set; }
    public TrustManagerUIContext UIContext { get; public set; }
    public ApplicationIdentity PreviousApplicationIdentity { get; public set; }
    public TrustManagerContext(TrustManagerUIContext uiContext);
    [CompilerGeneratedAttribute]
public virtual bool get_IgnorePersistedDecision();
    [CompilerGeneratedAttribute]
public virtual void set_IgnorePersistedDecision(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_KeepAlive();
    [CompilerGeneratedAttribute]
public virtual void set_KeepAlive(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_NoPrompt();
    [CompilerGeneratedAttribute]
public virtual void set_NoPrompt(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_Persist();
    [CompilerGeneratedAttribute]
public virtual void set_Persist(bool value);
    [CompilerGeneratedAttribute]
public virtual TrustManagerUIContext get_UIContext();
    [CompilerGeneratedAttribute]
public virtual void set_UIContext(TrustManagerUIContext value);
    [CompilerGeneratedAttribute]
public virtual ApplicationIdentity get_PreviousApplicationIdentity();
    [CompilerGeneratedAttribute]
public virtual void set_PreviousApplicationIdentity(ApplicationIdentity value);
}
public enum System.Security.Policy.TrustManagerUIContext : Enum {
    public int value__;
    public static TrustManagerUIContext Install;
    public static TrustManagerUIContext Run;
    public static TrustManagerUIContext Upgrade;
}
[ObsoleteAttribute("This type is obsolete. See https://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public class System.Security.Policy.UnionCodeGroup : CodeGroup {
    public string MergeLogic { get; }
    public UnionCodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
    public virtual string get_MergeLogic();
    public virtual CodeGroup Copy();
    public virtual PolicyStatement Resolve(Evidence evidence);
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
}
public class System.Security.Policy.Url : EvidenceBase {
    public string Value { get; }
    public Url(string name);
    public string get_Value();
    public object Copy();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Security.Policy.UrlMembershipCondition : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Url { get; public set; }
    public UrlMembershipCondition(string url);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object obj);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
public class System.Security.Policy.Zone : EvidenceBase {
    public SecurityZone SecurityZone { get; }
    public Zone(SecurityZone zone);
    public SecurityZone get_SecurityZone();
    public object Copy();
    public static Zone CreateFromUrl(string url);
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Security.Policy.ZoneMembershipCondition : object {
    [CompilerGeneratedAttribute]
private SecurityZone <SecurityZone>k__BackingField;
    public SecurityZone SecurityZone { get; public set; }
    public ZoneMembershipCondition(SecurityZone zone);
    [CompilerGeneratedAttribute]
public SecurityZone get_SecurityZone();
    [CompilerGeneratedAttribute]
public void set_SecurityZone(SecurityZone value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
public enum System.Security.PolicyLevelType : Enum {
    public int value__;
    public static PolicyLevelType AppDomain;
    public static PolicyLevelType Enterprise;
    public static PolicyLevelType Machine;
    public static PolicyLevelType User;
}
public class System.Security.SecurityContext : object {
    public static SecurityContext Capture();
    public SecurityContext CreateCopy();
    public sealed virtual void Dispose();
    public static bool IsFlowSuppressed();
    public static bool IsWindowsIdentityFlowSuppressed();
    public static void RestoreFlow();
    public static void Run(SecurityContext securityContext, ContextCallback callback, object state);
    public static AsyncFlowControl SuppressFlow();
    public static AsyncFlowControl SuppressFlowWindowsIdentity();
}
public enum System.Security.SecurityContextSource : Enum {
    public int value__;
    public static SecurityContextSource CurrentAppDomain;
    public static SecurityContextSource CurrentAssembly;
}
public static class System.Security.SecurityManager : object {
    [CompilerGeneratedAttribute]
private static bool <CheckExecutionRights>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SecurityEnabled>k__BackingField;
    [ObsoleteAttribute]
public static bool CheckExecutionRights { get; public set; }
    [ObsoleteAttribute]
public static bool SecurityEnabled { get; public set; }
    [CompilerGeneratedAttribute]
public static bool get_CheckExecutionRights();
    [CompilerGeneratedAttribute]
public static void set_CheckExecutionRights(bool value);
    [CompilerGeneratedAttribute]
public static bool get_SecurityEnabled();
    [CompilerGeneratedAttribute]
public static void set_SecurityEnabled(bool value);
    public static bool CurrentThreadRequiresSecurityContextCapture();
    public static PermissionSet GetStandardSandbox(Evidence evidence);
    public static void GetZoneAndOrigin(ArrayList& zone, ArrayList& origin);
    [ObsoleteAttribute]
public static bool IsGranted(IPermission perm);
    [ObsoleteAttribute]
public static PolicyLevel LoadPolicyLevelFromFile(string path, PolicyLevelType type);
    [ObsoleteAttribute]
public static PolicyLevel LoadPolicyLevelFromString(string str, PolicyLevelType type);
    [ObsoleteAttribute]
public static IEnumerator PolicyHierarchy();
    [ObsoleteAttribute]
public static PermissionSet ResolvePolicy(Evidence evidence);
    [ObsoleteAttribute]
public static PermissionSet ResolvePolicy(Evidence evidence, PermissionSet reqdPset, PermissionSet optPset, PermissionSet denyPset, PermissionSet& denied);
    [ObsoleteAttribute]
public static PermissionSet ResolvePolicy(Evidence[] evidences);
    [ObsoleteAttribute]
public static IEnumerator ResolvePolicyGroups(Evidence evidence);
    [ObsoleteAttribute]
public static PermissionSet ResolveSystemPolicy(Evidence evidence);
    [ObsoleteAttribute]
public static void SavePolicy();
    [ObsoleteAttribute]
public static void SavePolicyLevel(PolicyLevel level);
}
public abstract class System.Security.SecurityState : object {
    public abstract virtual void EnsureState();
    public bool IsStateAvailable();
}
public enum System.Security.SecurityZone : Enum {
    public int value__;
    public static SecurityZone Internet;
    public static SecurityZone Intranet;
    public static SecurityZone MyComputer;
    public static SecurityZone NoZone;
    public static SecurityZone Trusted;
    public static SecurityZone Untrusted;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.XmlSyntaxException : SystemException {
    public XmlSyntaxException(int lineNumber);
    public XmlSyntaxException(int lineNumber, string message);
    public XmlSyntaxException(string message);
    public XmlSyntaxException(string message, Exception inner);
    private XmlSyntaxException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceProcess.ServiceControllerPermission : ResourcePermissionBase {
    public ServiceControllerPermissionEntryCollection PermissionEntries { get; }
    public ServiceControllerPermission(PermissionState state);
    public ServiceControllerPermission(ServiceControllerPermissionAccess permissionAccess, string machineName, string serviceName);
    public ServiceControllerPermission(ServiceControllerPermissionEntry[] permissionAccessEntries);
    public ServiceControllerPermissionEntryCollection get_PermissionEntries();
}
[FlagsAttribute]
public enum System.ServiceProcess.ServiceControllerPermissionAccess : Enum {
    public int value__;
    public static ServiceControllerPermissionAccess None;
    public static ServiceControllerPermissionAccess Browse;
    public static ServiceControllerPermissionAccess Control;
}
[AttributeUsageAttribute("621")]
public class System.ServiceProcess.ServiceControllerPermissionAttribute : CodeAccessSecurityAttribute {
    public string MachineName { get; public set; }
    public ServiceControllerPermissionAccess PermissionAccess { get; public set; }
    public string ServiceName { get; public set; }
    public ServiceControllerPermissionAttribute(SecurityAction action);
    public string get_MachineName();
    public void set_MachineName(string value);
    public ServiceControllerPermissionAccess get_PermissionAccess();
    public void set_PermissionAccess(ServiceControllerPermissionAccess value);
    public string get_ServiceName();
    public void set_ServiceName(string value);
    public virtual IPermission CreatePermission();
}
public class System.ServiceProcess.ServiceControllerPermissionEntry : object {
    public string MachineName { get; }
    public ServiceControllerPermissionAccess PermissionAccess { get; }
    public string ServiceName { get; }
    public ServiceControllerPermissionEntry(ServiceControllerPermissionAccess permissionAccess, string machineName, string serviceName);
    public string get_MachineName();
    public ServiceControllerPermissionAccess get_PermissionAccess();
    public string get_ServiceName();
}
[DefaultMemberAttribute("Item")]
public class System.ServiceProcess.ServiceControllerPermissionEntryCollection : CollectionBase {
    public ServiceControllerPermissionEntry Item { get; public set; }
    public ServiceControllerPermissionEntry get_Item(int index);
    public void set_Item(int index, ServiceControllerPermissionEntry value);
    public int Add(ServiceControllerPermissionEntry value);
    public void AddRange(ServiceControllerPermissionEntry[] value);
    public void AddRange(ServiceControllerPermissionEntryCollection value);
    public bool Contains(ServiceControllerPermissionEntry value);
    public void CopyTo(ServiceControllerPermissionEntry[] array, int index);
    public int IndexOf(ServiceControllerPermissionEntry value);
    public void Insert(int index, ServiceControllerPermissionEntry value);
    protected virtual void OnClear();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnSet(int index, object oldValue, object newValue);
    public void Remove(ServiceControllerPermissionEntry value);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Argument_InvalidPermissionState { get; }
    internal static string Argument_NotAPermissionElement { get; }
    internal static string Argument_InvalidXMLBadVersion { get; }
    internal static string Argument_WrongType { get; }
    internal static string HostProtection_ProtectedResources { get; }
    internal static string HostProtection_DemandedResources { get; }
    internal static string Security_PrincipalPermission { get; }
    internal static string PlatformNotSupported_CAS { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Argument_InvalidPermissionState();
    internal static string get_Argument_NotAPermissionElement();
    internal static string get_Argument_InvalidXMLBadVersion();
    internal static string get_Argument_WrongType();
    internal static string get_HostProtection_ProtectedResources();
    internal static string get_HostProtection_DemandedResources();
    internal static string get_Security_PrincipalPermission();
    internal static string get_PlatformNotSupported_CAS();
}
public class System.Transactions.DistributedTransactionPermission : CodeAccessPermission {
    public DistributedTransactionPermission(PermissionState state);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("32767")]
public class System.Transactions.DistributedTransactionPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private bool <Unrestricted>k__BackingField;
    public bool Unrestricted { get; public set; }
    public DistributedTransactionPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public bool get_Unrestricted();
    [CompilerGeneratedAttribute]
public void set_Unrestricted(bool value);
    public virtual IPermission CreatePermission();
}
public class System.Web.AspNetHostingPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private AspNetHostingPermissionLevel <Level>k__BackingField;
    public AspNetHostingPermissionLevel Level { get; public set; }
    public AspNetHostingPermission(PermissionState state);
    public AspNetHostingPermission(AspNetHostingPermissionLevel level);
    [CompilerGeneratedAttribute]
public AspNetHostingPermissionLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(AspNetHostingPermissionLevel value);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("32767")]
public class System.Web.AspNetHostingPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private AspNetHostingPermissionLevel <Level>k__BackingField;
    public AspNetHostingPermissionLevel Level { get; public set; }
    public AspNetHostingPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public AspNetHostingPermissionLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(AspNetHostingPermissionLevel value);
    public virtual IPermission CreatePermission();
}
public enum System.Web.AspNetHostingPermissionLevel : Enum {
    public int value__;
    public static AspNetHostingPermissionLevel None;
    public static AspNetHostingPermissionLevel Minimal;
    public static AspNetHostingPermissionLevel Low;
    public static AspNetHostingPermissionLevel Medium;
    public static AspNetHostingPermissionLevel High;
    public static AspNetHostingPermissionLevel Unrestricted;
}
public class System.Xaml.Permissions.XamlLoadPermission : CodeAccessPermission {
    [CompilerGeneratedAttribute]
private IList`1<XamlAccessLevel> <AllowedAccess>k__BackingField;
    public IList`1<XamlAccessLevel> AllowedAccess { get; private set; }
    public XamlLoadPermission(PermissionState state);
    public XamlLoadPermission(XamlAccessLevel allowedAccess);
    public XamlLoadPermission(IEnumerable`1<XamlAccessLevel> allowedAccess);
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public IList`1<XamlAccessLevel> get_AllowedAccess();
    [CompilerGeneratedAttribute]
private void set_AllowedAccess(IList`1<XamlAccessLevel> value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement elem);
    public bool Includes(XamlAccessLevel requestedAccess);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission other);
    public sealed virtual bool IsUnrestricted();
}
