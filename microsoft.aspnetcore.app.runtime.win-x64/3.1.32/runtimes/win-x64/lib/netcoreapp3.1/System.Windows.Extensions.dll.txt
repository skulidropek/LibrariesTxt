internal static class FxResources.System.Windows.Extensions.SR : object {
}
internal static class Interop : object {
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static T GetInvalidHandle(Func`1<T> invalidHandleFactory);
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
public class System.Drawing.FontConverter : TypeConverter {
    private static string StylePrefix;
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    private ValueTuple`2<string, string> ParseSizeTokens(string text, char separator);
    private GraphicsUnit ParseGraphicsUnits(string units);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.IconConverter : ExpandableObjectConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Drawing.ImageConverter : TypeConverter {
    private static ReadOnlySpan`1<byte> PBrush { get; }
    private static ReadOnlySpan`1<byte> BMBytes { get; }
    private static ReadOnlySpan`1<byte> get_PBrush();
    private static ReadOnlySpan`1<byte> get_BMBytes();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    private static ImageCodecInfo FindEncoder(ImageFormat imageformat);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
    private Stream GetBitmapStream(ReadOnlySpan`1<byte> rawData);
}
public class System.Drawing.ImageFormatConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.Printing.MarginsConverter : ExpandableObjectConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
}
public class System.Media.SoundPlayer : Component {
    private static int BlockSize;
    private static int DefaultLoadTimeout;
    private Uri _uri;
    private string _soundLocation;
    private int _loadTimeout;
    private ManualResetEvent _semaphore;
    private Task _copyTask;
    private CancellationTokenSource _copyTaskCancellation;
    private int _currentPos;
    private Stream _stream;
    private Exception _lastLoadException;
    private bool _doesLoadAppearSynchronous;
    private Byte[] _streamData;
    private AsyncOperation _asyncOperation;
    private SendOrPostCallback _loadAsyncOperationCompleted;
    private static object s_eventLoadCompleted;
    private static object s_eventSoundLocationChanged;
    private static object s_eventStreamChanged;
    [CompilerGeneratedAttribute]
private bool <IsLoadCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    public int LoadTimeout { get; public set; }
    public string SoundLocation { get; public set; }
    public Stream Stream { get; public set; }
    public bool IsLoadCompleted { get; private set; }
    public object Tag { get; public set; }
    public SoundPlayer(string soundLocation);
    public SoundPlayer(Stream stream);
    protected SoundPlayer(SerializationInfo serializationInfo, StreamingContext context);
    private static SoundPlayer();
    public int get_LoadTimeout();
    public void set_LoadTimeout(int value);
    public string get_SoundLocation();
    public void set_SoundLocation(string value);
    public Stream get_Stream();
    public void set_Stream(Stream value);
    [CompilerGeneratedAttribute]
public bool get_IsLoadCompleted();
    [CompilerGeneratedAttribute]
private void set_IsLoadCompleted(bool value);
    [CompilerGeneratedAttribute]
public object get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(object value);
    public void LoadAsync();
    private void LoadAsyncOperationCompleted(object arg);
    private void CleanupStreamData();
    public void Load();
    private void LoadAndPlay(int flags);
    private void CancelLoad();
    private void LoadSync();
    private void LoadStream(bool loadSync);
    public void Play();
    public void PlaySync();
    public void PlayLooping();
    private static Uri ResolveUri(string partialUri);
    private void SetupSoundLocation(string soundLocation);
    private void SetupStream(Stream stream);
    public void Stop();
    public void add_LoadCompleted(AsyncCompletedEventHandler value);
    public void remove_LoadCompleted(AsyncCompletedEventHandler value);
    public void add_SoundLocationChanged(EventHandler value);
    public void remove_SoundLocationChanged(EventHandler value);
    public void add_StreamChanged(EventHandler value);
    public void remove_StreamChanged(EventHandler value);
    protected virtual void OnLoadCompleted(AsyncCompletedEventArgs e);
    protected virtual void OnSoundLocationChanged(EventArgs e);
    protected virtual void OnStreamChanged(EventArgs e);
    [AsyncStateMachineAttribute("System.Media.SoundPlayer/<CopyStreamAsync>d__66")]
private Task CopyStreamAsync(CancellationToken cancellationToken);
    private void ValidateSoundFile(string fileName);
    private static void ValidateSoundData(Byte[] data);
    private static short BytesToInt16(byte ch0, byte ch1);
    private static int BytesToInt(byte ch0, byte ch1, byte ch2, byte ch3);
    private static int mmioFOURCC(char ch0, char ch1, char ch2, char ch3);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Media.SystemSound : object {
    private int _soundType;
    internal SystemSound(int soundType);
    public void Play();
}
public static class System.Media.SystemSounds : object {
    private static SystemSound modreq(System.Runtime.CompilerServices.IsVolatile) s_asterisk;
    private static SystemSound modreq(System.Runtime.CompilerServices.IsVolatile) s_beep;
    private static SystemSound modreq(System.Runtime.CompilerServices.IsVolatile) s_exclamation;
    private static SystemSound modreq(System.Runtime.CompilerServices.IsVolatile) s_hand;
    private static SystemSound modreq(System.Runtime.CompilerServices.IsVolatile) s_question;
    public static SystemSound Asterisk { get; }
    public static SystemSound Beep { get; }
    public static SystemSound Exclamation { get; }
    public static SystemSound Hand { get; }
    public static SystemSound Question { get; }
    public static SystemSound get_Asterisk();
    public static SystemSound get_Beep();
    public static SystemSound get_Exclamation();
    public static SystemSound get_Hand();
    public static SystemSound get_Question();
}
internal class System.Security.Cryptography.X509Certificates.SafeCertContextHandle : SafePointerHandle`1<SafeCertContextHandle> {
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.X509Certificates.SafeCertStoreHandle : SafePointerHandle`1<SafeCertStoreHandle> {
    protected sealed virtual bool ReleaseHandle();
}
internal abstract class System.Security.Cryptography.X509Certificates.SafePointerHandle`1 : SafeHandle {
    public bool IsInvalid { get; }
    public static T InvalidHandle { get; }
    public sealed virtual bool get_IsInvalid();
    public static T get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2UI : object {
    internal static int ERROR_SUCCESS;
    internal static int ERROR_CANCELLED;
    public static void DisplayCertificate(X509Certificate2 certificate);
    public static void DisplayCertificate(X509Certificate2 certificate, IntPtr hwndParent);
    public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag);
    public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag, IntPtr hwndParent);
    private static void DisplayX509Certificate(X509Certificate2 certificate, IntPtr hwndParent);
    private static X509Certificate2Collection SelectFromCollectionHelper(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag, IntPtr hwndParent);
    private static SafeCertStoreHandle SelectFromStore(SafeCertStoreHandle safeSourceStoreHandle, string title, string message, X509SelectionFlag selectionFlags, IntPtr hwndParent);
}
public enum System.Security.Cryptography.X509Certificates.X509SelectionFlag : Enum {
    public int value__;
    public static X509SelectionFlag SingleSelection;
    public static X509SelectionFlag MultiSelection;
}
internal static class System.Security.Cryptography.X509Certificates.X509Utils : object {
    internal static UInt32 CERT_STORE_ENUM_ARCHIVED_FLAG;
    internal static UInt32 CERT_STORE_CREATE_NEW_FLAG;
    internal static SafeCertContextHandle DuplicateCertificateContext(X509Certificate2 certificate);
    internal static SafeCertStoreHandle ExportToMemoryStore(X509Certificate2Collection collection);
    internal static X509Certificate2Collection GetCertificates(SafeCertStoreHandle safeCertStoreHandle);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ConvertInvalidPrimitive { get; }
    internal static string Cryptography_InvalidHandle { get; }
    internal static string Enum_InvalidValue { get; }
    internal static string none { get; }
    internal static string InvalidArgumentValue { get; }
    internal static string PlatformNotSupported_System_Windows_Extensions { get; }
    internal static string SoundAPIBadSoundLocation { get; }
    internal static string SoundAPIFileDoesNotExist { get; }
    internal static string SoundAPIFormatNotSupported { get; }
    internal static string SoundAPIInvalidWaveFile { get; }
    internal static string SoundAPIInvalidWaveHeader { get; }
    internal static string SoundAPILoadTimedOut { get; }
    internal static string SoundAPILoadTimeout { get; }
    internal static string SoundAPIReadError { get; }
    internal static string TextParseFailedFormat { get; }
    internal static string PropertyValueInvalidEntry { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ConvertInvalidPrimitive();
    internal static string get_Cryptography_InvalidHandle();
    internal static string get_Enum_InvalidValue();
    internal static string get_none();
    internal static string get_InvalidArgumentValue();
    internal static string get_PlatformNotSupported_System_Windows_Extensions();
    internal static string get_SoundAPIBadSoundLocation();
    internal static string get_SoundAPIFileDoesNotExist();
    internal static string get_SoundAPIFormatNotSupported();
    internal static string get_SoundAPIInvalidWaveFile();
    internal static string get_SoundAPIInvalidWaveHeader();
    internal static string get_SoundAPILoadTimedOut();
    internal static string get_SoundAPILoadTimeout();
    internal static string get_SoundAPIReadError();
    internal static string get_TextParseFailedFormat();
    internal static string get_PropertyValueInvalidEntry();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference();
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    public void Insert(int index, string s);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
public class System.Xaml.Permissions.XamlAccessLevel : object {
    [CompilerGeneratedAttribute]
private string <PrivateAccessToTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyNameString>k__BackingField;
    public AssemblyName AssemblyAccessToAssemblyName { get; }
    public string PrivateAccessToTypeName { get; private set; }
    internal string AssemblyNameString { get; private set; }
    private XamlAccessLevel(string assemblyName, string typeName);
    public static XamlAccessLevel AssemblyAccessTo(Assembly assembly);
    public static XamlAccessLevel AssemblyAccessTo(AssemblyName assemblyName);
    public static XamlAccessLevel PrivateAccessTo(Type type);
    public static XamlAccessLevel PrivateAccessTo(string assemblyQualifiedTypeName);
    public AssemblyName get_AssemblyAccessToAssemblyName();
    [CompilerGeneratedAttribute]
public string get_PrivateAccessToTypeName();
    [CompilerGeneratedAttribute]
private void set_PrivateAccessToTypeName(string value);
    [CompilerGeneratedAttribute]
internal string get_AssemblyNameString();
    [CompilerGeneratedAttribute]
private void set_AssemblyNameString(string value);
}
