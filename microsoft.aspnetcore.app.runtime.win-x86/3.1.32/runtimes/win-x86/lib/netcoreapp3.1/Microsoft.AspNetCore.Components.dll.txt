public static class Microsoft.AspNetCore.Components.BindConverter : object {
    private static object BoxedTrue;
    private static object BoxedFalse;
    internal static BindParser`1<string> ConvertToString;
    internal static BindParser`1<bool> ConvertToBool;
    internal static BindParser`1<Nullable`1<bool>> ConvertToNullableBool;
    internal static BindParser`1<int> ConvertToInt;
    internal static BindParser`1<Nullable`1<int>> ConvertToNullableInt;
    internal static BindParser`1<long> ConvertToLong;
    internal static BindParser`1<Nullable`1<long>> ConvertToNullableLong;
    internal static BindParser`1<float> ConvertToFloat;
    internal static BindParser`1<Nullable`1<float>> ConvertToNullableFloat;
    internal static BindParser`1<double> ConvertToDoubleDelegate;
    internal static BindParser`1<Nullable`1<double>> ConvertToNullableDoubleDelegate;
    internal static BindParser`1<decimal> ConvertToDecimal;
    internal static BindParser`1<Nullable`1<decimal>> ConvertToNullableDecimal;
    internal static BindParser`1<DateTime> ConvertToDateTime;
    internal static BindParserWithFormat`1<DateTime> ConvertToDateTimeWithFormat;
    internal static BindParser`1<Nullable`1<DateTime>> ConvertToNullableDateTime;
    internal static BindParserWithFormat`1<Nullable`1<DateTime>> ConvertToNullableDateTimeWithFormat;
    internal static BindParser`1<DateTimeOffset> ConvertToDateTimeOffset;
    internal static BindParserWithFormat`1<DateTimeOffset> ConvertToDateTimeOffsetWithFormat;
    internal static BindParser`1<Nullable`1<DateTimeOffset>> ConvertToNullableDateTimeOffset;
    internal static BindParserWithFormat`1<Nullable`1<DateTimeOffset>> ConvertToNullableDateTimeOffsetWithFormat;
    private static BindConverter();
    public static string FormatValue(string value, CultureInfo culture);
    private static string FormatStringValueCore(string value, CultureInfo culture);
    public static bool FormatValue(bool value, CultureInfo culture);
    private static object FormatBoolValueCore(bool value, CultureInfo culture);
    public static Nullable`1<bool> FormatValue(Nullable`1<bool> value, CultureInfo culture);
    private static object FormatNullableBoolValueCore(Nullable`1<bool> value, CultureInfo culture);
    public static string FormatValue(int value, CultureInfo culture);
    private static string FormatIntValueCore(int value, CultureInfo culture);
    public static string FormatValue(Nullable`1<int> value, CultureInfo culture);
    private static string FormatNullableIntValueCore(Nullable`1<int> value, CultureInfo culture);
    public static string FormatValue(long value, CultureInfo culture);
    private static string FormatLongValueCore(long value, CultureInfo culture);
    public static string FormatValue(Nullable`1<long> value, CultureInfo culture);
    private static string FormatNullableLongValueCore(Nullable`1<long> value, CultureInfo culture);
    public static string FormatValue(float value, CultureInfo culture);
    private static string FormatFloatValueCore(float value, CultureInfo culture);
    public static string FormatValue(Nullable`1<float> value, CultureInfo culture);
    private static string FormatNullableFloatValueCore(Nullable`1<float> value, CultureInfo culture);
    public static string FormatValue(double value, CultureInfo culture);
    private static string FormatDoubleValueCore(double value, CultureInfo culture);
    public static string FormatValue(Nullable`1<double> value, CultureInfo culture);
    private static string FormatNullableDoubleValueCore(Nullable`1<double> value, CultureInfo culture);
    public static string FormatValue(decimal value, CultureInfo culture);
    private static string FormatDecimalValueCore(decimal value, CultureInfo culture);
    public static string FormatValue(Nullable`1<decimal> value, CultureInfo culture);
    private static string FormatNullableDecimalValueCore(Nullable`1<decimal> value, CultureInfo culture);
    public static string FormatValue(DateTime value, CultureInfo culture);
    public static string FormatValue(DateTime value, string format, CultureInfo culture);
    private static string FormatDateTimeValueCore(DateTime value, string format, CultureInfo culture);
    private static string FormatDateTimeValueCore(DateTime value, CultureInfo culture);
    public static string FormatValue(Nullable`1<DateTime> value, CultureInfo culture);
    public static string FormatValue(Nullable`1<DateTime> value, string format, CultureInfo culture);
    private static string FormatNullableDateTimeValueCore(Nullable`1<DateTime> value, string format, CultureInfo culture);
    private static string FormatNullableDateTimeValueCore(Nullable`1<DateTime> value, CultureInfo culture);
    public static string FormatValue(DateTimeOffset value, CultureInfo culture);
    public static string FormatValue(DateTimeOffset value, string format, CultureInfo culture);
    private static string FormatDateTimeOffsetValueCore(DateTimeOffset value, string format, CultureInfo culture);
    private static string FormatDateTimeOffsetValueCore(DateTimeOffset value, CultureInfo culture);
    public static string FormatValue(Nullable`1<DateTimeOffset> value, CultureInfo culture);
    public static string FormatValue(Nullable`1<DateTimeOffset> value, string format, CultureInfo culture);
    private static string FormatNullableDateTimeOffsetValueCore(Nullable`1<DateTimeOffset> value, string format, CultureInfo culture);
    private static string FormatNullableDateTimeOffsetValueCore(Nullable`1<DateTimeOffset> value, CultureInfo culture);
    private static string FormatEnumValueCore(T value, CultureInfo culture);
    private static string FormatNullableEnumValueCore(Nullable`1<T> value, CultureInfo culture);
    public static object FormatValue(T value, CultureInfo culture);
    public static bool TryConvertToString(object obj, CultureInfo culture, String& value);
    private static bool ConvertToStringCore(object obj, CultureInfo culture, String& value);
    public static bool TryConvertToBool(object obj, CultureInfo culture, Boolean& value);
    public static bool TryConvertToNullableBool(object obj, CultureInfo culture, Nullable`1& value);
    private static bool ConvertToBoolCore(object obj, CultureInfo culture, Boolean& value);
    private static bool ConvertToNullableBoolCore(object obj, CultureInfo culture, Nullable`1& value);
    public static bool TryConvertToInt(object obj, CultureInfo culture, Int32& value);
    public static bool TryConvertToNullableInt(object obj, CultureInfo culture, Nullable`1& value);
    private static bool ConvertToIntCore(object obj, CultureInfo culture, Int32& value);
    private static bool ConvertToNullableIntCore(object obj, CultureInfo culture, Nullable`1& value);
    public static bool TryConvertToLong(object obj, CultureInfo culture, Int64& value);
    public static bool TryConvertToNullableLong(object obj, CultureInfo culture, Nullable`1& value);
    private static bool ConvertToLongCore(object obj, CultureInfo culture, Int64& value);
    private static bool ConvertToNullableLongCore(object obj, CultureInfo culture, Nullable`1& value);
    public static bool TryConvertToFloat(object obj, CultureInfo culture, Single& value);
    public static bool TryConvertToNullableFloat(object obj, CultureInfo culture, Nullable`1& value);
    private static bool ConvertToFloatCore(object obj, CultureInfo culture, Single& value);
    private static bool ConvertToNullableFloatCore(object obj, CultureInfo culture, Nullable`1& value);
    public static bool TryConvertToDouble(object obj, CultureInfo culture, Double& value);
    public static bool TryConvertToNullableDouble(object obj, CultureInfo culture, Nullable`1& value);
    private static bool ConvertToDoubleCore(object obj, CultureInfo culture, Double& value);
    private static bool ConvertToNullableDoubleCore(object obj, CultureInfo culture, Nullable`1& value);
    public static bool TryConvertToDecimal(object obj, CultureInfo culture, Decimal& value);
    public static bool TryConvertToNullableDecimal(object obj, CultureInfo culture, Nullable`1& value);
    private static bool ConvertToDecimalCore(object obj, CultureInfo culture, Decimal& value);
    private static bool ConvertToNullableDecimalCore(object obj, CultureInfo culture, Nullable`1& value);
    public static bool TryConvertToDateTime(object obj, CultureInfo culture, DateTime& value);
    public static bool TryConvertToDateTime(object obj, CultureInfo culture, string format, DateTime& value);
    public static bool TryConvertToNullableDateTime(object obj, CultureInfo culture, Nullable`1& value);
    public static bool TryConvertToNullableDateTime(object obj, CultureInfo culture, string format, Nullable`1& value);
    private static bool ConvertToDateTimeCore(object obj, CultureInfo culture, DateTime& value);
    private static bool ConvertToDateTimeCore(object obj, CultureInfo culture, string format, DateTime& value);
    private static bool ConvertToNullableDateTimeCore(object obj, CultureInfo culture, Nullable`1& value);
    private static bool ConvertToNullableDateTimeCore(object obj, CultureInfo culture, string format, Nullable`1& value);
    public static bool TryConvertToDateTimeOffset(object obj, CultureInfo culture, DateTimeOffset& value);
    public static bool TryConvertToDateTimeOffset(object obj, CultureInfo culture, string format, DateTimeOffset& value);
    public static bool TryConvertToNullableDateTimeOffset(object obj, CultureInfo culture, Nullable`1& value);
    public static bool TryConvertToNullableDateTimeOffset(object obj, CultureInfo culture, string format, Nullable`1& value);
    private static bool ConvertToDateTimeOffsetCore(object obj, CultureInfo culture, DateTimeOffset& value);
    private static bool ConvertToDateTimeOffsetCore(object obj, CultureInfo culture, string format, DateTimeOffset& value);
    private static bool ConvertToNullableDateTimeOffsetCore(object obj, CultureInfo culture, Nullable`1& value);
    private static bool ConvertToNullableDateTimeOffsetCore(object obj, CultureInfo culture, string format, Nullable`1& value);
    private static bool ConvertToEnum(object obj, CultureInfo culture, T& value);
    private static bool ConvertToNullableEnum(object obj, CultureInfo culture, Nullable`1& value);
    public static bool TryConvertTo(object obj, CultureInfo culture, T& value);
}
[AttributeUsageAttribute("4")]
public class Microsoft.AspNetCore.Components.BindElementAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValueAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeAttribute>k__BackingField;
    public string Element { get; }
    public string Suffix { get; }
    public string ValueAttribute { get; }
    public string ChangeAttribute { get; }
    public BindElementAttribute(string element, string suffix, string valueAttribute, string changeAttribute);
    [CompilerGeneratedAttribute]
public string get_Element();
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public string get_ValueAttribute();
    [CompilerGeneratedAttribute]
public string get_ChangeAttribute();
}
[AttributeUsageAttribute("128")]
public class Microsoft.AspNetCore.Components.CascadingParameterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.CascadingParameterState : ValueType {
    private static ConcurrentDictionary`2<Type, ReflectedCascadingParameterInfo[]> _cachedInfos;
    [CompilerGeneratedAttribute]
private string <LocalValueName>k__BackingField;
    [CompilerGeneratedAttribute]
private ICascadingValueComponent <ValueSupplier>k__BackingField;
    public string LocalValueName { get; }
    public ICascadingValueComponent ValueSupplier { get; }
    public CascadingParameterState(string localValueName, ICascadingValueComponent valueSupplier);
    private static CascadingParameterState();
    [CompilerGeneratedAttribute]
public string get_LocalValueName();
    [CompilerGeneratedAttribute]
public ICascadingValueComponent get_ValueSupplier();
    public static IReadOnlyList`1<CascadingParameterState> FindCascadingParameters(ComponentState componentState);
    private static ICascadingValueComponent GetMatchingCascadingValueSupplier(ReflectedCascadingParameterInfo& info, ComponentState componentState);
    private static ReflectedCascadingParameterInfo[] GetReflectedCascadingParameterInfos(Type componentType);
    private static ReflectedCascadingParameterInfo[] CreateReflectedCascadingParameterInfos(Type componentType);
}
public class Microsoft.AspNetCore.Components.CascadingValue`1 : object {
    private RenderHandle _renderHandle;
    private HashSet`1<ComponentState> _subscribers;
    private bool _hasSetParametersPreviously;
    [CompilerGeneratedAttribute]
private RenderFragment <ChildContent>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFixed>k__BackingField;
    [ParameterAttribute]
public RenderFragment ChildContent { get; public set; }
    [ParameterAttribute]
public TValue Value { get; public set; }
    [ParameterAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
public bool IsFixed { get; public set; }
    private object Microsoft.AspNetCore.Components.ICascadingValueComponent.CurrentValue { get; }
    private bool Microsoft.AspNetCore.Components.ICascadingValueComponent.CurrentValueIsFixed { get; }
    [CompilerGeneratedAttribute]
public RenderFragment get_ChildContent();
    [CompilerGeneratedAttribute]
public void set_ChildContent(RenderFragment value);
    [CompilerGeneratedAttribute]
public TValue get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(TValue value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsFixed();
    [CompilerGeneratedAttribute]
public void set_IsFixed(bool value);
    private sealed virtual override object Microsoft.AspNetCore.Components.ICascadingValueComponent.get_CurrentValue();
    private sealed virtual override bool Microsoft.AspNetCore.Components.ICascadingValueComponent.get_CurrentValueIsFixed();
    public sealed virtual void Attach(RenderHandle renderHandle);
    public sealed virtual Task SetParametersAsync(ParameterView parameters);
    private sealed virtual override bool Microsoft.AspNetCore.Components.ICascadingValueComponent.CanSupplyValue(Type requestedType, string requestedName);
    private sealed virtual override void Microsoft.AspNetCore.Components.ICascadingValueComponent.Subscribe(ComponentState subscriber);
    private sealed virtual override void Microsoft.AspNetCore.Components.ICascadingValueComponent.Unsubscribe(ComponentState subscriber);
    private void NotifySubscribers(ParameterViewLifetime& lifetime);
    private void Render(RenderTreeBuilder builder);
}
internal class Microsoft.AspNetCore.Components.ChangeDetection : object {
    public static bool MayHaveChanged(T1 oldValue, T2 newValue);
    private static bool IsKnownImmutableType(Type type);
}
public class Microsoft.AspNetCore.Components.ChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; public set; }
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
public static class Microsoft.AspNetCore.Components.CompilerServices.RuntimeHelpers : object {
    public static T TypeCheck(T value);
    public static EventCallback`1<T> CreateInferredEventCallback(object receiver, Action`1<T> callback, T value);
    public static EventCallback`1<T> CreateInferredEventCallback(object receiver, Func`2<T, Task> callback, T value);
}
public abstract class Microsoft.AspNetCore.Components.ComponentBase : object {
    private RenderFragment _renderFragment;
    private RenderHandle _renderHandle;
    private bool _initialized;
    private bool _hasNeverRendered;
    private bool _hasPendingQueuedRender;
    private bool _hasCalledOnAfterRender;
    protected virtual void BuildRenderTree(RenderTreeBuilder builder);
    protected virtual void OnInitialized();
    protected virtual Task OnInitializedAsync();
    protected virtual void OnParametersSet();
    protected virtual Task OnParametersSetAsync();
    protected void StateHasChanged();
    protected virtual bool ShouldRender();
    protected virtual void OnAfterRender(bool firstRender);
    protected virtual Task OnAfterRenderAsync(bool firstRender);
    protected Task InvokeAsync(Action workItem);
    protected Task InvokeAsync(Func`1<Task> workItem);
    private sealed virtual override void Microsoft.AspNetCore.Components.IComponent.Attach(RenderHandle renderHandle);
    public virtual Task SetParametersAsync(ParameterView parameters);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.ComponentBase/<RunInitAndSetParametersAsync>d__20")]
private Task RunInitAndSetParametersAsync();
    private Task CallOnParametersSetAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.ComponentBase/<CallStateHasChangedOnAsyncCompletion>d__22")]
private Task CallStateHasChangedOnAsyncCompletion(Task task);
    private sealed virtual override Task Microsoft.AspNetCore.Components.IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, object arg);
    private sealed virtual override Task Microsoft.AspNetCore.Components.IHandleAfterRender.OnAfterRenderAsync();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0(RenderTreeBuilder builder);
}
internal class Microsoft.AspNetCore.Components.ComponentFactory : object {
    private static BindingFlags _injectablePropertyBindingFlags;
    private ConcurrentDictionary`2<Type, Action`2<IServiceProvider, IComponent>> _cachedInitializers;
    public static ComponentFactory Instance;
    private static ComponentFactory();
    public IComponent InstantiateComponent(IServiceProvider serviceProvider, Type componentType);
    private void PerformPropertyInjection(IServiceProvider serviceProvider, IComponent instance);
    private Action`2<IServiceProvider, IComponent> CreateInitializer(Type type);
}
public abstract class Microsoft.AspNetCore.Components.Dispatcher : object {
    [CompilerGeneratedAttribute]
private UnhandledExceptionEventHandler UnhandledException;
    public static Dispatcher CreateDefault();
    [CompilerGeneratedAttribute]
internal void add_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public void AssertAccess();
    public abstract virtual bool CheckAccess();
    public abstract virtual Task InvokeAsync(Action workItem);
    public abstract virtual Task InvokeAsync(Func`1<Task> workItem);
    public abstract virtual Task`1<TResult> InvokeAsync(Func`1<TResult> workItem);
    public abstract virtual Task`1<TResult> InvokeAsync(Func`1<Task`1<TResult>> workItem);
    protected void OnUnhandledException(UnhandledExceptionEventArgs e);
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.ElementReference : ValueType {
    private static long _nextIdForWebAssemblyOnly;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; }
    public ElementReference(string id);
    private static ElementReference();
    [CompilerGeneratedAttribute]
public string get_Id();
    internal static ElementReference CreateWithUniqueId();
    private static string CreateUniqueId();
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.EventCallback : ValueType {
    public static EventCallbackFactory Factory;
    public static EventCallback Empty;
    internal MulticastDelegate Delegate;
    internal IHandleEvent Receiver;
    public bool HasDelegate { get; }
    internal bool RequiresExplicitReceiver { get; }
    public EventCallback(IHandleEvent receiver, MulticastDelegate delegate);
    private static EventCallback();
    public sealed virtual bool get_HasDelegate();
    internal bool get_RequiresExplicitReceiver();
    public Task InvokeAsync(object arg);
    private sealed virtual override object Microsoft.AspNetCore.Components.IEventCallback.UnpackForRenderTree();
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.EventCallback`1 : ValueType {
    public static EventCallback`1<TValue> Empty;
    internal MulticastDelegate Delegate;
    internal IHandleEvent Receiver;
    public bool HasDelegate { get; }
    internal bool RequiresExplicitReceiver { get; }
    public EventCallback`1(IHandleEvent receiver, MulticastDelegate delegate);
    private static EventCallback`1();
    public sealed virtual bool get_HasDelegate();
    internal bool get_RequiresExplicitReceiver();
    public Task InvokeAsync(TValue arg);
    internal EventCallback AsUntyped();
    private sealed virtual override object Microsoft.AspNetCore.Components.IEventCallback.UnpackForRenderTree();
}
public class Microsoft.AspNetCore.Components.EventCallbackFactory : object {
    [EditorBrowsableAttribute("1")]
public EventCallback Create(object receiver, EventCallback callback);
    public EventCallback Create(object receiver, Action callback);
    public EventCallback Create(object receiver, Action`1<object> callback);
    public EventCallback Create(object receiver, Func`1<Task> callback);
    public EventCallback Create(object receiver, Func`2<object, Task> callback);
    [EditorBrowsableAttribute("1")]
public EventCallback`1<TValue> Create(object receiver, EventCallback callback);
    [EditorBrowsableAttribute("1")]
public EventCallback`1<TValue> Create(object receiver, EventCallback`1<TValue> callback);
    public EventCallback`1<TValue> Create(object receiver, Action callback);
    public EventCallback`1<TValue> Create(object receiver, Action`1<TValue> callback);
    public EventCallback`1<TValue> Create(object receiver, Func`1<Task> callback);
    public EventCallback`1<TValue> Create(object receiver, Func`2<TValue, Task> callback);
    [EditorBrowsableAttribute("1")]
public EventCallback`1<TValue> CreateInferred(object receiver, Action`1<TValue> callback, TValue value);
    [EditorBrowsableAttribute("1")]
public EventCallback`1<TValue> CreateInferred(object receiver, Func`2<TValue, Task> callback, TValue value);
    private EventCallback CreateCore(object receiver, MulticastDelegate callback);
    private EventCallback`1<TValue> CreateCore(object receiver, MulticastDelegate callback);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions : object {
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<string> setter, string existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<bool> setter, bool existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<Nullable`1<bool>> setter, Nullable`1<bool> existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<int> setter, int existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<Nullable`1<int>> setter, Nullable`1<int> existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<long> setter, long existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<Nullable`1<long>> setter, Nullable`1<long> existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<float> setter, float existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<Nullable`1<float>> setter, Nullable`1<float> existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<double> setter, double existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<Nullable`1<double>> setter, Nullable`1<double> existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<decimal> setter, decimal existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<Nullable`1<decimal>> setter, Nullable`1<decimal> existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<DateTime> setter, DateTime existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<DateTime> setter, DateTime existingValue, string format, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<Nullable`1<DateTime>> setter, Nullable`1<DateTime> existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<Nullable`1<DateTime>> setter, Nullable`1<DateTime> existingValue, string format, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<DateTimeOffset> setter, DateTimeOffset existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<DateTimeOffset> setter, DateTimeOffset existingValue, string format, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<Nullable`1<DateTimeOffset>> setter, Nullable`1<DateTimeOffset> existingValue, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<Nullable`1<DateTimeOffset>> setter, Nullable`1<DateTimeOffset> existingValue, string format, CultureInfo culture);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> CreateBinder(EventCallbackFactory factory, object receiver, Action`1<T> setter, T existingValue, CultureInfo culture);
    [ExtensionAttribute]
private static EventCallback`1<ChangeEventArgs> CreateBinderCore(EventCallbackFactory factory, object receiver, Action`1<T> setter, CultureInfo culture, BindParser`1<T> converter);
    [ExtensionAttribute]
private static EventCallback`1<ChangeEventArgs> CreateBinderCore(EventCallbackFactory factory, object receiver, Action`1<T> setter, CultureInfo culture, string format, BindParserWithFormat`1<T> converter);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Components.EventCallbackFactoryEventArgsExtensions : object {
    [ExtensionAttribute]
public static EventCallback`1<EventArgs> Create(EventCallbackFactory factory, object receiver, Action`1<EventArgs> callback);
    [ExtensionAttribute]
public static EventCallback`1<EventArgs> Create(EventCallbackFactory factory, object receiver, Func`2<EventArgs, Task> callback);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> Create(EventCallbackFactory factory, object receiver, Action`1<ChangeEventArgs> callback);
    [ExtensionAttribute]
public static EventCallback`1<ChangeEventArgs> Create(EventCallbackFactory factory, object receiver, Func`2<ChangeEventArgs, Task> callback);
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.EventCallbackWorkItem : ValueType {
    public static EventCallbackWorkItem Empty;
    private MulticastDelegate _delegate;
    public EventCallbackWorkItem(MulticastDelegate delegate);
    private static EventCallbackWorkItem();
    public Task InvokeAsync(object arg);
    internal static Task InvokeAsync(MulticastDelegate delegate, T arg);
}
[AttributeUsageAttribute("4")]
public class Microsoft.AspNetCore.Components.EventHandlerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AttributeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EventArgsType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableStopPropagation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePreventDefault>k__BackingField;
    public string AttributeName { get; }
    public Type EventArgsType { get; }
    public bool EnableStopPropagation { get; }
    public bool EnablePreventDefault { get; }
    public EventHandlerAttribute(string attributeName, Type eventArgsType);
    public EventHandlerAttribute(string attributeName, Type eventArgsType, bool enableStopPropagation, bool enablePreventDefault);
    [CompilerGeneratedAttribute]
public string get_AttributeName();
    [CompilerGeneratedAttribute]
public Type get_EventArgsType();
    [CompilerGeneratedAttribute]
public bool get_EnableStopPropagation();
    [CompilerGeneratedAttribute]
public bool get_EnablePreventDefault();
}
internal interface Microsoft.AspNetCore.Components.ICascadingValueComponent {
    public object CurrentValue { get; }
    public bool CurrentValueIsFixed { get; }
    public abstract virtual bool CanSupplyValue(Type valueType, string valueName);
    public abstract virtual object get_CurrentValue();
    public abstract virtual bool get_CurrentValueIsFixed();
    public abstract virtual void Subscribe(ComponentState subscriber);
    public abstract virtual void Unsubscribe(ComponentState subscriber);
}
public interface Microsoft.AspNetCore.Components.IComponent {
    public abstract virtual void Attach(RenderHandle renderHandle);
    public abstract virtual Task SetParametersAsync(ParameterView parameters);
}
internal interface Microsoft.AspNetCore.Components.IEventCallback {
    public bool HasDelegate { get; }
    public abstract virtual bool get_HasDelegate();
    public abstract virtual object UnpackForRenderTree();
}
public interface Microsoft.AspNetCore.Components.IHandleAfterRender {
    public abstract virtual Task OnAfterRenderAsync();
}
public interface Microsoft.AspNetCore.Components.IHandleEvent {
    public abstract virtual Task HandleEventAsync(EventCallbackWorkItem item, object arg);
}
[AttributeUsageAttribute("128")]
public class Microsoft.AspNetCore.Components.InjectAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class Microsoft.AspNetCore.Components.LayoutAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <LayoutType>k__BackingField;
    public Type LayoutType { get; private set; }
    public LayoutAttribute(Type layoutType);
    [CompilerGeneratedAttribute]
public Type get_LayoutType();
    [CompilerGeneratedAttribute]
private void set_LayoutType(Type value);
}
public abstract class Microsoft.AspNetCore.Components.LayoutComponentBase : ComponentBase {
    internal static string BodyPropertyName;
    [CompilerGeneratedAttribute]
private RenderFragment <Body>k__BackingField;
    [ParameterAttribute]
public RenderFragment Body { get; public set; }
    [CompilerGeneratedAttribute]
public RenderFragment get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(RenderFragment value);
}
public class Microsoft.AspNetCore.Components.LayoutView : object {
    private static RenderFragment EmptyRenderFragment;
    private RenderHandle _renderHandle;
    [CompilerGeneratedAttribute]
private RenderFragment <ChildContent>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Layout>k__BackingField;
    [ParameterAttribute]
public RenderFragment ChildContent { get; public set; }
    [ParameterAttribute]
public Type Layout { get; public set; }
    private static LayoutView();
    [CompilerGeneratedAttribute]
public RenderFragment get_ChildContent();
    [CompilerGeneratedAttribute]
public void set_ChildContent(RenderFragment value);
    [CompilerGeneratedAttribute]
public Type get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(Type value);
    public sealed virtual void Attach(RenderHandle renderHandle);
    public sealed virtual Task SetParametersAsync(ParameterView parameters);
    private void Render();
    private static RenderFragment WrapInLayout(Type layoutType, RenderFragment bodyParam);
    private static Type GetParentLayoutType(Type type);
}
public class Microsoft.AspNetCore.Components.LocationChangeException : Exception {
    public LocationChangeException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.MarkupString : ValueType {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public MarkupString(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public static MarkupString op_Explicit(string value);
    public virtual string ToString();
}
public class Microsoft.AspNetCore.Components.NavigationException : Exception {
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    public string Location { get; }
    public NavigationException(string uri);
    [CompilerGeneratedAttribute]
public string get_Location();
}
public abstract class Microsoft.AspNetCore.Components.NavigationManager : object {
    private EventHandler`1<LocationChangedEventArgs> _locationChanged;
    private Uri _baseUri;
    private string _uri;
    private bool _isInitialized;
    public string BaseUri { get; protected set; }
    public string Uri { get; protected set; }
    public void add_LocationChanged(EventHandler`1<LocationChangedEventArgs> value);
    public void remove_LocationChanged(EventHandler`1<LocationChangedEventArgs> value);
    public string get_BaseUri();
    protected void set_BaseUri(string value);
    public string get_Uri();
    protected void set_Uri(string value);
    public void NavigateTo(string uri, bool forceLoad);
    protected abstract virtual void NavigateToCore(string uri, bool forceLoad);
    protected void Initialize(string baseUri, string uri);
    protected virtual void EnsureInitialized();
    public Uri ToAbsoluteUri(string relativeUri);
    public string ToBaseRelativePath(string uri);
    internal static string NormalizeBaseUri(string baseUri);
    protected void NotifyLocationChanged(bool isInterceptedLink);
    private void AssertInitialized();
    private static bool TryGetLengthOfBaseUriPrefix(Uri baseUri, string uri, Int32& length);
    private static void Validate(Uri baseUri, string uri);
}
public abstract class Microsoft.AspNetCore.Components.OwningComponentBase : ComponentBase {
    private IServiceScope _scope;
    [CompilerGeneratedAttribute]
private IServiceScopeFactory <ScopeFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [InjectAttribute]
private IServiceScopeFactory ScopeFactory { get; private set; }
    protected bool IsDisposed { get; private set; }
    protected IServiceProvider ScopedServices { get; }
    [CompilerGeneratedAttribute]
private IServiceScopeFactory get_ScopeFactory();
    [CompilerGeneratedAttribute]
private void set_ScopeFactory(IServiceScopeFactory value);
    [CompilerGeneratedAttribute]
protected bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    protected IServiceProvider get_ScopedServices();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
}
public abstract class Microsoft.AspNetCore.Components.OwningComponentBase`1 : OwningComponentBase {
    private TService _item;
    protected TService Service { get; }
    protected TService get_Service();
}
[AttributeUsageAttribute("128")]
public class Microsoft.AspNetCore.Components.ParameterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <CaptureUnmatchedValues>k__BackingField;
    public bool CaptureUnmatchedValues { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CaptureUnmatchedValues();
    [CompilerGeneratedAttribute]
public void set_CaptureUnmatchedValues(bool value);
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.ParameterValue : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cascading>k__BackingField;
    public string Name { get; }
    public object Value { get; }
    public bool Cascading { get; }
    internal ParameterValue(string name, object value, bool cascading);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public bool get_Cascading();
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.ParameterView : ValueType {
    private static string GeneratedParameterViewElementName;
    private static RenderTreeFrame[] _emptyFrames;
    private static ParameterView _empty;
    private ParameterViewLifetime _lifetime;
    private RenderTreeFrame[] _frames;
    private int _ownerIndex;
    private IReadOnlyList`1<CascadingParameterState> _cascadingParametersOrNull;
    public static ParameterView Empty { get; }
    internal ParameterViewLifetime Lifetime { get; }
    internal ParameterView(ParameterViewLifetime& lifetime, RenderTreeFrame[] frames, int ownerIndex);
    private ParameterView(ParameterViewLifetime& lifetime, RenderTreeFrame[] frames, int ownerIndex, IReadOnlyList`1<CascadingParameterState> cascadingParametersOrNull);
    private static ParameterView();
    public static ParameterView get_Empty();
    internal ParameterViewLifetime get_Lifetime();
    public Enumerator GetEnumerator();
    public bool TryGetValue(string parameterName, TValue& result);
    public TValue GetValueOrDefault(string parameterName);
    public TValue GetValueOrDefault(string parameterName, TValue defaultValue);
    public IReadOnlyDictionary`2<string, object> ToDictionary();
    internal ParameterView WithCascadingParameters(IReadOnlyList`1<CascadingParameterState> cascadingParameters);
    internal bool DefinitelyEquals(ParameterView oldParameters);
    internal void CaptureSnapshot(ArrayBuilder`1<RenderTreeFrame> builder);
    public static ParameterView FromDictionary(IDictionary`2<string, object> parameters);
    public void SetParameterProperties(object target);
}
internal static class Microsoft.AspNetCore.Components.PlatformInfo : object {
    [CompilerGeneratedAttribute]
private static bool <IsWebAssembly>k__BackingField;
    public static bool IsWebAssembly { get; }
    private static PlatformInfo();
    [CompilerGeneratedAttribute]
public static bool get_IsWebAssembly();
}
internal static class Microsoft.AspNetCore.Components.Reflection.ComponentProperties : object {
    private static BindingFlags _bindablePropertyFlags;
    private static ConcurrentDictionary`2<Type, WritersForType> _cachedWritersByType;
    private static ComponentProperties();
    public static void SetProperties(ParameterView& parameters, object target);
    internal static IEnumerable`1<PropertyInfo> GetCandidateBindableProperties(Type targetType);
    private static void ThrowForUnknownIncomingParameterName(Type targetType, string parameterName);
    private static void ThrowForSettingCascadingParameterWithNonCascadingValue(Type targetType, string parameterName);
    private static void ThrowForSettingParameterWithCascadingValue(Type targetType, string parameterName);
    private static void ThrowForCaptureUnmatchedValuesConflict(Type targetType, string parameterName, Dictionary`2<string, object> unmatched);
    private static void ThrowForMultipleCaptureUnmatchedValuesParameters(Type targetType);
    private static void ThrowForInvalidCaptureUnmatchedValuesParameterType(Type targetType, PropertyInfo propertyInfo);
    [CompilerGeneratedAttribute]
internal static void <SetProperties>g__SetProperty|2_0(object target, IPropertySetter writer, string parameterName, object value);
}
internal interface Microsoft.AspNetCore.Components.Reflection.IPropertySetter {
    public bool Cascading { get; }
    public abstract virtual bool get_Cascading();
    public abstract virtual void SetValue(object target, object value);
}
internal class Microsoft.AspNetCore.Components.Reflection.MemberAssignment : object {
    public static IEnumerable`1<PropertyInfo> GetPropertiesIncludingInherited(Type type, BindingFlags bindingFlags);
    public static IPropertySetter CreatePropertySetter(Type targetType, PropertyInfo property, bool cascading);
}
public class Microsoft.AspNetCore.Components.RenderFragment : MulticastDelegate {
    public RenderFragment(object object, IntPtr method);
    public virtual void Invoke(RenderTreeBuilder builder);
    public virtual IAsyncResult BeginInvoke(RenderTreeBuilder builder, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.AspNetCore.Components.RenderFragment`1 : MulticastDelegate {
    public RenderFragment`1(object object, IntPtr method);
    public virtual RenderFragment Invoke(TValue value);
    public virtual IAsyncResult BeginInvoke(TValue value, AsyncCallback callback, object object);
    public virtual RenderFragment EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.RenderHandle : ValueType {
    private Renderer _renderer;
    private int _componentId;
    public Dispatcher Dispatcher { get; }
    public bool IsInitialized { get; }
    internal RenderHandle(Renderer renderer, int componentId);
    public Dispatcher get_Dispatcher();
    public bool get_IsInitialized();
    public void Render(RenderFragment renderFragment);
    private static void ThrowNotInitialized();
}
internal class Microsoft.AspNetCore.Components.Rendering.ComponentState : object {
    private Renderer _renderer;
    private IReadOnlyList`1<CascadingParameterState> _cascadingParameters;
    private bool _hasAnyCascadingParameterSubscriptions;
    private RenderTreeBuilder _renderTreeBuilderPrevious;
    private ArrayBuilder`1<RenderTreeFrame> _latestDirectParametersSnapshot;
    private bool _componentWasDisposed;
    [CompilerGeneratedAttribute]
private int <ComponentId>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponent <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private ComponentState <ParentComponentState>k__BackingField;
    [CompilerGeneratedAttribute]
private RenderTreeBuilder <CurrentRenderTree>k__BackingField;
    public int ComponentId { get; }
    public IComponent Component { get; }
    public ComponentState ParentComponentState { get; }
    public RenderTreeBuilder CurrentRenderTree { get; private set; }
    public ComponentState(Renderer renderer, int componentId, IComponent component, ComponentState parentComponentState);
    [CompilerGeneratedAttribute]
public int get_ComponentId();
    [CompilerGeneratedAttribute]
public IComponent get_Component();
    [CompilerGeneratedAttribute]
public ComponentState get_ParentComponentState();
    [CompilerGeneratedAttribute]
public RenderTreeBuilder get_CurrentRenderTree();
    [CompilerGeneratedAttribute]
private void set_CurrentRenderTree(RenderTreeBuilder value);
    public void RenderIntoBatch(RenderBatchBuilder batchBuilder, RenderFragment renderFragment);
    public bool TryDisposeInBatch(RenderBatchBuilder batchBuilder, Exception& exception);
    public Task NotifyRenderCompletedAsync();
    public void SetDirectParameters(ParameterView parameters);
    public void NotifyCascadingValueChanged(ParameterViewLifetime& lifetime);
    private bool AddCascadingParameterSubscriptions();
    private void RemoveCascadingParameterSubscriptions();
    public sealed virtual void Dispose();
    private void DisposeBuffers();
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.Rendering.KeyedItemInfo : ValueType {
    public int OldIndex;
    public int NewIndex;
    public int OldSiblingIndex;
    public int NewSiblingIndex;
    public KeyedItemInfo(int oldIndex, int newIndex);
    private KeyedItemInfo(KeyedItemInfo& copyFrom, int oldSiblingIndex, int newSiblingIndex);
    public KeyedItemInfo WithOldSiblingIndex(int oldSiblingIndex);
    public KeyedItemInfo WithNewSiblingIndex(int newSiblingIndex);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.Rendering.ParameterViewLifetime : ValueType {
    private RenderBatchBuilder _owner;
    private int _stamp;
    public static ParameterViewLifetime Unbound;
    public ParameterViewLifetime(RenderBatchBuilder owner);
    private static ParameterViewLifetime();
    public void AssertNotExpired();
}
internal class Microsoft.AspNetCore.Components.Rendering.RenderBatchBuilder : object {
    private int _parameterViewValidityStamp;
    [CompilerGeneratedAttribute]
private ArrayBuilder`1<RenderTreeDiff> <UpdatedComponentDiffs>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayBuilder`1<int> <DisposedComponentIds>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayBuilder`1<ulong> <DisposedEventHandlerIds>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayBuilder`1<RenderTreeEdit> <EditsBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayBuilder`1<RenderTreeFrame> <ReferenceFramesBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private Queue`1<RenderQueueEntry> <ComponentRenderQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private Queue`1<int> <ComponentDisposalQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, int> <AttributeDiffSet>k__BackingField;
    [CompilerGeneratedAttribute]
private StackObjectPool`1<Dictionary`2<object, KeyedItemInfo>> <KeyedItemInfoDictionaryPool>k__BackingField;
    public ArrayBuilder`1<RenderTreeDiff> UpdatedComponentDiffs { get; }
    public ArrayBuilder`1<int> DisposedComponentIds { get; }
    public ArrayBuilder`1<ulong> DisposedEventHandlerIds { get; }
    public ArrayBuilder`1<RenderTreeEdit> EditsBuffer { get; }
    public ArrayBuilder`1<RenderTreeFrame> ReferenceFramesBuffer { get; }
    public Queue`1<RenderQueueEntry> ComponentRenderQueue { get; }
    public Queue`1<int> ComponentDisposalQueue { get; }
    public Dictionary`2<string, int> AttributeDiffSet { get; }
    public int ParameterViewValidityStamp { get; }
    internal StackObjectPool`1<Dictionary`2<object, KeyedItemInfo>> KeyedItemInfoDictionaryPool { get; }
    [CompilerGeneratedAttribute]
public ArrayBuilder`1<RenderTreeDiff> get_UpdatedComponentDiffs();
    [CompilerGeneratedAttribute]
public ArrayBuilder`1<int> get_DisposedComponentIds();
    [CompilerGeneratedAttribute]
public ArrayBuilder`1<ulong> get_DisposedEventHandlerIds();
    [CompilerGeneratedAttribute]
public ArrayBuilder`1<RenderTreeEdit> get_EditsBuffer();
    [CompilerGeneratedAttribute]
public ArrayBuilder`1<RenderTreeFrame> get_ReferenceFramesBuffer();
    [CompilerGeneratedAttribute]
public Queue`1<RenderQueueEntry> get_ComponentRenderQueue();
    [CompilerGeneratedAttribute]
public Queue`1<int> get_ComponentDisposalQueue();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, int> get_AttributeDiffSet();
    public int get_ParameterViewValidityStamp();
    [CompilerGeneratedAttribute]
internal StackObjectPool`1<Dictionary`2<object, KeyedItemInfo>> get_KeyedItemInfoDictionaryPool();
    public void ClearStateForCurrentBatch();
    public RenderBatch ToBatch();
    public void InvalidateParameterViews();
    public sealed virtual void Dispose();
}
[DebuggerDisplayAttribute("{_state,nq}")]
internal class Microsoft.AspNetCore.Components.Rendering.RendererSynchronizationContext : SynchronizationContext {
    private static ContextCallback ExecutionContextThunk;
    private static Action`2<Task, object> BackgroundWorkThunk;
    private State _state;
    [CompilerGeneratedAttribute]
private UnhandledExceptionEventHandler UnhandledException;
    private RendererSynchronizationContext(State state);
    private static RendererSynchronizationContext();
    [CompilerGeneratedAttribute]
public void add_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public Task InvokeAsync(Action action);
    public Task InvokeAsync(Func`1<Task> asyncAction);
    public Task`1<TResult> InvokeAsync(Func`1<TResult> function);
    public Task`1<TResult> InvokeAsync(Func`1<Task`1<TResult>> asyncFunction);
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual SynchronizationContext CreateCopy();
    private void ExecuteSynchronouslyIfPossible(SendOrPostCallback d, object state);
    private Task Enqueue(Task antecedant, SendOrPostCallback d, object state, bool forceAsync);
    private void ExecuteSynchronously(TaskCompletionSource`1<object> completion, SendOrPostCallback d, object state);
    private void ExecuteBackground(WorkItem item);
    private void DispatchException(Exception ex);
}
internal class Microsoft.AspNetCore.Components.Rendering.RendererSynchronizationContextDispatcher : Dispatcher {
    private RendererSynchronizationContext _context;
    public virtual bool CheckAccess();
    public virtual Task InvokeAsync(Action workItem);
    public virtual Task InvokeAsync(Func`1<Task> workItem);
    public virtual Task`1<TResult> InvokeAsync(Func`1<TResult> workItem);
    public virtual Task`1<TResult> InvokeAsync(Func`1<Task`1<TResult>> workItem);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(object sender, UnhandledExceptionEventArgs e);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.Rendering.RenderQueueEntry : ValueType {
    public ComponentState ComponentState;
    public RenderFragment RenderFragment;
    public RenderQueueEntry(ComponentState componentState, RenderFragment renderFragment);
}
public class Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder : object {
    private static object BoxedTrue;
    private static object BoxedFalse;
    private static string ComponentReferenceCaptureInvalidParentMessage;
    private ArrayBuilder`1<RenderTreeFrame> _entries;
    private Stack`1<int> _openElementIndices;
    private Nullable`1<RenderTreeFrameType> _lastNonAttributeFrameType;
    private bool _hasSeenAddMultipleAttributes;
    private Dictionary`2<string, int> _seenAttributeNames;
    private static string ChildContent;
    private static RenderTreeBuilder();
    public void OpenElement(int sequence, string elementName);
    public void CloseElement();
    public void AddMarkupContent(int sequence, string markupContent);
    public void AddContent(int sequence, string textContent);
    public void AddContent(int sequence, RenderFragment fragment);
    public void AddContent(int sequence, RenderFragment`1<TValue> fragment, TValue value);
    public void AddContent(int sequence, MarkupString markupContent);
    public void AddContent(int sequence, object textContent);
    public void AddAttribute(int sequence, string name, bool value);
    public void AddAttribute(int sequence, string name, string value);
    public void AddAttribute(int sequence, string name, MulticastDelegate value);
    public void AddAttribute(int sequence, string name, EventCallback value);
    public void AddAttribute(int sequence, string name, EventCallback`1<TArgument> value);
    public void AddAttribute(int sequence, string name, object value);
    public void AddAttribute(int sequence, RenderTreeFrame& frame);
    public void AddMultipleAttributes(int sequence, IEnumerable`1<KeyValuePair`2<string, object>> attributes);
    public void SetUpdatesAttributeName(string updatesAttributeName);
    public void OpenComponent(int sequence);
    public void OpenComponent(int sequence, Type componentType);
    public void SetKey(object value);
    private void OpenComponentUnchecked(int sequence, Type componentType);
    public void CloseComponent();
    public void AddElementReferenceCapture(int sequence, Action`1<ElementReference> elementReferenceCaptureAction);
    public void AddComponentReferenceCapture(int sequence, Action`1<object> componentReferenceCaptureAction);
    public void OpenRegion(int sequence);
    public void CloseRegion();
    private void AssertCanAddAttribute();
    private Nullable`1<int> GetCurrentParentFrameIndex();
    private Nullable`1<RenderTreeFrameType> GetCurrentParentFrameType();
    public void Clear();
    internal void InsertAttributeExpensive(int insertAtIndex, int sequence, string attributeName, object attributeValue);
    public ArrayRange`1<RenderTreeFrame> GetFrames();
    private void Append(RenderTreeFrame& frame);
    internal void ProcessDuplicateAttributes(int first);
    internal void TrackAttributeName(string name);
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class Microsoft.AspNetCore.Components.Rendering.RenderTreeUpdater : object {
    public static void UpdateToMatchClientState(RenderTreeBuilder renderTreeBuilder, ulong eventHandlerId, object newFieldValue);
    private static void UpdateFrameToMatchClientState(RenderTreeBuilder renderTreeBuilder, RenderTreeFrame[] framesArray, int elementFrameIndex, string attributeName, object attributeValue);
}
internal class Microsoft.AspNetCore.Components.RenderTree.ArrayBuilder`1 : object {
    private T[] _items;
    private int _itemsInUse;
    private static T[] Empty;
    private ArrayPool`1<T> _arrayPool;
    private int _minCapacity;
    private bool _disposed;
    public int Count { get; }
    public T[] Buffer { get; }
    public ArrayBuilder`1(int minCapacity, ArrayPool`1<T> arrayPool);
    private static ArrayBuilder`1();
    public int get_Count();
    public T[] get_Buffer();
    public int Append(T& item);
    internal int Append(T[] source, int startIndex, int length);
    public void Overwrite(int index, T& value);
    public void RemoveLast();
    public void InsertExpensive(int index, T value);
    public void Clear();
    private void GrowBuffer(int desiredCapacity);
    private void ReturnBuffer();
    public sealed virtual void Dispose();
    private static void ThrowIndexOutOfBoundsException();
    private static void ThrowObjectDisposedException();
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Components.RenderTree.ArrayBuilderExtensions : object {
    [ExtensionAttribute]
public static ArrayRange`1<T> ToRange(ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
public static ArrayBuilderSegment`1<T> ToSegment(ArrayBuilder`1<T> builder, int fromIndexInclusive, int toIndexExclusive);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Microsoft.AspNetCore.Components.RenderTree.ArrayBuilderSegment`1 : ValueType {
    private ArrayBuilder`1<T> _builder;
    private int _offset;
    private int _count;
    public T[] Array { get; }
    public int Offset { get; }
    public int Count { get; }
    public T Item { get; }
    internal ArrayBuilderSegment`1(ArrayBuilder`1<T> builder, int offset, int count);
    public T[] get_Array();
    public int get_Offset();
    public int get_Count();
    public T get_Item(int index);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.RenderTree.ArrayRange`1 : ValueType {
    public T[] Array;
    public int Count;
    public ArrayRange`1(T[] array, int count);
    public ArrayRange`1<T> Clone();
}
public class Microsoft.AspNetCore.Components.RenderTree.EventFieldInfo : object {
    [CompilerGeneratedAttribute]
private int <ComponentId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <FieldValue>k__BackingField;
    public int ComponentId { get; public set; }
    public object FieldValue { get; public set; }
    [CompilerGeneratedAttribute]
public int get_ComponentId();
    [CompilerGeneratedAttribute]
public void set_ComponentId(int value);
    [CompilerGeneratedAttribute]
public object get_FieldValue();
    [CompilerGeneratedAttribute]
public void set_FieldValue(object value);
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.RenderTree.RenderBatch : ValueType {
    [CompilerGeneratedAttribute]
private ArrayRange`1<RenderTreeDiff> <UpdatedComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayRange`1<RenderTreeFrame> <ReferenceFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayRange`1<int> <DisposedComponentIDs>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayRange`1<ulong> <DisposedEventHandlerIDs>k__BackingField;
    public ArrayRange`1<RenderTreeDiff> UpdatedComponents { get; }
    public ArrayRange`1<RenderTreeFrame> ReferenceFrames { get; }
    public ArrayRange`1<int> DisposedComponentIDs { get; }
    public ArrayRange`1<ulong> DisposedEventHandlerIDs { get; }
    internal RenderBatch(ArrayRange`1<RenderTreeDiff> updatedComponents, ArrayRange`1<RenderTreeFrame> referenceFrames, ArrayRange`1<int> disposedComponentIDs, ArrayRange`1<ulong> disposedEventHandlerIDs);
    [CompilerGeneratedAttribute]
public ArrayRange`1<RenderTreeDiff> get_UpdatedComponents();
    [CompilerGeneratedAttribute]
public ArrayRange`1<RenderTreeFrame> get_ReferenceFrames();
    [CompilerGeneratedAttribute]
public ArrayRange`1<int> get_DisposedComponentIDs();
    [CompilerGeneratedAttribute]
public ArrayRange`1<ulong> get_DisposedEventHandlerIDs();
}
public abstract class Microsoft.AspNetCore.Components.RenderTree.Renderer : object {
    private IServiceProvider _serviceProvider;
    private Dictionary`2<int, ComponentState> _componentStateById;
    private RenderBatchBuilder _batchBuilder;
    private Dictionary`2<ulong, EventCallback> _eventBindings;
    private Dictionary`2<ulong, ulong> _eventHandlerIdReplacements;
    private ILogger`1<Renderer> _logger;
    private int _nextComponentId;
    private bool _isBatchInProgress;
    private ulong _lastEventHandlerId;
    private List`1<Task> _pendingTasks;
    private bool _disposed;
    public Dispatcher Dispatcher { get; }
    public Renderer(IServiceProvider serviceProvider, ILoggerFactory loggerFactory);
    public void add_UnhandledSynchronizationException(UnhandledExceptionEventHandler value);
    public void remove_UnhandledSynchronizationException(UnhandledExceptionEventHandler value);
    public abstract virtual Dispatcher get_Dispatcher();
    protected IComponent InstantiateComponent(Type componentType);
    protected internal int AssignRootComponentId(IComponent component);
    protected ArrayRange`1<RenderTreeFrame> GetCurrentRenderTreeFrames(int componentId);
    protected Task RenderRootComponentAsync(int componentId);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.RenderTree.Renderer/<RenderRootComponentAsync>d__21")]
protected Task RenderRootComponentAsync(int componentId, ParameterView initialParameters);
    protected abstract virtual void HandleException(Exception exception);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.RenderTree.Renderer/<ProcessAsynchronousWork>d__23")]
private Task ProcessAsynchronousWork();
    private ComponentState AttachAndInitComponent(IComponent component, int parentComponentId);
    protected abstract virtual Task UpdateDisplayAsync(RenderBatch& modreq(System.Runtime.InteropServices.InAttribute) renderBatch);
    public virtual Task DispatchEventAsync(ulong eventHandlerId, EventFieldInfo fieldInfo, EventArgs eventArgs);
    internal void InstantiateChildComponentOnFrame(RenderTreeFrame& frame, int parentComponentId);
    internal void AddToPendingTasks(Task task);
    internal void AssignEventHandlerId(RenderTreeFrame& frame);
    internal void AddToRenderQueue(int componentId, RenderFragment renderFragment);
    internal void TrackReplacedEventHandlerId(ulong oldEventHandlerId, ulong newEventHandlerId);
    private ulong FindLatestEventHandlerIdInChain(ulong eventHandlerId);
    private ComponentState GetRequiredComponentState(int componentId);
    private ComponentState GetOptionalComponentState(int componentId);
    protected virtual void ProcessPendingRender();
    private void ProcessRenderQueue();
    private Task InvokeRenderCompletedCalls(ArrayRange`1<RenderTreeDiff> updatedComponents, Task updateDisplayTask);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.RenderTree.Renderer/<InvokeRenderCompletedCallsAfterUpdateDisplayTask>d__38")]
private Task InvokeRenderCompletedCallsAfterUpdateDisplayTask(Task updateDisplayTask, Int32[] updatedComponents);
    private void NotifyRenderCompleted(ComponentState state, List`1& batch);
    private void RenderInExistingBatch(RenderQueueEntry renderQueueEntry);
    private void RemoveEventHandlerIds(ArrayRange`1<ulong> eventHandlerIds, Task afterTaskIgnoreErrors);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.RenderTree.Renderer/<GetErrorHandledTask>d__42")]
private Task GetErrorHandledTask(Task taskToHandle);
    private void UpdateRenderTreeToMatchClientState(ulong eventHandlerId, EventFieldInfo fieldInfo);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.RenderTree.Renderer/<<RemoveEventHandlerIds>g__ContinueAfterTask|41_0>d")]
[CompilerGeneratedAttribute]
private Task <RemoveEventHandlerIds>g__ContinueAfterTask|41_0(ArrayRange`1<ulong> eventHandlerIds, Task afterTaskIgnoreErrors);
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.RenderTree.RenderTreeDiff : ValueType {
    public int ComponentId;
    public ArrayBuilderSegment`1<RenderTreeEdit> Edits;
    internal RenderTreeDiff(int componentId, ArrayBuilderSegment`1<RenderTreeEdit> entries);
}
internal static class Microsoft.AspNetCore.Components.RenderTree.RenderTreeDiffBuilder : object {
    public static int SystemAddedAttributeSequenceNumber;
    public static RenderTreeDiff ComputeDiff(Renderer renderer, RenderBatchBuilder batchBuilder, int componentId, ArrayRange`1<RenderTreeFrame> oldTree, ArrayRange`1<RenderTreeFrame> newTree);
    public static void DisposeFrames(RenderBatchBuilder batchBuilder, ArrayRange`1<RenderTreeFrame> frames);
    private static void AppendDiffEntriesForRange(DiffContext& diffContext, int oldStartIndex, int oldEndIndexExcl, int newStartIndex, int newEndIndexExcl);
    private static Dictionary`2<object, KeyedItemInfo> BuildKeyToInfoLookup(DiffContext diffContext, int oldStartIndex, int oldEndIndexExcl, int newStartIndex, int newEndIndexExcl);
    private static void ThrowExceptionForDuplicateKey(object key);
    private static object KeyValue(RenderTreeFrame& frame);
    private static void AppendAttributeDiffEntriesForRange(DiffContext& diffContext, int oldStartIndex, int oldEndIndexExcl, int newStartIndex, int newEndIndexExcl);
    private static void AppendAttributeDiffEntriesForRangeSlow(DiffContext& diffContext, int oldStartIndex, int oldEndIndexExcl, int newStartIndex, int newEndIndexExcl);
    private static void UpdateRetainedChildComponent(DiffContext& diffContext, int oldComponentIndex, int newComponentIndex);
    private static int NextSiblingIndex(RenderTreeFrame& frame, int frameIndex);
    private static void AppendDiffEntriesForFramesWithSameSequence(DiffContext& diffContext, int oldFrameIndex, int newFrameIndex);
    private static void AppendDiffEntriesForAttributeFrame(DiffContext& diffContext, int oldFrameIndex, int newFrameIndex);
    private static void InsertNewFrame(DiffContext& diffContext, int newFrameIndex);
    private static void RemoveOldFrame(DiffContext& diffContext, int oldFrameIndex);
    private static int GetAttributesEndIndexExclusive(RenderTreeFrame[] tree, int rootIndex);
    private static void AppendStepOut(DiffContext& diffContext);
    private static void InitializeNewSubtree(DiffContext& diffContext, int frameIndex);
    private static void InitializeNewComponentFrame(DiffContext& diffContext, int frameIndex);
    private static void InitializeNewAttributeFrame(DiffContext& diffContext, RenderTreeFrame& newFrame);
    private static void InitializeNewElementReferenceCaptureFrame(DiffContext& diffContext, RenderTreeFrame& newFrame);
    private static void InitializeNewComponentReferenceCaptureFrame(DiffContext& diffContext, RenderTreeFrame& newFrame);
    private static void DisposeFramesInRange(RenderBatchBuilder batchBuilder, RenderTreeFrame[] frames, int startIndex, int endIndexExcl);
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.RenderTree.RenderTreeEdit : ValueType {
    public RenderTreeEditType Type;
    public int SiblingIndex;
    public int ReferenceFrameIndex;
    public int MoveToSiblingIndex;
    public string RemovedAttributeName;
    private RenderTreeEdit(RenderTreeEditType type);
    private RenderTreeEdit(RenderTreeEditType type, int siblingIndex);
    private RenderTreeEdit(RenderTreeEditType type, int siblingIndex, int referenceFrameOrMoveToSiblingIndex);
    private RenderTreeEdit(RenderTreeEditType type, int siblingIndex, string removedAttributeName);
    internal static RenderTreeEdit RemoveFrame(int siblingIndex);
    internal static RenderTreeEdit PrependFrame(int siblingIndex, int referenceFrameIndex);
    internal static RenderTreeEdit UpdateText(int siblingIndex, int referenceFrameIndex);
    internal static RenderTreeEdit UpdateMarkup(int siblingIndex, int referenceFrameIndex);
    internal static RenderTreeEdit SetAttribute(int siblingIndex, int referenceFrameIndex);
    internal static RenderTreeEdit RemoveAttribute(int siblingIndex, string name);
    internal static RenderTreeEdit StepIn(int siblingIndex);
    internal static RenderTreeEdit StepOut();
    internal static RenderTreeEdit PermutationListEntry(int fromSiblingIndex, int toSiblingIndex);
    internal static RenderTreeEdit PermutationListEnd();
}
public enum Microsoft.AspNetCore.Components.RenderTree.RenderTreeEditType : Enum {
    public int value__;
    public static RenderTreeEditType PrependFrame;
    public static RenderTreeEditType RemoveFrame;
    public static RenderTreeEditType SetAttribute;
    public static RenderTreeEditType RemoveAttribute;
    public static RenderTreeEditType UpdateText;
    public static RenderTreeEditType StepIn;
    public static RenderTreeEditType StepOut;
    public static RenderTreeEditType UpdateMarkup;
    public static RenderTreeEditType PermutationListEntry;
    public static RenderTreeEditType PermutationListEnd;
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.RenderTree.RenderTreeFrame : ValueType {
    public int Sequence;
    public RenderTreeFrameType FrameType;
    public int ElementSubtreeLength;
    public string ElementName;
    public object ElementKey;
    public string TextContent;
    public ulong AttributeEventHandlerId;
    public string AttributeName;
    public object AttributeValue;
    public string AttributeEventUpdatesAttributeName;
    public int ComponentSubtreeLength;
    public int ComponentId;
    public Type ComponentType;
    internal ComponentState ComponentState;
    public object ComponentKey;
    public int RegionSubtreeLength;
    public string ElementReferenceCaptureId;
    public Action`1<ElementReference> ElementReferenceCaptureAction;
    public int ComponentReferenceCaptureParentFrameIndex;
    public Action`1<object> ComponentReferenceCaptureAction;
    public string MarkupContent;
    public IComponent Component { get; }
    private RenderTreeFrame(int sequence, int elementSubtreeLength, string elementName, object elementKey);
    private RenderTreeFrame(int sequence, int componentSubtreeLength, Type componentType, ComponentState componentState, object componentKey);
    private RenderTreeFrame(int sequence, int regionSubtreeLength);
    private RenderTreeFrame(int sequence, bool isMarkup, string textOrMarkup);
    private RenderTreeFrame(int sequence, string attributeName, object attributeValue, ulong attributeEventHandlerId, string attributeEventUpdatesAttributeName);
    private RenderTreeFrame(int sequence, Action`1<ElementReference> elementReferenceCaptureAction, string elementReferenceCaptureId);
    private RenderTreeFrame(int sequence, Action`1<object> componentReferenceCaptureAction, int parentFrameIndex);
    public IComponent get_Component();
    internal static RenderTreeFrame Element(int sequence, string elementName);
    internal static RenderTreeFrame Text(int sequence, string textContent);
    internal static RenderTreeFrame Markup(int sequence, string markupContent);
    internal static RenderTreeFrame Attribute(int sequence, string name, object value);
    internal static RenderTreeFrame ChildComponent(int sequence, Type componentType);
    internal static RenderTreeFrame PlaceholderChildComponentWithSubtreeLength(int subtreeLength);
    internal static RenderTreeFrame Region(int sequence);
    internal static RenderTreeFrame ElementReferenceCapture(int sequence, Action`1<ElementReference> elementReferenceCaptureAction);
    internal static RenderTreeFrame ComponentReferenceCapture(int sequence, Action`1<object> componentReferenceCaptureAction, int parentFrameIndex);
    internal RenderTreeFrame WithElementSubtreeLength(int elementSubtreeLength);
    internal RenderTreeFrame WithComponentSubtreeLength(int componentSubtreeLength);
    internal RenderTreeFrame WithAttributeSequence(int sequence);
    internal RenderTreeFrame WithComponent(ComponentState componentState);
    internal RenderTreeFrame WithAttributeEventHandlerId(ulong eventHandlerId);
    internal RenderTreeFrame WithAttributeValue(object attributeValue);
    internal RenderTreeFrame WithAttributeEventUpdatesAttributeName(string attributeUpdatesAttributeName);
    internal RenderTreeFrame WithRegionSubtreeLength(int regionSubtreeLength);
    internal RenderTreeFrame WithElementReferenceCaptureId(string elementReferenceCaptureId);
    internal RenderTreeFrame WithElementKey(object elementKey);
    internal RenderTreeFrame WithComponentKey(object componentKey);
    public virtual string ToString();
    private static string EscapeNewlines(string text);
}
public enum Microsoft.AspNetCore.Components.RenderTree.RenderTreeFrameType : Enum {
    public short value__;
    public static RenderTreeFrameType None;
    public static RenderTreeFrameType Element;
    public static RenderTreeFrameType Text;
    public static RenderTreeFrameType Attribute;
    public static RenderTreeFrameType Component;
    public static RenderTreeFrameType Region;
    public static RenderTreeFrameType ElementReferenceCapture;
    public static RenderTreeFrameType ComponentReferenceCapture;
    public static RenderTreeFrameType Markup;
}
internal class Microsoft.AspNetCore.Components.RenderTree.StackObjectPool`1 : object {
    private int _maxPreservedItems;
    private Func`1<T> _instanceFactory;
    private T[] _contents;
    private int _numSuppliedItems;
    private int _numTrackedItems;
    public StackObjectPool`1(int maxPreservedItems, Func`1<T> instanceFactory);
    public T Get();
    public void Return(T instance);
}
[AttributeUsageAttribute("4")]
public class Microsoft.AspNetCore.Components.RouteAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Template>k__BackingField;
    public string Template { get; }
    public RouteAttribute(string template);
    [CompilerGeneratedAttribute]
public string get_Template();
}
public class Microsoft.AspNetCore.Components.RouteData : object {
    [CompilerGeneratedAttribute]
private Type <PageType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <RouteValues>k__BackingField;
    public Type PageType { get; }
    public IReadOnlyDictionary`2<string, object> RouteValues { get; }
    public RouteData(Type pageType, IReadOnlyDictionary`2<string, object> routeValues);
    [CompilerGeneratedAttribute]
public Type get_PageType();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_RouteValues();
}
internal static class Microsoft.AspNetCore.Components.RouteTableFactory : object {
    private static ConcurrentDictionary`2<Key, RouteTable> Cache;
    public static IComparer`1<RouteEntry> RoutePrecedence;
    private static RouteTableFactory();
    public static RouteTable Create(IEnumerable`1<Assembly> assemblies);
    internal static RouteTable Create(IEnumerable`1<Type> componentTypes);
    internal static RouteTable Create(Dictionary`2<Type, String[]> templatesByHandler);
    private static String[] GetParameterNames(RouteTemplate routeTemplate);
    internal static int RouteComparison(RouteEntry x, RouteEntry y);
}
public class Microsoft.AspNetCore.Components.RouteView : object {
    private RenderFragment _renderDelegate;
    private RenderFragment _renderPageWithParametersDelegate;
    private RenderHandle _renderHandle;
    [CompilerGeneratedAttribute]
private RouteData <RouteData>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DefaultLayout>k__BackingField;
    [ParameterAttribute]
public RouteData RouteData { get; public set; }
    [ParameterAttribute]
public Type DefaultLayout { get; public set; }
    [CompilerGeneratedAttribute]
public RouteData get_RouteData();
    [CompilerGeneratedAttribute]
public void set_RouteData(RouteData value);
    [CompilerGeneratedAttribute]
public Type get_DefaultLayout();
    [CompilerGeneratedAttribute]
public void set_DefaultLayout(Type value);
    public sealed virtual void Attach(RenderHandle renderHandle);
    public sealed virtual Task SetParametersAsync(ParameterView parameters);
    protected virtual void Render(RenderTreeBuilder builder);
    private void RenderPageWithParameters(RenderTreeBuilder builder);
}
public interface Microsoft.AspNetCore.Components.Routing.IHostEnvironmentNavigationManager {
    public abstract virtual void Initialize(string baseUri, string uri);
}
public interface Microsoft.AspNetCore.Components.Routing.INavigationInterception {
    public abstract virtual Task EnableNavigationInterceptionAsync();
}
public class Microsoft.AspNetCore.Components.Routing.LocationChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNavigationIntercepted>k__BackingField;
    public string Location { get; }
    public bool IsNavigationIntercepted { get; }
    public LocationChangedEventArgs(string location, bool isNavigationIntercepted);
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
public bool get_IsNavigationIntercepted();
}
internal abstract class Microsoft.AspNetCore.Components.Routing.RouteConstraint : object {
    private static ConcurrentDictionary`2<string, RouteConstraint> _cachedConstraints;
    private static RouteConstraint();
    public abstract virtual bool Match(string pathSegment, Object& convertedValue);
    public static RouteConstraint Parse(string template, string segment, string constraint);
    private static RouteConstraint CreateRouteConstraint(string constraint);
}
internal class Microsoft.AspNetCore.Components.Routing.RouteContext : object {
    private static Char[] Separator;
    [CompilerGeneratedAttribute]
private String[] <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Parameters>k__BackingField;
    public String[] Segments { get; }
    public Type Handler { get; public set; }
    public IReadOnlyDictionary`2<string, object> Parameters { get; public set; }
    public RouteContext(string path);
    private static RouteContext();
    [CompilerGeneratedAttribute]
public String[] get_Segments();
    [CompilerGeneratedAttribute]
public Type get_Handler();
    [CompilerGeneratedAttribute]
public void set_Handler(Type value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(IReadOnlyDictionary`2<string, object> value);
}
[DebuggerDisplayAttribute("Handler = {Handler}, Template = {Template}")]
internal class Microsoft.AspNetCore.Components.Routing.RouteEntry : object {
    [CompilerGeneratedAttribute]
private RouteTemplate <Template>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <UnusedRouteParameterNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Handler>k__BackingField;
    public RouteTemplate Template { get; }
    public String[] UnusedRouteParameterNames { get; }
    public Type Handler { get; }
    public RouteEntry(RouteTemplate template, Type handler, String[] unusedRouteParameterNames);
    [CompilerGeneratedAttribute]
public RouteTemplate get_Template();
    [CompilerGeneratedAttribute]
public String[] get_UnusedRouteParameterNames();
    [CompilerGeneratedAttribute]
public Type get_Handler();
    internal void Match(RouteContext context);
}
public class Microsoft.AspNetCore.Components.Routing.Router : object {
    private static Char[] _queryOrHashStartChar;
    private static ReadOnlyDictionary`2<string, object> _emptyParametersDictionary;
    private RenderHandle _renderHandle;
    private string _baseUri;
    private string _locationAbsolute;
    private bool _navigationInterceptionEnabled;
    private ILogger`1<Router> _logger;
    [CompilerGeneratedAttribute]
private NavigationManager <NavigationManager>k__BackingField;
    [CompilerGeneratedAttribute]
private INavigationInterception <NavigationInterception>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoggerFactory <LoggerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <AppAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Assembly> <AdditionalAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private RenderFragment <NotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private RenderFragment`1<RouteData> <Found>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteTable <Routes>k__BackingField;
    [InjectAttribute]
private NavigationManager NavigationManager { get; private set; }
    [InjectAttribute]
private INavigationInterception NavigationInterception { get; private set; }
    [InjectAttribute]
private ILoggerFactory LoggerFactory { get; private set; }
    [ParameterAttribute]
public Assembly AppAssembly { get; public set; }
    [ParameterAttribute]
public IEnumerable`1<Assembly> AdditionalAssemblies { get; public set; }
    [ParameterAttribute]
public RenderFragment NotFound { get; public set; }
    [ParameterAttribute]
public RenderFragment`1<RouteData> Found { get; public set; }
    private RouteTable Routes { get; private set; }
    private static Router();
    [CompilerGeneratedAttribute]
private NavigationManager get_NavigationManager();
    [CompilerGeneratedAttribute]
private void set_NavigationManager(NavigationManager value);
    [CompilerGeneratedAttribute]
private INavigationInterception get_NavigationInterception();
    [CompilerGeneratedAttribute]
private void set_NavigationInterception(INavigationInterception value);
    [CompilerGeneratedAttribute]
private ILoggerFactory get_LoggerFactory();
    [CompilerGeneratedAttribute]
private void set_LoggerFactory(ILoggerFactory value);
    [CompilerGeneratedAttribute]
public Assembly get_AppAssembly();
    [CompilerGeneratedAttribute]
public void set_AppAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Assembly> get_AdditionalAssemblies();
    [CompilerGeneratedAttribute]
public void set_AdditionalAssemblies(IEnumerable`1<Assembly> value);
    [CompilerGeneratedAttribute]
public RenderFragment get_NotFound();
    [CompilerGeneratedAttribute]
public void set_NotFound(RenderFragment value);
    [CompilerGeneratedAttribute]
public RenderFragment`1<RouteData> get_Found();
    [CompilerGeneratedAttribute]
public void set_Found(RenderFragment`1<RouteData> value);
    [CompilerGeneratedAttribute]
private RouteTable get_Routes();
    [CompilerGeneratedAttribute]
private void set_Routes(RouteTable value);
    public sealed virtual void Attach(RenderHandle renderHandle);
    public sealed virtual Task SetParametersAsync(ParameterView parameters);
    public sealed virtual void Dispose();
    private static string StringUntilAny(string str, Char[] chars);
    private void Refresh(bool isNavigationIntercepted);
    private void OnLocationChanged(object sender, LocationChangedEventArgs args);
    private sealed virtual override Task Microsoft.AspNetCore.Components.IHandleAfterRender.OnAfterRenderAsync();
}
internal class Microsoft.AspNetCore.Components.Routing.RouteTable : object {
    [CompilerGeneratedAttribute]
private RouteEntry[] <Routes>k__BackingField;
    public RouteEntry[] Routes { get; }
    public RouteTable(RouteEntry[] routes);
    [CompilerGeneratedAttribute]
public RouteEntry[] get_Routes();
    internal void Route(RouteContext routeContext);
}
[DebuggerDisplayAttribute("{TemplateText}")]
internal class Microsoft.AspNetCore.Components.Routing.RouteTemplate : object {
    [CompilerGeneratedAttribute]
private string <TemplateText>k__BackingField;
    [CompilerGeneratedAttribute]
private TemplateSegment[] <Segments>k__BackingField;
    public string TemplateText { get; }
    public TemplateSegment[] Segments { get; }
    public RouteTemplate(string templateText, TemplateSegment[] segments);
    [CompilerGeneratedAttribute]
public string get_TemplateText();
    [CompilerGeneratedAttribute]
public TemplateSegment[] get_Segments();
}
internal class Microsoft.AspNetCore.Components.Routing.TemplateParser : object {
    public static Char[] InvalidParameterNameCharacters;
    private static TemplateParser();
    internal static RouteTemplate ParseTemplate(string template);
}
internal class Microsoft.AspNetCore.Components.Routing.TemplateSegment : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteConstraint[] <Constraints>k__BackingField;
    public string Value { get; }
    public bool IsParameter { get; }
    public RouteConstraint[] Constraints { get; }
    public TemplateSegment(string template, string segment, bool isParameter);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public bool get_IsParameter();
    [CompilerGeneratedAttribute]
public RouteConstraint[] get_Constraints();
    public bool Match(string pathSegment, Object& matchedParameterValue);
}
internal class Microsoft.AspNetCore.Components.Routing.TypeRouteConstraint`1 : RouteConstraint {
    private TryParseDelegate<T> _parser;
    public TypeRouteConstraint`1(TryParseDelegate<T> parser);
    public virtual bool Match(string pathSegment, Object& convertedValue);
}
internal class Microsoft.Extensions.Internal.HashCodeCombiner : ValueType {
    private long _combinedHash64;
    public int CombinedHash { get; }
    private HashCodeCombiner(long seed);
    public int get_CombinedHash();
    public void Add(IEnumerable e);
    public static int op_Implicit(HashCodeCombiner self);
    public void Add(int i);
    public void Add(string s);
    public void Add(object o);
    public void Add(TValue value, IEqualityComparer`1<TValue> comparer);
    public static HashCodeCombiner Start();
}
