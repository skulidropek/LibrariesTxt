[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions : object {
    private static String[] GetVerb;
    private static String[] PostVerb;
    private static String[] PutVerb;
    private static String[] DeleteVerb;
    private static EndpointRouteBuilderExtensions();
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapGet(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapPost(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapPut(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapDelete(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapMethods(IEndpointRouteBuilder endpoints, string pattern, IEnumerable`1<string> httpMethods, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder Map(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder Map(IEndpointRouteBuilder endpoints, RoutePattern pattern, RequestDelegate requestDelegate);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions : object {
    private static string EndpointRouteBuilder;
    [ExtensionAttribute]
public static IApplicationBuilder UseRouting(IApplicationBuilder builder);
    [ExtensionAttribute]
public static IApplicationBuilder UseEndpoints(IApplicationBuilder builder, Action`1<IEndpointRouteBuilder> configure);
    private static void VerifyRoutingServicesAreRegistered(IApplicationBuilder app);
    private static void VerifyEndpointRoutingMiddlewareIsRegistered(IApplicationBuilder app, DefaultEndpointRouteBuilder& endpointRouteBuilder);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.FallbackEndpointRouteBuilderExtensions : object {
    public static string DefaultPattern;
    private static FallbackEndpointRouteBuilderExtensions();
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapFallback(IEndpointRouteBuilder endpoints, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapFallback(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions : object {
    [ExtensionAttribute]
public static IRouteBuilder MapRoute(IRouteBuilder routeBuilder, string name, string template);
    [ExtensionAttribute]
public static IRouteBuilder MapRoute(IRouteBuilder routeBuilder, string name, string template, object defaults);
    [ExtensionAttribute]
public static IRouteBuilder MapRoute(IRouteBuilder routeBuilder, string name, string template, object defaults, object constraints);
    [ExtensionAttribute]
public static IRouteBuilder MapRoute(IRouteBuilder routeBuilder, string name, string template, object defaults, object constraints, object dataTokens);
    private static IInlineConstraintResolver CreateInlineConstraintResolver(IServiceProvider serviceProvider);
}
public class Microsoft.AspNetCore.Builder.RouterMiddleware : object {
    private ILogger _logger;
    private RequestDelegate _next;
    private IRouter _router;
    public RouterMiddleware(RequestDelegate next, ILoggerFactory loggerFactory, IRouter router);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Builder.RouterMiddleware/<Invoke>d__4")]
public Task Invoke(HttpContext httpContext);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.RoutingBuilderExtensions : object {
    [ExtensionAttribute]
public static IApplicationBuilder UseRouter(IApplicationBuilder builder, IRouter router);
    [ExtensionAttribute]
public static IApplicationBuilder UseRouter(IApplicationBuilder builder, Action`1<IRouteBuilder> action);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.RoutingEndpointConventionBuilderExtensions : object {
    [ExtensionAttribute]
public static TBuilder RequireHost(TBuilder builder, String[] hosts);
    [ExtensionAttribute]
public static TBuilder WithDisplayName(TBuilder builder, string displayName);
    [ExtensionAttribute]
public static TBuilder WithDisplayName(TBuilder builder, Func`2<EndpointBuilder, string> func);
    [ExtensionAttribute]
public static TBuilder WithMetadata(TBuilder builder, Object[] items);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Routing.ArrayBuilder`1 : ValueType {
    private static int DefaultCapacity;
    private static int MaxCoreClrArrayLength;
    private T[] _array;
    private int _count;
    public int Capacity { get; }
    public T[] Buffer { get; }
    public int Count { get; }
    public T Item { get; }
    public ArrayBuilder`1(int capacity);
    public int get_Capacity();
    public T[] get_Buffer();
    public int get_Count();
    public T get_Item(int index);
    public void Add(T item);
    public T First();
    public T Last();
    public T[] ToArray();
    public void UncheckedAdd(T item);
    private void EnsureCapacity(int minimum);
}
[DebuggerDisplayAttribute("{DebuggerDisplayString,nq}")]
public class Microsoft.AspNetCore.Routing.CompositeEndpointDataSource : EndpointDataSource {
    private object _lock;
    private ICollection`1<EndpointDataSource> _dataSources;
    private IReadOnlyList`1<Endpoint> _endpoints;
    private IChangeToken _consumerChangeToken;
    private CancellationTokenSource _cts;
    public IEnumerable`1<EndpointDataSource> DataSources { get; }
    public IReadOnlyList`1<Endpoint> Endpoints { get; }
    private string DebuggerDisplayString { get; }
    internal CompositeEndpointDataSource(ObservableCollection`1<EndpointDataSource> dataSources);
    public CompositeEndpointDataSource(IEnumerable`1<EndpointDataSource> endpointDataSources);
    private void OnDataSourcesChanged(object sender, NotifyCollectionChangedEventArgs e);
    public IEnumerable`1<EndpointDataSource> get_DataSources();
    public virtual IChangeToken GetChangeToken();
    public virtual IReadOnlyList`1<Endpoint> get_Endpoints();
    private void EnsureInitialized();
    private void Initialize();
    private void HandleChange();
    private void CreateChangeToken();
    private string get_DebuggerDisplayString();
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <get_DebuggerDisplayString>g__FormatValues|19_0(IEnumerable`1<KeyValuePair`2<string, object>> values);
}
public class Microsoft.AspNetCore.Routing.Constraints.AlphaRouteConstraint : RegexRouteConstraint {
}
public class Microsoft.AspNetCore.Routing.Constraints.BoolRouteConstraint : object {
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.CompositeRouteConstraint : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IRouteConstraint> <Constraints>k__BackingField;
    public IEnumerable`1<IRouteConstraint> Constraints { get; private set; }
    public CompositeRouteConstraint(IEnumerable`1<IRouteConstraint> constraints);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IRouteConstraint> get_Constraints();
    [CompilerGeneratedAttribute]
private void set_Constraints(IEnumerable`1<IRouteConstraint> value);
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.DateTimeRouteConstraint : object {
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.DecimalRouteConstraint : object {
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.DoubleRouteConstraint : object {
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.FileNameRouteConstraint : object {
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    internal static bool IsFileName(ReadOnlySpan`1<char> value);
}
public class Microsoft.AspNetCore.Routing.Constraints.FloatRouteConstraint : object {
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.GuidRouteConstraint : object {
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.HttpMethodRouteConstraint : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <AllowedMethods>k__BackingField;
    public IList`1<string> AllowedMethods { get; }
    public HttpMethodRouteConstraint(String[] allowedMethods);
    [CompilerGeneratedAttribute]
public IList`1<string> get_AllowedMethods();
    public virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.IntRouteConstraint : object {
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.LengthRouteConstraint : object {
    [CompilerGeneratedAttribute]
private int <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    public int MinLength { get; }
    public int MaxLength { get; }
    public LengthRouteConstraint(int length);
    public LengthRouteConstraint(int minLength, int maxLength);
    [CompilerGeneratedAttribute]
public int get_MinLength();
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.LongRouteConstraint : object {
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.MaxLengthRouteConstraint : object {
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    public int MaxLength { get; }
    public MaxLengthRouteConstraint(int maxLength);
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.MaxRouteConstraint : object {
    [CompilerGeneratedAttribute]
private long <Max>k__BackingField;
    public long Max { get; private set; }
    public MaxRouteConstraint(long max);
    [CompilerGeneratedAttribute]
public long get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(long value);
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.MinLengthRouteConstraint : object {
    [CompilerGeneratedAttribute]
private int <MinLength>k__BackingField;
    public int MinLength { get; private set; }
    public MinLengthRouteConstraint(int minLength);
    [CompilerGeneratedAttribute]
public int get_MinLength();
    [CompilerGeneratedAttribute]
private void set_MinLength(int value);
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.MinRouteConstraint : object {
    [CompilerGeneratedAttribute]
private long <Min>k__BackingField;
    public long Min { get; }
    public MinRouteConstraint(long min);
    [CompilerGeneratedAttribute]
public long get_Min();
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.NonFileNameRouteConstraint : object {
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
internal class Microsoft.AspNetCore.Routing.Constraints.NullRouteConstraint : object {
    public static NullRouteConstraint Instance;
    private static NullRouteConstraint();
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.OptionalRouteConstraint : object {
    [CompilerGeneratedAttribute]
private IRouteConstraint <InnerConstraint>k__BackingField;
    public IRouteConstraint InnerConstraint { get; }
    public OptionalRouteConstraint(IRouteConstraint innerConstraint);
    [CompilerGeneratedAttribute]
public IRouteConstraint get_InnerConstraint();
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.RangeRouteConstraint : object {
    [CompilerGeneratedAttribute]
private long <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Max>k__BackingField;
    public long Min { get; private set; }
    public long Max { get; private set; }
    public RangeRouteConstraint(long min, long max);
    [CompilerGeneratedAttribute]
public long get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(long value);
    [CompilerGeneratedAttribute]
public long get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(long value);
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.RegexInlineRouteConstraint : RegexRouteConstraint {
    public RegexInlineRouteConstraint(string regexPattern);
}
public class Microsoft.AspNetCore.Routing.Constraints.RegexRouteConstraint : object {
    private static TimeSpan RegexMatchTimeout;
    [CompilerGeneratedAttribute]
private Regex <Constraint>k__BackingField;
    public Regex Constraint { get; private set; }
    public RegexRouteConstraint(Regex regex);
    public RegexRouteConstraint(string regexPattern);
    private static RegexRouteConstraint();
    [CompilerGeneratedAttribute]
public Regex get_Constraint();
    [CompilerGeneratedAttribute]
private void set_Constraint(Regex value);
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.RequiredRouteConstraint : object {
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.StringRouteConstraint : object {
    private string _value;
    public StringRouteConstraint(string value);
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
internal class Microsoft.AspNetCore.Routing.DataSourceDependentCache`1 : object {
    private EndpointDataSource _dataSource;
    private Func`2<IReadOnlyList`1<Endpoint>, T> _initializeCore;
    private Func`1<T> _initializer;
    private Action`1<object> _initializerWithState;
    private object _lock;
    private bool _initialized;
    private T _value;
    private IDisposable _disposable;
    private bool _disposed;
    public T Value { get; }
    public DataSourceDependentCache`1(EndpointDataSource dataSource, Func`2<IReadOnlyList`1<Endpoint>, T> initialize);
    public T get_Value();
    public T EnsureInitialized();
    private T Initialize();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(object state);
}
public class Microsoft.AspNetCore.Routing.DataTokensMetadata : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <DataTokens>k__BackingField;
    public IReadOnlyDictionary`2<string, object> DataTokens { get; }
    public DataTokensMetadata(IReadOnlyDictionary`2<string, object> dataTokens);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, object> get_DataTokens();
}
internal class Microsoft.AspNetCore.Routing.DecisionTree.DecisionCriterion`1 : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<object, DecisionTreeNode`1<TItem>> <Branches>k__BackingField;
    public string Key { get; public set; }
    public Dictionary`2<object, DecisionTreeNode`1<TItem>> Branches { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<object, DecisionTreeNode`1<TItem>> get_Branches();
    [CompilerGeneratedAttribute]
public void set_Branches(Dictionary`2<object, DecisionTreeNode`1<TItem>> value);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Routing.DecisionTree.DecisionCriterionValue : ValueType {
    private object _value;
    public object Value { get; }
    public DecisionCriterionValue(object value);
    public object get_Value();
}
internal class Microsoft.AspNetCore.Routing.DecisionTree.DecisionCriterionValueEqualityComparer : object {
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<object> <InnerComparer>k__BackingField;
    public IEqualityComparer`1<object> InnerComparer { get; private set; }
    public DecisionCriterionValueEqualityComparer(IEqualityComparer`1<object> innerComparer);
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<object> get_InnerComparer();
    [CompilerGeneratedAttribute]
private void set_InnerComparer(IEqualityComparer`1<object> value);
    public sealed virtual bool Equals(DecisionCriterionValue x, DecisionCriterionValue y);
    public sealed virtual int GetHashCode(DecisionCriterionValue obj);
}
internal static class Microsoft.AspNetCore.Routing.DecisionTree.DecisionTreeBuilder`1 : object {
    public static DecisionTreeNode`1<TItem> GenerateTree(IReadOnlyList`1<TItem> items, IClassifier`1<TItem> classifier);
    private static DecisionTreeNode`1<TItem> GenerateNode(TreeBuilderContext<TItem> context, DecisionCriterionValueEqualityComparer comparer, List`1<ItemDescriptor`1<TItem>> items);
}
internal class Microsoft.AspNetCore.Routing.DecisionTree.DecisionTreeNode`1 : object {
    [CompilerGeneratedAttribute]
private IList`1<TItem> <Matches>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DecisionCriterion`1<TItem>> <Criteria>k__BackingField;
    public IList`1<TItem> Matches { get; public set; }
    public IList`1<DecisionCriterion`1<TItem>> Criteria { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<TItem> get_Matches();
    [CompilerGeneratedAttribute]
public void set_Matches(IList`1<TItem> value);
    [CompilerGeneratedAttribute]
public IList`1<DecisionCriterion`1<TItem>> get_Criteria();
    [CompilerGeneratedAttribute]
public void set_Criteria(IList`1<DecisionCriterion`1<TItem>> value);
}
internal interface Microsoft.AspNetCore.Routing.DecisionTree.IClassifier`1 {
    public IEqualityComparer`1<object> ValueComparer { get; }
    public abstract virtual IDictionary`2<string, DecisionCriterionValue> GetCriteria(TItem item);
    public abstract virtual IEqualityComparer`1<object> get_ValueComparer();
}
internal class Microsoft.AspNetCore.Routing.DecisionTree.ItemDescriptor`1 : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, DecisionCriterionValue> <Criteria>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private TItem <Item>k__BackingField;
    public IDictionary`2<string, DecisionCriterionValue> Criteria { get; public set; }
    public int Index { get; public set; }
    public TItem Item { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, DecisionCriterionValue> get_Criteria();
    [CompilerGeneratedAttribute]
public void set_Criteria(IDictionary`2<string, DecisionCriterionValue> value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public TItem get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(TItem value);
}
internal class Microsoft.AspNetCore.Routing.DefaultEndpointConventionBuilder : object {
    [CompilerGeneratedAttribute]
private EndpointBuilder <EndpointBuilder>k__BackingField;
    private List`1<Action`1<EndpointBuilder>> _conventions;
    internal EndpointBuilder EndpointBuilder { get; }
    public DefaultEndpointConventionBuilder(EndpointBuilder endpointBuilder);
    [CompilerGeneratedAttribute]
internal EndpointBuilder get_EndpointBuilder();
    public sealed virtual void Add(Action`1<EndpointBuilder> convention);
    public Endpoint Build();
}
public class Microsoft.AspNetCore.Routing.DefaultEndpointDataSource : EndpointDataSource {
    private IReadOnlyList`1<Endpoint> _endpoints;
    public IReadOnlyList`1<Endpoint> Endpoints { get; }
    public DefaultEndpointDataSource(Endpoint[] endpoints);
    public DefaultEndpointDataSource(IEnumerable`1<Endpoint> endpoints);
    public virtual IChangeToken GetChangeToken();
    public virtual IReadOnlyList`1<Endpoint> get_Endpoints();
}
internal class Microsoft.AspNetCore.Routing.DefaultEndpointRouteBuilder : object {
    [CompilerGeneratedAttribute]
private IApplicationBuilder <ApplicationBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EndpointDataSource> <DataSources>k__BackingField;
    public IApplicationBuilder ApplicationBuilder { get; }
    public ICollection`1<EndpointDataSource> DataSources { get; }
    public IServiceProvider ServiceProvider { get; }
    public DefaultEndpointRouteBuilder(IApplicationBuilder applicationBuilder);
    [CompilerGeneratedAttribute]
public IApplicationBuilder get_ApplicationBuilder();
    public sealed virtual IApplicationBuilder CreateApplicationBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<EndpointDataSource> get_DataSources();
    public sealed virtual IServiceProvider get_ServiceProvider();
}
public class Microsoft.AspNetCore.Routing.DefaultInlineConstraintResolver : object {
    private IDictionary`2<string, Type> _inlineConstraintMap;
    private IServiceProvider _serviceProvider;
    public DefaultInlineConstraintResolver(IOptions`1<RouteOptions> routeOptions, IServiceProvider serviceProvider);
    public virtual IRouteConstraint ResolveConstraint(string inlineConstraint);
}
internal class Microsoft.AspNetCore.Routing.DefaultLinkGenerator : LinkGenerator {
    private ParameterPolicyFactory _parameterPolicyFactory;
    private TemplateBinderFactory _binderFactory;
    private ILogger`1<DefaultLinkGenerator> _logger;
    private IServiceProvider _serviceProvider;
    private LinkOptions _globalLinkOptions;
    private DataSourceDependentCache`1<ConcurrentDictionary`2<RouteEndpoint, TemplateBinder>> _cache;
    private Func`2<RouteEndpoint, TemplateBinder> _createTemplateBinder;
    public DefaultLinkGenerator(ParameterPolicyFactory parameterPolicyFactory, TemplateBinderFactory binderFactory, EndpointDataSource dataSource, IOptions`1<RouteOptions> routeOptions, ILogger`1<DefaultLinkGenerator> logger, IServiceProvider serviceProvider);
    public virtual string GetPathByAddress(HttpContext httpContext, TAddress address, RouteValueDictionary values, RouteValueDictionary ambientValues, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    public virtual string GetPathByAddress(TAddress address, RouteValueDictionary values, PathString pathBase, FragmentString fragment, LinkOptions options);
    public virtual string GetUriByAddress(HttpContext httpContext, TAddress address, RouteValueDictionary values, RouteValueDictionary ambientValues, string scheme, Nullable`1<HostString> host, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    public virtual string GetUriByAddress(TAddress address, RouteValueDictionary values, string scheme, HostString host, PathString pathBase, FragmentString fragment, LinkOptions options);
    private List`1<RouteEndpoint> GetEndpoints(TAddress address);
    private string GetPathByEndpoints(HttpContext httpContext, List`1<RouteEndpoint> endpoints, RouteValueDictionary values, RouteValueDictionary ambientValues, PathString pathBase, FragmentString fragment, LinkOptions options);
    public string GetUriByEndpoints(List`1<RouteEndpoint> endpoints, RouteValueDictionary values, RouteValueDictionary ambientValues, string scheme, HostString host, PathString pathBase, FragmentString fragment, LinkOptions options);
    private TemplateBinder CreateTemplateBinder(RouteEndpoint endpoint);
    internal TemplateBinder GetTemplateBinder(RouteEndpoint endpoint);
    internal bool TryProcessTemplate(HttpContext httpContext, RouteEndpoint endpoint, RouteValueDictionary values, RouteValueDictionary ambientValues, LinkOptions options, ValueTuple`2& result);
    public static RouteValueDictionary GetAmbientValues(HttpContext httpContext);
    public sealed virtual void Dispose();
}
internal class Microsoft.AspNetCore.Routing.DefaultLinkParser : LinkParser {
    private ParameterPolicyFactory _parameterPolicyFactory;
    private ILogger`1<DefaultLinkParser> _logger;
    private IServiceProvider _serviceProvider;
    private DataSourceDependentCache`1<ConcurrentDictionary`2<RouteEndpoint, MatcherState>> _matcherCache;
    private Func`2<RouteEndpoint, MatcherState> _createMatcher;
    public DefaultLinkParser(ParameterPolicyFactory parameterPolicyFactory, EndpointDataSource dataSource, ILogger`1<DefaultLinkParser> logger, IServiceProvider serviceProvider);
    public virtual RouteValueDictionary ParsePathByAddress(TAddress address, PathString path);
    private List`1<RouteEndpoint> GetEndpoints(TAddress address);
    private MatcherState CreateRoutePatternMatcher(RouteEndpoint endpoint);
    internal MatcherState GetMatcherState(RouteEndpoint endpoint);
    internal bool TryParse(RouteEndpoint endpoint, PathString path, RouteValueDictionary& values);
    public sealed virtual void Dispose();
}
internal class Microsoft.AspNetCore.Routing.DefaultParameterPolicyFactory : ParameterPolicyFactory {
    private RouteOptions _options;
    private IServiceProvider _serviceProvider;
    public DefaultParameterPolicyFactory(IOptions`1<RouteOptions> options, IServiceProvider serviceProvider);
    public virtual IParameterPolicy Create(RoutePatternParameterPart parameter, IParameterPolicy parameterPolicy);
    public virtual IParameterPolicy Create(RoutePatternParameterPart parameter, string inlineText);
    private IParameterPolicy InitializeRouteConstraint(bool optional, IRouteConstraint routeConstraint);
}
public abstract class Microsoft.AspNetCore.Routing.EndpointDataSource : object {
    public IReadOnlyList`1<Endpoint> Endpoints { get; }
    public abstract virtual IChangeToken GetChangeToken();
    public abstract virtual IReadOnlyList`1<Endpoint> get_Endpoints();
}
internal class Microsoft.AspNetCore.Routing.EndpointMiddleware : object {
    internal static string AuthorizationMiddlewareInvokedKey;
    internal static string CorsMiddlewareInvokedKey;
    private ILogger _logger;
    private RequestDelegate _next;
    private RouteOptions _routeOptions;
    public EndpointMiddleware(ILogger`1<EndpointMiddleware> logger, RequestDelegate next, IOptions`1<RouteOptions> routeOptions);
    public Task Invoke(HttpContext httpContext);
    private static void ThrowMissingAuthMiddlewareException(Endpoint endpoint);
    private static void ThrowMissingCorsMiddlewareException(Endpoint endpoint);
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.EndpointMiddleware/<<Invoke>g__AwaitRequestTask|6_0>d")]
internal static Task <Invoke>g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger);
}
internal class Microsoft.AspNetCore.Routing.EndpointNameAddressScheme : object {
    private DataSourceDependentCache`1<Dictionary`2<string, Endpoint[]>> _cache;
    internal Dictionary`2<string, Endpoint[]> Entries { get; }
    public EndpointNameAddressScheme(EndpointDataSource dataSource);
    internal Dictionary`2<string, Endpoint[]> get_Entries();
    public sealed virtual IEnumerable`1<Endpoint> FindEndpoints(string address);
    private static Dictionary`2<string, Endpoint[]> Initialize(IReadOnlyList`1<Endpoint> endpoints);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static string <Initialize>g__GetEndpointName|5_3(Endpoint endpoint);
}
public class Microsoft.AspNetCore.Routing.EndpointNameMetadata : object {
    [CompilerGeneratedAttribute]
private string <EndpointName>k__BackingField;
    public string EndpointName { get; }
    public EndpointNameMetadata(string endpointName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EndpointName();
}
internal class Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware : object {
    private static string DiagnosticsEndpointMatchedKey;
    private MatcherFactory _matcherFactory;
    private ILogger _logger;
    private EndpointDataSource _endpointDataSource;
    private DiagnosticListener _diagnosticListener;
    private RequestDelegate _next;
    private Task`1<Matcher> _initializationTask;
    public EndpointRoutingMiddleware(MatcherFactory matcherFactory, ILogger`1<EndpointRoutingMiddleware> logger, IEndpointRouteBuilder endpointRouteBuilder, DiagnosticListener diagnosticListener, RequestDelegate next);
    public Task Invoke(HttpContext httpContext);
    private Task SetRoutingAndContinue(HttpContext httpContext);
    private Task`1<Matcher> InitializeAsync();
    private Task`1<Matcher> InitializeCoreAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware/<<Invoke>g__AwaitMatcher|8_0>d")]
[CompilerGeneratedAttribute]
internal static Task <Invoke>g__AwaitMatcher|8_0(EndpointRoutingMiddleware middleware, HttpContext httpContext, Task`1<Matcher> matcherTask);
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware/<<Invoke>g__AwaitMatch|8_1>d")]
internal static Task <Invoke>g__AwaitMatch|8_1(EndpointRoutingMiddleware middleware, HttpContext httpContext, Task matchTask);
}
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
[AttributeUsageAttribute("68")]
public class Microsoft.AspNetCore.Routing.HostAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Hosts>k__BackingField;
    public IReadOnlyList`1<string> Hosts { get; }
    public HostAttribute(string host);
    public HostAttribute(String[] hosts);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_Hosts();
    private string DebuggerToString();
}
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
public class Microsoft.AspNetCore.Routing.HttpMethodMetadata : object {
    [CompilerGeneratedAttribute]
private bool <AcceptCorsPreflight>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <HttpMethods>k__BackingField;
    public bool AcceptCorsPreflight { get; }
    public IReadOnlyList`1<string> HttpMethods { get; }
    public HttpMethodMetadata(IEnumerable`1<string> httpMethods);
    public HttpMethodMetadata(IEnumerable`1<string> httpMethods, bool acceptCorsPreflight);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AcceptCorsPreflight();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_HttpMethods();
    private string DebuggerToString();
}
public interface Microsoft.AspNetCore.Routing.IDataTokensMetadata {
    public IReadOnlyDictionary`2<string, object> DataTokens { get; }
    public abstract virtual IReadOnlyDictionary`2<string, object> get_DataTokens();
}
public interface Microsoft.AspNetCore.Routing.IDynamicEndpointMetadata {
    public bool IsDynamic { get; }
    public abstract virtual bool get_IsDynamic();
}
public interface Microsoft.AspNetCore.Routing.IEndpointAddressScheme`1 {
    public abstract virtual IEnumerable`1<Endpoint> FindEndpoints(TAddress address);
}
public interface Microsoft.AspNetCore.Routing.IEndpointNameMetadata {
    public string EndpointName { get; }
    public abstract virtual string get_EndpointName();
}
public interface Microsoft.AspNetCore.Routing.IEndpointRouteBuilder {
    public IServiceProvider ServiceProvider { get; }
    public ICollection`1<EndpointDataSource> DataSources { get; }
    public abstract virtual IApplicationBuilder CreateApplicationBuilder();
    public abstract virtual IServiceProvider get_ServiceProvider();
    public abstract virtual ICollection`1<EndpointDataSource> get_DataSources();
}
public interface Microsoft.AspNetCore.Routing.IHostMetadata {
    public IReadOnlyList`1<string> Hosts { get; }
    public abstract virtual IReadOnlyList`1<string> get_Hosts();
}
public interface Microsoft.AspNetCore.Routing.IHttpMethodMetadata {
    public bool AcceptCorsPreflight { get; }
    public IReadOnlyList`1<string> HttpMethods { get; }
    public abstract virtual bool get_AcceptCorsPreflight();
    public abstract virtual IReadOnlyList`1<string> get_HttpMethods();
}
public interface Microsoft.AspNetCore.Routing.IInlineConstraintResolver {
    public abstract virtual IRouteConstraint ResolveConstraint(string inlineConstraint);
}
public interface Microsoft.AspNetCore.Routing.INamedRouter {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public static class Microsoft.AspNetCore.Routing.InlineRouteParameterParser : object {
    public static TemplatePart ParseRouteParameter(string routeParameter);
    private static ConstraintParseResults ParseConstraints(string routeParameter, int currentIndex, int endIndex);
}
public class Microsoft.AspNetCore.Routing.Internal.DfaGraphWriter : object {
    private IServiceProvider _services;
    public DfaGraphWriter(IServiceProvider services);
    public void Write(EndpointDataSource dataSource, TextWriter writer);
}
public interface Microsoft.AspNetCore.Routing.IRouteBuilder {
    public IApplicationBuilder ApplicationBuilder { get; }
    public IRouter DefaultHandler { get; public set; }
    public IServiceProvider ServiceProvider { get; }
    public IList`1<IRouter> Routes { get; }
    public abstract virtual IApplicationBuilder get_ApplicationBuilder();
    public abstract virtual IRouter get_DefaultHandler();
    public abstract virtual void set_DefaultHandler(IRouter value);
    public abstract virtual IServiceProvider get_ServiceProvider();
    public abstract virtual IList`1<IRouter> get_Routes();
    public abstract virtual IRouter Build();
}
public interface Microsoft.AspNetCore.Routing.IRouteCollection {
    public abstract virtual void Add(IRouter router);
}
public interface Microsoft.AspNetCore.Routing.IRouteNameMetadata {
    public string RouteName { get; }
    public abstract virtual string get_RouteName();
}
public interface Microsoft.AspNetCore.Routing.ISuppressLinkGenerationMetadata {
    public bool SuppressLinkGeneration { get; }
    public abstract virtual bool get_SuppressLinkGeneration();
}
public interface Microsoft.AspNetCore.Routing.ISuppressMatchingMetadata {
    public bool SuppressMatching { get; }
    public abstract virtual bool get_SuppressMatching();
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Routing.LinkGeneratorEndpointNameAddressExtensions : object {
    [ExtensionAttribute]
public static string GetPathByName(LinkGenerator generator, HttpContext httpContext, string endpointName, object values, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
public static string GetPathByName(LinkGenerator generator, string endpointName, object values, PathString pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
public static string GetUriByName(LinkGenerator generator, HttpContext httpContext, string endpointName, object values, string scheme, Nullable`1<HostString> host, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
public static string GetUriByName(LinkGenerator generator, string endpointName, object values, string scheme, HostString host, PathString pathBase, FragmentString fragment, LinkOptions options);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Routing.LinkGeneratorRouteValuesAddressExtensions : object {
    [ExtensionAttribute]
public static string GetPathByRouteValues(LinkGenerator generator, HttpContext httpContext, string routeName, object values, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
public static string GetPathByRouteValues(LinkGenerator generator, string routeName, object values, PathString pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
public static string GetUriByRouteValues(LinkGenerator generator, HttpContext httpContext, string routeName, object values, string scheme, Nullable`1<HostString> host, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
public static string GetUriByRouteValues(LinkGenerator generator, string routeName, object values, string scheme, HostString host, PathString pathBase, FragmentString fragment, LinkOptions options);
    private static RouteValuesAddress CreateAddress(HttpContext httpContext, string routeName, object values);
}
public abstract class Microsoft.AspNetCore.Routing.LinkParser : object {
    public abstract virtual RouteValueDictionary ParsePathByAddress(TAddress address, PathString path);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions : object {
    [ExtensionAttribute]
public static RouteValueDictionary ParsePathByEndpointName(LinkParser parser, string endpointName, PathString path);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Routing.Logging.RouteConstraintMatcherExtensions : object {
    private static Action`5<ILogger, object, string, IRouteConstraint, Exception> _constraintNotMatched;
    private static RouteConstraintMatcherExtensions();
    [ExtensionAttribute]
public static void ConstraintNotMatched(ILogger logger, object routeValue, string routeKey, IRouteConstraint routeConstraint);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Routing.Logging.RouterMiddlewareLoggerExtensions : object {
    private static Action`2<ILogger, Exception> _requestNotMatched;
    private static RouterMiddlewareLoggerExtensions();
    [ExtensionAttribute]
public static void RequestNotMatched(ILogger logger);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Routing.Logging.TreeRouterLoggerExtensions : object {
    private static Action`4<ILogger, string, string, Exception> _requestMatchedRoute;
    private static TreeRouterLoggerExtensions();
    [ExtensionAttribute]
public static void RequestMatchedRoute(ILogger logger, string routeName, string routeTemplate);
}
public abstract class Microsoft.AspNetCore.Routing.MatcherPolicy : object {
    public int Order { get; }
    public abstract virtual int get_Order();
    protected static bool ContainsDynamicEndpoints(IReadOnlyList`1<Endpoint> endpoints);
}
internal class Microsoft.AspNetCore.Routing.Matching.AmbiguousMatchException : Exception {
    public AmbiguousMatchException(string message);
    protected AmbiguousMatchException(SerializationInfo info, StreamingContext context);
}
internal static class Microsoft.AspNetCore.Routing.Matching.Ascii : object {
    public static bool AsciiIgnoreCaseEquals(ReadOnlySpan`1<char> a, ReadOnlySpan`1<char> b, int length);
    public static bool AsciiIgnoreCaseEquals(char charA, char charB);
    public static bool IsAscii(string text);
    private static void ThrowArgumentExceptionForLength();
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Routing.Matching.Candidate : ValueType {
    public Endpoint Endpoint;
    public CandidateFlags Flags;
    public KeyValuePair`2[] Slots;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`3[] Captures;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`3<string, int, int> CatchAll;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2[] ComplexSegments;
    public KeyValuePair`2[] Constraints;
    public int Score;
    public Candidate(Endpoint endpoint);
    public Candidate(Endpoint endpoint, int score, KeyValuePair`2[] slots, ValueTuple`3[] captures, ValueTuple`3& catchAll, ValueTuple`2[] complexSegments, KeyValuePair`2[] constraints);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.AspNetCore.Routing.Matching.CandidateSet : object {
    internal CandidateState[] Candidates;
    public int Count { get; }
    public CandidateState& Item { get; }
    public CandidateSet(Endpoint[] endpoints, RouteValueDictionary[] values, Int32[] scores);
    internal CandidateSet(Candidate[] candidates);
    internal CandidateSet(CandidateState[] candidates);
    public int get_Count();
    public CandidateState& get_Item(int index);
    public bool IsValidCandidate(int index);
    internal static bool IsValidCandidate(CandidateState& candidate);
    public void SetValidity(int index, bool value);
    internal static void SetValidity(CandidateState& candidate, bool value);
    public void ReplaceEndpoint(int index, Endpoint endpoint, RouteValueDictionary values);
    public void ExpandEndpoint(int index, IReadOnlyList`1<Endpoint> endpoints, IComparer`1<Endpoint> comparer);
    private int GetOriginalScore(int index);
    private void ValidateUniqueScore(int index);
    private static void ThrowIndexArgumentOutOfRangeException();
    private static void ThrowArgumentNullException(string parameter);
}
public class Microsoft.AspNetCore.Routing.Matching.CandidateState : ValueType {
    [CompilerGeneratedAttribute]
private Endpoint <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Score>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Values>k__BackingField;
    public Endpoint Endpoint { get; }
    public int Score { get; }
    public RouteValueDictionary Values { get; internal set; }
    internal CandidateState(Endpoint endpoint, int score);
    internal CandidateState(Endpoint endpoint, RouteValueDictionary values, int score);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Endpoint get_Endpoint();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Score();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public RouteValueDictionary get_Values();
    [CompilerGeneratedAttribute]
internal void set_Values(RouteValueDictionary value);
}
internal class Microsoft.AspNetCore.Routing.Matching.DataSourceDependentMatcher : Matcher {
    private Func`1<MatcherBuilder> _matcherBuilderFactory;
    private DataSourceDependentCache`1<Matcher> _cache;
    internal Matcher CurrentMatcher { get; }
    public DataSourceDependentMatcher(EndpointDataSource dataSource, Lifetime lifetime, Func`1<MatcherBuilder> matcherBuilderFactory);
    internal Matcher get_CurrentMatcher();
    public virtual Task MatchAsync(HttpContext httpContext);
    private Matcher CreateMatcher(IReadOnlyList`1<Endpoint> endpoints);
}
internal class Microsoft.AspNetCore.Routing.Matching.DefaultEndpointSelector : EndpointSelector {
    public virtual Task SelectAsync(HttpContext httpContext, CandidateSet candidateSet);
    internal static void Select(HttpContext httpContext, CandidateState[] candidateState);
    private static void ProcessFinalCandidates(HttpContext httpContext, CandidateState[] candidateState);
    private static void ReportAmbiguity(CandidateState[] candidateState);
}
internal class Microsoft.AspNetCore.Routing.Matching.DfaMatcher : Matcher {
    private ILogger _logger;
    private EndpointSelector _selector;
    private DfaState[] _states;
    private int _maxSegmentCount;
    private bool _isDefaultEndpointSelector;
    public DfaMatcher(ILogger`1<DfaMatcher> logger, EndpointSelector selector, DfaState[] states, int maxSegmentCount);
    public sealed virtual Task MatchAsync(HttpContext httpContext);
    internal ValueTuple`2<Candidate[], IEndpointSelectorPolicy[]> FindCandidateSet(HttpContext httpContext, string path, ReadOnlySpan`1<PathSegment> segments);
    private void ProcessCaptures(KeyValuePair`2[] slots, ValueTuple`3[] captures, string path, ReadOnlySpan`1<PathSegment> segments);
    private void ProcessCatchAll(KeyValuePair`2[] slots, ValueTuple`3& catchAll, string path, ReadOnlySpan`1<PathSegment> segments);
    private bool ProcessComplexSegments(Endpoint endpoint, ValueTuple`2[] complexSegments, string path, ReadOnlySpan`1<PathSegment> segments, RouteValueDictionary values);
    private bool ProcessConstraints(Endpoint endpoint, KeyValuePair`2[] constraints, HttpContext httpContext, RouteValueDictionary values);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.Matching.DfaMatcher/<SelectEndpointWithPoliciesAsync>d__12")]
private Task SelectEndpointWithPoliciesAsync(HttpContext httpContext, IEndpointSelectorPolicy[] policies, CandidateSet candidateSet);
}
internal class Microsoft.AspNetCore.Routing.Matching.DfaMatcherBuilder : MatcherBuilder {
    private List`1<RouteEndpoint> _endpoints;
    private ILoggerFactory _loggerFactory;
    private ParameterPolicyFactory _parameterPolicyFactory;
    private EndpointSelector _selector;
    private IEndpointSelectorPolicy[] _endpointSelectorPolicies;
    private INodeBuilderPolicy[] _nodeBuilders;
    private EndpointComparer _comparer;
    private Dictionary`2<string, int> _assignments;
    private List`1<KeyValuePair`2<string, object>> _slots;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`3<string, int, int>> _captures;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<RoutePatternPathSegment, int>> _complexSegments;
    private List`1<KeyValuePair`2<string, IRouteConstraint>> _constraints;
    private int _stateIndex;
    [CompilerGeneratedAttribute]
private bool <UseCorrectCatchAllBehavior>k__BackingField;
    internal EndpointComparer Comparer { get; }
    internal bool UseCorrectCatchAllBehavior { get; internal set; }
    public DfaMatcherBuilder(ILoggerFactory loggerFactory, ParameterPolicyFactory parameterPolicyFactory, EndpointSelector selector, IEnumerable`1<MatcherPolicy> policies);
    internal EndpointComparer get_Comparer();
    [CompilerGeneratedAttribute]
internal bool get_UseCorrectCatchAllBehavior();
    [CompilerGeneratedAttribute]
internal void set_UseCorrectCatchAllBehavior(bool value);
    public virtual void AddEndpoint(RouteEndpoint endpoint);
    public DfaNode BuildDfaTree(bool includeLabel);
    private static void AddLiteralNode(bool includeLabel, List`1<DfaNode> nextParents, DfaNode parent, string literal);
    private static RoutePatternPathSegment GetCurrentSegment(RouteEndpoint endpoint, int depth);
    private static int GetPrecedenceDigitAtDepth(RouteEndpoint endpoint, int depth);
    public virtual Matcher Build();
    private int AddNode(DfaNode node, DfaState[] states, int exitDestination);
    private static PolicyJumpTable BuildPolicy(int exitDestination, INodeBuilderPolicy nodeBuilder, PolicyJumpTableEdge[] policyEntries);
    internal Candidate[] CreateCandidates(IReadOnlyList`1<Endpoint> endpoints);
    internal Candidate CreateCandidate(Endpoint endpoint, int score);
    private Int32[] GetGroupLengths(DfaNode node);
    private static bool HasAdditionalRequiredSegments(RouteEndpoint endpoint, int depth);
    private void ApplyPolicies(DfaNode node);
    private static ValueTuple`3<INodeBuilderPolicy[], IEndpointComparerPolicy[], IEndpointSelectorPolicy[]> ExtractPolicies(IEnumerable`1<MatcherPolicy> policies);
    private static bool TryGetRequiredValue(RoutePattern routePattern, RoutePatternParameterPart parameterPart, Object& value);
    [CompilerGeneratedAttribute]
private int <AddNode>g__Transition|26_0(DfaNode next, <>c__DisplayClass26_0& );
}
internal class Microsoft.AspNetCore.Routing.Matching.DfaMatcherFactory : MatcherFactory {
    private IServiceProvider _services;
    public DfaMatcherFactory(IServiceProvider services);
    public virtual Matcher CreateMatcher(EndpointDataSource dataSource);
    [CompilerGeneratedAttribute]
private MatcherBuilder <CreateMatcher>b__2_0();
}
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
internal class Microsoft.AspNetCore.Routing.Matching.DfaNode : object {
    [CompilerGeneratedAttribute]
private int <PathDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Endpoint> <Matches>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, DfaNode> <Literals>k__BackingField;
    [CompilerGeneratedAttribute]
private DfaNode <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private DfaNode <CatchAll>k__BackingField;
    [CompilerGeneratedAttribute]
private INodeBuilderPolicy <NodeBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<object, DfaNode> <PolicyEdges>k__BackingField;
    public int PathDepth { get; public set; }
    public string Label { get; public set; }
    public List`1<Endpoint> Matches { get; private set; }
    public Dictionary`2<string, DfaNode> Literals { get; private set; }
    public DfaNode Parameters { get; public set; }
    public DfaNode CatchAll { get; public set; }
    public INodeBuilderPolicy NodeBuilder { get; public set; }
    public Dictionary`2<object, DfaNode> PolicyEdges { get; private set; }
    [CompilerGeneratedAttribute]
public int get_PathDepth();
    [CompilerGeneratedAttribute]
public void set_PathDepth(int value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public List`1<Endpoint> get_Matches();
    [CompilerGeneratedAttribute]
private void set_Matches(List`1<Endpoint> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, DfaNode> get_Literals();
    [CompilerGeneratedAttribute]
private void set_Literals(Dictionary`2<string, DfaNode> value);
    [CompilerGeneratedAttribute]
public DfaNode get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(DfaNode value);
    [CompilerGeneratedAttribute]
public DfaNode get_CatchAll();
    [CompilerGeneratedAttribute]
public void set_CatchAll(DfaNode value);
    [CompilerGeneratedAttribute]
public INodeBuilderPolicy get_NodeBuilder();
    [CompilerGeneratedAttribute]
public void set_NodeBuilder(INodeBuilderPolicy value);
    [CompilerGeneratedAttribute]
public Dictionary`2<object, DfaNode> get_PolicyEdges();
    [CompilerGeneratedAttribute]
private void set_PolicyEdges(Dictionary`2<object, DfaNode> value);
    public void AddPolicyEdge(object state, DfaNode node);
    public void AddLiteral(string literal, DfaNode node);
    public void AddMatch(Endpoint endpoint);
    public void AddMatches(IEnumerable`1<Endpoint> endpoints);
    public void Visit(Action`1<DfaNode> visitor);
    private string DebuggerToString();
    [CompilerGeneratedAttribute]
private string <DebuggerToString>b__37_0(KeyValuePair`2<string, DfaNode> kvp);
    [CompilerGeneratedAttribute]
private string <DebuggerToString>g__FormatNode|37_1(DfaNode other);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
internal class Microsoft.AspNetCore.Routing.Matching.DfaState : ValueType {
    public Candidate[] Candidates;
    public IEndpointSelectorPolicy[] Policies;
    public JumpTable PathTransitions;
    public PolicyJumpTable PolicyTransitions;
    public DfaState(Candidate[] candidates, IEndpointSelectorPolicy[] policies, JumpTable pathTransitions, PolicyJumpTable policyTransitions);
    public string DebuggerToString();
}
internal class Microsoft.AspNetCore.Routing.Matching.DictionaryJumpTable : JumpTable {
    private int _defaultDestination;
    private int _exitDestination;
    private Dictionary`2<string, int> _dictionary;
    public DictionaryJumpTable(int defaultDestination, int exitDestination, ValueTuple`2[] entries);
    public virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
internal class Microsoft.AspNetCore.Routing.Matching.EndpointComparer : object {
    private IComparer`1[] _comparers;
    public EndpointComparer(IEndpointComparerPolicy[] policies);
    public sealed virtual int Compare(Endpoint x, Endpoint y);
    private int ComparePattern(Endpoint x, Endpoint y);
    public sealed virtual bool Equals(Endpoint x, Endpoint y);
    public sealed virtual int GetHashCode(Endpoint obj);
    private int CompareCore(Endpoint x, Endpoint y);
}
public class Microsoft.AspNetCore.Routing.Matching.EndpointMetadataComparer : object {
    private IServiceProvider _services;
    private IComparer`1[] _comparers;
    private IComparer`1[] Comparers { get; }
    internal EndpointMetadataComparer(IServiceProvider services);
    private IComparer`1[] get_Comparers();
    private sealed virtual override int System.Collections.Generic.IComparer<Microsoft.AspNetCore.Http.Endpoint>.Compare(Endpoint x, Endpoint y);
}
public abstract class Microsoft.AspNetCore.Routing.Matching.EndpointMetadataComparer`1 : object {
    public static EndpointMetadataComparer`1<TMetadata> Default;
    private static EndpointMetadataComparer`1();
    public sealed virtual int Compare(Endpoint x, Endpoint y);
    protected virtual TMetadata GetMetadata(Endpoint endpoint);
    protected virtual int CompareMetadata(TMetadata x, TMetadata y);
}
public abstract class Microsoft.AspNetCore.Routing.Matching.EndpointSelector : object {
    public abstract virtual Task SelectAsync(HttpContext httpContext, CandidateSet candidates);
}
internal static class Microsoft.AspNetCore.Routing.Matching.FastPathTokenizer : object {
    public static int Tokenize(string path, Span`1<PathSegment> segments);
}
public class Microsoft.AspNetCore.Routing.Matching.HostMatcherPolicy : MatcherPolicy {
    private static string WildcardHost;
    private static string WildcardPrefix;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparer`1<Endpoint> <Comparer>k__BackingField;
    public int Order { get; }
    public IComparer`1<Endpoint> Comparer { get; }
    [CompilerGeneratedAttribute]
public virtual int get_Order();
    [CompilerGeneratedAttribute]
public sealed virtual IComparer`1<Endpoint> get_Comparer();
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.INodeBuilderPolicy.AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IEndpointSelectorPolicy.AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    private bool AppliesToEndpointsCore(IReadOnlyList`1<Endpoint> endpoints);
    public sealed virtual Task ApplyAsync(HttpContext httpContext, CandidateSet candidates);
    private static EdgeKey CreateEdgeKey(string host);
    public sealed virtual IReadOnlyList`1<PolicyNodeEdge> GetEdges(IReadOnlyList`1<Endpoint> endpoints);
    public sealed virtual PolicyJumpTable BuildJumpTable(int exitDestination, IReadOnlyList`1<PolicyJumpTableEdge> edges);
    private int GetScore(EdgeKey& key);
    private static ValueTuple`2<string, Nullable`1<int>> GetHostAndPort(HttpContext httpContext);
    [CompilerGeneratedAttribute]
private int <BuildJumpTable>b__14_1(ValueTuple`2<EdgeKey, int> e);
}
public class Microsoft.AspNetCore.Routing.Matching.HttpMethodMatcherPolicy : MatcherPolicy {
    internal static string OriginHeader;
    internal static string AccessControlRequestMethod;
    internal static string PreflightHttpMethod;
    internal static string Http405EndpointDisplayName;
    internal static string AnyMethod;
    public IComparer`1<Endpoint> Comparer { get; }
    public int Order { get; }
    private static HttpMethodMatcherPolicy();
    public sealed virtual IComparer`1<Endpoint> get_Comparer();
    public virtual int get_Order();
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.INodeBuilderPolicy.AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IEndpointSelectorPolicy.AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    private bool AppliesToEndpointsCore(IReadOnlyList`1<Endpoint> endpoints);
    public sealed virtual Task ApplyAsync(HttpContext httpContext, CandidateSet candidates);
    public sealed virtual IReadOnlyList`1<PolicyNodeEdge> GetEdges(IReadOnlyList`1<Endpoint> endpoints);
    public sealed virtual PolicyJumpTable BuildJumpTable(int exitDestination, IReadOnlyList`1<PolicyJumpTableEdge> edges);
    private Endpoint CreateRejectionEndpoint(IEnumerable`1<string> httpMethods);
    private static bool ContainsHttpMethod(List`1<string> httpMethods, string httpMethod);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<IReadOnlyList`1<string>, bool> <GetEdges>g__GetHttpMethods|13_0(Endpoint e);
}
public interface Microsoft.AspNetCore.Routing.Matching.IEndpointComparerPolicy {
    public IComparer`1<Endpoint> Comparer { get; }
    public abstract virtual IComparer`1<Endpoint> get_Comparer();
}
public interface Microsoft.AspNetCore.Routing.Matching.IEndpointSelectorPolicy {
    public abstract virtual bool AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    public abstract virtual Task ApplyAsync(HttpContext httpContext, CandidateSet candidates);
}
internal static class Microsoft.AspNetCore.Routing.Matching.ILEmitTrieFactory : object {
    public static int NotAscii;
    public static Func`4<string, int, int, int> Create(int defaultDestination, int exitDestination, ValueTuple`2[] entries, Nullable`1<bool> vectorize);
    internal static bool ShouldVectorize(ValueTuple`2[] entries);
    private static void GenerateMethodBody(ILGenerator il, int defaultDestination, int exitDestination, ValueTuple`2[] entries, Nullable`1<bool> vectorize);
    private static void EmitTable(ILGenerator il, ValueTuple`2[] entries, int index, int length, Locals locals, Labels labels, Methods methods);
    private static void EmitVectorizedTable(ILGenerator il, ValueTuple`2[] entries, int index, int length, Locals locals, Labels labels, Methods methods);
    private static void EmitSingleCharacterTable(ILGenerator il, ValueTuple`2[] entries, int index, int length, Locals locals, Labels labels, Methods methods);
    public static void EmitReturnDestination(ILGenerator il, ValueTuple`2[] entries);
    private static ulong GetUInt64Key(string text, int index);
    private static ushort GetUInt16Key(string text, int index);
}
internal class Microsoft.AspNetCore.Routing.Matching.ILEmitTrieJumpTable : JumpTable {
    private static int NotAscii;
    private int _defaultDestination;
    private int _exitDestination;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _entries;
    private Nullable`1<bool> _vectorize;
    private JumpTable _fallback;
    private object _lock;
    private bool _initializing;
    private Task _task;
    internal Func`3<string, PathSegment, int> _getDestination;
    public ILEmitTrieJumpTable(int defaultDestination, int exitDestination, ValueTuple`2[] entries, Nullable`1<bool> vectorize, JumpTable fallback);
    public virtual int GetDestination(string path, PathSegment segment);
    private int FallbackGetDestination(string path, PathSegment segment);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.Matching.ILEmitTrieJumpTable/<InitializeILDelegateAsync>d__13")]
internal Task InitializeILDelegateAsync();
    internal void InitializeILDelegate();
    [CompilerGeneratedAttribute]
private void <InitializeILDelegateAsync>b__13_0();
}
public interface Microsoft.AspNetCore.Routing.Matching.INodeBuilderPolicy {
    public abstract virtual bool AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    public abstract virtual IReadOnlyList`1<PolicyNodeEdge> GetEdges(IReadOnlyList`1<Endpoint> endpoints);
    public abstract virtual PolicyJumpTable BuildJumpTable(int exitDestination, IReadOnlyList`1<PolicyJumpTableEdge> edges);
}
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
internal abstract class Microsoft.AspNetCore.Routing.Matching.JumpTable : object {
    public abstract virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
internal static class Microsoft.AspNetCore.Routing.Matching.JumpTableBuilder : object {
    public static int InvalidDestination;
    private static JumpTableBuilder();
    public static JumpTable Build(int defaultDestination, int exitDestination, ValueTuple`2[] pathEntries);
}
internal class Microsoft.AspNetCore.Routing.Matching.LinearSearchJumpTable : JumpTable {
    private int _defaultDestination;
    private int _exitDestination;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _entries;
    public LinearSearchJumpTable(int defaultDestination, int exitDestination, ValueTuple`2[] entries);
    public virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
internal abstract class Microsoft.AspNetCore.Routing.Matching.Matcher : object {
    public abstract virtual Task MatchAsync(HttpContext httpContext);
}
internal abstract class Microsoft.AspNetCore.Routing.Matching.MatcherBuilder : object {
    public abstract virtual void AddEndpoint(RouteEndpoint endpoint);
    public abstract virtual Matcher Build();
}
internal abstract class Microsoft.AspNetCore.Routing.Matching.MatcherFactory : object {
    public abstract virtual Matcher CreateMatcher(EndpointDataSource dataSource);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Routing.Matching.PathSegment : ValueType {
    public int Start;
    public int Length;
    public PathSegment(int start, int length);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PathSegment other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class Microsoft.AspNetCore.Routing.Matching.PolicyJumpTable : object {
    public abstract virtual int GetDestination(HttpContext httpContext);
    internal virtual string DebuggerToString();
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Routing.Matching.PolicyJumpTableEdge : ValueType {
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Destination>k__BackingField;
    public object State { get; }
    public int Destination { get; }
    public PolicyJumpTableEdge(object state, int destination);
    [CompilerGeneratedAttribute]
public object get_State();
    [CompilerGeneratedAttribute]
public int get_Destination();
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Routing.Matching.PolicyNodeEdge : ValueType {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Endpoint> <Endpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    public IReadOnlyList`1<Endpoint> Endpoints { get; }
    public object State { get; }
    public PolicyNodeEdge(object state, IReadOnlyList`1<Endpoint> endpoints);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Endpoint> get_Endpoints();
    [CompilerGeneratedAttribute]
public object get_State();
}
internal class Microsoft.AspNetCore.Routing.Matching.SingleEntryAsciiJumpTable : JumpTable {
    private int _defaultDestination;
    private int _exitDestination;
    private string _text;
    private int _destination;
    public SingleEntryAsciiJumpTable(int defaultDestination, int exitDestination, string text, int destination);
    public virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
internal class Microsoft.AspNetCore.Routing.Matching.SingleEntryJumpTable : JumpTable {
    private int _defaultDestination;
    private int _exitDestination;
    private string _text;
    private int _destination;
    public SingleEntryJumpTable(int defaultDestination, int exitDestination, string text, int destination);
    public virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
internal class Microsoft.AspNetCore.Routing.Matching.ZeroEntryJumpTable : JumpTable {
    private int _defaultDestination;
    private int _exitDestination;
    public ZeroEntryJumpTable(int defaultDestination, int exitDestination);
    public virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
internal class Microsoft.AspNetCore.Routing.ModelEndpointDataSource : EndpointDataSource {
    private List`1<DefaultEndpointConventionBuilder> _endpointConventionBuilders;
    public IReadOnlyList`1<Endpoint> Endpoints { get; }
    internal IEnumerable`1<EndpointBuilder> EndpointBuilders { get; }
    public IEndpointConventionBuilder AddEndpointBuilder(EndpointBuilder endpointBuilder);
    public virtual IChangeToken GetChangeToken();
    public virtual IReadOnlyList`1<Endpoint> get_Endpoints();
    internal IEnumerable`1<EndpointBuilder> get_EndpointBuilders();
}
internal class Microsoft.AspNetCore.Routing.NullRouter : object {
    public static NullRouter Instance;
    private static NullRouter();
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    public sealed virtual Task RouteAsync(RouteContext context);
}
internal static class Microsoft.AspNetCore.Routing.ParameterPolicyActivator : object {
    public static T ResolveParameterPolicy(IDictionary`2<string, Type> inlineParameterPolicyMap, IServiceProvider serviceProvider, string inlineParameterPolicy, String& parameterPolicyKey);
    private static IParameterPolicy CreateParameterPolicy(IServiceProvider serviceProvider, Type parameterPolicyType, string argumentString);
    private static int GetNonConvertableParameterTypeCount(IServiceProvider serviceProvider, ParameterInfo[] parameters);
    private static Object[] ConvertArguments(IServiceProvider serviceProvider, ParameterInfo[] parameterInfos, String[] arguments);
}
public abstract class Microsoft.AspNetCore.Routing.ParameterPolicyFactory : object {
    public abstract virtual IParameterPolicy Create(RoutePatternParameterPart parameter, string inlineText);
    public abstract virtual IParameterPolicy Create(RoutePatternParameterPart parameter, IParameterPolicy parameterPolicy);
    public IParameterPolicy Create(RoutePatternParameterPart parameter, RoutePatternParameterPolicyReference reference);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Routing.PathTokenizer : ValueType {
    private string _path;
    private int _count;
    public int Count { get; }
    public StringSegment Item { get; }
    public PathTokenizer(PathString path);
    public sealed virtual int get_Count();
    public sealed virtual StringSegment get_Item(int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<StringSegment> System.Collections.Generic.IEnumerable<Microsoft.Extensions.Primitives.StringSegment>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.AspNetCore.Routing.Patterns.DefaultRoutePatternTransformer : RoutePatternTransformer {
    private ParameterPolicyFactory _policyFactory;
    public DefaultRoutePatternTransformer(ParameterPolicyFactory policyFactory);
    public virtual RoutePattern SubstituteRequiredValues(RoutePattern original, object requiredValues);
    private RoutePattern SubstituteRequiredValuesCore(RoutePattern original, RouteValueDictionary requiredValues);
    private bool MatchesConstraints(RoutePattern pattern, RoutePatternParameterPart parameter, string key, RouteValueDictionary requiredValues);
    private void RemoveParameterDefault(List`1<RoutePatternPathSegment> segments, List`1<RoutePatternParameterPart> parameters, RoutePatternParameterPart parameter);
}
internal static class Microsoft.AspNetCore.Routing.Patterns.RouteParameterParser : object {
    public static RoutePatternParameterPart ParseRouteParameter(string parameter);
    private static ParameterPolicyParseResults ParseConstraints(string text, int currentIndex, int endIndex);
}
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePattern : object {
    public static object RequiredValueAny;
    private static string SeparatorString;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyList`1<RoutePatternParameterPolicyReference>> <ParameterPolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <RequiredValues>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <InboundPrecedence>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <OutboundPrecedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawText>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RoutePatternParameterPart> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RoutePatternPathSegment> <PathSegments>k__BackingField;
    public IReadOnlyDictionary`2<string, object> Defaults { get; }
    public IReadOnlyDictionary`2<string, IReadOnlyList`1<RoutePatternParameterPolicyReference>> ParameterPolicies { get; }
    public IReadOnlyDictionary`2<string, object> RequiredValues { get; }
    public decimal InboundPrecedence { get; }
    public decimal OutboundPrecedence { get; }
    public string RawText { get; }
    public IReadOnlyList`1<RoutePatternParameterPart> Parameters { get; }
    public IReadOnlyList`1<RoutePatternPathSegment> PathSegments { get; }
    internal RoutePattern(string rawText, IReadOnlyDictionary`2<string, object> defaults, IReadOnlyDictionary`2<string, IReadOnlyList`1<RoutePatternParameterPolicyReference>> parameterPolicies, IReadOnlyDictionary`2<string, object> requiredValues, IReadOnlyList`1<RoutePatternParameterPart> parameters, IReadOnlyList`1<RoutePatternPathSegment> pathSegments);
    private static RoutePattern();
    internal static bool IsRequiredValueAny(object value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Defaults();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, IReadOnlyList`1<RoutePatternParameterPolicyReference>> get_ParameterPolicies();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_RequiredValues();
    [CompilerGeneratedAttribute]
public decimal get_InboundPrecedence();
    [CompilerGeneratedAttribute]
public decimal get_OutboundPrecedence();
    [CompilerGeneratedAttribute]
public string get_RawText();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RoutePatternParameterPart> get_Parameters();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RoutePatternPathSegment> get_PathSegments();
    public RoutePatternParameterPart GetParameter(string name);
    internal string DebuggerToString();
}
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternException : Exception {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    public string Pattern { get; }
    private RoutePatternException(SerializationInfo info, StreamingContext context);
    public RoutePatternException(string pattern, string message);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public static class Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory : object {
    private static IReadOnlyDictionary`2<string, object> EmptyDictionary;
    private static IReadOnlyDictionary`2<string, IReadOnlyList`1<RoutePatternParameterPolicyReference>> EmptyPoliciesDictionary;
    private static RoutePatternFactory();
    public static RoutePattern Parse(string pattern);
    public static RoutePattern Parse(string pattern, object defaults, object parameterPolicies);
    public static RoutePattern Parse(string pattern, object defaults, object parameterPolicies, object requiredValues);
    public static RoutePattern Pattern(IEnumerable`1<RoutePatternPathSegment> segments);
    public static RoutePattern Pattern(string rawText, IEnumerable`1<RoutePatternPathSegment> segments);
    public static RoutePattern Pattern(object defaults, object parameterPolicies, IEnumerable`1<RoutePatternPathSegment> segments);
    public static RoutePattern Pattern(string rawText, object defaults, object parameterPolicies, IEnumerable`1<RoutePatternPathSegment> segments);
    public static RoutePattern Pattern(RoutePatternPathSegment[] segments);
    public static RoutePattern Pattern(string rawText, RoutePatternPathSegment[] segments);
    public static RoutePattern Pattern(object defaults, object parameterPolicies, RoutePatternPathSegment[] segments);
    public static RoutePattern Pattern(string rawText, object defaults, object parameterPolicies, RoutePatternPathSegment[] segments);
    private static RoutePattern PatternCore(string rawText, RouteValueDictionary defaults, RouteValueDictionary parameterPolicies, RouteValueDictionary requiredValues, IEnumerable`1<RoutePatternPathSegment> segments);
    public static RoutePatternPathSegment Segment(IEnumerable`1<RoutePatternPart> parts);
    public static RoutePatternPathSegment Segment(RoutePatternPart[] parts);
    private static RoutePatternPathSegment SegmentCore(RoutePatternPart[] parts);
    public static RoutePatternLiteralPart LiteralPart(string content);
    private static RoutePatternLiteralPart LiteralPartCore(string content);
    public static RoutePatternSeparatorPart SeparatorPart(string content);
    private static RoutePatternSeparatorPart SeparatorPartCore(string content);
    public static RoutePatternParameterPart ParameterPart(string parameterName);
    public static RoutePatternParameterPart ParameterPart(string parameterName, object default);
    public static RoutePatternParameterPart ParameterPart(string parameterName, object default, RoutePatternParameterKind parameterKind);
    public static RoutePatternParameterPart ParameterPart(string parameterName, object default, RoutePatternParameterKind parameterKind, IEnumerable`1<RoutePatternParameterPolicyReference> parameterPolicies);
    public static RoutePatternParameterPart ParameterPart(string parameterName, object default, RoutePatternParameterKind parameterKind, RoutePatternParameterPolicyReference[] parameterPolicies);
    private static RoutePatternParameterPart ParameterPartCore(string parameterName, object default, RoutePatternParameterKind parameterKind, RoutePatternParameterPolicyReference[] parameterPolicies);
    private static RoutePatternParameterPart ParameterPartCore(string parameterName, object default, RoutePatternParameterKind parameterKind, RoutePatternParameterPolicyReference[] parameterPolicies, bool encodeSlashes);
    public static RoutePatternParameterPolicyReference Constraint(object constraint);
    public static RoutePatternParameterPolicyReference Constraint(IRouteConstraint constraint);
    public static RoutePatternParameterPolicyReference Constraint(string constraint);
    public static RoutePatternParameterPolicyReference ParameterPolicy(IParameterPolicy parameterPolicy);
    public static RoutePatternParameterPolicyReference ParameterPolicy(string parameterPolicy);
    private static RoutePatternParameterPolicyReference ParameterPolicyCore(string parameterPolicy);
    private static RoutePatternParameterPolicyReference ParameterPolicyCore(IParameterPolicy parameterPolicy);
    private static RouteValueDictionary Wrap(object values);
    [CompilerGeneratedAttribute]
internal static RoutePatternPathSegment <PatternCore>g__VisitSegment|13_2(RoutePatternPathSegment segment, <>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
internal static RoutePatternPart <PatternCore>g__VisitPart|13_3(RoutePatternPart part, <>c__DisplayClass13_0& );
}
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternLiteralPart : RoutePatternPart {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public string Content { get; }
    internal RoutePatternLiteralPart(string content);
    [CompilerGeneratedAttribute]
public string get_Content();
    internal virtual string DebuggerToString();
}
public enum Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterKind : Enum {
    public int value__;
    public static RoutePatternParameterKind Standard;
    public static RoutePatternParameterKind Optional;
    public static RoutePatternParameterKind CatchAll;
}
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPart : RoutePatternPart {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RoutePatternParameterPolicyReference> <ParameterPolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EncodeSlashes>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private RoutePatternParameterKind <ParameterKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IReadOnlyList`1<RoutePatternParameterPolicyReference> ParameterPolicies { get; }
    public bool EncodeSlashes { get; }
    public object Default { get; }
    public bool IsCatchAll { get; }
    public bool IsOptional { get; }
    public RoutePatternParameterKind ParameterKind { get; }
    public string Name { get; }
    internal RoutePatternParameterPart(string parameterName, object default, RoutePatternParameterKind parameterKind, RoutePatternParameterPolicyReference[] parameterPolicies);
    internal RoutePatternParameterPart(string parameterName, object default, RoutePatternParameterKind parameterKind, RoutePatternParameterPolicyReference[] parameterPolicies, bool encodeSlashes);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RoutePatternParameterPolicyReference> get_ParameterPolicies();
    [CompilerGeneratedAttribute]
public bool get_EncodeSlashes();
    [CompilerGeneratedAttribute]
public object get_Default();
    public bool get_IsCatchAll();
    public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public RoutePatternParameterKind get_ParameterKind();
    [CompilerGeneratedAttribute]
public string get_Name();
    internal virtual string DebuggerToString();
}
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPolicyReference : object {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameterPolicy <ParameterPolicy>k__BackingField;
    public string Content { get; }
    public IParameterPolicy ParameterPolicy { get; }
    internal RoutePatternParameterPolicyReference(string content);
    internal RoutePatternParameterPolicyReference(IParameterPolicy parameterPolicy);
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public IParameterPolicy get_ParameterPolicy();
    private string DebuggerToString();
}
internal static class Microsoft.AspNetCore.Routing.Patterns.RoutePatternParser : object {
    private static char Separator;
    private static char OpenBrace;
    private static char CloseBrace;
    private static char EqualsSign;
    private static char QuestionMark;
    private static char Asterisk;
    private static string PeriodString;
    internal static Char[] InvalidParameterNameChars;
    private static RoutePatternParser();
    public static RoutePattern Parse(string pattern);
    private static bool ParseSegment(Context context, List`1<RoutePatternPathSegment> segments);
    private static bool ParseParameter(Context context, List`1<RoutePatternPart> parts);
    private static bool ParseLiteral(Context context, List`1<RoutePatternPart> parts);
    private static bool IsAllValid(Context context, List`1<RoutePatternPathSegment> segments);
    private static bool IsSegmentValid(Context context, List`1<RoutePatternPart> parts);
    private static bool IsValidParameterName(Context context, string parameterName);
    private static bool IsValidLiteral(Context context, string literal);
    private static string TrimPrefix(string routePattern);
}
public abstract class Microsoft.AspNetCore.Routing.Patterns.RoutePatternPart : object {
    [CompilerGeneratedAttribute]
private RoutePatternPartKind <PartKind>k__BackingField;
    public RoutePatternPartKind PartKind { get; }
    public bool IsLiteral { get; }
    public bool IsParameter { get; }
    public bool IsSeparator { get; }
    private protected RoutePatternPart(RoutePatternPartKind partKind);
    [CompilerGeneratedAttribute]
public RoutePatternPartKind get_PartKind();
    public bool get_IsLiteral();
    public bool get_IsParameter();
    public bool get_IsSeparator();
    internal abstract virtual string DebuggerToString();
}
public enum Microsoft.AspNetCore.Routing.Patterns.RoutePatternPartKind : Enum {
    public int value__;
    public static RoutePatternPartKind Literal;
    public static RoutePatternPartKind Parameter;
    public static RoutePatternPartKind Separator;
}
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RoutePatternPart> <Parts>k__BackingField;
    public bool IsSimple { get; }
    public IReadOnlyList`1<RoutePatternPart> Parts { get; }
    internal RoutePatternPathSegment(IReadOnlyList`1<RoutePatternPart> parts);
    public bool get_IsSimple();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RoutePatternPart> get_Parts();
    internal string DebuggerToString();
    internal static string DebuggerToString(IReadOnlyList`1<RoutePatternPart> parts);
}
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternSeparatorPart : RoutePatternPart {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public string Content { get; }
    internal RoutePatternSeparatorPart(string content);
    [CompilerGeneratedAttribute]
public string get_Content();
    internal virtual string DebuggerToString();
}
public abstract class Microsoft.AspNetCore.Routing.Patterns.RoutePatternTransformer : object {
    public abstract virtual RoutePattern SubstituteRequiredValues(RoutePattern original, object requiredValues);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions : object {
    [ExtensionAttribute]
public static IRouteBuilder MapRoute(IRouteBuilder builder, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewareRoute(IRouteBuilder builder, string template, Action`1<IApplicationBuilder> action);
    [ExtensionAttribute]
public static IRouteBuilder MapDelete(IRouteBuilder builder, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewareDelete(IRouteBuilder builder, string template, Action`1<IApplicationBuilder> action);
    [ExtensionAttribute]
public static IRouteBuilder MapDelete(IRouteBuilder builder, string template, Func`4<HttpRequest, HttpResponse, RouteData, Task> handler);
    [ExtensionAttribute]
public static IRouteBuilder MapGet(IRouteBuilder builder, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewareGet(IRouteBuilder builder, string template, Action`1<IApplicationBuilder> action);
    [ExtensionAttribute]
public static IRouteBuilder MapGet(IRouteBuilder builder, string template, Func`4<HttpRequest, HttpResponse, RouteData, Task> handler);
    [ExtensionAttribute]
public static IRouteBuilder MapPost(IRouteBuilder builder, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewarePost(IRouteBuilder builder, string template, Action`1<IApplicationBuilder> action);
    [ExtensionAttribute]
public static IRouteBuilder MapPost(IRouteBuilder builder, string template, Func`4<HttpRequest, HttpResponse, RouteData, Task> handler);
    [ExtensionAttribute]
public static IRouteBuilder MapPut(IRouteBuilder builder, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewarePut(IRouteBuilder builder, string template, Action`1<IApplicationBuilder> action);
    [ExtensionAttribute]
public static IRouteBuilder MapPut(IRouteBuilder builder, string template, Func`4<HttpRequest, HttpResponse, RouteData, Task> handler);
    [ExtensionAttribute]
public static IRouteBuilder MapVerb(IRouteBuilder builder, string verb, string template, Func`4<HttpRequest, HttpResponse, RouteData, Task> handler);
    [ExtensionAttribute]
public static IRouteBuilder MapVerb(IRouteBuilder builder, string verb, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewareVerb(IRouteBuilder builder, string verb, string template, Action`1<IApplicationBuilder> action);
    private static IInlineConstraintResolver GetConstraintResolver(IRouteBuilder builder);
}
internal static class Microsoft.AspNetCore.Routing.Resources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentMustBeGreaterThanOrEqualTo { get; }
    internal static string RangeConstraint_MinShouldBeLessThanOrEqualToMax { get; }
    internal static string PropertyOfTypeCannotBeNull { get; }
    internal static string NamedRoutes_AmbiguousRoutesFound { get; }
    internal static string DefaultHandler_MustBeSet { get; }
    internal static string DefaultInlineConstraintResolver_AmbiguousCtors { get; }
    internal static string DefaultInlineConstraintResolver_CouldNotFindCtor { get; }
    internal static string DefaultInlineConstraintResolver_TypeNotConstraint { get; }
    internal static string TemplateRoute_CannotHaveCatchAllInMultiSegment { get; }
    internal static string TemplateRoute_CannotHaveDefaultValueSpecifiedInlineAndExplicitly { get; }
    internal static string TemplateRoute_CannotHaveConsecutiveParameters { get; }
    internal static string TemplateRoute_CannotHaveConsecutiveSeparators { get; }
    internal static string TemplateRoute_CatchAllCannotBeOptional { get; }
    internal static string TemplateRoute_OptionalCannotHaveDefaultValue { get; }
    internal static string TemplateRoute_CatchAllMustBeLast { get; }
    internal static string TemplateRoute_InvalidLiteral { get; }
    internal static string TemplateRoute_InvalidParameterName { get; }
    internal static string TemplateRoute_InvalidRouteTemplate { get; }
    internal static string TemplateRoute_MismatchedParameter { get; }
    internal static string TemplateRoute_RepeatedParameter { get; }
    internal static string RouteConstraintBuilder_ValidationMustBeStringOrCustomConstraint { get; }
    internal static string RouteConstraintBuilder_CouldNotResolveConstraint { get; }
    internal static string TemplateRoute_UnescapedBrace { get; }
    internal static string TemplateRoute_OptionalParameterCanbBePrecededByPeriod { get; }
    internal static string TemplateRoute_OptionalParameterHasTobeTheLast { get; }
    internal static string AttributeRoute_DifferentLinkGenerationEntries_SameName { get; }
    internal static string UnableToFindServices { get; }
    internal static string TemplateRoute_Exception { get; }
    internal static string AmbiguousEndpoints { get; }
    internal static string Argument_NullOrEmpty { get; }
    internal static string RoutePatternBuilder_CollectionCannotBeEmpty { get; }
    internal static string ConstraintMustBeStringOrConstraint { get; }
    internal static string RoutePattern_InvalidConstraintReference { get; }
    internal static string RoutePattern_InvalidParameterConstraintReference { get; }
    internal static string RoutePattern_ConstraintReferenceNotFound { get; }
    internal static string RoutePattern_InvalidStringConstraintReference { get; }
    internal static string DuplicateEndpointNameEntry { get; }
    internal static string DuplicateEndpointNameHeader { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_ArgumentMustBeGreaterThanOrEqualTo();
    internal static string FormatArgumentMustBeGreaterThanOrEqualTo(object p0);
    internal static string get_RangeConstraint_MinShouldBeLessThanOrEqualToMax();
    internal static string FormatRangeConstraint_MinShouldBeLessThanOrEqualToMax(object p0, object p1);
    internal static string get_PropertyOfTypeCannotBeNull();
    internal static string FormatPropertyOfTypeCannotBeNull(object p0, object p1);
    internal static string get_NamedRoutes_AmbiguousRoutesFound();
    internal static string FormatNamedRoutes_AmbiguousRoutesFound(object p0);
    internal static string get_DefaultHandler_MustBeSet();
    internal static string FormatDefaultHandler_MustBeSet(object p0);
    internal static string get_DefaultInlineConstraintResolver_AmbiguousCtors();
    internal static string FormatDefaultInlineConstraintResolver_AmbiguousCtors(object p0, object p1);
    internal static string get_DefaultInlineConstraintResolver_CouldNotFindCtor();
    internal static string FormatDefaultInlineConstraintResolver_CouldNotFindCtor(object p0, object p1);
    internal static string get_DefaultInlineConstraintResolver_TypeNotConstraint();
    internal static string FormatDefaultInlineConstraintResolver_TypeNotConstraint(object p0, object p1, object p2);
    internal static string get_TemplateRoute_CannotHaveCatchAllInMultiSegment();
    internal static string get_TemplateRoute_CannotHaveDefaultValueSpecifiedInlineAndExplicitly();
    internal static string FormatTemplateRoute_CannotHaveDefaultValueSpecifiedInlineAndExplicitly(object p0);
    internal static string get_TemplateRoute_CannotHaveConsecutiveParameters();
    internal static string get_TemplateRoute_CannotHaveConsecutiveSeparators();
    internal static string get_TemplateRoute_CatchAllCannotBeOptional();
    internal static string get_TemplateRoute_OptionalCannotHaveDefaultValue();
    internal static string get_TemplateRoute_CatchAllMustBeLast();
    internal static string get_TemplateRoute_InvalidLiteral();
    internal static string FormatTemplateRoute_InvalidLiteral(object p0);
    internal static string get_TemplateRoute_InvalidParameterName();
    internal static string FormatTemplateRoute_InvalidParameterName(object p0);
    internal static string get_TemplateRoute_InvalidRouteTemplate();
    internal static string get_TemplateRoute_MismatchedParameter();
    internal static string get_TemplateRoute_RepeatedParameter();
    internal static string FormatTemplateRoute_RepeatedParameter(object p0);
    internal static string get_RouteConstraintBuilder_ValidationMustBeStringOrCustomConstraint();
    internal static string FormatRouteConstraintBuilder_ValidationMustBeStringOrCustomConstraint(object p0, object p1, object p2, object p3);
    internal static string get_RouteConstraintBuilder_CouldNotResolveConstraint();
    internal static string FormatRouteConstraintBuilder_CouldNotResolveConstraint(object p0, object p1, object p2, object p3);
    internal static string get_TemplateRoute_UnescapedBrace();
    internal static string get_TemplateRoute_OptionalParameterCanbBePrecededByPeriod();
    internal static string FormatTemplateRoute_OptionalParameterCanbBePrecededByPeriod(object p0, object p1, object p2);
    internal static string get_TemplateRoute_OptionalParameterHasTobeTheLast();
    internal static string FormatTemplateRoute_OptionalParameterHasTobeTheLast(object p0, object p1, object p2);
    internal static string get_AttributeRoute_DifferentLinkGenerationEntries_SameName();
    internal static string FormatAttributeRoute_DifferentLinkGenerationEntries_SameName(object p0);
    internal static string get_UnableToFindServices();
    internal static string FormatUnableToFindServices(object p0, object p1, object p2);
    internal static string get_TemplateRoute_Exception();
    internal static string FormatTemplateRoute_Exception(object p0, object p1);
    internal static string get_AmbiguousEndpoints();
    internal static string FormatAmbiguousEndpoints(object p0, object p1);
    internal static string get_Argument_NullOrEmpty();
    internal static string get_RoutePatternBuilder_CollectionCannotBeEmpty();
    internal static string get_ConstraintMustBeStringOrConstraint();
    internal static string FormatConstraintMustBeStringOrConstraint(object p0, object p1, object p2);
    internal static string get_RoutePattern_InvalidConstraintReference();
    internal static string FormatRoutePattern_InvalidConstraintReference(object p0, object p1);
    internal static string get_RoutePattern_InvalidParameterConstraintReference();
    internal static string FormatRoutePattern_InvalidParameterConstraintReference(object p0, object p1, object p2, object p3);
    internal static string get_RoutePattern_ConstraintReferenceNotFound();
    internal static string FormatRoutePattern_ConstraintReferenceNotFound(object p0, object p1, object p2);
    internal static string get_RoutePattern_InvalidStringConstraintReference();
    internal static string FormatRoutePattern_InvalidStringConstraintReference(object p0, object p1, object p2, object p3);
    internal static string get_DuplicateEndpointNameEntry();
    internal static string FormatDuplicateEndpointNameEntry(object p0);
    internal static string get_DuplicateEndpointNameHeader();
}
public class Microsoft.AspNetCore.Routing.Route : RouteBase {
    private IRouter _target;
    public string RouteTemplate { get; }
    public Route(IRouter target, string routeTemplate, IInlineConstraintResolver inlineConstraintResolver);
    public Route(IRouter target, string routeTemplate, RouteValueDictionary defaults, IDictionary`2<string, object> constraints, RouteValueDictionary dataTokens, IInlineConstraintResolver inlineConstraintResolver);
    public Route(IRouter target, string routeName, string routeTemplate, RouteValueDictionary defaults, IDictionary`2<string, object> constraints, RouteValueDictionary dataTokens, IInlineConstraintResolver inlineConstraintResolver);
    public string get_RouteTemplate();
    protected virtual Task OnRouteMatched(RouteContext context);
    protected virtual VirtualPathData OnVirtualPathGenerated(VirtualPathContext context);
}
public abstract class Microsoft.AspNetCore.Routing.RouteBase : object {
    private object _loggersLock;
    private TemplateMatcher _matcher;
    private TemplateBinder _binder;
    private ILogger _logger;
    private ILogger _constraintLogger;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IRouteConstraint> <Constraints>k__BackingField;
    [CompilerGeneratedAttribute]
private IInlineConstraintResolver <ConstraintResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <DataTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteTemplate <ParsedTemplate>k__BackingField;
    public IDictionary`2<string, IRouteConstraint> Constraints { get; protected set; }
    protected IInlineConstraintResolver ConstraintResolver { get; protected set; }
    public RouteValueDictionary DataTokens { get; protected set; }
    public RouteValueDictionary Defaults { get; protected set; }
    public string Name { get; protected set; }
    public RouteTemplate ParsedTemplate { get; protected set; }
    public RouteBase(string template, string name, IInlineConstraintResolver constraintResolver, RouteValueDictionary defaults, IDictionary`2<string, object> constraints, RouteValueDictionary dataTokens);
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<string, IRouteConstraint> get_Constraints();
    [CompilerGeneratedAttribute]
protected virtual void set_Constraints(IDictionary`2<string, IRouteConstraint> value);
    [CompilerGeneratedAttribute]
protected virtual IInlineConstraintResolver get_ConstraintResolver();
    [CompilerGeneratedAttribute]
protected virtual void set_ConstraintResolver(IInlineConstraintResolver value);
    [CompilerGeneratedAttribute]
public virtual RouteValueDictionary get_DataTokens();
    [CompilerGeneratedAttribute]
protected virtual void set_DataTokens(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public virtual RouteValueDictionary get_Defaults();
    [CompilerGeneratedAttribute]
protected virtual void set_Defaults(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
protected virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual RouteTemplate get_ParsedTemplate();
    [CompilerGeneratedAttribute]
protected virtual void set_ParsedTemplate(RouteTemplate value);
    protected abstract virtual Task OnRouteMatched(RouteContext context);
    protected abstract virtual VirtualPathData OnVirtualPathGenerated(VirtualPathContext context);
    public virtual Task RouteAsync(RouteContext context);
    public virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    protected static IDictionary`2<string, IRouteConstraint> GetConstraints(IInlineConstraintResolver inlineConstraintResolver, RouteTemplate parsedTemplate, IDictionary`2<string, object> constraints);
    protected static RouteValueDictionary GetDefaults(RouteTemplate parsedTemplate, RouteValueDictionary defaults);
    private static void MergeValues(RouteValueDictionary destination, RouteValueDictionary values);
    private void EnsureBinder(HttpContext context);
    private void EnsureLoggers(HttpContext context);
    private void EnsureMatcher();
    public virtual string ToString();
}
public class Microsoft.AspNetCore.Routing.RouteBuilder : object {
    [CompilerGeneratedAttribute]
private IApplicationBuilder <ApplicationBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IRouter <DefaultHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <ServiceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IRouter> <Routes>k__BackingField;
    public IApplicationBuilder ApplicationBuilder { get; }
    public IRouter DefaultHandler { get; public set; }
    public IServiceProvider ServiceProvider { get; }
    public IList`1<IRouter> Routes { get; }
    public RouteBuilder(IApplicationBuilder applicationBuilder);
    public RouteBuilder(IApplicationBuilder applicationBuilder, IRouter defaultHandler);
    [CompilerGeneratedAttribute]
public sealed virtual IApplicationBuilder get_ApplicationBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual IRouter get_DefaultHandler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultHandler(IRouter value);
    [CompilerGeneratedAttribute]
public sealed virtual IServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IRouter> get_Routes();
    public sealed virtual IRouter Build();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.AspNetCore.Routing.RouteCollection : object {
    private static Char[] UrlQueryDelimiters;
    private List`1<IRouter> _routes;
    private List`1<IRouter> _unnamedRoutes;
    private Dictionary`2<string, INamedRouter> _namedRoutes;
    private RouteOptions _options;
    public IRouter Item { get; }
    public int Count { get; }
    private static RouteCollection();
    public IRouter get_Item(int index);
    public int get_Count();
    public sealed virtual void Add(IRouter router);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.RouteCollection/<RouteAsync>d__10")]
public virtual Task RouteAsync(RouteContext context);
    public virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    private VirtualPathData GetVirtualPath(VirtualPathContext context, List`1<IRouter> routes);
    private VirtualPathData NormalizeVirtualPath(VirtualPathData pathData);
    private void EnsureOptions(HttpContext context);
}
public class Microsoft.AspNetCore.Routing.RouteConstraintBuilder : object {
    private IInlineConstraintResolver _inlineConstraintResolver;
    private string _displayName;
    private Dictionary`2<string, List`1<IRouteConstraint>> _constraints;
    private HashSet`1<string> _optionalParameters;
    public RouteConstraintBuilder(IInlineConstraintResolver inlineConstraintResolver, string displayName);
    public IDictionary`2<string, IRouteConstraint> Build();
    public void AddConstraint(string key, object value);
    public void AddResolvedConstraint(string key, string constraintText);
    public void SetOptional(string key);
    private void Add(string key, IRouteConstraint constraint);
}
public static class Microsoft.AspNetCore.Routing.RouteConstraintMatcher : object {
    public static bool Match(IDictionary`2<string, IRouteConstraint> constraints, RouteValueDictionary routeValues, HttpContext httpContext, IRouter route, RouteDirection routeDirection, ILogger logger);
}
public class Microsoft.AspNetCore.Routing.RouteCreationException : Exception {
    public RouteCreationException(string message);
    public RouteCreationException(string message, Exception innerException);
}
public class Microsoft.AspNetCore.Routing.RouteEndpoint : Endpoint {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private RoutePattern <RoutePattern>k__BackingField;
    public int Order { get; }
    public RoutePattern RoutePattern { get; }
    public RouteEndpoint(RequestDelegate requestDelegate, RoutePattern routePattern, int order, EndpointMetadataCollection metadata, string displayName);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public RoutePattern get_RoutePattern();
}
public class Microsoft.AspNetCore.Routing.RouteEndpointBuilder : EndpointBuilder {
    [CompilerGeneratedAttribute]
private RoutePattern <RoutePattern>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public RoutePattern RoutePattern { get; public set; }
    public int Order { get; public set; }
    public RouteEndpointBuilder(RequestDelegate requestDelegate, RoutePattern routePattern, int order);
    [CompilerGeneratedAttribute]
public RoutePattern get_RoutePattern();
    [CompilerGeneratedAttribute]
public void set_RoutePattern(RoutePattern value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    public virtual Endpoint Build();
}
public class Microsoft.AspNetCore.Routing.RouteHandler : object {
    private RequestDelegate _requestDelegate;
    public RouteHandler(RequestDelegate requestDelegate);
    public sealed virtual RequestDelegate GetRequestHandler(HttpContext httpContext, RouteData routeData);
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    public sealed virtual Task RouteAsync(RouteContext context);
}
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
public class Microsoft.AspNetCore.Routing.RouteNameMetadata : object {
    [CompilerGeneratedAttribute]
private string <RouteName>k__BackingField;
    public string RouteName { get; }
    public RouteNameMetadata(string routeName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RouteName();
    internal string DebuggerToString();
}
public class Microsoft.AspNetCore.Routing.RouteOptions : object {
    private IDictionary`2<string, Type> _constraintTypeMap;
    private ICollection`1<EndpointDataSource> _endpointDataSources;
    [CompilerGeneratedAttribute]
private bool <LowercaseUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LowercaseQueryStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AppendTrailingSlash>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressCheckForUnhandledSecurityMetadata>k__BackingField;
    internal ICollection`1<EndpointDataSource> EndpointDataSources { get; internal set; }
    public bool LowercaseUrls { get; public set; }
    public bool LowercaseQueryStrings { get; public set; }
    public bool AppendTrailingSlash { get; public set; }
    public bool SuppressCheckForUnhandledSecurityMetadata { get; public set; }
    public IDictionary`2<string, Type> ConstraintMap { get; public set; }
    internal ICollection`1<EndpointDataSource> get_EndpointDataSources();
    internal void set_EndpointDataSources(ICollection`1<EndpointDataSource> value);
    [CompilerGeneratedAttribute]
public bool get_LowercaseUrls();
    [CompilerGeneratedAttribute]
public void set_LowercaseUrls(bool value);
    [CompilerGeneratedAttribute]
public bool get_LowercaseQueryStrings();
    [CompilerGeneratedAttribute]
public void set_LowercaseQueryStrings(bool value);
    [CompilerGeneratedAttribute]
public bool get_AppendTrailingSlash();
    [CompilerGeneratedAttribute]
public void set_AppendTrailingSlash(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressCheckForUnhandledSecurityMetadata();
    [CompilerGeneratedAttribute]
public void set_SuppressCheckForUnhandledSecurityMetadata(bool value);
    public IDictionary`2<string, Type> get_ConstraintMap();
    public void set_ConstraintMap(IDictionary`2<string, Type> value);
    private static IDictionary`2<string, Type> GetDefaultConstraintMap();
}
internal class Microsoft.AspNetCore.Routing.RoutePatternMatcher : object {
    private static string SeparatorString;
    private static char SeparatorChar;
    private Boolean[] _hasDefaultValue;
    private Object[] _defaultValues;
    private static Char[] Delimiters;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private RoutePattern <RoutePattern>k__BackingField;
    public RouteValueDictionary Defaults { get; }
    public RoutePattern RoutePattern { get; }
    public RoutePatternMatcher(RoutePattern pattern, RouteValueDictionary defaults);
    private static RoutePatternMatcher();
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_Defaults();
    [CompilerGeneratedAttribute]
public RoutePattern get_RoutePattern();
    public bool TryMatch(PathString path, RouteValueDictionary values);
    private bool TryMatchLiterals(int index, StringSegment stringSegment, RoutePatternPathSegment pathSegment);
    private bool SavePathSegmentsAsValues(int index, RouteValueDictionary values, StringSegment requestSegment, RoutePatternPathSegment pathSegment);
    internal static bool MatchComplexSegment(RoutePatternPathSegment routeSegment, ReadOnlySpan`1<char> requestSegment, RouteValueDictionary values);
    private static bool MatchComplexSegmentCore(RoutePatternPathSegment routeSegment, ReadOnlySpan`1<char> requestSegment, RouteValueDictionary values, int indexOfLastSegmentUsed);
}
public class Microsoft.AspNetCore.Routing.RouteValueEqualityComparer : object {
    public static RouteValueEqualityComparer Default;
    private static RouteValueEqualityComparer();
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
public class Microsoft.AspNetCore.Routing.RouteValuesAddress : object {
    [CompilerGeneratedAttribute]
private string <RouteName>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <ExplicitValues>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <AmbientValues>k__BackingField;
    public string RouteName { get; public set; }
    public RouteValueDictionary ExplicitValues { get; public set; }
    public RouteValueDictionary AmbientValues { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RouteName();
    [CompilerGeneratedAttribute]
public void set_RouteName(string value);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_ExplicitValues();
    [CompilerGeneratedAttribute]
public void set_ExplicitValues(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_AmbientValues();
    [CompilerGeneratedAttribute]
public void set_AmbientValues(RouteValueDictionary value);
}
internal class Microsoft.AspNetCore.Routing.RouteValuesAddressScheme : object {
    private DataSourceDependentCache`1<StateEntry> _cache;
    internal StateEntry State { get; }
    public RouteValuesAddressScheme(EndpointDataSource dataSource);
    internal StateEntry get_State();
    public sealed virtual IEnumerable`1<Endpoint> FindEndpoints(RouteValuesAddress address);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Routing.RouteValuesAddressScheme/<GetEndpoints>d__5")]
private static IEnumerable`1<Endpoint> GetEndpoints(IList`1<OutboundMatchResult> matchResults, int matchCount);
    private StateEntry Initialize(IReadOnlyList`1<Endpoint> endpoints);
    private OutboundRouteEntry CreateOutboundRouteEntry(RouteEndpoint endpoint, IReadOnlyDictionary`2<string, object> requiredValues, string routeName);
    public sealed virtual void Dispose();
}
public class Microsoft.AspNetCore.Routing.RoutingFeature : object {
    [CompilerGeneratedAttribute]
private RouteData <RouteData>k__BackingField;
    public RouteData RouteData { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual RouteData get_RouteData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RouteData(RouteData value);
}
internal class Microsoft.AspNetCore.Routing.RoutingMarkerService : object {
}
internal enum Microsoft.AspNetCore.Routing.SegmentState : Enum {
    public int value__;
    public static SegmentState Beginning;
    public static SegmentState Inside;
}
public class Microsoft.AspNetCore.Routing.SuppressLinkGenerationMetadata : object {
    public bool SuppressLinkGeneration { get; }
    public sealed virtual bool get_SuppressLinkGeneration();
}
public class Microsoft.AspNetCore.Routing.SuppressMatchingMetadata : object {
    public bool SuppressMatching { get; }
    public sealed virtual bool get_SuppressMatching();
}
internal class Microsoft.AspNetCore.Routing.Template.DefaultTemplateBinderFactory : TemplateBinderFactory {
    private ParameterPolicyFactory _policyFactory;
    private ObjectPool`1<UriBuildingContext> _pool;
    public DefaultTemplateBinderFactory(ParameterPolicyFactory policyFactory, ObjectPool`1<UriBuildingContext> pool);
    public virtual TemplateBinder Create(RouteTemplate template, RouteValueDictionary defaults);
    public virtual TemplateBinder Create(RoutePattern pattern);
}
public class Microsoft.AspNetCore.Routing.Template.InlineConstraint : object {
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    public string Constraint { get; }
    public InlineConstraint(string constraint);
    public InlineConstraint(RoutePatternParameterPolicyReference other);
    [CompilerGeneratedAttribute]
public string get_Constraint();
}
public static class Microsoft.AspNetCore.Routing.Template.RoutePrecedence : object {
    public static decimal ComputeInbound(RouteTemplate template);
    internal static decimal ComputeInbound(RoutePattern routePattern);
    public static decimal ComputeOutbound(RouteTemplate template);
    internal static decimal ComputeOutbound(RoutePattern routePattern);
    private static void ValidateSegementLength(int length);
    private static int ComputeOutboundPrecedenceDigit(TemplateSegment segment);
    private static int ComputeOutboundPrecedenceDigit(RoutePatternPathSegment pathSegment);
    private static int ComputeInboundPrecedenceDigit(TemplateSegment segment);
    internal static int ComputeInboundPrecedenceDigit(RoutePattern routePattern, RoutePatternPathSegment pathSegment);
}
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Template.RouteTemplate : object {
    private static string SeparatorString;
    [CompilerGeneratedAttribute]
private string <TemplateText>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TemplatePart> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TemplateSegment> <Segments>k__BackingField;
    public string TemplateText { get; }
    public IList`1<TemplatePart> Parameters { get; }
    public IList`1<TemplateSegment> Segments { get; }
    public RouteTemplate(RoutePattern other);
    public RouteTemplate(string template, List`1<TemplateSegment> segments);
    [CompilerGeneratedAttribute]
public string get_TemplateText();
    [CompilerGeneratedAttribute]
public IList`1<TemplatePart> get_Parameters();
    [CompilerGeneratedAttribute]
public IList`1<TemplateSegment> get_Segments();
    public TemplateSegment GetSegment(int index);
    private string DebuggerToString();
    public TemplatePart GetParameter(string name);
    public RoutePattern ToRoutePattern();
}
public class Microsoft.AspNetCore.Routing.Template.TemplateBinder : object {
    private UrlEncoder _urlEncoder;
    private ObjectPool`1<UriBuildingContext> _pool;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _constraints;
    private RouteValueDictionary _defaults;
    private KeyValuePair`2[] _filters;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _parameterTransformers;
    private RoutePattern _pattern;
    private String[] _requiredKeys;
    private KeyValuePair`2[] _slots;
    internal TemplateBinder(UrlEncoder urlEncoder, ObjectPool`1<UriBuildingContext> pool, RouteTemplate template, RouteValueDictionary defaults);
    internal TemplateBinder(UrlEncoder urlEncoder, ObjectPool`1<UriBuildingContext> pool, RoutePattern pattern, RouteValueDictionary defaults, IEnumerable`1<string> requiredKeys, IEnumerable`1<ValueTuple`2<string, IParameterPolicy>> parameterPolicies);
    internal TemplateBinder(UrlEncoder urlEncoder, ObjectPool`1<UriBuildingContext> pool, RoutePattern pattern, IEnumerable`1<ValueTuple`2<string, IParameterPolicy>> parameterPolicies);
    public TemplateValuesResult GetValues(RouteValueDictionary ambientValues, RouteValueDictionary values);
    public bool TryProcessConstraints(HttpContext httpContext, RouteValueDictionary combinedValues, String& parameterName, IRouteConstraint& constraint);
    public string BindValues(RouteValueDictionary acceptedValues);
    internal bool TryBindValues(RouteValueDictionary acceptedValues, LinkOptions options, LinkOptions globalOptions, ValueTuple`2& result);
    private bool TryBindValuesCore(UriBuildingContext context, RouteValueDictionary acceptedValues);
    private bool AddQueryKeyValueToContext(UriBuildingContext context, string key, object value, bool wroteFirst);
    public static bool RoutePartsEqual(object a, object b);
    private static bool IsRoutePartNonEmpty(object part);
    private void CopyNonParameterAmbientValues(RouteValueDictionary ambientValues, RouteValueDictionary acceptedValues, RouteValueDictionary combinedValues);
    private static KeyValuePair`2[] AssignSlots(RoutePattern pattern, KeyValuePair`2[] filters);
}
public abstract class Microsoft.AspNetCore.Routing.Template.TemplateBinderFactory : object {
    public abstract virtual TemplateBinder Create(RouteTemplate template, RouteValueDictionary defaults);
    public abstract virtual TemplateBinder Create(RoutePattern pattern);
}
public class Microsoft.AspNetCore.Routing.Template.TemplateMatcher : object {
    private static string SeparatorString;
    private static char SeparatorChar;
    private Boolean[] _hasDefaultValue;
    private Object[] _defaultValues;
    private static Char[] Delimiters;
    private RoutePatternMatcher _routePatternMatcher;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteTemplate <Template>k__BackingField;
    public RouteValueDictionary Defaults { get; }
    public RouteTemplate Template { get; }
    public TemplateMatcher(RouteTemplate template, RouteValueDictionary defaults);
    private static TemplateMatcher();
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_Defaults();
    [CompilerGeneratedAttribute]
public RouteTemplate get_Template();
    public bool TryMatch(PathString path, RouteValueDictionary values);
}
public static class Microsoft.AspNetCore.Routing.Template.TemplateParser : object {
    public static RouteTemplate Parse(string routeTemplate);
}
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Template.TemplatePart : object {
    [CompilerGeneratedAttribute]
private bool <IsCatchAll>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLiteral>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptionalSeperator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<InlineConstraint> <InlineConstraints>k__BackingField;
    public bool IsCatchAll { get; private set; }
    public bool IsLiteral { get; private set; }
    public bool IsParameter { get; private set; }
    public bool IsOptional { get; private set; }
    public bool IsOptionalSeperator { get; public set; }
    public string Name { get; private set; }
    public string Text { get; private set; }
    public object DefaultValue { get; private set; }
    public IEnumerable`1<InlineConstraint> InlineConstraints { get; private set; }
    public TemplatePart(RoutePatternPart other);
    public static TemplatePart CreateLiteral(string text);
    public static TemplatePart CreateParameter(string name, bool isCatchAll, bool isOptional, object defaultValue, IEnumerable`1<InlineConstraint> inlineConstraints);
    [CompilerGeneratedAttribute]
public bool get_IsCatchAll();
    [CompilerGeneratedAttribute]
private void set_IsCatchAll(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLiteral();
    [CompilerGeneratedAttribute]
private void set_IsLiteral(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParameter();
    [CompilerGeneratedAttribute]
private void set_IsParameter(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
private void set_IsOptional(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOptionalSeperator();
    [CompilerGeneratedAttribute]
public void set_IsOptionalSeperator(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
private void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<InlineConstraint> get_InlineConstraints();
    [CompilerGeneratedAttribute]
private void set_InlineConstraints(IEnumerable`1<InlineConstraint> value);
    internal string DebuggerToString();
    public RoutePatternPart ToRoutePatternPart();
}
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Template.TemplateSegment : object {
    [CompilerGeneratedAttribute]
private List`1<TemplatePart> <Parts>k__BackingField;
    public bool IsSimple { get; }
    public List`1<TemplatePart> Parts { get; }
    public TemplateSegment(RoutePatternPathSegment other);
    public bool get_IsSimple();
    [CompilerGeneratedAttribute]
public List`1<TemplatePart> get_Parts();
    internal string DebuggerToString();
    public RoutePatternPathSegment ToRoutePatternPathSegment();
}
public class Microsoft.AspNetCore.Routing.Template.TemplateValuesResult : object {
    [CompilerGeneratedAttribute]
private RouteValueDictionary <AcceptedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <CombinedValues>k__BackingField;
    public RouteValueDictionary AcceptedValues { get; public set; }
    public RouteValueDictionary CombinedValues { get; public set; }
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_AcceptedValues();
    [CompilerGeneratedAttribute]
public void set_AcceptedValues(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_CombinedValues();
    [CompilerGeneratedAttribute]
public void set_CombinedValues(RouteValueDictionary value);
}
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
public class Microsoft.AspNetCore.Routing.Tree.InboundMatch : object {
    [CompilerGeneratedAttribute]
private InboundRouteEntry <Entry>k__BackingField;
    [CompilerGeneratedAttribute]
private TemplateMatcher <TemplateMatcher>k__BackingField;
    public InboundRouteEntry Entry { get; public set; }
    public TemplateMatcher TemplateMatcher { get; public set; }
    [CompilerGeneratedAttribute]
public InboundRouteEntry get_Entry();
    [CompilerGeneratedAttribute]
public void set_Entry(InboundRouteEntry value);
    [CompilerGeneratedAttribute]
public TemplateMatcher get_TemplateMatcher();
    [CompilerGeneratedAttribute]
public void set_TemplateMatcher(TemplateMatcher value);
    private string DebuggerToString();
}
public class Microsoft.AspNetCore.Routing.Tree.InboundRouteEntry : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IRouteConstraint> <Constraints>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private IRouter <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RouteName>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteTemplate <RouteTemplate>k__BackingField;
    public IDictionary`2<string, IRouteConstraint> Constraints { get; public set; }
    public RouteValueDictionary Defaults { get; public set; }
    public IRouter Handler { get; public set; }
    public int Order { get; public set; }
    public decimal Precedence { get; public set; }
    public string RouteName { get; public set; }
    public RouteTemplate RouteTemplate { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IRouteConstraint> get_Constraints();
    [CompilerGeneratedAttribute]
public void set_Constraints(IDictionary`2<string, IRouteConstraint> value);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_Defaults();
    [CompilerGeneratedAttribute]
public void set_Defaults(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public IRouter get_Handler();
    [CompilerGeneratedAttribute]
public void set_Handler(IRouter value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    [CompilerGeneratedAttribute]
public decimal get_Precedence();
    [CompilerGeneratedAttribute]
public void set_Precedence(decimal value);
    [CompilerGeneratedAttribute]
public string get_RouteName();
    [CompilerGeneratedAttribute]
public void set_RouteName(string value);
    [CompilerGeneratedAttribute]
public RouteTemplate get_RouteTemplate();
    [CompilerGeneratedAttribute]
public void set_RouteTemplate(RouteTemplate value);
}
[DebuggerDisplayAttribute("{DebuggerDisplayString,nq}")]
internal class Microsoft.AspNetCore.Routing.Tree.LinkGenerationDecisionTree : object {
    private static RouteValueDictionary EmptyAmbientValues;
    private DecisionTreeNode`1<OutboundMatch> _root;
    private List`1<OutboundMatch> _conventionalEntries;
    internal string DebuggerDisplayString { get; }
    public LinkGenerationDecisionTree(IReadOnlyList`1<OutboundMatch> entries);
    private static LinkGenerationDecisionTree();
    public IList`1<OutboundMatchResult> GetMatches(RouteValueDictionary values, RouteValueDictionary ambientValues);
    private void Walk(List`1<OutboundMatchResult> results, RouteValueDictionary values, RouteValueDictionary ambientValues, DecisionTreeNode`1<OutboundMatch> node, bool isFallbackPath);
    private void ProcessConventionalEntries(List`1<OutboundMatchResult> results, RouteValueDictionary values, RouteValueDictionary ambientvalues);
    internal string get_DebuggerDisplayString();
    private void FlattenTree(Stack`1<string> branchStack, StringBuilder sb, DecisionTreeNode`1<OutboundMatch> node);
}
public class Microsoft.AspNetCore.Routing.Tree.OutboundMatch : object {
    [CompilerGeneratedAttribute]
private OutboundRouteEntry <Entry>k__BackingField;
    [CompilerGeneratedAttribute]
private TemplateBinder <TemplateBinder>k__BackingField;
    public OutboundRouteEntry Entry { get; public set; }
    public TemplateBinder TemplateBinder { get; public set; }
    [CompilerGeneratedAttribute]
public OutboundRouteEntry get_Entry();
    [CompilerGeneratedAttribute]
public void set_Entry(OutboundRouteEntry value);
    [CompilerGeneratedAttribute]
public TemplateBinder get_TemplateBinder();
    [CompilerGeneratedAttribute]
public void set_TemplateBinder(TemplateBinder value);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Routing.Tree.OutboundMatchResult : ValueType {
    [CompilerGeneratedAttribute]
private OutboundMatch <Match>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFallbackMatch>k__BackingField;
    public OutboundMatch Match { get; }
    public bool IsFallbackMatch { get; }
    public OutboundMatchResult(OutboundMatch match, bool isFallbackMatch);
    [CompilerGeneratedAttribute]
public OutboundMatch get_Match();
    [CompilerGeneratedAttribute]
public bool get_IsFallbackMatch();
}
public class Microsoft.AspNetCore.Routing.Tree.OutboundRouteEntry : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IRouteConstraint> <Constraints>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private IRouter <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RouteName>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <RequiredLinkValues>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteTemplate <RouteTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public IDictionary`2<string, IRouteConstraint> Constraints { get; public set; }
    public RouteValueDictionary Defaults { get; public set; }
    public IRouter Handler { get; public set; }
    public int Order { get; public set; }
    public decimal Precedence { get; public set; }
    public string RouteName { get; public set; }
    public RouteValueDictionary RequiredLinkValues { get; public set; }
    public RouteTemplate RouteTemplate { get; public set; }
    public object Data { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IRouteConstraint> get_Constraints();
    [CompilerGeneratedAttribute]
public void set_Constraints(IDictionary`2<string, IRouteConstraint> value);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_Defaults();
    [CompilerGeneratedAttribute]
public void set_Defaults(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public IRouter get_Handler();
    [CompilerGeneratedAttribute]
public void set_Handler(IRouter value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    [CompilerGeneratedAttribute]
public decimal get_Precedence();
    [CompilerGeneratedAttribute]
public void set_Precedence(decimal value);
    [CompilerGeneratedAttribute]
public string get_RouteName();
    [CompilerGeneratedAttribute]
public void set_RouteName(string value);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_RequiredLinkValues();
    [CompilerGeneratedAttribute]
public void set_RequiredLinkValues(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public RouteTemplate get_RouteTemplate();
    [CompilerGeneratedAttribute]
public void set_RouteTemplate(RouteTemplate value);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
}
internal class Microsoft.AspNetCore.Routing.Tree.TreeEnumerator : ValueType {
    private Stack`1<UrlMatchingNode> _stack;
    private PathTokenizer _tokenizer;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <Current>k__BackingField;
    public UrlMatchingNode Current { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    public TreeEnumerator(UrlMatchingNode root, PathTokenizer tokenizer);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public sealed virtual UrlMatchingNode get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(UrlMatchingNode value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class Microsoft.AspNetCore.Routing.Tree.TreeRouteBuilder : object {
    private ILogger _logger;
    private ILogger _constraintLogger;
    private UrlEncoder _urlEncoder;
    private ObjectPool`1<UriBuildingContext> _objectPool;
    private IInlineConstraintResolver _constraintResolver;
    [CompilerGeneratedAttribute]
private IList`1<InboundRouteEntry> <InboundEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<OutboundRouteEntry> <OutboundEntries>k__BackingField;
    public IList`1<InboundRouteEntry> InboundEntries { get; }
    public IList`1<OutboundRouteEntry> OutboundEntries { get; }
    internal TreeRouteBuilder(ILoggerFactory loggerFactory, ObjectPool`1<UriBuildingContext> objectPool, IInlineConstraintResolver constraintResolver);
    public InboundRouteEntry MapInbound(IRouter handler, RouteTemplate routeTemplate, string routeName, int order);
    public OutboundRouteEntry MapOutbound(IRouter handler, RouteTemplate routeTemplate, RouteValueDictionary requiredLinkValues, string routeName, int order);
    [CompilerGeneratedAttribute]
public IList`1<InboundRouteEntry> get_InboundEntries();
    [CompilerGeneratedAttribute]
public IList`1<OutboundRouteEntry> get_OutboundEntries();
    public TreeRouter Build();
    public TreeRouter Build(int version);
    public void Clear();
}
public class Microsoft.AspNetCore.Routing.Tree.TreeRouter : object {
    public static string RouteGroupKey;
    private LinkGenerationDecisionTree _linkGenerationTree;
    private UrlMatchingTree[] _trees;
    private IDictionary`2<string, OutboundMatch> _namedEntries;
    private ILogger _logger;
    private ILogger _constraintLogger;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public int Version { get; }
    internal IEnumerable`1<UrlMatchingTree> MatchingTrees { get; }
    internal TreeRouter(UrlMatchingTree[] trees, IEnumerable`1<OutboundRouteEntry> linkGenerationEntries, UrlEncoder urlEncoder, ObjectPool`1<UriBuildingContext> objectPool, ILogger routeLogger, ILogger constraintLogger, int version);
    private static TreeRouter();
    [CompilerGeneratedAttribute]
public int get_Version();
    internal IEnumerable`1<UrlMatchingTree> get_MatchingTrees();
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.Tree.TreeRouter/<RouteAsync>d__13")]
public sealed virtual Task RouteAsync(RouteContext context);
    private VirtualPathData GetVirtualPathForNamedRoute(VirtualPathContext context);
    private VirtualPathData GenerateVirtualPath(VirtualPathContext context, OutboundRouteEntry entry, TemplateBinder binder);
}
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
public class Microsoft.AspNetCore.Routing.Tree.UrlMatchingNode : object {
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCatchAll>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<InboundMatch> <Matches>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, UrlMatchingNode> <Literals>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <ConstrainedParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <ConstrainedCatchAlls>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <CatchAlls>k__BackingField;
    public int Depth { get; }
    public bool IsCatchAll { get; public set; }
    public List`1<InboundMatch> Matches { get; }
    public Dictionary`2<string, UrlMatchingNode> Literals { get; }
    public UrlMatchingNode ConstrainedParameters { get; public set; }
    public UrlMatchingNode Parameters { get; public set; }
    public UrlMatchingNode ConstrainedCatchAlls { get; public set; }
    public UrlMatchingNode CatchAlls { get; public set; }
    public UrlMatchingNode(int length);
    [CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public bool get_IsCatchAll();
    [CompilerGeneratedAttribute]
public void set_IsCatchAll(bool value);
    [CompilerGeneratedAttribute]
public List`1<InboundMatch> get_Matches();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, UrlMatchingNode> get_Literals();
    [CompilerGeneratedAttribute]
public UrlMatchingNode get_ConstrainedParameters();
    [CompilerGeneratedAttribute]
public void set_ConstrainedParameters(UrlMatchingNode value);
    [CompilerGeneratedAttribute]
public UrlMatchingNode get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(UrlMatchingNode value);
    [CompilerGeneratedAttribute]
public UrlMatchingNode get_ConstrainedCatchAlls();
    [CompilerGeneratedAttribute]
public void set_ConstrainedCatchAlls(UrlMatchingNode value);
    [CompilerGeneratedAttribute]
public UrlMatchingNode get_CatchAlls();
    [CompilerGeneratedAttribute]
public void set_CatchAlls(UrlMatchingNode value);
    private string DebuggerToString();
}
public class Microsoft.AspNetCore.Routing.Tree.UrlMatchingTree : object {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <Root>k__BackingField;
    public int Order { get; }
    public UrlMatchingNode Root { get; }
    public UrlMatchingTree(int order);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public UrlMatchingNode get_Root();
    internal void AddEntry(InboundRouteEntry entry);
    private static bool RemainingSegmentsAreOptional(IList`1<TemplateSegment> segments, int currentParameterIndex);
}
internal class Microsoft.AspNetCore.Routing.UriBuilderContextPooledObjectPolicy : object {
    public sealed virtual UriBuildingContext Create();
    public sealed virtual bool Return(UriBuildingContext obj);
}
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
internal class Microsoft.AspNetCore.Routing.UriBuildingContext : object {
    private StringBuilder _path;
    private StringBuilder _query;
    private List`1<BufferValue> _buffer;
    private UrlEncoder _urlEncoder;
    private bool _hasEmptySegment;
    private int _lastValueOffset;
    [CompilerGeneratedAttribute]
private bool <LowercaseUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LowercaseQueryStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AppendTrailingSlash>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentState <BufferState>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentState <UriState>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <PathWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <QueryWriter>k__BackingField;
    public bool LowercaseUrls { get; public set; }
    public bool LowercaseQueryStrings { get; public set; }
    public bool AppendTrailingSlash { get; public set; }
    public SegmentState BufferState { get; private set; }
    public SegmentState UriState { get; private set; }
    public TextWriter PathWriter { get; }
    public TextWriter QueryWriter { get; }
    public UriBuildingContext(UrlEncoder urlEncoder);
    [CompilerGeneratedAttribute]
public bool get_LowercaseUrls();
    [CompilerGeneratedAttribute]
public void set_LowercaseUrls(bool value);
    [CompilerGeneratedAttribute]
public bool get_LowercaseQueryStrings();
    [CompilerGeneratedAttribute]
public void set_LowercaseQueryStrings(bool value);
    [CompilerGeneratedAttribute]
public bool get_AppendTrailingSlash();
    [CompilerGeneratedAttribute]
public void set_AppendTrailingSlash(bool value);
    [CompilerGeneratedAttribute]
public SegmentState get_BufferState();
    [CompilerGeneratedAttribute]
private void set_BufferState(SegmentState value);
    [CompilerGeneratedAttribute]
public SegmentState get_UriState();
    [CompilerGeneratedAttribute]
private void set_UriState(SegmentState value);
    [CompilerGeneratedAttribute]
public TextWriter get_PathWriter();
    [CompilerGeneratedAttribute]
public TextWriter get_QueryWriter();
    public bool Accept(string value);
    public bool Accept(string value, bool encodeSlashes);
    public void Remove(string literal);
    public bool Buffer(string value);
    public void EndSegment();
    public void Clear();
    public virtual string ToString();
    public PathString ToPathString();
    public QueryString ToQueryString();
    private void EncodeValue(string value);
    private void EncodeValue(string value, bool encodeSlashes);
    internal void EncodeValue(string value, int start, int characterCount, bool encodeSlashes);
    private string DebuggerToString();
}
internal class Microsoft.Extensions.DependencyInjection.ConfigureRouteOptions : object {
    private ICollection`1<EndpointDataSource> _dataSources;
    public ConfigureRouteOptions(ICollection`1<EndpointDataSource> dataSources);
    public sealed virtual void Configure(RouteOptions options);
}
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.RoutingServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddRouting(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddRouting(IServiceCollection services, Action`1<RouteOptions> configureOptions);
}
internal class Microsoft.Extensions.Internal.HashCodeCombiner : ValueType {
    private long _combinedHash64;
    public int CombinedHash { get; }
    private HashCodeCombiner(long seed);
    public int get_CombinedHash();
    public void Add(IEnumerable e);
    public static int op_Implicit(HashCodeCombiner self);
    public void Add(int i);
    public void Add(string s);
    public void Add(object o);
    public void Add(TValue value, IEqualityComparer`1<TValue> comparer);
    public static HashCodeCombiner Start();
}
internal class Microsoft.Extensions.Internal.PropertyHelper : object {
    private static MethodInfo CallPropertyGetterOpenGenericMethod;
    private static MethodInfo CallPropertyGetterByReferenceOpenGenericMethod;
    private static MethodInfo CallNullSafePropertyGetterOpenGenericMethod;
    private static MethodInfo CallNullSafePropertyGetterByReferenceOpenGenericMethod;
    private static MethodInfo CallPropertySetterOpenGenericMethod;
    private static ConcurrentDictionary`2<Type, PropertyHelper[]> PropertiesCache;
    private static ConcurrentDictionary`2<Type, PropertyHelper[]> VisiblePropertiesCache;
    private static Type IsByRefLikeAttribute;
    private Action`2<object, object> _valueSetter;
    private Func`2<object, object> _valueGetter;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public PropertyInfo Property { get; }
    public string Name { get; protected set; }
    public Func`2<object, object> ValueGetter { get; }
    public Action`2<object, object> ValueSetter { get; }
    public PropertyHelper(PropertyInfo property);
    private static PropertyHelper();
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
protected virtual void set_Name(string value);
    public Func`2<object, object> get_ValueGetter();
    public Action`2<object, object> get_ValueSetter();
    public object GetValue(object instance);
    public void SetValue(object instance, object value);
    public static PropertyHelper[] GetProperties(TypeInfo typeInfo);
    public static PropertyHelper[] GetProperties(Type type);
    public static PropertyHelper[] GetVisibleProperties(TypeInfo typeInfo);
    public static PropertyHelper[] GetVisibleProperties(Type type);
    public static Func`2<object, object> MakeFastPropertyGetter(PropertyInfo propertyInfo);
    public static Func`2<object, object> MakeNullSafeFastPropertyGetter(PropertyInfo propertyInfo);
    private static Func`2<object, object> MakeFastPropertyGetter(PropertyInfo propertyInfo, MethodInfo propertyGetterWrapperMethod, MethodInfo propertyGetterByRefWrapperMethod);
    private static Func`2<object, object> MakeFastPropertyGetter(Type openGenericDelegateType, MethodInfo propertyGetMethod, MethodInfo openGenericWrapperMethod);
    public static Action`2<object, object> MakeFastPropertySetter(PropertyInfo propertyInfo);
    public static IDictionary`2<string, object> ObjectToDictionary(object value);
    private static PropertyHelper CreateInstance(PropertyInfo property);
    private static object CallPropertyGetter(Func`2<TDeclaringType, TValue> getter, object target);
    private static object CallPropertyGetterByReference(ByRefFunc`2<TDeclaringType, TValue> getter, object target);
    private static object CallNullSafePropertyGetter(Func`2<TDeclaringType, TValue> getter, object target);
    private static object CallNullSafePropertyGetterByReference(ByRefFunc`2<TDeclaringType, TValue> getter, object target);
    private static void CallPropertySetter(Action`2<TDeclaringType, TValue> setter, object target, object value);
    protected static PropertyHelper[] GetVisibleProperties(Type type, Func`2<PropertyInfo, PropertyHelper> createPropertyHelper, ConcurrentDictionary`2<Type, PropertyHelper[]> allPropertiesCache, ConcurrentDictionary`2<Type, PropertyHelper[]> visiblePropertiesCache);
    protected static PropertyHelper[] GetProperties(Type type, Func`2<PropertyInfo, PropertyHelper> createPropertyHelper, ConcurrentDictionary`2<Type, PropertyHelper[]> cache);
    private static bool IsInterestingProperty(PropertyInfo property);
    private static bool IsRefStructProperty(PropertyInfo property);
}
