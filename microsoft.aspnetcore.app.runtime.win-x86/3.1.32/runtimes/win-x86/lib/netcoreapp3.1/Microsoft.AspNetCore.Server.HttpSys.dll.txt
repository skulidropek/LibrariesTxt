[ExtensionAttribute]
public static class Microsoft.AspNetCore.Hosting.WebHostBuilderHttpSysExtensions : object {
    [ExtensionAttribute]
public static IWebHostBuilder UseHttpSys(IWebHostBuilder hostBuilder);
    [ExtensionAttribute]
public static IWebHostBuilder UseHttpSys(IWebHostBuilder hostBuilder, Action`1<HttpSysOptions> options);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.Constants : object {
    internal static string HttpScheme;
    internal static string HttpsScheme;
    internal static string Chunked;
    internal static string Close;
    internal static string Zero;
    internal static string SchemeDelimiter;
    internal static string DefaultServerAddress;
    internal static Version V1_0;
    internal static Version V1_1;
    internal static Version V2;
    private static Constants();
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.HttpSys.Internal.CookedUrl : ValueType {
    private HTTP_COOKED_URL _nativeCookedUrl;
    internal CookedUrl(HTTP_COOKED_URL nativeCookedUrl);
    internal string GetFullUrl();
    internal string GetHost();
    internal string GetAbsPath();
    internal string GetQueryString();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.HttpSys.Internal.HeaderCollection : object {
    private Nullable`1<long> _contentLength;
    private StringValues _contentLengthText;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, StringValues> <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private IDictionary`2<string, StringValues> Store { get; private set; }
    public bool IsReadOnly { get; internal set; }
    public StringValues Item { get; public set; }
    private StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Item { get; private set; }
    public int Count { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<StringValues> Values { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public HeaderCollection(IDictionary`2<string, StringValues> store);
    [CompilerGeneratedAttribute]
private IDictionary`2<string, StringValues> get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IDictionary`2<string, StringValues> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
internal void set_IsReadOnly(bool value);
    public sealed virtual StringValues get_Item(string key);
    public sealed virtual void set_Item(string key, StringValues value);
    private sealed virtual override StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.set_Item(string key, StringValues value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<StringValues> get_Values();
    public sealed virtual Nullable`1<long> get_ContentLength();
    public sealed virtual void set_ContentLength(Nullable`1<long> value);
    public sealed virtual void Add(KeyValuePair`2<string, StringValues> item);
    public sealed virtual void Add(string key, StringValues value);
    public void Append(string key, string value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, StringValues> item);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, StringValues>> GetEnumerator();
    public IEnumerable`1<string> GetValues(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, StringValues> item);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, StringValues& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowIfReadOnly();
    public static void ValidateHeaderCharacters(StringValues headerValues);
    public static void ValidateHeaderCharacters(string headerCharacters);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.HeaderEncoding : object {
    private static Encoding Encoding;
    private static HeaderEncoding();
    internal static string GetString(Byte* pBytes, int byteCount, bool useLatin1);
    internal static Byte[] GetBytes(string myString);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.HeaderParser : object {
    internal static IEnumerable`1<string> Empty;
    private static HeaderParser();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.HeaderParser/<SplitValues>d__1")]
internal static IEnumerable`1<string> SplitValues(StringValues values);
}
internal class Microsoft.AspNetCore.HttpSys.Internal.HeapAllocHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private static IntPtr ProcessHeap;
    private static HeapAllocHandle();
    protected virtual bool ReleaseHandle();
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.HttpApiTypes : object {
    internal static int MaxTimeout;
    internal static String[] HttpVerbs;
    private static HttpApiTypes();
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.HttpKnownHeaderNames : object {
    internal static string CacheControl;
    internal static string Connection;
    internal static string Date;
    internal static string KeepAlive;
    internal static string Pragma;
    internal static string ProxyConnection;
    internal static string Trailer;
    internal static string TransferEncoding;
    internal static string Upgrade;
    internal static string Via;
    internal static string Warning;
    internal static string ContentLength;
    internal static string ContentType;
    internal static string ContentDisposition;
    internal static string ContentEncoding;
    internal static string ContentLanguage;
    internal static string ContentLocation;
    internal static string ContentRange;
    internal static string Expires;
    internal static string LastModified;
    internal static string Age;
    internal static string Location;
    internal static string ProxyAuthenticate;
    internal static string RetryAfter;
    internal static string Server;
    internal static string SetCookie;
    internal static string SetCookie2;
    internal static string Vary;
    internal static string WWWAuthenticate;
    internal static string Accept;
    internal static string AcceptCharset;
    internal static string AcceptEncoding;
    internal static string AcceptLanguage;
    internal static string Authorization;
    internal static string Cookie;
    internal static string Cookie2;
    internal static string Expect;
    internal static string From;
    internal static string Host;
    internal static string IfMatch;
    internal static string IfModifiedSince;
    internal static string IfNoneMatch;
    internal static string IfRange;
    internal static string IfUnmodifiedSince;
    internal static string MaxForwards;
    internal static string ProxyAuthorization;
    internal static string Referer;
    internal static string Range;
    internal static string UserAgent;
    internal static string ContentMD5;
    internal static string ETag;
    internal static string TE;
    internal static string Allow;
    internal static string AcceptRanges;
    internal static string P3P;
    internal static string XPoweredBy;
    internal static string XAspNetVersion;
    internal static string SecWebSocketKey;
    internal static string SecWebSocketExtensions;
    internal static string SecWebSocketAccept;
    internal static string Origin;
    internal static string SecWebSocketProtocol;
    internal static string SecWebSocketVersion;
}
internal enum Microsoft.AspNetCore.HttpSys.Internal.HttpSysRequestHeader : Enum {
    public int value__;
    public static HttpSysRequestHeader CacheControl;
    public static HttpSysRequestHeader Connection;
    public static HttpSysRequestHeader Date;
    public static HttpSysRequestHeader KeepAlive;
    public static HttpSysRequestHeader Pragma;
    public static HttpSysRequestHeader Trailer;
    public static HttpSysRequestHeader TransferEncoding;
    public static HttpSysRequestHeader Upgrade;
    public static HttpSysRequestHeader Via;
    public static HttpSysRequestHeader Warning;
    public static HttpSysRequestHeader Allow;
    public static HttpSysRequestHeader ContentLength;
    public static HttpSysRequestHeader ContentType;
    public static HttpSysRequestHeader ContentEncoding;
    public static HttpSysRequestHeader ContentLanguage;
    public static HttpSysRequestHeader ContentLocation;
    public static HttpSysRequestHeader ContentMd5;
    public static HttpSysRequestHeader ContentRange;
    public static HttpSysRequestHeader Expires;
    public static HttpSysRequestHeader LastModified;
    public static HttpSysRequestHeader Accept;
    public static HttpSysRequestHeader AcceptCharset;
    public static HttpSysRequestHeader AcceptEncoding;
    public static HttpSysRequestHeader AcceptLanguage;
    public static HttpSysRequestHeader Authorization;
    public static HttpSysRequestHeader Cookie;
    public static HttpSysRequestHeader Expect;
    public static HttpSysRequestHeader From;
    public static HttpSysRequestHeader Host;
    public static HttpSysRequestHeader IfMatch;
    public static HttpSysRequestHeader IfModifiedSince;
    public static HttpSysRequestHeader IfNoneMatch;
    public static HttpSysRequestHeader IfRange;
    public static HttpSysRequestHeader IfUnmodifiedSince;
    public static HttpSysRequestHeader MaxForwards;
    public static HttpSysRequestHeader ProxyAuthorization;
    public static HttpSysRequestHeader Referer;
    public static HttpSysRequestHeader Range;
    public static HttpSysRequestHeader Te;
    public static HttpSysRequestHeader Translate;
    public static HttpSysRequestHeader UserAgent;
}
internal enum Microsoft.AspNetCore.HttpSys.Internal.HttpSysResponseHeader : Enum {
    public int value__;
    public static HttpSysResponseHeader CacheControl;
    public static HttpSysResponseHeader Connection;
    public static HttpSysResponseHeader Date;
    public static HttpSysResponseHeader KeepAlive;
    public static HttpSysResponseHeader Pragma;
    public static HttpSysResponseHeader Trailer;
    public static HttpSysResponseHeader TransferEncoding;
    public static HttpSysResponseHeader Upgrade;
    public static HttpSysResponseHeader Via;
    public static HttpSysResponseHeader Warning;
    public static HttpSysResponseHeader Allow;
    public static HttpSysResponseHeader ContentLength;
    public static HttpSysResponseHeader ContentType;
    public static HttpSysResponseHeader ContentEncoding;
    public static HttpSysResponseHeader ContentLanguage;
    public static HttpSysResponseHeader ContentLocation;
    public static HttpSysResponseHeader ContentMd5;
    public static HttpSysResponseHeader ContentRange;
    public static HttpSysResponseHeader Expires;
    public static HttpSysResponseHeader LastModified;
    public static HttpSysResponseHeader AcceptRanges;
    public static HttpSysResponseHeader Age;
    public static HttpSysResponseHeader ETag;
    public static HttpSysResponseHeader Location;
    public static HttpSysResponseHeader ProxyAuthenticate;
    public static HttpSysResponseHeader RetryAfter;
    public static HttpSysResponseHeader Server;
    public static HttpSysResponseHeader SetCookie;
    public static HttpSysResponseHeader Vary;
    public static HttpSysResponseHeader WwwAuthenticate;
}
internal class Microsoft.AspNetCore.HttpSys.Internal.NativeRequestContext : object {
    private static int AlignmentPadding;
    private IntPtr _originalBufferAddress;
    private bool _useLatin1;
    private HTTP_REQUEST* _nativeRequest;
    private Byte[] _backingBuffer;
    private int _bufferAlignment;
    private SafeNativeOverlapped _nativeOverlapped;
    private bool _permanentlyPinned;
    internal SafeNativeOverlapped NativeOverlapped { get; }
    internal HTTP_REQUEST* NativeRequest { get; }
    internal HTTP_REQUEST_V2* NativeRequestV2 { get; }
    internal ulong RequestId { get; internal set; }
    internal ulong ConnectionId { get; }
    internal HTTP_VERB VerbId { get; }
    internal ulong UrlContext { get; }
    internal ushort UnknownHeaderCount { get; }
    internal SslStatus SslStatus { get; }
    internal bool IsHttp2 { get; }
    internal UInt32 Size { get; }
    internal NativeRequestContext(SafeNativeOverlapped nativeOverlapped, int bufferAlignment, HTTP_REQUEST* nativeRequest, Byte[] backingBuffer, ulong requestId);
    internal NativeRequestContext(HTTP_REQUEST* request, bool useLatin1);
    internal SafeNativeOverlapped get_NativeOverlapped();
    internal HTTP_REQUEST* get_NativeRequest();
    internal HTTP_REQUEST_V2* get_NativeRequestV2();
    internal ulong get_RequestId();
    internal void set_RequestId(ulong value);
    internal ulong get_ConnectionId();
    internal HTTP_VERB get_VerbId();
    internal ulong get_UrlContext();
    internal ushort get_UnknownHeaderCount();
    internal SslStatus get_SslStatus();
    internal bool get_IsHttp2();
    internal UInt32 get_Size();
    internal void ReleasePins();
    public virtual void Dispose();
    internal string GetVerb();
    internal string GetRawUrl();
    internal Span`1<byte> GetRawUrlInBytes();
    internal CookedUrl GetCookedUrl();
    internal Version GetVersion();
    internal bool CheckAuthenticated();
    internal WindowsPrincipal GetUser();
    internal HTTP_SSL_PROTOCOL_INFO GetTlsHandshake();
    private static string GetAuthTypeFromRequest(HTTP_REQUEST_AUTH_TYPE input);
    internal string GetKnownHeader(HttpSysRequestHeader header);
    private string GetKnowHeaderHelper(HttpSysRequestHeader header, long fixup, HTTP_REQUEST* request);
    internal void GetUnknownHeaders(IDictionary`2<string, StringValues> unknownHeaders);
    private void GetUnknownHeadersHelper(IDictionary`2<string, StringValues> unknownHeaders, long fixup, HTTP_REQUEST* request);
    internal SocketAddress GetRemoteEndPoint();
    internal SocketAddress GetLocalEndPoint();
    private SocketAddress GetEndPoint(bool localEndpoint);
    private SocketAddress GetEndPointHelper(bool localEndpoint, HTTP_REQUEST* request, Byte* pMemoryBlob);
    private static SocketAddress CopyOutAddress(IntPtr address);
    internal UInt32 GetChunks(Int32& dataChunkIndex, UInt32& dataChunkOffset, Byte[] buffer, int offset, int size);
    private UInt32 GetChunksHelper(Int32& dataChunkIndex, UInt32& dataChunkOffset, Byte[] buffer, int offset, int size, long fixup, HTTP_REQUEST* request);
    internal IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> GetRequestInfo();
    private IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> GetRequestInfo(IntPtr baseAddress, HTTP_REQUEST_V2* nativeRequest);
    internal X509Certificate2 GetClientCertificate();
    private X509Certificate2 GetClientCertificate(IntPtr baseAddress, HTTP_REQUEST_V2* nativeRequest);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.NclUtilities : object {
    internal static bool HasShutdownStarted { get; }
    internal static bool get_HasShutdownStarted();
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.PathNormalizer : object {
    private static byte ByteSlash;
    private static byte ByteDot;
    public static int RemoveDotSegments(Span`1<byte> input);
    public static int RemoveDotSegments(Byte* start, Byte* end);
    public static bool ContainsDotSegments(Byte* start, Byte* end);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.RawUrlHelper : object {
    public static Span`1<byte> GetPath(Span`1<byte> raw);
    private static int FindHttpOrHttps(Span`1<byte> raw);
    private static int Find(Span`1<byte> raw, int begin, byte target);
}
[DefaultMemberAttribute("Item")]
[GeneratedCodeAttribute("TextTemplatingFileGenerator", "")]
internal class Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders : object {
    private IDictionary`2<string, StringValues> _extra;
    private NativeRequestContext _requestMemoryBlob;
    private Nullable`1<long> _contentLength;
    private StringValues _contentLengthText;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private UInt32 _flag0;
    private UInt32 _flag1;
    private StringValues _Accept;
    private StringValues _AcceptCharset;
    private StringValues _AcceptEncoding;
    private StringValues _AcceptLanguage;
    private StringValues _Allow;
    private StringValues _Authorization;
    private StringValues _CacheControl;
    private StringValues _Connection;
    private StringValues _ContentEncoding;
    private StringValues _ContentLanguage;
    private StringValues _ContentLength;
    private StringValues _ContentLocation;
    private StringValues _ContentMd5;
    private StringValues _ContentRange;
    private StringValues _ContentType;
    private StringValues _Cookie;
    private StringValues _Date;
    private StringValues _Expect;
    private StringValues _Expires;
    private StringValues _From;
    private StringValues _Host;
    private StringValues _IfMatch;
    private StringValues _IfModifiedSince;
    private StringValues _IfNoneMatch;
    private StringValues _IfRange;
    private StringValues _IfUnmodifiedSince;
    private StringValues _KeepAlive;
    private StringValues _LastModified;
    private StringValues _MaxForwards;
    private StringValues _Pragma;
    private StringValues _ProxyAuthorization;
    private StringValues _Range;
    private StringValues _Referer;
    private StringValues _Te;
    private StringValues _Trailer;
    private StringValues _TransferEncoding;
    private StringValues _Translate;
    private StringValues _Upgrade;
    private StringValues _UserAgent;
    private StringValues _Via;
    private StringValues _Warning;
    public bool IsReadOnly { get; internal set; }
    private IDictionary`2<string, StringValues> Extra { get; }
    private StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Item { get; private set; }
    public ICollection`1<string> Keys { get; }
    private ICollection`1<StringValues> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Values { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.IsReadOnly { get; }
    private Nullable`1<long> Microsoft.AspNetCore.Http.IHeaderDictionary.ContentLength { get; private set; }
    public StringValues Item { get; public set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Item { get; private set; }
    internal StringValues Accept { get; internal set; }
    internal StringValues AcceptCharset { get; internal set; }
    internal StringValues AcceptEncoding { get; internal set; }
    internal StringValues AcceptLanguage { get; internal set; }
    internal StringValues Allow { get; internal set; }
    internal StringValues Authorization { get; internal set; }
    internal StringValues CacheControl { get; internal set; }
    internal StringValues Connection { get; internal set; }
    internal StringValues ContentEncoding { get; internal set; }
    internal StringValues ContentLanguage { get; internal set; }
    internal StringValues ContentLength { get; internal set; }
    internal StringValues ContentLocation { get; internal set; }
    internal StringValues ContentMd5 { get; internal set; }
    internal StringValues ContentRange { get; internal set; }
    internal StringValues ContentType { get; internal set; }
    internal StringValues Cookie { get; internal set; }
    internal StringValues Date { get; internal set; }
    internal StringValues Expect { get; internal set; }
    internal StringValues Expires { get; internal set; }
    internal StringValues From { get; internal set; }
    internal StringValues Host { get; internal set; }
    internal StringValues IfMatch { get; internal set; }
    internal StringValues IfModifiedSince { get; internal set; }
    internal StringValues IfNoneMatch { get; internal set; }
    internal StringValues IfRange { get; internal set; }
    internal StringValues IfUnmodifiedSince { get; internal set; }
    internal StringValues KeepAlive { get; internal set; }
    internal StringValues LastModified { get; internal set; }
    internal StringValues MaxForwards { get; internal set; }
    internal StringValues Pragma { get; internal set; }
    internal StringValues ProxyAuthorization { get; internal set; }
    internal StringValues Range { get; internal set; }
    internal StringValues Referer { get; internal set; }
    internal StringValues Te { get; internal set; }
    internal StringValues Trailer { get; internal set; }
    internal StringValues TransferEncoding { get; internal set; }
    internal StringValues Translate { get; internal set; }
    internal StringValues Upgrade { get; internal set; }
    internal StringValues UserAgent { get; internal set; }
    internal StringValues Via { get; internal set; }
    internal StringValues Warning { get; internal set; }
    internal RequestHeaders(NativeRequestContext requestMemoryBlob);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
internal void set_IsReadOnly(bool value);
    private IDictionary`2<string, StringValues> get_Extra();
    private sealed virtual override StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.set_Item(string key, StringValues value);
    private string GetKnownHeader(HttpSysRequestHeader header);
    private void GetUnknownHeaders(IDictionary`2<string, StringValues> extra);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Add(string key, StringValues value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual ICollection`1<string> get_Keys();
    private sealed virtual override ICollection`1<StringValues> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, StringValues& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Add(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Contains(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.get_IsReadOnly();
    private sealed virtual override Nullable`1<long> Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentLength();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentLength(Nullable`1<long> value);
    public StringValues get_Item(string key);
    public void set_Item(string key, StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Item(string key);
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Item(string key, StringValues value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Remove(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, StringValues>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowIfReadOnly();
    public IEnumerable`1<string> GetValues(string key);
    internal StringValues get_Accept();
    internal void set_Accept(StringValues value);
    internal StringValues get_AcceptCharset();
    internal void set_AcceptCharset(StringValues value);
    internal StringValues get_AcceptEncoding();
    internal void set_AcceptEncoding(StringValues value);
    internal StringValues get_AcceptLanguage();
    internal void set_AcceptLanguage(StringValues value);
    internal StringValues get_Allow();
    internal void set_Allow(StringValues value);
    internal StringValues get_Authorization();
    internal void set_Authorization(StringValues value);
    internal StringValues get_CacheControl();
    internal void set_CacheControl(StringValues value);
    internal StringValues get_Connection();
    internal void set_Connection(StringValues value);
    internal StringValues get_ContentEncoding();
    internal void set_ContentEncoding(StringValues value);
    internal StringValues get_ContentLanguage();
    internal void set_ContentLanguage(StringValues value);
    internal StringValues get_ContentLength();
    internal void set_ContentLength(StringValues value);
    internal StringValues get_ContentLocation();
    internal void set_ContentLocation(StringValues value);
    internal StringValues get_ContentMd5();
    internal void set_ContentMd5(StringValues value);
    internal StringValues get_ContentRange();
    internal void set_ContentRange(StringValues value);
    internal StringValues get_ContentType();
    internal void set_ContentType(StringValues value);
    internal StringValues get_Cookie();
    internal void set_Cookie(StringValues value);
    internal StringValues get_Date();
    internal void set_Date(StringValues value);
    internal StringValues get_Expect();
    internal void set_Expect(StringValues value);
    internal StringValues get_Expires();
    internal void set_Expires(StringValues value);
    internal StringValues get_From();
    internal void set_From(StringValues value);
    internal StringValues get_Host();
    internal void set_Host(StringValues value);
    internal StringValues get_IfMatch();
    internal void set_IfMatch(StringValues value);
    internal StringValues get_IfModifiedSince();
    internal void set_IfModifiedSince(StringValues value);
    internal StringValues get_IfNoneMatch();
    internal void set_IfNoneMatch(StringValues value);
    internal StringValues get_IfRange();
    internal void set_IfRange(StringValues value);
    internal StringValues get_IfUnmodifiedSince();
    internal void set_IfUnmodifiedSince(StringValues value);
    internal StringValues get_KeepAlive();
    internal void set_KeepAlive(StringValues value);
    internal StringValues get_LastModified();
    internal void set_LastModified(StringValues value);
    internal StringValues get_MaxForwards();
    internal void set_MaxForwards(StringValues value);
    internal StringValues get_Pragma();
    internal void set_Pragma(StringValues value);
    internal StringValues get_ProxyAuthorization();
    internal void set_ProxyAuthorization(StringValues value);
    internal StringValues get_Range();
    internal void set_Range(StringValues value);
    internal StringValues get_Referer();
    internal void set_Referer(StringValues value);
    internal StringValues get_Te();
    internal void set_Te(StringValues value);
    internal StringValues get_Trailer();
    internal void set_Trailer(StringValues value);
    internal StringValues get_TransferEncoding();
    internal void set_TransferEncoding(StringValues value);
    internal StringValues get_Translate();
    internal void set_Translate(StringValues value);
    internal StringValues get_Upgrade();
    internal void set_Upgrade(StringValues value);
    internal StringValues get_UserAgent();
    internal void set_UserAgent(StringValues value);
    internal StringValues get_Via();
    internal void set_Via(StringValues value);
    internal StringValues get_Warning();
    internal void set_Warning(StringValues value);
    private bool PropertiesContainsKey(string key);
    private bool PropertiesTryGetValue(string key, StringValues& value);
    private bool PropertiesTrySetValue(string key, StringValues value);
    private bool PropertiesTryRemove(string key);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders/<PropertiesKeys>d__216")]
private IEnumerable`1<string> PropertiesKeys();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders/<PropertiesValues>d__217")]
private IEnumerable`1<StringValues> PropertiesValues();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders/<PropertiesEnumerable>d__218")]
private IEnumerable`1<KeyValuePair`2<string, StringValues>> PropertiesEnumerable();
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.RequestUriBuilder : object {
    private static Encoding UTF8;
    private static RequestUriBuilder();
    public static string DecodeAndUnescapePath(Span`1<byte> rawUrlBytes);
    private static Span`1<byte> Unescape(Span`1<byte> rawPath);
    private static bool DecodeCore(Int32& reader, Int32& writer, int end, Span`1<byte> buffer);
    private static void Copy(int begin, int end, Int32& writer, Span`1<byte> buffer);
    private static Nullable`1<int> UnescapePercentEncoding(Int32& scan, int end, ReadOnlySpan`1<byte> buffer);
    private static Nullable`1<int> ReadHex(Int32& scan, int end, ReadOnlySpan`1<byte> buffer);
    private static bool SkipUnescape(int value1, int value2);
}
internal class Microsoft.AspNetCore.HttpSys.Internal.SafeLocalFreeChannelBinding : ChannelBinding {
    private static int LMEM_FIXED;
    private int size;
    public int Size { get; }
    public bool IsInvalid { get; }
    public virtual int get_Size();
    public static SafeLocalFreeChannelBinding LocalAlloc(int cb);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.AspNetCore.HttpSys.Internal.SafeLocalMemHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeLocalMemHandle(IntPtr existingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.AspNetCore.HttpSys.Internal.SafeNativeOverlapped : SafeHandle {
    internal static SafeNativeOverlapped Zero;
    private ThreadPoolBoundHandle _boundHandle;
    public bool IsInvalid { get; }
    internal SafeNativeOverlapped(ThreadPoolBoundHandle boundHandle, NativeOverlapped* handle);
    private static SafeNativeOverlapped();
    public virtual bool get_IsInvalid();
    public void ReinitializeNativeOverlapped();
    protected virtual bool ReleaseHandle();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.HttpSys.Internal.SocketAddress : object {
    private static int NumberOfIPv6Labels;
    private static string IPv6NumberFormat;
    private static string IPv6StringSeparator;
    private static string IPv4StringFormat;
    internal static int IPv6AddressSize;
    internal static int IPv4AddressSize;
    private static int WriteableOffset;
    private int _size;
    private Byte[] _buffer;
    private int _hash;
    internal Byte[] Buffer { get; }
    internal AddressFamily Family { get; }
    internal int Size { get; }
    private byte Item { get; }
    public SocketAddress(AddressFamily family, int size);
    internal Byte[] get_Buffer();
    internal AddressFamily get_Family();
    internal int get_Size();
    private byte get_Item(int offset);
    internal int GetPort();
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    internal IPAddress GetIPAddress();
    private IPAddress GetIpv6Address();
    private IPAddress GetIPv4Address();
    public virtual string ToString();
    internal string GetIPAddressString();
    private string GetIPv4AddressString();
    private string GetIpv6AddressString();
    private static string GetIPv6AddressString(UInt16* numbers);
    private static KeyValuePair`2<int, int> FindCompressionRange(UInt16* numbers);
    private static bool ShouldHaveIpv4Embedded(UInt16* numbers);
}
internal enum Microsoft.AspNetCore.HttpSys.Internal.SslStatus : Enum {
    public byte value__;
    public static SslStatus Insecure;
    public static SslStatus NoClientCert;
    public static SslStatus ClientCert;
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.UnsafeNclNativeMethods : object {
    private static string sspicli_LIB;
    private static string api_ms_win_core_processthreads_LIB;
    private static string api_ms_win_core_io_LIB;
    private static string api_ms_win_core_handle_LIB;
    private static string api_ms_win_core_libraryloader_LIB;
    private static string api_ms_win_core_heap_LIB;
    private static string api_ms_win_core_heap_obsolete_LIB;
    private static string api_ms_win_core_kernel32_legacy_LIB;
    private static string TOKENBINDING;
    internal static UInt32 CancelIoEx(SafeHandle handle, SafeNativeOverlapped overlapped);
    internal static bool SetFileCompletionNotificationModes(SafeHandle handle, FileCompletionNotificationModes modes);
    public static int TokenBindingVerifyMessage(Byte* tokenBindingMessage, UInt32 tokenBindingMessageSize, Char* keyType, Byte* tlsUnique, UInt32 tlsUniqueSize, HeapAllocHandle& resultList);
    internal static IntPtr GetProcessHeap();
    internal static bool HeapFree(IntPtr hHeap, UInt32 dwFlags, IntPtr lpMem);
}
internal class Microsoft.AspNetCore.Server.HttpSys.AsyncAcceptContext : object {
    internal static IOCompletionCallback IOCallback;
    private TaskCompletionSource`1<RequestContext> _tcs;
    private HttpSysListener _server;
    private NativeRequestContext _nativeRequestContext;
    private static int DefaultBufferSize;
    private static int AlignmentPadding;
    internal Task`1<RequestContext> Task { get; }
    private TaskCompletionSource`1<RequestContext> Tcs { get; }
    internal HttpSysListener Server { get; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal AsyncAcceptContext(HttpSysListener server);
    private static AsyncAcceptContext();
    internal Task`1<RequestContext> get_Task();
    private TaskCompletionSource`1<RequestContext> get_Tcs();
    internal HttpSysListener get_Server();
    private static void IOCompleted(AsyncAcceptContext asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void IOWaitCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    internal UInt32 QueueBeginGetContext();
    internal void AllocateNativeRequest(Nullable`1<UInt32> size, ulong requestId);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.AspNetCore.Server.HttpSys.AuthenticationHandler : object {
    private RequestContext _requestContext;
    private AuthenticationScheme _scheme;
    public sealed virtual Task`1<AuthenticateResult> AuthenticateAsync();
    public sealed virtual Task ChallengeAsync(AuthenticationProperties properties);
    public sealed virtual Task ForbidAsync(AuthenticationProperties properties);
    public sealed virtual Task InitializeAsync(AuthenticationScheme scheme, HttpContext context);
}
public class Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager : object {
    private static int AuthInfoSize;
    private UrlGroup _urlGroup;
    private AuthenticationSchemes _authSchemes;
    private bool _allowAnonymous;
    public AuthenticationSchemes Schemes { get; public set; }
    public bool AllowAnonymous { get; public set; }
    private static AuthenticationManager();
    public AuthenticationSchemes get_Schemes();
    public void set_Schemes(AuthenticationSchemes value);
    public bool get_AllowAnonymous();
    public void set_AllowAnonymous(bool value);
    internal void SetUrlGroupSecurity(UrlGroup urlGroup);
    private void SetUrlGroupSecurity();
    internal static IList`1<string> GenerateChallenges(AuthenticationSchemes authSchemes);
    internal void SetAuthenticationChallenge(RequestContext context);
}
[FlagsAttribute]
public enum Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes : Enum {
    public int value__;
    public static AuthenticationSchemes None;
    public static AuthenticationSchemes Basic;
    public static AuthenticationSchemes NTLM;
    public static AuthenticationSchemes Negotiate;
    public static AuthenticationSchemes Kerberos;
}
internal enum Microsoft.AspNetCore.Server.HttpSys.BoundaryType : Enum {
    public int value__;
    public static BoundaryType None;
    public static BoundaryType Chunked;
    public static BoundaryType ContentLength;
    public static BoundaryType Close;
    public static BoundaryType PassThrough;
    public static BoundaryType Invalid;
}
public enum Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod : Enum {
    public int value__;
    public static ClientCertificateMethod NoCertificate;
    public static ClientCertificateMethod AllowCertificate;
    public static ClientCertificateMethod AllowRenegotation;
}
internal class Microsoft.AspNetCore.Server.HttpSys.ClientCertLoader : object {
    private static UInt32 CertBoblSize;
    private static IOCompletionCallback IOCallback;
    private static int RequestChannelBindStatusSize;
    private SafeNativeOverlapped _overlapped;
    private Byte[] _backingBuffer;
    private HTTP_SSL_CLIENT_CERT_INFO* _memoryBlob;
    private UInt32 _size;
    private TaskCompletionSource`1<object> _tcs;
    private RequestContext _requestContext;
    private int _clientCertError;
    private X509Certificate2 _clientCert;
    private Exception _clientCertException;
    private CancellationTokenRegistration _cancellationRegistration;
    internal SafeHandle RequestQueueHandle { get; }
    internal X509Certificate2 ClientCert { get; }
    internal int ClientCertError { get; }
    internal Exception ClientCertException { get; }
    private RequestContext RequestContext { get; }
    private Task Task { get; }
    private SafeNativeOverlapped NativeOverlapped { get; }
    private HTTP_SSL_CLIENT_CERT_INFO* RequestBlob { get; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal ClientCertLoader(RequestContext requestContext, CancellationToken cancellationToken);
    private static ClientCertLoader();
    internal SafeHandle get_RequestQueueHandle();
    internal X509Certificate2 get_ClientCert();
    internal int get_ClientCertError();
    internal Exception get_ClientCertException();
    private RequestContext get_RequestContext();
    private Task get_Task();
    private SafeNativeOverlapped get_NativeOverlapped();
    private HTTP_SSL_CLIENT_CERT_INFO* get_RequestBlob();
    private void Reset(UInt32 size);
    internal Task LoadClientCertificateAsync();
    private void Complete(int certErrors, X509Certificate2 cert);
    private void Fail(Exception ex);
    private void IOCompleted(UInt32 errorCode, UInt32 numBytes);
    private static void IOCompleted(ClientCertLoader asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void WaitCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal static ChannelBinding GetChannelBindingFromTls(RequestQueue requestQueue, ulong connectionId, ILogger logger);
    private static int GetTokenOffsetFromBlob(IntPtr blob);
    private static int GetTokenSizeFromBlob(IntPtr blob);
}
internal static class Microsoft.AspNetCore.Server.HttpSys.ComNetOS : object {
    internal static bool IsWin8orLater;
    private static ComNetOS();
}
internal class Microsoft.AspNetCore.Server.HttpSys.DisconnectListener : object {
    private ConcurrentDictionary`2<ulong, ConnectionCancellation> _connectionCancellationTokens;
    private RequestQueue _requestQueue;
    private ILogger _logger;
    internal DisconnectListener(RequestQueue requestQueue, ILogger logger);
    internal CancellationToken GetTokenForConnection(ulong connectionId);
    private CancellationToken GetOrCreateDisconnectToken(ulong connectionId);
    private ConnectionCancellation GetCreatedConnectionCancellation(ulong connectionId);
    private CancellationToken CreateDisconnectToken(ulong connectionId);
}
internal class Microsoft.AspNetCore.Server.HttpSys.FeatureContext : object {
    private RequestContext _requestContext;
    private IFeatureCollection _features;
    private bool _enableResponseCaching;
    private Stream _requestBody;
    private IHeaderDictionary _requestHeaders;
    private string _scheme;
    private string _httpMethod;
    private string _httpProtocolVersion;
    private string _query;
    private string _pathBase;
    private string _path;
    private string _rawTarget;
    private IPAddress _remoteIpAddress;
    private IPAddress _localIpAddress;
    private int _remotePort;
    private int _localPort;
    private string _connectionId;
    private string _traceIdentitfier;
    private X509Certificate2 _clientCert;
    private ClaimsPrincipal _user;
    private CancellationToken _disconnectToken;
    private Stream _responseStream;
    private PipeWriter _pipeWriter;
    private bool _bodyCompleted;
    private IHeaderDictionary _responseHeaders;
    private Fields _initializedFields;
    private List`1<Tuple`2<Func`2<object, Task>, object>> _onStartingActions;
    private List`1<Tuple`2<Func`2<object, Task>, object>> _onCompletedActions;
    private bool _responseStarted;
    private bool _completed;
    internal IFeatureCollection Features { get; }
    internal object RequestContext { get; }
    private Request Request { get; }
    private Response Response { get; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Body { get; private set; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Headers { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Method { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Path { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.PathBase { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Protocol { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.QueryString { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.RawTarget { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Scheme { get; private set; }
    private IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalIpAddress { get; private set; }
    private IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemoteIpAddress { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalPort { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemotePort { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.ConnectionId { get; private set; }
    private X509Certificate2 Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.ClientCertificate { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.Body { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.Stream { get; }
    private PipeWriter Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.Writer { get; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.Headers { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.HasStarted { get; }
    private string Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.ReasonPhrase { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.StatusCode { get; private set; }
    private CancellationToken Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.RequestAborted { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.IsUpgradableRequest { get; }
    private ClaimsPrincipal Microsoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature.User { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.TraceIdentifier { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.AllowSynchronousIO { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.IsReadOnly { get; }
    private Nullable`1<long> Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.MaxRequestBodySize { get; private set; }
    private SslProtocols Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.Protocol { get; }
    private CipherAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.CipherAlgorithm { get; }
    private int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.CipherStrength { get; }
    private HashAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.HashAlgorithm { get; }
    private int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.HashStrength { get; }
    private ExchangeAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.KeyExchangeAlgorithm { get; }
    private int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.KeyExchangeStrength { get; }
    private IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> Microsoft.AspNetCore.Server.HttpSys.IHttpSysRequestInfoFeature.RequestInfo { get; }
    internal FeatureContext(RequestContext requestContext);
    internal IFeatureCollection get_Features();
    internal object get_RequestContext();
    private Request get_Request();
    private Response get_Response();
    private bool IsNotInitialized(Fields field);
    private void SetInitialized(Fields field);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Body();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Body(Stream value);
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Headers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Headers(IHeaderDictionary value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Method();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Method(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Path();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Path(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_PathBase();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_PathBase(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Protocol();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Protocol(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_QueryString();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_QueryString(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_RawTarget();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_RawTarget(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Scheme();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Scheme(string value);
    private sealed virtual override IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_LocalIpAddress();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_LocalIpAddress(IPAddress value);
    private sealed virtual override IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_RemoteIpAddress();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_RemoteIpAddress(IPAddress value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_LocalPort();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_LocalPort(int value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_RemotePort();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_RemotePort(int value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_ConnectionId();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_ConnectionId(string value);
    private sealed virtual override X509Certificate2 Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.get_ClientCertificate();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.set_ClientCertificate(X509Certificate2 value);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.FeatureContext/<Microsoft-AspNetCore-Http-Features-ITlsConnectionFeature-GetClientCertificateAsync>d__87")]
private sealed virtual override Task`1<X509Certificate2> Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.GetClientCertificateAsync(CancellationToken cancellationToken);
    internal ITlsConnectionFeature GetTlsConnectionFeature();
    internal ITlsHandshakeFeature GetTlsHandshakeFeature();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.DisableBuffering();
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_Body();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_Body(Stream value);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.get_Stream();
    private sealed virtual override PipeWriter Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.get_Writer();
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_Headers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_Headers(IHeaderDictionary value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_HasStarted();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.OnStarting(Func`2<object, Task> callback, object state);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.OnCompleted(Func`2<object, Task> callback, object state);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_ReasonPhrase();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_ReasonPhrase(string value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_StatusCode();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_StatusCode(int value);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.FeatureContext/<Microsoft-AspNetCore-Http-Features-IHttpResponseBodyFeature-SendFileAsync>d__111")]
private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.SendFileAsync(string path, long offset, Nullable`1<long> length, CancellationToken cancellation);
    private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.StartAsync(CancellationToken cancellation);
    private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.CompleteAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.FeatureContext/<CompleteAsync>d__114")]
internal Task CompleteAsync();
    private sealed virtual override CancellationToken Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.get_RequestAborted();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.set_RequestAborted(CancellationToken value);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.Abort();
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.get_IsUpgradableRequest();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.FeatureContext/<Microsoft-AspNetCore-Http-Features-IHttpUpgradeFeature-UpgradeAsync>d__121")]
private sealed virtual override Task`1<Stream> Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.UpgradeAsync();
    private sealed virtual override ClaimsPrincipal Microsoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature.get_User();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature.set_User(ClaimsPrincipal value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.get_TraceIdentifier();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.set_TraceIdentifier(string value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.get_AllowSynchronousIO();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.set_AllowSynchronousIO(bool value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.get_IsReadOnly();
    private sealed virtual override Nullable`1<long> Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.get_MaxRequestBodySize();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.set_MaxRequestBodySize(Nullable`1<long> value);
    private sealed virtual override SslProtocols Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_Protocol();
    private sealed virtual override CipherAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_CipherAlgorithm();
    private sealed virtual override int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_CipherStrength();
    private sealed virtual override HashAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_HashAlgorithm();
    private sealed virtual override int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_HashStrength();
    private sealed virtual override ExchangeAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_KeyExchangeAlgorithm();
    private sealed virtual override int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_KeyExchangeStrength();
    private sealed virtual override IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> Microsoft.AspNetCore.Server.HttpSys.IHttpSysRequestInfoFeature.get_RequestInfo();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.FeatureContext/<OnResponseStart>d__152")]
internal Task OnResponseStart();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.FeatureContext/<NotifiyOnStartingAsync>d__153")]
private Task NotifiyOnStartingAsync();
    private void ConsiderEnablingResponseCache();
    private static Nullable`1<TimeSpan> GetCacheTtl(RequestContext requestContext);
    internal Task OnCompleted();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.FeatureContext/<NotifyOnCompletedAsync>d__157")]
private Task NotifyOnCompletedAsync();
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.HttpSys.Helpers : object {
    internal static Byte[] ChunkTerminator;
    internal static Byte[] CRLF;
    private static Helpers();
    [ExtensionAttribute]
internal static ConfiguredTaskAwaitable SupressContext(Task task);
    [ExtensionAttribute]
internal static ConfiguredTaskAwaitable`1<T> SupressContext(Task`1<T> task);
    [ExtensionAttribute]
internal static IAsyncResult ToIAsyncResult(Task task, AsyncCallback callback, object state);
    internal static ArraySegment`1<byte> GetChunkHeader(long size);
    internal static ArraySegment`1<byte> GetChunkHeader(int size);
}
public enum Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel : Enum {
    public long value__;
    public static Http503VerbosityLevel Basic;
    public static Http503VerbosityLevel Limited;
    public static Http503VerbosityLevel Full;
}
internal static class Microsoft.AspNetCore.Server.HttpSys.HttpApi : object {
    private static string HTTPAPI;
    private static HTTPAPI_VERSION version;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) supported;
    internal static HTTPAPI_VERSION Version { get; }
    internal static HTTP_API_VERSION ApiVersion { get; }
    internal static bool Supported { get; }
    private static HttpApi();
    internal static UInt32 HttpInitialize(HTTPAPI_VERSION version, UInt32 flags, Void* pReserved);
    internal static UInt32 HttpReceiveRequestEntityBody(SafeHandle requestQueueHandle, ulong requestId, UInt32 flags, IntPtr pEntityBuffer, UInt32 entityBufferLength, UInt32& bytesReturned, SafeNativeOverlapped pOverlapped);
    internal static UInt32 HttpReceiveClientCertificate(SafeHandle requestQueueHandle, ulong connectionId, UInt32 flags, HTTP_SSL_CLIENT_CERT_INFO* pSslClientCertInfo, UInt32 sslClientCertInfoSize, UInt32* pBytesReceived, SafeNativeOverlapped pOverlapped);
    internal static UInt32 HttpReceiveClientCertificate(SafeHandle requestQueueHandle, ulong connectionId, UInt32 flags, Byte* pSslClientCertInfo, UInt32 sslClientCertInfoSize, UInt32* pBytesReceived, SafeNativeOverlapped pOverlapped);
    internal static UInt32 HttpReceiveHttpRequest(SafeHandle requestQueueHandle, ulong requestId, UInt32 flags, HTTP_REQUEST* pRequestBuffer, UInt32 requestBufferLength, UInt32* pBytesReturned, SafeNativeOverlapped pOverlapped);
    internal static UInt32 HttpSendHttpResponse(SafeHandle requestQueueHandle, ulong requestId, UInt32 flags, HTTP_RESPONSE_V2* pHttpResponse, HTTP_CACHE_POLICY* pCachePolicy, UInt32* pBytesSent, IntPtr pReserved1, UInt32 Reserved2, SafeNativeOverlapped pOverlapped, IntPtr pLogData);
    internal static UInt32 HttpSendResponseEntityBody(SafeHandle requestQueueHandle, ulong requestId, UInt32 flags, ushort entityChunkCount, HTTP_DATA_CHUNK* pEntityChunks, UInt32* pBytesSent, IntPtr pReserved1, UInt32 Reserved2, SafeNativeOverlapped pOverlapped, IntPtr pLogData);
    internal static UInt32 HttpCancelHttpRequest(SafeHandle requestQueueHandle, ulong requestId, IntPtr pOverlapped);
    internal static UInt32 HttpWaitForDisconnectEx(SafeHandle requestQueueHandle, ulong connectionId, UInt32 reserved, SafeNativeOverlapped overlapped);
    internal static UInt32 HttpCreateServerSession(HTTPAPI_VERSION version, UInt64* serverSessionId, UInt32 reserved);
    internal static UInt32 HttpCreateUrlGroup(ulong serverSessionId, UInt64* urlGroupId, UInt32 reserved);
    internal static UInt32 HttpAddUrlToUrlGroup(ulong urlGroupId, string pFullyQualifiedUrl, ulong context, UInt32 pReserved);
    internal static UInt32 HttpSetUrlGroupProperty(ulong urlGroupId, HTTP_SERVER_PROPERTY serverProperty, IntPtr pPropertyInfo, UInt32 propertyInfoLength);
    internal static UInt32 HttpRemoveUrlFromUrlGroup(ulong urlGroupId, string pFullyQualifiedUrl, UInt32 flags);
    internal static UInt32 HttpCloseServerSession(ulong serverSessionId);
    internal static UInt32 HttpCloseUrlGroup(ulong urlGroupId);
    internal static UInt32 HttpSetRequestQueueProperty(SafeHandle requestQueueHandle, HTTP_SERVER_PROPERTY serverProperty, IntPtr pPropertyInfo, UInt32 propertyInfoLength, UInt32 reserved, IntPtr pReserved);
    internal static UInt32 HttpCreateRequestQueue(HTTPAPI_VERSION version, string pName, SECURITY_ATTRIBUTES pSecurityAttributes, HTTP_CREATE_REQUEST_QUEUE_FLAG flags, HttpRequestQueueV2Handle& pReqQueueHandle);
    internal static UInt32 HttpCloseRequestQueue(IntPtr pReqQueueHandle);
    internal static HTTPAPI_VERSION get_Version();
    internal static HTTP_API_VERSION get_ApiVersion();
    private static void InitHttpApi(ushort majorVersion, ushort minorVersion);
    internal static bool get_Supported();
}
internal static class Microsoft.AspNetCore.Server.HttpSys.HttpReasonPhrase : object {
    private static String[][] HttpReasonPhrases;
    private static HttpReasonPhrase();
    internal static string Get(int code);
}
internal class Microsoft.AspNetCore.Server.HttpSys.HttpRequestQueueV2Handle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.AspNetCore.Server.HttpSys.HttpServerSessionHandle : CriticalHandleZeroOrMinusOneIsInvalid {
    private int disposed;
    private ulong serverSessionId;
    internal HttpServerSessionHandle(ulong id);
    internal ulong DangerousGetServerSessionId();
    protected virtual bool ReleaseHandle();
}
public static class Microsoft.AspNetCore.Server.HttpSys.HttpSysDefaults : object {
    public static string AuthenticationScheme;
}
public class Microsoft.AspNetCore.Server.HttpSys.HttpSysException : Win32Exception {
    public int ErrorCode { get; }
    internal HttpSysException(int errorCode);
    internal HttpSysException(int errorCode, string message);
    public virtual int get_ErrorCode();
}
internal class Microsoft.AspNetCore.Server.HttpSys.HttpSysListener : object {
    internal static bool SkipIOCPCallbackOnSuccess;
    private static int UnknownHeaderLimit;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private ServerSession _serverSession;
    private UrlGroup _urlGroup;
    private RequestQueue _requestQueue;
    private DisconnectListener _disconnectListener;
    private object _internalLock;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpSysOptions <Options>k__BackingField;
    internal ILogger Logger { get; private set; }
    internal UrlGroup UrlGroup { get; }
    internal RequestQueue RequestQueue { get; }
    internal DisconnectListener DisconnectListener { get; }
    public HttpSysOptions Options { get; }
    public bool IsListening { get; }
    public HttpSysListener(HttpSysOptions options, ILoggerFactory loggerFactory);
    private static HttpSysListener();
    [CompilerGeneratedAttribute]
internal ILogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ILogger value);
    internal UrlGroup get_UrlGroup();
    internal RequestQueue get_RequestQueue();
    internal DisconnectListener get_DisconnectListener();
    [CompilerGeneratedAttribute]
public HttpSysOptions get_Options();
    public bool get_IsListening();
    public void Start();
    private void Stop();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private void DisposeInternal();
    public Task`1<RequestContext> AcceptAsync();
    internal bool ValidateRequest(NativeRequestContext requestMemory);
    internal bool ValidateAuth(NativeRequestContext requestMemory);
    internal void SendError(ulong requestId, int httpStatusCode, IList`1<string> authChallenges);
    private void CheckDisposed();
}
public class Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions : object {
    private static UInt32 MaximumRequestQueueNameLength;
    private static Http503VerbosityLevel DefaultRejectionVerbosityLevel;
    private static long DefaultRequestQueueLength;
    internal static int DefaultMaxAccepts;
    private static long DefaultMaxRequestBodySize;
    private Http503VerbosityLevel _rejectionVebosityLevel;
    private long _requestQueueLength;
    private Nullable`1<long> _maxConnections;
    private RequestQueue _requestQueue;
    private UrlGroup _urlGroup;
    private Nullable`1<long> _maxRequestBodySize;
    private string _requestQueueName;
    [CompilerGeneratedAttribute]
private RequestQueueMode <RequestQueueMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientCertificateMethod <ClientCertificateMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAccepts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableResponseCaching>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlPrefixCollection <UrlPrefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationManager <Authentication>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeoutManager <Timeouts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowWriteExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSynchronousIO>k__BackingField;
    public string RequestQueueName { get; public set; }
    public RequestQueueMode RequestQueueMode { get; public set; }
    public ClientCertificateMethod ClientCertificateMethod { get; public set; }
    public int MaxAccepts { get; public set; }
    public bool EnableResponseCaching { get; public set; }
    public UrlPrefixCollection UrlPrefixes { get; }
    public AuthenticationManager Authentication { get; }
    public TimeoutManager Timeouts { get; }
    public bool ThrowWriteExceptions { get; public set; }
    public Nullable`1<long> MaxConnections { get; public set; }
    public long RequestQueueLimit { get; public set; }
    public Nullable`1<long> MaxRequestBodySize { get; public set; }
    public bool AllowSynchronousIO { get; public set; }
    public Http503VerbosityLevel Http503Verbosity { get; public set; }
    private static HttpSysOptions();
    public string get_RequestQueueName();
    public void set_RequestQueueName(string value);
    [CompilerGeneratedAttribute]
public RequestQueueMode get_RequestQueueMode();
    [CompilerGeneratedAttribute]
public void set_RequestQueueMode(RequestQueueMode value);
    [CompilerGeneratedAttribute]
public ClientCertificateMethod get_ClientCertificateMethod();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateMethod(ClientCertificateMethod value);
    [CompilerGeneratedAttribute]
public int get_MaxAccepts();
    [CompilerGeneratedAttribute]
public void set_MaxAccepts(int value);
    [CompilerGeneratedAttribute]
public bool get_EnableResponseCaching();
    [CompilerGeneratedAttribute]
public void set_EnableResponseCaching(bool value);
    [CompilerGeneratedAttribute]
public UrlPrefixCollection get_UrlPrefixes();
    [CompilerGeneratedAttribute]
public AuthenticationManager get_Authentication();
    [CompilerGeneratedAttribute]
public TimeoutManager get_Timeouts();
    [CompilerGeneratedAttribute]
public bool get_ThrowWriteExceptions();
    [CompilerGeneratedAttribute]
public void set_ThrowWriteExceptions(bool value);
    public Nullable`1<long> get_MaxConnections();
    public void set_MaxConnections(Nullable`1<long> value);
    public long get_RequestQueueLimit();
    public void set_RequestQueueLimit(long value);
    public Nullable`1<long> get_MaxRequestBodySize();
    public void set_MaxRequestBodySize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_AllowSynchronousIO();
    [CompilerGeneratedAttribute]
public void set_AllowSynchronousIO(bool value);
    public Http503VerbosityLevel get_Http503Verbosity();
    public void set_Http503Verbosity(Http503VerbosityLevel value);
    internal void Apply(UrlGroup urlGroup, RequestQueue requestQueue);
}
internal static class Microsoft.AspNetCore.Server.HttpSys.HttpSysSettings : object {
    private static string HttpSysParametersKey;
    private static bool EnableNonUtf8Default;
    private static bool FavorUtf8Default;
    private static string EnableNonUtf8Name;
    private static string FavorUtf8Name;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) enableNonUtf8;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) favorUtf8;
    internal static bool EnableNonUtf8 { get; }
    internal static bool FavorUtf8 { get; }
    private static HttpSysSettings();
    internal static bool get_EnableNonUtf8();
    internal static bool get_FavorUtf8();
    private static void ReadHttpSysRegistrySettings();
    private static bool ReadRegistryValue(RegistryKey key, string valueName, bool defaultValue);
    private static void LogRegistryException(string methodName, Exception e);
    private static void LogWarning(string methodName, string message, Object[] args);
}
public interface Microsoft.AspNetCore.Server.HttpSys.IHttpSysRequestInfoFeature {
    public IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> RequestInfo { get; }
    public abstract virtual IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> get_RequestInfo();
}
internal static class Microsoft.AspNetCore.Server.HttpSys.IntPtrHelper : object {
    internal static IntPtr Add(IntPtr a, int b);
    internal static long Subtract(IntPtr a, IntPtr b);
}
internal static class Microsoft.AspNetCore.Server.HttpSys.LogHelper : object {
    internal static ILogger CreateLogger(ILoggerFactory factory, Type type);
    internal static void LogInfo(ILogger logger, string data);
    internal static void LogWarning(ILogger logger, string data);
    internal static void LogDebug(ILogger logger, string data);
    internal static void LogDebug(ILogger logger, string location, string data);
    internal static void LogDebug(ILogger logger, string location, Exception exception);
    internal static void LogException(ILogger logger, string location, Exception exception);
    internal static void LogError(ILogger logger, string location, string message);
}
internal class Microsoft.AspNetCore.Server.HttpSys.MessagePump : object {
    private ILogger _logger;
    private HttpSysOptions _options;
    private IHttpApplication`1<object> _application;
    private int _maxAccepts;
    private int _acceptorCounts;
    private Action`1<object> _processRequest;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _stopping;
    private int _outstandingRequests;
    private TaskCompletionSource`1<object> _shutdownSignal;
    private int _shutdownSignalCompleted;
    private ServerAddressesFeature _serverAddresses;
    [CompilerGeneratedAttribute]
private HttpSysListener <Listener>k__BackingField;
    [CompilerGeneratedAttribute]
private IFeatureCollection <Features>k__BackingField;
    internal HttpSysListener Listener { get; }
    public IFeatureCollection Features { get; }
    private bool Stopping { get; }
    public MessagePump(IOptions`1<HttpSysOptions> options, ILoggerFactory loggerFactory, IAuthenticationSchemeProvider authentication);
    [CompilerGeneratedAttribute]
internal HttpSysListener get_Listener();
    [CompilerGeneratedAttribute]
public sealed virtual IFeatureCollection get_Features();
    private bool get_Stopping();
    public sealed virtual Task StartAsync(IHttpApplication`1<TContext> application, CancellationToken cancellationToken);
    private void ActivateRequestProcessingLimits();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.MessagePump/<ProcessRequestsWorker>d__22")]
private void ProcessRequestsWorker();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.MessagePump/<ProcessRequestAsync>d__23")]
private void ProcessRequestAsync(object requestContextObj);
    private static void SetFatalResponse(RequestContext context, int status);
    public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
internal class Microsoft.AspNetCore.Server.HttpSys.OpaqueStream : Stream {
    private Stream _requestStream;
    private Stream _responseStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal OpaqueStream(Stream requestStream, Stream responseStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.AspNetCore.Server.HttpSys.Request : object {
    private NativeRequestContext _nativeRequestContext;
    private X509Certificate2 _clientCert;
    private BoundaryType _contentBoundaryType;
    private Nullable`1<long> _contentLength;
    private RequestStream _nativeStream;
    private SocketAddress _localEndPoint;
    private SocketAddress _remoteEndPoint;
    private IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> _requestInfo;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private ulong <UConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private SslStatus <SslStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryString>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestHeaders <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private HTTP_VERB <KnownMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathBase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private WindowsPrincipal <User>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherAlgorithmType <CipherAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CipherStrength>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmType <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HashStrength>k__BackingField;
    [CompilerGeneratedAttribute]
private ExchangeAlgorithmType <KeyExchangeAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyExchangeStrength>k__BackingField;
    internal ulong UConnectionId { get; }
    public long ConnectionId { get; }
    internal ulong RequestId { get; }
    private SslStatus SslStatus { get; }
    private RequestContext RequestContext { get; }
    public string QueryString { get; }
    public Nullable`1<long> ContentLength { get; }
    public RequestHeaders Headers { get; }
    internal HTTP_VERB KnownMethod { get; }
    internal bool IsHeadMethod { get; }
    public string Method { get; }
    public Stream Body { get; }
    public bool HasRequestBodyStarted { get; }
    public Nullable`1<long> MaxRequestBodySize { get; public set; }
    public string PathBase { get; }
    public string Path { get; }
    public bool IsHttps { get; }
    public string RawUrl { get; }
    public Version ProtocolVersion { get; }
    public bool HasEntityBody { get; }
    private SocketAddress RemoteEndPoint { get; }
    private SocketAddress LocalEndPoint { get; }
    public IPAddress RemoteIpAddress { get; }
    public IPAddress LocalIpAddress { get; }
    public int RemotePort { get; }
    public int LocalPort { get; }
    public string Scheme { get; }
    internal bool IsUpgradable { get; }
    internal WindowsPrincipal User { get; }
    public SslProtocols Protocol { get; private set; }
    public CipherAlgorithmType CipherAlgorithm { get; private set; }
    public int CipherStrength { get; private set; }
    public HashAlgorithmType HashAlgorithm { get; private set; }
    public int HashStrength { get; private set; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; private set; }
    public int KeyExchangeStrength { get; private set; }
    public IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> RequestInfo { get; }
    public X509Certificate2 ClientCertificate { get; }
    internal Request(RequestContext requestContext, NativeRequestContext nativeRequestContext);
    [CompilerGeneratedAttribute]
internal ulong get_UConnectionId();
    public long get_ConnectionId();
    [CompilerGeneratedAttribute]
internal ulong get_RequestId();
    [CompilerGeneratedAttribute]
private SslStatus get_SslStatus();
    [CompilerGeneratedAttribute]
private RequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
public string get_QueryString();
    public Nullable`1<long> get_ContentLength();
    [CompilerGeneratedAttribute]
public RequestHeaders get_Headers();
    [CompilerGeneratedAttribute]
internal HTTP_VERB get_KnownMethod();
    internal bool get_IsHeadMethod();
    [CompilerGeneratedAttribute]
public string get_Method();
    public Stream get_Body();
    private RequestStream EnsureRequestStream();
    public bool get_HasRequestBodyStarted();
    public Nullable`1<long> get_MaxRequestBodySize();
    public void set_MaxRequestBodySize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_PathBase();
    [CompilerGeneratedAttribute]
public string get_Path();
    public bool get_IsHttps();
    [CompilerGeneratedAttribute]
public string get_RawUrl();
    [CompilerGeneratedAttribute]
public Version get_ProtocolVersion();
    public bool get_HasEntityBody();
    private SocketAddress get_RemoteEndPoint();
    private SocketAddress get_LocalEndPoint();
    public IPAddress get_RemoteIpAddress();
    public IPAddress get_LocalIpAddress();
    public int get_RemotePort();
    public int get_LocalPort();
    public string get_Scheme();
    internal bool get_IsUpgradable();
    [CompilerGeneratedAttribute]
internal WindowsPrincipal get_User();
    [CompilerGeneratedAttribute]
public SslProtocols get_Protocol();
    [CompilerGeneratedAttribute]
private void set_Protocol(SslProtocols value);
    [CompilerGeneratedAttribute]
public CipherAlgorithmType get_CipherAlgorithm();
    [CompilerGeneratedAttribute]
private void set_CipherAlgorithm(CipherAlgorithmType value);
    [CompilerGeneratedAttribute]
public int get_CipherStrength();
    [CompilerGeneratedAttribute]
private void set_CipherStrength(int value);
    [CompilerGeneratedAttribute]
public HashAlgorithmType get_HashAlgorithm();
    [CompilerGeneratedAttribute]
private void set_HashAlgorithm(HashAlgorithmType value);
    [CompilerGeneratedAttribute]
public int get_HashStrength();
    [CompilerGeneratedAttribute]
private void set_HashStrength(int value);
    [CompilerGeneratedAttribute]
public ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    [CompilerGeneratedAttribute]
private void set_KeyExchangeAlgorithm(ExchangeAlgorithmType value);
    [CompilerGeneratedAttribute]
public int get_KeyExchangeStrength();
    [CompilerGeneratedAttribute]
private void set_KeyExchangeStrength(int value);
    public IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> get_RequestInfo();
    private void GetTlsHandshakeResults();
    public X509Certificate2 get_ClientCertificate();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.Request/<GetClientCertificateAsync>d__116")]
public Task`1<X509Certificate2> GetClientCertificateAsync(CancellationToken cancellationToken);
    internal UInt32 GetChunks(Int32& dataChunkIndex, UInt32& dataChunkOffset, Byte[] buffer, int offset, int size);
    internal void Dispose();
    private void CheckDisposed();
    internal void SwitchToOpaqueMode();
}
internal class Microsoft.AspNetCore.Server.HttpSys.RequestContext : object {
    private static Action`1<object> AbortDelegate;
    private NativeRequestContext _memoryBlob;
    private CancellationTokenSource _requestAbortSource;
    private Nullable`1<CancellationToken> _disconnectToken;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private HttpSysListener <Server>k__BackingField;
    [CompilerGeneratedAttribute]
private Request <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private Response <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSynchronousIO>k__BackingField;
    internal HttpSysListener Server { get; }
    internal ILogger Logger { get; }
    public Request Request { get; }
    public Response Response { get; }
    public WindowsPrincipal User { get; }
    public CancellationToken DisconnectToken { get; }
    public Guid TraceIdentifier { get; }
    public bool IsUpgradableRequest { get; }
    internal bool AllowSynchronousIO { get; internal set; }
    internal RequestContext(HttpSysListener server, NativeRequestContext memoryBlob);
    private static RequestContext();
    [CompilerGeneratedAttribute]
internal HttpSysListener get_Server();
    internal ILogger get_Logger();
    [CompilerGeneratedAttribute]
public Request get_Request();
    [CompilerGeneratedAttribute]
public Response get_Response();
    public WindowsPrincipal get_User();
    public CancellationToken get_DisconnectToken();
    public Guid get_TraceIdentifier();
    public bool get_IsUpgradableRequest();
    [CompilerGeneratedAttribute]
internal bool get_AllowSynchronousIO();
    [CompilerGeneratedAttribute]
internal void set_AllowSynchronousIO(bool value);
    public Task`1<Stream> UpgradeAsync();
    internal bool TryGetChannelBinding(ChannelBinding& value);
    public sealed virtual void Dispose();
    public void Abort();
    private static void Abort(object state);
    internal CancellationTokenRegistration RegisterForCancellation(CancellationToken cancellationToken);
    internal void ForceCancelRequest();
}
internal class Microsoft.AspNetCore.Server.HttpSys.RequestQueue : object {
    private static int BindingInfoSize;
    private RequestQueueMode _mode;
    private UrlGroup _urlGroup;
    private ILogger _logger;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private bool <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private SafeHandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadPoolBoundHandle <BoundHandle>k__BackingField;
    internal bool Created { get; }
    internal SafeHandle Handle { get; }
    internal ThreadPoolBoundHandle BoundHandle { get; }
    internal RequestQueue(UrlGroup urlGroup, string requestQueueName, RequestQueueMode mode, ILogger logger);
    private static RequestQueue();
    [CompilerGeneratedAttribute]
internal bool get_Created();
    [CompilerGeneratedAttribute]
internal SafeHandle get_Handle();
    [CompilerGeneratedAttribute]
internal ThreadPoolBoundHandle get_BoundHandle();
    internal void AttachToUrlGroup();
    internal void DetachFromUrlGroup();
    internal void SetLengthLimit(long length);
    internal void SetRejectionVerbosity(Http503VerbosityLevel verbosity);
    public void Dispose();
    private void CheckDisposed();
}
public enum Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode : Enum {
    public int value__;
    public static RequestQueueMode Create;
    public static RequestQueueMode Attach;
    public static RequestQueueMode CreateOrAttach;
}
internal class Microsoft.AspNetCore.Server.HttpSys.RequestStream : Stream {
    private static int MaxReadSize;
    private RequestContext _requestContext;
    private UInt32 _dataChunkOffset;
    private int _dataChunkIndex;
    private Nullable`1<long> _maxSize;
    private long _totalRead;
    private bool _closed;
    [CompilerGeneratedAttribute]
private bool <HasStarted>k__BackingField;
    internal RequestContext RequestContext { get; }
    private SafeHandle RequestQueueHandle { get; }
    private ulong RequestId { get; }
    private ILogger Logger { get; }
    public bool HasStarted { get; private set; }
    public Nullable`1<long> MaxSize { get; public set; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal RequestStream(RequestContext httpContext);
    internal RequestContext get_RequestContext();
    private SafeHandle get_RequestQueueHandle();
    private ulong get_RequestId();
    private ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_HasStarted();
    [CompilerGeneratedAttribute]
private void set_HasStarted(bool value);
    public Nullable`1<long> get_MaxSize();
    public void set_MaxSize(Nullable`1<long> value);
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    internal void SwitchToOpaqueMode();
    internal void Abort();
    private void ValidateReadBuffer(Byte[] buffer, int offset, int size);
    public virtual int Read(Byte[] buffer, int offset, int size);
    internal void UpdateAfterRead(UInt32 statusCode, UInt32 dataRead);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private void CheckSizeLimit();
    internal bool TryCheckSizeLimit(int bytesRead, Exception& exception);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.AspNetCore.Server.HttpSys.RequestStreamAsyncResult : object {
    private static IOCompletionCallback IOCallback;
    private SafeNativeOverlapped _overlapped;
    private IntPtr _pinnedBuffer;
    private UInt32 _dataAlreadyRead;
    private TaskCompletionSource`1<int> _tcs;
    private RequestStream _requestStream;
    private AsyncCallback _callback;
    private CancellationTokenRegistration _cancellationRegistration;
    [CompilerGeneratedAttribute]
private bool <EndCalled>k__BackingField;
    internal RequestStream RequestStream { get; }
    internal SafeNativeOverlapped NativeOverlapped { get; }
    internal IntPtr PinnedBuffer { get; }
    internal UInt32 DataAlreadyRead { get; }
    internal Task`1<int> Task { get; }
    internal bool EndCalled { get; internal set; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal RequestStreamAsyncResult(RequestStream requestStream, object userState, AsyncCallback callback);
    internal RequestStreamAsyncResult(RequestStream requestStream, object userState, AsyncCallback callback, UInt32 dataAlreadyRead);
    internal RequestStreamAsyncResult(RequestStream requestStream, object userState, AsyncCallback callback, Byte[] buffer, int offset, UInt32 dataAlreadyRead);
    internal RequestStreamAsyncResult(RequestStream requestStream, object userState, AsyncCallback callback, Byte[] buffer, int offset, UInt32 dataAlreadyRead, CancellationTokenRegistration cancellationRegistration);
    private static RequestStreamAsyncResult();
    internal RequestStream get_RequestStream();
    internal SafeNativeOverlapped get_NativeOverlapped();
    internal IntPtr get_PinnedBuffer();
    internal UInt32 get_DataAlreadyRead();
    internal Task`1<int> get_Task();
    [CompilerGeneratedAttribute]
internal bool get_EndCalled();
    [CompilerGeneratedAttribute]
internal void set_EndCalled(bool value);
    internal void IOCompleted(UInt32 errorCode, UInt32 numBytes);
    private static void IOCompleted(RequestStreamAsyncResult asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void Callback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    internal void Complete(int read, UInt32 errorCode);
    internal void Fail(Exception ex);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
}
internal static class Microsoft.AspNetCore.Server.HttpSys.Resources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Exception_ArrayTooSmall { get; }
    internal static string Exception_EndCalledMultipleTimes { get; }
    internal static string Exception_InvalidStatusCode { get; }
    internal static string Exception_NoSeek { get; }
    internal static string Exception_PrefixAlreadyRegistered { get; }
    internal static string Exception_ReadOnlyStream { get; }
    internal static string Exception_TooMuchWritten { get; }
    internal static string Exception_UnsupportedScheme { get; }
    internal static string Exception_WriteOnlyStream { get; }
    internal static string Exception_WrongIAsyncResult { get; }
    internal static string Warning_ExceptionInOnResponseCompletedAction { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_Exception_ArrayTooSmall();
    internal static string get_Exception_EndCalledMultipleTimes();
    internal static string get_Exception_InvalidStatusCode();
    internal static string FormatException_InvalidStatusCode(object p0);
    internal static string get_Exception_NoSeek();
    internal static string get_Exception_PrefixAlreadyRegistered();
    internal static string FormatException_PrefixAlreadyRegistered(object p0);
    internal static string get_Exception_ReadOnlyStream();
    internal static string get_Exception_TooMuchWritten();
    internal static string get_Exception_UnsupportedScheme();
    internal static string get_Exception_WriteOnlyStream();
    internal static string get_Exception_WrongIAsyncResult();
    internal static string get_Warning_ExceptionInOnResponseCompletedAction();
    internal static string FormatWarning_ExceptionInOnResponseCompletedAction(object p0);
}
internal class Microsoft.AspNetCore.Server.HttpSys.Response : object {
    private static bool SupportsGoAway;
    private ResponseState _responseState;
    private string _reasonPhrase;
    private ResponseBody _nativeStream;
    private AuthenticationSchemes _authChallenges;
    private Nullable`1<TimeSpan> _cacheTtl;
    private long _expectedBodyLength;
    private BoundaryType _boundaryType;
    private HTTP_RESPONSE_V2 _nativeResponse;
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    private static Int32[] StatusWithNoResponseBody;
    [CompilerGeneratedAttribute]
private HeaderCollection <Headers>k__BackingField;
    private RequestContext RequestContext { get; }
    private Request Request { get; }
    public int StatusCode { get; public set; }
    public string ReasonPhrase { get; public set; }
    public Stream Body { get; }
    internal bool BodyIsFinished { get; }
    public AuthenticationSchemes AuthenticationChallenges { get; public set; }
    public HeaderCollection Headers { get; }
    internal long ExpectedBodyLength { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public Nullable`1<TimeSpan> CacheTtl { get; public set; }
    internal BoundaryType BoundaryType { get; }
    internal bool HasComputedHeaders { get; }
    public bool HasStarted { get; }
    internal Response(RequestContext requestContext);
    private static Response();
    [CompilerGeneratedAttribute]
private RequestContext get_RequestContext();
    private Request get_Request();
    public int get_StatusCode();
    public void set_StatusCode(int value);
    public string get_ReasonPhrase();
    public void set_ReasonPhrase(string value);
    public Stream get_Body();
    internal bool get_BodyIsFinished();
    public AuthenticationSchemes get_AuthenticationChallenges();
    public void set_AuthenticationChallenges(AuthenticationSchemes value);
    private string GetReasonPhrase(int statusCode);
    private static bool CanSendResponseBody(int responseCode);
    [CompilerGeneratedAttribute]
public HeaderCollection get_Headers();
    internal long get_ExpectedBodyLength();
    public Nullable`1<long> get_ContentLength();
    public void set_ContentLength(Nullable`1<long> value);
    public Nullable`1<TimeSpan> get_CacheTtl();
    public void set_CacheTtl(Nullable`1<TimeSpan> value);
    internal void Abort();
    internal void Dispose();
    internal BoundaryType get_BoundaryType();
    internal bool get_HasComputedHeaders();
    public bool get_HasStarted();
    private void CheckResponseStarted();
    private void EnsureResponseStream();
    internal UInt32 SendHeaders(HTTP_DATA_CHUNK[] dataChunks, ResponseStreamAsyncResult asyncResult, HTTP_FLAGS flags, bool isOpaqueUpgrade);
    internal HTTP_FLAGS ComputeHeaders(long writeCount, bool endOfRequest);
    private static bool Matches(string knownValue, string input);
    private List`1<GCHandle> SerializeHeaders(bool isOpaqueUpgrade);
    private static void FreePinnedHeaders(List`1<GCHandle> pinnedHeaders);
    internal void SendOpaqueUpgrade();
    internal void CancelLastWrite();
    public Task SendFileAsync(string path, long offset, Nullable`1<long> count, CancellationToken cancel);
    internal void SwitchToOpaqueMode();
}
internal class Microsoft.AspNetCore.Server.HttpSys.ResponseBody : Stream {
    private RequestContext _requestContext;
    private long _leftToWrite;
    private bool _skipWrites;
    private bool _disposed;
    private ResponseStreamAsyncResult _lastWrite;
    internal RequestContext RequestContext { get; }
    private SafeHandle RequestQueueHandle { get; }
    private ulong RequestId { get; }
    private ILogger Logger { get; }
    internal bool ThrowWriteExceptions { get; }
    internal bool IsDisposed { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ResponseBody(RequestContext requestContext);
    internal RequestContext get_RequestContext();
    private SafeHandle get_RequestQueueHandle();
    private ulong get_RequestId();
    private ILogger get_Logger();
    internal bool get_ThrowWriteExceptions();
    internal bool get_IsDisposed();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    private void FlushInternal(bool endOfRequest, ArraySegment`1<byte> data);
    private List`1<GCHandle> PinDataBuffers(bool endOfRequest, ArraySegment`1<byte> data, HTTP_DATA_CHUNK[]& dataChunks);
    private static void SetDataChunk(HTTP_DATA_CHUNK[] chunks, Int32& chunkIndex, List`1<GCHandle> pins, ArraySegment`1<byte> buffer);
    private void FreeDataBuffers(List`1<GCHandle> pinnedBuffers);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    private Task FlushInternalAsync(ArraySegment`1<byte> data, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    internal void Abort(bool dispose);
    private HTTP_FLAGS ComputeLeftToWrite(long writeCount, bool endOfRequest);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void CheckWriteCount(Nullable`1<long> count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.ResponseBody/<SendFileAsync>d__48")]
internal Task SendFileAsync(string fileName, long offset, Nullable`1<long> count, CancellationToken cancellationToken);
    internal Task SendFileAsyncCore(string fileName, long offset, Nullable`1<long> count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    internal void SwitchToOpaqueMode();
    internal void CancelLastWrite();
    private void CheckDisposed();
}
internal class Microsoft.AspNetCore.Server.HttpSys.ResponseStream : Stream {
    private Stream _innerStream;
    private Func`1<Task> _onStart;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ResponseStream(Stream innerStream, Func`1<Task> onStart);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Flush();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.ResponseStream/<FlushAsync>d__20")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.ResponseStream/<WriteAsync>d__22")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private static IAsyncResult ToIAsyncResult(Task task, AsyncCallback callback, object state);
}
internal class Microsoft.AspNetCore.Server.HttpSys.ResponseStreamAsyncResult : object {
    private static IOCompletionCallback IOCallback;
    private SafeNativeOverlapped _overlapped;
    private HTTP_DATA_CHUNK[] _dataChunks;
    private FileStream _fileStream;
    private ResponseBody _responseStream;
    private TaskCompletionSource`1<object> _tcs;
    private UInt32 _bytesSent;
    private CancellationToken _cancellationToken;
    private CancellationTokenRegistration _cancellationRegistration;
    [CompilerGeneratedAttribute]
private bool <EndCalled>k__BackingField;
    internal SafeNativeOverlapped NativeOverlapped { get; }
    internal Task Task { get; }
    internal UInt32 BytesSent { get; internal set; }
    internal ushort DataChunkCount { get; }
    internal HTTP_DATA_CHUNK* DataChunks { get; }
    internal bool EndCalled { get; internal set; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal ResponseStreamAsyncResult(ResponseBody responseStream, CancellationToken cancellationToken);
    internal ResponseStreamAsyncResult(ResponseBody responseStream, ArraySegment`1<byte> data, bool chunked, CancellationToken cancellationToken);
    internal ResponseStreamAsyncResult(ResponseBody responseStream, FileStream fileStream, long offset, long count, bool chunked, CancellationToken cancellationToken);
    private static ResponseStreamAsyncResult();
    private static void SetDataChunk(HTTP_DATA_CHUNK[] chunks, Int32& chunkIndex, Object[] objectsToPin, Int32& pinIndex, ArraySegment`1<byte> segment);
    internal SafeNativeOverlapped get_NativeOverlapped();
    internal Task get_Task();
    internal UInt32 get_BytesSent();
    internal void set_BytesSent(UInt32 value);
    internal ushort get_DataChunkCount();
    internal HTTP_DATA_CHUNK* get_DataChunks();
    [CompilerGeneratedAttribute]
internal bool get_EndCalled();
    [CompilerGeneratedAttribute]
internal void set_EndCalled(bool value);
    internal void IOCompleted(UInt32 errorCode);
    internal void IOCompleted(UInt32 errorCode, UInt32 numBytes);
    private static void IOCompleted(ResponseStreamAsyncResult asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void Callback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    internal void Complete();
    internal void FailSilently();
    internal void Cancel(bool dispose);
    internal void Fail(Exception ex);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    public sealed virtual void Dispose();
}
internal class Microsoft.AspNetCore.Server.HttpSys.ServerSession : object {
    [CompilerGeneratedAttribute]
private HttpServerSessionHandle <Id>k__BackingField;
    public HttpServerSessionHandle Id { get; private set; }
    [CompilerGeneratedAttribute]
public HttpServerSessionHandle get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(HttpServerSessionHandle value);
    public sealed virtual void Dispose();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Server.HttpSys.StandardFeatureCollection : object {
    private static Func`2<FeatureContext, object> _identityFunc;
    private static Dictionary`2<Type, Func`2<FeatureContext, object>> _featureFuncLookup;
    private FeatureContext _featureContext;
    public bool IsReadOnly { get; }
    public int Revision { get; }
    public object Item { get; public set; }
    private static StandardFeatureCollection();
    public StandardFeatureCollection(FeatureContext featureContext);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Revision();
    public sealed virtual object get_Item(Type key);
    public sealed virtual void set_Item(Type key, object value);
    private static object ReturnIdentity(FeatureContext featureContext);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.StandardFeatureCollection/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<System-Type,System-Object>>-GetEnumerator>d__14")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<Type, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type,System.Object>>.GetEnumerator();
    public sealed virtual TFeature Get();
    public sealed virtual void Set(TFeature instance);
}
public class Microsoft.AspNetCore.Server.HttpSys.TimeoutManager : object {
    private static int TimeoutLimitSize;
    private UrlGroup _urlGroup;
    private Int32[] _timeouts;
    private UInt32 _minSendBytesPerSecond;
    public TimeSpan EntityBody { get; public set; }
    public TimeSpan DrainEntityBody { get; public set; }
    public TimeSpan RequestQueue { get; public set; }
    public TimeSpan IdleConnection { get; public set; }
    public TimeSpan HeaderWait { get; public set; }
    public long MinSendBytesPerSecond { get; public set; }
    private static TimeoutManager();
    public TimeSpan get_EntityBody();
    public void set_EntityBody(TimeSpan value);
    public TimeSpan get_DrainEntityBody();
    public void set_DrainEntityBody(TimeSpan value);
    public TimeSpan get_RequestQueue();
    public void set_RequestQueue(TimeSpan value);
    public TimeSpan get_IdleConnection();
    public void set_IdleConnection(TimeSpan value);
    public TimeSpan get_HeaderWait();
    public void set_HeaderWait(TimeSpan value);
    public long get_MinSendBytesPerSecond();
    public void set_MinSendBytesPerSecond(long value);
    private TimeSpan GetTimeSpanTimeout(HTTP_TIMEOUT_TYPE type);
    private void SetTimeSpanTimeout(HTTP_TIMEOUT_TYPE type, TimeSpan value);
    internal void SetUrlGroupTimeouts(UrlGroup urlGroup);
    private void SetUrlGroupTimeouts(Int32[] timeouts, UInt32 minSendBytesPerSecond);
}
internal static class Microsoft.AspNetCore.Server.HttpSys.TokenBindingUtil : object {
    private static Byte[] ExtractIdentifierBlob(TOKENBINDING_RESULT_DATA* pTokenBindingResultData);
    public static Byte[] GetProvidedTokenIdFromBindingInfo(HTTP_REQUEST_TOKEN_BINDING_INFO* pTokenBindingInfo, Byte[]& referredId);
}
internal class Microsoft.AspNetCore.Server.HttpSys.UrlGroup : object {
    private static int QosInfoSize;
    private ServerSession _serverSession;
    private ILogger _logger;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private ulong <Id>k__BackingField;
    internal ulong Id { get; private set; }
    internal UrlGroup(ServerSession serverSession, ILogger logger);
    private static UrlGroup();
    [CompilerGeneratedAttribute]
internal ulong get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(ulong value);
    internal void SetMaxConnections(long maxConnections);
    internal void SetProperty(HTTP_SERVER_PROPERTY property, IntPtr info, UInt32 infosize, bool throwOnError);
    internal void RegisterPrefix(string uriPrefix, int contextId);
    internal bool UnregisterPrefix(string uriPrefix);
    public sealed virtual void Dispose();
    private void CheckDisposed();
}
public class Microsoft.AspNetCore.Server.HttpSys.UrlPrefix : object {
    [CompilerGeneratedAttribute]
private bool <IsHttps>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostAndPort>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PortValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathWithoutTrailingSlash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPrefix>k__BackingField;
    public bool IsHttps { get; }
    public string Scheme { get; }
    public string Host { get; }
    public string Port { get; }
    internal string HostAndPort { get; }
    public int PortValue { get; }
    public string Path { get; }
    internal string PathWithoutTrailingSlash { get; }
    public string FullPrefix { get; }
    private UrlPrefix(bool isHttps, string scheme, string host, string port, int portValue, string path);
    public static UrlPrefix Create(string scheme, string host, string port, string path);
    public static UrlPrefix Create(string scheme, string host, Nullable`1<int> portValue, string path);
    public static UrlPrefix Create(string prefix);
    [CompilerGeneratedAttribute]
public bool get_IsHttps();
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public string get_Port();
    [CompilerGeneratedAttribute]
internal string get_HostAndPort();
    [CompilerGeneratedAttribute]
public int get_PortValue();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
internal string get_PathWithoutTrailingSlash();
    [CompilerGeneratedAttribute]
public string get_FullPrefix();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection : object {
    private IDictionary`2<int, UrlPrefix> _prefixes;
    private UrlGroup _urlGroup;
    private int _nextId;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public void Add(string prefix);
    public sealed virtual void Add(UrlPrefix item);
    internal UrlPrefix GetPrefix(int id);
    internal bool TryMatchLongestPrefix(bool isHttps, string host, string originalPath, String& pathBase, String& remainingPath);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(UrlPrefix item);
    public sealed virtual void CopyTo(UrlPrefix[] array, int arrayIndex);
    public bool Remove(string prefix);
    public sealed virtual bool Remove(UrlPrefix item);
    public sealed virtual IEnumerator`1<UrlPrefix> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void RegisterAllPrefixes(UrlGroup urlGroup);
    internal void UnregisterAllPrefixes();
}
internal static class Microsoft.AspNetCore.Server.HttpSys.ValidationHelper : object {
    public static string ExceptionMessage(Exception exception);
    public static string ToString(object objectValue);
    public static string HashString(object objectValue);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StringUtilities : object {
    private static Char[] s_encode16Chars;
    private static StringUtilities();
    [ExtensionAttribute]
public static string GetAsciiOrUTF8StringNonNullCharacters(Span`1<byte> span, Encoding defaultEncoding);
    [ExtensionAttribute]
public static string GetLatin1StringNonNullCharacters(Span`1<byte> span);
    public static bool TryGetAsciiString(Byte* input, Char* output, int count);
    public static bool TryGetLatin1String(Byte* input, Char* output, int count);
    public static bool BytesOrdinalEqualsStringAndAscii(string previousValue, Span`1<byte> newValue);
    private static bool WidenFourAsciiBytesToUtf16AndCompareToChars(Char& charStart, UInt32 value);
    private static bool WidenTwoAsciiBytesToUtf16AndCompareToChars(Char& charStart, ushort value);
    private static bool AllBytesInUInt32AreAscii(UInt32 value);
    private static bool AllBytesInUInt16AreAscii(ushort value);
    private static bool IsValidHeaderString(string value);
    public static string ConcatAsHexSuffix(string str, char separator, UInt32 number);
    private static bool CheckBytesInAsciiRange(Vector`1<sbyte> check);
    private static bool CheckBytesInAsciiRange(long check);
    private static bool CheckBytesInAsciiRange(int check);
    private static bool CheckBytesInAsciiRange(short check);
    private static bool CheckBytesInAsciiRange(sbyte check);
    private static bool CheckBytesNotNull(Vector`1<byte> check);
    private static bool CheckBytesNotNull(long check);
    private static bool CheckBytesNotNull(int check);
    private static bool CheckBytesNotNull(short check);
    private static bool CheckBytesNotNull(sbyte check);
}
