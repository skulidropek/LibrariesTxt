internal class Microsoft.AspNetCore.Certificates.Generation.CertificateManager : object {
    public static string AspNetHttpsOid;
    public static string AspNetHttpsOidFriendlyName;
    private static string ServerAuthenticationEnhancedKeyUsageOid;
    private static string ServerAuthenticationEnhancedKeyUsageOidFriendlyName;
    private static string LocalhostHttpsDnsName;
    private static string LocalhostHttpsDistinguishedName;
    public static int RSAMinimumKeySizeInBits;
    private static TimeSpan MaxRegexTimeout;
    private static string CertificateSubjectRegex;
    private static string MacOSSystemKeyChain;
    private static string MacOSUserKeyChain;
    private static string MacOSFindCertificateCommandLine;
    private static string MacOSFindCertificateCommandLineArgumentsFormat;
    private static string MacOSFindCertificateOutputRegex;
    private static string MacOSRemoveCertificateTrustCommandLine;
    private static string MacOSRemoveCertificateTrustCommandLineArgumentsFormat;
    private static string MacOSDeleteCertificateCommandLine;
    private static string MacOSDeleteCertificateCommandLineArgumentsFormat;
    private static string MacOSTrustCertificateCommandLine;
    private static string MacOSTrustCertificateCommandLineArguments;
    private static int UserCancelledErrorCode;
    private static string MacOSSetPartitionKeyPermissionsCommandLine;
    private static string MacOSSetPartitionKeyPermissionsCommandLineArguments;
    [CompilerGeneratedAttribute]
private static int <AspNetHttpsCertificateVersion>k__BackingField;
    public static int AspNetHttpsCertificateVersion { get; public set; }
    private static CertificateManager();
    [CompilerGeneratedAttribute]
public static int get_AspNetHttpsCertificateVersion();
    [CompilerGeneratedAttribute]
public static void set_AspNetHttpsCertificateVersion(int value);
    public static bool IsHttpsDevelopmentCertificate(X509Certificate2 certificate);
    public static IList`1<X509Certificate2> ListCertificates(CertificatePurpose purpose, StoreName storeName, StoreLocation location, bool isValid, bool requireExportable, DiagnosticInformation diagnostics);
    private static void DisposeCertificates(IEnumerable`1<X509Certificate2> disposables);
    internal bool HasValidCertificateWithInnaccessibleKeyAcrossPartitions();
    public IList`1<X509Certificate2> GetHttpsCertificates();
    public X509Certificate2 CreateAspNetCoreHttpsDevelopmentCertificate(DateTimeOffset notBefore, DateTimeOffset notAfter, string subjectOverride, DiagnosticInformation diagnostics);
    internal static bool CheckDeveloperCertificateKey(X509Certificate2 candidate);
    public X509Certificate2 CreateSelfSignedCertificate(X500DistinguishedName subject, IEnumerable`1<X509Extension> extensions, DateTimeOffset notBefore, DateTimeOffset notAfter);
    public X509Certificate2 SaveCertificateInStore(X509Certificate2 certificate, StoreName name, StoreLocation location, DiagnosticInformation diagnostics);
    public void ExportCertificate(X509Certificate2 certificate, string path, bool includePrivateKey, string password, DiagnosticInformation diagnostics);
    public void TrustCertificate(X509Certificate2 certificate, DiagnosticInformation diagnostics);
    private void TrustCertificateOnMac(X509Certificate2 publicCertificate, DiagnosticInformation diagnostics);
    private static void TrustCertificateOnWindows(X509Certificate2 certificate, X509Certificate2 publicCertificate, DiagnosticInformation diagnostics);
    public bool IsTrusted(X509Certificate2 certificate);
    public void CleanupHttpsCertificates(string subject);
    public void CleanupCertificates(CertificatePurpose purpose, string subject);
    public DiagnosticInformation CleanupHttpsCertificates2(string subject);
    public DiagnosticInformation CleanupCertificates2(CertificatePurpose purpose, string subject);
    public void RemoveAllCertificates(CertificatePurpose purpose, StoreName storeName, StoreLocation storeLocation, string subject);
    private void RemoveCertificate(X509Certificate2 certificate, RemoveLocations locations, DiagnosticInformation diagnostics);
    private static void RemoveCertificateFromUserStore(X509Certificate2 certificate, DiagnosticInformation diagnostics);
    private void RemoveCertificateFromTrustedRoots(X509Certificate2 certificate, DiagnosticInformation diagnostics);
    private static void RemoveCertificateTrustRule(X509Certificate2 certificate);
    private static void RemoveCertificateFromKeyChain(string keyChain, X509Certificate2 certificate);
    public DetailedEnsureCertificateResult EnsureAspNetCoreHttpsDevelopmentCertificate(DateTimeOffset notBefore, DateTimeOffset notAfter, string path, bool trust, bool includePrivateKey, string password, string subject, bool isInteractive);
    public DetailedEnsureCertificateResult EnsureValidCertificateExists(DateTimeOffset notBefore, DateTimeOffset notAfter, CertificatePurpose purpose, string path, bool trust, bool includePrivateKey, string password, string subjectOverride, bool isInteractive);
    private void MakeCertificateKeyAccessibleAcrossPartitions(X509Certificate2 certificate);
    private static string GetCertificateSentinelPath(X509Certificate2 certificate);
    private bool OtherNonAspNetCoreHttpsCertificatesPresent();
    private bool CanAccessCertificateKeyAcrossPartitions(X509Certificate2 certificate);
    [CompilerGeneratedAttribute]
internal static bool <ListCertificates>g__HasOid|28_0(X509Certificate2 certificate, string oid);
    [CompilerGeneratedAttribute]
internal static bool <ListCertificates>g__MatchesVersion|28_1(X509Certificate2 c);
    [CompilerGeneratedAttribute]
internal static bool <ListCertificates>g__IsExportable|28_2(X509Certificate2 c);
    [CompilerGeneratedAttribute]
internal static RSA <CreateSelfSignedCertificate>g__CreateKeyMaterial|34_0(int minimumKeySize);
    [CompilerGeneratedAttribute]
internal static bool <OtherNonAspNetCoreHttpsCertificatesPresent>g__HasOid|55_0(X509Certificate2 certificate, string oid);
}
internal enum Microsoft.AspNetCore.Certificates.Generation.CertificatePurpose : Enum {
    public int value__;
    public static CertificatePurpose All;
    public static CertificatePurpose HTTPS;
}
internal enum Microsoft.AspNetCore.Certificates.Generation.EnsureCertificateResult : Enum {
    public int value__;
    public static EnsureCertificateResult Succeeded;
    public static EnsureCertificateResult ValidCertificatePresent;
    public static EnsureCertificateResult ErrorCreatingTheCertificate;
    public static EnsureCertificateResult ErrorSavingTheCertificateIntoTheCurrentUserPersonalStore;
    public static EnsureCertificateResult ErrorExportingTheCertificate;
    public static EnsureCertificateResult FailedToTrustTheCertificate;
    public static EnsureCertificateResult UserCancelledTrustStep;
    public static EnsureCertificateResult FailedToMakeKeyAccessible;
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Hosting.KestrelServerOptionsSystemdExtensions : object {
    private static ulong SdListenFdsStart;
    private static string ListenPidEnvVar;
    [ExtensionAttribute]
public static KestrelServerOptions UseSystemd(KestrelServerOptions options);
    [ExtensionAttribute]
public static KestrelServerOptions UseSystemd(KestrelServerOptions options, Action`1<ListenOptions> configure);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Hosting.ListenOptionsConnectionLoggingExtensions : object {
    [ExtensionAttribute]
public static ListenOptions UseConnectionLogging(ListenOptions listenOptions);
    [ExtensionAttribute]
public static ListenOptions UseConnectionLogging(ListenOptions listenOptions, string loggerName);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions : object {
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, string fileName);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, string fileName, string password);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, string fileName, string password, Action`1<HttpsConnectionAdapterOptions> configureOptions);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, StoreName storeName, string subject);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, StoreName storeName, string subject, bool allowInvalid);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, StoreName storeName, string subject, bool allowInvalid, StoreLocation location);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, StoreName storeName, string subject, bool allowInvalid, StoreLocation location, Action`1<HttpsConnectionAdapterOptions> configureOptions);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, X509Certificate2 serverCertificate);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, X509Certificate2 serverCertificate, Action`1<HttpsConnectionAdapterOptions> configureOptions);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, Action`1<HttpsConnectionAdapterOptions> configureOptions);
    [ExtensionAttribute]
internal static bool TryUseHttps(ListenOptions listenOptions);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, HttpsConnectionAdapterOptions httpsOptions);
}
internal class Microsoft.AspNetCore.Internal.UrlDecoder : object {
    public static int DecodeRequestLine(ReadOnlySpan`1<byte> source, Span`1<byte> destination, bool isFormEncoding);
    public static int DecodeInPlace(Span`1<byte> buffer, bool isFormEncoding);
    private static bool DecodeCore(Int32& sourceIndex, Int32& destinationIndex, Span`1<byte> buffer, bool isFormEncoding);
    private static void Copy(int begin, int end, Int32& writer, Span`1<byte> buffer);
    private static int UnescapePercentEncoding(Int32& scan, Span`1<byte> buffer, bool isFormEncoding);
    private static int ReadHex(Int32& scan, Span`1<byte> buffer);
    private static bool SkipUnescape(int value1, int value2, bool isFormEncoding);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Internal.ValueTaskExtensions : object {
    [ExtensionAttribute]
public static Task GetAsTask(ValueTask`1& valueTask);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.AnyIPListenOptions : ListenOptions {
    internal AnyIPListenOptions(int port);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.AnyIPListenOptions/<BindAsync>d__1")]
internal virtual Task BindAsync(AddressBindContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(AddressBindContext context);
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.BadHttpRequestException : IOException {
    [CompilerGeneratedAttribute]
private int <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private StringValues <AllowedHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestRejectionReason <Reason>k__BackingField;
    public int StatusCode { get; }
    internal StringValues AllowedHeader { get; }
    internal RequestRejectionReason Reason { get; }
    private BadHttpRequestException(string message, int statusCode, RequestRejectionReason reason);
    private BadHttpRequestException(string message, int statusCode, RequestRejectionReason reason, Nullable`1<HttpMethod> requiredMethod);
    [CompilerGeneratedAttribute]
public int get_StatusCode();
    [CompilerGeneratedAttribute]
internal StringValues get_AllowedHeader();
    [CompilerGeneratedAttribute]
internal RequestRejectionReason get_Reason();
    [StackTraceHiddenAttribute]
internal static void Throw(RequestRejectionReason reason);
    [StackTraceHiddenAttribute]
internal static void Throw(RequestRejectionReason reason, HttpMethod method);
    internal static BadHttpRequestException GetException(RequestRejectionReason reason);
    [StackTraceHiddenAttribute]
internal static void Throw(RequestRejectionReason reason, string detail);
    [StackTraceHiddenAttribute]
internal static void Throw(RequestRejectionReason reason, StringValues detail);
    internal static BadHttpRequestException GetException(RequestRejectionReason reason, string detail);
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.CoreStrings : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string BadRequest { get; }
    internal static string BadRequest_BadChunkSizeData { get; }
    internal static string BadRequest_BadChunkSuffix { get; }
    internal static string BadRequest_ChunkedRequestIncomplete { get; }
    internal static string BadRequest_FinalTransferCodingNotChunked { get; }
    internal static string BadRequest_HeadersExceedMaxTotalSize { get; }
    internal static string BadRequest_InvalidCharactersInHeaderName { get; }
    internal static string BadRequest_InvalidContentLength_Detail { get; }
    internal static string BadRequest_InvalidHostHeader { get; }
    internal static string BadRequest_InvalidHostHeader_Detail { get; }
    internal static string BadRequest_InvalidRequestHeadersNoCRLF { get; }
    internal static string BadRequest_InvalidRequestHeader_Detail { get; }
    internal static string BadRequest_InvalidRequestLine { get; }
    internal static string BadRequest_InvalidRequestLine_Detail { get; }
    internal static string BadRequest_InvalidRequestTarget_Detail { get; }
    internal static string BadRequest_LengthRequired { get; }
    internal static string BadRequest_LengthRequiredHttp10 { get; }
    internal static string BadRequest_MalformedRequestInvalidHeaders { get; }
    internal static string BadRequest_MethodNotAllowed { get; }
    internal static string BadRequest_MissingHostHeader { get; }
    internal static string BadRequest_MultipleContentLengths { get; }
    internal static string BadRequest_MultipleHostHeaders { get; }
    internal static string BadRequest_RequestLineTooLong { get; }
    internal static string BadRequest_RequestHeadersTimeout { get; }
    internal static string BadRequest_TooManyHeaders { get; }
    internal static string BadRequest_UnexpectedEndOfRequestContent { get; }
    internal static string BadRequest_UnrecognizedHTTPVersion { get; }
    internal static string FallbackToIPv4Any { get; }
    internal static string ResponseStreamWasUpgraded { get; }
    internal static string BigEndianNotSupported { get; }
    internal static string MaxRequestBufferSmallerThanRequestHeaderBuffer { get; }
    internal static string MaxRequestBufferSmallerThanRequestLineBuffer { get; }
    internal static string ServerAlreadyStarted { get; }
    internal static string UnknownTransportMode { get; }
    internal static string InvalidAsciiOrControlChar { get; }
    internal static string InvalidContentLength_InvalidNumber { get; }
    internal static string NonNegativeNumberOrNullRequired { get; }
    internal static string NonNegativeNumberRequired { get; }
    internal static string PositiveNumberRequired { get; }
    internal static string PositiveNumberOrNullRequired { get; }
    internal static string UnixSocketPathMustBeAbsolute { get; }
    internal static string AddressBindingFailed { get; }
    internal static string BindingToDefaultAddress { get; }
    internal static string ConfigureHttpsFromMethodCall { get; }
    internal static string ConfigurePathBaseFromMethodCall { get; }
    internal static string DynamicPortOnLocalhostNotSupported { get; }
    internal static string EndpointAlreadyInUse { get; }
    internal static string InvalidUrl { get; }
    internal static string NetworkInterfaceBindingFailed { get; }
    internal static string OverridingWithKestrelOptions { get; }
    internal static string OverridingWithPreferHostingUrls { get; }
    internal static string UnsupportedAddressScheme { get; }
    internal static string HeadersAreReadOnly { get; }
    internal static string KeyAlreadyExists { get; }
    internal static string HeaderNotAllowedOnResponse { get; }
    internal static string ParameterReadOnlyAfterResponseStarted { get; }
    internal static string RequestProcessingAborted { get; }
    internal static string TooFewBytesWritten { get; }
    internal static string TooManyBytesWritten { get; }
    internal static string UnhandledApplicationException { get; }
    internal static string WritingToResponseBodyNotSupported { get; }
    internal static string ConnectionShutdownError { get; }
    internal static string RequestProcessingEndError { get; }
    internal static string CannotUpgradeNonUpgradableRequest { get; }
    internal static string UpgradedConnectionLimitReached { get; }
    internal static string UpgradeCannotBeCalledMultipleTimes { get; }
    internal static string BadRequest_RequestBodyTooLarge { get; }
    internal static string MaxRequestBodySizeCannotBeModifiedAfterRead { get; }
    internal static string MaxRequestBodySizeCannotBeModifiedForUpgradedRequests { get; }
    internal static string PositiveTimeSpanRequired { get; }
    internal static string NonNegativeTimeSpanRequired { get; }
    internal static string MinimumGracePeriodRequired { get; }
    internal static string SynchronousReadsDisallowed { get; }
    internal static string SynchronousWritesDisallowed { get; }
    internal static string PositiveNumberOrNullMinDataRateRequired { get; }
    internal static string ConcurrentTimeoutsNotSupported { get; }
    internal static string PositiveFiniteTimeSpanRequired { get; }
    internal static string EndPointRequiresAtLeastOneProtocol { get; }
    internal static string EndPointHttp2NotNegotiated { get; }
    internal static string HPackErrorDynamicTableSizeUpdateTooLarge { get; }
    internal static string HPackErrorIndexOutOfRange { get; }
    internal static string HPackHuffmanErrorIncomplete { get; }
    internal static string HPackHuffmanErrorEOS { get; }
    internal static string HPackHuffmanErrorDestinationTooSmall { get; }
    internal static string HPackHuffmanError { get; }
    internal static string HPackStringLengthTooLarge { get; }
    internal static string HPackErrorIncompleteHeaderBlock { get; }
    internal static string Http2ErrorStreamIdEven { get; }
    internal static string Http2ErrorPushPromiseReceived { get; }
    internal static string Http2ErrorHeadersInterleaved { get; }
    internal static string Http2ErrorStreamIdZero { get; }
    internal static string Http2ErrorStreamIdNotZero { get; }
    internal static string Http2ErrorPaddingTooLong { get; }
    internal static string Http2ErrorStreamClosed { get; }
    internal static string Http2ErrorStreamHalfClosedRemote { get; }
    internal static string Http2ErrorStreamSelfDependency { get; }
    internal static string Http2ErrorUnexpectedFrameLength { get; }
    internal static string Http2ErrorSettingsLengthNotMultipleOfSix { get; }
    internal static string Http2ErrorSettingsAckLengthNotZero { get; }
    internal static string Http2ErrorSettingsParameterOutOfRange { get; }
    internal static string Http2ErrorWindowUpdateIncrementZero { get; }
    internal static string Http2ErrorContinuationWithNoHeaders { get; }
    internal static string Http2ErrorStreamIdle { get; }
    internal static string Http2ErrorTrailersContainPseudoHeaderField { get; }
    internal static string Http2ErrorHeaderNameUppercase { get; }
    internal static string Http2ErrorTrailerNameUppercase { get; }
    internal static string Http2ErrorHeadersWithTrailersNoEndStream { get; }
    internal static string Http2ErrorMissingMandatoryPseudoHeaderFields { get; }
    internal static string Http2ErrorPseudoHeaderFieldAfterRegularHeaders { get; }
    internal static string Http2ErrorUnknownPseudoHeaderField { get; }
    internal static string Http2ErrorResponsePseudoHeaderField { get; }
    internal static string Http2ErrorDuplicatePseudoHeaderField { get; }
    internal static string Http2ErrorConnectionSpecificHeaderField { get; }
    internal static string UnableToConfigureHttpsBindings { get; }
    internal static string AuthenticationFailed { get; }
    internal static string AuthenticationTimedOut { get; }
    internal static string InvalidServerCertificateEku { get; }
    internal static string PositiveTimeSpanRequired1 { get; }
    internal static string ServerCertificateRequired { get; }
    internal static string BindingToDefaultAddresses { get; }
    internal static string CertNotFoundInStore { get; }
    internal static string EndpointMissingUrl { get; }
    internal static string NoCertSpecifiedNoDevelopmentCertificateFound { get; }
    internal static string MultipleCertificateSources { get; }
    internal static string WritingToResponseBodyAfterResponseCompleted { get; }
    internal static string BadRequest_RequestBodyTimeout { get; }
    internal static string ConnectionAbortedByApplication { get; }
    internal static string ConnectionAbortedDuringServerShutdown { get; }
    internal static string ConnectionTimedBecauseResponseMininumDataRateNotSatisfied { get; }
    internal static string ConnectionTimedOutByServer { get; }
    internal static string Http2ErrorFrameOverLimit { get; }
    internal static string Http2ErrorMinTlsVersion { get; }
    internal static string Http2ErrorInvalidPreface { get; }
    internal static string InvalidEmptyHeaderName { get; }
    internal static string ConnectionOrStreamAbortedByCancellationToken { get; }
    internal static string Http2ErrorInitialWindowSizeInvalid { get; }
    internal static string Http2ErrorWindowUpdateSizeInvalid { get; }
    internal static string Http2ConnectionFaulted { get; }
    internal static string Http2StreamResetByClient { get; }
    internal static string Http2StreamAborted { get; }
    internal static string Http2ErrorFlowControlWindowExceeded { get; }
    internal static string Http2ErrorConnectMustNotSendSchemeOrPath { get; }
    internal static string Http2ErrorMethodInvalid { get; }
    internal static string Http2StreamErrorPathInvalid { get; }
    internal static string Http2StreamErrorSchemeMismatch { get; }
    internal static string Http2StreamErrorLessDataThanLength { get; }
    internal static string Http2StreamErrorMoreDataThanLength { get; }
    internal static string Http2StreamErrorAfterHeaders { get; }
    internal static string Http2ErrorMaxStreams { get; }
    internal static string GreaterThanZeroRequired { get; }
    internal static string ArgumentOutOfRange { get; }
    internal static string HPackErrorDynamicTableSizeUpdateNotAtBeginningOfHeaderBlock { get; }
    internal static string HPackErrorNotEnoughBuffer { get; }
    internal static string HPackErrorIntegerTooBig { get; }
    internal static string ConnectionAbortedByClient { get; }
    internal static string Http2ErrorStreamAborted { get; }
    internal static string ProtocolSelectionFailed { get; }
    internal static string ServerShutdownDuringConnectionInitialization { get; }
    internal static string StartAsyncBeforeGetMemory { get; }
    internal static string Http2MinDataRateNotSupported { get; }
    internal static string RequestTrailersNotAvailable { get; }
    internal static string HTTP2NoTlsOsx { get; }
    internal static string HTTP2NoTlsWin7 { get; }
    internal static string Http2StreamResetByApplication { get; }
    internal static string Http2TellClientToCalmDown { get; }
    internal static string BadDeveloperCertificateState { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_BadRequest();
    internal static string get_BadRequest_BadChunkSizeData();
    internal static string get_BadRequest_BadChunkSuffix();
    internal static string get_BadRequest_ChunkedRequestIncomplete();
    internal static string get_BadRequest_FinalTransferCodingNotChunked();
    internal static string FormatBadRequest_FinalTransferCodingNotChunked(object detail);
    internal static string get_BadRequest_HeadersExceedMaxTotalSize();
    internal static string get_BadRequest_InvalidCharactersInHeaderName();
    internal static string get_BadRequest_InvalidContentLength_Detail();
    internal static string FormatBadRequest_InvalidContentLength_Detail(object detail);
    internal static string get_BadRequest_InvalidHostHeader();
    internal static string get_BadRequest_InvalidHostHeader_Detail();
    internal static string FormatBadRequest_InvalidHostHeader_Detail(object detail);
    internal static string get_BadRequest_InvalidRequestHeadersNoCRLF();
    internal static string get_BadRequest_InvalidRequestHeader_Detail();
    internal static string FormatBadRequest_InvalidRequestHeader_Detail(object detail);
    internal static string get_BadRequest_InvalidRequestLine();
    internal static string get_BadRequest_InvalidRequestLine_Detail();
    internal static string FormatBadRequest_InvalidRequestLine_Detail(object detail);
    internal static string get_BadRequest_InvalidRequestTarget_Detail();
    internal static string FormatBadRequest_InvalidRequestTarget_Detail(object detail);
    internal static string get_BadRequest_LengthRequired();
    internal static string FormatBadRequest_LengthRequired(object detail);
    internal static string get_BadRequest_LengthRequiredHttp10();
    internal static string FormatBadRequest_LengthRequiredHttp10(object detail);
    internal static string get_BadRequest_MalformedRequestInvalidHeaders();
    internal static string get_BadRequest_MethodNotAllowed();
    internal static string get_BadRequest_MissingHostHeader();
    internal static string get_BadRequest_MultipleContentLengths();
    internal static string get_BadRequest_MultipleHostHeaders();
    internal static string get_BadRequest_RequestLineTooLong();
    internal static string get_BadRequest_RequestHeadersTimeout();
    internal static string get_BadRequest_TooManyHeaders();
    internal static string get_BadRequest_UnexpectedEndOfRequestContent();
    internal static string get_BadRequest_UnrecognizedHTTPVersion();
    internal static string FormatBadRequest_UnrecognizedHTTPVersion(object detail);
    internal static string get_FallbackToIPv4Any();
    internal static string FormatFallbackToIPv4Any(object port);
    internal static string get_ResponseStreamWasUpgraded();
    internal static string get_BigEndianNotSupported();
    internal static string get_MaxRequestBufferSmallerThanRequestHeaderBuffer();
    internal static string FormatMaxRequestBufferSmallerThanRequestHeaderBuffer(object requestBufferSize, object requestHeaderSize);
    internal static string get_MaxRequestBufferSmallerThanRequestLineBuffer();
    internal static string FormatMaxRequestBufferSmallerThanRequestLineBuffer(object requestBufferSize, object requestLineSize);
    internal static string get_ServerAlreadyStarted();
    internal static string get_UnknownTransportMode();
    internal static string FormatUnknownTransportMode(object mode);
    internal static string get_InvalidAsciiOrControlChar();
    internal static string FormatInvalidAsciiOrControlChar(object character);
    internal static string get_InvalidContentLength_InvalidNumber();
    internal static string FormatInvalidContentLength_InvalidNumber(object value);
    internal static string get_NonNegativeNumberOrNullRequired();
    internal static string get_NonNegativeNumberRequired();
    internal static string get_PositiveNumberRequired();
    internal static string get_PositiveNumberOrNullRequired();
    internal static string get_UnixSocketPathMustBeAbsolute();
    internal static string get_AddressBindingFailed();
    internal static string FormatAddressBindingFailed(object address);
    internal static string get_BindingToDefaultAddress();
    internal static string FormatBindingToDefaultAddress(object address);
    internal static string get_ConfigureHttpsFromMethodCall();
    internal static string FormatConfigureHttpsFromMethodCall(object methodName);
    internal static string get_ConfigurePathBaseFromMethodCall();
    internal static string FormatConfigurePathBaseFromMethodCall(object methodName);
    internal static string get_DynamicPortOnLocalhostNotSupported();
    internal static string get_EndpointAlreadyInUse();
    internal static string FormatEndpointAlreadyInUse(object endpoint);
    internal static string get_InvalidUrl();
    internal static string FormatInvalidUrl(object url);
    internal static string get_NetworkInterfaceBindingFailed();
    internal static string FormatNetworkInterfaceBindingFailed(object address, object interfaceName, object error);
    internal static string get_OverridingWithKestrelOptions();
    internal static string FormatOverridingWithKestrelOptions(object addresses, object methodName);
    internal static string get_OverridingWithPreferHostingUrls();
    internal static string FormatOverridingWithPreferHostingUrls(object settingName, object addresses);
    internal static string get_UnsupportedAddressScheme();
    internal static string FormatUnsupportedAddressScheme(object address);
    internal static string get_HeadersAreReadOnly();
    internal static string get_KeyAlreadyExists();
    internal static string get_HeaderNotAllowedOnResponse();
    internal static string FormatHeaderNotAllowedOnResponse(object name, object statusCode);
    internal static string get_ParameterReadOnlyAfterResponseStarted();
    internal static string FormatParameterReadOnlyAfterResponseStarted(object name);
    internal static string get_RequestProcessingAborted();
    internal static string get_TooFewBytesWritten();
    internal static string FormatTooFewBytesWritten(object written, object expected);
    internal static string get_TooManyBytesWritten();
    internal static string FormatTooManyBytesWritten(object written, object expected);
    internal static string get_UnhandledApplicationException();
    internal static string get_WritingToResponseBodyNotSupported();
    internal static string FormatWritingToResponseBodyNotSupported(object statusCode);
    internal static string get_ConnectionShutdownError();
    internal static string get_RequestProcessingEndError();
    internal static string get_CannotUpgradeNonUpgradableRequest();
    internal static string get_UpgradedConnectionLimitReached();
    internal static string get_UpgradeCannotBeCalledMultipleTimes();
    internal static string get_BadRequest_RequestBodyTooLarge();
    internal static string get_MaxRequestBodySizeCannotBeModifiedAfterRead();
    internal static string get_MaxRequestBodySizeCannotBeModifiedForUpgradedRequests();
    internal static string get_PositiveTimeSpanRequired();
    internal static string get_NonNegativeTimeSpanRequired();
    internal static string get_MinimumGracePeriodRequired();
    internal static string FormatMinimumGracePeriodRequired(object heartbeatInterval);
    internal static string get_SynchronousReadsDisallowed();
    internal static string get_SynchronousWritesDisallowed();
    internal static string get_PositiveNumberOrNullMinDataRateRequired();
    internal static string get_ConcurrentTimeoutsNotSupported();
    internal static string get_PositiveFiniteTimeSpanRequired();
    internal static string get_EndPointRequiresAtLeastOneProtocol();
    internal static string get_EndPointHttp2NotNegotiated();
    internal static string get_HPackErrorDynamicTableSizeUpdateTooLarge();
    internal static string FormatHPackErrorDynamicTableSizeUpdateTooLarge(object size, object maxSize);
    internal static string get_HPackErrorIndexOutOfRange();
    internal static string FormatHPackErrorIndexOutOfRange(object index);
    internal static string get_HPackHuffmanErrorIncomplete();
    internal static string get_HPackHuffmanErrorEOS();
    internal static string get_HPackHuffmanErrorDestinationTooSmall();
    internal static string get_HPackHuffmanError();
    internal static string get_HPackStringLengthTooLarge();
    internal static string FormatHPackStringLengthTooLarge(object length, object maxStringLength);
    internal static string get_HPackErrorIncompleteHeaderBlock();
    internal static string get_Http2ErrorStreamIdEven();
    internal static string FormatHttp2ErrorStreamIdEven(object frameType, object streamId);
    internal static string get_Http2ErrorPushPromiseReceived();
    internal static string get_Http2ErrorHeadersInterleaved();
    internal static string FormatHttp2ErrorHeadersInterleaved(object frameType, object streamId, object headersStreamId);
    internal static string get_Http2ErrorStreamIdZero();
    internal static string FormatHttp2ErrorStreamIdZero(object frameType);
    internal static string get_Http2ErrorStreamIdNotZero();
    internal static string FormatHttp2ErrorStreamIdNotZero(object frameType);
    internal static string get_Http2ErrorPaddingTooLong();
    internal static string FormatHttp2ErrorPaddingTooLong(object frameType);
    internal static string get_Http2ErrorStreamClosed();
    internal static string FormatHttp2ErrorStreamClosed(object frameType, object streamId);
    internal static string get_Http2ErrorStreamHalfClosedRemote();
    internal static string FormatHttp2ErrorStreamHalfClosedRemote(object frameType, object streamId);
    internal static string get_Http2ErrorStreamSelfDependency();
    internal static string FormatHttp2ErrorStreamSelfDependency(object frameType, object streamId);
    internal static string get_Http2ErrorUnexpectedFrameLength();
    internal static string FormatHttp2ErrorUnexpectedFrameLength(object frameType, object expectedLength);
    internal static string get_Http2ErrorSettingsLengthNotMultipleOfSix();
    internal static string get_Http2ErrorSettingsAckLengthNotZero();
    internal static string get_Http2ErrorSettingsParameterOutOfRange();
    internal static string FormatHttp2ErrorSettingsParameterOutOfRange(object parameter);
    internal static string get_Http2ErrorWindowUpdateIncrementZero();
    internal static string get_Http2ErrorContinuationWithNoHeaders();
    internal static string get_Http2ErrorStreamIdle();
    internal static string FormatHttp2ErrorStreamIdle(object frameType, object streamId);
    internal static string get_Http2ErrorTrailersContainPseudoHeaderField();
    internal static string get_Http2ErrorHeaderNameUppercase();
    internal static string get_Http2ErrorTrailerNameUppercase();
    internal static string get_Http2ErrorHeadersWithTrailersNoEndStream();
    internal static string get_Http2ErrorMissingMandatoryPseudoHeaderFields();
    internal static string get_Http2ErrorPseudoHeaderFieldAfterRegularHeaders();
    internal static string get_Http2ErrorUnknownPseudoHeaderField();
    internal static string get_Http2ErrorResponsePseudoHeaderField();
    internal static string get_Http2ErrorDuplicatePseudoHeaderField();
    internal static string get_Http2ErrorConnectionSpecificHeaderField();
    internal static string get_UnableToConfigureHttpsBindings();
    internal static string get_AuthenticationFailed();
    internal static string get_AuthenticationTimedOut();
    internal static string get_InvalidServerCertificateEku();
    internal static string FormatInvalidServerCertificateEku(object thumbprint);
    internal static string get_PositiveTimeSpanRequired1();
    internal static string get_ServerCertificateRequired();
    internal static string get_BindingToDefaultAddresses();
    internal static string FormatBindingToDefaultAddresses(object address0, object address1);
    internal static string get_CertNotFoundInStore();
    internal static string FormatCertNotFoundInStore(object subject, object storeLocation, object storeName, object allowInvalid);
    internal static string get_EndpointMissingUrl();
    internal static string FormatEndpointMissingUrl(object endpointName);
    internal static string get_NoCertSpecifiedNoDevelopmentCertificateFound();
    internal static string get_MultipleCertificateSources();
    internal static string FormatMultipleCertificateSources(object endpointName);
    internal static string get_WritingToResponseBodyAfterResponseCompleted();
    internal static string get_BadRequest_RequestBodyTimeout();
    internal static string get_ConnectionAbortedByApplication();
    internal static string get_ConnectionAbortedDuringServerShutdown();
    internal static string get_ConnectionTimedBecauseResponseMininumDataRateNotSatisfied();
    internal static string get_ConnectionTimedOutByServer();
    internal static string get_Http2ErrorFrameOverLimit();
    internal static string FormatHttp2ErrorFrameOverLimit(object size, object limit);
    internal static string get_Http2ErrorMinTlsVersion();
    internal static string FormatHttp2ErrorMinTlsVersion(object protocol);
    internal static string get_Http2ErrorInvalidPreface();
    internal static string get_InvalidEmptyHeaderName();
    internal static string get_ConnectionOrStreamAbortedByCancellationToken();
    internal static string get_Http2ErrorInitialWindowSizeInvalid();
    internal static string get_Http2ErrorWindowUpdateSizeInvalid();
    internal static string get_Http2ConnectionFaulted();
    internal static string get_Http2StreamResetByClient();
    internal static string get_Http2StreamAborted();
    internal static string get_Http2ErrorFlowControlWindowExceeded();
    internal static string get_Http2ErrorConnectMustNotSendSchemeOrPath();
    internal static string get_Http2ErrorMethodInvalid();
    internal static string FormatHttp2ErrorMethodInvalid(object method);
    internal static string get_Http2StreamErrorPathInvalid();
    internal static string FormatHttp2StreamErrorPathInvalid(object path);
    internal static string get_Http2StreamErrorSchemeMismatch();
    internal static string FormatHttp2StreamErrorSchemeMismatch(object requestScheme, object transportScheme);
    internal static string get_Http2StreamErrorLessDataThanLength();
    internal static string get_Http2StreamErrorMoreDataThanLength();
    internal static string get_Http2StreamErrorAfterHeaders();
    internal static string get_Http2ErrorMaxStreams();
    internal static string get_GreaterThanZeroRequired();
    internal static string get_ArgumentOutOfRange();
    internal static string FormatArgumentOutOfRange(object min, object max);
    internal static string get_HPackErrorDynamicTableSizeUpdateNotAtBeginningOfHeaderBlock();
    internal static string get_HPackErrorNotEnoughBuffer();
    internal static string get_HPackErrorIntegerTooBig();
    internal static string get_ConnectionAbortedByClient();
    internal static string get_Http2ErrorStreamAborted();
    internal static string FormatHttp2ErrorStreamAborted(object frameType, object streamId);
    internal static string get_ProtocolSelectionFailed();
    internal static string get_ServerShutdownDuringConnectionInitialization();
    internal static string get_StartAsyncBeforeGetMemory();
    internal static string get_Http2MinDataRateNotSupported();
    internal static string get_RequestTrailersNotAvailable();
    internal static string get_HTTP2NoTlsOsx();
    internal static string get_HTTP2NoTlsWin7();
    internal static string get_Http2StreamResetByApplication();
    internal static string FormatHttp2StreamResetByApplication(object errorCode);
    internal static string get_Http2TellClientToCalmDown();
    internal static string get_BadDeveloperCertificateState();
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.IConnectionTimeoutFeature {
    public abstract virtual void SetTimeout(TimeSpan timeSpan);
    public abstract virtual void ResetTimeout(TimeSpan timeSpan);
    public abstract virtual void CancelTimeout();
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.IDecrementConcurrentConnectionCountFeature {
    public abstract virtual void ReleaseConnection();
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttp2StreamIdFeature {
    public int StreamId { get; }
    public abstract virtual int get_StreamId();
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature {
    public MinDataRate MinDataRate { get; public set; }
    public abstract virtual MinDataRate get_MinDataRate();
    public abstract virtual void set_MinDataRate(MinDataRate value);
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinResponseDataRateFeature {
    public MinDataRate MinDataRate { get; public set; }
    public abstract virtual MinDataRate get_MinDataRate();
    public abstract virtual void set_MinDataRate(MinDataRate value);
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.ITlsApplicationProtocolFeature {
    public ReadOnlyMemory`1<byte> ApplicationProtocol { get; }
    public abstract virtual ReadOnlyMemory`1<byte> get_ApplicationProtocol();
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits : object {
    private int _maxStreamsPerConnection;
    private int _headerTableSize;
    private int _maxFrameSize;
    private int _maxRequestHeaderFieldSize;
    private int _initialConnectionWindowSize;
    private int _initialStreamWindowSize;
    public int MaxStreamsPerConnection { get; public set; }
    public int HeaderTableSize { get; public set; }
    public int MaxFrameSize { get; public set; }
    public int MaxRequestHeaderFieldSize { get; public set; }
    public int InitialConnectionWindowSize { get; public set; }
    public int InitialStreamWindowSize { get; public set; }
    public int get_MaxStreamsPerConnection();
    public void set_MaxStreamsPerConnection(int value);
    public int get_HeaderTableSize();
    public void set_HeaderTableSize(int value);
    public int get_MaxFrameSize();
    public void set_MaxFrameSize(int value);
    public int get_MaxRequestHeaderFieldSize();
    public void set_MaxRequestHeaderFieldSize(int value);
    public int get_InitialConnectionWindowSize();
    public void set_InitialConnectionWindowSize(int value);
    public int get_InitialStreamWindowSize();
    public void set_InitialStreamWindowSize(int value);
}
[FlagsAttribute]
public enum Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols : Enum {
    public int value__;
    public static HttpProtocols None;
    public static HttpProtocols Http1;
    public static HttpProtocols Http2;
    public static HttpProtocols Http1AndHttp2;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.AddressBindContext : object {
    [CompilerGeneratedAttribute]
private ICollection`1<string> <Addresses>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ListenOptions> <ListenOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelServerOptions <ServerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ListenOptions, Task> <CreateBinding>k__BackingField;
    public ICollection`1<string> Addresses { get; public set; }
    public List`1<ListenOptions> ListenOptions { get; public set; }
    public KestrelServerOptions ServerOptions { get; public set; }
    public ILogger Logger { get; public set; }
    public Func`2<ListenOptions, Task> CreateBinding { get; public set; }
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_Addresses();
    [CompilerGeneratedAttribute]
public void set_Addresses(ICollection`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<ListenOptions> get_ListenOptions();
    [CompilerGeneratedAttribute]
public void set_ListenOptions(List`1<ListenOptions> value);
    [CompilerGeneratedAttribute]
public KestrelServerOptions get_ServerOptions();
    [CompilerGeneratedAttribute]
public void set_ServerOptions(KestrelServerOptions value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public Func`2<ListenOptions, Task> get_CreateBinding();
    [CompilerGeneratedAttribute]
public void set_CreateBinding(Func`2<ListenOptions, Task> value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.AddressBinder : object {
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.AddressBinder/<BindAsync>d__0")]
public static Task BindAsync(IServerAddressesFeature addresses, KestrelServerOptions serverOptions, ILogger logger, Func`2<ListenOptions, Task> createBinding);
    private static IStrategy CreateStrategy(ListenOptions[] listenOptions, String[] addresses, bool preferAddresses);
    protected internal static bool TryCreateIPEndPoint(BindingAddress address, IPEndPoint& endpoint);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.AddressBinder/<BindEndpointAsync>d__3")]
internal static Task BindEndpointAsync(ListenOptions endpoint, AddressBindContext context);
    internal static ListenOptions ParseAddress(string address, Boolean& https);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.CertificateConfig : object {
    [CompilerGeneratedAttribute]
private IConfigurationSection <ConfigSection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowInvalid>k__BackingField;
    public IConfigurationSection ConfigSection { get; }
    public bool IsFileCert { get; }
    public string Path { get; public set; }
    public string Password { get; public set; }
    public bool IsStoreCert { get; }
    public string Subject { get; public set; }
    public string Store { get; public set; }
    public string Location { get; public set; }
    public Nullable`1<bool> AllowInvalid { get; public set; }
    public CertificateConfig(IConfigurationSection configSection);
    [CompilerGeneratedAttribute]
public IConfigurationSection get_ConfigSection();
    public bool get_IsFileCert();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    public bool get_IsStoreCert();
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_Store();
    [CompilerGeneratedAttribute]
public void set_Store(string value);
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowInvalid();
    [CompilerGeneratedAttribute]
public void set_AllowInvalid(Nullable`1<bool> value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConfigurationReader : object {
    private static string ProtocolsKey;
    private static string CertificatesKey;
    private static string CertificateKey;
    private static string EndpointDefaultsKey;
    private static string EndpointsKey;
    private static string UrlKey;
    private static string Latin1RequestHeadersKey;
    private IConfiguration _configuration;
    private IDictionary`2<string, CertificateConfig> _certificates;
    private IList`1<EndpointConfig> _endpoints;
    private EndpointDefaults _endpointDefaults;
    private Nullable`1<bool> _latin1RequestHeaders;
    public IDictionary`2<string, CertificateConfig> Certificates { get; }
    public EndpointDefaults EndpointDefaults { get; }
    public IEnumerable`1<EndpointConfig> Endpoints { get; }
    public bool Latin1RequestHeaders { get; }
    public ConfigurationReader(IConfiguration configuration);
    public IDictionary`2<string, CertificateConfig> get_Certificates();
    public EndpointDefaults get_EndpointDefaults();
    public IEnumerable`1<EndpointConfig> get_Endpoints();
    public bool get_Latin1RequestHeaders();
    private void ReadCertificates();
    private void ReadEndpointDefaults();
    private void ReadEndpoints();
    private static Nullable`1<HttpProtocols> ParseProtocols(string protocols);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConnectionDispatcher : object {
    private static long _lastConnectionId;
    private ServiceContext _serviceContext;
    private ConnectionDelegate _connectionDelegate;
    private TaskCompletionSource`1<object> _acceptLoopTcs;
    private IKestrelTrace Log { get; }
    public ConnectionDispatcher(ServiceContext serviceContext, ConnectionDelegate connectionDelegate);
    private static ConnectionDispatcher();
    private IKestrelTrace get_Log();
    public Task StartAcceptingConnections(IConnectionListener listener);
    private void StartAcceptingConnectionsCore(IConnectionListener listener);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConnectionLimitMiddleware : object {
    private ConnectionDelegate _next;
    private ResourceCounter _concurrentConnectionCounter;
    private IKestrelTrace _trace;
    public ConnectionLimitMiddleware(ConnectionDelegate next, long connectionLimit, IKestrelTrace trace);
    internal ConnectionLimitMiddleware(ConnectionDelegate next, ResourceCounter concurrentConnectionCounter, IKestrelTrace trace);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConnectionLimitMiddleware/<OnConnectionAsync>d__5")]
public Task OnConnectionAsync(ConnectionContext connection);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConnectionLogScope : object {
    private string _connectionId;
    private string _cachedToString;
    public KeyValuePair`2<string, object> Item { get; }
    public int Count { get; }
    public ConnectionLogScope(string connectionId);
    public sealed virtual KeyValuePair`2<string, object> get_Item(int index);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConnectionLogScope/<GetEnumerator>d__7")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.DuplexPipeStream : Stream {
    private PipeReader _input;
    private PipeWriter _output;
    private bool _throwOnCancelled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _cancelCalled;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DuplexPipeStream(PipeReader input, PipeWriter output, bool throwOnCancelled);
    public void CancelPendingRead();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.DuplexPipeStream/<WriteAsync>d__23")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.DuplexPipeStream/<WriteAsync>d__24")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.DuplexPipeStream/<ReadAsyncInternal>d__27")]
private ValueTask`1<int> ReadAsyncInternal(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    private Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, object state);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.DuplexPipeStreamAdapter`1 : DuplexPipeStream {
    private bool _disposed;
    private object _disposeLock;
    [CompilerGeneratedAttribute]
private TStream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeReader <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeWriter <Output>k__BackingField;
    public TStream Stream { get; }
    public PipeReader Input { get; }
    public PipeWriter Output { get; }
    public DuplexPipeStreamAdapter`1(IDuplexPipe duplexPipe, Func`2<Stream, TStream> createStream);
    public DuplexPipeStreamAdapter`1(IDuplexPipe duplexPipe, StreamPipeReaderOptions readerOptions, StreamPipeWriterOptions writerOptions, Func`2<Stream, TStream> createStream);
    [CompilerGeneratedAttribute]
public TStream get_Stream();
    [CompilerGeneratedAttribute]
public sealed virtual PipeReader get_Input();
    [CompilerGeneratedAttribute]
public sealed virtual PipeWriter get_Output();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.DuplexPipeStreamAdapter`1/<DisposeAsync>d__13")]
public virtual ValueTask DisposeAsync();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.EndpointConfig : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<HttpProtocols> <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigurationSection <ConfigSection>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificateConfig <Certificate>k__BackingField;
    public string Name { get; public set; }
    public string Url { get; public set; }
    public Nullable`1<HttpProtocols> Protocols { get; public set; }
    public IConfigurationSection ConfigSection { get; public set; }
    public CertificateConfig Certificate { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<HttpProtocols> get_Protocols();
    [CompilerGeneratedAttribute]
public void set_Protocols(Nullable`1<HttpProtocols> value);
    [CompilerGeneratedAttribute]
public IConfigurationSection get_ConfigSection();
    [CompilerGeneratedAttribute]
public void set_ConfigSection(IConfigurationSection value);
    [CompilerGeneratedAttribute]
public CertificateConfig get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(CertificateConfig value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.EndpointDefaults : object {
    [CompilerGeneratedAttribute]
private Nullable`1<HttpProtocols> <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigurationSection <ConfigSection>k__BackingField;
    public Nullable`1<HttpProtocols> Protocols { get; public set; }
    public IConfigurationSection ConfigSection { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<HttpProtocols> get_Protocols();
    [CompilerGeneratedAttribute]
public void set_Protocols(Nullable`1<HttpProtocols> value);
    [CompilerGeneratedAttribute]
public IConfigurationSection get_ConfigSection();
    [CompilerGeneratedAttribute]
public void set_ConfigSection(IConfigurationSection value);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.ChunkWriter : object {
    private static Byte[] _hex;
    private static ChunkWriter();
    public static int BeginChunkBytes(int dataCount, Span`1<byte> span);
    internal static int GetPrefixBytesForChunk(int length, Boolean& sliceOneByte);
    [ExtensionAttribute]
internal static int WriteBeginChunkBytes(BufferWriter`1& start, int dataCount);
    [ExtensionAttribute]
internal static void WriteEndChunkBytes(BufferWriter`1& start);
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.ConnectionOptions : Enum {
    public int value__;
    public static ConnectionOptions None;
    public static ConnectionOptions Close;
    public static ConnectionOptions KeepAlive;
    public static ConnectionOptions Upgrade;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.DateHeaderValueManager : object {
    private static Byte[] _datePreambleBytes;
    private DateHeaderValues _dateValues;
    private static DateHeaderValueManager();
    public DateHeaderValues GetDateHeaderValues();
    public sealed virtual void OnHeartbeat(DateTimeOffset now);
    private void SetDateValues(DateTimeOffset value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ChunkedEncodingMessageBody : Http1MessageBody {
    private static byte ByteCR;
    private static int MaxChunkPrefixBytes;
    private long _inputLength;
    private Mode _mode;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _canceled;
    private Task _pumpTask;
    private Pipe _requestBodyPipe;
    private ReadResult _readResult;
    public Http1ChunkedEncodingMessageBody(bool keepAlive, Http1Connection context);
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual bool TryRead(ReadResult& readResult);
    public virtual bool TryReadInternal(ReadResult& readResult);
    public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ChunkedEncodingMessageBody/<ReadAsyncInternal>d__14")]
public virtual ValueTask`1<ReadResult> ReadAsyncInternal(CancellationToken cancellationToken);
    public virtual void Complete(Exception exception);
    public virtual void CancelPendingRead();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ChunkedEncodingMessageBody/<PumpAsync>d__17")]
private Task PumpAsync();
    protected virtual Task OnStopAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ChunkedEncodingMessageBody/<StopAsyncAwaited>d__19")]
private Task StopAsyncAwaited();
    private void Copy(ReadOnlySequence`1& readableBuffer, PipeWriter writableBuffer);
    protected virtual void OnReadStarted();
    private bool Read(ReadOnlySequence`1<byte> readableBuffer, PipeWriter writableBuffer, SequencePosition& consumed, SequencePosition& examined);
    private void ParseChunkedPrefix(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    private void ParseExtension(ReadOnlySequence`1<byte> buffer, SequencePosition& consumed, SequencePosition& examined);
    private void ReadChunkedData(ReadOnlySequence`1& buffer, PipeWriter writableBuffer, SequencePosition& consumed, SequencePosition& examined);
    private void ParseChunkedSuffix(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    private void ParseChunkedTrailer(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    private int CalculateChunkSize(int extraHexDigit, int currentParsedSize);
    private Pipe CreateRequestBodyPipe(Http1Connection context);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1Connection : HttpProtocol {
    private static byte ByteAsterisk;
    private static byte ByteForwardSlash;
    private static string Asterisk;
    private static string ForwardSlash;
    private HttpConnectionContext _context;
    private IHttpParser`1<Http1ParsingHandler> _parser;
    private Http1OutputProducer _http1Output;
    protected long _keepAliveTicks;
    private long _requestHeadersTimeoutTicks;
    private int _requestAborted;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _requestTimedOut;
    private UInt32 _requestCount;
    private HttpRequestTarget _requestTargetForm;
    private Uri _absoluteRequestTarget;
    private string _parsedPath;
    private string _parsedQueryString;
    private string _parsedRawTarget;
    private Uri _parsedAbsoluteRequestTarget;
    private int _remainingRequestHeadersBytesAllowed;
    [CompilerGeneratedAttribute]
private PipeReader <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private MinDataRate <MinResponseDataRate>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryPool`1<byte> <MemoryPool>k__BackingField;
    public PipeReader Input { get; }
    public bool RequestTimedOut { get; }
    public MinDataRate MinResponseDataRate { get; public set; }
    public MemoryPool`1<byte> MemoryPool { get; }
    private MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.MinDataRate { get; private set; }
    private MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinResponseDataRateFeature.MinDataRate { get; private set; }
    public Http1Connection(HttpConnectionContext context);
    [CompilerGeneratedAttribute]
public PipeReader get_Input();
    public bool get_RequestTimedOut();
    [CompilerGeneratedAttribute]
public MinDataRate get_MinResponseDataRate();
    [CompilerGeneratedAttribute]
public void set_MinResponseDataRate(MinDataRate value);
    [CompilerGeneratedAttribute]
public MemoryPool`1<byte> get_MemoryPool();
    protected virtual void OnRequestProcessingEnded();
    public sealed virtual void OnInputOrOutputCompleted();
    public sealed virtual void Abort(ConnectionAbortedException abortReason);
    protected virtual void ApplicationAbort();
    public sealed virtual void StopProcessingNextRequest();
    public void SendTimeoutResponse();
    public sealed virtual void HandleRequestHeadersTimeout();
    public sealed virtual void HandleReadDataRateTimeout();
    public void ParseRequest(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    public bool TakeStartLine(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    public bool TakeMessageHeaders(ReadOnlySequence`1& buffer, bool trailers, SequencePosition& consumed, SequencePosition& examined);
    public void OnStartLine(HttpMethod method, HttpVersion version, Span`1<byte> target, Span`1<byte> path, Span`1<byte> query, Span`1<byte> customMethod, bool pathEncoded);
    private void OnOriginFormTarget(bool pathEncoded, Span`1<byte> target, Span`1<byte> path, Span`1<byte> query);
    private void OnAuthorityFormTarget(HttpMethod method, Span`1<byte> target);
    private void OnAsteriskFormTarget(HttpMethod method);
    private void OnAbsoluteFormTarget(Span`1<byte> target, Span`1<byte> query);
    internal void EnsureHostHeaderExists();
    private void ValidateNonOriginHostHeader(string hostText);
    protected virtual void OnReset();
    protected virtual void OnRequestProcessingEnding();
    protected virtual string CreateRequestId();
    protected virtual MessageBody CreateMessageBody();
    protected virtual void BeginRequestProcessing();
    protected virtual bool BeginRead(ValueTask`1& awaitable);
    protected virtual bool TryParseRequest(ReadResult result, Boolean& endConnection);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.IRequestProcessor.Tick(DateTimeOffset now);
    private sealed virtual override MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.get_MinDataRate();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.set_MinDataRate(MinDataRate value);
    private sealed virtual override MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinResponseDataRateFeature.get_MinDataRate();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinResponseDataRateFeature.set_MinDataRate(MinDataRate value);
    [CompilerGeneratedAttribute]
private void <ParseRequest>g__TrimAndParseHeaders|40_0(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    [CompilerGeneratedAttribute]
private bool <TakeStartLine>g__TrimAndTakeStartLine|41_0(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    [CompilerGeneratedAttribute]
private bool <TakeMessageHeaders>g__TrimAndTakeMessageHeaders|42_0(ReadOnlySequence`1& buffer, bool trailers, SequencePosition& consumed, SequencePosition& examined);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1Connection`1 : Http1Connection {
    [CompilerGeneratedAttribute]
private TContext <Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext>k__BackingField;
    private TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext { get; private set; }
    public Http1Connection`1(HttpConnectionContext context);
    [CompilerGeneratedAttribute]
private sealed virtual override TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.get_HostContext();
    [CompilerGeneratedAttribute]
private sealed virtual override void Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.set_HostContext(TContext value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ContentLengthMessageBody : Http1MessageBody {
    private ReadResult _readResult;
    private long _contentLength;
    private long _inputLength;
    private bool _readCompleted;
    private bool _isReading;
    private int _userCanceled;
    private bool _finalAdvanceCalled;
    public Http1ContentLengthMessageBody(bool keepAlive, long contentLength, Http1Connection context);
    public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ContentLengthMessageBody/<ReadAsyncInternal>d__9")]
public virtual ValueTask`1<ReadResult> ReadAsyncInternal(CancellationToken cancellationToken);
    public virtual bool TryRead(ReadResult& readResult);
    public virtual bool TryReadInternal(ReadResult& readResult);
    private long CreateReadResultFromConnectionReadResult();
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    protected virtual void OnReadStarting();
    public virtual void Complete(Exception exception);
    public virtual void CancelPendingRead();
    protected virtual Task OnStopAsync();
    [CompilerGeneratedAttribute]
private void <ReadAsyncInternal>g__ResetReadingState|9_0();
}
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1MessageBody : MessageBody {
    protected Http1Connection _context;
    protected bool _completed;
    protected Http1MessageBody(Http1Connection context);
    [StackTraceHiddenAttribute]
protected void ThrowUnexpectedEndOfRequestContent();
    public abstract virtual bool TryReadInternal(ReadResult& readResult);
    public abstract virtual ValueTask`1<ReadResult> ReadAsyncInternal(CancellationToken cancellationToken);
    protected virtual Task OnConsumeAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1MessageBody/<OnConsumeAsyncAwaited>d__7")]
protected Task OnConsumeAsyncAwaited();
    public static MessageBody For(HttpVersion httpVersion, HttpRequestHeaders headers, Http1Connection context);
    protected void ThrowIfCompleted();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1OutputProducer : object {
    private static int MaxBeginChunkLength;
    private static int EndChunkLength;
    private string _connectionId;
    private ConnectionContext _connectionContext;
    private IKestrelTrace _log;
    private IHttpMinResponseDataRateFeature _minResponseDataRateFeature;
    private TimingPipeFlusher _flusher;
    private MemoryPool`1<byte> _memoryPool;
    private object _contextLock;
    private bool _pipeWriterCompleted;
    private bool _aborted;
    private long _unflushedBytes;
    private int _currentMemoryPrefixBytes;
    private ConcurrentPipeWriter _pipeWriter;
    private IMemoryOwner`1<byte> _fakeMemoryOwner;
    private bool _autoChunk;
    private bool _writeStreamSuffixCalled;
    private ValueTask`1<FlushResult> _writeStreamSuffixValueTask;
    private int _advancedBytesForChunk;
    private Memory`1<byte> _currentChunkMemory;
    private bool _currentChunkMemoryUpdated;
    private List`1<CompletedBuffer> _completedSegments;
    private Memory`1<byte> _currentSegment;
    private IMemoryOwner`1<byte> _currentSegmentOwner;
    private int _position;
    private bool _startCalled;
    private static ReadOnlySpan`1<byte> ContinueBytes { get; }
    private static ReadOnlySpan`1<byte> HttpVersion11Bytes { get; }
    private static ReadOnlySpan`1<byte> EndHeadersBytes { get; }
    private static ReadOnlySpan`1<byte> EndChunkedResponseBytes { get; }
    public Http1OutputProducer(PipeWriter pipeWriter, string connectionId, ConnectionContext connectionContext, IKestrelTrace log, ITimeoutControl timeoutControl, IHttpMinResponseDataRateFeature minResponseDataRateFeature, MemoryPool`1<byte> memoryPool);
    private static ReadOnlySpan`1<byte> get_ContinueBytes();
    private static ReadOnlySpan`1<byte> get_HttpVersion11Bytes();
    private static ReadOnlySpan`1<byte> get_EndHeadersBytes();
    private static ReadOnlySpan`1<byte> get_EndChunkedResponseBytes();
    public sealed virtual Task WriteDataAsync(ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> WriteDataToPipeAsync(ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> WriteStreamSuffixAsync();
    public sealed virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    public sealed virtual void Advance(int bytes);
    public sealed virtual void CancelPendingFlush();
    public sealed virtual ValueTask`1<FlushResult> WriteChunkAsync(ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    private void CommitChunkInternal(BufferWriter`1& writer, ReadOnlySpan`1<byte> buffer);
    public sealed virtual void WriteResponseHeaders(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, bool appComplete);
    private void WriteResponseHeadersInternal(BufferWriter`1& writer, int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk);
    private void WriteDataWrittenBeforeHeaders(BufferWriter`1& writer);
    public sealed virtual void Dispose();
    private void DisposeCurrentSegment();
    private void CompletePipe();
    public sealed virtual void Abort(ConnectionAbortedException error);
    public sealed virtual void Stop();
    public sealed virtual ValueTask`1<FlushResult> Write100ContinueAsync();
    public sealed virtual ValueTask`1<FlushResult> FirstWriteAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> FirstWriteChunkedAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    public sealed virtual void Reset();
    private ValueTask`1<FlushResult> WriteAsync(ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    private ValueTask`1<FlushResult> WriteAsyncInternal(BufferWriter`1& writer, ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    private Memory`1<byte> GetChunkedMemory(int sizeHint);
    private void UpdateCurrentChunkMemory(int sizeHint);
    private void WriteCurrentChunkMemoryToPipeWriter(BufferWriter`1& writer);
    private Memory`1<byte> GetFakeMemory(int sizeHint);
    private Memory`1<byte> LeasedMemory(int sizeHint);
    private void EnsureCapacity(int sizeHint);
    private void AddSegment(int sizeHint);
    [StackTraceHiddenAttribute]
private void ThrowIfSuffixSent();
    [StackTraceHiddenAttribute]
private static void ThrowSuffixSent();
    [CompilerGeneratedAttribute]
internal static ValueTask`1<FlushResult> <FlushAsync>g__FlushAsyncChunked|38_0(Http1OutputProducer producer, CancellationToken token);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ParsingHandler : ValueType {
    public Http1Connection Connection;
    public bool Trailers;
    public Http1ParsingHandler(Http1Connection connection);
    public Http1ParsingHandler(Http1Connection connection, bool trailers);
    public sealed virtual void OnHeader(Span`1<byte> name, Span`1<byte> value);
    public sealed virtual void OnHeadersComplete();
    public sealed virtual void OnStartLine(HttpMethod method, HttpVersion version, Span`1<byte> target, Span`1<byte> path, Span`1<byte> query, Span`1<byte> customMethod, bool pathEncoded);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1UpgradeMessageBody : Http1MessageBody {
    private int _userCanceled;
    public bool IsEmpty { get; }
    public Http1UpgradeMessageBody(Http1Connection context);
    public virtual bool get_IsEmpty();
    public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual bool TryRead(ReadResult& result);
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual void Complete(Exception exception);
    public virtual void CancelPendingRead();
    public virtual Task ConsumeAsync();
    public virtual Task StopAsync();
    public virtual bool TryReadInternal(ReadResult& readResult);
    public virtual ValueTask`1<ReadResult> ReadAsyncInternal(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1UpgradeMessageBody/<ReadAsyncInternalAwaited>d__14")]
private ValueTask`1<ReadResult> ReadAsyncInternalAwaited(ValueTask`1<ReadResult> readTask, CancellationToken cancellationToken);
}
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpHeaders : object {
    protected long _bits;
    protected Nullable`1<long> _contentLength;
    protected bool _isReadOnly;
    protected Dictionary`2<string, StringValues> MaybeUnknown;
    protected Dictionary`2<string, StringValues> Unknown { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Item { get; private set; }
    private StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.IsReadOnly { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Keys { get; }
    private ICollection`1<StringValues> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Values { get; }
    protected Dictionary`2<string, StringValues> get_Unknown();
    public sealed virtual Nullable`1<long> get_ContentLength();
    public sealed virtual void set_ContentLength(Nullable`1<long> value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Item(string key);
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Item(string key, StringValues value);
    private sealed virtual override StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.set_Item(string key, StringValues value);
    protected static void ThrowHeadersReadOnlyException();
    protected static void ThrowArgumentException();
    protected static void ThrowKeyNotFoundException();
    protected static void ThrowDuplicateKeyException();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.get_IsReadOnly();
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Keys();
    private sealed virtual override ICollection`1<StringValues> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Values();
    public void SetReadOnly();
    public void Reset();
    protected static StringValues AppendValue(StringValues existing, string append);
    protected bool TryGetUnknown(string key, StringValues& value);
    protected bool RemoveUnknown(string key);
    protected virtual int GetCountFast();
    protected virtual bool TryGetValueFast(string key, StringValues& value);
    protected virtual void SetValueFast(string key, StringValues value);
    protected virtual bool AddValueFast(string key, StringValues value);
    protected virtual bool RemoveFast(string key);
    protected virtual void ClearFast();
    protected virtual bool CopyToFast(KeyValuePair`2[] array, int arrayIndex);
    protected virtual IEnumerator`1<KeyValuePair`2<string, StringValues>> GetEnumeratorFast();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Add(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Add(string key, StringValues value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Contains(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.ContainsKey(string key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, StringValues>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Remove(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.TryGetValue(string key, StringValues& value);
    public static void ValidateHeaderValueCharacters(StringValues headerValues);
    public static void ValidateHeaderValueCharacters(string headerCharacters);
    public static void ValidateHeaderNameCharacters(string headerCharacters);
    public static ConnectionOptions ParseConnection(StringValues connection);
    public static TransferCoding GetFinalTransferCoding(StringValues transferEncoding);
    private static void ThrowInvalidContentLengthException(long value);
    private static void ThrowInvalidHeaderCharacter(char ch);
    private static void ThrowInvalidEmptyHeaderName();
}
public enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod : Enum {
    public byte value__;
    public static HttpMethod Get;
    public static HttpMethod Put;
    public static HttpMethod Delete;
    public static HttpMethod Post;
    public static HttpMethod Head;
    public static HttpMethod Trace;
    public static HttpMethod Patch;
    public static HttpMethod Connect;
    public static HttpMethod Options;
    public static HttpMethod Custom;
    public static HttpMethod None;
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpParser`1 : object {
    private bool _showErrorDetails;
    private static byte ByteCR;
    private static byte ByteLF;
    private static byte ByteColon;
    private static byte ByteSpace;
    private static byte ByteTab;
    private static byte ByteQuestionMark;
    private static byte BytePercentage;
    public HttpParser`1(bool showErrorDetails);
    public bool ParseRequestLine(TRequestHandler handler, ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    private void ParseRequestLine(TRequestHandler handler, Byte* data, int length);
    public sealed virtual bool ParseHeaders(TRequestHandler handler, SequenceReader`1& reader);
    private int ParseMultiSpanHeader(TRequestHandler handler, SequenceReader`1& reader);
    private int FindEndOfName(Byte* headerLine, int length);
    private void TakeSingleHeader(Byte* headerLine, int length, TRequestHandler handler);
    private static bool TryGetNewLine(ReadOnlySequence`1& buffer, SequencePosition& found);
    private Span`1<byte> GetUnknownMethod(Byte* data, int length, Int32& methodLength);
    [StackTraceHiddenAttribute]
private void RejectRequestLine(Byte* requestLine, int length);
    [StackTraceHiddenAttribute]
private void RejectRequestHeader(Byte* headerLine, int length);
    [StackTraceHiddenAttribute]
private void RejectUnknownVersion(Byte* version, int length);
    private BadHttpRequestException GetInvalidRequestException(RequestRejectionReason reason, Byte* detail, int length);
    private sealed virtual override bool Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpParser<TRequestHandler>.ParseRequestLine(TRequestHandler handler, ReadOnlySequence`1& modreq(System.Runtime.InteropServices.InAttribute) buffer, SequencePosition& consumed, SequencePosition& examined);
}
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol : object {
    private static Byte[] _bytesConnectionClose;
    private static Byte[] _bytesConnectionKeepAlive;
    private static Byte[] _bytesTransferEncodingChunked;
    private static Byte[] _bytesServer;
    protected BodyControl _bodyControl;
    private Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> _onStarting;
    private Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> _onCompleted;
    private object _abortLock;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _connectionAborted;
    private bool _preventRequestAbortedCancellation;
    private CancellationTokenSource _abortedCts;
    private Nullable`1<CancellationToken> _manuallySetRequestAbortToken;
    protected RequestProcessingStatus _requestProcessingStatus;
    protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _keepAlive;
    private bool _canWriteResponseBody;
    private bool _hasAdvanced;
    private bool _isLeasedMemoryInvalid;
    private bool _autoChunk;
    protected Exception _applicationException;
    private BadHttpRequestException _requestRejectedException;
    protected HttpVersion _httpVersion;
    private string _requestId;
    private int _requestHeadersParsed;
    private long _responseBytesWritten;
    private HttpConnectionContext _context;
    private RouteValueDictionary _routeValues;
    private Endpoint _endpoint;
    protected string _methodText;
    private string _scheme;
    private Stream _requestStreamInternal;
    private Stream _responseStreamInternal;
    [CompilerGeneratedAttribute]
private IHttpResponseControl <HttpResponseControl>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpOutputProducer <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelServerOptions <ServerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionIdFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasStartedConsumingRequestBody>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxRequestBodySize>k__BackingField;
    [CompilerGeneratedAttribute]
private MinDataRate <MinRequestBodyDataRate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSynchronousIO>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUpgradableRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUpgraded>k__BackingField;
    [CompilerGeneratedAttribute]
private IPAddress <RemoteIpAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RemotePort>k__BackingField;
    [CompilerGeneratedAttribute]
private IPAddress <LocalIpAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocalPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathBase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private IHeaderDictionary <RequestHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IHeaderDictionary <RequestTrailers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestTrailersAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <RequestBody>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeReader <RequestBodyPipeReader>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponseTrailers <ResponseTrailers>k__BackingField;
    private int _statusCode;
    private string _reasonPhrase;
    [CompilerGeneratedAttribute]
private IHeaderDictionary <ResponseHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <ResponseBody>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeWriter <ResponseBodyPipeWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpRequestHeaders <HttpRequestHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponseHeaders <HttpResponseHeaders>k__BackingField;
    private static Type IHttpRequestFeatureType;
    private static Type IHttpResponseFeatureType;
    private static Type IHttpResponseBodyFeatureType;
    private static Type IRequestBodyPipeFeatureType;
    private static Type IHttpRequestIdentifierFeatureType;
    private static Type IServiceProvidersFeatureType;
    private static Type IHttpRequestLifetimeFeatureType;
    private static Type IHttpConnectionFeatureType;
    private static Type IRouteValuesFeatureType;
    private static Type IEndpointFeatureType;
    private static Type IHttpAuthenticationFeatureType;
    private static Type IHttpRequestTrailersFeatureType;
    private static Type IQueryFeatureType;
    private static Type IFormFeatureType;
    private static Type IHttpUpgradeFeatureType;
    private static Type IHttp2StreamIdFeatureType;
    private static Type IHttpResponseTrailersFeatureType;
    private static Type IResponseCookiesFeatureType;
    private static Type IItemsFeatureType;
    private static Type ITlsConnectionFeatureType;
    private static Type IHttpWebSocketFeatureType;
    private static Type ISessionFeatureType;
    private static Type IHttpMaxRequestBodySizeFeatureType;
    private static Type IHttpMinRequestBodyDataRateFeatureType;
    private static Type IHttpMinResponseDataRateFeatureType;
    private static Type IHttpBodyControlFeatureType;
    private static Type IHttpResetFeatureType;
    private object _currentIHttpRequestFeature;
    private object _currentIHttpResponseFeature;
    private object _currentIHttpResponseBodyFeature;
    private object _currentIRequestBodyPipeFeature;
    private object _currentIHttpRequestIdentifierFeature;
    private object _currentIServiceProvidersFeature;
    private object _currentIHttpRequestLifetimeFeature;
    private object _currentIHttpConnectionFeature;
    private object _currentIRouteValuesFeature;
    private object _currentIEndpointFeature;
    private object _currentIHttpAuthenticationFeature;
    private object _currentIHttpRequestTrailersFeature;
    private object _currentIQueryFeature;
    private object _currentIFormFeature;
    private object _currentIHttpUpgradeFeature;
    private object _currentIHttp2StreamIdFeature;
    private object _currentIHttpResponseTrailersFeature;
    private object _currentIResponseCookiesFeature;
    private object _currentIItemsFeature;
    private object _currentITlsConnectionFeature;
    private object _currentIHttpWebSocketFeature;
    private object _currentISessionFeature;
    private object _currentIHttpMaxRequestBodySizeFeature;
    private object _currentIHttpMinRequestBodyDataRateFeature;
    private object _currentIHttpMinResponseDataRateFeature;
    private object _currentIHttpBodyControlFeature;
    private object _currentIHttpResetFeature;
    private int _featureRevision;
    private List`1<KeyValuePair`2<Type, object>> MaybeExtra;
    public IHttpResponseControl HttpResponseControl { get; public set; }
    public ServiceContext ServiceContext { get; }
    private IPEndPoint LocalEndPoint { get; }
    private IPEndPoint RemoteEndPoint { get; }
    public ITimeoutControl TimeoutControl { get; }
    public IFeatureCollection ConnectionFeatures { get; }
    public IHttpOutputProducer Output { get; protected set; }
    protected IKestrelTrace Log { get; }
    private DateHeaderValueManager DateHeaderValueManager { get; }
    protected KestrelServerOptions ServerOptions { get; }
    protected string ConnectionId { get; }
    public string ConnectionIdFeature { get; public set; }
    public bool HasStartedConsumingRequestBody { get; public set; }
    public Nullable`1<long> MaxRequestBodySize { get; public set; }
    public MinDataRate MinRequestBodyDataRate { get; public set; }
    public bool AllowSynchronousIO { get; public set; }
    public string TraceIdentifier { get; public set; }
    public bool IsUpgradableRequest { get; private set; }
    public bool IsUpgraded { get; public set; }
    public IPAddress RemoteIpAddress { get; public set; }
    public int RemotePort { get; public set; }
    public IPAddress LocalIpAddress { get; public set; }
    public int LocalPort { get; public set; }
    public string Scheme { get; public set; }
    public HttpMethod Method { get; public set; }
    public string PathBase { get; public set; }
    public string Path { get; public set; }
    public string QueryString { get; public set; }
    public string RawTarget { get; public set; }
    public string HttpVersion { get; public set; }
    public IHeaderDictionary RequestHeaders { get; public set; }
    public IHeaderDictionary RequestTrailers { get; }
    public bool RequestTrailersAvailable { get; public set; }
    public Stream RequestBody { get; public set; }
    public PipeReader RequestBodyPipeReader { get; public set; }
    public HttpResponseTrailers ResponseTrailers { get; public set; }
    public int StatusCode { get; public set; }
    public string ReasonPhrase { get; public set; }
    public IHeaderDictionary ResponseHeaders { get; public set; }
    public Stream ResponseBody { get; public set; }
    public PipeWriter ResponseBodyPipeWriter { get; public set; }
    public CancellationToken RequestAborted { get; public set; }
    public bool HasResponseStarted { get; }
    public bool HasFlushedHeaders { get; }
    public bool HasResponseCompleted { get; }
    protected HttpRequestHeaders HttpRequestHeaders { get; }
    protected HttpResponseHeaders HttpResponseHeaders { get; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Protocol { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Scheme { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Method { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.PathBase { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Path { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.QueryString { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.RawTarget { get; private set; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Headers { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Body { get; private set; }
    private PipeReader Microsoft.AspNetCore.Http.Features.IRequestBodyPipeFeature.Reader { get; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpRequestTrailersFeature.Available { get; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestTrailersFeature.Trailers { get; }
    private int Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.StatusCode { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.ReasonPhrase { get; private set; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.Headers { get; private set; }
    private CancellationToken Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.RequestAborted { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.HasStarted { get; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.IsUpgradableRequest { get; }
    private IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemoteIpAddress { get; private set; }
    private IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalIpAddress { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemotePort { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalPort { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.ConnectionId { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.TraceIdentifier { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.AllowSynchronousIO { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.IsReadOnly { get; }
    private Nullable`1<long> Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.MaxRequestBodySize { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.Body { get; private set; }
    private PipeWriter Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.Writer { get; }
    private Endpoint Microsoft.AspNetCore.Http.Features.IEndpointFeature.Endpoint { get; private set; }
    private RouteValueDictionary Microsoft.AspNetCore.Http.Features.IRouteValuesFeature.RouteValues { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.Stream { get; }
    private bool Microsoft.AspNetCore.Http.Features.IFeatureCollection.IsReadOnly { get; }
    private int Microsoft.AspNetCore.Http.Features.IFeatureCollection.Revision { get; }
    private object Microsoft.AspNetCore.Http.Features.IFeatureCollection.Item { get; private set; }
    public HttpProtocol(HttpConnectionContext context);
    private static HttpProtocol();
    [CompilerGeneratedAttribute]
public IHttpResponseControl get_HttpResponseControl();
    [CompilerGeneratedAttribute]
public void set_HttpResponseControl(IHttpResponseControl value);
    public ServiceContext get_ServiceContext();
    private IPEndPoint get_LocalEndPoint();
    private IPEndPoint get_RemoteEndPoint();
    public ITimeoutControl get_TimeoutControl();
    public IFeatureCollection get_ConnectionFeatures();
    [CompilerGeneratedAttribute]
public IHttpOutputProducer get_Output();
    [CompilerGeneratedAttribute]
protected void set_Output(IHttpOutputProducer value);
    protected IKestrelTrace get_Log();
    private DateHeaderValueManager get_DateHeaderValueManager();
    [CompilerGeneratedAttribute]
protected KestrelServerOptions get_ServerOptions();
    protected string get_ConnectionId();
    [CompilerGeneratedAttribute]
public string get_ConnectionIdFeature();
    [CompilerGeneratedAttribute]
public void set_ConnectionIdFeature(string value);
    [CompilerGeneratedAttribute]
public bool get_HasStartedConsumingRequestBody();
    [CompilerGeneratedAttribute]
public void set_HasStartedConsumingRequestBody(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxRequestBodySize();
    [CompilerGeneratedAttribute]
public void set_MaxRequestBodySize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public MinDataRate get_MinRequestBodyDataRate();
    [CompilerGeneratedAttribute]
public void set_MinRequestBodyDataRate(MinDataRate value);
    [CompilerGeneratedAttribute]
public bool get_AllowSynchronousIO();
    [CompilerGeneratedAttribute]
public void set_AllowSynchronousIO(bool value);
    public void set_TraceIdentifier(string value);
    public string get_TraceIdentifier();
    [CompilerGeneratedAttribute]
public bool get_IsUpgradableRequest();
    [CompilerGeneratedAttribute]
private void set_IsUpgradableRequest(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsUpgraded();
    [CompilerGeneratedAttribute]
public void set_IsUpgraded(bool value);
    [CompilerGeneratedAttribute]
public IPAddress get_RemoteIpAddress();
    [CompilerGeneratedAttribute]
public void set_RemoteIpAddress(IPAddress value);
    [CompilerGeneratedAttribute]
public int get_RemotePort();
    [CompilerGeneratedAttribute]
public void set_RemotePort(int value);
    [CompilerGeneratedAttribute]
public IPAddress get_LocalIpAddress();
    [CompilerGeneratedAttribute]
public void set_LocalIpAddress(IPAddress value);
    [CompilerGeneratedAttribute]
public int get_LocalPort();
    [CompilerGeneratedAttribute]
public void set_LocalPort(int value);
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
public void set_Scheme(string value);
    [CompilerGeneratedAttribute]
public HttpMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(HttpMethod value);
    [CompilerGeneratedAttribute]
public string get_PathBase();
    [CompilerGeneratedAttribute]
public void set_PathBase(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_QueryString();
    [CompilerGeneratedAttribute]
public void set_QueryString(string value);
    [CompilerGeneratedAttribute]
public string get_RawTarget();
    [CompilerGeneratedAttribute]
public void set_RawTarget(string value);
    public string get_HttpVersion();
    public void set_HttpVersion(string value);
    private void HttpVersionSetSlow(string value);
    [CompilerGeneratedAttribute]
public IHeaderDictionary get_RequestHeaders();
    [CompilerGeneratedAttribute]
public void set_RequestHeaders(IHeaderDictionary value);
    [CompilerGeneratedAttribute]
public IHeaderDictionary get_RequestTrailers();
    [CompilerGeneratedAttribute]
public bool get_RequestTrailersAvailable();
    [CompilerGeneratedAttribute]
public void set_RequestTrailersAvailable(bool value);
    [CompilerGeneratedAttribute]
public Stream get_RequestBody();
    [CompilerGeneratedAttribute]
public void set_RequestBody(Stream value);
    [CompilerGeneratedAttribute]
public PipeReader get_RequestBodyPipeReader();
    [CompilerGeneratedAttribute]
public void set_RequestBodyPipeReader(PipeReader value);
    [CompilerGeneratedAttribute]
public HttpResponseTrailers get_ResponseTrailers();
    [CompilerGeneratedAttribute]
public void set_ResponseTrailers(HttpResponseTrailers value);
    public int get_StatusCode();
    public void set_StatusCode(int value);
    public string get_ReasonPhrase();
    public void set_ReasonPhrase(string value);
    [CompilerGeneratedAttribute]
public IHeaderDictionary get_ResponseHeaders();
    [CompilerGeneratedAttribute]
public void set_ResponseHeaders(IHeaderDictionary value);
    [CompilerGeneratedAttribute]
public Stream get_ResponseBody();
    [CompilerGeneratedAttribute]
public void set_ResponseBody(Stream value);
    [CompilerGeneratedAttribute]
public PipeWriter get_ResponseBodyPipeWriter();
    [CompilerGeneratedAttribute]
public void set_ResponseBodyPipeWriter(PipeWriter value);
    public CancellationToken get_RequestAborted();
    public void set_RequestAborted(CancellationToken value);
    public bool get_HasResponseStarted();
    public bool get_HasFlushedHeaders();
    public bool get_HasResponseCompleted();
    [CompilerGeneratedAttribute]
protected HttpRequestHeaders get_HttpRequestHeaders();
    [CompilerGeneratedAttribute]
protected HttpResponseHeaders get_HttpResponseHeaders();
    public void InitializeBodyControl(MessageBody messageBody);
    internal void ResetState();
    public void Reset();
    protected abstract virtual void OnReset();
    protected abstract virtual void ApplicationAbort();
    protected virtual void OnRequestProcessingEnding();
    protected virtual void OnRequestProcessingEnded();
    protected virtual void BeginRequestProcessing();
    protected virtual void OnErrorAfterResponseStarted();
    protected virtual bool BeginRead(ValueTask`1& awaitable);
    protected abstract virtual string CreateRequestId();
    protected abstract virtual MessageBody CreateMessageBody();
    protected abstract virtual bool TryParseRequest(ReadResult result, Boolean& endConnection);
    private void CancelRequestAbortedToken();
    protected void AbortRequest();
    protected void PoisonRequestBodyStream(Exception abortReason);
    private void PreventRequestAbortedCancellation();
    public void OnHeader(Span`1<byte> name, Span`1<byte> value);
    public void OnTrailer(Span`1<byte> name, Span`1<byte> value);
    public void OnHeadersComplete();
    public void OnTrailersComplete();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<ProcessRequestsAsync>d__213`1")]
public sealed virtual Task ProcessRequestsAsync(IHttpApplication`1<TContext> application);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<ProcessRequests>d__214`1")]
private Task ProcessRequests(IHttpApplication`1<TContext> application);
    public void OnStarting(Func`2<object, Task> callback, object state);
    public void OnCompleted(Func`2<object, Task> callback, object state);
    protected Task FireOnStarting();
    private Task FireOnStartingMayAwait(Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> onStarting);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<FireOnStartingAwaited>d__219")]
private Task FireOnStartingAwaited(Task currentTask, Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> onStarting);
    protected Task FireOnCompleted();
    private Task FireOnCompletedMayAwait(Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> onCompleted);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<FireOnCompletedAwaited>d__222")]
private Task FireOnCompletedAwaited(Task currentTask, Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> onCompleted);
    private void VerifyAndUpdateWrite(int count);
    [StackTraceHiddenAttribute]
private void ThrowTooManyBytesWritten(int count);
    private InvalidOperationException GetTooManyBytesWrittenException(int count);
    private void CheckLastWrite();
    protected bool VerifyResponseContentLength(Exception& ex);
    public sealed virtual void ProduceContinue();
    public Task InitializeResponseAsync(int firstWriteByteCount);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<InitializeResponseAwaited>d__230")]
public Task InitializeResponseAwaited(Task startingTask, int firstWriteByteCount);
    private HttpResponseHeaders InitializeResponseFirstWrite(int firstWriteByteCount);
    private void ProduceStart(bool appCompleted);
    private void VerifyInitializeState(int firstWriteByteCount);
    protected Task TryProduceInvalidRequestResponse();
    protected Task ProduceEnd();
    private Task WriteSuffix();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<WriteSuffixAwaited>d__237")]
private Task WriteSuffixAwaited(ValueTask`1<FlushResult> writeTask);
    private HttpResponseHeaders CreateResponseHeaders(bool appCompleted);
    private bool CanWriteResponseBody();
    private bool CanAutoSetContentLengthZeroResponseHeader();
    private static void ThrowResponseAlreadyStartedException(string value);
    private void RejectNonBodyTransferEncodingResponse(bool appCompleted);
    private void SetErrorResponseException(BadHttpRequestException ex);
    private void SetErrorResponseHeaders(int statusCode);
    public void HandleNonBodyResponseWrite();
    [StackTraceHiddenAttribute]
private void ThrowWritingToResponseBodyNotSupported();
    [StackTraceHiddenAttribute]
private void ThrowResponseAbortedException();
    [StackTraceHiddenAttribute]
public void ThrowRequestTargetRejected(Span`1<byte> target);
    private BadHttpRequestException GetInvalidRequestTargetException(Span`1<byte> target);
    public void SetBadRequestState(BadHttpRequestException ex);
    public void ReportApplicationError(Exception ex);
    public sealed virtual void Advance(int bytes);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    public sealed virtual ValueTask`1<FlushResult> FlushPipeAsync(CancellationToken cancellationToken);
    public sealed virtual void CancelPendingFlush();
    public sealed virtual Task CompleteAsync(Exception exception);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<CompleteAsyncAwaited>d__258")]
private Task CompleteAsyncAwaited(Task onStartingTask);
    [StackTraceHiddenAttribute]
private static void ThrowException(Exception exception);
    public sealed virtual ValueTask`1<FlushResult> WritePipeAsync(ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    private ValueTask`1<FlushResult> FirstWriteAsync(ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<FirstWriteAsyncAwaited>d__262")]
private ValueTask`1<FlushResult> FirstWriteAsyncAwaited(Task initializeTask, ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    private ValueTask`1<FlushResult> FirstWriteAsyncInternal(ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    public Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<FlushAsyncAwaited>d__265")]
private ValueTask`1<FlushResult> FlushAsyncAwaited(Task initializeTask, CancellationToken cancellationToken);
    public Task WriteAsync(ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<WriteAsyncAwaited>d__267")]
public ValueTask`1<FlushResult> WriteAsyncAwaited(Task initializeTask, ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Protocol();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Protocol(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Scheme();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Scheme(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Method();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Method(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_PathBase();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_PathBase(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Path();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Path(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_QueryString();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_QueryString(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_RawTarget();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_RawTarget(string value);
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Headers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Headers(IHeaderDictionary value);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Body();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Body(Stream value);
    private sealed virtual override PipeReader Microsoft.AspNetCore.Http.Features.IRequestBodyPipeFeature.get_Reader();
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpRequestTrailersFeature.get_Available();
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestTrailersFeature.get_Trailers();
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_StatusCode();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_StatusCode(int value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_ReasonPhrase();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_ReasonPhrase(string value);
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_Headers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_Headers(IHeaderDictionary value);
    private sealed virtual override CancellationToken Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.get_RequestAborted();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.set_RequestAborted(CancellationToken value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_HasStarted();
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.get_IsUpgradableRequest();
    private sealed virtual override IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_RemoteIpAddress();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_RemoteIpAddress(IPAddress value);
    private sealed virtual override IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_LocalIpAddress();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_LocalIpAddress(IPAddress value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_RemotePort();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_RemotePort(int value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_LocalPort();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_LocalPort(int value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_ConnectionId();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_ConnectionId(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.get_TraceIdentifier();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.set_TraceIdentifier(string value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.get_AllowSynchronousIO();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.set_AllowSynchronousIO(bool value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.get_IsReadOnly();
    private sealed virtual override Nullable`1<long> Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.get_MaxRequestBodySize();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.set_MaxRequestBodySize(Nullable`1<long> value);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_Body();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_Body(Stream value);
    private sealed virtual override PipeWriter Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.get_Writer();
    private sealed virtual override Endpoint Microsoft.AspNetCore.Http.Features.IEndpointFeature.get_Endpoint();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IEndpointFeature.set_Endpoint(Endpoint value);
    private sealed virtual override RouteValueDictionary Microsoft.AspNetCore.Http.Features.IRouteValuesFeature.get_RouteValues();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IRouteValuesFeature.set_RouteValues(RouteValueDictionary value);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.get_Stream();
    protected void ResetHttp1Features();
    protected void ResetHttp2Features();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.OnStarting(Func`2<object, Task> callback, object state);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.OnCompleted(Func`2<object, Task> callback, object state);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<Microsoft-AspNetCore-Http-Features-IHttpUpgradeFeature-UpgradeAsync>d__360")]
private sealed virtual override Task`1<Stream> Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.UpgradeAsync();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.Abort();
    private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.StartAsync(CancellationToken cancellationToken);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.DisableBuffering();
    private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.SendFileAsync(string path, long offset, Nullable`1<long> count, CancellationToken cancellation);
    private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.CompleteAsync();
    private void FastReset();
    internal void ResetFeatureCollection();
    private object ExtraFeatureGet(Type key);
    private void ExtraFeatureSet(Type key, object value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_IsReadOnly();
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_Revision();
    private sealed virtual override object Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_Item(Type key);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IFeatureCollection.set_Item(Type key, object value);
    private sealed virtual override TFeature Microsoft.AspNetCore.Http.Features.IFeatureCollection.Get();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IFeatureCollection.Set(TFeature feature);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<FastEnumerable>d__435")]
private IEnumerable`1<KeyValuePair`2<Type, object>> FastEnumerable();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<Type, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestHeaders : HttpHeaders {
    private HeaderReferences _headers;
    private bool _reuseHeaderValues;
    private bool _useLatin1;
    private long _previousBits;
    public bool HasConnection { get; }
    public bool HasTransferEncoding { get; }
    public int HostCount { get; }
    public StringValues HeaderCacheControl { get; public set; }
    public StringValues HeaderConnection { get; public set; }
    public StringValues HeaderDate { get; public set; }
    public StringValues HeaderKeepAlive { get; public set; }
    public StringValues HeaderPragma { get; public set; }
    public StringValues HeaderTrailer { get; public set; }
    public StringValues HeaderTransferEncoding { get; public set; }
    public StringValues HeaderUpgrade { get; public set; }
    public StringValues HeaderVia { get; public set; }
    public StringValues HeaderWarning { get; public set; }
    public StringValues HeaderAllow { get; public set; }
    public StringValues HeaderContentType { get; public set; }
    public StringValues HeaderContentEncoding { get; public set; }
    public StringValues HeaderContentLanguage { get; public set; }
    public StringValues HeaderContentLocation { get; public set; }
    public StringValues HeaderContentMD5 { get; public set; }
    public StringValues HeaderContentRange { get; public set; }
    public StringValues HeaderExpires { get; public set; }
    public StringValues HeaderLastModified { get; public set; }
    public StringValues HeaderAccept { get; public set; }
    public StringValues HeaderAcceptCharset { get; public set; }
    public StringValues HeaderAcceptEncoding { get; public set; }
    public StringValues HeaderAcceptLanguage { get; public set; }
    public StringValues HeaderAuthorization { get; public set; }
    public StringValues HeaderCookie { get; public set; }
    public StringValues HeaderExpect { get; public set; }
    public StringValues HeaderFrom { get; public set; }
    public StringValues HeaderHost { get; public set; }
    public StringValues HeaderIfMatch { get; public set; }
    public StringValues HeaderIfModifiedSince { get; public set; }
    public StringValues HeaderIfNoneMatch { get; public set; }
    public StringValues HeaderIfRange { get; public set; }
    public StringValues HeaderIfUnmodifiedSince { get; public set; }
    public StringValues HeaderMaxForwards { get; public set; }
    public StringValues HeaderProxyAuthorization { get; public set; }
    public StringValues HeaderReferer { get; public set; }
    public StringValues HeaderRange { get; public set; }
    public StringValues HeaderTE { get; public set; }
    public StringValues HeaderTranslate { get; public set; }
    public StringValues HeaderUserAgent { get; public set; }
    public StringValues HeaderDNT { get; public set; }
    public StringValues HeaderUpgradeInsecureRequests { get; public set; }
    public StringValues HeaderRequestId { get; public set; }
    public StringValues HeaderCorrelationContext { get; public set; }
    public StringValues HeaderTraceParent { get; public set; }
    public StringValues HeaderTraceState { get; public set; }
    public StringValues HeaderOrigin { get; public set; }
    public StringValues HeaderAccessControlRequestMethod { get; public set; }
    public StringValues HeaderAccessControlRequestHeaders { get; public set; }
    public StringValues HeaderContentLength { get; public set; }
    public HttpRequestHeaders(bool reuseHeaderValues, bool useLatin1);
    public bool get_HasConnection();
    public bool get_HasTransferEncoding();
    public int get_HostCount();
    public StringValues get_HeaderCacheControl();
    public void set_HeaderCacheControl(StringValues value);
    public StringValues get_HeaderConnection();
    public void set_HeaderConnection(StringValues value);
    public StringValues get_HeaderDate();
    public void set_HeaderDate(StringValues value);
    public StringValues get_HeaderKeepAlive();
    public void set_HeaderKeepAlive(StringValues value);
    public StringValues get_HeaderPragma();
    public void set_HeaderPragma(StringValues value);
    public StringValues get_HeaderTrailer();
    public void set_HeaderTrailer(StringValues value);
    public StringValues get_HeaderTransferEncoding();
    public void set_HeaderTransferEncoding(StringValues value);
    public StringValues get_HeaderUpgrade();
    public void set_HeaderUpgrade(StringValues value);
    public StringValues get_HeaderVia();
    public void set_HeaderVia(StringValues value);
    public StringValues get_HeaderWarning();
    public void set_HeaderWarning(StringValues value);
    public StringValues get_HeaderAllow();
    public void set_HeaderAllow(StringValues value);
    public StringValues get_HeaderContentType();
    public void set_HeaderContentType(StringValues value);
    public StringValues get_HeaderContentEncoding();
    public void set_HeaderContentEncoding(StringValues value);
    public StringValues get_HeaderContentLanguage();
    public void set_HeaderContentLanguage(StringValues value);
    public StringValues get_HeaderContentLocation();
    public void set_HeaderContentLocation(StringValues value);
    public StringValues get_HeaderContentMD5();
    public void set_HeaderContentMD5(StringValues value);
    public StringValues get_HeaderContentRange();
    public void set_HeaderContentRange(StringValues value);
    public StringValues get_HeaderExpires();
    public void set_HeaderExpires(StringValues value);
    public StringValues get_HeaderLastModified();
    public void set_HeaderLastModified(StringValues value);
    public StringValues get_HeaderAccept();
    public void set_HeaderAccept(StringValues value);
    public StringValues get_HeaderAcceptCharset();
    public void set_HeaderAcceptCharset(StringValues value);
    public StringValues get_HeaderAcceptEncoding();
    public void set_HeaderAcceptEncoding(StringValues value);
    public StringValues get_HeaderAcceptLanguage();
    public void set_HeaderAcceptLanguage(StringValues value);
    public StringValues get_HeaderAuthorization();
    public void set_HeaderAuthorization(StringValues value);
    public StringValues get_HeaderCookie();
    public void set_HeaderCookie(StringValues value);
    public StringValues get_HeaderExpect();
    public void set_HeaderExpect(StringValues value);
    public StringValues get_HeaderFrom();
    public void set_HeaderFrom(StringValues value);
    public StringValues get_HeaderHost();
    public void set_HeaderHost(StringValues value);
    public StringValues get_HeaderIfMatch();
    public void set_HeaderIfMatch(StringValues value);
    public StringValues get_HeaderIfModifiedSince();
    public void set_HeaderIfModifiedSince(StringValues value);
    public StringValues get_HeaderIfNoneMatch();
    public void set_HeaderIfNoneMatch(StringValues value);
    public StringValues get_HeaderIfRange();
    public void set_HeaderIfRange(StringValues value);
    public StringValues get_HeaderIfUnmodifiedSince();
    public void set_HeaderIfUnmodifiedSince(StringValues value);
    public StringValues get_HeaderMaxForwards();
    public void set_HeaderMaxForwards(StringValues value);
    public StringValues get_HeaderProxyAuthorization();
    public void set_HeaderProxyAuthorization(StringValues value);
    public StringValues get_HeaderReferer();
    public void set_HeaderReferer(StringValues value);
    public StringValues get_HeaderRange();
    public void set_HeaderRange(StringValues value);
    public StringValues get_HeaderTE();
    public void set_HeaderTE(StringValues value);
    public StringValues get_HeaderTranslate();
    public void set_HeaderTranslate(StringValues value);
    public StringValues get_HeaderUserAgent();
    public void set_HeaderUserAgent(StringValues value);
    public StringValues get_HeaderDNT();
    public void set_HeaderDNT(StringValues value);
    public StringValues get_HeaderUpgradeInsecureRequests();
    public void set_HeaderUpgradeInsecureRequests(StringValues value);
    public StringValues get_HeaderRequestId();
    public void set_HeaderRequestId(StringValues value);
    public StringValues get_HeaderCorrelationContext();
    public void set_HeaderCorrelationContext(StringValues value);
    public StringValues get_HeaderTraceParent();
    public void set_HeaderTraceParent(StringValues value);
    public StringValues get_HeaderTraceState();
    public void set_HeaderTraceState(StringValues value);
    public StringValues get_HeaderOrigin();
    public void set_HeaderOrigin(StringValues value);
    public StringValues get_HeaderAccessControlRequestMethod();
    public void set_HeaderAccessControlRequestMethod(StringValues value);
    public StringValues get_HeaderAccessControlRequestHeaders();
    public void set_HeaderAccessControlRequestHeaders(StringValues value);
    public StringValues get_HeaderContentLength();
    public void set_HeaderContentLength(StringValues value);
    protected virtual int GetCountFast();
    protected virtual bool TryGetValueFast(string key, StringValues& value);
    protected virtual void SetValueFast(string key, StringValues value);
    protected virtual bool AddValueFast(string key, StringValues value);
    protected virtual bool RemoveFast(string key);
    private void Clear(long bitsToClear);
    protected virtual bool CopyToFast(KeyValuePair`2[] array, int arrayIndex);
    public void Append(Span`1<byte> name, Span`1<byte> value);
    public void OnHeadersComplete();
    protected virtual void ClearFast();
    private static long ParseContentLength(string value);
    private void AppendContentLength(Span`1<byte> value);
    private void SetValueUnknown(string key, StringValues value);
    private bool AddValueUnknown(string key, StringValues value);
    private void AppendUnknownHeaders(Span`1<byte> name, string valueString);
    public Enumerator GetEnumerator();
    protected virtual IEnumerator`1<KeyValuePair`2<string, StringValues>> GetEnumeratorFast();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestPipeReader : PipeReader {
    private MessageBody _body;
    private HttpStreamState _state;
    private ExceptionDispatchInfo _error;
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual void CancelPendingRead();
    public virtual void Complete(Exception exception);
    public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual bool TryRead(ReadResult& result);
    public void StartAcceptingReads(MessageBody body);
    public void StopAcceptingReads();
    public void Abort(Exception error);
    private void ValidateState(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <ValidateState>g__ThrowObjectDisposedException|13_0();
    [CompilerGeneratedAttribute]
internal static void <ValidateState>g__ThrowTaskCanceledException|13_1();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream : Stream {
    private HttpRequestPipeReader _pipeReader;
    private IHttpBodyControlFeature _bodyControl;
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int WriteTimeout { get; public set; }
    public HttpRequestStream(IHttpBodyControlFeature bodyControl, HttpRequestPipeReader pipeReader);
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    private Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, object state);
    private ValueTask`1<int> ReadAsyncWrapper(Memory`1<byte> destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream/<ReadAsyncInternal>d__30")]
private ValueTask`1<int> ReadAsyncInternal(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream/<CopyToAsyncInternal>d__32")]
private Task CopyToAsyncInternal(Stream destination, CancellationToken cancellationToken);
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestTarget : Enum {
    public int value__;
    public static HttpRequestTarget Unknown;
    public static HttpRequestTarget OriginForm;
    public static HttpRequestTarget AbsoluteForm;
    public static HttpRequestTarget AuthorityForm;
    public static HttpRequestTarget AsteriskForm;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponseHeaders : HttpHeaders {
    private HeaderReferences _headers;
    private static ReadOnlySpan`1<byte> HeaderBytes { get; }
    public bool HasConnection { get; }
    public bool HasDate { get; }
    public bool HasTransferEncoding { get; }
    public bool HasServer { get; }
    public StringValues HeaderCacheControl { get; public set; }
    public StringValues HeaderConnection { get; public set; }
    public StringValues HeaderDate { get; public set; }
    public StringValues HeaderKeepAlive { get; public set; }
    public StringValues HeaderPragma { get; public set; }
    public StringValues HeaderTrailer { get; public set; }
    public StringValues HeaderTransferEncoding { get; public set; }
    public StringValues HeaderUpgrade { get; public set; }
    public StringValues HeaderVia { get; public set; }
    public StringValues HeaderWarning { get; public set; }
    public StringValues HeaderAllow { get; public set; }
    public StringValues HeaderContentType { get; public set; }
    public StringValues HeaderContentEncoding { get; public set; }
    public StringValues HeaderContentLanguage { get; public set; }
    public StringValues HeaderContentLocation { get; public set; }
    public StringValues HeaderContentMD5 { get; public set; }
    public StringValues HeaderContentRange { get; public set; }
    public StringValues HeaderExpires { get; public set; }
    public StringValues HeaderLastModified { get; public set; }
    public StringValues HeaderAcceptRanges { get; public set; }
    public StringValues HeaderAge { get; public set; }
    public StringValues HeaderETag { get; public set; }
    public StringValues HeaderLocation { get; public set; }
    public StringValues HeaderProxyAuthenticate { get; public set; }
    public StringValues HeaderRetryAfter { get; public set; }
    public StringValues HeaderServer { get; public set; }
    public StringValues HeaderSetCookie { get; public set; }
    public StringValues HeaderVary { get; public set; }
    public StringValues HeaderWWWAuthenticate { get; public set; }
    public StringValues HeaderAccessControlAllowCredentials { get; public set; }
    public StringValues HeaderAccessControlAllowHeaders { get; public set; }
    public StringValues HeaderAccessControlAllowMethods { get; public set; }
    public StringValues HeaderAccessControlAllowOrigin { get; public set; }
    public StringValues HeaderAccessControlExposeHeaders { get; public set; }
    public StringValues HeaderAccessControlMaxAge { get; public set; }
    public StringValues HeaderContentLength { get; public set; }
    private static ReadOnlySpan`1<byte> CrLf { get; }
    private static ReadOnlySpan`1<byte> ColonSpace { get; }
    private static ReadOnlySpan`1<byte> get_HeaderBytes();
    public bool get_HasConnection();
    public bool get_HasDate();
    public bool get_HasTransferEncoding();
    public bool get_HasServer();
    public StringValues get_HeaderCacheControl();
    public void set_HeaderCacheControl(StringValues value);
    public StringValues get_HeaderConnection();
    public void set_HeaderConnection(StringValues value);
    public StringValues get_HeaderDate();
    public void set_HeaderDate(StringValues value);
    public StringValues get_HeaderKeepAlive();
    public void set_HeaderKeepAlive(StringValues value);
    public StringValues get_HeaderPragma();
    public void set_HeaderPragma(StringValues value);
    public StringValues get_HeaderTrailer();
    public void set_HeaderTrailer(StringValues value);
    public StringValues get_HeaderTransferEncoding();
    public void set_HeaderTransferEncoding(StringValues value);
    public StringValues get_HeaderUpgrade();
    public void set_HeaderUpgrade(StringValues value);
    public StringValues get_HeaderVia();
    public void set_HeaderVia(StringValues value);
    public StringValues get_HeaderWarning();
    public void set_HeaderWarning(StringValues value);
    public StringValues get_HeaderAllow();
    public void set_HeaderAllow(StringValues value);
    public StringValues get_HeaderContentType();
    public void set_HeaderContentType(StringValues value);
    public StringValues get_HeaderContentEncoding();
    public void set_HeaderContentEncoding(StringValues value);
    public StringValues get_HeaderContentLanguage();
    public void set_HeaderContentLanguage(StringValues value);
    public StringValues get_HeaderContentLocation();
    public void set_HeaderContentLocation(StringValues value);
    public StringValues get_HeaderContentMD5();
    public void set_HeaderContentMD5(StringValues value);
    public StringValues get_HeaderContentRange();
    public void set_HeaderContentRange(StringValues value);
    public StringValues get_HeaderExpires();
    public void set_HeaderExpires(StringValues value);
    public StringValues get_HeaderLastModified();
    public void set_HeaderLastModified(StringValues value);
    public StringValues get_HeaderAcceptRanges();
    public void set_HeaderAcceptRanges(StringValues value);
    public StringValues get_HeaderAge();
    public void set_HeaderAge(StringValues value);
    public StringValues get_HeaderETag();
    public void set_HeaderETag(StringValues value);
    public StringValues get_HeaderLocation();
    public void set_HeaderLocation(StringValues value);
    public StringValues get_HeaderProxyAuthenticate();
    public void set_HeaderProxyAuthenticate(StringValues value);
    public StringValues get_HeaderRetryAfter();
    public void set_HeaderRetryAfter(StringValues value);
    public StringValues get_HeaderServer();
    public void set_HeaderServer(StringValues value);
    public StringValues get_HeaderSetCookie();
    public void set_HeaderSetCookie(StringValues value);
    public StringValues get_HeaderVary();
    public void set_HeaderVary(StringValues value);
    public StringValues get_HeaderWWWAuthenticate();
    public void set_HeaderWWWAuthenticate(StringValues value);
    public StringValues get_HeaderAccessControlAllowCredentials();
    public void set_HeaderAccessControlAllowCredentials(StringValues value);
    public StringValues get_HeaderAccessControlAllowHeaders();
    public void set_HeaderAccessControlAllowHeaders(StringValues value);
    public StringValues get_HeaderAccessControlAllowMethods();
    public void set_HeaderAccessControlAllowMethods(StringValues value);
    public StringValues get_HeaderAccessControlAllowOrigin();
    public void set_HeaderAccessControlAllowOrigin(StringValues value);
    public StringValues get_HeaderAccessControlExposeHeaders();
    public void set_HeaderAccessControlExposeHeaders(StringValues value);
    public StringValues get_HeaderAccessControlMaxAge();
    public void set_HeaderAccessControlMaxAge(StringValues value);
    public StringValues get_HeaderContentLength();
    public void set_HeaderContentLength(StringValues value);
    public void SetRawConnection(StringValues value, Byte[] raw);
    public void SetRawDate(StringValues value, Byte[] raw);
    public void SetRawTransferEncoding(StringValues value, Byte[] raw);
    public void SetRawServer(StringValues value, Byte[] raw);
    protected virtual int GetCountFast();
    protected virtual bool TryGetValueFast(string key, StringValues& value);
    protected virtual void SetValueFast(string key, StringValues value);
    protected virtual bool AddValueFast(string key, StringValues value);
    protected virtual bool RemoveFast(string key);
    protected virtual void ClearFast();
    protected virtual bool CopyToFast(KeyValuePair`2[] array, int arrayIndex);
    internal void CopyToFast(BufferWriter`1& output);
    private static ReadOnlySpan`1<byte> get_CrLf();
    private static ReadOnlySpan`1<byte> get_ColonSpace();
    public Enumerator GetEnumerator();
    protected virtual IEnumerator`1<KeyValuePair`2<string, StringValues>> GetEnumeratorFast();
    internal void CopyTo(BufferWriter`1& buffer);
    private static long ParseContentLength(string value);
    private static void ThrowInvalidContentLengthException(string value);
    private void SetValueUnknown(string key, StringValues value);
    private bool AddValueUnknown(string key, StringValues value);
    [CompilerGeneratedAttribute]
internal static void <CopyTo>g__CopyExtraHeaders|139_0(BufferWriter`1& buffer, Dictionary`2<string, StringValues> headers);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponsePipeWriter : PipeWriter {
    private IHttpResponseControl _pipeControl;
    private HttpStreamState _state;
    private Task _completeTask;
    public HttpResponsePipeWriter(IHttpResponseControl pipeControl);
    public virtual void Advance(int bytes);
    public virtual void CancelPendingFlush();
    public virtual void Complete(Exception exception);
    public virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public virtual Memory`1<byte> GetMemory(int sizeHint);
    public virtual Span`1<byte> GetSpan(int sizeHint);
    public virtual ValueTask`1<FlushResult> WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public void StartAcceptingWrites();
    public Task StopAcceptingWritesAsync();
    public void Abort();
    private void ValidateState(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <ValidateState>g__ThrowObjectDisposedException|14_0();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponseStream : Stream {
    private HttpResponsePipeWriter _pipeWriter;
    private IHttpBodyControlFeature _bodyControl;
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public HttpResponseStream(IHttpBodyControlFeature bodyControl, HttpResponsePipeWriter pipeWriter);
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, object state);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    private Task WriteAsyncInternal(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponseTrailers : HttpHeaders {
    private HeaderReferences _headers;
    private static ReadOnlySpan`1<byte> HeaderBytes { get; }
    public StringValues HeaderETag { get; public set; }
    private static ReadOnlySpan`1<byte> get_HeaderBytes();
    public StringValues get_HeaderETag();
    public void set_HeaderETag(StringValues value);
    protected virtual int GetCountFast();
    protected virtual bool TryGetValueFast(string key, StringValues& value);
    protected virtual void SetValueFast(string key, StringValues value);
    protected virtual bool AddValueFast(string key, StringValues value);
    protected virtual bool RemoveFast(string key);
    protected virtual void ClearFast();
    protected virtual bool CopyToFast(KeyValuePair`2[] array, int arrayIndex);
    public Enumerator GetEnumerator();
    protected virtual IEnumerator`1<KeyValuePair`2<string, StringValues>> GetEnumeratorFast();
    private void SetValueUnknown(string key, StringValues value);
    private bool AddValueUnknown(string key, StringValues value);
}
public enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme : Enum {
    public int value__;
    public static HttpScheme Unknown;
    public static HttpScheme Http;
    public static HttpScheme Https;
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpStreamState : Enum {
    public int value__;
    public static HttpStreamState Open;
    public static HttpStreamState Closed;
    public static HttpStreamState Aborted;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpUpgradeStream : Stream {
    private Stream _requestStream;
    private Stream _responseStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public HttpUpgradeStream(Stream requestStream, Stream responseStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Close();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion : Enum {
    public int value__;
    public static HttpVersion Unknown;
    public static HttpVersion Http10;
    public static HttpVersion Http11;
    public static HttpVersion Http2;
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpHeadersHandler {
    public abstract virtual void OnHeader(Span`1<byte> name, Span`1<byte> value);
    public abstract virtual void OnHeadersComplete();
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputAborter {
    public abstract virtual void Abort(ConnectionAbortedException abortReason);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputProducer {
    public abstract virtual ValueTask`1<FlushResult> WriteChunkAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> Write100ContinueAsync();
    public abstract virtual void WriteResponseHeaders(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, bool appCompleted);
    public abstract virtual ValueTask`1<FlushResult> WriteDataToPipeAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public abstract virtual Task WriteDataAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> WriteStreamSuffixAsync();
    public abstract virtual void Advance(int bytes);
    public abstract virtual Span`1<byte> GetSpan(int sizeHint);
    public abstract virtual Memory`1<byte> GetMemory(int sizeHint);
    public abstract virtual void CancelPendingFlush();
    public abstract virtual void Stop();
    public abstract virtual ValueTask`1<FlushResult> FirstWriteAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> FirstWriteChunkedAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public abstract virtual void Reset();
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpParser`1 {
    public abstract virtual bool ParseRequestLine(TRequestHandler handler, ReadOnlySequence`1& modreq(System.Runtime.InteropServices.InAttribute) buffer, SequencePosition& consumed, SequencePosition& examined);
    public abstract virtual bool ParseHeaders(TRequestHandler handler, SequenceReader`1& reader);
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpRequestLineHandler {
    public abstract virtual void OnStartLine(HttpMethod method, HttpVersion version, Span`1<byte> target, Span`1<byte> path, Span`1<byte> query, Span`1<byte> customMethod, bool pathEncoded);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpResponseControl {
    public abstract virtual void ProduceContinue();
    public abstract virtual Memory`1<byte> GetMemory(int sizeHint);
    public abstract virtual Span`1<byte> GetSpan(int sizeHint);
    public abstract virtual void Advance(int bytes);
    public abstract virtual ValueTask`1<FlushResult> FlushPipeAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> WritePipeAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public abstract virtual void CancelPendingFlush();
    public abstract virtual Task CompleteAsync(Exception exception);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpResponsePipeWriterControl {
    public abstract virtual void ProduceContinue();
    public abstract virtual Memory`1<byte> GetMemory(int sizeHint);
    public abstract virtual Span`1<byte> GetSpan(int sizeHint);
    public abstract virtual void Advance(int bytes);
    public abstract virtual ValueTask`1<FlushResult> FlushPipeAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> WritePipeAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public abstract virtual void CancelPendingFlush();
}
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.MessageBody : object {
    private static MessageBody _zeroContentLengthClose;
    private static MessageBody _zeroContentLengthKeepAlive;
    private HttpProtocol _context;
    private bool _send100Continue;
    private long _consumedBytes;
    private bool _stopped;
    protected bool _timingEnabled;
    protected bool _backpressure;
    protected long _alreadyTimedBytes;
    protected long _examinedUnconsumedBytes;
    [CompilerGeneratedAttribute]
private bool <RequestKeepAlive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestUpgrade>k__BackingField;
    public static MessageBody ZeroContentLengthClose { get; }
    public static MessageBody ZeroContentLengthKeepAlive { get; }
    public bool RequestKeepAlive { get; protected set; }
    public bool RequestUpgrade { get; protected set; }
    public bool IsEmpty { get; }
    protected IKestrelTrace Log { get; }
    protected MessageBody(HttpProtocol context);
    private static MessageBody();
    public static MessageBody get_ZeroContentLengthClose();
    public static MessageBody get_ZeroContentLengthKeepAlive();
    [CompilerGeneratedAttribute]
public bool get_RequestKeepAlive();
    [CompilerGeneratedAttribute]
protected void set_RequestKeepAlive(bool value);
    [CompilerGeneratedAttribute]
public bool get_RequestUpgrade();
    [CompilerGeneratedAttribute]
protected void set_RequestUpgrade(bool value);
    public virtual bool get_IsEmpty();
    protected IKestrelTrace get_Log();
    public abstract virtual void AdvanceTo(SequencePosition consumed);
    public abstract virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public abstract virtual bool TryRead(ReadResult& readResult);
    public abstract virtual void Complete(Exception exception);
    public abstract virtual void CancelPendingRead();
    public abstract virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual Task ConsumeAsync();
    public virtual Task StopAsync();
    protected virtual Task OnConsumeAsync();
    protected virtual Task OnStopAsync();
    protected void TryProduceContinue();
    protected void TryStart();
    protected void TryStop();
    protected virtual void OnReadStarting();
    protected virtual void OnReadStarted();
    protected virtual void OnDataRead(long bytesRead);
    protected void AddAndCheckConsumedBytes(long consumedBytes);
    protected ValueTask`1<ReadResult> StartTimingReadAsync(ValueTask`1<ReadResult> readAwaitable, CancellationToken cancellationToken);
    protected void CountBytesRead(long bytesInReadResult);
    protected void StopTimingRead(long bytesInReadResult);
    protected long OnAdvance(ReadResult readResult, SequencePosition consumed, SequencePosition examined);
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.PathNormalizer : object {
    private static byte ByteSlash;
    private static byte ByteDot;
    public static string DecodePath(Span`1<byte> path, bool pathEncoded, string rawTarget, int queryLength);
    public static int RemoveDotSegments(Span`1<byte> input);
    public static int RemoveDotSegments(Byte* start, Byte* end);
    public static bool ContainsDotSegments(Byte* start, Byte* end);
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.ProduceEndType : Enum {
    public int value__;
    public static ProduceEndType SocketShutdown;
    public static ProduceEndType SocketDisconnect;
    public static ProduceEndType ConnectionKeepAlive;
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.ReasonPhrases : object {
    private static Byte[] _bytesStatus100;
    private static Byte[] _bytesStatus101;
    private static Byte[] _bytesStatus102;
    private static Byte[] _bytesStatus200;
    private static Byte[] _bytesStatus201;
    private static Byte[] _bytesStatus202;
    private static Byte[] _bytesStatus203;
    private static Byte[] _bytesStatus204;
    private static Byte[] _bytesStatus205;
    private static Byte[] _bytesStatus206;
    private static Byte[] _bytesStatus207;
    private static Byte[] _bytesStatus208;
    private static Byte[] _bytesStatus226;
    private static Byte[] _bytesStatus300;
    private static Byte[] _bytesStatus301;
    private static Byte[] _bytesStatus302;
    private static Byte[] _bytesStatus303;
    private static Byte[] _bytesStatus304;
    private static Byte[] _bytesStatus305;
    private static Byte[] _bytesStatus306;
    private static Byte[] _bytesStatus307;
    private static Byte[] _bytesStatus308;
    private static Byte[] _bytesStatus400;
    private static Byte[] _bytesStatus401;
    private static Byte[] _bytesStatus402;
    private static Byte[] _bytesStatus403;
    private static Byte[] _bytesStatus404;
    private static Byte[] _bytesStatus405;
    private static Byte[] _bytesStatus406;
    private static Byte[] _bytesStatus407;
    private static Byte[] _bytesStatus408;
    private static Byte[] _bytesStatus409;
    private static Byte[] _bytesStatus410;
    private static Byte[] _bytesStatus411;
    private static Byte[] _bytesStatus412;
    private static Byte[] _bytesStatus413;
    private static Byte[] _bytesStatus414;
    private static Byte[] _bytesStatus415;
    private static Byte[] _bytesStatus416;
    private static Byte[] _bytesStatus417;
    private static Byte[] _bytesStatus418;
    private static Byte[] _bytesStatus419;
    private static Byte[] _bytesStatus421;
    private static Byte[] _bytesStatus422;
    private static Byte[] _bytesStatus423;
    private static Byte[] _bytesStatus424;
    private static Byte[] _bytesStatus426;
    private static Byte[] _bytesStatus428;
    private static Byte[] _bytesStatus429;
    private static Byte[] _bytesStatus431;
    private static Byte[] _bytesStatus451;
    private static Byte[] _bytesStatus500;
    private static Byte[] _bytesStatus501;
    private static Byte[] _bytesStatus502;
    private static Byte[] _bytesStatus503;
    private static Byte[] _bytesStatus504;
    private static Byte[] _bytesStatus505;
    private static Byte[] _bytesStatus506;
    private static Byte[] _bytesStatus507;
    private static Byte[] _bytesStatus508;
    private static Byte[] _bytesStatus510;
    private static Byte[] _bytesStatus511;
    private static ReasonPhrases();
    private static Byte[] CreateStatusBytes(int statusCode);
    public static Byte[] ToStatusBytes(int statusCode, string reasonPhrase);
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.RequestProcessingStatus : Enum {
    public int value__;
    public static RequestProcessingStatus RequestPending;
    public static RequestProcessingStatus ParsingRequestLine;
    public static RequestProcessingStatus ParsingHeaders;
    public static RequestProcessingStatus AppStarted;
    public static RequestProcessingStatus HeadersCommitted;
    public static RequestProcessingStatus HeadersFlushed;
    public static RequestProcessingStatus ResponseCompleted;
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.RequestRejectionReason : Enum {
    public int value__;
    public static RequestRejectionReason UnrecognizedHTTPVersion;
    public static RequestRejectionReason InvalidRequestLine;
    public static RequestRejectionReason InvalidRequestHeader;
    public static RequestRejectionReason InvalidRequestHeadersNoCRLF;
    public static RequestRejectionReason MalformedRequestInvalidHeaders;
    public static RequestRejectionReason InvalidContentLength;
    public static RequestRejectionReason MultipleContentLengths;
    public static RequestRejectionReason UnexpectedEndOfRequestContent;
    public static RequestRejectionReason BadChunkSuffix;
    public static RequestRejectionReason BadChunkSizeData;
    public static RequestRejectionReason ChunkedRequestIncomplete;
    public static RequestRejectionReason InvalidRequestTarget;
    public static RequestRejectionReason InvalidCharactersInHeaderName;
    public static RequestRejectionReason RequestLineTooLong;
    public static RequestRejectionReason HeadersExceedMaxTotalSize;
    public static RequestRejectionReason TooManyHeaders;
    public static RequestRejectionReason RequestBodyTooLarge;
    public static RequestRejectionReason RequestHeadersTimeout;
    public static RequestRejectionReason RequestBodyTimeout;
    public static RequestRejectionReason FinalTransferCodingNotChunked;
    public static RequestRejectionReason LengthRequired;
    public static RequestRejectionReason LengthRequiredHttp10;
    public static RequestRejectionReason OptionsMethodRequired;
    public static RequestRejectionReason ConnectMethodRequired;
    public static RequestRejectionReason MissingHostHeader;
    public static RequestRejectionReason MultipleHostHeaders;
    public static RequestRejectionReason InvalidHostHeader;
    public static RequestRejectionReason RequestBodyExceedsContentLength;
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.TransferCoding : Enum {
    public int value__;
    public static TransferCoding None;
    public static TransferCoding Chunked;
    public static TransferCoding Other;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.ZeroContentLengthMessageBody : MessageBody {
    public bool IsEmpty { get; }
    public ZeroContentLengthMessageBody(bool keepAlive);
    public virtual bool get_IsEmpty();
    public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual Task ConsumeAsync();
    public virtual Task StopAsync();
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual bool TryRead(ReadResult& result);
    public virtual void Complete(Exception ex);
    public virtual void CancelPendingRead();
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Bitshifter : object {
    public static UInt32 ReadUInt24BigEndian(ReadOnlySpan`1<byte> source);
    public static void WriteUInt24BigEndian(Span`1<byte> destination, UInt32 value);
    public static UInt32 ReadUInt31BigEndian(ReadOnlySpan`1<byte> source);
    public static void WriteUInt31BigEndian(Span`1<byte> destination, UInt32 value);
    public static void WriteUInt31BigEndian(Span`1<byte> destination, UInt32 value, bool preserveHighestBit);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.FlowControl.FlowControl : ValueType {
    [CompilerGeneratedAttribute]
private int <Available>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAborted>k__BackingField;
    public int Available { get; private set; }
    public bool IsAborted { get; private set; }
    public FlowControl(UInt32 initialWindowSize);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Available();
    [CompilerGeneratedAttribute]
private void set_Available(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsAborted();
    [CompilerGeneratedAttribute]
private void set_IsAborted(bool value);
    public void Advance(int bytes);
    public bool TryUpdateWindow(int bytes);
    public void Abort();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.FlowControl.InputFlowControl : object {
    private int _initialWindowSize;
    private int _minWindowSizeIncrement;
    private FlowControl _flow;
    private int _pendingUpdateSize;
    private bool _windowUpdatesDisabled;
    private object _flowLock;
    public bool IsAvailabilityLow { get; }
    public InputFlowControl(UInt32 initialWindowSize, UInt32 minWindowSizeIncrement);
    public bool get_IsAvailabilityLow();
    public bool TryAdvance(int bytes);
    public bool TryUpdateWindow(int bytes, Int32& updateSize);
    public void StopWindowUpdates();
    public int Abort();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.FlowControl.OutputFlowControl : object {
    private FlowControl _flow;
    private Queue`1<OutputFlowControlAwaitable> _awaitableQueue;
    public int Available { get; }
    public bool IsAborted { get; }
    public OutputFlowControlAwaitable AvailabilityAwaitable { get; }
    public OutputFlowControl(UInt32 initialWindowSize);
    public int get_Available();
    public bool get_IsAborted();
    public OutputFlowControlAwaitable get_AvailabilityAwaitable();
    public void Advance(int bytes);
    public bool TryUpdateWindow(int bytes);
    public void Abort();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.FlowControl.OutputFlowControlAwaitable : object {
    private static Action _callbackCompleted;
    private Action _callback;
    public bool IsCompleted { get; }
    private static OutputFlowControlAwaitable();
    public OutputFlowControlAwaitable GetAwaiter();
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    public void Complete();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.FlowControl.StreamInputFlowControl : object {
    private InputFlowControl _connectionLevelFlowControl;
    private InputFlowControl _streamLevelFlowControl;
    private int _streamId;
    private Http2FrameWriter _frameWriter;
    public StreamInputFlowControl(int streamId, Http2FrameWriter frameWriter, InputFlowControl connectionLevelFlowControl, UInt32 initialWindowSize, UInt32 minWindowSizeIncrement);
    public void Advance(int bytes);
    public void UpdateWindows(int bytes);
    public void StopWindowUpdates();
    public void Abort();
    private void UpdateConnectionWindow(int bytes);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.FlowControl.StreamOutputFlowControl : object {
    private OutputFlowControl _connectionLevelFlowControl;
    private OutputFlowControl _streamLevelFlowControl;
    private OutputFlowControlAwaitable _currentConnectionLevelAwaitable;
    public int Available { get; }
    public bool IsAborted { get; }
    public StreamOutputFlowControl(OutputFlowControl connectionLevelFlowControl, UInt32 initialWindowSize);
    public int get_Available();
    public bool get_IsAborted();
    public void Advance(int bytes);
    public int AdvanceUpToAndWait(long bytes, OutputFlowControlAwaitable& awaitable);
    public bool TryUpdateWindow(int bytes);
    public void Abort();
    private static int Clamp(int value, int min, long max);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.DynamicTable : object {
    private HeaderField[] _buffer;
    private int _maxSize;
    private int _size;
    private int _count;
    private int _insertIndex;
    private int _removeIndex;
    public int Count { get; }
    public int Size { get; }
    public int MaxSize { get; }
    public HeaderField Item { get; }
    public DynamicTable(int maxSize);
    public int get_Count();
    public int get_Size();
    public int get_MaxSize();
    public HeaderField get_Item(int index);
    public void Insert(Span`1<byte> name, Span`1<byte> value);
    public void Resize(int maxSize);
    private void EnsureAvailable(int available);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.HeaderField : ValueType {
    public static int RfcOverhead;
    [CompilerGeneratedAttribute]
private Byte[] <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Name { get; }
    public Byte[] Value { get; }
    public int Length { get; }
    public HeaderField(Span`1<byte> name, Span`1<byte> value);
    [CompilerGeneratedAttribute]
public Byte[] get_Name();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    public int get_Length();
    public static int GetLength(int nameLength, int valueLength);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.HPackDecoder : object {
    private static byte IndexedHeaderFieldMask;
    private static byte IndexedHeaderFieldRepresentation;
    private static byte LiteralHeaderFieldWithIncrementalIndexingMask;
    private static byte LiteralHeaderFieldWithIncrementalIndexingRepresentation;
    private static byte LiteralHeaderFieldWithoutIndexingMask;
    private static byte LiteralHeaderFieldWithoutIndexingRepresentation;
    private static byte LiteralHeaderFieldNeverIndexedMask;
    private static byte LiteralHeaderFieldNeverIndexedRepresentation;
    private static byte DynamicTableSizeUpdateMask;
    private static byte DynamicTableSizeUpdateRepresentation;
    private static byte HuffmanMask;
    private static int IndexedHeaderFieldPrefix;
    private static int LiteralHeaderFieldWithIncrementalIndexingPrefix;
    private static int LiteralHeaderFieldWithoutIndexingPrefix;
    private static int LiteralHeaderFieldNeverIndexedPrefix;
    private static int DynamicTableSizeUpdatePrefix;
    private static int StringLengthPrefix;
    private int _maxDynamicTableSize;
    private DynamicTable _dynamicTable;
    private IntegerDecoder _integerDecoder;
    private Byte[] _stringOctets;
    private Byte[] _headerNameOctets;
    private Byte[] _headerValueOctets;
    private State _state;
    private Byte[] _headerName;
    private int _stringIndex;
    private int _stringLength;
    private int _headerNameLength;
    private int _headerValueLength;
    private bool _index;
    private bool _huffman;
    private bool _headersObserved;
    public HPackDecoder(int maxDynamicTableSize, int maxRequestHeaderFieldSize);
    internal HPackDecoder(int maxDynamicTableSize, int maxRequestHeaderFieldSize, DynamicTable dynamicTable);
    public void Decode(ReadOnlySequence`1& data, bool endHeaders, IHttpHeadersHandler handler);
    private void OnByte(byte b, IHttpHeadersHandler handler);
    private void ProcessHeaderValue(IHttpHeadersHandler handler);
    private void OnIndexedHeaderField(int index, IHttpHeadersHandler handler);
    private void OnIndexedHeaderName(int index);
    private void OnStringLength(int length, State nextState);
    private void OnString(State nextState);
    private HeaderField GetHeader(int index);
    private void SetDynamicHeaderTableSize(int size);
    [CompilerGeneratedAttribute]
private int <OnString>g__Decode|41_0(Byte[] dst);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.HPackDecodingException : Exception {
    public HPackDecodingException(string message);
    public HPackDecodingException(string message, Exception innerException);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.HPackEncoder : object {
    private IEnumerator`1<KeyValuePair`2<string, string>> _enumerator;
    public bool BeginEncode(IEnumerable`1<KeyValuePair`2<string, string>> headers, Span`1<byte> buffer, Int32& length);
    public bool BeginEncode(int statusCode, IEnumerable`1<KeyValuePair`2<string, string>> headers, Span`1<byte> buffer, Int32& length);
    public bool Encode(Span`1<byte> buffer, Int32& length);
    private bool Encode(Span`1<byte> buffer, bool throwIfNoneEncoded, Int32& length);
    private int EncodeStatusCode(int statusCode, Span`1<byte> buffer);
    private bool EncodeHeader(string name, string value, Span`1<byte> buffer, Int32& length);
    private bool EncodeString(string s, Span`1<byte> buffer, Int32& length, bool lowercase);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.HPackEncodingException : Exception {
    public HPackEncodingException(string message);
    public HPackEncodingException(string message, Exception innerException);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.Huffman : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2[] _encodingTable;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2[] _decodingTable;
    private static Huffman();
    public static ValueTuple`2<UInt32, int> Encode(int data);
    public static int Decode(ReadOnlySpan`1<byte> src, Span`1<byte> dst);
    internal static int DecodeValue(UInt32 data, int validBits, Int32& decodedBits);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.HuffmanDecodingException : Exception {
    public HuffmanDecodingException(string message);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.IntegerDecoder : object {
    private int _i;
    private int _m;
    public bool BeginTryDecode(byte b, int prefixLength, Int32& result);
    public bool TryDecode(byte b, Int32& result);
    public static void ThrowIntegerTooBigException();
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.IntegerEncoder : object {
    public static bool Encode(int i, int n, Span`1<byte> buffer, Int32& length);
    private static byte MaskHigh(int n);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.StaticTable : object {
    private static StaticTable _instance;
    private Dictionary`2<int, int> _statusIndex;
    private HeaderField[] _staticTable;
    public static StaticTable Instance { get; }
    public int Count { get; }
    public HeaderField Item { get; }
    public IReadOnlyDictionary`2<int, int> StatusIndex { get; }
    private static StaticTable();
    public static StaticTable get_Instance();
    public int get_Count();
    public HeaderField get_Item(int index);
    public IReadOnlyDictionary`2<int, int> get_StatusIndex();
    private static HeaderField CreateHeaderField(string name, string value);
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPack.StatusCodes : object {
    private static Byte[] _bytesStatus100;
    private static Byte[] _bytesStatus101;
    private static Byte[] _bytesStatus102;
    private static Byte[] _bytesStatus200;
    private static Byte[] _bytesStatus201;
    private static Byte[] _bytesStatus202;
    private static Byte[] _bytesStatus203;
    private static Byte[] _bytesStatus204;
    private static Byte[] _bytesStatus205;
    private static Byte[] _bytesStatus206;
    private static Byte[] _bytesStatus207;
    private static Byte[] _bytesStatus208;
    private static Byte[] _bytesStatus226;
    private static Byte[] _bytesStatus300;
    private static Byte[] _bytesStatus301;
    private static Byte[] _bytesStatus302;
    private static Byte[] _bytesStatus303;
    private static Byte[] _bytesStatus304;
    private static Byte[] _bytesStatus305;
    private static Byte[] _bytesStatus306;
    private static Byte[] _bytesStatus307;
    private static Byte[] _bytesStatus308;
    private static Byte[] _bytesStatus400;
    private static Byte[] _bytesStatus401;
    private static Byte[] _bytesStatus402;
    private static Byte[] _bytesStatus403;
    private static Byte[] _bytesStatus404;
    private static Byte[] _bytesStatus405;
    private static Byte[] _bytesStatus406;
    private static Byte[] _bytesStatus407;
    private static Byte[] _bytesStatus408;
    private static Byte[] _bytesStatus409;
    private static Byte[] _bytesStatus410;
    private static Byte[] _bytesStatus411;
    private static Byte[] _bytesStatus412;
    private static Byte[] _bytesStatus413;
    private static Byte[] _bytesStatus414;
    private static Byte[] _bytesStatus415;
    private static Byte[] _bytesStatus416;
    private static Byte[] _bytesStatus417;
    private static Byte[] _bytesStatus418;
    private static Byte[] _bytesStatus419;
    private static Byte[] _bytesStatus421;
    private static Byte[] _bytesStatus422;
    private static Byte[] _bytesStatus423;
    private static Byte[] _bytesStatus424;
    private static Byte[] _bytesStatus426;
    private static Byte[] _bytesStatus428;
    private static Byte[] _bytesStatus429;
    private static Byte[] _bytesStatus431;
    private static Byte[] _bytesStatus451;
    private static Byte[] _bytesStatus500;
    private static Byte[] _bytesStatus501;
    private static Byte[] _bytesStatus502;
    private static Byte[] _bytesStatus503;
    private static Byte[] _bytesStatus504;
    private static Byte[] _bytesStatus505;
    private static Byte[] _bytesStatus506;
    private static Byte[] _bytesStatus507;
    private static Byte[] _bytesStatus508;
    private static Byte[] _bytesStatus510;
    private static Byte[] _bytesStatus511;
    private static StatusCodes();
    private static Byte[] CreateStatusBytes(int statusCode);
    public static Byte[] ToStatusBytes(int statusCode);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection : object {
    [CompilerGeneratedAttribute]
private static Byte[] <ClientPreface>k__BackingField;
    private static PseudoHeaderFields _mandatoryRequestPseudoHeaderFields;
    private static Byte[] _authorityBytes;
    private static Byte[] _methodBytes;
    private static Byte[] _pathBytes;
    private static Byte[] _schemeBytes;
    private static Byte[] _statusBytes;
    private static Byte[] _connectionBytes;
    private static Byte[] _teBytes;
    private static Byte[] _trailersBytes;
    private static Byte[] _connectBytes;
    private HttpConnectionContext _context;
    private Http2FrameWriter _frameWriter;
    private Pipe _input;
    private Task _inputTask;
    private int _minAllocBufferSize;
    private HPackDecoder _hpackDecoder;
    private InputFlowControl _inputFlowControl;
    private OutputFlowControl _outputFlowControl;
    private Http2PeerSettings _serverSettings;
    private Http2PeerSettings _clientSettings;
    private Http2Frame _incomingFrame;
    private Http2Stream _currentHeadersStream;
    private RequestHeaderParsingState _requestHeaderParsingState;
    private PseudoHeaderFields _parsedPseudoHeaderFields;
    private Http2HeadersFrameFlags _headerFlags;
    private int _totalParsedHeaderSize;
    private bool _isMethodConnect;
    private int _highestOpenedStreamId;
    private bool _gracefulCloseStarted;
    private Dictionary`2<int, Http2Stream> _streams;
    private int _clientActiveStreamCount;
    private int _serverActiveStreamCount;
    private ConcurrentQueue`1<Http2Stream> _completedStreams;
    private StreamCloseAwaitable _streamCompletionAwaitable;
    private int _gracefulCloseInitiator;
    private int _isClosed;
    public static Byte[] ClientPreface { get; }
    public string ConnectionId { get; }
    public PipeReader Input { get; }
    public IKestrelTrace Log { get; }
    public IFeatureCollection ConnectionFeatures { get; }
    public ISystemClock SystemClock { get; }
    public ITimeoutControl TimeoutControl { get; }
    public KestrelServerLimits Limits { get; }
    internal Http2PeerSettings ServerSettings { get; }
    public Http2Connection(HttpConnectionContext context);
    private static Http2Connection();
    [CompilerGeneratedAttribute]
public static Byte[] get_ClientPreface();
    public string get_ConnectionId();
    public PipeReader get_Input();
    public IKestrelTrace get_Log();
    public IFeatureCollection get_ConnectionFeatures();
    public ISystemClock get_SystemClock();
    public ITimeoutControl get_TimeoutControl();
    public KestrelServerLimits get_Limits();
    internal Http2PeerSettings get_ServerSettings();
    public sealed virtual void OnInputOrOutputCompleted();
    public sealed virtual void Abort(ConnectionAbortedException ex);
    public sealed virtual void StopProcessingNextRequest();
    public sealed virtual void HandleRequestHeadersTimeout();
    public sealed virtual void HandleReadDataRateTimeout();
    public void StopProcessingNextRequest(bool serverInitiated);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection/<ProcessRequestsAsync>d__62`1")]
public sealed virtual Task ProcessRequestsAsync(IHttpApplication`1<TContext> application);
    private void ValidateTlsRequirements();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection/<TryReadPrefaceAsync>d__64")]
private Task`1<bool> TryReadPrefaceAsync();
    private bool ParsePreface(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    private Task ProcessFrameAsync(IHttpApplication`1<TContext> application, ReadOnlySequence`1& payload);
    private Task ProcessDataFrameAsync(ReadOnlySequence`1& payload);
    private Task ProcessHeadersFrameAsync(IHttpApplication`1<TContext> application, ReadOnlySequence`1& payload);
    private Task ProcessPriorityFrameAsync();
    private Task ProcessRstStreamFrameAsync();
    private Task ProcessSettingsFrameAsync(ReadOnlySequence`1& payload);
    private Task ProcessPingFrameAsync(ReadOnlySequence`1& payload);
    private Task ProcessGoAwayFrameAsync();
    private Task ProcessWindowUpdateFrameAsync();
    private Task ProcessContinuationFrameAsync(ReadOnlySequence`1& payload);
    private Task ProcessUnknownFrameAsync();
    private Task DecodeHeadersAsync(bool endHeaders, ReadOnlySequence`1& payload);
    private Task DecodeTrailersAsync(bool endHeaders, ReadOnlySequence`1& payload);
    private void StartStream();
    private void ResetRequestHeaderParsingState();
    private void ThrowIfIncomingFrameSentToIdleStream();
    private void AbortStream(int streamId, IOException error);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.IRequestProcessor.Tick(DateTimeOffset now);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.IHttp2StreamLifetimeHandler.OnStreamCompleted(Http2Stream stream);
    private void UpdateCompletedStreams();
    private void UpdateConnectionState();
    public sealed virtual void OnHeader(Span`1<byte> name, Span`1<byte> value);
    public sealed virtual void OnHeadersComplete();
    private void ValidateHeader(Span`1<byte> name, Span`1<byte> value);
    private bool IsPseudoHeaderField(Span`1<byte> name, PseudoHeaderFields& headerField);
    private static bool IsConnectionSpecificHeaderField(Span`1<byte> name, Span`1<byte> value);
    private bool TryClose();
    public void IncrementActiveClientStreamCount();
    public sealed virtual void DecrementActiveClientStreamCount();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection/<ReadInputAsync>d__95")]
private Task ReadInputAsync();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2ConnectionErrorException : Exception {
    [CompilerGeneratedAttribute]
private Http2ErrorCode <ErrorCode>k__BackingField;
    public Http2ErrorCode ErrorCode { get; }
    public Http2ConnectionErrorException(string message, Http2ErrorCode errorCode);
    [CompilerGeneratedAttribute]
public Http2ErrorCode get_ErrorCode();
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2ContinuationFrameFlags : Enum {
    public byte value__;
    public static Http2ContinuationFrameFlags NONE;
    public static Http2ContinuationFrameFlags END_HEADERS;
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2DataFrameFlags : Enum {
    public byte value__;
    public static Http2DataFrameFlags NONE;
    public static Http2DataFrameFlags END_STREAM;
    public static Http2DataFrameFlags PADDED;
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2ErrorCode : Enum {
    public UInt32 value__;
    public static Http2ErrorCode NO_ERROR;
    public static Http2ErrorCode PROTOCOL_ERROR;
    public static Http2ErrorCode INTERNAL_ERROR;
    public static Http2ErrorCode FLOW_CONTROL_ERROR;
    public static Http2ErrorCode SETTINGS_TIMEOUT;
    public static Http2ErrorCode STREAM_CLOSED;
    public static Http2ErrorCode FRAME_SIZE_ERROR;
    public static Http2ErrorCode REFUSED_STREAM;
    public static Http2ErrorCode CANCEL;
    public static Http2ErrorCode COMPRESSION_ERROR;
    public static Http2ErrorCode CONNECT_ERROR;
    public static Http2ErrorCode ENHANCE_YOUR_CALM;
    public static Http2ErrorCode INADEQUATE_SECURITY;
    public static Http2ErrorCode HTTP_1_1_REQUIRED;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Frame : object {
    [CompilerGeneratedAttribute]
private int <PayloadLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2FrameType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <DataPadLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GoAwayLastStreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2ErrorCode <GoAwayErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <HeadersPadLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeadersStreamDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <HeadersPriorityWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PriorityStreamDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PriorityIsExclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <PriorityWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2ErrorCode <RstStreamErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WindowUpdateSizeIncrement>k__BackingField;
    public Http2ContinuationFrameFlags ContinuationFlags { get; public set; }
    public bool ContinuationEndHeaders { get; }
    public int PayloadLength { get; public set; }
    public Http2FrameType Type { get; public set; }
    public byte Flags { get; public set; }
    public int StreamId { get; public set; }
    public Http2DataFrameFlags DataFlags { get; public set; }
    public bool DataEndStream { get; }
    public bool DataHasPadding { get; }
    public byte DataPadLength { get; public set; }
    private int DataPayloadOffset { get; }
    public int DataPayloadLength { get; }
    public int GoAwayLastStreamId { get; public set; }
    public Http2ErrorCode GoAwayErrorCode { get; public set; }
    public Http2HeadersFrameFlags HeadersFlags { get; public set; }
    public bool HeadersEndHeaders { get; }
    public bool HeadersEndStream { get; }
    public bool HeadersHasPadding { get; }
    public bool HeadersHasPriority { get; }
    public byte HeadersPadLength { get; public set; }
    public int HeadersStreamDependency { get; public set; }
    public byte HeadersPriorityWeight { get; public set; }
    private int HeadersPayloadOffset { get; }
    public int HeadersPayloadLength { get; }
    public Http2PingFrameFlags PingFlags { get; public set; }
    public bool PingAck { get; }
    public int PriorityStreamDependency { get; public set; }
    public bool PriorityIsExclusive { get; public set; }
    public byte PriorityWeight { get; public set; }
    public Http2ErrorCode RstStreamErrorCode { get; public set; }
    public Http2SettingsFrameFlags SettingsFlags { get; public set; }
    public bool SettingsAck { get; }
    public int WindowUpdateSizeIncrement { get; public set; }
    public Http2ContinuationFrameFlags get_ContinuationFlags();
    public void set_ContinuationFlags(Http2ContinuationFrameFlags value);
    public bool get_ContinuationEndHeaders();
    public void PrepareContinuation(Http2ContinuationFrameFlags flags, int streamId);
    [CompilerGeneratedAttribute]
public int get_PayloadLength();
    [CompilerGeneratedAttribute]
public void set_PayloadLength(int value);
    [CompilerGeneratedAttribute]
public Http2FrameType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Http2FrameType value);
    [CompilerGeneratedAttribute]
public byte get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(byte value);
    [CompilerGeneratedAttribute]
public int get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(int value);
    internal object ShowFlags();
    public virtual string ToString();
    public Http2DataFrameFlags get_DataFlags();
    public void set_DataFlags(Http2DataFrameFlags value);
    public bool get_DataEndStream();
    public bool get_DataHasPadding();
    [CompilerGeneratedAttribute]
public byte get_DataPadLength();
    [CompilerGeneratedAttribute]
public void set_DataPadLength(byte value);
    private int get_DataPayloadOffset();
    public int get_DataPayloadLength();
    public void PrepareData(int streamId, Nullable`1<byte> padLength);
    [CompilerGeneratedAttribute]
public int get_GoAwayLastStreamId();
    [CompilerGeneratedAttribute]
public void set_GoAwayLastStreamId(int value);
    [CompilerGeneratedAttribute]
public Http2ErrorCode get_GoAwayErrorCode();
    [CompilerGeneratedAttribute]
public void set_GoAwayErrorCode(Http2ErrorCode value);
    public void PrepareGoAway(int lastStreamId, Http2ErrorCode errorCode);
    public Http2HeadersFrameFlags get_HeadersFlags();
    public void set_HeadersFlags(Http2HeadersFrameFlags value);
    public bool get_HeadersEndHeaders();
    public bool get_HeadersEndStream();
    public bool get_HeadersHasPadding();
    public bool get_HeadersHasPriority();
    [CompilerGeneratedAttribute]
public byte get_HeadersPadLength();
    [CompilerGeneratedAttribute]
public void set_HeadersPadLength(byte value);
    [CompilerGeneratedAttribute]
public int get_HeadersStreamDependency();
    [CompilerGeneratedAttribute]
public void set_HeadersStreamDependency(int value);
    [CompilerGeneratedAttribute]
public byte get_HeadersPriorityWeight();
    [CompilerGeneratedAttribute]
public void set_HeadersPriorityWeight(byte value);
    private int get_HeadersPayloadOffset();
    public int get_HeadersPayloadLength();
    public void PrepareHeaders(Http2HeadersFrameFlags flags, int streamId);
    public Http2PingFrameFlags get_PingFlags();
    public void set_PingFlags(Http2PingFrameFlags value);
    public bool get_PingAck();
    public void PreparePing(Http2PingFrameFlags flags);
    [CompilerGeneratedAttribute]
public int get_PriorityStreamDependency();
    [CompilerGeneratedAttribute]
public void set_PriorityStreamDependency(int value);
    [CompilerGeneratedAttribute]
public bool get_PriorityIsExclusive();
    [CompilerGeneratedAttribute]
public void set_PriorityIsExclusive(bool value);
    [CompilerGeneratedAttribute]
public byte get_PriorityWeight();
    [CompilerGeneratedAttribute]
public void set_PriorityWeight(byte value);
    public void PreparePriority(int streamId, int streamDependency, bool exclusive, byte weight);
    [CompilerGeneratedAttribute]
public Http2ErrorCode get_RstStreamErrorCode();
    [CompilerGeneratedAttribute]
public void set_RstStreamErrorCode(Http2ErrorCode value);
    public void PrepareRstStream(int streamId, Http2ErrorCode errorCode);
    public Http2SettingsFrameFlags get_SettingsFlags();
    public void set_SettingsFlags(Http2SettingsFrameFlags value);
    public bool get_SettingsAck();
    public void PrepareSettings(Http2SettingsFrameFlags flags);
    [CompilerGeneratedAttribute]
public int get_WindowUpdateSizeIncrement();
    [CompilerGeneratedAttribute]
public void set_WindowUpdateSizeIncrement(int value);
    public void PrepareWindowUpdate(int streamId, int sizeIncrement);
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameReader : object {
    public static int HeaderLength;
    private static int TypeOffset;
    private static int FlagsOffset;
    private static int StreamIdOffset;
    public static int SettingSize;
    public static bool ReadFrame(ReadOnlySequence`1& readableBuffer, Http2Frame frame, UInt32 maxFrameSize, ReadOnlySequence`1& framePayload);
    private static int ReadExtendedFields(Http2Frame frame, ReadOnlySequence`1& readableBuffer);
    public static int GetPayloadFieldsLength(Http2Frame frame);
    public static IList`1<Http2PeerSetting> ReadSettings(ReadOnlySequence`1& payload);
    private static Http2PeerSetting ReadSetting(ReadOnlySpan`1<byte> payload);
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameType : Enum {
    public byte value__;
    public static Http2FrameType DATA;
    public static Http2FrameType HEADERS;
    public static Http2FrameType PRIORITY;
    public static Http2FrameType RST_STREAM;
    public static Http2FrameType SETTINGS;
    public static Http2FrameType PUSH_PROMISE;
    public static Http2FrameType PING;
    public static Http2FrameType GOAWAY;
    public static Http2FrameType WINDOW_UPDATE;
    public static Http2FrameType CONTINUATION;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameWriter : object {
    private object _writeLock;
    private Http2Frame _outgoingFrame;
    private HPackEncoder _hpackEncoder;
    private ConcurrentPipeWriter _outputWriter;
    private ConnectionContext _connectionContext;
    private Http2Connection _http2Connection;
    private OutputFlowControl _connectionOutputFlowControl;
    private string _connectionId;
    private IKestrelTrace _log;
    private ITimeoutControl _timeoutControl;
    private MinDataRate _minResponseDataRate;
    private TimingPipeFlusher _flusher;
    private UInt32 _maxFrameSize;
    private Byte[] _headerEncodingBuffer;
    private long _unflushedBytes;
    private bool _completed;
    private bool _aborted;
    private static ReadOnlySpan`1<byte> ContinueBytes { get; }
    public Http2FrameWriter(PipeWriter outputPipeWriter, ConnectionContext connectionContext, Http2Connection http2Connection, OutputFlowControl connectionOutputFlowControl, ITimeoutControl timeoutControl, MinDataRate minResponseDataRate, string connectionId, MemoryPool`1<byte> memoryPool, IKestrelTrace log);
    private static ReadOnlySpan`1<byte> get_ContinueBytes();
    public void UpdateMaxFrameSize(UInt32 maxFrameSize);
    public void Complete();
    public void Abort(ConnectionAbortedException error);
    public ValueTask`1<FlushResult> FlushAsync(IHttpOutputAborter outputAborter, CancellationToken cancellationToken);
    public ValueTask`1<FlushResult> Write100ContinueAsync(int streamId);
    public void WriteResponseHeaders(int streamId, int statusCode, Http2HeadersFrameFlags headerFrameFlags, IHeaderDictionary headers);
    public ValueTask`1<FlushResult> WriteResponseTrailers(int streamId, HttpResponseTrailers headers);
    private void FinishWritingHeaders(int streamId, int payloadLength, bool done);
    public ValueTask`1<FlushResult> WriteDataAsync(int streamId, StreamOutputFlowControl flowControl, ReadOnlySequence`1& data, bool endStream);
    private void WriteDataUnsynchronized(int streamId, ReadOnlySequence`1& data, long dataLength, bool endStream);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameWriter/<WriteDataAsync>d__30")]
private ValueTask`1<FlushResult> WriteDataAsync(int streamId, StreamOutputFlowControl flowControl, ReadOnlySequence`1<byte> data, long dataLength, bool endStream);
    public ValueTask`1<FlushResult> WriteWindowUpdateAsync(int streamId, int sizeIncrement);
    public ValueTask`1<FlushResult> WriteRstStreamAsync(int streamId, Http2ErrorCode errorCode);
    public ValueTask`1<FlushResult> WriteSettingsAsync(IList`1<Http2PeerSetting> settings);
    internal static void WriteSettings(IList`1<Http2PeerSetting> settings, Span`1<byte> destination);
    public ValueTask`1<FlushResult> WriteSettingsAckAsync();
    public ValueTask`1<FlushResult> WritePingAsync(Http2PingFrameFlags flags, ReadOnlySequence`1& payload);
    public ValueTask`1<FlushResult> WriteGoAwayAsync(int lastStreamId, Http2ErrorCode errorCode);
    private void WriteHeaderUnsynchronized();
    internal static void WriteHeader(Http2Frame frame, PipeWriter output);
    private ValueTask`1<FlushResult> TimeFlushUnsynchronizedAsync();
    public bool TryUpdateConnectionWindow(int bytes);
    public bool TryUpdateStreamWindow(StreamOutputFlowControl flowControl, int bytes);
    public void AbortPendingStreamDataWrites(StreamOutputFlowControl flowControl);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameWriter/<EnumerateHeaders>d__44")]
private static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateHeaders(IHeaderDictionary headers);
    [CompilerGeneratedAttribute]
private void <WriteDataUnsynchronized>g__TrimAndWriteDataUnsynchronized|29_0(ReadOnlySequence`1& data, long dataLength, bool endStream);
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2HeadersFrameFlags : Enum {
    public byte value__;
    public static Http2HeadersFrameFlags NONE;
    public static Http2HeadersFrameFlags END_STREAM;
    public static Http2HeadersFrameFlags END_HEADERS;
    public static Http2HeadersFrameFlags PADDED;
    public static Http2HeadersFrameFlags PRIORITY;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2MessageBody : MessageBody {
    private Http2Stream _context;
    private ReadResult _readResult;
    private Http2MessageBody(Http2Stream context);
    protected virtual void OnReadStarting();
    protected virtual void OnReadStarted();
    protected virtual void OnDataRead(long bytesRead);
    public static MessageBody For(Http2Stream context);
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual bool TryRead(ReadResult& readResult);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2MessageBody/<ReadAsync>d__10")]
public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual void Complete(Exception exception);
    public virtual void CancelPendingRead();
    protected virtual Task OnStopAsync();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer : object {
    private int _streamId;
    private Http2FrameWriter _frameWriter;
    private TimingPipeFlusher _flusher;
    private IKestrelTrace _log;
    private StreamOutputFlowControl _flowControl;
    private MemoryPool`1<byte> _memoryPool;
    private Http2Stream _stream;
    private object _dataWriterLock;
    private PipeWriter _pipeWriter;
    private PipeReader _pipeReader;
    private ValueTask`1<FlushResult> _dataWriteProcessingTask;
    private bool _startedWritingDataFrames;
    private bool _completed;
    private bool _suffixSent;
    private bool _streamEnded;
    private bool _disposed;
    private IMemoryOwner`1<byte> _fakeMemoryOwner;
    public Http2OutputProducer(int streamId, Http2FrameWriter frameWriter, StreamOutputFlowControl flowControl, MemoryPool`1<byte> pool, Http2Stream stream, IKestrelTrace log);
    public void Dispose();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputAborter.Abort(ConnectionAbortedException abortReason);
    public sealed virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> Write100ContinueAsync();
    public sealed virtual void WriteResponseHeaders(int statusCode, string ReasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, bool appCompleted);
    public sealed virtual Task WriteDataAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> WriteStreamSuffixAsync();
    public ValueTask`1<FlushResult> WriteRstStreamAsync(Http2ErrorCode error);
    public sealed virtual void Advance(int bytes);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual void CancelPendingFlush();
    public sealed virtual ValueTask`1<FlushResult> WriteDataToPipeAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> FirstWriteAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    private sealed virtual override ValueTask`1<FlushResult> Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputProducer.WriteChunkAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> FirstWriteChunkedAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual void Stop();
    public sealed virtual void Reset();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer/<ProcessDataWrites>d__36")]
private ValueTask`1<FlushResult> ProcessDataWrites();
    private Memory`1<byte> GetFakeMemory(int sizeHint);
    [StackTraceHiddenAttribute]
private void ThrowIfSuffixSentOrDisposed();
    [StackTraceHiddenAttribute]
private static void ThrowSuffixSent();
    [StackTraceHiddenAttribute]
private static void ThrowDisposed();
    private static Pipe CreateDataPipe(MemoryPool`1<byte> pool);
    [CompilerGeneratedAttribute]
internal static void <ProcessDataWrites>g__ThrowUnexpectedState|36_0();
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2PeerSetting : ValueType {
    [CompilerGeneratedAttribute]
private Http2SettingsParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public Http2SettingsParameter Parameter { get; }
    public UInt32 Value { get; }
    public Http2PeerSetting(Http2SettingsParameter parameter, UInt32 value);
    [CompilerGeneratedAttribute]
public Http2SettingsParameter get_Parameter();
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2PeerSettings : object {
    public static UInt32 DefaultHeaderTableSize;
    public static bool DefaultEnablePush;
    public static UInt32 DefaultMaxConcurrentStreams;
    public static UInt32 DefaultInitialWindowSize;
    public static UInt32 DefaultMaxFrameSize;
    public static UInt32 DefaultMaxHeaderListSize;
    public static UInt32 MaxWindowSize;
    internal static int MinAllowedMaxFrameSize;
    internal static int MaxAllowedMaxFrameSize;
    [CompilerGeneratedAttribute]
private UInt32 <HeaderTableSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePush>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxConcurrentStreams>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <InitialWindowSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxFrameSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxHeaderListSize>k__BackingField;
    public UInt32 HeaderTableSize { get; public set; }
    public bool EnablePush { get; public set; }
    public UInt32 MaxConcurrentStreams { get; public set; }
    public UInt32 InitialWindowSize { get; public set; }
    public UInt32 MaxFrameSize { get; public set; }
    public UInt32 MaxHeaderListSize { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_HeaderTableSize();
    [CompilerGeneratedAttribute]
public void set_HeaderTableSize(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_EnablePush();
    [CompilerGeneratedAttribute]
public void set_EnablePush(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxConcurrentStreams();
    [CompilerGeneratedAttribute]
public void set_MaxConcurrentStreams(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_InitialWindowSize();
    [CompilerGeneratedAttribute]
public void set_InitialWindowSize(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxFrameSize();
    [CompilerGeneratedAttribute]
public void set_MaxFrameSize(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxHeaderListSize();
    [CompilerGeneratedAttribute]
public void set_MaxHeaderListSize(UInt32 value);
    public void Update(IList`1<Http2PeerSetting> settings);
    internal IList`1<Http2PeerSetting> GetNonProtocolDefaults();
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2PingFrameFlags : Enum {
    public byte value__;
    public static Http2PingFrameFlags NONE;
    public static Http2PingFrameFlags ACK;
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2SettingsFrameFlags : Enum {
    public byte value__;
    public static Http2SettingsFrameFlags NONE;
    public static Http2SettingsFrameFlags ACK;
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2SettingsParameter : Enum {
    public ushort value__;
    public static Http2SettingsParameter SETTINGS_HEADER_TABLE_SIZE;
    public static Http2SettingsParameter SETTINGS_ENABLE_PUSH;
    public static Http2SettingsParameter SETTINGS_MAX_CONCURRENT_STREAMS;
    public static Http2SettingsParameter SETTINGS_INITIAL_WINDOW_SIZE;
    public static Http2SettingsParameter SETTINGS_MAX_FRAME_SIZE;
    public static Http2SettingsParameter SETTINGS_MAX_HEADER_LIST_SIZE;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2SettingsParameterOutOfRangeException : Exception {
    [CompilerGeneratedAttribute]
private Http2SettingsParameter <Parameter>k__BackingField;
    public Http2SettingsParameter Parameter { get; }
    public Http2SettingsParameterOutOfRangeException(Http2SettingsParameter parameter, long lowerBound, long upperBound);
    [CompilerGeneratedAttribute]
public Http2SettingsParameter get_Parameter();
}
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Stream : HttpProtocol {
    private Http2StreamContext _context;
    private Http2OutputProducer _http2Output;
    private StreamInputFlowControl _inputFlowControl;
    private StreamOutputFlowControl _outputFlowControl;
    private bool _decrementCalled;
    [CompilerGeneratedAttribute]
private Pipe <RequestBodyPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DrainExpirationTicks>k__BackingField;
    private StreamCompletionFlags _completionState;
    private object _completionLock;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <InputRemaining>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestBodyStarted>k__BackingField;
    private IHeaderDictionary _userTrailers;
    public Pipe RequestBodyPipe { get; }
    internal long DrainExpirationTicks { get; internal set; }
    public int StreamId { get; }
    public Nullable`1<long> InputRemaining { get; internal set; }
    public bool RequestBodyStarted { get; private set; }
    public bool EndStreamReceived { get; }
    private bool IsAborted { get; }
    internal bool RstStreamReceived { get; }
    public bool ReceivedEmptyRequestBody { get; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.Trailers { get; private set; }
    private int Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttp2StreamIdFeature.StreamId { get; }
    private MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.MinDataRate { get; private set; }
    public Http2Stream(Http2StreamContext context);
    [CompilerGeneratedAttribute]
public Pipe get_RequestBodyPipe();
    [CompilerGeneratedAttribute]
internal long get_DrainExpirationTicks();
    [CompilerGeneratedAttribute]
internal void set_DrainExpirationTicks(long value);
    public int get_StreamId();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_InputRemaining();
    [CompilerGeneratedAttribute]
internal void set_InputRemaining(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_RequestBodyStarted();
    [CompilerGeneratedAttribute]
private void set_RequestBodyStarted(bool value);
    public bool get_EndStreamReceived();
    private bool get_IsAborted();
    internal bool get_RstStreamReceived();
    public bool get_ReceivedEmptyRequestBody();
    protected virtual void OnReset();
    protected virtual void OnRequestProcessingEnded();
    protected virtual string CreateRequestId();
    protected virtual MessageBody CreateMessageBody();
    protected virtual bool TryParseRequest(ReadResult result, Boolean& endConnection);
    private bool TryValidatePseudoHeaders();
    private bool TryValidateMethod();
    private bool TryValidateAuthorityAndHost(String& hostText);
    private bool TryValidatePath(ReadOnlySpan`1<char> pathSegment);
    public Task OnDataAsync(Http2Frame dataFrame, ReadOnlySequence`1& payload);
    public void OnEndStreamReceived();
    public void OnDataRead(int bytesRead);
    public bool TryUpdateOutputWindow(int bytes);
    public void AbortRstStreamReceived();
    public void Abort(IOException abortReason);
    protected virtual void OnErrorAfterResponseStarted();
    protected virtual void ApplicationAbort();
    internal void ResetAndAbort(ConnectionAbortedException abortReason, Http2ErrorCode error);
    private void AbortCore(Exception abortReason);
    public void DecrementActiveClientStreamCount();
    private Pipe CreateRequestBodyPipe(UInt32 windowSize);
    private ValueTuple`2<StreamCompletionFlags, StreamCompletionFlags> ApplyCompletionFlag(StreamCompletionFlags completionState);
    public abstract virtual void Execute();
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.get_Trailers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.set_Trailers(IHeaderDictionary value);
    private sealed virtual override int Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttp2StreamIdFeature.get_StreamId();
    private sealed virtual override MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.get_MinDataRate();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.set_MinDataRate(MinDataRate value);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResetFeature.Reset(int errorCode);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Stream`1 : Http2Stream {
    private IHttpApplication`1<TContext> _application;
    [CompilerGeneratedAttribute]
private TContext <Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext>k__BackingField;
    private TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext { get; private set; }
    public Http2Stream`1(IHttpApplication`1<TContext> application, Http2StreamContext context);
    public virtual void Execute();
    [CompilerGeneratedAttribute]
private sealed virtual override TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.get_HostContext();
    [CompilerGeneratedAttribute]
private sealed virtual override void Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.set_HostContext(TContext value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2StreamContext : HttpConnectionContext {
    [CompilerGeneratedAttribute]
private int <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttp2StreamLifetimeHandler <StreamLifetimeHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2PeerSettings <ClientPeerSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2PeerSettings <ServerPeerSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2FrameWriter <FrameWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private InputFlowControl <ConnectionInputFlowControl>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputFlowControl <ConnectionOutputFlowControl>k__BackingField;
    public int StreamId { get; public set; }
    public IHttp2StreamLifetimeHandler StreamLifetimeHandler { get; public set; }
    public Http2PeerSettings ClientPeerSettings { get; public set; }
    public Http2PeerSettings ServerPeerSettings { get; public set; }
    public Http2FrameWriter FrameWriter { get; public set; }
    public InputFlowControl ConnectionInputFlowControl { get; public set; }
    public OutputFlowControl ConnectionOutputFlowControl { get; public set; }
    [CompilerGeneratedAttribute]
public int get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(int value);
    [CompilerGeneratedAttribute]
public IHttp2StreamLifetimeHandler get_StreamLifetimeHandler();
    [CompilerGeneratedAttribute]
public void set_StreamLifetimeHandler(IHttp2StreamLifetimeHandler value);
    [CompilerGeneratedAttribute]
public Http2PeerSettings get_ClientPeerSettings();
    [CompilerGeneratedAttribute]
public void set_ClientPeerSettings(Http2PeerSettings value);
    [CompilerGeneratedAttribute]
public Http2PeerSettings get_ServerPeerSettings();
    [CompilerGeneratedAttribute]
public void set_ServerPeerSettings(Http2PeerSettings value);
    [CompilerGeneratedAttribute]
public Http2FrameWriter get_FrameWriter();
    [CompilerGeneratedAttribute]
public void set_FrameWriter(Http2FrameWriter value);
    [CompilerGeneratedAttribute]
public InputFlowControl get_ConnectionInputFlowControl();
    [CompilerGeneratedAttribute]
public void set_ConnectionInputFlowControl(InputFlowControl value);
    [CompilerGeneratedAttribute]
public OutputFlowControl get_ConnectionOutputFlowControl();
    [CompilerGeneratedAttribute]
public void set_ConnectionOutputFlowControl(OutputFlowControl value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2StreamErrorException : Exception {
    [CompilerGeneratedAttribute]
private int <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2ErrorCode <ErrorCode>k__BackingField;
    public int StreamId { get; }
    public Http2ErrorCode ErrorCode { get; }
    public Http2StreamErrorException(int streamId, string message, Http2ErrorCode errorCode);
    [CompilerGeneratedAttribute]
public int get_StreamId();
    [CompilerGeneratedAttribute]
public Http2ErrorCode get_ErrorCode();
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.IHttp2StreamLifetimeHandler {
    public abstract virtual void OnStreamCompleted(Http2Stream stream);
    public abstract virtual void DecrementActiveClientStreamCount();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.ThreadPoolAwaitable : object {
    public static ThreadPoolAwaitable Instance;
    public bool IsCompleted { get; }
    private static ThreadPoolAwaitable();
    public ThreadPoolAwaitable GetAwaiter();
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpConnection : object {
    private HttpConnectionContext _context;
    private ISystemClock _systemClock;
    private TimeoutControl _timeoutControl;
    private object _protocolSelectionLock;
    private ProtocolSelectionState _protocolSelectionState;
    private IRequestProcessor _requestProcessor;
    private Http1Connection _http1Connection;
    private static ReadOnlySpan`1<byte> Http2Id { get; }
    private IKestrelTrace Log { get; }
    public HttpConnection(HttpConnectionContext context);
    private static ReadOnlySpan`1<byte> get_Http2Id();
    private IKestrelTrace get_Log();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpConnection/<ProcessRequestsAsync>d__12`1")]
public Task ProcessRequestsAsync(IHttpApplication`1<TContext> httpApplication);
    internal void Initialize(IRequestProcessor requestProcessor);
    private void StopProcessingNextRequest();
    private void OnConnectionClosed();
    private void Abort(ConnectionAbortedException ex);
    private HttpProtocols SelectProtocol();
    private void Tick();
    public sealed virtual void OnTimeout(TimeoutReason reason);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpConnectionBuilderExtensions : object {
    [ExtensionAttribute]
public static IConnectionBuilder UseHttpServer(IConnectionBuilder builder, ServiceContext serviceContext, IHttpApplication`1<TContext> application, HttpProtocols protocols);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpConnectionContext : object {
    [CompilerGeneratedAttribute]
private string <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpProtocols <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionContext <ConnectionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceContext <ServiceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IFeatureCollection <ConnectionFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryPool`1<byte> <MemoryPool>k__BackingField;
    [CompilerGeneratedAttribute]
private IPEndPoint <LocalEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IPEndPoint <RemoteEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ITimeoutControl <TimeoutControl>k__BackingField;
    [CompilerGeneratedAttribute]
private IDuplexPipe <Transport>k__BackingField;
    public string ConnectionId { get; public set; }
    public HttpProtocols Protocols { get; public set; }
    public ConnectionContext ConnectionContext { get; public set; }
    public ServiceContext ServiceContext { get; public set; }
    public IFeatureCollection ConnectionFeatures { get; public set; }
    public MemoryPool`1<byte> MemoryPool { get; public set; }
    public IPEndPoint LocalEndPoint { get; public set; }
    public IPEndPoint RemoteEndPoint { get; public set; }
    public ITimeoutControl TimeoutControl { get; public set; }
    public IDuplexPipe Transport { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConnectionId();
    [CompilerGeneratedAttribute]
public void set_ConnectionId(string value);
    [CompilerGeneratedAttribute]
public HttpProtocols get_Protocols();
    [CompilerGeneratedAttribute]
public void set_Protocols(HttpProtocols value);
    [CompilerGeneratedAttribute]
public ConnectionContext get_ConnectionContext();
    [CompilerGeneratedAttribute]
public void set_ConnectionContext(ConnectionContext value);
    [CompilerGeneratedAttribute]
public ServiceContext get_ServiceContext();
    [CompilerGeneratedAttribute]
public void set_ServiceContext(ServiceContext value);
    [CompilerGeneratedAttribute]
public IFeatureCollection get_ConnectionFeatures();
    [CompilerGeneratedAttribute]
public void set_ConnectionFeatures(IFeatureCollection value);
    [CompilerGeneratedAttribute]
public MemoryPool`1<byte> get_MemoryPool();
    [CompilerGeneratedAttribute]
public void set_MemoryPool(MemoryPool`1<byte> value);
    [CompilerGeneratedAttribute]
public IPEndPoint get_LocalEndPoint();
    [CompilerGeneratedAttribute]
public void set_LocalEndPoint(IPEndPoint value);
    [CompilerGeneratedAttribute]
public IPEndPoint get_RemoteEndPoint();
    [CompilerGeneratedAttribute]
public void set_RemoteEndPoint(IPEndPoint value);
    [CompilerGeneratedAttribute]
public ITimeoutControl get_TimeoutControl();
    [CompilerGeneratedAttribute]
public void set_TimeoutControl(ITimeoutControl value);
    [CompilerGeneratedAttribute]
public IDuplexPipe get_Transport();
    [CompilerGeneratedAttribute]
public void set_Transport(IDuplexPipe value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpConnectionMiddleware`1 : object {
    private ServiceContext _serviceContext;
    private IHttpApplication`1<TContext> _application;
    private HttpProtocols _protocols;
    public HttpConnectionMiddleware`1(ServiceContext serviceContext, IHttpApplication`1<TContext> application, HttpProtocols protocols);
    public Task OnConnectionAsync(ConnectionContext connectionContext);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.BodyControl : object {
    private static ThrowingWasUpgradedWriteOnlyStream _throwingResponseStream;
    private HttpResponseStream _response;
    private HttpResponsePipeWriter _responseWriter;
    private HttpRequestPipeReader _requestReader;
    private HttpRequestStream _request;
    private HttpRequestPipeReader _emptyRequestReader;
    private WrappingStream _upgradeableResponse;
    private HttpRequestStream _emptyRequest;
    private Stream _upgradeStream;
    public BodyControl(IHttpBodyControlFeature bodyControl, IHttpResponseControl responseControl);
    private static BodyControl();
    public Stream Upgrade();
    public ValueTuple`4<Stream, Stream, PipeReader, PipeWriter> Start(MessageBody body);
    public Task StopAsync();
    public void Abort(Exception error);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ConnectionManager : object {
    private ConcurrentDictionary`2<long, ConnectionReference> _connectionReferences;
    private IKestrelTrace _trace;
    [CompilerGeneratedAttribute]
private ResourceCounter <UpgradedConnectionCount>k__BackingField;
    public ResourceCounter UpgradedConnectionCount { get; }
    public ConnectionManager(IKestrelTrace trace, Nullable`1<long> upgradedConnectionLimit);
    public ConnectionManager(IKestrelTrace trace, ResourceCounter upgradedConnections);
    [CompilerGeneratedAttribute]
public ResourceCounter get_UpgradedConnectionCount();
    public void AddConnection(long id, KestrelConnection connection);
    public void RemoveConnection(long id);
    public void Walk(Action`1<KestrelConnection> callback);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ConnectionManager/<CloseAllConnectionsAsync>d__10")]
public Task`1<bool> CloseAllConnectionsAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ConnectionManager/<AbortAllConnectionsAsync>d__11")]
public Task`1<bool> AbortAllConnectionsAsync();
    private static Task CancellationTokenAsTask(CancellationToken token);
    private static ResourceCounter GetCounter(Nullable`1<long> number);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ConnectionReference : object {
    private WeakReference`1<KestrelConnection> _weakReference;
    [CompilerGeneratedAttribute]
private string <ConnectionId>k__BackingField;
    public string ConnectionId { get; }
    public ConnectionReference(KestrelConnection connection);
    [CompilerGeneratedAttribute]
public string get_ConnectionId();
    public bool TryGetConnection(KestrelConnection& connection);
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.Constants : object {
    public static int MaxExceptionDetailSize;
    public static string DefaultServerAddress;
    public static string DefaultServerHttpsAddress;
    public static string UnixPipeHostPrefix;
    public static string PipeDescriptorPrefix;
    public static string SocketDescriptorPrefix;
    public static string ServerName;
    public static TimeSpan RequestBodyDrainTimeout;
    private static Constants();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.DebuggerWrapper : object {
    [CompilerGeneratedAttribute]
private static IDebugger <Singleton>k__BackingField;
    public static IDebugger Singleton { get; }
    public bool IsAttached { get; }
    private static DebuggerWrapper();
    [CompilerGeneratedAttribute]
public static IDebugger get_Singleton();
    public sealed virtual bool get_IsAttached();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.Disposable : object {
    private Action _dispose;
    private bool _disposedValue;
    public Disposable(Action dispose);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.Heartbeat : object {
    public static TimeSpan Interval;
    private IHeartbeatHandler[] _callbacks;
    private ISystemClock _systemClock;
    private IDebugger _debugger;
    private IKestrelTrace _trace;
    private TimeSpan _interval;
    private Timer _timer;
    private int _executingOnHeartbeat;
    public Heartbeat(IHeartbeatHandler[] callbacks, ISystemClock systemClock, IDebugger debugger, IKestrelTrace trace);
    private static Heartbeat();
    public void Start();
    private static void OnHeartbeat(object state);
    internal void OnHeartbeat();
    public sealed virtual void Dispose();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.HeartbeatManager : object {
    private ConnectionManager _connectionManager;
    private Action`1<KestrelConnection> _walkCallback;
    private DateTimeOffset _now;
    private long _nowTicks;
    public DateTimeOffset UtcNow { get; }
    public long UtcNowTicks { get; }
    public DateTimeOffset UtcNowUnsynchronized { get; }
    public HeartbeatManager(ConnectionManager connectionManager);
    public sealed virtual DateTimeOffset get_UtcNow();
    public sealed virtual long get_UtcNowTicks();
    public sealed virtual DateTimeOffset get_UtcNowUnsynchronized();
    public sealed virtual void OnHeartbeat(DateTimeOffset now);
    private void WalkCallback(KestrelConnection connection);
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.HttpCharacters : object {
    private static int _tableSize;
    private static Boolean[] _alphaNumeric;
    private static Boolean[] _authority;
    private static Boolean[] _token;
    private static Boolean[] _host;
    private static Boolean[] _fieldValue;
    private static HttpCharacters();
    internal static void Initialize();
    private static Boolean[] InitializeAlphaNumeric();
    private static Boolean[] InitializeAuthority();
    private static Boolean[] InitializeToken();
    private static Boolean[] InitializeHost();
    private static Boolean[] InitializeFieldValue();
    public static bool ContainsInvalidAuthorityChar(Span`1<byte> s);
    public static int IndexOfInvalidHostChar(string s);
    public static int IndexOfInvalidTokenChar(string s);
    public static int IndexOfInvalidTokenChar(Byte* s, int length);
    public static int IndexOfInvalidFieldValueChar(string s);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.HttpUtilities : object {
    public static string Http10Version;
    public static string Http11Version;
    public static string Http2Version;
    public static string HttpUriScheme;
    public static string HttpsUriScheme;
    private static ulong _httpSchemeLong;
    private static ulong _httpsSchemeLong;
    private static UInt32 _httpGetMethodInt;
    private static ulong _http10VersionLong;
    private static ulong _http11VersionLong;
    private static UTF8EncodingSealed HeaderValueEncoding;
    private static ulong _httpConnectMethodLong;
    private static ulong _httpDeleteMethodLong;
    private static ulong _httpHeadMethodLong;
    private static ulong _httpPatchMethodLong;
    private static ulong _httpPostMethodLong;
    private static ulong _httpPutMethodLong;
    private static ulong _httpOptionsMethodLong;
    private static ulong _httpTraceMethodLong;
    private static ulong _mask8Chars;
    private static ulong _mask7Chars;
    private static ulong _mask6Chars;
    private static ulong _mask5Chars;
    private static ulong _mask4Chars;
    private static Tuple`4[] _knownMethods;
    private static String[] _methodNames;
    private static HttpUtilities();
    private static void SetKnownMethod(ulong mask, ulong knownMethodUlong, HttpMethod knownMethod, int length);
    private static void FillKnownMethodsGaps();
    private static ulong GetAsciiStringAsLong(string str);
    private static UInt32 GetAsciiStringAsInt(string str);
    private static ulong GetMaskAsLong(Byte[] bytes);
    [ExtensionAttribute]
public static string GetHeaderName(Span`1<byte> span);
    [ExtensionAttribute]
public static string GetAsciiStringNonNullCharacters(Span`1<byte> span);
    [ExtensionAttribute]
public static string GetRequestHeaderStringNonNullCharacters(Span`1<byte> span, bool useLatin1);
    [ExtensionAttribute]
public static string GetAsciiStringEscaped(Span`1<byte> span, int maxChars);
    [ExtensionAttribute]
public static bool GetKnownMethod(Span`1<byte> span, HttpMethod& method, Int32& length);
    internal static HttpMethod GetKnownMethod(Byte* data, int length, Int32& methodLength);
    public static HttpMethod GetKnownMethod(string value);
    [ExtensionAttribute]
public static bool GetKnownVersion(Span`1<byte> span, HttpVersion& knownVersion, Byte& length);
    internal static HttpVersion GetKnownVersion(Byte* location, int length);
    [ExtensionAttribute]
public static bool GetKnownHttpScheme(Span`1<byte> span, HttpScheme& knownScheme);
    private static bool GetKnownHttpScheme(Byte* location, int length, HttpScheme& knownScheme);
    public static string VersionToString(HttpVersion httpVersion);
    public static string MethodToString(HttpMethod method);
    public static string SchemeToString(HttpScheme scheme);
    public static bool IsHostHeaderValid(string hostText);
    private static bool IsIPv6HostValid(string hostText);
    private static bool IsHostPortValid(string hostText, int offset);
    private static bool IsNumeric(char ch);
    private static bool IsHex(char ch);
    private static int GetKnownMethodIndex(ulong value);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.IDebugger {
    public bool IsAttached { get; }
    public abstract virtual bool get_IsAttached();
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.IHeartbeatHandler {
    public abstract virtual void OnHeartbeat(DateTimeOffset now);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.IKestrelTrace {
    public abstract virtual void ConnectionAccepted(string connectionId);
    public abstract virtual void ConnectionStart(string connectionId);
    public abstract virtual void ConnectionStop(string connectionId);
    public abstract virtual void ConnectionPause(string connectionId);
    public abstract virtual void ConnectionResume(string connectionId);
    public abstract virtual void ConnectionRejected(string connectionId);
    public abstract virtual void ConnectionKeepAlive(string connectionId);
    public abstract virtual void ConnectionDisconnect(string connectionId);
    public abstract virtual void RequestProcessingError(string connectionId, Exception ex);
    public abstract virtual void ConnectionHeadResponseBodyWrite(string connectionId, long count);
    public abstract virtual void NotAllConnectionsClosedGracefully();
    public abstract virtual void ConnectionBadRequest(string connectionId, BadHttpRequestException ex);
    public abstract virtual void ApplicationError(string connectionId, string traceIdentifier, Exception ex);
    public abstract virtual void NotAllConnectionsAborted();
    public abstract virtual void HeartbeatSlow(TimeSpan interval, DateTimeOffset now);
    public abstract virtual void ApplicationNeverCompleted(string connectionId);
    public abstract virtual void RequestBodyStart(string connectionId, string traceIdentifier);
    public abstract virtual void RequestBodyDone(string connectionId, string traceIdentifier);
    public abstract virtual void RequestBodyNotEntirelyRead(string connectionId, string traceIdentifier);
    public abstract virtual void RequestBodyDrainTimedOut(string connectionId, string traceIdentifier);
    public abstract virtual void RequestBodyMinimumDataRateNotSatisfied(string connectionId, string traceIdentifier, double rate);
    public abstract virtual void ResponseMinimumDataRateNotSatisfied(string connectionId, string traceIdentifier);
    public abstract virtual void ApplicationAbortedConnection(string connectionId, string traceIdentifier);
    public abstract virtual void Http2ConnectionError(string connectionId, Http2ConnectionErrorException ex);
    public abstract virtual void Http2ConnectionClosing(string connectionId);
    public abstract virtual void Http2ConnectionClosed(string connectionId, int highestOpenedStreamId);
    public abstract virtual void Http2StreamError(string connectionId, Http2StreamErrorException ex);
    public abstract virtual void Http2StreamResetAbort(string traceIdentifier, Http2ErrorCode error, ConnectionAbortedException abortReason);
    public abstract virtual void HPackDecodingError(string connectionId, int streamId, HPackDecodingException ex);
    public abstract virtual void HPackEncodingError(string connectionId, int streamId, HPackEncodingException ex);
    public abstract virtual void Http2FrameReceived(string connectionId, Http2Frame frame);
    public abstract virtual void Http2FrameSending(string connectionId, Http2Frame frame);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ISystemClock {
    public DateTimeOffset UtcNow { get; }
    public long UtcNowTicks { get; }
    public DateTimeOffset UtcNowUnsynchronized { get; }
    public abstract virtual DateTimeOffset get_UtcNow();
    public abstract virtual long get_UtcNowTicks();
    public abstract virtual DateTimeOffset get_UtcNowUnsynchronized();
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ITimeoutControl {
    public TimeoutReason TimerReason { get; }
    public abstract virtual TimeoutReason get_TimerReason();
    public abstract virtual void SetTimeout(long ticks, TimeoutReason timeoutReason);
    public abstract virtual void ResetTimeout(long ticks, TimeoutReason timeoutReason);
    public abstract virtual void CancelTimeout();
    public abstract virtual void InitializeHttp2(InputFlowControl connectionInputFlowControl);
    public abstract virtual void StartRequestBody(MinDataRate minRate);
    public abstract virtual void StopRequestBody();
    public abstract virtual void StartTimingRead();
    public abstract virtual void StopTimingRead();
    public abstract virtual void BytesRead(long count);
    public abstract virtual void StartTimingWrite();
    public abstract virtual void StopTimingWrite();
    public abstract virtual void BytesWrittenToBuffer(MinDataRate minRate, long count);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ITimeoutHandler {
    public abstract virtual void OnTimeout(TimeoutReason reason);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelConnection : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<Action`1<object>, object>> _heartbeatHandlers;
    private object _heartbeatLock;
    private Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> _onCompleted;
    private bool _completed;
    private CancellationTokenSource _connectionClosingCts;
    private TaskCompletionSource`1<object> _completionTcs;
    private long _id;
    private ServiceContext _serviceContext;
    private ConnectionDelegate _connectionDelegate;
    [CompilerGeneratedAttribute]
private IKestrelTrace <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionContext <TransportConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <ConnectionClosedRequested>k__BackingField;
    private IKestrelTrace Logger { get; }
    public ConnectionContext TransportConnection { get; public set; }
    public CancellationToken ConnectionClosedRequested { get; public set; }
    public Task ExecutionTask { get; }
    public KestrelConnection(long id, ServiceContext serviceContext, ConnectionDelegate connectionDelegate, ConnectionContext connectionContext, IKestrelTrace logger);
    [CompilerGeneratedAttribute]
private IKestrelTrace get_Logger();
    [CompilerGeneratedAttribute]
public ConnectionContext get_TransportConnection();
    [CompilerGeneratedAttribute]
public void set_TransportConnection(ConnectionContext value);
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_ConnectionClosedRequested();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConnectionClosedRequested(CancellationToken value);
    public Task get_ExecutionTask();
    public void TickHeartbeat();
    public sealed virtual void OnHeartbeat(Action`1<object> action, object state);
    private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IConnectionCompleteFeature.OnCompleted(Func`2<object, Task> callback, object state);
    public Task FireOnCompletedAsync();
    private Task CompleteAsyncMayAwait(Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> onCompleted);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelConnection/<CompleteAsyncAwaited>d__28")]
private Task CompleteAsyncAwaited(Task currentTask, Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> onCompleted);
    public sealed virtual void RequestClose();
    public void Complete();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.Execute();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelConnection/<ExecuteAsync>d__32")]
internal Task ExecuteAsync();
    private IDisposable BeginConnectionScope(ConnectionContext connectionContext);
}
[EventSourceAttribute]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelEventSource : EventSource {
    public static KestrelEventSource Log;
    private static KestrelEventSource();
    [NonEventAttribute]
public void ConnectionStart(ConnectionContext connection);
    [EventAttribute("1")]
private void ConnectionStart(string connectionId, string localEndPoint, string remoteEndPoint);
    [NonEventAttribute]
public void ConnectionStop(ConnectionContext connection);
    [EventAttribute("2")]
private void ConnectionStop(string connectionId);
    [EventAttribute("5")]
public void ConnectionRejected(string connectionId);
    [NonEventAttribute]
public void RequestStart(HttpProtocol httpProtocol);
    [EventAttribute("3")]
private void RequestStart(string connectionId, string requestId);
    [NonEventAttribute]
public void RequestStop(HttpProtocol httpProtocol);
    [EventAttribute("4")]
private void RequestStop(string connectionId, string requestId);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelTrace : object {
    private static Action`3<ILogger, string, Exception> _connectionStart;
    private static Action`3<ILogger, string, Exception> _connectionStop;
    private static Action`3<ILogger, string, Exception> _connectionPause;
    private static Action`3<ILogger, string, Exception> _connectionResume;
    private static Action`3<ILogger, string, Exception> _connectionKeepAlive;
    private static Action`3<ILogger, string, Exception> _connectionDisconnect;
    private static Action`4<ILogger, string, string, Exception> _applicationError;
    private static Action`2<ILogger, Exception> _notAllConnectionsClosedGracefully;
    private static Action`4<ILogger, string, string, Exception> _connectionBadRequest;
    private static Action`4<ILogger, string, long, Exception> _connectionHeadResponseBodyWrite;
    private static Action`3<ILogger, string, Exception> _requestProcessingError;
    private static Action`2<ILogger, Exception> _notAllConnectionsAborted;
    private static Action`4<ILogger, TimeSpan, DateTimeOffset, Exception> _heartbeatSlow;
    private static Action`3<ILogger, string, Exception> _applicationNeverCompleted;
    private static Action`3<ILogger, string, Exception> _connectionRejected;
    private static Action`4<ILogger, string, string, Exception> _requestBodyStart;
    private static Action`4<ILogger, string, string, Exception> _requestBodyDone;
    private static Action`5<ILogger, string, string, double, Exception> _requestBodyMinimumDataRateNotSatisfied;
    private static Action`4<ILogger, string, string, Exception> _responseMinimumDataRateNotSatisfied;
    private static Action`3<ILogger, string, Exception> _http2ConnectionError;
    private static Action`3<ILogger, string, Exception> _http2StreamError;
    private static Action`4<ILogger, string, int, Exception> _hpackDecodingError;
    private static Action`4<ILogger, string, string, Exception> _requestBodyNotEntirelyRead;
    private static Action`4<ILogger, string, string, Exception> _requestBodyDrainTimedOut;
    private static Action`4<ILogger, string, string, Exception> _applicationAbortedConnection;
    private static Action`4<ILogger, string, Http2ErrorCode, Exception> _http2StreamResetError;
    private static Action`3<ILogger, string, Exception> _http2ConnectionClosing;
    private static Action`4<ILogger, string, int, Exception> _http2ConnectionClosed;
    private static Action`7<ILogger, string, Http2FrameType, int, int, object, Exception> _http2FrameReceived;
    private static Action`7<ILogger, string, Http2FrameType, int, int, object, Exception> _http2FrameSending;
    private static Action`4<ILogger, string, int, Exception> _hpackEncodingError;
    private static Action`3<ILogger, string, Exception> _connectionAccepted;
    protected ILogger _logger;
    public KestrelTrace(ILogger logger);
    private static KestrelTrace();
    public virtual void ConnectionAccepted(string connectionId);
    public virtual void ConnectionStart(string connectionId);
    public virtual void ConnectionStop(string connectionId);
    public virtual void ConnectionPause(string connectionId);
    public virtual void ConnectionResume(string connectionId);
    public virtual void ConnectionKeepAlive(string connectionId);
    public virtual void ConnectionRejected(string connectionId);
    public virtual void ConnectionDisconnect(string connectionId);
    public virtual void ApplicationError(string connectionId, string traceIdentifier, Exception ex);
    public virtual void ConnectionHeadResponseBodyWrite(string connectionId, long count);
    public virtual void NotAllConnectionsClosedGracefully();
    public virtual void ConnectionBadRequest(string connectionId, BadHttpRequestException ex);
    public virtual void RequestProcessingError(string connectionId, Exception ex);
    public virtual void NotAllConnectionsAborted();
    public virtual void HeartbeatSlow(TimeSpan interval, DateTimeOffset now);
    public virtual void ApplicationNeverCompleted(string connectionId);
    public virtual void RequestBodyStart(string connectionId, string traceIdentifier);
    public virtual void RequestBodyDone(string connectionId, string traceIdentifier);
    public virtual void RequestBodyMinimumDataRateNotSatisfied(string connectionId, string traceIdentifier, double rate);
    public virtual void RequestBodyNotEntirelyRead(string connectionId, string traceIdentifier);
    public virtual void RequestBodyDrainTimedOut(string connectionId, string traceIdentifier);
    public virtual void ResponseMinimumDataRateNotSatisfied(string connectionId, string traceIdentifier);
    public virtual void ApplicationAbortedConnection(string connectionId, string traceIdentifier);
    public virtual void Http2ConnectionError(string connectionId, Http2ConnectionErrorException ex);
    public virtual void Http2ConnectionClosing(string connectionId);
    public virtual void Http2ConnectionClosed(string connectionId, int highestOpenedStreamId);
    public virtual void Http2StreamError(string connectionId, Http2StreamErrorException ex);
    public sealed virtual void Http2StreamResetAbort(string traceIdentifier, Http2ErrorCode error, ConnectionAbortedException abortReason);
    public virtual void HPackDecodingError(string connectionId, int streamId, HPackDecodingException ex);
    public virtual void HPackEncodingError(string connectionId, int streamId, HPackEncodingException ex);
    public sealed virtual void Http2FrameReceived(string connectionId, Http2Frame frame);
    public sealed virtual void Http2FrameSending(string connectionId, Http2Frame frame);
    public virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
    public virtual bool IsEnabled(LogLevel logLevel);
    public virtual IDisposable BeginScope(TState state);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.PipeWriterHelpers.ConcurrentPipeWriter : PipeWriter {
    private static int InitialSegmentPoolSize;
    private static int MaxSegmentPoolSize;
    private static int MinimumBufferSize;
    private static Exception _successfullyCompletedSentinel;
    private object _sync;
    private PipeWriter _innerPipeWriter;
    private MemoryPool`1<byte> _pool;
    private BufferSegmentStack _bufferSegmentPool;
    private BufferSegment _head;
    private BufferSegment _tail;
    private Memory`1<byte> _tailMemory;
    private int _tailBytesBuffered;
    private long _bytesBuffered;
    private TaskCompletionSource`1<FlushResult> _currentFlushTcs;
    private bool _bufferedWritePending;
    private bool _aborted;
    private Exception _completeException;
    public ConcurrentPipeWriter(PipeWriter innerPipeWriter, MemoryPool`1<byte> pool, object sync);
    private static ConcurrentPipeWriter();
    public virtual Memory`1<byte> GetMemory(int sizeHint);
    public virtual Span`1<byte> GetSpan(int sizeHint);
    public virtual void Advance(int bytes);
    public virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.PipeWriterHelpers.ConcurrentPipeWriter/<FlushAsyncAwaited>d__22")]
private Task FlushAsyncAwaited(ValueTask`1<FlushResult> flushTask, CancellationToken cancellationToken);
    public virtual void CancelPendingFlush();
    public virtual void Complete(Exception exception);
    public void Abort();
    private void CleanupSegmentsUnsynchronized();
    private void CopyAndReturnSegmentsUnsynchronized();
    private void CompleteFlushUnsynchronized(FlushResult flushResult, Exception flushEx);
    private void AllocateMemoryUnsynchronized(int sizeHint);
    private BufferSegment AllocateSegmentUnsynchronized(int sizeHint);
    private BufferSegment CreateSegmentUnsynchronized();
    private void ReturnSegmentUnsynchronized(BufferSegment segment);
    private static int GetSegmentSize(int sizeHint, int maxBufferSize);
    private static void ThrowArgumentOutOfRangeException(string argumentName);
    private static Exception CreateArgumentOutOfRangeException(string argumentName);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.PipeWriterHelpers.TimingPipeFlusher : object {
    private PipeWriter _writer;
    private ITimeoutControl _timeoutControl;
    private IKestrelTrace _log;
    public TimingPipeFlusher(PipeWriter writer, ITimeoutControl timeoutControl, IKestrelTrace log);
    public ValueTask`1<FlushResult> FlushAsync();
    public ValueTask`1<FlushResult> FlushAsync(IHttpOutputAborter outputAborter, CancellationToken cancellationToken);
    public ValueTask`1<FlushResult> FlushAsync(MinDataRate minRate, long count);
    public ValueTask`1<FlushResult> FlushAsync(MinDataRate minRate, long count, IHttpOutputAborter outputAborter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.PipeWriterHelpers.TimingPipeFlusher/<TimeFlushAsyncAwaited>d__8")]
private ValueTask`1<FlushResult> TimeFlushAsyncAwaited(ValueTask`1<FlushResult> pipeFlushTask, MinDataRate minRate, IHttpOutputAborter outputAborter, CancellationToken cancellationToken);
}
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ReadOnlyStream : Stream {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public int WriteTimeout { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ResourceCounter : object {
    [CompilerGeneratedAttribute]
private static ResourceCounter <Unlimited>k__BackingField;
    public static ResourceCounter Unlimited { get; }
    private static ResourceCounter();
    public abstract virtual bool TryLockOne();
    public abstract virtual void ReleaseOne();
    [CompilerGeneratedAttribute]
public static ResourceCounter get_Unlimited();
    public static ResourceCounter Quota(long amount);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StringUtilities : object {
    private static Char[] s_encode16Chars;
    private static StringUtilities();
    [ExtensionAttribute]
public static string GetAsciiOrUTF8StringNonNullCharacters(Span`1<byte> span, Encoding defaultEncoding);
    [ExtensionAttribute]
public static string GetLatin1StringNonNullCharacters(Span`1<byte> span);
    public static bool TryGetAsciiString(Byte* input, Char* output, int count);
    public static bool TryGetLatin1String(Byte* input, Char* output, int count);
    public static bool BytesOrdinalEqualsStringAndAscii(string previousValue, Span`1<byte> newValue);
    private static bool WidenFourAsciiBytesToUtf16AndCompareToChars(Char& charStart, UInt32 value);
    private static bool WidenTwoAsciiBytesToUtf16AndCompareToChars(Char& charStart, ushort value);
    private static bool AllBytesInUInt32AreAscii(UInt32 value);
    private static bool AllBytesInUInt16AreAscii(ushort value);
    private static bool IsValidHeaderString(string value);
    public static string ConcatAsHexSuffix(string str, char separator, UInt32 number);
    private static bool CheckBytesInAsciiRange(Vector`1<sbyte> check);
    private static bool CheckBytesInAsciiRange(long check);
    private static bool CheckBytesInAsciiRange(int check);
    private static bool CheckBytesInAsciiRange(short check);
    private static bool CheckBytesInAsciiRange(sbyte check);
    private static bool CheckBytesNotNull(Vector`1<byte> check);
    private static bool CheckBytesNotNull(long check);
    private static bool CheckBytesNotNull(int check);
    private static bool CheckBytesNotNull(short check);
    private static bool CheckBytesNotNull(sbyte check);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.SystemClock : object {
    public DateTimeOffset UtcNow { get; }
    public long UtcNowTicks { get; }
    public DateTimeOffset UtcNowUnsynchronized { get; }
    public sealed virtual DateTimeOffset get_UtcNow();
    public sealed virtual long get_UtcNowTicks();
    public sealed virtual DateTimeOffset get_UtcNowUnsynchronized();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ThrowingWasUpgradedWriteOnlyStream : WriteOnlyStream {
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TimeoutControl : object {
    private ITimeoutHandler _timeoutHandler;
    private long _lastTimestamp;
    private long _timeoutTimestamp;
    private object _readTimingLock;
    private MinDataRate _minReadRate;
    private bool _readTimingEnabled;
    private bool _readTimingPauseRequested;
    private long _readTimingElapsedTicks;
    private long _readTimingBytesRead;
    private InputFlowControl _connectionInputFlowControl;
    private int _concurrentIncompleteRequestBodies;
    private int _concurrentAwaitingReads;
    private object _writeTimingLock;
    private int _concurrentAwaitingWrites;
    private long _writeTimingTimeoutTimestamp;
    [CompilerGeneratedAttribute]
private TimeoutReason <TimerReason>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugger <Debugger>k__BackingField;
    public TimeoutReason TimerReason { get; private set; }
    internal IDebugger Debugger { get; internal set; }
    public TimeoutControl(ITimeoutHandler timeoutHandler);
    [CompilerGeneratedAttribute]
public sealed virtual TimeoutReason get_TimerReason();
    [CompilerGeneratedAttribute]
private void set_TimerReason(TimeoutReason value);
    [CompilerGeneratedAttribute]
internal IDebugger get_Debugger();
    [CompilerGeneratedAttribute]
internal void set_Debugger(IDebugger value);
    internal void Initialize(long nowTicks);
    public void Tick(DateTimeOffset now);
    private void CheckForTimeout(long timestamp);
    private void CheckForReadDataRateTimeout(long timestamp);
    private void CheckForWriteDataRateTimeout(long timestamp);
    public sealed virtual void SetTimeout(long ticks, TimeoutReason timeoutReason);
    public sealed virtual void ResetTimeout(long ticks, TimeoutReason timeoutReason);
    public sealed virtual void CancelTimeout();
    private void AssignTimeout(long ticks, TimeoutReason timeoutReason);
    public sealed virtual void InitializeHttp2(InputFlowControl connectionInputFlowControl);
    public sealed virtual void StartRequestBody(MinDataRate minRate);
    public sealed virtual void StopRequestBody();
    public sealed virtual void StopTimingRead();
    public sealed virtual void StartTimingRead();
    public sealed virtual void BytesRead(long count);
    public sealed virtual void StartTimingWrite();
    public sealed virtual void StopTimingWrite();
    public sealed virtual void BytesWrittenToBuffer(MinDataRate minRate, long count);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Features.IConnectionTimeoutFeature.SetTimeout(TimeSpan timeSpan);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Features.IConnectionTimeoutFeature.ResetTimeout(TimeSpan timeSpan);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TimeoutControlExtensions : object {
    [ExtensionAttribute]
public static void StartDrainTimeout(ITimeoutControl timeoutControl, MinDataRate minDataRate, Nullable`1<long> maxResponseBufferSize);
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TimeoutReason : Enum {
    public int value__;
    public static TimeoutReason None;
    public static TimeoutReason KeepAlive;
    public static TimeoutReason RequestHeaders;
    public static TimeoutReason ReadDataRate;
    public static TimeoutReason WriteDataRate;
    public static TimeoutReason RequestBodyDrain;
    public static TimeoutReason TimeoutFeature;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.WrappingStream : Stream {
    private Stream _inner;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public WrappingStream(Stream inner);
    public void SetInnerStream(Stream inner);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual object InitializeLifetimeService();
    public virtual void Close();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
}
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.WriteOnlyStream : Stream {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.IRequestProcessor {
    public abstract virtual Task ProcessRequestsAsync(IHttpApplication`1<TContext> application);
    public abstract virtual void StopProcessingNextRequest();
    public abstract virtual void HandleRequestHeadersTimeout();
    public abstract virtual void HandleReadDataRateTimeout();
    public abstract virtual void OnInputOrOutputCompleted();
    public abstract virtual void Tick(DateTimeOffset now);
    public abstract virtual void Abort(ConnectionAbortedException ex);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.KestrelServerOptionsSetup : object {
    private IServiceProvider _services;
    public KestrelServerOptionsSetup(IServiceProvider services);
    public sealed virtual void Configure(KestrelServerOptions options);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggerExtensions : object {
    private static Action`4<ILogger, string, string, Exception> _locatedDevelopmentCertificate;
    private static Action`2<ILogger, Exception> _unableToLocateDevelopmentCertificate;
    private static Action`3<ILogger, string, Exception> _failedToLocateDevelopmentCertificateFile;
    private static Action`3<ILogger, string, Exception> _failedToLoadDevelopmentCertificate;
    private static LoggerExtensions();
    [ExtensionAttribute]
public static void LocatedDevelopmentCertificate(ILogger logger, X509Certificate2 certificate);
    [ExtensionAttribute]
public static void UnableToLocateDevelopmentCertificate(ILogger logger);
    [ExtensionAttribute]
public static void FailedToLocateDevelopmentCertificateFile(ILogger logger, string certificatePath);
    [ExtensionAttribute]
public static void FailedToLoadDevelopmentCertificate(ILogger logger, string certificatePath);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingConnectionMiddleware : object {
    private ConnectionDelegate _next;
    private ILogger _logger;
    public LoggingConnectionMiddleware(ConnectionDelegate next, ILogger logger);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingConnectionMiddleware/<OnConnectionAsync>d__3")]
public Task OnConnectionAsync(ConnectionContext context);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingStream : Stream {
    private Stream _inner;
    private ILogger _logger;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public LoggingStream(Stream inner, ILogger logger);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> destination);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingStream/<ReadAsync>d__18")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingStream/<ReadAsync>d__19")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> source);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    private void Log(string method, ReadOnlySpan`1<byte> buffer);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    private Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, object state);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.MemoryPoolExtensions : object {
    [ExtensionAttribute]
public static int GetMinimumSegmentSize(MemoryPool`1<byte> pool);
    [ExtensionAttribute]
public static int GetMinimumAllocSize(MemoryPool`1<byte> pool);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ServerAddressesFeature : object {
    [CompilerGeneratedAttribute]
private ICollection`1<string> <Addresses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferHostingUrls>k__BackingField;
    public ICollection`1<string> Addresses { get; }
    public bool PreferHostingUrls { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<string> get_Addresses();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PreferHostingUrls();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PreferHostingUrls(bool value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ServiceContext : object {
    [CompilerGeneratedAttribute]
private IKestrelTrace <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeScheduler <Scheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpParser`1<Http1ParsingHandler> <HttpParser>k__BackingField;
    [CompilerGeneratedAttribute]
private ISystemClock <SystemClock>k__BackingField;
    [CompilerGeneratedAttribute]
private DateHeaderValueManager <DateHeaderValueManager>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionManager <ConnectionManager>k__BackingField;
    [CompilerGeneratedAttribute]
private Heartbeat <Heartbeat>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelServerOptions <ServerOptions>k__BackingField;
    public IKestrelTrace Log { get; public set; }
    public PipeScheduler Scheduler { get; public set; }
    public IHttpParser`1<Http1ParsingHandler> HttpParser { get; public set; }
    public ISystemClock SystemClock { get; public set; }
    public DateHeaderValueManager DateHeaderValueManager { get; public set; }
    public ConnectionManager ConnectionManager { get; public set; }
    public Heartbeat Heartbeat { get; public set; }
    public KestrelServerOptions ServerOptions { get; public set; }
    [CompilerGeneratedAttribute]
public IKestrelTrace get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(IKestrelTrace value);
    [CompilerGeneratedAttribute]
public PipeScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
public void set_Scheduler(PipeScheduler value);
    [CompilerGeneratedAttribute]
public IHttpParser`1<Http1ParsingHandler> get_HttpParser();
    [CompilerGeneratedAttribute]
public void set_HttpParser(IHttpParser`1<Http1ParsingHandler> value);
    [CompilerGeneratedAttribute]
public ISystemClock get_SystemClock();
    [CompilerGeneratedAttribute]
public void set_SystemClock(ISystemClock value);
    [CompilerGeneratedAttribute]
public DateHeaderValueManager get_DateHeaderValueManager();
    [CompilerGeneratedAttribute]
public void set_DateHeaderValueManager(DateHeaderValueManager value);
    [CompilerGeneratedAttribute]
public ConnectionManager get_ConnectionManager();
    [CompilerGeneratedAttribute]
public void set_ConnectionManager(ConnectionManager value);
    [CompilerGeneratedAttribute]
public Heartbeat get_Heartbeat();
    [CompilerGeneratedAttribute]
public void set_Heartbeat(Heartbeat value);
    [CompilerGeneratedAttribute]
public KestrelServerOptions get_ServerOptions();
    [CompilerGeneratedAttribute]
public void set_ServerOptions(KestrelServerOptions value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.TlsConnectionFeature : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <ClientCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <ApplicationProtocol>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherAlgorithmType <CipherAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CipherStrength>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmType <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HashStrength>k__BackingField;
    [CompilerGeneratedAttribute]
private ExchangeAlgorithmType <KeyExchangeAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyExchangeStrength>k__BackingField;
    public X509Certificate2 ClientCertificate { get; public set; }
    public ReadOnlyMemory`1<byte> ApplicationProtocol { get; public set; }
    public SslProtocols Protocol { get; public set; }
    public CipherAlgorithmType CipherAlgorithm { get; public set; }
    public int CipherStrength { get; public set; }
    public HashAlgorithmType HashAlgorithm { get; public set; }
    public int HashStrength { get; public set; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; public set; }
    public int KeyExchangeStrength { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual X509Certificate2 get_ClientCertificate();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClientCertificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public sealed virtual ReadOnlyMemory`1<byte> get_ApplicationProtocol();
    [CompilerGeneratedAttribute]
public void set_ApplicationProtocol(ReadOnlyMemory`1<byte> value);
    [CompilerGeneratedAttribute]
public sealed virtual SslProtocols get_Protocol();
    [CompilerGeneratedAttribute]
public void set_Protocol(SslProtocols value);
    [CompilerGeneratedAttribute]
public sealed virtual CipherAlgorithmType get_CipherAlgorithm();
    [CompilerGeneratedAttribute]
public void set_CipherAlgorithm(CipherAlgorithmType value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CipherStrength();
    [CompilerGeneratedAttribute]
public void set_CipherStrength(int value);
    [CompilerGeneratedAttribute]
public sealed virtual HashAlgorithmType get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_HashAlgorithm(HashAlgorithmType value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_HashStrength();
    [CompilerGeneratedAttribute]
public void set_HashStrength(int value);
    [CompilerGeneratedAttribute]
public sealed virtual ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    [CompilerGeneratedAttribute]
public void set_KeyExchangeAlgorithm(ExchangeAlgorithmType value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_KeyExchangeStrength();
    [CompilerGeneratedAttribute]
public void set_KeyExchangeStrength(int value);
    public sealed virtual Task`1<X509Certificate2> GetClientCertificateAsync(CancellationToken cancellationToken);
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer : object {
    private List`1<ValueTuple`2<IConnectionListener, Task>> _transports;
    private IServerAddressesFeature _serverAddresses;
    private IConnectionListenerFactory _transportFactory;
    private bool _hasStarted;
    private int _stopping;
    private TaskCompletionSource`1<object> _stoppedTcs;
    [CompilerGeneratedAttribute]
private IFeatureCollection <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceContext <ServiceContext>k__BackingField;
    public IFeatureCollection Features { get; }
    public KestrelServerOptions Options { get; }
    private ServiceContext ServiceContext { get; }
    private IKestrelTrace Trace { get; }
    private ConnectionManager ConnectionManager { get; }
    public KestrelServer(IOptions`1<KestrelServerOptions> options, IConnectionListenerFactory transportFactory, ILoggerFactory loggerFactory);
    internal KestrelServer(IConnectionListenerFactory transportFactory, ServiceContext serviceContext);
    private static ServiceContext CreateServiceContext(IOptions`1<KestrelServerOptions> options, ILoggerFactory loggerFactory);
    [CompilerGeneratedAttribute]
public sealed virtual IFeatureCollection get_Features();
    public KestrelServerOptions get_Options();
    [CompilerGeneratedAttribute]
private ServiceContext get_ServiceContext();
    private IKestrelTrace get_Trace();
    private ConnectionManager get_ConnectionManager();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer/<StartAsync>d__21`1")]
public sealed virtual Task StartAsync(IHttpApplication`1<TContext> application, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer/<StopAsync>d__22")]
public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void ValidateOptions();
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits : object {
    private Nullable`1<long> _maxResponseBufferSize;
    private Nullable`1<long> _maxRequestBufferSize;
    private int _maxRequestLineSize;
    private int _maxRequestHeadersTotalSize;
    private Nullable`1<long> _maxRequestBodySize;
    private int _maxRequestHeaderCount;
    private TimeSpan _keepAliveTimeout;
    private TimeSpan _requestHeadersTimeout;
    private Nullable`1<long> _maxConcurrentConnections;
    private Nullable`1<long> _maxConcurrentUpgradedConnections;
    [CompilerGeneratedAttribute]
private Http2Limits <Http2>k__BackingField;
    [CompilerGeneratedAttribute]
private MinDataRate <MinRequestBodyDataRate>k__BackingField;
    [CompilerGeneratedAttribute]
private MinDataRate <MinResponseDataRate>k__BackingField;
    public Nullable`1<long> MaxResponseBufferSize { get; public set; }
    public Nullable`1<long> MaxRequestBufferSize { get; public set; }
    public int MaxRequestLineSize { get; public set; }
    public int MaxRequestHeadersTotalSize { get; public set; }
    public int MaxRequestHeaderCount { get; public set; }
    public Nullable`1<long> MaxRequestBodySize { get; public set; }
    public TimeSpan KeepAliveTimeout { get; public set; }
    public TimeSpan RequestHeadersTimeout { get; public set; }
    public Nullable`1<long> MaxConcurrentConnections { get; public set; }
    public Nullable`1<long> MaxConcurrentUpgradedConnections { get; public set; }
    public Http2Limits Http2 { get; }
    public MinDataRate MinRequestBodyDataRate { get; public set; }
    public MinDataRate MinResponseDataRate { get; public set; }
    public Nullable`1<long> get_MaxResponseBufferSize();
    public void set_MaxResponseBufferSize(Nullable`1<long> value);
    public Nullable`1<long> get_MaxRequestBufferSize();
    public void set_MaxRequestBufferSize(Nullable`1<long> value);
    public int get_MaxRequestLineSize();
    public void set_MaxRequestLineSize(int value);
    public int get_MaxRequestHeadersTotalSize();
    public void set_MaxRequestHeadersTotalSize(int value);
    public int get_MaxRequestHeaderCount();
    public void set_MaxRequestHeaderCount(int value);
    public Nullable`1<long> get_MaxRequestBodySize();
    public void set_MaxRequestBodySize(Nullable`1<long> value);
    public TimeSpan get_KeepAliveTimeout();
    public void set_KeepAliveTimeout(TimeSpan value);
    public TimeSpan get_RequestHeadersTimeout();
    public void set_RequestHeadersTimeout(TimeSpan value);
    public Nullable`1<long> get_MaxConcurrentConnections();
    public void set_MaxConcurrentConnections(Nullable`1<long> value);
    public Nullable`1<long> get_MaxConcurrentUpgradedConnections();
    public void set_MaxConcurrentUpgradedConnections(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Http2Limits get_Http2();
    [CompilerGeneratedAttribute]
public MinDataRate get_MinRequestBodyDataRate();
    [CompilerGeneratedAttribute]
public void set_MinRequestBodyDataRate(MinDataRate value);
    [CompilerGeneratedAttribute]
public MinDataRate get_MinResponseDataRate();
    [CompilerGeneratedAttribute]
public void set_MinResponseDataRate(MinDataRate value);
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions : object {
    [CompilerGeneratedAttribute]
private List`1<ListenOptions> <ListenOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddServerHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSynchronousIO>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableStringReuse>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <ApplicationServices>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelServerLimits <Limits>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelConfigurationLoader <ConfigurationLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ListenOptions> <EndpointDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<HttpsConnectionAdapterOptions> <HttpsDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <DefaultCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDevCertLoaded>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Latin1RequestHeaders>k__BackingField;
    internal List`1<ListenOptions> ListenOptions { get; }
    public bool AddServerHeader { get; public set; }
    public bool AllowSynchronousIO { get; public set; }
    public bool DisableStringReuse { get; public set; }
    public IServiceProvider ApplicationServices { get; public set; }
    public KestrelServerLimits Limits { get; }
    public KestrelConfigurationLoader ConfigurationLoader { get; public set; }
    private Action`1<ListenOptions> EndpointDefaults { get; private set; }
    private Action`1<HttpsConnectionAdapterOptions> HttpsDefaults { get; private set; }
    internal X509Certificate2 DefaultCertificate { get; internal set; }
    internal bool IsDevCertLoaded { get; internal set; }
    internal bool Latin1RequestHeaders { get; internal set; }
    [CompilerGeneratedAttribute]
internal List`1<ListenOptions> get_ListenOptions();
    [CompilerGeneratedAttribute]
public bool get_AddServerHeader();
    [CompilerGeneratedAttribute]
public void set_AddServerHeader(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowSynchronousIO();
    [CompilerGeneratedAttribute]
public void set_AllowSynchronousIO(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableStringReuse();
    [CompilerGeneratedAttribute]
public void set_DisableStringReuse(bool value);
    [CompilerGeneratedAttribute]
public IServiceProvider get_ApplicationServices();
    [CompilerGeneratedAttribute]
public void set_ApplicationServices(IServiceProvider value);
    [CompilerGeneratedAttribute]
public KestrelServerLimits get_Limits();
    [CompilerGeneratedAttribute]
public KestrelConfigurationLoader get_ConfigurationLoader();
    [CompilerGeneratedAttribute]
public void set_ConfigurationLoader(KestrelConfigurationLoader value);
    [CompilerGeneratedAttribute]
private Action`1<ListenOptions> get_EndpointDefaults();
    [CompilerGeneratedAttribute]
private void set_EndpointDefaults(Action`1<ListenOptions> value);
    [CompilerGeneratedAttribute]
private Action`1<HttpsConnectionAdapterOptions> get_HttpsDefaults();
    [CompilerGeneratedAttribute]
private void set_HttpsDefaults(Action`1<HttpsConnectionAdapterOptions> value);
    [CompilerGeneratedAttribute]
internal X509Certificate2 get_DefaultCertificate();
    [CompilerGeneratedAttribute]
internal void set_DefaultCertificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
internal bool get_IsDevCertLoaded();
    [CompilerGeneratedAttribute]
internal void set_IsDevCertLoaded(bool value);
    [CompilerGeneratedAttribute]
internal bool get_Latin1RequestHeaders();
    [CompilerGeneratedAttribute]
internal void set_Latin1RequestHeaders(bool value);
    public void ConfigureEndpointDefaults(Action`1<ListenOptions> configureOptions);
    internal void ApplyEndpointDefaults(ListenOptions listenOptions);
    public void ConfigureHttpsDefaults(Action`1<HttpsConnectionAdapterOptions> configureOptions);
    internal void ApplyHttpsDefaults(HttpsConnectionAdapterOptions httpsOptions);
    internal void ApplyDefaultCert(HttpsConnectionAdapterOptions httpsOptions);
    private void EnsureDefaultCert();
    public KestrelConfigurationLoader Configure();
    public KestrelConfigurationLoader Configure(IConfiguration config);
    public void Listen(IPAddress address, int port);
    public void Listen(IPAddress address, int port, Action`1<ListenOptions> configure);
    public void Listen(IPEndPoint endPoint);
    public void Listen(IPEndPoint endPoint, Action`1<ListenOptions> configure);
    public void ListenLocalhost(int port);
    public void ListenLocalhost(int port, Action`1<ListenOptions> configure);
    public void ListenAnyIP(int port);
    public void ListenAnyIP(int port, Action`1<ListenOptions> configure);
    public void ListenUnixSocket(string socketPath);
    public void ListenUnixSocket(string socketPath, Action`1<ListenOptions> configure);
    public void ListenHandle(ulong handle);
    public void ListenHandle(ulong handle, Action`1<ListenOptions> configure);
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions : object {
    internal List`1<Func`2<ConnectionDelegate, ConnectionDelegate>> _middleware;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelServerOptions <KestrelServerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpProtocols <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHttp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTls>k__BackingField;
    internal EndPoint EndPoint { get; internal set; }
    public IPEndPoint IPEndPoint { get; }
    public string SocketPath { get; }
    public ulong FileHandle { get; }
    public KestrelServerOptions KestrelServerOptions { get; internal set; }
    public HttpProtocols Protocols { get; public set; }
    public IServiceProvider ApplicationServices { get; }
    internal string Scheme { get; }
    internal bool IsHttp { get; internal set; }
    internal bool IsTls { get; internal set; }
    internal ListenOptions(IPEndPoint endPoint);
    internal ListenOptions(string socketPath);
    internal ListenOptions(ulong fileHandle);
    internal ListenOptions(ulong fileHandle, FileHandleType handleType);
    [CompilerGeneratedAttribute]
internal EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
internal void set_EndPoint(EndPoint value);
    public IPEndPoint get_IPEndPoint();
    public string get_SocketPath();
    public ulong get_FileHandle();
    [CompilerGeneratedAttribute]
public KestrelServerOptions get_KestrelServerOptions();
    [CompilerGeneratedAttribute]
internal void set_KestrelServerOptions(KestrelServerOptions value);
    [CompilerGeneratedAttribute]
public HttpProtocols get_Protocols();
    [CompilerGeneratedAttribute]
public void set_Protocols(HttpProtocols value);
    public sealed virtual IServiceProvider get_ApplicationServices();
    internal string get_Scheme();
    [CompilerGeneratedAttribute]
internal bool get_IsHttp();
    [CompilerGeneratedAttribute]
internal void set_IsHttp(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsTls();
    [CompilerGeneratedAttribute]
internal void set_IsTls(bool value);
    internal virtual string GetDisplayName();
    public virtual string ToString();
    public sealed virtual IConnectionBuilder Use(Func`2<ConnectionDelegate, ConnectionDelegate> middleware);
    public sealed virtual ConnectionDelegate Build();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions/<BindAsync>d__39")]
internal virtual Task BindAsync(AddressBindContext context);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.LocalhostListenOptions : ListenOptions {
    internal LocalhostListenOptions(int port);
    internal virtual string GetDisplayName();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.LocalhostListenOptions/<BindAsync>d__2")]
internal virtual Task BindAsync(AddressBindContext context);
    internal ListenOptions Clone(IPAddress address);
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate : object {
    [CompilerGeneratedAttribute]
private double <BytesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <GracePeriod>k__BackingField;
    public double BytesPerSecond { get; }
    public TimeSpan GracePeriod { get; }
    public MinDataRate(double bytesPerSecond, TimeSpan gracePeriod);
    [CompilerGeneratedAttribute]
public double get_BytesPerSecond();
    [CompilerGeneratedAttribute]
public TimeSpan get_GracePeriod();
}
public class Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <IsHttps>k__BackingField;
    [CompilerGeneratedAttribute]
private ListenOptions <ListenOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpsConnectionAdapterOptions <HttpsOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigurationSection <ConfigSection>k__BackingField;
    public bool IsHttps { get; }
    public ListenOptions ListenOptions { get; }
    public HttpsConnectionAdapterOptions HttpsOptions { get; }
    public IConfigurationSection ConfigSection { get; }
    internal EndpointConfiguration(bool isHttps, ListenOptions listenOptions, HttpsConnectionAdapterOptions httpsOptions, IConfigurationSection configSection);
    [CompilerGeneratedAttribute]
public bool get_IsHttps();
    [CompilerGeneratedAttribute]
public ListenOptions get_ListenOptions();
    [CompilerGeneratedAttribute]
public HttpsConnectionAdapterOptions get_HttpsOptions();
    [CompilerGeneratedAttribute]
public IConfigurationSection get_ConfigSection();
}
public static class Microsoft.AspNetCore.Server.Kestrel.Https.CertificateLoader : object {
    private static string ServerAuthenticationOid;
    public static X509Certificate2 LoadFromStoreCert(string subject, string storeName, StoreLocation storeLocation, bool allowInvalid);
    internal static bool IsCertificateAllowedForServerAuth(X509Certificate2 certificate);
    internal static bool DoesCertificateHaveAnAccessiblePrivateKey(X509Certificate2 certificate);
    private static void DisposeCertificates(X509Certificate2Collection certificates, X509Certificate2 except);
}
public enum Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode : Enum {
    public int value__;
    public static ClientCertificateMode NoCertificate;
    public static ClientCertificateMode AllowCertificate;
    public static ClientCertificateMode RequireCertificate;
}
public class Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions : object {
    private TimeSpan _handshakeTimeout;
    [CompilerGeneratedAttribute]
private X509Certificate2 <ServerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<ConnectionContext, string, X509Certificate2> <ServerCertificateSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientCertificateMode <ClientCertificateMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<X509Certificate2, X509Chain, SslPolicyErrors, bool> <ClientCertificateValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <SslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpProtocols <HttpProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckCertificateRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<ConnectionContext, SslServerAuthenticationOptions> <OnAuthenticate>k__BackingField;
    public X509Certificate2 ServerCertificate { get; public set; }
    public Func`3<ConnectionContext, string, X509Certificate2> ServerCertificateSelector { get; public set; }
    public ClientCertificateMode ClientCertificateMode { get; public set; }
    public Func`4<X509Certificate2, X509Chain, SslPolicyErrors, bool> ClientCertificateValidation { get; public set; }
    public SslProtocols SslProtocols { get; public set; }
    internal HttpProtocols HttpProtocols { get; internal set; }
    public bool CheckCertificateRevocation { get; public set; }
    public Action`2<ConnectionContext, SslServerAuthenticationOptions> OnAuthenticate { get; public set; }
    public TimeSpan HandshakeTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public X509Certificate2 get_ServerCertificate();
    [CompilerGeneratedAttribute]
public void set_ServerCertificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public Func`3<ConnectionContext, string, X509Certificate2> get_ServerCertificateSelector();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateSelector(Func`3<ConnectionContext, string, X509Certificate2> value);
    [CompilerGeneratedAttribute]
public ClientCertificateMode get_ClientCertificateMode();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateMode(ClientCertificateMode value);
    [CompilerGeneratedAttribute]
public Func`4<X509Certificate2, X509Chain, SslPolicyErrors, bool> get_ClientCertificateValidation();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateValidation(Func`4<X509Certificate2, X509Chain, SslPolicyErrors, bool> value);
    [CompilerGeneratedAttribute]
public SslProtocols get_SslProtocols();
    [CompilerGeneratedAttribute]
public void set_SslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
internal HttpProtocols get_HttpProtocols();
    [CompilerGeneratedAttribute]
internal void set_HttpProtocols(HttpProtocols value);
    [CompilerGeneratedAttribute]
public bool get_CheckCertificateRevocation();
    [CompilerGeneratedAttribute]
public void set_CheckCertificateRevocation(bool value);
    public void AllowAnyClientCertificate();
    [CompilerGeneratedAttribute]
public Action`2<ConnectionContext, SslServerAuthenticationOptions> get_OnAuthenticate();
    [CompilerGeneratedAttribute]
public void set_OnAuthenticate(Action`2<ConnectionContext, SslServerAuthenticationOptions> value);
    public TimeSpan get_HandshakeTimeout();
    public void set_HandshakeTimeout(TimeSpan value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Https.Internal.HttpsConnectionMiddleware : object {
    private ConnectionDelegate _next;
    private HttpsConnectionAdapterOptions _options;
    private ILogger _logger;
    private X509Certificate2 _serverCertificate;
    private Func`3<ConnectionContext, string, X509Certificate2> _serverCertificateSelector;
    public HttpsConnectionMiddleware(ConnectionDelegate next, HttpsConnectionAdapterOptions options);
    public HttpsConnectionMiddleware(ConnectionDelegate next, HttpsConnectionAdapterOptions options, ILoggerFactory loggerFactory);
    public Task OnConnectionAsync(ConnectionContext context);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Https.Internal.HttpsConnectionMiddleware/<InnerOnConnectionAsync>d__8")]
private Task InnerOnConnectionAsync(ConnectionContext context);
    private static void EnsureCertificateIsAllowedForServerAuth(X509Certificate2 certificate);
    private static X509Certificate2 ConvertToX509Certificate2(X509Certificate certificate);
}
public class Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader : object {
    private bool _loaded;
    [CompilerGeneratedAttribute]
private KestrelServerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationReader <ConfigurationReader>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Action`1<EndpointConfiguration>> <EndpointConfigurations>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Action> <EndpointsToAdd>k__BackingField;
    public KestrelServerOptions Options { get; }
    public IConfiguration Configuration { get; }
    internal ConfigurationReader ConfigurationReader { get; }
    private IDictionary`2<string, Action`1<EndpointConfiguration>> EndpointConfigurations { get; }
    private IList`1<Action> EndpointsToAdd { get; }
    internal KestrelConfigurationLoader(KestrelServerOptions options, IConfiguration configuration);
    [CompilerGeneratedAttribute]
public KestrelServerOptions get_Options();
    [CompilerGeneratedAttribute]
public IConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
internal ConfigurationReader get_ConfigurationReader();
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Action`1<EndpointConfiguration>> get_EndpointConfigurations();
    [CompilerGeneratedAttribute]
private IList`1<Action> get_EndpointsToAdd();
    public KestrelConfigurationLoader Endpoint(string name, Action`1<EndpointConfiguration> configureOptions);
    public KestrelConfigurationLoader Endpoint(IPAddress address, int port);
    public KestrelConfigurationLoader Endpoint(IPAddress address, int port, Action`1<ListenOptions> configure);
    public KestrelConfigurationLoader Endpoint(IPEndPoint endPoint);
    public KestrelConfigurationLoader Endpoint(IPEndPoint endPoint, Action`1<ListenOptions> configure);
    public KestrelConfigurationLoader LocalhostEndpoint(int port);
    public KestrelConfigurationLoader LocalhostEndpoint(int port, Action`1<ListenOptions> configure);
    public KestrelConfigurationLoader AnyIPEndpoint(int port);
    public KestrelConfigurationLoader AnyIPEndpoint(int port, Action`1<ListenOptions> configure);
    public KestrelConfigurationLoader UnixSocketEndpoint(string socketPath);
    public KestrelConfigurationLoader UnixSocketEndpoint(string socketPath, Action`1<ListenOptions> configure);
    public KestrelConfigurationLoader HandleEndpoint(ulong handle);
    public KestrelConfigurationLoader HandleEndpoint(ulong handle, Action`1<ListenOptions> configure);
    internal void ApplyConfigurationDefaults(ListenOptions listenOptions);
    public void Load();
    private void LoadDefaultCert(ConfigurationReader configReader);
    private X509Certificate2 FindDeveloperCertificateFile(ConfigurationReader configReader, ILogger`1<KestrelServer> logger);
    private bool IsDevelopmentCertificate(X509Certificate2 certificate);
    private bool TryGetCertificatePath(String& path);
    private X509Certificate2 LoadCertificate(CertificateConfig certInfo, string endpointName);
    private static X509Certificate2 LoadFromStoreCert(CertificateConfig certInfo);
}
[ExtensionAttribute]
internal static class System.Buffers.BufferExtensions : object {
    private static int _maxULongByteLength;
    [ThreadStaticAttribute]
private static Byte[] _numericBytesScratch;
    private static Byte[] NumericBytesScratch { get; }
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> ToSpan(ReadOnlySequence`1& buffer);
    [ExtensionAttribute]
public static ArraySegment`1<byte> GetArray(Memory`1<byte> buffer);
    [ExtensionAttribute]
public static ArraySegment`1<byte> GetArray(ReadOnlyMemory`1<byte> memory);
    [ExtensionAttribute]
internal static void WriteAsciiNoValidation(BufferWriter`1& buffer, string data);
    [ExtensionAttribute]
internal static void WriteNumeric(BufferWriter`1& buffer, ulong number);
    [ExtensionAttribute]
private static void WriteNumericMultiWrite(BufferWriter`1& buffer, ulong number);
    [ExtensionAttribute]
private static void WriteAsciiMultiWrite(BufferWriter`1& buffer, string data);
    private static void EncodeAsciiCharsToBytes(Char* input, Byte* output, int length);
    private static Byte[] get_NumericBytesScratch();
    private static Byte[] CreateNumericBytesScratch();
}
internal class System.Buffers.BuffersThrowHelper : object {
    public static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument);
    private static string GetArgumentName(ExceptionArgument argument);
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsByRefLikeAttribute]
internal class System.Buffers.BufferWriter`1 : ValueType {
    private T _output;
    private Span`1<byte> _span;
    private int _buffered;
    private long _bytesCommitted;
    public Span`1<byte> Span { get; }
    public long BytesCommitted { get; }
    public BufferWriter`1(T output);
    public Span`1<byte> get_Span();
    public long get_BytesCommitted();
    public void Commit();
    public void Advance(int count);
    public void Write(ReadOnlySpan`1<byte> source);
    public void Ensure(int count);
    private void EnsureMore(int count);
    private void WriteMultiBuffer(ReadOnlySpan`1<byte> source);
}
[AttributeUsageAttribute("108")]
internal class System.Diagnostics.StackTraceHiddenAttribute : Attribute {
}
internal class System.IO.Pipelines.BufferSegment : ReadOnlySequenceSegment`1<byte> {
    private object _memoryOwner;
    private BufferSegment _next;
    private int _end;
    [CompilerGeneratedAttribute]
private Memory`1<byte> <AvailableMemory>k__BackingField;
    public int End { get; public set; }
    public BufferSegment NextSegment { get; public set; }
    internal object MemoryOwner { get; }
    public Memory`1<byte> AvailableMemory { get; private set; }
    public int Length { get; }
    public int WritableBytes { get; }
    public int get_End();
    public void set_End(int value);
    public BufferSegment get_NextSegment();
    public void set_NextSegment(BufferSegment value);
    public void SetOwnedMemory(IMemoryOwner`1<byte> memoryOwner);
    public void SetOwnedMemory(Byte[] arrayPoolBuffer);
    public void SetUnownedMemory(Memory`1<byte> memory);
    public void ResetMemory();
    internal object get_MemoryOwner();
    [CompilerGeneratedAttribute]
public Memory`1<byte> get_AvailableMemory();
    [CompilerGeneratedAttribute]
private void set_AvailableMemory(Memory`1<byte> value);
    public int get_Length();
    public int get_WritableBytes();
    public void SetNext(BufferSegment segment);
    internal static long GetLength(BufferSegment startSegment, int startIndex, BufferSegment endSegment, int endIndex);
    internal static long GetLength(long startPosition, BufferSegment endSegment, int endIndex);
}
internal class System.IO.Pipelines.BufferSegmentStack : ValueType {
    private SegmentAsValueType[] _array;
    private int _size;
    public int Count { get; }
    public BufferSegmentStack(int size);
    public int get_Count();
    public bool TryPop(BufferSegment& result);
    public void Push(BufferSegment item);
    private void PushWithResize(BufferSegment item);
}
