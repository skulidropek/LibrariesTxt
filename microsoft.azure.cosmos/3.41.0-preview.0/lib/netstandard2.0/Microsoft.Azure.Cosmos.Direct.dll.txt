internal static class AssemblyKeys : object {
    internal static string ProductPublicKey;
    internal static string TestPublicKey;
    internal static string MoqPublicKey;
    internal static string FakesPublicKey;
}
internal static class AssemblyRef : object {
    internal static string ProductPublicKey;
    internal static string TestPublicKey;
    internal static string MoqPublicKey;
    internal static string FakesPublicKey;
}
internal static class AssemblyVersionInfo : object {
    public static string AssemblyFileVersionString;
}
internal static class Azure.Core.ActivityExtensions : object {
    [CompilerGeneratedAttribute]
private static bool <SupportsActivitySource>k__BackingField;
    public static bool SupportsActivitySource { get; private set; }
    private static ActivityExtensions();
    [CompilerGeneratedAttribute]
public static bool get_SupportsActivitySource();
    [CompilerGeneratedAttribute]
private static void set_SupportsActivitySource(bool value);
    public static void ResetFeatureSwitch();
}
internal static class Azure.Core.AppContextSwitchHelper : object {
    [NullableContextAttribute("1")]
public static bool GetConfigValue(string appContexSwitchName, string environmentVariableName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.DiagnosticScope : ValueType {
    private static string AzureSdkScopeLabel;
    internal static string OpenTelemetrySchemaAttribute;
    internal static string OpenTelemetrySchemaVersion;
    private static object AzureSdkScopeValue;
    [NullableAttribute("2")]
private ActivityAdapter _activityAdapter;
    private bool _suppressNestedClientActivities;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    internal DiagnosticScope(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities);
    private static DiagnosticScope();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public void AddAttribute(string name, string value);
    public void AddIntegerAttribute(string name, int value);
    public void AddAttribute(string name, T value, Func`2<T, string> format);
    public void AddLink(string traceparent, string tracestate, IDictionary`2<string, string> attributes);
    public void Start();
    public void SetDisplayName(string displayName);
    public void SetStartTime(DateTime dateTime);
    public void SetTraceContext(string traceparent, string tracestate);
    public sealed virtual void Dispose();
    public void Failed(Exception exception);
    public void Failed(string errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.DiagnosticScopeFactory : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DiagnosticListener> _listeners;
    [NullableAttribute("2")]
private string _resourceProviderNamespace;
    [NullableAttribute("2")]
private DiagnosticListener _source;
    private bool _suppressNestedClientActivities;
    private bool _isStable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ActivitySource> ActivitySources;
    [CompilerGeneratedAttribute]
private bool <IsActivityEnabled>k__BackingField;
    public bool IsActivityEnabled { get; }
    public DiagnosticScopeFactory(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable);
    private static DiagnosticScopeFactory();
    [CompilerGeneratedAttribute]
public bool get_IsActivityEnabled();
    public DiagnosticScope CreateScope(string name, ActivityKind kind);
    private ActivitySource GetActivitySource(string ns, string name);
}
internal static class Microsoft.Azure.Cosmos.Core.Trace.DefaultTrace : object {
    public static Guid ProviderId;
    private static TraceSource TraceSourceInternal;
    private static bool IsListenerAdded;
    public static TraceSource TraceSource { get; public set; }
    private static DefaultTrace();
    public static TraceSource get_TraceSource();
    public static void set_TraceSource(TraceSource value);
    public static void InitEventListener();
    public static void Flush();
    public static void TraceVerbose(string message);
    public static void TraceVerbose(string format, Object[] args);
    public static void TraceInformation(string message);
    public static void TraceInformation(string format, Object[] args);
    public static void TraceWarning(string message);
    public static void TraceWarning(string format, Object[] args);
    public static void TraceError(string message);
    public static void TraceError(string format, Object[] args);
    public static void TraceCritical(string message);
    public static void TraceCritical(string format, Object[] args);
    public static void RemoveDefaultTraceListener();
    internal static void TraceMetrics(string name, Object[] values);
}
internal static class Microsoft.Azure.Cosmos.Core.Trace.EtwNativeInterop : object {
    internal static UInt32 EventRegister(Guid& providerId, IntPtr enableCallback, IntPtr callbackContext, ProviderHandle& registrationHandle);
    internal static UInt32 EventUnregister(IntPtr registrationHandle);
    public static UInt32 EventWriteString(ProviderHandle registrationHandle, byte level, long keywords, string message);
}
internal class Microsoft.Azure.Cosmos.Core.Trace.EtwTraceListener : TraceListener {
    public static int MaxEtwEventLength;
    private ProviderHandle providerHandle;
    [CompilerGeneratedAttribute]
private Guid <ProviderGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsThreadSafe>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LastReturnCode>k__BackingField;
    public Guid ProviderGuid { get; }
    public bool IsThreadSafe { get; }
    internal UInt32 LastReturnCode { get; private set; }
    public EtwTraceListener(Guid providerGuid, string name);
    [CompilerGeneratedAttribute]
public Guid get_ProviderGuid();
    [CompilerGeneratedAttribute]
public virtual bool get_IsThreadSafe();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    private void TraceInternal(TraceEventType eventType, string message);
    [CompilerGeneratedAttribute]
internal UInt32 get_LastReturnCode();
    [CompilerGeneratedAttribute]
private void set_LastReturnCode(UInt32 value);
    private bool IsFiltered(TraceEventCache eventCache, string source, TraceEventType eventType, int id);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
}
internal class Microsoft.Azure.Cosmos.Rntbd.BytesDeserializer : ValueType {
    private Memory`1<byte> metadata;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; private set; }
    public int Length { get; }
    public BytesDeserializer(Byte[] metadata, int length);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public int get_Length();
    public ushort ReadUInt16();
    public void AdvancePositionByUInt16();
    public byte ReadByte();
    public UInt32 ReadUInt32();
    public void AdvancePositionByUInt32();
    public int ReadInt32();
    public void AdvancePositionByInt32();
    public ulong ReadUInt64();
    public void AdvancePositionByUInt64();
    public long ReadInt64();
    public void AdvancePositionByInt64();
    public float ReadSingle();
    public void AdvancePositionBySingle();
    public double ReadDouble();
    public void AdvancePositionByDouble();
    public Guid ReadGuid();
    public void AdvancePositionByGuid();
    public ReadOnlyMemory`1<byte> ReadBytes(int length);
    public void AdvancePositionByBytes(int count);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class Microsoft.Azure.Cosmos.Rntbd.BytesSerializer : ValueType {
    private Span`1<byte> targetByteArray;
    private int position;
    public BytesSerializer(Byte[] targetByteArray, int length);
    public static Guid ReadGuidFromBytes(ArraySegment`1<byte> array);
    public static string GetStringFromBytes(ReadOnlyMemory`1<byte> memory);
    public static ReadOnlyMemory`1<byte> GetBytesForString(string toConvert, Request request);
    internal int GetPosition();
    internal static int GetSizeOfGuid();
    public void Write(Byte[] value);
    public void Write(UInt32 value);
    public void Write(int value);
    public void Write(long value);
    public void Write(ulong value);
    public void Write(float value);
    public void Write(double value);
    public void Write(ushort value);
    public void Write(byte value);
    public int Write(Guid value);
    public void Write(ArraySegment`1<byte> value);
    public void Write(ReadOnlyMemory`1<byte> valueToWrite);
    public void Write(ReadOnlySpan`1<byte> valueToWrite);
    private void WriteValue(T value, int sizeT);
}
internal class Microsoft.Azure.Cosmos.Rntbd.RntbdOpenConnectionHandler : object {
    private TransportClient transportClient;
    private SemaphoreSlim semaphore;
    private static TimeSpan SemaphoreAcquireTimeout;
    private bool disposed;
    public RntbdOpenConnectionHandler(TransportClient transportClient);
    private static RntbdOpenConnectionHandler();
    [AsyncStateMachineAttribute("Microsoft.Azure.Cosmos.Rntbd.RntbdOpenConnectionHandler/<TryOpenRntbdChannelsAsync>d__5")]
public sealed virtual Task TryOpenRntbdChannelsAsync(IEnumerable`1<TransportAddressUri> addresses);
    public sealed virtual void Dispose();
}
internal class Microsoft.Azure.Cosmos.Rntbd.RntbdStreamReader : object {
    private static int BufferSize;
    private Stream stream;
    private Byte[] buffer;
    private int offset;
    private int length;
    internal int AvailableByteCount { get; }
    public RntbdStreamReader(Stream stream);
    internal int get_AvailableByteCount();
    public sealed virtual void Dispose();
    public ValueTask`1<int> ReadAsync(Byte[] payload, int offset, int count);
    public ValueTask`1<int> ReadAsync(MemoryStream payload, int count);
    [AsyncStateMachineAttribute("Microsoft.Azure.Cosmos.Rntbd.RntbdStreamReader/<PopulateBytesAndReadAsync>d__11")]
private ValueTask`1<int> PopulateBytesAndReadAsync(Byte[] payload, int offset, int count);
    [AsyncStateMachineAttribute("Microsoft.Azure.Cosmos.Rntbd.RntbdStreamReader/<PopulateBytesAndReadAsync>d__12")]
private ValueTask`1<int> PopulateBytesAndReadAsync(MemoryStream payload, int count);
    private int CopyFromAvailableBytes(Byte[] payload, int offset, int count);
    private int CopyFromAvailableBytes(MemoryStream payload, int count);
    [AsyncStateMachineAttribute("Microsoft.Azure.Cosmos.Rntbd.RntbdStreamReader/<ReadStreamAsync>d__15")]
private Task`1<int> ReadStreamAsync(Byte[] buffer, int offset, int count);
}
internal class Microsoft.Azure.Documents.Address : Resource {
    [JsonPropertyAttribute]
public bool IsAuxiliary { get; internal set; }
    [JsonPropertyAttribute]
public bool IsPrimary { get; internal set; }
    [JsonPropertyAttribute]
public string Protocol { get; internal set; }
    [JsonPropertyAttribute]
public string LogicalUri { get; internal set; }
    [JsonPropertyAttribute]
public string PhysicalUri { get; internal set; }
    [JsonPropertyAttribute]
public string PartitionIndex { get; internal set; }
    [JsonPropertyAttribute]
public string PartitionKeyRangeId { get; internal set; }
    public bool get_IsAuxiliary();
    internal void set_IsAuxiliary(bool value);
    public bool get_IsPrimary();
    internal void set_IsPrimary(bool value);
    public string get_Protocol();
    internal void set_Protocol(string value);
    public string get_LogicalUri();
    internal void set_LogicalUri(string value);
    public string get_PhysicalUri();
    internal void set_PhysicalUri(string value);
    public string get_PartitionIndex();
    internal void set_PartitionIndex(string value);
    public string get_PartitionKeyRangeId();
    internal void set_PartitionKeyRangeId(string value);
}
internal class Microsoft.Azure.Documents.AddressCacheToken : object {
    public PartitionKeyRangeIdentity PartitionKeyRangeIdentity;
    [CompilerGeneratedAttribute]
private Uri <ServiceEndpoint>k__BackingField;
    public Uri ServiceEndpoint { get; private set; }
    public AddressCacheToken(PartitionKeyRangeIdentity partitionKeyRangeIdentity, Uri serviceEndpoint);
    [CompilerGeneratedAttribute]
public Uri get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
private void set_ServiceEndpoint(Uri value);
    public virtual bool Equals(object obj);
    public bool Equals(AddressCacheToken token);
    public virtual int GetHashCode();
}
internal class Microsoft.Azure.Documents.AddressEnumerator : object {
    [ThreadStaticAttribute]
private static Random random;
    private static int GenerateNextRandom(int start, int maxValue);
    public sealed virtual IEnumerable`1<TransportAddressUri> GetTransportAddresses(IReadOnlyList`1<TransportAddressUri> transportAddressUris, Lazy`1<HashSet`1<TransportAddressUri>> failedEndpoints, bool replicaAddressValidationEnabled);
    private IEnumerable`1<TransportAddressUri> GetTransportAddresses(IReadOnlyList`1<TransportAddressUri> transportAddressUris);
    private static IEnumerable`1<TransportAddressUri> ReorderReplicasByHealthStatus(IEnumerable`1<TransportAddressUri> randomPermutation, Lazy`1<HashSet`1<TransportAddressUri>> lazyFailedReplicasPerRequest, bool replicaAddressValidationEnabled);
    [IteratorStateMachineAttribute("Microsoft.Azure.Documents.AddressEnumerator/<ReorderAddressesWhenReplicaValidationEnabled>d__7")]
private static IEnumerable`1<TransportAddressUri> ReorderAddressesWhenReplicaValidationEnabled(IEnumerable`1<TransportAddressUri> addresses, HashSet`1<TransportAddressUri> failedReplicasPerRequest);
    [IteratorStateMachineAttribute("Microsoft.Azure.Documents.AddressEnumerator/<MoveFailedReplicasToTheEnd>d__8")]
private static IEnumerable`1<TransportAddressUri> MoveFailedReplicasToTheEnd(IEnumerable`1<TransportAddressUri> addresses, HashSet`1<TransportAddressUri> failedReplicasPerRequest);
    private static HealthStatus GetEffectiveStatus(TransportAddressUri addressUri, HashSet`1<TransportAddressUri> failedEndpoints);
}
internal class Microsoft.Azure.Documents.AddressInformation : object {
    private Nullable`1<int> lazyHashCode;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrimary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAuxiliary>k__BackingField;
    [CompilerGeneratedAttribute]
private Protocol <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PhysicalUri>k__BackingField;
    public bool IsPublic { get; }
    public bool IsPrimary { get; }
    public bool IsAuxiliary { get; }
    public Protocol Protocol { get; }
    public string PhysicalUri { get; }
    public AddressInformation(string physicalUri, bool isPublic, bool isPrimary, Protocol protocol, bool isAuxiliary);
    public AddressInformation(string physicalUri, bool isPublic, bool isPrimary, Protocol protocol);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public bool get_IsPrimary();
    [CompilerGeneratedAttribute]
public bool get_IsAuxiliary();
    [CompilerGeneratedAttribute]
public Protocol get_Protocol();
    [CompilerGeneratedAttribute]
public string get_PhysicalUri();
    public sealed virtual int CompareTo(AddressInformation other);
    public sealed virtual bool Equals(AddressInformation other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static int <GetHashCode>g__Calculate|20_0(AddressInformation self);
}
internal class Microsoft.Azure.Documents.AddressSelector : object {
    private IAddressResolver addressResolver;
    private Protocol protocol;
    public AddressSelector(IAddressResolver addressResolver, Protocol protocol);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.AddressSelector/<ResolveAllTransportAddressUriAsync>d__3")]
public Task`1<ValueTuple`2<IReadOnlyList`1<TransportAddressUri>, IReadOnlyList`1<string>>> ResolveAllTransportAddressUriAsync(DocumentServiceRequest request, bool includePrimary, bool forceRefresh);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.AddressSelector/<ResolvePrimaryTransportAddressUriAsync>d__4")]
public Task`1<TransportAddressUri> ResolvePrimaryTransportAddressUriAsync(DocumentServiceRequest request, bool forceAddressRefresh);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.AddressSelector/<ResolveAddressesAsync>d__5")]
public Task`1<PerProtocolPartitionAddressInformation> ResolveAddressesAsync(DocumentServiceRequest request, bool forceAddressRefresh);
    public void StartBackgroundAddressRefresh(DocumentServiceRequest request);
}
[FlagsAttribute]
internal enum Microsoft.Azure.Documents.ApiType : Enum {
    public int value__;
    public static ApiType None;
    public static ApiType MongoDB;
    public static ApiType Gremlin;
    public static ApiType Cassandra;
    public static ApiType Table;
    public static ApiType Sql;
    public static ApiType Etcd;
    public static ApiType GremlinV2;
}
internal class Microsoft.Azure.Documents.Attachment : Resource {
    [JsonPropertyAttribute]
public string ContentType { get; public set; }
    [JsonPropertyAttribute]
public string MediaLink { get; public set; }
    public string get_ContentType();
    public void set_ContentType(string value);
    public string get_MediaLink();
    public void set_MediaLink(string value);
    internal static Attachment FromObject(object attachment, JsonSerializerSettings settings);
    private object GetProperty(string propertyName, Type returnType);
    private object SetProperty(string propertyName, object value);
    private T AsType();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
internal enum Microsoft.Azure.Documents.AuthorizationTokenType : Enum {
    public int value__;
    public static AuthorizationTokenType Invalid;
    public static AuthorizationTokenType PrimaryMasterKey;
    public static AuthorizationTokenType PrimaryReadonlyMasterKey;
    public static AuthorizationTokenType SecondaryMasterKey;
    public static AuthorizationTokenType SecondaryReadonlyMasterKey;
    public static AuthorizationTokenType SystemReadOnly;
    public static AuthorizationTokenType SystemReadWrite;
    public static AuthorizationTokenType SystemAll;
    public static AuthorizationTokenType ResourceToken;
    public static AuthorizationTokenType ComputeGatewayKey;
    public static AuthorizationTokenType AadToken;
    public static AuthorizationTokenType CompoundToken;
    public static AuthorizationTokenType SasToken;
    public static AuthorizationTokenType TokenCredential;
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.AuthorizationTokenTypeExtensions : object {
    private static Dictionary`2<int, string> CodeNameMap;
    private static AuthorizationTokenTypeExtensions();
    [ExtensionAttribute]
public static string ToAuthorizationTokenTypeString(AuthorizationTokenType code);
}
internal static class Microsoft.Azure.Documents.BackoffRetryUtility`1 : object {
    public static string ExceptionSourceToIgnoreForIgnoreForRetry;
    public static Task`1<T> ExecuteAsync(Func`1<Task`1<T>> callbackMethod, IRetryPolicy retryPolicy, CancellationToken cancellationToken, Action`1<Exception> preRetryCallback);
    public static Task`1<T> ExecuteAsync(Func`3<TParam, CancellationToken, Task`1<T>> callbackMethod, IRetryPolicy retryPolicy, TParam param, CancellationToken cancellationToken, Action`1<Exception> preRetryCallback);
    public static Task`1<T> ExecuteAsync(Func`2<TPolicyArg1, Task`1<T>> callbackMethod, IRetryPolicy`1<TPolicyArg1> retryPolicy, CancellationToken cancellationToken, Action`1<Exception> preRetryCallback);
    public static Task`1<T> ExecuteAsync(Func`1<Task`1<T>> callbackMethod, IRetryPolicy retryPolicy, Func`1<Task`1<T>> inBackoffAlternateCallbackMethod, TimeSpan minBackoffForInBackoffCallback, CancellationToken cancellationToken, Action`1<Exception> preRetryCallback);
    public static Task`1<T> ExecuteAsync(Func`2<TPolicyArg1, Task`1<T>> callbackMethod, IRetryPolicy`1<TPolicyArg1> retryPolicy, Func`2<TPolicyArg1, Task`1<T>> inBackoffAlternateCallbackMethod, TimeSpan minBackoffForInBackoffCallback, CancellationToken cancellationToken, Action`1<Exception> preRetryCallback);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.BackoffRetryUtility`1/<ExecuteRetryAsync>d__6`2")]
private static Task`1<T> ExecuteRetryAsync(Func`1<Task`1<T>> callbackMethod, Func`3<TParam, CancellationToken, Task`1<T>> callbackMethodWithParam, Func`2<TPolicy, Task`1<T>> callbackMethodWithPolicy, TParam param, IRetryPolicy retryPolicy, IRetryPolicy`1<TPolicy> retryPolicyWithArg, Func`1<Task`1<T>> inBackoffAlternateCallbackMethod, Func`2<TPolicy, Task`1<T>> inBackoffAlternateCallbackMethodWithPolicy, TimeSpan minBackoffForInBackoffCallback, CancellationToken cancellationToken, Action`1<Exception> preRetryCallback);
}
internal class Microsoft.Azure.Documents.BadRequestException : DocumentClientException {
    public BadRequestException(string message);
    public BadRequestException(string message, bool rawErrorMessageOnly);
    public BadRequestException(string message, HttpResponseHeaders headers, Uri requestUri);
    public BadRequestException(string message, INameValueCollection headers, Uri requestUri);
    public BadRequestException(string message, Exception innerException);
    public BadRequestException(Exception innerException);
    public BadRequestException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri, bool rawErrorMessageOnly);
    private BadRequestException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
}
internal static class Microsoft.Azure.Documents.BarrierRequestHelper : object {
    private static bool OldBarrierRequestHandlingEnabledDefault;
    private static int extensiveLsnGapThreshold;
    private static int highLsnGapThreshold;
    private static int mediumLsnGapThreshold;
    private static TimeSpan extensiveLsnGapDelayBetweenWriteBarrierCalls;
    private static TimeSpan highLsnGapDelayBetweenWriteBarrierCalls;
    private static TimeSpan mediumLsnGapDelayBetweenWriteBarrierCalls;
    private static bool isOldBarrierRequestHandlingEnabled;
    internal static bool IsOldBarrierRequestHandlingEnabled { get; }
    private static BarrierRequestHelper();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.BarrierRequestHelper/<CreateAsync>d__8")]
public static Task`1<DocumentServiceRequest> CreateAsync(DocumentServiceRequest request, IAuthorizationTokenProvider authorizationTokenProvider, Nullable`1<long> targetLsn, Nullable`1<long> targetGlobalCommittedLsn);
    internal static bool get_IsOldBarrierRequestHandlingEnabled();
    internal static bool IsCollectionHeadBarrierRequest(ResourceType resourceType, OperationType operationType);
    internal static bool ShouldDelayBetweenHeadRequests(TimeSpan previousHeadRequestLatency, IList`1<ReferenceCountedDisposable`1<StoreResult>> responses, TimeSpan minDelay, TimeSpan& delay);
    private static TimeSpan GetDelayBetweenHeadRequests(int minLSNGap);
}
internal static class Microsoft.Azure.Documents.BitUtils : object {
    private static Int32[] tab64;
    private static BitUtils();
    public static long GetMostSignificantBit(long x);
    public static int FloorLog2(ulong value);
    public static bool IsPowerOf2(ulong x);
    public static int GetMostSignificantBitIndex(ulong x);
    public static long GetLeastSignificantBit(long x);
    public static int GetLeastSignificantBitIndex(long x);
    public static bool BitTestAndReset64(long input, int index, Int64& output);
}
internal class Microsoft.Azure.Documents.BoundingBoxSpec : JsonSerializable {
    [JsonPropertyAttribute]
public double Xmin { get; public set; }
    [JsonPropertyAttribute]
public double Ymin { get; public set; }
    [JsonPropertyAttribute]
public double Xmax { get; public set; }
    [JsonPropertyAttribute]
public double Ymax { get; public set; }
    public double get_Xmin();
    public void set_Xmin(double value);
    public double get_Ymin();
    public void set_Ymin(double value);
    public double get_Xmax();
    public void set_Xmax(double value);
    public double get_Ymax();
    public void set_Ymax(double value);
    public sealed virtual object Clone();
    internal virtual void Validate();
}
internal class Microsoft.Azure.Documents.BufferProvider : object {
    private ArrayPool`1<byte> arrayPool;
    public DisposableBuffer GetBuffer(int desiredLength);
}
internal class Microsoft.Azure.Documents.ByokConfig : JsonSerializable {
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public ByokStatus ByokStatus { get; public set; }
    public ByokConfig(ByokStatus byokStatus);
    public ByokStatus get_ByokStatus();
    public void set_ByokStatus(ByokStatus value);
}
internal enum Microsoft.Azure.Documents.ByokStatus : Enum {
    public int value__;
    public static ByokStatus None;
    public static ByokStatus Active;
}
internal class Microsoft.Azure.Documents.ChangeFeedPolicy : JsonSerializable {
    [JsonPropertyAttribute]
public TimeSpan RetentionDuration { get; public set; }
    public TimeSpan get_RetentionDuration();
    public void set_RetentionDuration(TimeSpan value);
    public sealed virtual object Clone();
}
internal class Microsoft.Azure.Documents.Client.AccessCondition : object {
    [CompilerGeneratedAttribute]
private AccessConditionType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public AccessConditionType Type { get; public set; }
    public string Condition { get; public set; }
    [CompilerGeneratedAttribute]
public AccessConditionType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(AccessConditionType value);
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
internal enum Microsoft.Azure.Documents.Client.AccessConditionType : Enum {
    public int value__;
    public static AccessConditionType IfMatch;
    public static AccessConditionType IfNoneMatch;
}
internal class Microsoft.Azure.Documents.Client.DocumentResponse`1 : ResourceResponseBase {
    private TDocument document;
    private JsonSerializerSettings settings;
    public TDocument Document { get; }
    public DocumentResponse`1(TDocument document);
    internal DocumentResponse`1(DocumentServiceResponse response, JsonSerializerSettings settings);
    public sealed virtual TDocument get_Document();
    public static TDocument op_Implicit(DocumentResponse`1<TDocument> source);
}
internal interface Microsoft.Azure.Documents.Client.IDocumentResponse`1 {
    public TDocument Document { get; }
    public abstract virtual TDocument get_Document();
}
internal interface Microsoft.Azure.Documents.Client.IResourceResponse`1 {
    public TResource Resource { get; }
    public abstract virtual TResource get_Resource();
}
internal interface Microsoft.Azure.Documents.Client.IResourceResponseBase {
    public long DatabaseQuota { get; }
    public long DatabaseUsage { get; }
    public long CollectionQuota { get; }
    public long CollectionUsage { get; }
    public long UserQuota { get; }
    public long UserUsage { get; }
    public long PermissionQuota { get; }
    public long PermissionUsage { get; }
    public long CollectionSizeQuota { get; }
    public long CollectionSizeUsage { get; }
    public long DocumentQuota { get; }
    public long DocumentUsage { get; }
    public long StoredProceduresQuota { get; }
    public long StoredProceduresUsage { get; }
    public long TriggersQuota { get; }
    public long TriggersUsage { get; }
    public long UserDefinedFunctionsQuota { get; }
    public long UserDefinedFunctionsUsage { get; }
    public string ActivityId { get; }
    public string SessionToken { get; }
    public HttpStatusCode StatusCode { get; }
    public string MaxResourceQuota { get; }
    public string CurrentResourceQuotaUsage { get; }
    public Stream ResponseStream { get; }
    public double RequestCharge { get; }
    public NameValueCollection ResponseHeaders { get; }
    public string ContentLocation { get; }
    public long IndexTransformationProgress { get; }
    public long LazyIndexingProgress { get; }
    public abstract virtual long get_DatabaseQuota();
    public abstract virtual long get_DatabaseUsage();
    public abstract virtual long get_CollectionQuota();
    public abstract virtual long get_CollectionUsage();
    public abstract virtual long get_UserQuota();
    public abstract virtual long get_UserUsage();
    public abstract virtual long get_PermissionQuota();
    public abstract virtual long get_PermissionUsage();
    public abstract virtual long get_CollectionSizeQuota();
    public abstract virtual long get_CollectionSizeUsage();
    public abstract virtual long get_DocumentQuota();
    public abstract virtual long get_DocumentUsage();
    public abstract virtual long get_StoredProceduresQuota();
    public abstract virtual long get_StoredProceduresUsage();
    public abstract virtual long get_TriggersQuota();
    public abstract virtual long get_TriggersUsage();
    public abstract virtual long get_UserDefinedFunctionsQuota();
    public abstract virtual long get_UserDefinedFunctionsUsage();
    public abstract virtual string get_ActivityId();
    public abstract virtual string get_SessionToken();
    public abstract virtual HttpStatusCode get_StatusCode();
    public abstract virtual string get_MaxResourceQuota();
    public abstract virtual string get_CurrentResourceQuotaUsage();
    public abstract virtual Stream get_ResponseStream();
    public abstract virtual double get_RequestCharge();
    public abstract virtual NameValueCollection get_ResponseHeaders();
    public abstract virtual string get_ContentLocation();
    public abstract virtual long get_IndexTransformationProgress();
    public abstract virtual long get_LazyIndexingProgress();
}
internal enum Microsoft.Azure.Documents.Client.Protocol : Enum {
    public int value__;
    public static Protocol Https;
    public static Protocol Tcp;
}
internal class Microsoft.Azure.Documents.Client.RequestOptions : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <PreTriggerInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <PostTriggerInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessCondition <AccessCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexingDirective> <IndexingDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <ConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ResourceTokenExpirySeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OfferType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <OfferThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OfferEnableRUPerMinuteThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <BackgroundTaskMaxAllowedThroughputPercent>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionKey <PartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableScriptLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnlyScript>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSnapshotDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PopulateQuotaInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableRUPerMinuteUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerSettings <JsonSerializerSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PopulatePartitionKeyRangeStatistics>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PopulateUniqueIndexReIndexProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PopulateAnalyticalMigrationProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PopulateBYOKEncryptionProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RemoteStorageType> <RemoteStorageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKeyRangeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceDatabaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceCollectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RestorePointInTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PopulateRestoreStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PopulateCapacityType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExcludeSystemProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InsertSystemPartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MergeStaticId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveFullContent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceSideBySideIndexMigration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollectionTruncate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClientEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PopulateUserStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SharedOfferThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PriorityLevel> <PriorityLevel>k__BackingField;
    public IList`1<string> PreTriggerInclude { get; public set; }
    public IList`1<string> PostTriggerInclude { get; public set; }
    public AccessCondition AccessCondition { get; public set; }
    public Nullable`1<IndexingDirective> IndexingDirective { get; public set; }
    public Nullable`1<ConsistencyLevel> ConsistencyLevel { get; public set; }
    public string SessionToken { get; public set; }
    public Nullable`1<int> ResourceTokenExpirySeconds { get; public set; }
    public string OfferType { get; public set; }
    public Nullable`1<int> OfferThroughput { get; public set; }
    public bool OfferEnableRUPerMinuteThroughput { get; public set; }
    internal Nullable`1<double> BackgroundTaskMaxAllowedThroughputPercent { get; internal set; }
    public PartitionKey PartitionKey { get; public set; }
    public bool EnableScriptLogging { get; public set; }
    internal bool IsReadOnlyScript { get; internal set; }
    internal bool IncludeSnapshotDirectories { get; internal set; }
    public bool PopulateQuotaInfo { get; public set; }
    public bool DisableRUPerMinuteUsage { get; public set; }
    public JsonSerializerSettings JsonSerializerSettings { get; public set; }
    public bool PopulatePartitionKeyRangeStatistics { get; public set; }
    internal bool PopulateUniqueIndexReIndexProgress { get; internal set; }
    internal bool PopulateAnalyticalMigrationProgress { get; internal set; }
    internal bool PopulateBYOKEncryptionProgress { get; internal set; }
    internal Nullable`1<RemoteStorageType> RemoteStorageType { get; internal set; }
    internal string PartitionKeyRangeId { get; internal set; }
    internal string SourceDatabaseId { get; internal set; }
    internal string SourceCollectionId { get; internal set; }
    internal Nullable`1<long> RestorePointInTime { get; internal set; }
    internal bool PopulateRestoreStatus { get; internal set; }
    internal bool PopulateCapacityType { get; internal set; }
    internal Nullable`1<bool> ExcludeSystemProperties { get; internal set; }
    internal bool InsertSystemPartitionKey { get; internal set; }
    internal string MergeStaticId { get; internal set; }
    internal bool PreserveFullContent { get; internal set; }
    internal bool ForceSideBySideIndexMigration { get; internal set; }
    internal bool CollectionTruncate { get; internal set; }
    internal bool IsClientEncrypted { get; internal set; }
    internal bool PopulateUserStrings { get; internal set; }
    [ObsoleteAttribute("Deprecated")]
public Nullable`1<int> SharedOfferThroughput { get; public set; }
    internal Nullable`1<PriorityLevel> PriorityLevel { get; internal set; }
    [CompilerGeneratedAttribute]
public IList`1<string> get_PreTriggerInclude();
    [CompilerGeneratedAttribute]
public void set_PreTriggerInclude(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_PostTriggerInclude();
    [CompilerGeneratedAttribute]
public void set_PostTriggerInclude(IList`1<string> value);
    [CompilerGeneratedAttribute]
public AccessCondition get_AccessCondition();
    [CompilerGeneratedAttribute]
public void set_AccessCondition(AccessCondition value);
    [CompilerGeneratedAttribute]
public Nullable`1<IndexingDirective> get_IndexingDirective();
    [CompilerGeneratedAttribute]
public void set_IndexingDirective(Nullable`1<IndexingDirective> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ConsistencyLevel> get_ConsistencyLevel();
    [CompilerGeneratedAttribute]
public void set_ConsistencyLevel(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public string get_SessionToken();
    [CompilerGeneratedAttribute]
public void set_SessionToken(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ResourceTokenExpirySeconds();
    [CompilerGeneratedAttribute]
public void set_ResourceTokenExpirySeconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_OfferType();
    [CompilerGeneratedAttribute]
public void set_OfferType(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_OfferThroughput();
    [CompilerGeneratedAttribute]
public void set_OfferThroughput(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_OfferEnableRUPerMinuteThroughput();
    [CompilerGeneratedAttribute]
public void set_OfferEnableRUPerMinuteThroughput(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<double> get_BackgroundTaskMaxAllowedThroughputPercent();
    [CompilerGeneratedAttribute]
internal void set_BackgroundTaskMaxAllowedThroughputPercent(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public PartitionKey get_PartitionKey();
    [CompilerGeneratedAttribute]
public void set_PartitionKey(PartitionKey value);
    [CompilerGeneratedAttribute]
public bool get_EnableScriptLogging();
    [CompilerGeneratedAttribute]
public void set_EnableScriptLogging(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsReadOnlyScript();
    [CompilerGeneratedAttribute]
internal void set_IsReadOnlyScript(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IncludeSnapshotDirectories();
    [CompilerGeneratedAttribute]
internal void set_IncludeSnapshotDirectories(bool value);
    [CompilerGeneratedAttribute]
public bool get_PopulateQuotaInfo();
    [CompilerGeneratedAttribute]
public void set_PopulateQuotaInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableRUPerMinuteUsage();
    [CompilerGeneratedAttribute]
public void set_DisableRUPerMinuteUsage(bool value);
    [CompilerGeneratedAttribute]
public JsonSerializerSettings get_JsonSerializerSettings();
    [CompilerGeneratedAttribute]
public void set_JsonSerializerSettings(JsonSerializerSettings value);
    [CompilerGeneratedAttribute]
public bool get_PopulatePartitionKeyRangeStatistics();
    [CompilerGeneratedAttribute]
public void set_PopulatePartitionKeyRangeStatistics(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PopulateUniqueIndexReIndexProgress();
    [CompilerGeneratedAttribute]
internal void set_PopulateUniqueIndexReIndexProgress(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PopulateAnalyticalMigrationProgress();
    [CompilerGeneratedAttribute]
internal void set_PopulateAnalyticalMigrationProgress(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PopulateBYOKEncryptionProgress();
    [CompilerGeneratedAttribute]
internal void set_PopulateBYOKEncryptionProgress(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<RemoteStorageType> get_RemoteStorageType();
    [CompilerGeneratedAttribute]
internal void set_RemoteStorageType(Nullable`1<RemoteStorageType> value);
    [CompilerGeneratedAttribute]
internal string get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
internal void set_PartitionKeyRangeId(string value);
    [CompilerGeneratedAttribute]
internal string get_SourceDatabaseId();
    [CompilerGeneratedAttribute]
internal void set_SourceDatabaseId(string value);
    [CompilerGeneratedAttribute]
internal string get_SourceCollectionId();
    [CompilerGeneratedAttribute]
internal void set_SourceCollectionId(string value);
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_RestorePointInTime();
    [CompilerGeneratedAttribute]
internal void set_RestorePointInTime(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
internal bool get_PopulateRestoreStatus();
    [CompilerGeneratedAttribute]
internal void set_PopulateRestoreStatus(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PopulateCapacityType();
    [CompilerGeneratedAttribute]
internal void set_PopulateCapacityType(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_ExcludeSystemProperties();
    [CompilerGeneratedAttribute]
internal void set_ExcludeSystemProperties(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal bool get_InsertSystemPartitionKey();
    [CompilerGeneratedAttribute]
internal void set_InsertSystemPartitionKey(bool value);
    [CompilerGeneratedAttribute]
internal string get_MergeStaticId();
    [CompilerGeneratedAttribute]
internal void set_MergeStaticId(string value);
    [CompilerGeneratedAttribute]
internal bool get_PreserveFullContent();
    [CompilerGeneratedAttribute]
internal void set_PreserveFullContent(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ForceSideBySideIndexMigration();
    [CompilerGeneratedAttribute]
internal void set_ForceSideBySideIndexMigration(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CollectionTruncate();
    [CompilerGeneratedAttribute]
internal void set_CollectionTruncate(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsClientEncrypted();
    [CompilerGeneratedAttribute]
internal void set_IsClientEncrypted(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PopulateUserStrings();
    [CompilerGeneratedAttribute]
internal void set_PopulateUserStrings(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SharedOfferThroughput();
    [CompilerGeneratedAttribute]
public void set_SharedOfferThroughput(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<PriorityLevel> get_PriorityLevel();
    [CompilerGeneratedAttribute]
internal void set_PriorityLevel(Nullable`1<PriorityLevel> value);
}
internal class Microsoft.Azure.Documents.Client.ResourceResponse`1 : ResourceResponseBase {
    private TResource resource;
    private ITypeResolver`1<TResource> typeResolver;
    public TResource Resource { get; }
    public ResourceResponse`1(TResource resource);
    internal ResourceResponse`1(DocumentServiceResponse response, ITypeResolver`1<TResource> typeResolver);
    public sealed virtual TResource get_Resource();
    public static TResource op_Implicit(ResourceResponse`1<TResource> source);
}
internal abstract class Microsoft.Azure.Documents.Client.ResourceResponseBase : object {
    internal DocumentServiceResponse response;
    private Dictionary`2<string, long> usageHeaders;
    private Dictionary`2<string, long> quotaHeaders;
    public long DatabaseQuota { get; }
    public long DatabaseUsage { get; }
    public long CollectionQuota { get; }
    public long CollectionUsage { get; }
    public long UserQuota { get; }
    public long UserUsage { get; }
    public long PermissionQuota { get; }
    public long PermissionUsage { get; }
    public long CollectionSizeQuota { get; }
    public long CollectionSizeUsage { get; }
    public long DocumentQuota { get; }
    public long DocumentUsage { get; }
    public long StoredProceduresQuota { get; }
    public long StoredProceduresUsage { get; }
    public long TriggersQuota { get; }
    public long TriggersUsage { get; }
    public long UserDefinedFunctionsQuota { get; }
    public long UserDefinedFunctionsUsage { get; }
    internal long DocumentCount { get; }
    public string ActivityId { get; }
    public string SessionToken { get; }
    public HttpStatusCode StatusCode { get; }
    public string MaxResourceQuota { get; }
    public string CurrentResourceQuotaUsage { get; }
    public Stream ResponseStream { get; }
    public double RequestCharge { get; }
    public bool IsRUPerMinuteUsed { get; }
    public NameValueCollection ResponseHeaders { get; }
    internal INameValueCollection Headers { get; }
    public string ContentLocation { get; }
    public long IndexTransformationProgress { get; }
    public long LazyIndexingProgress { get; }
    public TimeSpan RequestLatency { get; }
    public string RequestDiagnosticsString { get; }
    internal IClientSideRequestStatistics RequestStatistics { get; }
    internal ResourceResponseBase(DocumentServiceResponse response);
    public sealed virtual long get_DatabaseQuota();
    public sealed virtual long get_DatabaseUsage();
    public sealed virtual long get_CollectionQuota();
    public sealed virtual long get_CollectionUsage();
    public sealed virtual long get_UserQuota();
    public sealed virtual long get_UserUsage();
    public sealed virtual long get_PermissionQuota();
    public sealed virtual long get_PermissionUsage();
    public sealed virtual long get_CollectionSizeQuota();
    public sealed virtual long get_CollectionSizeUsage();
    public sealed virtual long get_DocumentQuota();
    public sealed virtual long get_DocumentUsage();
    public sealed virtual long get_StoredProceduresQuota();
    public sealed virtual long get_StoredProceduresUsage();
    public sealed virtual long get_TriggersQuota();
    public sealed virtual long get_TriggersUsage();
    public sealed virtual long get_UserDefinedFunctionsQuota();
    public sealed virtual long get_UserDefinedFunctionsUsage();
    internal long get_DocumentCount();
    public sealed virtual string get_ActivityId();
    public sealed virtual string get_SessionToken();
    public sealed virtual HttpStatusCode get_StatusCode();
    public sealed virtual string get_MaxResourceQuota();
    public sealed virtual string get_CurrentResourceQuotaUsage();
    public sealed virtual Stream get_ResponseStream();
    public sealed virtual double get_RequestCharge();
    public bool get_IsRUPerMinuteUsed();
    public sealed virtual NameValueCollection get_ResponseHeaders();
    internal INameValueCollection get_Headers();
    public sealed virtual string get_ContentLocation();
    public sealed virtual long get_IndexTransformationProgress();
    public sealed virtual long get_LazyIndexingProgress();
    public TimeSpan get_RequestLatency();
    public string get_RequestDiagnosticsString();
    internal IClientSideRequestStatistics get_RequestStatistics();
    internal long GetCurrentQuotaHeader(string headerName);
    internal long GetMaxQuotaHeader(string headerName);
    private void PopulateQuotaHeader(string headerMaxQuota, string headerCurrentUsage);
}
internal class Microsoft.Azure.Documents.ClientEncryptionIncludedPath : JsonSerializable {
    [JsonPropertyAttribute]
public string Path { get; public set; }
    [JsonPropertyAttribute]
public string ClientEncryptionKeyId { get; public set; }
    [JsonPropertyAttribute]
public string EncryptionType { get; public set; }
    [JsonPropertyAttribute]
public string EncryptionAlgorithm { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public string get_ClientEncryptionKeyId();
    public void set_ClientEncryptionKeyId(string value);
    public string get_EncryptionType();
    public void set_EncryptionType(string value);
    public string get_EncryptionAlgorithm();
    public void set_EncryptionAlgorithm(string value);
}
internal class Microsoft.Azure.Documents.ClientEncryptionKey : Resource {
    private KeyWrapMetadata keyWrapMetadata;
    [JsonPropertyAttribute]
internal string EncryptionAlgorithm { get; internal set; }
    [JsonPropertyAttribute]
internal Byte[] WrappedDataEncryptionKey { get; internal set; }
    [JsonPropertyAttribute]
internal KeyWrapMetadata KeyWrapMetadata { get; internal set; }
    internal string get_EncryptionAlgorithm();
    internal void set_EncryptionAlgorithm(string value);
    internal Byte[] get_WrappedDataEncryptionKey();
    internal void set_WrappedDataEncryptionKey(Byte[] value);
    internal KeyWrapMetadata get_KeyWrapMetadata();
    internal void set_KeyWrapMetadata(KeyWrapMetadata value);
    internal virtual void OnSave();
}
internal class Microsoft.Azure.Documents.ClientEncryptionPolicy : JsonSerializable {
    private Collection`1<ClientEncryptionIncludedPath> includedPaths;
    [JsonPropertyAttribute]
public Collection`1<ClientEncryptionIncludedPath> IncludedPaths { get; public set; }
    public Collection`1<ClientEncryptionIncludedPath> get_IncludedPaths();
    public void set_IncludedPaths(Collection`1<ClientEncryptionIncludedPath> value);
    internal virtual void OnSave();
}
internal class Microsoft.Azure.Documents.ClientSideRequestStatistics : object {
    private static SystemUsageMonitor systemUsageMonitor;
    private static SystemUsageRecorder systemRecorder;
    private static TimeSpan SystemUsageRecordInterval;
    private static string EnableCpuMonitorConfig;
    private static int MaxSupplementalRequestsForToString;
    private static bool enableCpuMonitorFlag;
    private DateTime requestStartTime;
    private Nullable`1<DateTime> requestEndTime;
    private object lockObject;
    private object requestEndTimeLock;
    private List`1<StoreResponseStatistics> responseStatisticsList;
    private List`1<StoreResponseStatistics> supplementalResponseStatisticsList;
    private Dictionary`2<string, AddressResolutionStatistics> addressResolutionStatistics;
    private Lazy`1<List`1<HttpResponseStatistics>> httpResponseStatisticsList;
    private SystemUsageHistory systemUsageHistory;
    [CompilerGeneratedAttribute]
private List`1<TransportAddressUri> <ContactedReplicas>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<TransportAddressUri> <FailedReplicas>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ValueTuple`2<string, Uri>> <RegionsContacted>k__BackingField;
    public List`1<TransportAddressUri> ContactedReplicas { get; public set; }
    public HashSet`1<TransportAddressUri> FailedReplicas { get; private set; }
    public HashSet`1<ValueTuple`2<string, Uri>> RegionsContacted { get; private set; }
    public Nullable`1<TimeSpan> RequestLatency { get; }
    public Nullable`1<bool> IsCpuHigh { get; }
    public Nullable`1<bool> IsCpuThreadStarvation { get; }
    private static ClientSideRequestStatistics();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<TransportAddressUri> get_ContactedReplicas();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContactedReplicas(List`1<TransportAddressUri> value);
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<TransportAddressUri> get_FailedReplicas();
    [CompilerGeneratedAttribute]
private void set_FailedReplicas(HashSet`1<TransportAddressUri> value);
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<ValueTuple`2<string, Uri>> get_RegionsContacted();
    [CompilerGeneratedAttribute]
private void set_RegionsContacted(HashSet`1<ValueTuple`2<string, Uri>> value);
    public sealed virtual Nullable`1<TimeSpan> get_RequestLatency();
    public sealed virtual Nullable`1<bool> get_IsCpuHigh();
    public sealed virtual Nullable`1<bool> get_IsCpuThreadStarvation();
    internal static void DisableCpuMonitor();
    public sealed virtual void RecordRequest(DocumentServiceRequest request);
    public sealed virtual void RecordResponse(DocumentServiceRequest request, StoreResult storeResult, DateTime startTimeUtc, DateTime endTimeUtc);
    public sealed virtual void RecordException(DocumentServiceRequest request, Exception exception, DateTime startTime, DateTime endTimeUtc);
    public sealed virtual string RecordAddressResolutionStart(Uri targetEndpoint);
    public sealed virtual void RecordAddressResolutionEnd(string identifier);
    public sealed virtual void RecordHttpResponse(HttpRequestMessage request, HttpResponseMessage response, ResourceType resourceType, DateTime requestStartTimeUtc);
    public sealed virtual void RecordHttpException(HttpRequestMessage request, Exception exception, ResourceType resourceType, DateTime requestStartTimeUtc);
    private void UpdateRequestEndTime(DateTime requestEndTimeUtc);
    private void UpdateSystemUsageHistory();
    public virtual string ToString();
    public sealed virtual void AppendToBuilder(StringBuilder stringBuilder);
}
internal class Microsoft.Azure.Documents.CloneableStream : Stream {
    private MemoryStream internalStream;
    private bool allowUnsafeDataAccess;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public CloneableStream(MemoryStream internalStream, bool allowUnsafeDataAccess);
    public CloneableStream Clone();
    private sealed virtual override object System.ICloneable.Clone();
    private MemoryStream CloneStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public ArraySegment`1<byte> GetBuffer();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    public void WriteTo(Stream target);
    public void CopyBufferTo(Byte[] buffer, int offset);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private static MemoryStream ConvertToExportableMemoryStream(MemoryStream mediaStream);
}
internal class Microsoft.Azure.Documents.CMKMetadataInfo : JsonSerializable {
    [JsonPropertyAttribute]
public string KeyVaultKeyUri { get; public set; }
    [JsonPropertyAttribute]
public string DefaultIdentity { get; public set; }
    [JsonPropertyAttribute]
public string MsiClientId { get; public set; }
    [JsonPropertyAttribute]
public string MsiClientSecretEncrypted { get; public set; }
    [JsonPropertyAttribute]
public string WrappedDek { get; public set; }
    public string get_KeyVaultKeyUri();
    public void set_KeyVaultKeyUri(string value);
    public string get_DefaultIdentity();
    public void set_DefaultIdentity(string value);
    public string get_MsiClientId();
    public void set_MsiClientId(string value);
    public string get_MsiClientSecretEncrypted();
    public void set_MsiClientSecretEncrypted(string value);
    public string get_WrappedDek();
    public void set_WrappedDek(string value);
    public sealed virtual object Clone();
}
internal class Microsoft.Azure.Documents.CollectionBackupPolicy : JsonSerializable {
    [JsonPropertyAttribute]
public CollectionBackupType CollectionBackupType { get; public set; }
    public CollectionBackupType get_CollectionBackupType();
    public void set_CollectionBackupType(CollectionBackupType value);
    public sealed virtual object Clone();
}
internal enum Microsoft.Azure.Documents.CollectionBackupType : Enum {
    public int value__;
    public static CollectionBackupType Invalid;
    public static CollectionBackupType Continuous;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Azure.Documents.Collections.DictionaryNameValueCollection : object {
    private static StringComparer defaultStringComparer;
    private Dictionary`2<string, CompositeValue> dictionary;
    private CompositeValue nullValue;
    private NameValueCollection nvc;
    public IEnumerable`1<string> Keys { get; }
    public string Item { get; public set; }
    public DictionaryNameValueCollection(StringComparer comparer);
    public DictionaryNameValueCollection(int capacity);
    private DictionaryNameValueCollection(int capacity, StringComparer comparer);
    public DictionaryNameValueCollection(INameValueCollection c);
    public DictionaryNameValueCollection(NameValueCollection c);
    private static DictionaryNameValueCollection();
    public sealed virtual void Add(string key, string value);
    public sealed virtual void Add(INameValueCollection c);
    public sealed virtual void Set(string key, string value);
    public sealed virtual string Get(string key);
    public sealed virtual String[] GetValues(string key);
    public sealed virtual void Remove(string key);
    public sealed virtual void Clear();
    [IteratorStateMachineAttribute("Microsoft.Azure.Documents.Collections.DictionaryNameValueCollection/<get_Keys>d__18")]
public IEnumerable`1<string> get_Keys();
    public sealed virtual int Count();
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual INameValueCollection Clone();
    public sealed virtual String[] AllKeys();
    private sealed virtual override IEnumerable`1<string> Microsoft.Azure.Documents.Collections.INameValueCollection.Keys();
    public sealed virtual NameValueCollection ToNameValueCollection();
}
[DefaultMemberAttribute("Item")]
internal interface Microsoft.Azure.Documents.Collections.INameValueCollection {
    public string Item { get; public set; }
    public abstract virtual void Add(string key, string value);
    public abstract virtual void Set(string key, string value);
    public abstract virtual string Get(string key);
    public abstract virtual string get_Item(string key);
    public abstract virtual void set_Item(string key, string value);
    public abstract virtual void Remove(string key);
    public abstract virtual void Clear();
    public abstract virtual int Count();
    public abstract virtual INameValueCollection Clone();
    public abstract virtual void Add(INameValueCollection collection);
    public abstract virtual String[] GetValues(string key);
    public abstract virtual String[] AllKeys();
    public abstract virtual IEnumerable`1<string> Keys();
    public abstract virtual NameValueCollection ToNameValueCollection();
}
internal interface Microsoft.Azure.Documents.Collections.INameValueCollectionFactory {
    public abstract virtual INameValueCollection CreateNewNameValueCollection();
    public abstract virtual INameValueCollection CreateNewNameValueCollection(int capacity);
    public abstract virtual INameValueCollection CreateNewNameValueCollection(StringComparer comparer);
    public abstract virtual INameValueCollection CreateNewNameValueCollection(NameValueCollection collection);
    public abstract virtual INameValueCollection CreateNewNameValueCollection(INameValueCollection collection);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Azure.Documents.Collections.NameValueCollectionWrapper : object {
    private NameValueCollection collection;
    public string Item { get; public set; }
    public NameValueCollectionWrapper(int capacity);
    public NameValueCollectionWrapper(StringComparer comparer);
    public NameValueCollectionWrapper(NameValueCollectionWrapper values);
    public NameValueCollectionWrapper(NameValueCollection collection);
    public NameValueCollectionWrapper(INameValueCollection collection);
    public static NameValueCollectionWrapper Create(NameValueCollection collection);
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual void Add(INameValueCollection c);
    public sealed virtual void Add(string key, string value);
    public sealed virtual INameValueCollection Clone();
    public sealed virtual string Get(string key);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual String[] GetValues(string key);
    public sealed virtual void Remove(string key);
    public sealed virtual void Clear();
    public sealed virtual int Count();
    public sealed virtual void Set(string key, string value);
    public sealed virtual String[] AllKeys();
    [IteratorStateMachineAttribute("Microsoft.Azure.Documents.Collections.NameValueCollectionWrapper/<Keys>d__22")]
public sealed virtual IEnumerable`1<string> Keys();
    public sealed virtual NameValueCollection ToNameValueCollection();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Azure.Documents.Collections.RequestNameValueCollection : object {
    private static StringComparer DefaultStringComparer;
    private Dictionary`2<string, string> notCommonHeaders;
    private NameValueCollection nameValueCollection;
    [CompilerGeneratedAttribute]
private string <A_IM>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AddResourcePropertiesToResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllowDocumentReadsInOfflineRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllowRestoreParamsUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllowTentativeWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Authorization>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BinaryId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BinaryPassthroughRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BindReplicaDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuilderClientIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CanCharge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CanOfferReplaceComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CanThrottle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeFeedStartFullFidelityIfNoneMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeFeedWireFormatVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientIpAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientRetryAttemptCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionChildResourceContentLimitInKB>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionChildResourceNameLimitInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionPartitionIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionRemoteStorageSecurityIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionRid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionServiceIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionTruncate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentSerializationFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Continuation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelatedActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CosmosGatewayTransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisableRUPerMinuteUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EffectivePartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EmitVerboseTracesInQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnableConflictResolutionPolicyUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnableCrossPartitionQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnableDynamicRidRangeAllocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnableLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnableLowPrecisionOrderBy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnableScanInQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndEpk>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntityId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnumerationDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExcludeSystemProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FanoutOperationState>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilterBySchemaResourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ForceDatabaseAccountUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ForceQueryScan>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ForceSideBySideIndexMigration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GatewaySignature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GetAllPartitionKeyStatistics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HighPriorityForcedBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IfMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IfModifiedSince>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IfNoneMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IgnoreSystemLoweringMaxThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IncludePhysicalPartitionThroughputInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IncludeTentativeWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexingDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IntendedCollectionRid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsAutoScaleRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsBatchAtomic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsBatchOrdered>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsCassandraAlterTypeRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsClientEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsContinuationExpected>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsFanoutRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsInternalServerlessRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsMaterializedViewBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsMaterializedViewSourceSchemaReplaceBatchRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsMigratedFixedCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsOfferStorageRefreshRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsReadOnlyScript>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsRequestNotAuthorized>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsRetriedWriteRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsRUPerGBEnforcementRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsServerlessStorageRefreshRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsThroughputCapRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsUserRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MaxPollingIntervalMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MergeCheckPointGLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MergeStaticId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MigrateCollectionDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MigrateOfferToAutopilot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MigrateOfferToManualThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NoRetryOn449StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OfferReplaceRURedistribution>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OptimisticDirectExecute>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParallelizeCrossPartitionQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKeyRangeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionResourceFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateAnalyticalMigrationProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateByokEncryptionProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateCapacityType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateCollectionThroughputInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateCurrentPartitionThroughputInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateDocumentRecordCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateHighestTentativeWriteLLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateIndexMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateIndexMetricsV2>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateLogStoreInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateMinGLSNForDocumentOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateOldestActiveSchemaId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulatePartitionStatistics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateQueryMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateQuotaInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateResourceCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateUnflushedMergeEntryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateUniqueIndexReIndexProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopulateUserStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PostTriggerExclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PostTriggerInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreserveFullContent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreTriggerExclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreTriggerInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrimaryMasterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrimaryReadonlyKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PriorityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProfileRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PruneCollectionSchemas>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RbacAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RbacResource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RbacUserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReadFeedKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemainingTimeInMsOnClientRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteStorageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestedCollectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceSchemaName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceTokenExpiry>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseContinuationTokenLimitInKB>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RestoreMetadataFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RestoreParams>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RetriableWriteRequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RetriableWriteRequestStartTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SchemaHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SchemaId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SchemaOwnerRid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SDKSupportedCapabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecondaryMasterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecondaryReadonlyKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SetMasterResourcesDeletionPending>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShareThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShouldBatchContinueOnError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShouldReturnCurrentServerDateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SkipAdjustThroughputFractionsForOfferReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SkipRefreshDatabaseAccountConfigs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SkipThroughputCapValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceCollectionIfMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SqlQueryForPartitionKeyExtraction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartEpk>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupportedQueryFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupportedSerializationFormats>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupportSpatialLegacyCoordinates>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SystemDocumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SystemRestoreOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetGlobalCommittedLsn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetLsn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeToLiveInSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TraceParent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TraceState>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransactionCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransactionFirstRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransportRequestID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TruncateMergeLogRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueIndexNameEncodingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueIndexReIndexingState>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UpdateMaxThroughputEverProvisioned>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UpdateOfferStateToPending>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UpdateOfferStateToRestorePending>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UseArchivalPartition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UsePolygonsSmallerThanAHemisphere>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UseSystemBudget>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UseUserBackgroundBudget>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XDate>k__BackingField;
    public string A_IM { get; public set; }
    public string ActivityId { get; public set; }
    public string AddResourcePropertiesToResponse { get; public set; }
    public string AllowDocumentReadsInOfflineRegion { get; public set; }
    public string AllowRestoreParamsUpdate { get; public set; }
    public string AllowTentativeWrites { get; public set; }
    public string Authorization { get; public set; }
    public string BinaryId { get; public set; }
    public string BinaryPassthroughRequest { get; public set; }
    public string BindReplicaDirective { get; public set; }
    public string BuilderClientIdentifier { get; public set; }
    public string CanCharge { get; public set; }
    public string CanOfferReplaceComplete { get; public set; }
    public string CanThrottle { get; public set; }
    public string ChangeFeedStartFullFidelityIfNoneMatch { get; public set; }
    public string ChangeFeedWireFormatVersion { get; public set; }
    public string ClientIpAddress { get; public set; }
    public string ClientRetryAttemptCount { get; public set; }
    public string CollectionChildResourceContentLimitInKB { get; public set; }
    public string CollectionChildResourceNameLimitInBytes { get; public set; }
    public string CollectionPartitionIndex { get; public set; }
    public string CollectionRemoteStorageSecurityIdentifier { get; public set; }
    public string CollectionRid { get; public set; }
    public string CollectionServiceIndex { get; public set; }
    public string CollectionTruncate { get; public set; }
    public string ConsistencyLevel { get; public set; }
    public string ContentSerializationFormat { get; public set; }
    public string Continuation { get; public set; }
    public string CorrelatedActivityId { get; public set; }
    public string CosmosGatewayTransactionId { get; public set; }
    public string DisableRUPerMinuteUsage { get; public set; }
    public string EffectivePartitionKey { get; public set; }
    public string EmitVerboseTracesInQuery { get; public set; }
    public string EnableConflictResolutionPolicyUpdate { get; public set; }
    public string EnableCrossPartitionQuery { get; public set; }
    public string EnableDynamicRidRangeAllocation { get; public set; }
    public string EnableLogging { get; public set; }
    public string EnableLowPrecisionOrderBy { get; public set; }
    public string EnableScanInQuery { get; public set; }
    public string EndEpk { get; public set; }
    public string EndId { get; public set; }
    public string EntityId { get; public set; }
    public string EnumerationDirection { get; public set; }
    public string ExcludeSystemProperties { get; public set; }
    public string FanoutOperationState { get; public set; }
    public string FilterBySchemaResourceId { get; public set; }
    public string ForceDatabaseAccountUpdate { get; public set; }
    public string ForceQueryScan { get; public set; }
    public string ForceSideBySideIndexMigration { get; public set; }
    public string GatewaySignature { get; public set; }
    public string GetAllPartitionKeyStatistics { get; public set; }
    public string HighPriorityForcedBackup { get; public set; }
    public string HttpDate { get; public set; }
    public string IfMatch { get; public set; }
    public string IfModifiedSince { get; public set; }
    public string IfNoneMatch { get; public set; }
    public string IgnoreSystemLoweringMaxThroughput { get; public set; }
    public string IncludePhysicalPartitionThroughputInfo { get; public set; }
    public string IncludeTentativeWrites { get; public set; }
    public string IndexingDirective { get; public set; }
    public string IntendedCollectionRid { get; public set; }
    public string IsAutoScaleRequest { get; public set; }
    public string IsBatchAtomic { get; public set; }
    public string IsBatchOrdered { get; public set; }
    public string IsCassandraAlterTypeRequest { get; public set; }
    public string IsClientEncrypted { get; public set; }
    public string IsContinuationExpected { get; public set; }
    public string IsFanoutRequest { get; public set; }
    public string IsInternalServerlessRequest { get; public set; }
    public string IsMaterializedViewBuild { get; public set; }
    public string IsMaterializedViewSourceSchemaReplaceBatchRequest { get; public set; }
    public string IsMigratedFixedCollection { get; public set; }
    public string IsOfferStorageRefreshRequest { get; public set; }
    public string IsReadOnlyScript { get; public set; }
    public string IsRequestNotAuthorized { get; public set; }
    public string IsRetriedWriteRequest { get; public set; }
    public string IsRUPerGBEnforcementRequest { get; public set; }
    public string IsServerlessStorageRefreshRequest { get; public set; }
    public string IsThroughputCapRequest { get; public set; }
    public string IsUserRequest { get; public set; }
    public string MaxPollingIntervalMilliseconds { get; public set; }
    public string MergeCheckPointGLSN { get; public set; }
    public string MergeStaticId { get; public set; }
    public string MigrateCollectionDirective { get; public set; }
    public string MigrateOfferToAutopilot { get; public set; }
    public string MigrateOfferToManualThroughput { get; public set; }
    public string NoRetryOn449StatusCode { get; public set; }
    public string OfferReplaceRURedistribution { get; public set; }
    public string OptimisticDirectExecute { get; public set; }
    public string PageSize { get; public set; }
    public string ParallelizeCrossPartitionQuery { get; public set; }
    public string PartitionCount { get; public set; }
    public string PartitionKey { get; public set; }
    public string PartitionKeyRangeId { get; public set; }
    public string PartitionResourceFilter { get; public set; }
    public string PopulateAnalyticalMigrationProgress { get; public set; }
    public string PopulateByokEncryptionProgress { get; public set; }
    public string PopulateCapacityType { get; public set; }
    public string PopulateCollectionThroughputInfo { get; public set; }
    public string PopulateCurrentPartitionThroughputInfo { get; public set; }
    public string PopulateDocumentRecordCount { get; public set; }
    public string PopulateHighestTentativeWriteLLSN { get; public set; }
    public string PopulateIndexMetrics { get; public set; }
    public string PopulateIndexMetricsV2 { get; public set; }
    public string PopulateLogStoreInfo { get; public set; }
    public string PopulateMinGLSNForDocumentOperations { get; public set; }
    public string PopulateOldestActiveSchemaId { get; public set; }
    public string PopulatePartitionStatistics { get; public set; }
    public string PopulateQueryMetrics { get; public set; }
    public string PopulateQuotaInfo { get; public set; }
    public string PopulateResourceCount { get; public set; }
    public string PopulateUnflushedMergeEntryCount { get; public set; }
    public string PopulateUniqueIndexReIndexProgress { get; public set; }
    public string PopulateUserStrings { get; public set; }
    public string PostTriggerExclude { get; public set; }
    public string PostTriggerInclude { get; public set; }
    public string Prefer { get; public set; }
    public string PreserveFullContent { get; public set; }
    public string PreTriggerExclude { get; public set; }
    public string PreTriggerInclude { get; public set; }
    public string PrimaryMasterKey { get; public set; }
    public string PrimaryReadonlyKey { get; public set; }
    public string PriorityLevel { get; public set; }
    public string ProfileRequest { get; public set; }
    public string PruneCollectionSchemas { get; public set; }
    public string QueryVersion { get; public set; }
    public string RbacAction { get; public set; }
    public string RbacResource { get; public set; }
    public string RbacUserId { get; public set; }
    public string ReadFeedKeyType { get; public set; }
    public string RemainingTimeInMsOnClientRequest { get; public set; }
    public string RemoteStorageType { get; public set; }
    public string RequestedCollectionType { get; public set; }
    public string ResourceId { get; public set; }
    public string ResourceSchemaName { get; public set; }
    public string ResourceTokenExpiry { get; public set; }
    public string ResourceTypes { get; public set; }
    public string ResponseContinuationTokenLimitInKB { get; public set; }
    public string RestoreMetadataFilter { get; public set; }
    public string RestoreParams { get; public set; }
    public string RetriableWriteRequestId { get; public set; }
    public string RetriableWriteRequestStartTimestamp { get; public set; }
    public string SchemaHash { get; public set; }
    public string SchemaId { get; public set; }
    public string SchemaOwnerRid { get; public set; }
    public string SDKSupportedCapabilities { get; public set; }
    public string SecondaryMasterKey { get; public set; }
    public string SecondaryReadonlyKey { get; public set; }
    public string SessionToken { get; public set; }
    public string SetMasterResourcesDeletionPending { get; public set; }
    public string ShareThroughput { get; public set; }
    public string ShouldBatchContinueOnError { get; public set; }
    public string ShouldReturnCurrentServerDateTime { get; public set; }
    public string SkipAdjustThroughputFractionsForOfferReplace { get; public set; }
    public string SkipRefreshDatabaseAccountConfigs { get; public set; }
    public string SkipThroughputCapValidation { get; public set; }
    public string SourceCollectionIfMatch { get; public set; }
    public string SqlQueryForPartitionKeyExtraction { get; public set; }
    public string StartEpk { get; public set; }
    public string StartId { get; public set; }
    public string SupportedQueryFeatures { get; public set; }
    public string SupportedSerializationFormats { get; public set; }
    public string SupportSpatialLegacyCoordinates { get; public set; }
    public string SystemDocumentType { get; public set; }
    public string SystemRestoreOperation { get; public set; }
    public string TargetGlobalCommittedLsn { get; public set; }
    public string TargetLsn { get; public set; }
    public string TimeToLiveInSeconds { get; public set; }
    public string TraceParent { get; public set; }
    public string TraceState { get; public set; }
    public string TransactionCommit { get; public set; }
    public string TransactionFirstRequest { get; public set; }
    public string TransactionId { get; public set; }
    public string TransportRequestID { get; public set; }
    public string TruncateMergeLogRequest { get; public set; }
    public string UniqueIndexNameEncodingMode { get; public set; }
    public string UniqueIndexReIndexingState { get; public set; }
    public string UpdateMaxThroughputEverProvisioned { get; public set; }
    public string UpdateOfferStateToPending { get; public set; }
    public string UpdateOfferStateToRestorePending { get; public set; }
    public string UseArchivalPartition { get; public set; }
    public string UsePolygonsSmallerThanAHemisphere { get; public set; }
    public string UseSystemBudget { get; public set; }
    public string UseUserBackgroundBudget { get; public set; }
    public string Version { get; public set; }
    public string XDate { get; public set; }
    public string Item { get; public set; }
    public RequestNameValueCollection(INameValueCollection nameValueCollection);
    public RequestNameValueCollection(IDictionary`2<string, string> requestHeaders);
    private static RequestNameValueCollection();
    [CompilerGeneratedAttribute]
public string get_A_IM();
    [CompilerGeneratedAttribute]
public void set_A_IM(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityId();
    [CompilerGeneratedAttribute]
public void set_ActivityId(string value);
    [CompilerGeneratedAttribute]
public string get_AddResourcePropertiesToResponse();
    [CompilerGeneratedAttribute]
public void set_AddResourcePropertiesToResponse(string value);
    [CompilerGeneratedAttribute]
public string get_AllowDocumentReadsInOfflineRegion();
    [CompilerGeneratedAttribute]
public void set_AllowDocumentReadsInOfflineRegion(string value);
    [CompilerGeneratedAttribute]
public string get_AllowRestoreParamsUpdate();
    [CompilerGeneratedAttribute]
public void set_AllowRestoreParamsUpdate(string value);
    [CompilerGeneratedAttribute]
public string get_AllowTentativeWrites();
    [CompilerGeneratedAttribute]
public void set_AllowTentativeWrites(string value);
    [CompilerGeneratedAttribute]
public string get_Authorization();
    [CompilerGeneratedAttribute]
public void set_Authorization(string value);
    [CompilerGeneratedAttribute]
public string get_BinaryId();
    [CompilerGeneratedAttribute]
public void set_BinaryId(string value);
    [CompilerGeneratedAttribute]
public string get_BinaryPassthroughRequest();
    [CompilerGeneratedAttribute]
public void set_BinaryPassthroughRequest(string value);
    [CompilerGeneratedAttribute]
public string get_BindReplicaDirective();
    [CompilerGeneratedAttribute]
public void set_BindReplicaDirective(string value);
    [CompilerGeneratedAttribute]
public string get_BuilderClientIdentifier();
    [CompilerGeneratedAttribute]
public void set_BuilderClientIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_CanCharge();
    [CompilerGeneratedAttribute]
public void set_CanCharge(string value);
    [CompilerGeneratedAttribute]
public string get_CanOfferReplaceComplete();
    [CompilerGeneratedAttribute]
public void set_CanOfferReplaceComplete(string value);
    [CompilerGeneratedAttribute]
public string get_CanThrottle();
    [CompilerGeneratedAttribute]
public void set_CanThrottle(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeFeedStartFullFidelityIfNoneMatch();
    [CompilerGeneratedAttribute]
public void set_ChangeFeedStartFullFidelityIfNoneMatch(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeFeedWireFormatVersion();
    [CompilerGeneratedAttribute]
public void set_ChangeFeedWireFormatVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ClientIpAddress();
    [CompilerGeneratedAttribute]
public void set_ClientIpAddress(string value);
    [CompilerGeneratedAttribute]
public string get_ClientRetryAttemptCount();
    [CompilerGeneratedAttribute]
public void set_ClientRetryAttemptCount(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionChildResourceContentLimitInKB();
    [CompilerGeneratedAttribute]
public void set_CollectionChildResourceContentLimitInKB(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionChildResourceNameLimitInBytes();
    [CompilerGeneratedAttribute]
public void set_CollectionChildResourceNameLimitInBytes(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionPartitionIndex();
    [CompilerGeneratedAttribute]
public void set_CollectionPartitionIndex(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionRemoteStorageSecurityIdentifier();
    [CompilerGeneratedAttribute]
public void set_CollectionRemoteStorageSecurityIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionRid();
    [CompilerGeneratedAttribute]
public void set_CollectionRid(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionServiceIndex();
    [CompilerGeneratedAttribute]
public void set_CollectionServiceIndex(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionTruncate();
    [CompilerGeneratedAttribute]
public void set_CollectionTruncate(string value);
    [CompilerGeneratedAttribute]
public string get_ConsistencyLevel();
    [CompilerGeneratedAttribute]
public void set_ConsistencyLevel(string value);
    [CompilerGeneratedAttribute]
public string get_ContentSerializationFormat();
    [CompilerGeneratedAttribute]
public void set_ContentSerializationFormat(string value);
    [CompilerGeneratedAttribute]
public string get_Continuation();
    [CompilerGeneratedAttribute]
public void set_Continuation(string value);
    [CompilerGeneratedAttribute]
public string get_CorrelatedActivityId();
    [CompilerGeneratedAttribute]
public void set_CorrelatedActivityId(string value);
    [CompilerGeneratedAttribute]
public string get_CosmosGatewayTransactionId();
    [CompilerGeneratedAttribute]
public void set_CosmosGatewayTransactionId(string value);
    [CompilerGeneratedAttribute]
public string get_DisableRUPerMinuteUsage();
    [CompilerGeneratedAttribute]
public void set_DisableRUPerMinuteUsage(string value);
    [CompilerGeneratedAttribute]
public string get_EffectivePartitionKey();
    [CompilerGeneratedAttribute]
public void set_EffectivePartitionKey(string value);
    [CompilerGeneratedAttribute]
public string get_EmitVerboseTracesInQuery();
    [CompilerGeneratedAttribute]
public void set_EmitVerboseTracesInQuery(string value);
    [CompilerGeneratedAttribute]
public string get_EnableConflictResolutionPolicyUpdate();
    [CompilerGeneratedAttribute]
public void set_EnableConflictResolutionPolicyUpdate(string value);
    [CompilerGeneratedAttribute]
public string get_EnableCrossPartitionQuery();
    [CompilerGeneratedAttribute]
public void set_EnableCrossPartitionQuery(string value);
    [CompilerGeneratedAttribute]
public string get_EnableDynamicRidRangeAllocation();
    [CompilerGeneratedAttribute]
public void set_EnableDynamicRidRangeAllocation(string value);
    [CompilerGeneratedAttribute]
public string get_EnableLogging();
    [CompilerGeneratedAttribute]
public void set_EnableLogging(string value);
    [CompilerGeneratedAttribute]
public string get_EnableLowPrecisionOrderBy();
    [CompilerGeneratedAttribute]
public void set_EnableLowPrecisionOrderBy(string value);
    [CompilerGeneratedAttribute]
public string get_EnableScanInQuery();
    [CompilerGeneratedAttribute]
public void set_EnableScanInQuery(string value);
    [CompilerGeneratedAttribute]
public string get_EndEpk();
    [CompilerGeneratedAttribute]
public void set_EndEpk(string value);
    [CompilerGeneratedAttribute]
public string get_EndId();
    [CompilerGeneratedAttribute]
public void set_EndId(string value);
    [CompilerGeneratedAttribute]
public string get_EntityId();
    [CompilerGeneratedAttribute]
public void set_EntityId(string value);
    [CompilerGeneratedAttribute]
public string get_EnumerationDirection();
    [CompilerGeneratedAttribute]
public void set_EnumerationDirection(string value);
    [CompilerGeneratedAttribute]
public string get_ExcludeSystemProperties();
    [CompilerGeneratedAttribute]
public void set_ExcludeSystemProperties(string value);
    [CompilerGeneratedAttribute]
public string get_FanoutOperationState();
    [CompilerGeneratedAttribute]
public void set_FanoutOperationState(string value);
    [CompilerGeneratedAttribute]
public string get_FilterBySchemaResourceId();
    [CompilerGeneratedAttribute]
public void set_FilterBySchemaResourceId(string value);
    [CompilerGeneratedAttribute]
public string get_ForceDatabaseAccountUpdate();
    [CompilerGeneratedAttribute]
public void set_ForceDatabaseAccountUpdate(string value);
    [CompilerGeneratedAttribute]
public string get_ForceQueryScan();
    [CompilerGeneratedAttribute]
public void set_ForceQueryScan(string value);
    [CompilerGeneratedAttribute]
public string get_ForceSideBySideIndexMigration();
    [CompilerGeneratedAttribute]
public void set_ForceSideBySideIndexMigration(string value);
    [CompilerGeneratedAttribute]
public string get_GatewaySignature();
    [CompilerGeneratedAttribute]
public void set_GatewaySignature(string value);
    [CompilerGeneratedAttribute]
public string get_GetAllPartitionKeyStatistics();
    [CompilerGeneratedAttribute]
public void set_GetAllPartitionKeyStatistics(string value);
    [CompilerGeneratedAttribute]
public string get_HighPriorityForcedBackup();
    [CompilerGeneratedAttribute]
public void set_HighPriorityForcedBackup(string value);
    [CompilerGeneratedAttribute]
public string get_HttpDate();
    [CompilerGeneratedAttribute]
public void set_HttpDate(string value);
    [CompilerGeneratedAttribute]
public string get_IfMatch();
    [CompilerGeneratedAttribute]
public void set_IfMatch(string value);
    [CompilerGeneratedAttribute]
public string get_IfModifiedSince();
    [CompilerGeneratedAttribute]
public void set_IfModifiedSince(string value);
    [CompilerGeneratedAttribute]
public string get_IfNoneMatch();
    [CompilerGeneratedAttribute]
public void set_IfNoneMatch(string value);
    [CompilerGeneratedAttribute]
public string get_IgnoreSystemLoweringMaxThroughput();
    [CompilerGeneratedAttribute]
public void set_IgnoreSystemLoweringMaxThroughput(string value);
    [CompilerGeneratedAttribute]
public string get_IncludePhysicalPartitionThroughputInfo();
    [CompilerGeneratedAttribute]
public void set_IncludePhysicalPartitionThroughputInfo(string value);
    [CompilerGeneratedAttribute]
public string get_IncludeTentativeWrites();
    [CompilerGeneratedAttribute]
public void set_IncludeTentativeWrites(string value);
    [CompilerGeneratedAttribute]
public string get_IndexingDirective();
    [CompilerGeneratedAttribute]
public void set_IndexingDirective(string value);
    [CompilerGeneratedAttribute]
public string get_IntendedCollectionRid();
    [CompilerGeneratedAttribute]
public void set_IntendedCollectionRid(string value);
    [CompilerGeneratedAttribute]
public string get_IsAutoScaleRequest();
    [CompilerGeneratedAttribute]
public void set_IsAutoScaleRequest(string value);
    [CompilerGeneratedAttribute]
public string get_IsBatchAtomic();
    [CompilerGeneratedAttribute]
public void set_IsBatchAtomic(string value);
    [CompilerGeneratedAttribute]
public string get_IsBatchOrdered();
    [CompilerGeneratedAttribute]
public void set_IsBatchOrdered(string value);
    [CompilerGeneratedAttribute]
public string get_IsCassandraAlterTypeRequest();
    [CompilerGeneratedAttribute]
public void set_IsCassandraAlterTypeRequest(string value);
    [CompilerGeneratedAttribute]
public string get_IsClientEncrypted();
    [CompilerGeneratedAttribute]
public void set_IsClientEncrypted(string value);
    [CompilerGeneratedAttribute]
public string get_IsContinuationExpected();
    [CompilerGeneratedAttribute]
public void set_IsContinuationExpected(string value);
    [CompilerGeneratedAttribute]
public string get_IsFanoutRequest();
    [CompilerGeneratedAttribute]
public void set_IsFanoutRequest(string value);
    [CompilerGeneratedAttribute]
public string get_IsInternalServerlessRequest();
    [CompilerGeneratedAttribute]
public void set_IsInternalServerlessRequest(string value);
    [CompilerGeneratedAttribute]
public string get_IsMaterializedViewBuild();
    [CompilerGeneratedAttribute]
public void set_IsMaterializedViewBuild(string value);
    [CompilerGeneratedAttribute]
public string get_IsMaterializedViewSourceSchemaReplaceBatchRequest();
    [CompilerGeneratedAttribute]
public void set_IsMaterializedViewSourceSchemaReplaceBatchRequest(string value);
    [CompilerGeneratedAttribute]
public string get_IsMigratedFixedCollection();
    [CompilerGeneratedAttribute]
public void set_IsMigratedFixedCollection(string value);
    [CompilerGeneratedAttribute]
public string get_IsOfferStorageRefreshRequest();
    [CompilerGeneratedAttribute]
public void set_IsOfferStorageRefreshRequest(string value);
    [CompilerGeneratedAttribute]
public string get_IsReadOnlyScript();
    [CompilerGeneratedAttribute]
public void set_IsReadOnlyScript(string value);
    [CompilerGeneratedAttribute]
public string get_IsRequestNotAuthorized();
    [CompilerGeneratedAttribute]
public void set_IsRequestNotAuthorized(string value);
    [CompilerGeneratedAttribute]
public string get_IsRetriedWriteRequest();
    [CompilerGeneratedAttribute]
public void set_IsRetriedWriteRequest(string value);
    [CompilerGeneratedAttribute]
public string get_IsRUPerGBEnforcementRequest();
    [CompilerGeneratedAttribute]
public void set_IsRUPerGBEnforcementRequest(string value);
    [CompilerGeneratedAttribute]
public string get_IsServerlessStorageRefreshRequest();
    [CompilerGeneratedAttribute]
public void set_IsServerlessStorageRefreshRequest(string value);
    [CompilerGeneratedAttribute]
public string get_IsThroughputCapRequest();
    [CompilerGeneratedAttribute]
public void set_IsThroughputCapRequest(string value);
    [CompilerGeneratedAttribute]
public string get_IsUserRequest();
    [CompilerGeneratedAttribute]
public void set_IsUserRequest(string value);
    [CompilerGeneratedAttribute]
public string get_MaxPollingIntervalMilliseconds();
    [CompilerGeneratedAttribute]
public void set_MaxPollingIntervalMilliseconds(string value);
    [CompilerGeneratedAttribute]
public string get_MergeCheckPointGLSN();
    [CompilerGeneratedAttribute]
public void set_MergeCheckPointGLSN(string value);
    [CompilerGeneratedAttribute]
public string get_MergeStaticId();
    [CompilerGeneratedAttribute]
public void set_MergeStaticId(string value);
    [CompilerGeneratedAttribute]
public string get_MigrateCollectionDirective();
    [CompilerGeneratedAttribute]
public void set_MigrateCollectionDirective(string value);
    [CompilerGeneratedAttribute]
public string get_MigrateOfferToAutopilot();
    [CompilerGeneratedAttribute]
public void set_MigrateOfferToAutopilot(string value);
    [CompilerGeneratedAttribute]
public string get_MigrateOfferToManualThroughput();
    [CompilerGeneratedAttribute]
public void set_MigrateOfferToManualThroughput(string value);
    [CompilerGeneratedAttribute]
public string get_NoRetryOn449StatusCode();
    [CompilerGeneratedAttribute]
public void set_NoRetryOn449StatusCode(string value);
    [CompilerGeneratedAttribute]
public string get_OfferReplaceRURedistribution();
    [CompilerGeneratedAttribute]
public void set_OfferReplaceRURedistribution(string value);
    [CompilerGeneratedAttribute]
public string get_OptimisticDirectExecute();
    [CompilerGeneratedAttribute]
public void set_OptimisticDirectExecute(string value);
    [CompilerGeneratedAttribute]
public string get_PageSize();
    [CompilerGeneratedAttribute]
public void set_PageSize(string value);
    [CompilerGeneratedAttribute]
public string get_ParallelizeCrossPartitionQuery();
    [CompilerGeneratedAttribute]
public void set_ParallelizeCrossPartitionQuery(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionCount();
    [CompilerGeneratedAttribute]
public void set_PartitionCount(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionKey();
    [CompilerGeneratedAttribute]
public void set_PartitionKey(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
public void set_PartitionKeyRangeId(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionResourceFilter();
    [CompilerGeneratedAttribute]
public void set_PartitionResourceFilter(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateAnalyticalMigrationProgress();
    [CompilerGeneratedAttribute]
public void set_PopulateAnalyticalMigrationProgress(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateByokEncryptionProgress();
    [CompilerGeneratedAttribute]
public void set_PopulateByokEncryptionProgress(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateCapacityType();
    [CompilerGeneratedAttribute]
public void set_PopulateCapacityType(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateCollectionThroughputInfo();
    [CompilerGeneratedAttribute]
public void set_PopulateCollectionThroughputInfo(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateCurrentPartitionThroughputInfo();
    [CompilerGeneratedAttribute]
public void set_PopulateCurrentPartitionThroughputInfo(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateDocumentRecordCount();
    [CompilerGeneratedAttribute]
public void set_PopulateDocumentRecordCount(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateHighestTentativeWriteLLSN();
    [CompilerGeneratedAttribute]
public void set_PopulateHighestTentativeWriteLLSN(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateIndexMetrics();
    [CompilerGeneratedAttribute]
public void set_PopulateIndexMetrics(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateIndexMetricsV2();
    [CompilerGeneratedAttribute]
public void set_PopulateIndexMetricsV2(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateLogStoreInfo();
    [CompilerGeneratedAttribute]
public void set_PopulateLogStoreInfo(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateMinGLSNForDocumentOperations();
    [CompilerGeneratedAttribute]
public void set_PopulateMinGLSNForDocumentOperations(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateOldestActiveSchemaId();
    [CompilerGeneratedAttribute]
public void set_PopulateOldestActiveSchemaId(string value);
    [CompilerGeneratedAttribute]
public string get_PopulatePartitionStatistics();
    [CompilerGeneratedAttribute]
public void set_PopulatePartitionStatistics(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateQueryMetrics();
    [CompilerGeneratedAttribute]
public void set_PopulateQueryMetrics(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateQuotaInfo();
    [CompilerGeneratedAttribute]
public void set_PopulateQuotaInfo(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateResourceCount();
    [CompilerGeneratedAttribute]
public void set_PopulateResourceCount(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateUnflushedMergeEntryCount();
    [CompilerGeneratedAttribute]
public void set_PopulateUnflushedMergeEntryCount(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateUniqueIndexReIndexProgress();
    [CompilerGeneratedAttribute]
public void set_PopulateUniqueIndexReIndexProgress(string value);
    [CompilerGeneratedAttribute]
public string get_PopulateUserStrings();
    [CompilerGeneratedAttribute]
public void set_PopulateUserStrings(string value);
    [CompilerGeneratedAttribute]
public string get_PostTriggerExclude();
    [CompilerGeneratedAttribute]
public void set_PostTriggerExclude(string value);
    [CompilerGeneratedAttribute]
public string get_PostTriggerInclude();
    [CompilerGeneratedAttribute]
public void set_PostTriggerInclude(string value);
    [CompilerGeneratedAttribute]
public string get_Prefer();
    [CompilerGeneratedAttribute]
public void set_Prefer(string value);
    [CompilerGeneratedAttribute]
public string get_PreserveFullContent();
    [CompilerGeneratedAttribute]
public void set_PreserveFullContent(string value);
    [CompilerGeneratedAttribute]
public string get_PreTriggerExclude();
    [CompilerGeneratedAttribute]
public void set_PreTriggerExclude(string value);
    [CompilerGeneratedAttribute]
public string get_PreTriggerInclude();
    [CompilerGeneratedAttribute]
public void set_PreTriggerInclude(string value);
    [CompilerGeneratedAttribute]
public string get_PrimaryMasterKey();
    [CompilerGeneratedAttribute]
public void set_PrimaryMasterKey(string value);
    [CompilerGeneratedAttribute]
public string get_PrimaryReadonlyKey();
    [CompilerGeneratedAttribute]
public void set_PrimaryReadonlyKey(string value);
    [CompilerGeneratedAttribute]
public string get_PriorityLevel();
    [CompilerGeneratedAttribute]
public void set_PriorityLevel(string value);
    [CompilerGeneratedAttribute]
public string get_ProfileRequest();
    [CompilerGeneratedAttribute]
public void set_ProfileRequest(string value);
    [CompilerGeneratedAttribute]
public string get_PruneCollectionSchemas();
    [CompilerGeneratedAttribute]
public void set_PruneCollectionSchemas(string value);
    [CompilerGeneratedAttribute]
public string get_QueryVersion();
    [CompilerGeneratedAttribute]
public void set_QueryVersion(string value);
    [CompilerGeneratedAttribute]
public string get_RbacAction();
    [CompilerGeneratedAttribute]
public void set_RbacAction(string value);
    [CompilerGeneratedAttribute]
public string get_RbacResource();
    [CompilerGeneratedAttribute]
public void set_RbacResource(string value);
    [CompilerGeneratedAttribute]
public string get_RbacUserId();
    [CompilerGeneratedAttribute]
public void set_RbacUserId(string value);
    [CompilerGeneratedAttribute]
public string get_ReadFeedKeyType();
    [CompilerGeneratedAttribute]
public void set_ReadFeedKeyType(string value);
    [CompilerGeneratedAttribute]
public string get_RemainingTimeInMsOnClientRequest();
    [CompilerGeneratedAttribute]
public void set_RemainingTimeInMsOnClientRequest(string value);
    [CompilerGeneratedAttribute]
public string get_RemoteStorageType();
    [CompilerGeneratedAttribute]
public void set_RemoteStorageType(string value);
    [CompilerGeneratedAttribute]
public string get_RequestedCollectionType();
    [CompilerGeneratedAttribute]
public void set_RequestedCollectionType(string value);
    [CompilerGeneratedAttribute]
public string get_ResourceId();
    [CompilerGeneratedAttribute]
public void set_ResourceId(string value);
    [CompilerGeneratedAttribute]
public string get_ResourceSchemaName();
    [CompilerGeneratedAttribute]
public void set_ResourceSchemaName(string value);
    [CompilerGeneratedAttribute]
public string get_ResourceTokenExpiry();
    [CompilerGeneratedAttribute]
public void set_ResourceTokenExpiry(string value);
    [CompilerGeneratedAttribute]
public string get_ResourceTypes();
    [CompilerGeneratedAttribute]
public void set_ResourceTypes(string value);
    [CompilerGeneratedAttribute]
public string get_ResponseContinuationTokenLimitInKB();
    [CompilerGeneratedAttribute]
public void set_ResponseContinuationTokenLimitInKB(string value);
    [CompilerGeneratedAttribute]
public string get_RestoreMetadataFilter();
    [CompilerGeneratedAttribute]
public void set_RestoreMetadataFilter(string value);
    [CompilerGeneratedAttribute]
public string get_RestoreParams();
    [CompilerGeneratedAttribute]
public void set_RestoreParams(string value);
    [CompilerGeneratedAttribute]
public string get_RetriableWriteRequestId();
    [CompilerGeneratedAttribute]
public void set_RetriableWriteRequestId(string value);
    [CompilerGeneratedAttribute]
public string get_RetriableWriteRequestStartTimestamp();
    [CompilerGeneratedAttribute]
public void set_RetriableWriteRequestStartTimestamp(string value);
    [CompilerGeneratedAttribute]
public string get_SchemaHash();
    [CompilerGeneratedAttribute]
public void set_SchemaHash(string value);
    [CompilerGeneratedAttribute]
public string get_SchemaId();
    [CompilerGeneratedAttribute]
public void set_SchemaId(string value);
    [CompilerGeneratedAttribute]
public string get_SchemaOwnerRid();
    [CompilerGeneratedAttribute]
public void set_SchemaOwnerRid(string value);
    [CompilerGeneratedAttribute]
public string get_SDKSupportedCapabilities();
    [CompilerGeneratedAttribute]
public void set_SDKSupportedCapabilities(string value);
    [CompilerGeneratedAttribute]
public string get_SecondaryMasterKey();
    [CompilerGeneratedAttribute]
public void set_SecondaryMasterKey(string value);
    [CompilerGeneratedAttribute]
public string get_SecondaryReadonlyKey();
    [CompilerGeneratedAttribute]
public void set_SecondaryReadonlyKey(string value);
    [CompilerGeneratedAttribute]
public string get_SessionToken();
    [CompilerGeneratedAttribute]
public void set_SessionToken(string value);
    [CompilerGeneratedAttribute]
public string get_SetMasterResourcesDeletionPending();
    [CompilerGeneratedAttribute]
public void set_SetMasterResourcesDeletionPending(string value);
    [CompilerGeneratedAttribute]
public string get_ShareThroughput();
    [CompilerGeneratedAttribute]
public void set_ShareThroughput(string value);
    [CompilerGeneratedAttribute]
public string get_ShouldBatchContinueOnError();
    [CompilerGeneratedAttribute]
public void set_ShouldBatchContinueOnError(string value);
    [CompilerGeneratedAttribute]
public string get_ShouldReturnCurrentServerDateTime();
    [CompilerGeneratedAttribute]
public void set_ShouldReturnCurrentServerDateTime(string value);
    [CompilerGeneratedAttribute]
public string get_SkipAdjustThroughputFractionsForOfferReplace();
    [CompilerGeneratedAttribute]
public void set_SkipAdjustThroughputFractionsForOfferReplace(string value);
    [CompilerGeneratedAttribute]
public string get_SkipRefreshDatabaseAccountConfigs();
    [CompilerGeneratedAttribute]
public void set_SkipRefreshDatabaseAccountConfigs(string value);
    [CompilerGeneratedAttribute]
public string get_SkipThroughputCapValidation();
    [CompilerGeneratedAttribute]
public void set_SkipThroughputCapValidation(string value);
    [CompilerGeneratedAttribute]
public string get_SourceCollectionIfMatch();
    [CompilerGeneratedAttribute]
public void set_SourceCollectionIfMatch(string value);
    [CompilerGeneratedAttribute]
public string get_SqlQueryForPartitionKeyExtraction();
    [CompilerGeneratedAttribute]
public void set_SqlQueryForPartitionKeyExtraction(string value);
    [CompilerGeneratedAttribute]
public string get_StartEpk();
    [CompilerGeneratedAttribute]
public void set_StartEpk(string value);
    [CompilerGeneratedAttribute]
public string get_StartId();
    [CompilerGeneratedAttribute]
public void set_StartId(string value);
    [CompilerGeneratedAttribute]
public string get_SupportedQueryFeatures();
    [CompilerGeneratedAttribute]
public void set_SupportedQueryFeatures(string value);
    [CompilerGeneratedAttribute]
public string get_SupportedSerializationFormats();
    [CompilerGeneratedAttribute]
public void set_SupportedSerializationFormats(string value);
    [CompilerGeneratedAttribute]
public string get_SupportSpatialLegacyCoordinates();
    [CompilerGeneratedAttribute]
public void set_SupportSpatialLegacyCoordinates(string value);
    [CompilerGeneratedAttribute]
public string get_SystemDocumentType();
    [CompilerGeneratedAttribute]
public void set_SystemDocumentType(string value);
    [CompilerGeneratedAttribute]
public string get_SystemRestoreOperation();
    [CompilerGeneratedAttribute]
public void set_SystemRestoreOperation(string value);
    [CompilerGeneratedAttribute]
public string get_TargetGlobalCommittedLsn();
    [CompilerGeneratedAttribute]
public void set_TargetGlobalCommittedLsn(string value);
    [CompilerGeneratedAttribute]
public string get_TargetLsn();
    [CompilerGeneratedAttribute]
public void set_TargetLsn(string value);
    [CompilerGeneratedAttribute]
public string get_TimeToLiveInSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeToLiveInSeconds(string value);
    [CompilerGeneratedAttribute]
public string get_TraceParent();
    [CompilerGeneratedAttribute]
public void set_TraceParent(string value);
    [CompilerGeneratedAttribute]
public string get_TraceState();
    [CompilerGeneratedAttribute]
public void set_TraceState(string value);
    [CompilerGeneratedAttribute]
public string get_TransactionCommit();
    [CompilerGeneratedAttribute]
public void set_TransactionCommit(string value);
    [CompilerGeneratedAttribute]
public string get_TransactionFirstRequest();
    [CompilerGeneratedAttribute]
public void set_TransactionFirstRequest(string value);
    [CompilerGeneratedAttribute]
public string get_TransactionId();
    [CompilerGeneratedAttribute]
public void set_TransactionId(string value);
    [CompilerGeneratedAttribute]
public string get_TransportRequestID();
    [CompilerGeneratedAttribute]
public void set_TransportRequestID(string value);
    [CompilerGeneratedAttribute]
public string get_TruncateMergeLogRequest();
    [CompilerGeneratedAttribute]
public void set_TruncateMergeLogRequest(string value);
    [CompilerGeneratedAttribute]
public string get_UniqueIndexNameEncodingMode();
    [CompilerGeneratedAttribute]
public void set_UniqueIndexNameEncodingMode(string value);
    [CompilerGeneratedAttribute]
public string get_UniqueIndexReIndexingState();
    [CompilerGeneratedAttribute]
public void set_UniqueIndexReIndexingState(string value);
    [CompilerGeneratedAttribute]
public string get_UpdateMaxThroughputEverProvisioned();
    [CompilerGeneratedAttribute]
public void set_UpdateMaxThroughputEverProvisioned(string value);
    [CompilerGeneratedAttribute]
public string get_UpdateOfferStateToPending();
    [CompilerGeneratedAttribute]
public void set_UpdateOfferStateToPending(string value);
    [CompilerGeneratedAttribute]
public string get_UpdateOfferStateToRestorePending();
    [CompilerGeneratedAttribute]
public void set_UpdateOfferStateToRestorePending(string value);
    [CompilerGeneratedAttribute]
public string get_UseArchivalPartition();
    [CompilerGeneratedAttribute]
public void set_UseArchivalPartition(string value);
    [CompilerGeneratedAttribute]
public string get_UsePolygonsSmallerThanAHemisphere();
    [CompilerGeneratedAttribute]
public void set_UsePolygonsSmallerThanAHemisphere(string value);
    [CompilerGeneratedAttribute]
public string get_UseSystemBudget();
    [CompilerGeneratedAttribute]
public void set_UseSystemBudget(string value);
    [CompilerGeneratedAttribute]
public string get_UseUserBackgroundBudget();
    [CompilerGeneratedAttribute]
public void set_UseUserBackgroundBudget(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_XDate();
    [CompilerGeneratedAttribute]
public void set_XDate(string value);
    public static RequestNameValueCollection BuildRequestNameValueCollectionWithKnownHeadersOnly(IDictionary`2<string, string> requestHeaders);
    public static RequestNameValueCollection BuildRequestNameValueCollectionWithKnownHeadersOnly(INameValueCollection nameValueCollection);
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual void Add(INameValueCollection collection);
    public sealed virtual String[] AllKeys();
    public sealed virtual void Clear();
    public sealed virtual INameValueCollection Clone();
    public sealed virtual int Count();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual String[] GetValues(string key);
    [IteratorStateMachineAttribute("Microsoft.Azure.Documents.Collections.RequestNameValueCollection/<Keys>d__762")]
public sealed virtual IEnumerable`1<string> Keys();
    public sealed virtual NameValueCollection ToNameValueCollection();
    public sealed virtual void Remove(string key);
    public sealed virtual string Get(string key);
    public sealed virtual void Add(string key, string value);
    public sealed virtual void Set(string key, string value);
    public void UpdateHelper(string key, string value, bool throwIfAlreadyExists, bool ignoreNotCommonHeaders);
    private void InitializeNotCommonHeadersIfNeeded();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Azure.Documents.Collections.StoreResponseNameValueCollection : object {
    private static StringComparer DefaultStringComparer;
    private Dictionary`2<string, string> lazyNotCommonHeaders;
    private NameValueCollection nameValueCollection;
    [CompilerGeneratedAttribute]
private string <AadAppliedRoleAssignmentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AnalyticalMigrationProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppliedPolicyElementId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BackendRequestDurationMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ByokEncryptionProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CapacityType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeFeedInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionIndexTransformationProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionLazyIndexingProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionPartitionIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionSecurityIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionServiceIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionUniqueIndexReIndexProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionUniqueKeysUnderReIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfirmedStoreChecksum>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Continuation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelatedActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CosmosGatewayTransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentReplicaSetSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentResourceQuotaUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentWriteQuorum>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisableRntbdChannel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentRecordCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GlobalCommittedLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HasTentativeWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HighestTentativeWriteLLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexingDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexUtilization>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstantScaleUpValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsOfferRestorePending>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsRUPerMinuteUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemLocalLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastStateChangeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogResults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MaxContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MaxResourceQuota>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MergeProgressBlocked>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinGLSNForDocumentOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinGLSNForTombstoneOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinimumRUsForOffer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NumberOfReadRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OfferReplacePending>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OfferReplacePendingForMerge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldestActiveSchemaId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OwnerFullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OwnerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKeyRangeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionThroughputInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PendingPKDelete>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PhysicalPartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryExecutionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QuorumAckedLocalLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QuorumAckedLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReIndexerProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplicaStatusRevoked>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplicatorLSNToGLSNDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplicatorLSNToLLSNDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestCharge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestValidationFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequiresDistribution>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RestoreState>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RetryAfterInMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShareThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SoftMaxAllowedThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TentativeStoreChecksum>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeToLiveInSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TotalAccountThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransportRequestID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnflushedMergLogEntryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VectorClockLocalProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XPConfigurationSessionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XPRole>k__BackingField;
    public string AadAppliedRoleAssignmentId { get; public set; }
    public string ActivityId { get; public set; }
    public string AnalyticalMigrationProgress { get; public set; }
    public string AppliedPolicyElementId { get; public set; }
    public string BackendRequestDurationMilliseconds { get; public set; }
    public string ByokEncryptionProgress { get; public set; }
    public string CapacityType { get; public set; }
    public string ChangeFeedInfo { get; public set; }
    public string CollectionIndexTransformationProgress { get; public set; }
    public string CollectionLazyIndexingProgress { get; public set; }
    public string CollectionPartitionIndex { get; public set; }
    public string CollectionSecurityIdentifier { get; public set; }
    public string CollectionServiceIndex { get; public set; }
    public string CollectionUniqueIndexReIndexProgress { get; public set; }
    public string CollectionUniqueKeysUnderReIndex { get; public set; }
    public string ConfirmedStoreChecksum { get; public set; }
    public string Continuation { get; public set; }
    public string CorrelatedActivityId { get; public set; }
    public string CosmosGatewayTransactionId { get; public set; }
    public string CurrentReplicaSetSize { get; public set; }
    public string CurrentResourceQuotaUsage { get; public set; }
    public string CurrentWriteQuorum { get; public set; }
    public string DatabaseAccountId { get; public set; }
    public string DisableRntbdChannel { get; public set; }
    public string DocumentRecordCount { get; public set; }
    public string ETag { get; public set; }
    public string GlobalCommittedLSN { get; public set; }
    public string HasTentativeWrites { get; public set; }
    public string HighestTentativeWriteLLSN { get; public set; }
    public string IndexingDirective { get; public set; }
    public string IndexUtilization { get; public set; }
    public string InstantScaleUpValue { get; public set; }
    public string IsOfferRestorePending { get; public set; }
    public string IsRUPerMinuteUsed { get; public set; }
    public string ItemCount { get; public set; }
    public string ItemLocalLSN { get; public set; }
    public string ItemLSN { get; public set; }
    public string LastStateChangeUtc { get; public set; }
    public string LocalLSN { get; public set; }
    public string LogResults { get; public set; }
    public string LSN { get; public set; }
    public string MaxContentLength { get; public set; }
    public string MaxResourceQuota { get; public set; }
    public string MergeProgressBlocked { get; public set; }
    public string MinGLSNForDocumentOperations { get; public set; }
    public string MinGLSNForTombstoneOperations { get; public set; }
    public string MinimumRUsForOffer { get; public set; }
    public string NumberOfReadRegions { get; public set; }
    public string OfferReplacePending { get; public set; }
    public string OfferReplacePendingForMerge { get; public set; }
    public string OldestActiveSchemaId { get; public set; }
    public string OwnerFullName { get; public set; }
    public string OwnerId { get; public set; }
    public string PartitionKeyRangeId { get; public set; }
    public string PartitionThroughputInfo { get; public set; }
    public string PendingPKDelete { get; public set; }
    public string PhysicalPartitionId { get; public set; }
    public string QueryExecutionInfo { get; public set; }
    public string QueryMetrics { get; public set; }
    public string QuorumAckedLocalLSN { get; public set; }
    public string QuorumAckedLSN { get; public set; }
    public string ReIndexerProgress { get; public set; }
    public string ReplicaStatusRevoked { get; public set; }
    public string ReplicatorLSNToGLSNDelta { get; public set; }
    public string ReplicatorLSNToLLSNDelta { get; public set; }
    public string RequestCharge { get; public set; }
    public string RequestValidationFailure { get; public set; }
    public string RequiresDistribution { get; public set; }
    public string ResourceId { get; public set; }
    public string RestoreState { get; public set; }
    public string RetryAfterInMilliseconds { get; public set; }
    public string SchemaVersion { get; public set; }
    public string ServerVersion { get; public set; }
    public string SessionToken { get; public set; }
    public string ShareThroughput { get; public set; }
    public string SoftMaxAllowedThroughput { get; public set; }
    public string SubStatus { get; public set; }
    public string TentativeStoreChecksum { get; public set; }
    public string TimeToLiveInSeconds { get; public set; }
    public string TotalAccountThroughput { get; public set; }
    public string TransportRequestID { get; public set; }
    public string UnflushedMergLogEntryCount { get; public set; }
    public string UserStrings { get; public set; }
    public string VectorClockLocalProgress { get; public set; }
    public string XDate { get; public set; }
    public string XPConfigurationSessionsCount { get; public set; }
    public string XPRole { get; public set; }
    public string Item { get; public set; }
    private StoreResponseNameValueCollection(Dictionary`2<string, string> lazyNotCommonHeaders);
    private static StoreResponseNameValueCollection();
    [CompilerGeneratedAttribute]
public string get_AadAppliedRoleAssignmentId();
    [CompilerGeneratedAttribute]
public void set_AadAppliedRoleAssignmentId(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityId();
    [CompilerGeneratedAttribute]
public void set_ActivityId(string value);
    [CompilerGeneratedAttribute]
public string get_AnalyticalMigrationProgress();
    [CompilerGeneratedAttribute]
public void set_AnalyticalMigrationProgress(string value);
    [CompilerGeneratedAttribute]
public string get_AppliedPolicyElementId();
    [CompilerGeneratedAttribute]
public void set_AppliedPolicyElementId(string value);
    [CompilerGeneratedAttribute]
public string get_BackendRequestDurationMilliseconds();
    [CompilerGeneratedAttribute]
public void set_BackendRequestDurationMilliseconds(string value);
    [CompilerGeneratedAttribute]
public string get_ByokEncryptionProgress();
    [CompilerGeneratedAttribute]
public void set_ByokEncryptionProgress(string value);
    [CompilerGeneratedAttribute]
public string get_CapacityType();
    [CompilerGeneratedAttribute]
public void set_CapacityType(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeFeedInfo();
    [CompilerGeneratedAttribute]
public void set_ChangeFeedInfo(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionIndexTransformationProgress();
    [CompilerGeneratedAttribute]
public void set_CollectionIndexTransformationProgress(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionLazyIndexingProgress();
    [CompilerGeneratedAttribute]
public void set_CollectionLazyIndexingProgress(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionPartitionIndex();
    [CompilerGeneratedAttribute]
public void set_CollectionPartitionIndex(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionSecurityIdentifier();
    [CompilerGeneratedAttribute]
public void set_CollectionSecurityIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionServiceIndex();
    [CompilerGeneratedAttribute]
public void set_CollectionServiceIndex(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionUniqueIndexReIndexProgress();
    [CompilerGeneratedAttribute]
public void set_CollectionUniqueIndexReIndexProgress(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionUniqueKeysUnderReIndex();
    [CompilerGeneratedAttribute]
public void set_CollectionUniqueKeysUnderReIndex(string value);
    [CompilerGeneratedAttribute]
public string get_ConfirmedStoreChecksum();
    [CompilerGeneratedAttribute]
public void set_ConfirmedStoreChecksum(string value);
    [CompilerGeneratedAttribute]
public string get_Continuation();
    [CompilerGeneratedAttribute]
public void set_Continuation(string value);
    [CompilerGeneratedAttribute]
public string get_CorrelatedActivityId();
    [CompilerGeneratedAttribute]
public void set_CorrelatedActivityId(string value);
    [CompilerGeneratedAttribute]
public string get_CosmosGatewayTransactionId();
    [CompilerGeneratedAttribute]
public void set_CosmosGatewayTransactionId(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentReplicaSetSize();
    [CompilerGeneratedAttribute]
public void set_CurrentReplicaSetSize(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentResourceQuotaUsage();
    [CompilerGeneratedAttribute]
public void set_CurrentResourceQuotaUsage(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentWriteQuorum();
    [CompilerGeneratedAttribute]
public void set_CurrentWriteQuorum(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseAccountId();
    [CompilerGeneratedAttribute]
public void set_DatabaseAccountId(string value);
    [CompilerGeneratedAttribute]
public string get_DisableRntbdChannel();
    [CompilerGeneratedAttribute]
public void set_DisableRntbdChannel(string value);
    [CompilerGeneratedAttribute]
public string get_DocumentRecordCount();
    [CompilerGeneratedAttribute]
public void set_DocumentRecordCount(string value);
    [CompilerGeneratedAttribute]
public string get_ETag();
    [CompilerGeneratedAttribute]
public void set_ETag(string value);
    [CompilerGeneratedAttribute]
public string get_GlobalCommittedLSN();
    [CompilerGeneratedAttribute]
public void set_GlobalCommittedLSN(string value);
    [CompilerGeneratedAttribute]
public string get_HasTentativeWrites();
    [CompilerGeneratedAttribute]
public void set_HasTentativeWrites(string value);
    [CompilerGeneratedAttribute]
public string get_HighestTentativeWriteLLSN();
    [CompilerGeneratedAttribute]
public void set_HighestTentativeWriteLLSN(string value);
    [CompilerGeneratedAttribute]
public string get_IndexingDirective();
    [CompilerGeneratedAttribute]
public void set_IndexingDirective(string value);
    [CompilerGeneratedAttribute]
public string get_IndexUtilization();
    [CompilerGeneratedAttribute]
public void set_IndexUtilization(string value);
    [CompilerGeneratedAttribute]
public string get_InstantScaleUpValue();
    [CompilerGeneratedAttribute]
public void set_InstantScaleUpValue(string value);
    [CompilerGeneratedAttribute]
public string get_IsOfferRestorePending();
    [CompilerGeneratedAttribute]
public void set_IsOfferRestorePending(string value);
    [CompilerGeneratedAttribute]
public string get_IsRUPerMinuteUsed();
    [CompilerGeneratedAttribute]
public void set_IsRUPerMinuteUsed(string value);
    [CompilerGeneratedAttribute]
public string get_ItemCount();
    [CompilerGeneratedAttribute]
public void set_ItemCount(string value);
    [CompilerGeneratedAttribute]
public string get_ItemLocalLSN();
    [CompilerGeneratedAttribute]
public void set_ItemLocalLSN(string value);
    [CompilerGeneratedAttribute]
public string get_ItemLSN();
    [CompilerGeneratedAttribute]
public void set_ItemLSN(string value);
    [CompilerGeneratedAttribute]
public string get_LastStateChangeUtc();
    [CompilerGeneratedAttribute]
public void set_LastStateChangeUtc(string value);
    [CompilerGeneratedAttribute]
public string get_LocalLSN();
    [CompilerGeneratedAttribute]
public void set_LocalLSN(string value);
    [CompilerGeneratedAttribute]
public string get_LogResults();
    [CompilerGeneratedAttribute]
public void set_LogResults(string value);
    [CompilerGeneratedAttribute]
public string get_LSN();
    [CompilerGeneratedAttribute]
public void set_LSN(string value);
    [CompilerGeneratedAttribute]
public string get_MaxContentLength();
    [CompilerGeneratedAttribute]
public void set_MaxContentLength(string value);
    [CompilerGeneratedAttribute]
public string get_MaxResourceQuota();
    [CompilerGeneratedAttribute]
public void set_MaxResourceQuota(string value);
    [CompilerGeneratedAttribute]
public string get_MergeProgressBlocked();
    [CompilerGeneratedAttribute]
public void set_MergeProgressBlocked(string value);
    [CompilerGeneratedAttribute]
public string get_MinGLSNForDocumentOperations();
    [CompilerGeneratedAttribute]
public void set_MinGLSNForDocumentOperations(string value);
    [CompilerGeneratedAttribute]
public string get_MinGLSNForTombstoneOperations();
    [CompilerGeneratedAttribute]
public void set_MinGLSNForTombstoneOperations(string value);
    [CompilerGeneratedAttribute]
public string get_MinimumRUsForOffer();
    [CompilerGeneratedAttribute]
public void set_MinimumRUsForOffer(string value);
    [CompilerGeneratedAttribute]
public string get_NumberOfReadRegions();
    [CompilerGeneratedAttribute]
public void set_NumberOfReadRegions(string value);
    [CompilerGeneratedAttribute]
public string get_OfferReplacePending();
    [CompilerGeneratedAttribute]
public void set_OfferReplacePending(string value);
    [CompilerGeneratedAttribute]
public string get_OfferReplacePendingForMerge();
    [CompilerGeneratedAttribute]
public void set_OfferReplacePendingForMerge(string value);
    [CompilerGeneratedAttribute]
public string get_OldestActiveSchemaId();
    [CompilerGeneratedAttribute]
public void set_OldestActiveSchemaId(string value);
    [CompilerGeneratedAttribute]
public string get_OwnerFullName();
    [CompilerGeneratedAttribute]
public void set_OwnerFullName(string value);
    [CompilerGeneratedAttribute]
public string get_OwnerId();
    [CompilerGeneratedAttribute]
public void set_OwnerId(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
public void set_PartitionKeyRangeId(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionThroughputInfo();
    [CompilerGeneratedAttribute]
public void set_PartitionThroughputInfo(string value);
    [CompilerGeneratedAttribute]
public string get_PendingPKDelete();
    [CompilerGeneratedAttribute]
public void set_PendingPKDelete(string value);
    [CompilerGeneratedAttribute]
public string get_PhysicalPartitionId();
    [CompilerGeneratedAttribute]
public void set_PhysicalPartitionId(string value);
    [CompilerGeneratedAttribute]
public string get_QueryExecutionInfo();
    [CompilerGeneratedAttribute]
public void set_QueryExecutionInfo(string value);
    [CompilerGeneratedAttribute]
public string get_QueryMetrics();
    [CompilerGeneratedAttribute]
public void set_QueryMetrics(string value);
    [CompilerGeneratedAttribute]
public string get_QuorumAckedLocalLSN();
    [CompilerGeneratedAttribute]
public void set_QuorumAckedLocalLSN(string value);
    [CompilerGeneratedAttribute]
public string get_QuorumAckedLSN();
    [CompilerGeneratedAttribute]
public void set_QuorumAckedLSN(string value);
    [CompilerGeneratedAttribute]
public string get_ReIndexerProgress();
    [CompilerGeneratedAttribute]
public void set_ReIndexerProgress(string value);
    [CompilerGeneratedAttribute]
public string get_ReplicaStatusRevoked();
    [CompilerGeneratedAttribute]
public void set_ReplicaStatusRevoked(string value);
    [CompilerGeneratedAttribute]
public string get_ReplicatorLSNToGLSNDelta();
    [CompilerGeneratedAttribute]
public void set_ReplicatorLSNToGLSNDelta(string value);
    [CompilerGeneratedAttribute]
public string get_ReplicatorLSNToLLSNDelta();
    [CompilerGeneratedAttribute]
public void set_ReplicatorLSNToLLSNDelta(string value);
    [CompilerGeneratedAttribute]
public string get_RequestCharge();
    [CompilerGeneratedAttribute]
public void set_RequestCharge(string value);
    [CompilerGeneratedAttribute]
public string get_RequestValidationFailure();
    [CompilerGeneratedAttribute]
public void set_RequestValidationFailure(string value);
    [CompilerGeneratedAttribute]
public string get_RequiresDistribution();
    [CompilerGeneratedAttribute]
public void set_RequiresDistribution(string value);
    [CompilerGeneratedAttribute]
public string get_ResourceId();
    [CompilerGeneratedAttribute]
public void set_ResourceId(string value);
    [CompilerGeneratedAttribute]
public string get_RestoreState();
    [CompilerGeneratedAttribute]
public void set_RestoreState(string value);
    [CompilerGeneratedAttribute]
public string get_RetryAfterInMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RetryAfterInMilliseconds(string value);
    [CompilerGeneratedAttribute]
public string get_SchemaVersion();
    [CompilerGeneratedAttribute]
public void set_SchemaVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ServerVersion();
    [CompilerGeneratedAttribute]
public void set_ServerVersion(string value);
    [CompilerGeneratedAttribute]
public string get_SessionToken();
    [CompilerGeneratedAttribute]
public void set_SessionToken(string value);
    [CompilerGeneratedAttribute]
public string get_ShareThroughput();
    [CompilerGeneratedAttribute]
public void set_ShareThroughput(string value);
    [CompilerGeneratedAttribute]
public string get_SoftMaxAllowedThroughput();
    [CompilerGeneratedAttribute]
public void set_SoftMaxAllowedThroughput(string value);
    [CompilerGeneratedAttribute]
public string get_SubStatus();
    [CompilerGeneratedAttribute]
public void set_SubStatus(string value);
    [CompilerGeneratedAttribute]
public string get_TentativeStoreChecksum();
    [CompilerGeneratedAttribute]
public void set_TentativeStoreChecksum(string value);
    [CompilerGeneratedAttribute]
public string get_TimeToLiveInSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeToLiveInSeconds(string value);
    [CompilerGeneratedAttribute]
public string get_TotalAccountThroughput();
    [CompilerGeneratedAttribute]
public void set_TotalAccountThroughput(string value);
    [CompilerGeneratedAttribute]
public string get_TransportRequestID();
    [CompilerGeneratedAttribute]
public void set_TransportRequestID(string value);
    [CompilerGeneratedAttribute]
public string get_UnflushedMergLogEntryCount();
    [CompilerGeneratedAttribute]
public void set_UnflushedMergLogEntryCount(string value);
    [CompilerGeneratedAttribute]
public string get_UserStrings();
    [CompilerGeneratedAttribute]
public void set_UserStrings(string value);
    [CompilerGeneratedAttribute]
public string get_VectorClockLocalProgress();
    [CompilerGeneratedAttribute]
public void set_VectorClockLocalProgress(string value);
    [CompilerGeneratedAttribute]
public string get_XDate();
    [CompilerGeneratedAttribute]
public void set_XDate(string value);
    [CompilerGeneratedAttribute]
public string get_XPConfigurationSessionsCount();
    [CompilerGeneratedAttribute]
public void set_XPConfigurationSessionsCount(string value);
    [CompilerGeneratedAttribute]
public string get_XPRole();
    [CompilerGeneratedAttribute]
public void set_XPRole(string value);
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual void Add(INameValueCollection collection);
    public sealed virtual String[] AllKeys();
    public sealed virtual void Clear();
    public sealed virtual INameValueCollection Clone();
    public sealed virtual int Count();
    public sealed virtual IEnumerator GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Azure.Documents.Collections.StoreResponseNameValueCollection/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<System-String,System-String>>-GetEnumerator>d__362")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<string, string>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.String>>.GetEnumerator();
    public sealed virtual String[] GetValues(string key);
    [IteratorStateMachineAttribute("Microsoft.Azure.Documents.Collections.StoreResponseNameValueCollection/<Keys>d__364")]
public sealed virtual IEnumerable`1<string> Keys();
    public sealed virtual NameValueCollection ToNameValueCollection();
    public sealed virtual void Remove(string key);
    public sealed virtual string Get(string key);
    public sealed virtual void Add(string key, string value);
    public sealed virtual void Set(string key, string value);
    public void UpdateHelper(string key, string value, bool throwIfAlreadyExists);
    private Dictionary`2<string, string> GetOrCreateLazyHeaders();
}
internal static class Microsoft.Azure.Documents.Common.DefaultTraceEx : object {
    public static void TraceException(Exception e);
    private static void TraceExceptionInternal(Exception e);
}
internal class Microsoft.Azure.Documents.CompositePath : JsonSerializable {
    [JsonPropertyAttribute]
public string Path { get; public set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public CompositePathSortOrder Order { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public CompositePathSortOrder get_Order();
    public void set_Order(CompositePathSortOrder value);
    internal virtual void Validate();
    public sealed virtual object Clone();
}
internal enum Microsoft.Azure.Documents.CompositePathSortOrder : Enum {
    public int value__;
    [EnumMemberAttribute]
public static CompositePathSortOrder Ascending;
    [EnumMemberAttribute]
public static CompositePathSortOrder Descending;
}
internal class Microsoft.Azure.Documents.ComputedProperty : JsonSerializable {
    [JsonPropertyAttribute]
public string Name { get; public set; }
    [JsonPropertyAttribute]
public string Query { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Query();
    public void set_Query(string value);
    internal virtual void Validate();
    public sealed virtual object Clone();
}
internal class Microsoft.Azure.Documents.ConcurrentPrng : object {
    private object mutex;
    private Random rng;
    public int Next(int maxValue);
}
internal class Microsoft.Azure.Documents.Conflict : Resource {
    public string SourceResourceId { get; internal set; }
    internal long ConflictLSN { get; internal set; }
    public OperationKind OperationKind { get; internal set; }
    public Type ResourceType { get; internal set; }
    public string get_SourceResourceId();
    internal void set_SourceResourceId(string value);
    internal long get_ConflictLSN();
    internal void set_ConflictLSN(long value);
    public T GetResource();
    internal void SetResource(T baseResource);
    public OperationKind get_OperationKind();
    internal void set_OperationKind(OperationKind value);
    public Type get_ResourceType();
    internal void set_ResourceType(Type value);
}
internal class Microsoft.Azure.Documents.ConflictException : DocumentClientException {
    public ConflictException(string message);
    public ConflictException(string message, SubStatusCodes subStatusCode);
    public ConflictException(string message, HttpResponseHeaders headers, Uri requestUri);
    public ConflictException(Exception innerException);
    public ConflictException(Exception innerException, SubStatusCodes subStatusCode);
    public ConflictException(string message, Exception innerException);
    public ConflictException(string message, INameValueCollection headers, Uri requestUri);
    public ConflictException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri, Nullable`1<SubStatusCodes> subStatusCode);
    private ConflictException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
}
internal enum Microsoft.Azure.Documents.ConflictResolutionMode : Enum {
    public int value__;
    public static ConflictResolutionMode LastWriterWins;
    public static ConflictResolutionMode Custom;
}
internal class Microsoft.Azure.Documents.ConflictResolutionPolicy : JsonSerializable {
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public ConflictResolutionMode Mode { get; public set; }
    [JsonPropertyAttribute]
public string ConflictResolutionPath { get; public set; }
    [JsonPropertyAttribute]
public string ConflictResolutionProcedure { get; public set; }
    public ConflictResolutionMode get_Mode();
    public void set_Mode(ConflictResolutionMode value);
    public string get_ConflictResolutionPath();
    public void set_ConflictResolutionPath(string value);
    public string get_ConflictResolutionProcedure();
    public void set_ConflictResolutionProcedure(string value);
    internal virtual void Validate();
}
internal enum Microsoft.Azure.Documents.ConnectionEvent : Enum {
    public int value__;
    public static ConnectionEvent ReadEof;
    public static ConnectionEvent ReadFailure;
}
internal class Microsoft.Azure.Documents.ConnectionHealthChecker : object {
    private static int MinNumberOfSendsSinceLastReceiveForUnhealthyConnection;
    private static bool AggressiveTimeoutDetectionEnabledDefaultValue;
    private static int TimeoutDetectionTimeLimitDefaultValueInSeconds;
    private static int TimeoutDetectionOnWriteThresholdDefaultValue;
    private static int TimeoutDetectionOnWriteTimeLimitDefaultValueInSeconds;
    private static int TimeoutDetectionOnHighFrequencyThresholdDefaultValue;
    private static int TimeoutDetectionOnHighFrequencyTimeLimitDefaultValueInSeconds;
    private static int TimeoutDetectionDisabledOnCPUThresholdDefaultValue;
    private static TimeSpan TimeoutDetectionCPUUsageCacheEvictionTimeInSeconds;
    private static TimeSpan sendHangGracePeriod;
    private static TimeSpan receiveHangGracePeriod;
    private static TimeSpan recentReceiveWindow;
    private static Byte[] healthCheckBuffer;
    private TimeSpan receiveDelayLimit;
    private TimeSpan sendDelayLimit;
    private TimeSpan idleConnectionTimeout;
    private bool aggressiveTimeoutDetectionEnabled;
    private TimeSpan timeoutDetectionTimeLimit;
    private int timeoutDetectionOnWriteThreshold;
    private TimeSpan timeoutDetectionOnWriteTimeLimit;
    private int timeoutDetectionOnHighFrequencyThreshold;
    private TimeSpan timeoutDetectionOnHighFrequencyTimeLimit;
    private double timeoutDetectionDisableCPUThreshold;
    private SystemUtilizationReaderBase systemUtilizationReader;
    private int transitTimeoutOnReadCounter;
    private int transitTimeoutOnWriteCounter;
    public ConnectionHealthChecker(TimeSpan sendDelayLimit, TimeSpan receiveDelayLimit, TimeSpan idleConnectionTimeout);
    private static ConnectionHealthChecker();
    public bool IsHealthy(DateTime currentTime, DateTime lastSendAttempt, DateTime lastSend, DateTime lastReceive, Nullable`1<DateTime> firstSendSinceLastReceive, long numberOfSendsSinceLastReceive, Socket socket);
    internal void UpdateTransitTimeoutCounters(bool isCompleted, bool isReadReqeust);
    private void IncrementTransitTimeoutOnWriteCounter();
    private void IncrementTransitTimeoutOnReadCounter();
    private void ResetTransitTimeoutCounters();
    private bool IsTransitTimeoutsDetected(DateTime currentTime, DateTime lastReceiveTime);
    private bool IsBlackholeDetected(DateTime currentTime, DateTime lastSendAttempt, DateTime lastSend, DateTime lastReceive, Nullable`1<DateTime> firstSendSinceLastReceive, long numberOfSendsSinceLastReceive);
    private static bool IsDataReceivedRecently(DateTime currentTime, DateTime lastReceiveTime);
    private static bool IsSocketConnectionEstablished(Socket socket);
    private bool IsConnectionIdled(DateTime currentTime, DateTime lastReceive);
    private bool IsCpuUtilizationBelowDisableTimeoutDetectionThreshold();
    private void SnapshotTransitTimeoutCounters(Int32& totalTransitTimeoutCounter, Int32& transitTimeoutOnWriteCounter);
}
internal class Microsoft.Azure.Documents.ConnectionStateListener : object {
    private IAddressResolver addressResolver;
    public ConnectionStateListener(IAddressResolver addressResolver);
    public sealed virtual void OnConnectionEvent(ConnectionEvent connectionEvent, DateTime eventTime, ServerKey serverKey);
}
internal enum Microsoft.Azure.Documents.ConsistencyLevel : Enum {
    public int value__;
    public static ConsistencyLevel Strong;
    public static ConsistencyLevel BoundedStaleness;
    public static ConsistencyLevel Session;
    public static ConsistencyLevel Eventual;
    public static ConsistencyLevel ConsistentPrefix;
}
[SuppressMessageAttribute("", "AvoidMultiLineComments")]
internal class Microsoft.Azure.Documents.ConsistencyReader : object {
    private static int maxNumberOfSecondaryReadRetries;
    private AddressSelector addressSelector;
    private IServiceConfigurationReader serviceConfigReader;
    private IAuthorizationTokenProvider authorizationTokenProvider;
    private StoreReader storeReader;
    private QuorumReader quorumReader;
    public string LastReadAddress { get; public set; }
    public ConsistencyReader(AddressSelector addressSelector, ISessionContainer sessionContainer, TransportClient transportClient, IServiceConfigurationReader serviceConfigReader, IAuthorizationTokenProvider authorizationTokenProvider, bool enableReplicaValidation);
    public string get_LastReadAddress();
    public void set_LastReadAddress(string value);
    public Task`1<StoreResponse> ReadAsync(DocumentServiceRequest entity, TimeoutHelper timeout, bool isInRetry, bool forceRefresh, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ConsistencyReader/<ReadPrimaryAsync>d__11")]
private Task`1<StoreResponse> ReadPrimaryAsync(DocumentServiceRequest entity, bool useSessionToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ConsistencyReader/<ReadAnyAsync>d__12")]
private Task`1<StoreResponse> ReadAnyAsync(DocumentServiceRequest entity, ReadMode readMode);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ConsistencyReader/<ReadSessionAsync>d__13")]
private Task`1<StoreResponse> ReadSessionAsync(DocumentServiceRequest entity, ReadMode readMode);
    private ReadMode DeduceReadMode(DocumentServiceRequest request, ConsistencyLevel& targetConsistencyLevel, Boolean& useSessionToken);
    public int GetMaxReplicaSetSize(DocumentServiceRequest entity);
    public int GetMinReplicaSetSize(DocumentServiceRequest entity);
}
[SuppressMessageAttribute("", "AvoidMultiLineComments")]
internal class Microsoft.Azure.Documents.ConsistencyWriter : object {
    private static int maxNumberOfWriteBarrierReadRetries;
    private static int delayBetweenWriteBarrierCallsInMs;
    private static int maxShortBarrierRetriesForMultiRegion;
    private static int shortbarrierRetryIntervalInMsForMultiRegion;
    private static TimeSpan shortDelayBetweenWriteBarrierCallsForMultipleRegions;
    private static TimeSpan defaultDelayBetweenWriteBarrierCalls;
    private static TimeSpan[] defaultBarrierRequestDelays;
    private static TimeSpan totalAllowedBarrierRequestDelay;
    private StoreReader storeReader;
    private TransportClient transportClient;
    private AddressSelector addressSelector;
    private ISessionContainer sessionContainer;
    private IServiceConfigurationReader serviceConfigReader;
    private IAuthorizationTokenProvider authorizationTokenProvider;
    private bool useMultipleWriteLocations;
    [CompilerGeneratedAttribute]
private string <LastWriteAddress>k__BackingField;
    internal string LastWriteAddress { get; private set; }
    public ConsistencyWriter(AddressSelector addressSelector, ISessionContainer sessionContainer, TransportClient transportClient, IServiceConfigurationReader serviceConfigReader, IAuthorizationTokenProvider authorizationTokenProvider, bool useMultipleWriteLocations, bool enableReplicaValidation);
    private static ConsistencyWriter();
    [CompilerGeneratedAttribute]
internal string get_LastWriteAddress();
    [CompilerGeneratedAttribute]
private void set_LastWriteAddress(string value);
    private static TimeSpan[] GetDefaultBarrierRequestDelays();
    private static TimeSpan GetTotalAllowedBarrierRequestDelay();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ConsistencyWriter/<WriteAsync>d__22")]
public Task`1<StoreResponse> WriteAsync(DocumentServiceRequest entity, TimeoutHelper timeout, bool forceRefresh, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ConsistencyWriter/<WritePrivateAsync>d__23")]
private Task`1<StoreResponse> WritePrivateAsync(DocumentServiceRequest request, TimeoutHelper timeout, bool forceRefresh);
    private bool ShouldPerformWriteBarrierForGlobalStrong(StoreResult storeResult);
    private Task`1<bool> WaitForWriteBarrierAsync(DocumentServiceRequest barrierRequest, long selectedGlobalCommittedLsn);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ConsistencyWriter/<WaitForWriteBarrierOldAsync>d__26")]
private Task`1<bool> WaitForWriteBarrierOldAsync(DocumentServiceRequest barrierRequest, long selectedGlobalCommittedLsn);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ConsistencyWriter/<WaitForWriteBarrierNewAsync>d__27")]
private Task`1<bool> WaitForWriteBarrierNewAsync(DocumentServiceRequest barrierRequest, long selectedGlobalCommittedLsn);
}
internal static class Microsoft.Azure.Documents.Constants : object {
    public static char DBSeparator;
    public static char ModeSeparator;
    public static char StartArray;
    public static char EndArray;
    public static char PartitionSeparator;
    public static char UrlPathSeparator;
    public static string DataContractNamespace;
    public static int MaxResourceSizeInBytes;
    public static int MaxDirectModeBatchRequestBodySizeInBytes;
    public static int MaxOperationsInDirectModeBatchRequest;
    public static int MaxGatewayModeBatchRequestBodySizeInBytes;
    public static int MaxOperationsInGatewayModeBatchRequest;
    public static string FirewallAuthorization;
    public static string TableSecondaryEndpointSuffix;
}
internal enum Microsoft.Azure.Documents.ContentSerializationFormat : Enum {
    public int value__;
    public static ContentSerializationFormat JsonText;
    public static ContentSerializationFormat CosmosBinary;
    public static ContentSerializationFormat HybridRow;
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.CustomTypeExtensions : object {
    public static int UnicodeEncodingCharSize;
    public static string SDKName;
    public static string SDKVersion;
    public static Delegate CreateDelegate(Type delegateType, object target, MethodInfo methodInfo);
    public static IntPtr SecureStringToCoTaskMemAnsi(SecureString secureString);
    public static void SetActivityId(Guid& id);
    public static Random GetRandomNumber();
    public static QueryRequestPerformanceActivity StartActivity(DocumentServiceRequest request);
    public static string GenerateBaseUserAgentString();
    public static bool ConfirmOpen(Socket socket);
    public static bool ByPassQueryParsing();
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static Type GetBaseType(Type type);
    [ExtensionAttribute]
public static Type GeUnderlyingSystemType(Type type);
    [ExtensionAttribute]
public static Assembly GetAssembly(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<CustomAttributeData> GetsCustomAttributes(Type type);
}
internal class Microsoft.Azure.Documents.Database : Resource {
    private InAccountRestoreParameters restoreParameters;
    [JsonPropertyAttribute]
public string CollectionsLink { get; }
    [JsonPropertyAttribute]
public string UsersLink { get; }
    internal string UserDefinedTypesLink { get; }
    [JsonPropertyAttribute]
internal Nullable`1<DatabaseOrCollectionCreateMode> CreateMode { get; internal set; }
    [JsonPropertyAttribute]
internal InAccountRestoreParameters RestoreParameters { get; internal set; }
    public string get_CollectionsLink();
    public string get_UsersLink();
    internal string get_UserDefinedTypesLink();
    internal Nullable`1<DatabaseOrCollectionCreateMode> get_CreateMode();
    internal void set_CreateMode(Nullable`1<DatabaseOrCollectionCreateMode> value);
    internal InAccountRestoreParameters get_RestoreParameters();
    internal void set_RestoreParameters(InAccountRestoreParameters value);
    internal virtual void Validate();
    internal virtual void OnSave();
}
internal enum Microsoft.Azure.Documents.DatabaseOrCollectionCreateMode : Enum {
    public int value__;
    public static DatabaseOrCollectionCreateMode Default;
    public static DatabaseOrCollectionCreateMode Restore;
}
internal enum Microsoft.Azure.Documents.DataEncryptionKeyStatus : Enum {
    public int value__;
    public static DataEncryptionKeyStatus Active;
    public static DataEncryptionKeyStatus Revoked;
    public static DataEncryptionKeyStatus None;
}
internal class Microsoft.Azure.Documents.DataMaskingIncludedPath : JsonSerializable {
    [JsonPropertyAttribute]
public string Path { get; public set; }
    public string get_Path();
    public void set_Path(string value);
}
internal class Microsoft.Azure.Documents.DataMaskingPolicy : JsonSerializable {
    private Collection`1<DataMaskingIncludedPath> includedPaths;
    private bool isPolicyEnabled;
    [JsonPropertyAttribute]
public Collection`1<DataMaskingIncludedPath> IncludedPaths { get; public set; }
    [JsonPropertyAttribute]
public bool IsPolicyEnabled { get; public set; }
    public Collection`1<DataMaskingIncludedPath> get_IncludedPaths();
    public void set_IncludedPaths(Collection`1<DataMaskingIncludedPath> value);
    public bool get_IsPolicyEnabled();
    public void set_IsPolicyEnabled(bool value);
    internal virtual void OnSave();
}
internal enum Microsoft.Azure.Documents.DataType : Enum {
    public int value__;
    public static DataType Number;
    public static DataType String;
    public static DataType Point;
    public static DataType LineString;
    public static DataType Polygon;
    public static DataType MultiPolygon;
}
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
internal enum Microsoft.Azure.Documents.DistanceFunction : Enum {
    public int value__;
    [EnumMemberAttribute]
public static DistanceFunction Euclidean;
    [EnumMemberAttribute]
public static DistanceFunction Cosine;
    [EnumMemberAttribute]
public static DistanceFunction DotProduct;
}
internal class Microsoft.Azure.Documents.Document : Resource {
    public string AttachmentsLink { get; }
    [JsonPropertyAttribute]
public Nullable`1<int> TimeToLive { get; public set; }
    public string get_AttachmentsLink();
    public Nullable`1<int> get_TimeToLive();
    public void set_TimeToLive(Nullable`1<int> value);
    internal static Document FromObject(object document, JsonSerializerSettings settings);
    private object GetProperty(string propertyName, Type returnType);
    private object SetProperty(string propertyName, object value);
    private T AsType();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
internal class Microsoft.Azure.Documents.DocumentClientException : Exception {
    private Error error;
    private Nullable`1<SubStatusCodes> substatus;
    private INameValueCollection responseHeaders;
    private string rawErrorMessage;
    private bool rawErrorMessageOnly;
    [CompilerGeneratedAttribute]
private Nullable`1<HttpStatusCode> <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportRequestStats <TransportRequestStats>k__BackingField;
    [CompilerGeneratedAttribute]
private IClientSideRequestStatistics <RequestStatistics>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKeyRangeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseArmErrorResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <RequestUri>k__BackingField;
    public Error Error { get; internal set; }
    public string ActivityId { get; }
    public TimeSpan RetryAfter { get; }
    public NameValueCollection ResponseHeaders { get; }
    internal INameValueCollection Headers { get; }
    public Nullable`1<HttpStatusCode> StatusCode { get; internal set; }
    internal string StatusDescription { get; internal set; }
    internal TransportRequestStats TransportRequestStats { get; internal set; }
    public double RequestCharge { get; }
    public string ScriptLog { get; }
    public string Message { get; }
    internal string PublicMessage { get; }
    internal string RawErrorMessage { get; }
    internal IClientSideRequestStatistics RequestStatistics { get; internal set; }
    internal long LSN { get; internal set; }
    internal string PartitionKeyRangeId { get; internal set; }
    internal string ResourceAddress { get; internal set; }
    internal bool UseArmErrorResponse { get; internal set; }
    internal Uri RequestUri { get; private set; }
    internal DocumentClientException(Error errorResource, HttpResponseHeaders responseHeaders, Nullable`1<HttpStatusCode> statusCode);
    internal DocumentClientException(string message, Exception innerException, Nullable`1<HttpStatusCode> statusCode, Uri requestUri, string statusDescription);
    internal DocumentClientException(string message, Exception innerException, HttpResponseHeaders responseHeaders, Nullable`1<HttpStatusCode> statusCode, Uri requestUri, Nullable`1<SubStatusCodes> substatusCode, bool traceCallStack, bool rawErrorMessageOnly);
    internal DocumentClientException(string message, Exception innerException, INameValueCollection responseHeaders, Nullable`1<HttpStatusCode> statusCode, Nullable`1<SubStatusCodes> substatusCode, Uri requestUri);
    internal DocumentClientException(string message, Exception innerException, INameValueCollection responseHeaders, Nullable`1<HttpStatusCode> statusCode, Uri requestUri, bool rawErrorMessageOnly);
    internal DocumentClientException(string message, HttpStatusCode statusCode, SubStatusCodes subStatusCode);
    internal DocumentClientException(SerializationInfo info, StreamingContext context, Nullable`1<HttpStatusCode> statusCode);
    internal DocumentClientException(SerializationInfo info, StreamingContext context);
    public Error get_Error();
    internal void set_Error(Error value);
    public string get_ActivityId();
    public TimeSpan get_RetryAfter();
    public NameValueCollection get_ResponseHeaders();
    internal INameValueCollection get_Headers();
    [CompilerGeneratedAttribute]
public Nullable`1<HttpStatusCode> get_StatusCode();
    [CompilerGeneratedAttribute]
internal void set_StatusCode(Nullable`1<HttpStatusCode> value);
    [CompilerGeneratedAttribute]
internal string get_StatusDescription();
    [CompilerGeneratedAttribute]
internal void set_StatusDescription(string value);
    [CompilerGeneratedAttribute]
internal TransportRequestStats get_TransportRequestStats();
    [CompilerGeneratedAttribute]
internal void set_TransportRequestStats(TransportRequestStats value);
    public double get_RequestCharge();
    public string get_ScriptLog();
    public virtual string get_Message();
    internal virtual string get_PublicMessage();
    internal string get_RawErrorMessage();
    [CompilerGeneratedAttribute]
internal IClientSideRequestStatistics get_RequestStatistics();
    [CompilerGeneratedAttribute]
internal void set_RequestStatistics(IClientSideRequestStatistics value);
    [CompilerGeneratedAttribute]
internal long get_LSN();
    [CompilerGeneratedAttribute]
internal void set_LSN(long value);
    [CompilerGeneratedAttribute]
internal string get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
internal void set_PartitionKeyRangeId(string value);
    [CompilerGeneratedAttribute]
internal string get_ResourceAddress();
    [CompilerGeneratedAttribute]
internal void set_ResourceAddress(string value);
    [CompilerGeneratedAttribute]
internal bool get_UseArmErrorResponse();
    [CompilerGeneratedAttribute]
internal void set_UseArmErrorResponse(bool value);
    [CompilerGeneratedAttribute]
internal Uri get_RequestUri();
    [CompilerGeneratedAttribute]
private void set_RequestUri(Uri value);
    private static string MessageWithActivityId(string message, INameValueCollection responseHeaders);
    private static string MessageWithActivityId(string message, HttpResponseHeaders responseHeaders);
    private static string MessageWithActivityId(string message, string activityIdFromHeaders);
    private static string SerializeHTTPResponseHeaders(HttpResponseHeaders responseHeaders);
    internal SubStatusCodes GetSubStatus();
    internal static SubStatusCodes GetExceptionSubStatusForGoneRetryPolicy(Exception exception);
    private static string SerializeHTTPResponseHeaders(INameValueCollection responseHeaders);
}
internal class Microsoft.Azure.Documents.DocumentCollection : Resource {
    private IndexingPolicy indexingPolicy;
    private GeospatialConfig geospatialConfig;
    private PartitionKeyDefinition partitionKey;
    private SchemaDiscoveryPolicy schemaDiscoveryPolicy;
    private UniqueKeyPolicy uniqueKeyPolicy;
    private UniqueIndexReIndexContext uniqueIndexReIndexContext;
    private ConflictResolutionPolicy conflictResolutionPolicy;
    private ChangeFeedPolicy changeFeedPolicy;
    private CollectionBackupPolicy collectionBackupPolicy;
    private MaterializedViewDefinition materializedViewDefinition;
    private ByokConfig byokConfig;
    private ClientEncryptionPolicy clientEncryptionPolicy;
    private DataMaskingPolicy dataMaskingPolicy;
    private Collection`1<MaterializedViews> materializedViews;
    private EncryptionScopeMetadata encryptionScopeMetadata;
    private InAccountRestoreParameters restoreParameters;
    private byte uniqueIndexNameEncodingMode;
    private Collection`1<ComputedProperty> computedProperties;
    private Collection`1<string> userStrings;
    private VectorEmbeddingPolicy vectorEmbeddingPolicy;
    public IndexingPolicy IndexingPolicy { get; public set; }
    [JsonPropertyAttribute]
internal Collection`1<ComputedProperty> ComputedProperties { get; internal set; }
    [JsonPropertyAttribute]
public GeospatialConfig GeospatialConfig { get; public set; }
    [JsonPropertyAttribute]
internal string EncryptionScopeId { get; internal set; }
    [JsonPropertyAttribute]
internal EncryptionScopeMetadata EncryptionScopeMetadata { get; internal set; }
    [JsonPropertyAttribute]
internal MaterializedViewDefinition MaterializedViewDefinition { get; internal set; }
    [JsonPropertyAttribute]
internal ByokConfig ByokConfig { get; internal set; }
    [JsonPropertyAttribute]
internal byte UniqueIndexNameEncodingMode { get; internal set; }
    [JsonPropertyAttribute]
public string DocumentsLink { get; }
    [JsonPropertyAttribute]
public string StoredProceduresLink { get; }
    public string TriggersLink { get; }
    public string UserDefinedFunctionsLink { get; }
    public string ConflictsLink { get; }
    [JsonPropertyAttribute]
public PartitionKeyDefinition PartitionKey { get; public set; }
    [JsonPropertyAttribute]
public Nullable`1<int> DefaultTimeToLive { get; public set; }
    [JsonPropertyAttribute]
public string TimeToLivePropertyPath { get; public set; }
    internal SchemaDiscoveryPolicy SchemaDiscoveryPolicy { get; internal set; }
    [JsonPropertyAttribute]
public UniqueKeyPolicy UniqueKeyPolicy { get; public set; }
    [JsonPropertyAttribute]
internal UniqueIndexReIndexContext UniqueIndexReIndexContext { get; internal set; }
    [JsonPropertyAttribute]
public ConflictResolutionPolicy ConflictResolutionPolicy { get; public set; }
    [ObsoleteAttribute("PartitionKeyDeleteThroughputFraction is deprecated.")]
[JsonPropertyAttribute]
public double PartitionKeyDeleteThroughputFraction { get; public set; }
    [JsonIgnoreAttribute]
public IReadOnlyList`1<PartitionKeyRangeStatistics> PartitionKeyRangeStatistics { get; }
    [JsonPropertyAttribute]
internal IReadOnlyList`1<JRaw> StatisticsJRaw { get; internal set; }
    internal bool HasPartitionKey { get; }
    internal PartitionKeyInternal NonePartitionKeyValue { get; }
    [JsonPropertyAttribute]
internal ChangeFeedPolicy ChangeFeedPolicy { get; internal set; }
    [JsonPropertyAttribute]
internal Nullable`1<int> AnalyticalStorageTimeToLive { get; internal set; }
    [JsonPropertyAttribute]
internal Nullable`1<bool> AllowMaterializedViews { get; internal set; }
    [JsonPropertyAttribute]
internal CollectionBackupPolicy CollectionBackupPolicy { get; internal set; }
    [JsonPropertyAttribute]
internal JRaw SchemaPolicy { get; internal set; }
    [JsonPropertyAttribute]
internal InternalSchemaProperties InternalSchemaProperties { get; internal set; }
    [JsonPropertyAttribute]
internal ClientEncryptionPolicy ClientEncryptionPolicy { get; internal set; }
    [JsonPropertyAttribute]
internal DataMaskingPolicy DataMaskingPolicy { get; internal set; }
    [JsonPropertyAttribute]
internal VectorEmbeddingPolicy VectorEmbeddingPolicy { get; internal set; }
    [JsonPropertyAttribute]
internal Collection`1<MaterializedViews> MaterializedViews { get; internal set; }
    [JsonPropertyAttribute]
internal Nullable`1<DatabaseOrCollectionCreateMode> CreateMode { get; internal set; }
    [JsonPropertyAttribute]
internal InAccountRestoreParameters RestoreParameters { get; internal set; }
    [JsonPropertyAttribute]
internal Collection`1<string> UserStrings { get; internal set; }
    public IndexingPolicy get_IndexingPolicy();
    public void set_IndexingPolicy(IndexingPolicy value);
    internal Collection`1<ComputedProperty> get_ComputedProperties();
    internal void set_ComputedProperties(Collection`1<ComputedProperty> value);
    public GeospatialConfig get_GeospatialConfig();
    public void set_GeospatialConfig(GeospatialConfig value);
    internal string get_EncryptionScopeId();
    internal void set_EncryptionScopeId(string value);
    internal EncryptionScopeMetadata get_EncryptionScopeMetadata();
    internal void set_EncryptionScopeMetadata(EncryptionScopeMetadata value);
    internal MaterializedViewDefinition get_MaterializedViewDefinition();
    internal void set_MaterializedViewDefinition(MaterializedViewDefinition value);
    internal ByokConfig get_ByokConfig();
    internal void set_ByokConfig(ByokConfig value);
    internal byte get_UniqueIndexNameEncodingMode();
    internal void set_UniqueIndexNameEncodingMode(byte value);
    public string get_DocumentsLink();
    public string get_StoredProceduresLink();
    public string get_TriggersLink();
    public string get_UserDefinedFunctionsLink();
    public string get_ConflictsLink();
    public PartitionKeyDefinition get_PartitionKey();
    public void set_PartitionKey(PartitionKeyDefinition value);
    public Nullable`1<int> get_DefaultTimeToLive();
    public void set_DefaultTimeToLive(Nullable`1<int> value);
    public string get_TimeToLivePropertyPath();
    public void set_TimeToLivePropertyPath(string value);
    internal SchemaDiscoveryPolicy get_SchemaDiscoveryPolicy();
    internal void set_SchemaDiscoveryPolicy(SchemaDiscoveryPolicy value);
    public UniqueKeyPolicy get_UniqueKeyPolicy();
    public void set_UniqueKeyPolicy(UniqueKeyPolicy value);
    internal UniqueIndexReIndexContext get_UniqueIndexReIndexContext();
    internal void set_UniqueIndexReIndexContext(UniqueIndexReIndexContext value);
    public ConflictResolutionPolicy get_ConflictResolutionPolicy();
    public void set_ConflictResolutionPolicy(ConflictResolutionPolicy value);
    public double get_PartitionKeyDeleteThroughputFraction();
    public void set_PartitionKeyDeleteThroughputFraction(double value);
    public IReadOnlyList`1<PartitionKeyRangeStatistics> get_PartitionKeyRangeStatistics();
    internal IReadOnlyList`1<JRaw> get_StatisticsJRaw();
    internal void set_StatisticsJRaw(IReadOnlyList`1<JRaw> value);
    internal bool get_HasPartitionKey();
    internal PartitionKeyInternal get_NonePartitionKeyValue();
    internal ChangeFeedPolicy get_ChangeFeedPolicy();
    internal void set_ChangeFeedPolicy(ChangeFeedPolicy value);
    internal Nullable`1<int> get_AnalyticalStorageTimeToLive();
    internal void set_AnalyticalStorageTimeToLive(Nullable`1<int> value);
    internal Nullable`1<bool> get_AllowMaterializedViews();
    internal void set_AllowMaterializedViews(Nullable`1<bool> value);
    internal CollectionBackupPolicy get_CollectionBackupPolicy();
    internal void set_CollectionBackupPolicy(CollectionBackupPolicy value);
    internal JRaw get_SchemaPolicy();
    internal void set_SchemaPolicy(JRaw value);
    internal InternalSchemaProperties get_InternalSchemaProperties();
    internal void set_InternalSchemaProperties(InternalSchemaProperties value);
    internal bool IsMaterializedView();
    internal ClientEncryptionPolicy get_ClientEncryptionPolicy();
    internal void set_ClientEncryptionPolicy(ClientEncryptionPolicy value);
    internal DataMaskingPolicy get_DataMaskingPolicy();
    internal void set_DataMaskingPolicy(DataMaskingPolicy value);
    internal VectorEmbeddingPolicy get_VectorEmbeddingPolicy();
    internal void set_VectorEmbeddingPolicy(VectorEmbeddingPolicy value);
    internal Collection`1<MaterializedViews> get_MaterializedViews();
    internal void set_MaterializedViews(Collection`1<MaterializedViews> value);
    internal Nullable`1<DatabaseOrCollectionCreateMode> get_CreateMode();
    internal void set_CreateMode(Nullable`1<DatabaseOrCollectionCreateMode> value);
    internal InAccountRestoreParameters get_RestoreParameters();
    internal void set_RestoreParameters(InAccountRestoreParameters value);
    internal Collection`1<string> get_UserStrings();
    internal void set_UserStrings(Collection`1<string> value);
    internal virtual void Validate();
    internal virtual void OnSave();
}
internal class Microsoft.Azure.Documents.DocumentServiceRequest : object {
    private bool isDisposed;
    private static char PreferHeadersSeparator;
    private static string PreferHeaderValueFormat;
    private ServiceIdentity serviceIdentity;
    private PartitionKeyRangeIdentity partitionKeyRangeIdentity;
    [CompilerGeneratedAttribute]
private bool <IsNameBased>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResourceNameParsedFromUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseGatewayMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseStatusCodeForFailures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseStatusCodeFor429>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseStatusCodeForBadRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableRetryWithPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemAuthorizationParameters <SystemAuthorizationParams>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentServiceRequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFeed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntityId>k__BackingField;
    [CompilerGeneratedAttribute]
private INameValueCollection <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private CloneableStream <CloneableBody>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthorizationTokenType <RequestAuthorizationTokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationType <OperationType>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceType <ResourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceNameCacheRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastCollectionRoutingMapHashCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForcePartitionKeyRangeRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceCollectionRoutingMapRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceMasterRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerSettings <SerializerSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <DefaultReplicaIndex>k__BackingField;
    public bool IsNameBased { get; private set; }
    public string DatabaseName { get; private set; }
    public string CollectionName { get; private set; }
    public string DocumentName { get; private set; }
    public bool IsResourceNameParsedFromUri { get; private set; }
    public bool UseGatewayMode { get; public set; }
    public bool UseStatusCodeForFailures { get; public set; }
    public bool UseStatusCodeFor429 { get; public set; }
    public bool UseStatusCodeForBadRequest { get; public set; }
    public bool DisableRetryWithPolicy { get; public set; }
    public ServiceIdentity ServiceIdentity { get; private set; }
    public SystemAuthorizationParameters SystemAuthorizationParams { get; public set; }
    public PartitionKeyRangeIdentity PartitionKeyRangeIdentity { get; private set; }
    public string ResourceId { get; public set; }
    public DocumentServiceRequestContext RequestContext { get; public set; }
    public string ResourceAddress { get; private set; }
    public bool IsFeed { get; public set; }
    public string EntityId { get; public set; }
    public INameValueCollection Headers { get; private set; }
    public IDictionary`2<string, object> Properties { get; public set; }
    public Stream Body { get; public set; }
    public CloneableStream CloneableBody { get; private set; }
    public AuthorizationTokenType RequestAuthorizationTokenType { get; public set; }
    public bool IsBodySeekableClonableAndCountable { get; }
    public OperationType OperationType { get; private set; }
    public ResourceType ResourceType { get; private set; }
    public string QueryString { get; public set; }
    public string Continuation { get; public set; }
    internal string ApiVersion { get; }
    public bool ForceNameCacheRefresh { get; public set; }
    public int LastCollectionRoutingMapHashCode { get; public set; }
    public bool ForcePartitionKeyRangeRefresh { get; public set; }
    public bool ForceCollectionRoutingMapRefresh { get; public set; }
    public bool ForceMasterRefresh { get; public set; }
    public bool IsReadOnlyRequest { get; }
    public bool IsReadOnlyScript { get; }
    public bool IsChangeFeedRequest { get; }
    public string HttpMethod { get; }
    public JsonSerializerSettings SerializerSettings { get; public set; }
    public Nullable`1<UInt32> DefaultReplicaIndex { get; public set; }
    internal DocumentServiceRequest(OperationType operationType, string resourceIdOrFullName, ResourceType resourceType, Stream body, INameValueCollection headers, bool isNameBased, AuthorizationTokenType authorizationTokenType);
    internal DocumentServiceRequest(OperationType operationType, ResourceType resourceType, string path, Stream body, AuthorizationTokenType authorizationTokenType, INameValueCollection headers);
    internal DocumentServiceRequest(OperationType operationType, ResourceType resourceType, string path, Stream body, AuthorizationTokenType authorizationTokenType, INameValueCollection headers, bool isNameBased, bool isFeed, string resourceIdOrFullName, string databaseName, string collectionName, string documentName, string resourceTypeString);
    [CompilerGeneratedAttribute]
public bool get_IsNameBased();
    [CompilerGeneratedAttribute]
private void set_IsNameBased(bool value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
private void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionName();
    [CompilerGeneratedAttribute]
private void set_CollectionName(string value);
    [CompilerGeneratedAttribute]
public string get_DocumentName();
    [CompilerGeneratedAttribute]
private void set_DocumentName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsResourceNameParsedFromUri();
    [CompilerGeneratedAttribute]
private void set_IsResourceNameParsedFromUri(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseGatewayMode();
    [CompilerGeneratedAttribute]
public void set_UseGatewayMode(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseStatusCodeForFailures();
    [CompilerGeneratedAttribute]
public void set_UseStatusCodeForFailures(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseStatusCodeFor429();
    [CompilerGeneratedAttribute]
public void set_UseStatusCodeFor429(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseStatusCodeForBadRequest();
    [CompilerGeneratedAttribute]
public void set_UseStatusCodeForBadRequest(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableRetryWithPolicy();
    [CompilerGeneratedAttribute]
public void set_DisableRetryWithPolicy(bool value);
    public ServiceIdentity get_ServiceIdentity();
    private void set_ServiceIdentity(ServiceIdentity value);
    [CompilerGeneratedAttribute]
public SystemAuthorizationParameters get_SystemAuthorizationParams();
    [CompilerGeneratedAttribute]
public void set_SystemAuthorizationParams(SystemAuthorizationParameters value);
    public PartitionKeyRangeIdentity get_PartitionKeyRangeIdentity();
    private void set_PartitionKeyRangeIdentity(PartitionKeyRangeIdentity value);
    public void RouteTo(ServiceIdentity serviceIdentity);
    public void RouteTo(PartitionKeyRangeIdentity partitionKeyRangeIdentity);
    [CompilerGeneratedAttribute]
public string get_ResourceId();
    [CompilerGeneratedAttribute]
public void set_ResourceId(string value);
    [CompilerGeneratedAttribute]
public DocumentServiceRequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
public void set_RequestContext(DocumentServiceRequestContext value);
    [CompilerGeneratedAttribute]
public string get_ResourceAddress();
    [CompilerGeneratedAttribute]
private void set_ResourceAddress(string value);
    [CompilerGeneratedAttribute]
public bool get_IsFeed();
    [CompilerGeneratedAttribute]
public void set_IsFeed(bool value);
    [CompilerGeneratedAttribute]
public string get_EntityId();
    [CompilerGeneratedAttribute]
public void set_EntityId(string value);
    [CompilerGeneratedAttribute]
public INameValueCollection get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(INameValueCollection value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public Stream get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(Stream value);
    [CompilerGeneratedAttribute]
public CloneableStream get_CloneableBody();
    [CompilerGeneratedAttribute]
private void set_CloneableBody(CloneableStream value);
    [CompilerGeneratedAttribute]
public AuthorizationTokenType get_RequestAuthorizationTokenType();
    [CompilerGeneratedAttribute]
public void set_RequestAuthorizationTokenType(AuthorizationTokenType value);
    public bool get_IsBodySeekableClonableAndCountable();
    [CompilerGeneratedAttribute]
public OperationType get_OperationType();
    [CompilerGeneratedAttribute]
private void set_OperationType(OperationType value);
    [CompilerGeneratedAttribute]
public ResourceType get_ResourceType();
    [CompilerGeneratedAttribute]
private void set_ResourceType(ResourceType value);
    [CompilerGeneratedAttribute]
public string get_QueryString();
    [CompilerGeneratedAttribute]
public void set_QueryString(string value);
    public string get_Continuation();
    public void set_Continuation(string value);
    internal string get_ApiVersion();
    internal static bool IsGatewayMode(ResourceType resourceType, OperationType operationType);
    [CompilerGeneratedAttribute]
public bool get_ForceNameCacheRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceNameCacheRefresh(bool value);
    [CompilerGeneratedAttribute]
public int get_LastCollectionRoutingMapHashCode();
    [CompilerGeneratedAttribute]
public void set_LastCollectionRoutingMapHashCode(int value);
    [CompilerGeneratedAttribute]
public bool get_ForcePartitionKeyRangeRefresh();
    [CompilerGeneratedAttribute]
public void set_ForcePartitionKeyRangeRefresh(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceCollectionRoutingMapRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceCollectionRoutingMapRefresh(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceMasterRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceMasterRefresh(bool value);
    public bool get_IsReadOnlyRequest();
    public bool get_IsReadOnlyScript();
    public bool get_IsChangeFeedRequest();
    public string get_HttpMethod();
    [CompilerGeneratedAttribute]
public JsonSerializerSettings get_SerializerSettings();
    [CompilerGeneratedAttribute]
public void set_SerializerSettings(JsonSerializerSettings value);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_DefaultReplicaIndex();
    [CompilerGeneratedAttribute]
public void set_DefaultReplicaIndex(Nullable`1<UInt32> value);
    public sealed virtual void Dispose();
    public bool IsValidAddress(ResourceType resourceType);
    public void AddPreferHeader(string preferHeaderName, string preferHeaderValue);
    public static DocumentServiceRequest CreateFromResource(DocumentServiceRequest request, Resource modifiedResource);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope")]
public static DocumentServiceRequest Create(OperationType operationType, Resource resource, ResourceType resourceType, AuthorizationTokenType authorizationTokenType, INameValueCollection headers, string ownerResourceId, SerializationFormattingPolicy formattingPolicy);
    public static DocumentServiceRequest Create(OperationType operationType, ResourceType resourceType, MemoryStream stream, AuthorizationTokenType authorizationTokenType, INameValueCollection headers);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope")]
public static DocumentServiceRequest Create(OperationType operationType, string ownerResourceId, Byte[] seralizedResource, ResourceType resourceType, AuthorizationTokenType authorizationTokenType, INameValueCollection headers, SerializationFormattingPolicy formattingPolicy);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope")]
public static DocumentServiceRequest Create(OperationType operationType, string ownerResourceId, ResourceType resourceType, bool isNameBased, AuthorizationTokenType authorizationTokenType, Byte[] seralizedResource, INameValueCollection headers, SerializationFormattingPolicy formattingPolicy);
    public static DocumentServiceRequest Create(OperationType operationType, string resourceId, ResourceType resourceType, Stream body, AuthorizationTokenType authorizationTokenType, INameValueCollection headers);
    public static DocumentServiceRequest Create(OperationType operationType, string resourceId, ResourceType resourceType, AuthorizationTokenType authorizationTokenType, INameValueCollection headers);
    public static DocumentServiceRequest CreateFromName(OperationType operationType, string resourceFullName, ResourceType resourceType, AuthorizationTokenType authorizationTokenType, INameValueCollection headers);
    public static DocumentServiceRequest CreateFromName(OperationType operationType, Resource resource, ResourceType resourceType, INameValueCollection headers, string resourceFullName, AuthorizationTokenType authorizationTokenType, SerializationFormattingPolicy formattingPolicy);
    public static DocumentServiceRequest Create(OperationType operationType, ResourceType resourceType, AuthorizationTokenType authorizationTokenType);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope")]
public static DocumentServiceRequest Create(OperationType operationType, string relativePath, Resource resource, ResourceType resourceType, AuthorizationTokenType authorizationTokenType, INameValueCollection headers, SerializationFormattingPolicy formattingPolicy, JsonSerializerSettings settings);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope")]
public static DocumentServiceRequest Create(OperationType operationType, Uri requestUri, Resource resource, ResourceType resourceType, AuthorizationTokenType authorizationTokenType, INameValueCollection headers, SerializationFormattingPolicy formattingPolicy);
    public static DocumentServiceRequest Create(OperationType operationType, ResourceType resourceType, string relativePath, AuthorizationTokenType authorizationTokenType, INameValueCollection headers);
    public static DocumentServiceRequest Create(OperationType operationType, ResourceType resourceType, Uri requestUri, AuthorizationTokenType authorizationTokenType, INameValueCollection headers);
    public static DocumentServiceRequest Create(OperationType operationType, ResourceType resourceType, string relativePath, Stream resourceStream, AuthorizationTokenType authorizationTokenType, INameValueCollection headers);
    internal static DocumentServiceRequest Create(OperationType operationType, ResourceType resourceType, string relativePath, Stream resourceStream, AuthorizationTokenType authorizationTokenType, INameValueCollection headers, bool isNameBased, bool isFeed, string resourceIdOrFullName, string databaseName, string collectionName, string documentName, string resourceTypeString);
    public static DocumentServiceRequest Create(OperationType operationType, ResourceType resourceType, Uri requestUri, Stream resourceStream, AuthorizationTokenType authorizationTokenType, INameValueCollection headers);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.DocumentServiceRequest/<EnsureBufferedBodyAsync>d__178")]
public Task EnsureBufferedBodyAsync(bool allowUnsafeDataAccess);
    public void ClearRoutingHints();
    public DocumentServiceRequest Clone();
    private void InitializeWithDataParsedFromUri(string path, bool isNameBased, bool isFeed, string resourceIdOrFullName, string databaseName, string collectionName, string documentName, string resourceTypeString);
}
internal class Microsoft.Azure.Documents.DocumentServiceRequestContext : object {
    private ReferenceCountedDisposable`1<StoreResult> quorumSelectedStoreResponse;
    [CompilerGeneratedAttribute]
private TimeoutHelper <TimeoutHelper>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestChargeTracker <RequestChargeTracker>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceRefreshAddressCache>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastPartitionAddressInformationHashCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <OriginalRequestConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private long <QuorumSelectedLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private long <GlobalCommittedSelectedLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceCountedDisposable`1<StoreResult> <GlobalStrongWriteStoreResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceIdentity <TargetIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PerformLocalRefreshOnGoneException>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionKeyInternal <EffectivePartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionKeyRange <ResolvedPartitionKeyRange>k__BackingField;
    [CompilerGeneratedAttribute]
private ISessionToken <SessionToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PerformedBackgroundAddressRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private IClientSideRequestStatistics <ClientRequestStatistics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedCollectionRid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegionName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LocalRegionRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPartitionFailoverRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ExcludeRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<HashSet`1<TransportAddressUri>> <FailedEndpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UsePreferredLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LocationIndexToRoute>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LocationEndpointToRoute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnsureCollectionExistsCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableConnectionStateListener>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializedSourceCollectionForMaterializedView>k__BackingField;
    public TimeoutHelper TimeoutHelper { get; public set; }
    public RequestChargeTracker RequestChargeTracker { get; public set; }
    public bool ForceRefreshAddressCache { get; public set; }
    public int LastPartitionAddressInformationHashCode { get; public set; }
    public ReferenceCountedDisposable`1<StoreResult> QuorumSelectedStoreResponse { get; }
    public Nullable`1<ConsistencyLevel> OriginalRequestConsistencyLevel { get; public set; }
    public long QuorumSelectedLSN { get; public set; }
    public long GlobalCommittedSelectedLSN { get; public set; }
    public ReferenceCountedDisposable`1<StoreResult> GlobalStrongWriteStoreResult { get; public set; }
    public ServiceIdentity TargetIdentity { get; public set; }
    public bool PerformLocalRefreshOnGoneException { get; public set; }
    public PartitionKeyInternal EffectivePartitionKey { get; public set; }
    public PartitionKeyRange ResolvedPartitionKeyRange { get; public set; }
    public ISessionToken SessionToken { get; public set; }
    public bool PerformedBackgroundAddressRefresh { get; public set; }
    public IClientSideRequestStatistics ClientRequestStatistics { get; public set; }
    public string ResolvedCollectionRid { get; public set; }
    public string RegionName { get; public set; }
    public bool LocalRegionRequest { get; public set; }
    public bool IsRetry { get; public set; }
    public bool IsPartitionFailoverRetry { get; public set; }
    public List`1<string> ExcludeRegions { get; public set; }
    public Lazy`1<HashSet`1<TransportAddressUri>> FailedEndpoints { get; private set; }
    public Nullable`1<bool> UsePreferredLocations { get; private set; }
    public Nullable`1<int> LocationIndexToRoute { get; private set; }
    public Uri LocationEndpointToRoute { get; private set; }
    public bool EnsureCollectionExistsCheck { get; public set; }
    public bool EnableConnectionStateListener { get; public set; }
    public string SerializedSourceCollectionForMaterializedView { get; public set; }
    [CompilerGeneratedAttribute]
public TimeoutHelper get_TimeoutHelper();
    [CompilerGeneratedAttribute]
public void set_TimeoutHelper(TimeoutHelper value);
    [CompilerGeneratedAttribute]
public RequestChargeTracker get_RequestChargeTracker();
    [CompilerGeneratedAttribute]
public void set_RequestChargeTracker(RequestChargeTracker value);
    [CompilerGeneratedAttribute]
public bool get_ForceRefreshAddressCache();
    [CompilerGeneratedAttribute]
public void set_ForceRefreshAddressCache(bool value);
    [CompilerGeneratedAttribute]
public int get_LastPartitionAddressInformationHashCode();
    [CompilerGeneratedAttribute]
public void set_LastPartitionAddressInformationHashCode(int value);
    public ReferenceCountedDisposable`1<StoreResult> get_QuorumSelectedStoreResponse();
    [CompilerGeneratedAttribute]
public Nullable`1<ConsistencyLevel> get_OriginalRequestConsistencyLevel();
    [CompilerGeneratedAttribute]
public void set_OriginalRequestConsistencyLevel(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public long get_QuorumSelectedLSN();
    [CompilerGeneratedAttribute]
public void set_QuorumSelectedLSN(long value);
    [CompilerGeneratedAttribute]
public long get_GlobalCommittedSelectedLSN();
    [CompilerGeneratedAttribute]
public void set_GlobalCommittedSelectedLSN(long value);
    [CompilerGeneratedAttribute]
public ReferenceCountedDisposable`1<StoreResult> get_GlobalStrongWriteStoreResult();
    [CompilerGeneratedAttribute]
public void set_GlobalStrongWriteStoreResult(ReferenceCountedDisposable`1<StoreResult> value);
    [CompilerGeneratedAttribute]
public ServiceIdentity get_TargetIdentity();
    [CompilerGeneratedAttribute]
public void set_TargetIdentity(ServiceIdentity value);
    [CompilerGeneratedAttribute]
public bool get_PerformLocalRefreshOnGoneException();
    [CompilerGeneratedAttribute]
public void set_PerformLocalRefreshOnGoneException(bool value);
    [CompilerGeneratedAttribute]
public PartitionKeyInternal get_EffectivePartitionKey();
    [CompilerGeneratedAttribute]
public void set_EffectivePartitionKey(PartitionKeyInternal value);
    [CompilerGeneratedAttribute]
public PartitionKeyRange get_ResolvedPartitionKeyRange();
    [CompilerGeneratedAttribute]
public void set_ResolvedPartitionKeyRange(PartitionKeyRange value);
    [CompilerGeneratedAttribute]
public ISessionToken get_SessionToken();
    [CompilerGeneratedAttribute]
public void set_SessionToken(ISessionToken value);
    [CompilerGeneratedAttribute]
public bool get_PerformedBackgroundAddressRefresh();
    [CompilerGeneratedAttribute]
public void set_PerformedBackgroundAddressRefresh(bool value);
    [CompilerGeneratedAttribute]
public IClientSideRequestStatistics get_ClientRequestStatistics();
    [CompilerGeneratedAttribute]
public void set_ClientRequestStatistics(IClientSideRequestStatistics value);
    [CompilerGeneratedAttribute]
public string get_ResolvedCollectionRid();
    [CompilerGeneratedAttribute]
public void set_ResolvedCollectionRid(string value);
    [CompilerGeneratedAttribute]
public string get_RegionName();
    [CompilerGeneratedAttribute]
public void set_RegionName(string value);
    [CompilerGeneratedAttribute]
public bool get_LocalRegionRequest();
    [CompilerGeneratedAttribute]
public void set_LocalRegionRequest(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public void set_IsRetry(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPartitionFailoverRetry();
    [CompilerGeneratedAttribute]
public void set_IsPartitionFailoverRetry(bool value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ExcludeRegions();
    [CompilerGeneratedAttribute]
public void set_ExcludeRegions(List`1<string> value);
    [CompilerGeneratedAttribute]
public Lazy`1<HashSet`1<TransportAddressUri>> get_FailedEndpoints();
    [CompilerGeneratedAttribute]
private void set_FailedEndpoints(Lazy`1<HashSet`1<TransportAddressUri>> value);
    public void UpdateQuorumSelectedStoreResponse(ReferenceCountedDisposable`1<StoreResult> storeResult);
    public void AddToFailedEndpoints(Exception storeException, TransportAddressUri targetUri);
    public void RouteToLocation(int locationIndex, bool usePreferredLocations);
    public void RouteToLocation(Uri locationEndpoint);
    public void ClearRouteToLocation();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UsePreferredLocations();
    [CompilerGeneratedAttribute]
private void set_UsePreferredLocations(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LocationIndexToRoute();
    [CompilerGeneratedAttribute]
private void set_LocationIndexToRoute(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Uri get_LocationEndpointToRoute();
    [CompilerGeneratedAttribute]
private void set_LocationEndpointToRoute(Uri value);
    [CompilerGeneratedAttribute]
public bool get_EnsureCollectionExistsCheck();
    [CompilerGeneratedAttribute]
public void set_EnsureCollectionExistsCheck(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableConnectionStateListener();
    [CompilerGeneratedAttribute]
public void set_EnableConnectionStateListener(bool value);
    [CompilerGeneratedAttribute]
public string get_SerializedSourceCollectionForMaterializedView();
    [CompilerGeneratedAttribute]
public void set_SerializedSourceCollectionForMaterializedView(string value);
    public DocumentServiceRequestContext Clone();
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.DocumentServiceRequestExtensions : object {
    [ExtensionAttribute]
public static bool IsValidStatusCodeForExceptionlessRetry(DocumentServiceRequest request, int statusCode, SubStatusCodes subStatusCode);
}
internal class Microsoft.Azure.Documents.DocumentServiceResponse : object {
    private JsonSerializerSettings serializerSettings;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private IClientSideRequestStatistics <RequestStats>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private INameValueCollection <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Stream, JsonReader> <JsonReaderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <ResponseBody>k__BackingField;
    [CompilerGeneratedAttribute]
private SubStatusCodes <SubStatusCode>k__BackingField;
    public IClientSideRequestStatistics RequestStats { get; private set; }
    public string ResourceId { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public string StatusDescription { get; public set; }
    internal INameValueCollection Headers { get; internal set; }
    internal static Func`2<Stream, JsonReader> JsonReaderFactory { get; internal set; }
    public NameValueCollection ResponseHeaders { get; }
    public Stream ResponseBody { get; public set; }
    public SubStatusCodes SubStatusCode { get; private set; }
    internal DocumentServiceResponse(Stream body, INameValueCollection headers, HttpStatusCode statusCode, JsonSerializerSettings serializerSettings);
    internal DocumentServiceResponse(Stream body, INameValueCollection headers, HttpStatusCode statusCode, IClientSideRequestStatistics clientSideRequestStatistics, JsonSerializerSettings serializerSettings);
    [CompilerGeneratedAttribute]
public IClientSideRequestStatistics get_RequestStats();
    [CompilerGeneratedAttribute]
private void set_RequestStats(IClientSideRequestStatistics value);
    [CompilerGeneratedAttribute]
public string get_ResourceId();
    [CompilerGeneratedAttribute]
public void set_ResourceId(string value);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public string get_StatusDescription();
    [CompilerGeneratedAttribute]
public void set_StatusDescription(string value);
    [CompilerGeneratedAttribute]
internal INameValueCollection get_Headers();
    [CompilerGeneratedAttribute]
internal void set_Headers(INameValueCollection value);
    [CompilerGeneratedAttribute]
internal static Func`2<Stream, JsonReader> get_JsonReaderFactory();
    [CompilerGeneratedAttribute]
internal static void set_JsonReaderFactory(Func`2<Stream, JsonReader> value);
    public NameValueCollection get_ResponseHeaders();
    [CompilerGeneratedAttribute]
public Stream get_ResponseBody();
    [CompilerGeneratedAttribute]
public void set_ResponseBody(Stream value);
    [CompilerGeneratedAttribute]
public SubStatusCodes get_SubStatusCode();
    [CompilerGeneratedAttribute]
private void set_SubStatusCode(SubStatusCodes value);
    public TResource GetResource(ITypeResolver`1<TResource> typeResolver);
    public TResource GetInternalResource(Func`1<TResource> constructor);
    public sealed virtual void Dispose();
    public IEnumerable`1<object> GetQueryResponse(Type resourceType, Int32& itemCount);
    public IEnumerable`1<T> GetQueryResponse(Type resourceType, bool lazy, Int32& itemCount);
    internal SubStatusCodes GetSubStatusCodes();
    [IteratorStateMachineAttribute("Microsoft.Azure.Documents.DocumentServiceResponse/<GetEnumerable>d__44`1")]
private IEnumerable`1<T> GetEnumerable(Type resourceType, Func`2<JsonReader, T> callback);
    private static JsonReader Create(Stream stream);
    private static ITypeResolver`1<TResource> GetTypeResolver();
    private string GetOwnerFullName();
}
internal class Microsoft.Azure.Documents.Embedding : JsonSerializable {
    [JsonPropertyAttribute]
public string Path { get; public set; }
    [JsonPropertyAttribute]
public VectorDataType DataType { get; public set; }
    [JsonPropertyAttribute]
public ulong Dimensions { get; public set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public DistanceFunction DistanceFunction { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public VectorDataType get_DataType();
    public void set_DataType(VectorDataType value);
    public ulong get_Dimensions();
    public void set_Dimensions(ulong value);
    public DistanceFunction get_DistanceFunction();
    public void set_DistanceFunction(DistanceFunction value);
}
internal class Microsoft.Azure.Documents.EncryptionScopeMetadata : JsonSerializable {
    private Collection`1<CMKMetadataInfo> cmkMetadataList;
    [JsonPropertyAttribute]
public string Id { get; public set; }
    [JsonPropertyAttribute]
public string Name { get; public set; }
    [JsonPropertyAttribute]
public DataEncryptionKeyStatus DataEncryptionKeyStatus { get; public set; }
    [JsonPropertyAttribute]
public Collection`1<CMKMetadataInfo> CMKMetadataList { get; public set; }
    public string get_Id();
    public void set_Id(string value);
    public string get_Name();
    public void set_Name(string value);
    public DataEncryptionKeyStatus get_DataEncryptionKeyStatus();
    public void set_DataEncryptionKeyStatus(DataEncryptionKeyStatus value);
    public Collection`1<CMKMetadataInfo> get_CMKMetadataList();
    public void set_CMKMetadataList(Collection`1<CMKMetadataInfo> value);
    public sealed virtual object Clone();
    internal virtual void OnSave();
}
internal enum Microsoft.Azure.Documents.EnumerationDirection : Enum {
    public int value__;
    public static EnumerationDirection Forward;
    public static EnumerationDirection Reverse;
}
internal class Microsoft.Azure.Documents.Error : Resource {
    [JsonPropertyAttribute]
public string Code { get; public set; }
    [JsonPropertyAttribute]
public string Message { get; public set; }
    [JsonPropertyAttribute]
internal string ErrorDetails { get; internal set; }
    [JsonPropertyAttribute]
internal string AdditionalErrorInfo { get; internal set; }
    public string get_Code();
    public void set_Code(string value);
    public string get_Message();
    public void set_Message(string value);
    internal string get_ErrorDetails();
    internal void set_ErrorDetails(string value);
    internal string get_AdditionalErrorInfo();
    internal void set_AdditionalErrorInfo(string value);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.ExceptionExtensions : object {
    [ExtensionAttribute]
public static string ToLoggingString(Exception exception);
    [ExtensionAttribute]
public static string ToStringWithData(Exception exception);
    [ExtensionAttribute]
public static string ToStringWithMessageAndData(Exception exception);
    public static DocumentClientException GetTranslatedStoredProcedureException(DocumentClientException dce);
    private static void CaptureExceptionData(Exception exception, List`1<string> exceptionData);
}
internal class Microsoft.Azure.Documents.ExcludedPath : JsonSerializable {
    [JsonPropertyAttribute]
public string Path { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    internal virtual void Validate();
    public sealed virtual object Clone();
}
internal enum Microsoft.Azure.Documents.FanoutOperationState : Enum {
    public int value__;
    public static FanoutOperationState Started;
    public static FanoutOperationState Completed;
}
internal interface Microsoft.Azure.Documents.FaultInjection.IChaosInterceptor {
    public abstract virtual Task`1<ValueTuple`2<bool, StoreResponse>> OnRequestCallAsync(ChannelCallArguments args);
    public abstract virtual Task OnChannelOpenAsync(Guid activityId, Guid connectionCorrelationId, Uri serverUri, DocumentServiceRequest openingRequest, Channel channel);
    public abstract virtual void OnChannelDispose(Guid connectionCorrelationId);
    public abstract virtual Task OnBeforeConnectionWriteAsync(ChannelCallArguments args);
    public abstract virtual Task OnAfterConnectionWriteAsync(ChannelCallArguments args);
    public abstract virtual string GetFaultInjectionRuleId(Guid activityId);
}
internal class Microsoft.Azure.Documents.FeedResource`1 : Resource {
    private static string collectionName;
    private static string CollectionName { get; }
    public int Count { get; }
    internal Collection`1<T> InnerCollection { get; internal set; }
    private static string get_CollectionName();
    public int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    internal Collection`1<T> get_InnerCollection();
    internal void set_InnerCollection(Collection`1<T> value);
    internal virtual void OnSave();
}
internal class Microsoft.Azure.Documents.ForbiddenException : DocumentClientException {
    [CompilerGeneratedAttribute]
private IPAddress <ClientIpAddress>k__BackingField;
    public IPAddress ClientIpAddress { get; private set; }
    public ForbiddenException(string message);
    public ForbiddenException(string message, HttpResponseHeaders headers, Uri requestUri);
    public ForbiddenException(Exception innerException);
    public ForbiddenException(string message, Exception innerException);
    public ForbiddenException(string message, SubStatusCodes subStatusCode);
    public ForbiddenException(string message, INameValueCollection headers, Uri requestUri);
    public ForbiddenException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri);
    public ForbiddenException(string message, Exception innerException, INameValueCollection headers);
    private ForbiddenException(SerializationInfo info, StreamingContext context);
    public static ForbiddenException CreateWithClientIpAddress(IPAddress clientIpAddress, bool isPrivateIpPacket);
    [CompilerGeneratedAttribute]
public IPAddress get_ClientIpAddress();
    [CompilerGeneratedAttribute]
private void set_ClientIpAddress(IPAddress value);
    private void SetDescription();
}
internal enum Microsoft.Azure.Documents.GeoLinkTypes : Enum {
    public int value__;
    public static GeoLinkTypes Strong;
    public static GeoLinkTypes Medium;
    public static GeoLinkTypes Weak;
}
internal class Microsoft.Azure.Documents.GeospatialConfig : JsonSerializable {
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public GeospatialType GeospatialType { get; public set; }
    public GeospatialConfig(GeospatialType geospatialType);
    public GeospatialType get_GeospatialType();
    public void set_GeospatialType(GeospatialType value);
    public sealed virtual object Clone();
    internal virtual void Validate();
}
internal enum Microsoft.Azure.Documents.GeospatialType : Enum {
    public int value__;
    public static GeospatialType Geography;
    public static GeospatialType Geometry;
}
internal class Microsoft.Azure.Documents.GoneAndRetryRequestRetryPolicyContext : object {
    [CompilerGeneratedAttribute]
private bool <ForceRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RemainingTimeInMsOnClientRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClientRetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RegionRerouteAttemptCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeoutForInBackoffRetryPolicy>k__BackingField;
    public bool ForceRefresh { get; public set; }
    public bool IsInRetry { get; public set; }
    public TimeSpan RemainingTimeInMsOnClientRequest { get; public set; }
    public int ClientRetryCount { get; public set; }
    public int RegionRerouteAttemptCount { get; public set; }
    public TimeSpan TimeoutForInBackoffRetryPolicy { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ForceRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceRefresh(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInRetry();
    [CompilerGeneratedAttribute]
public void set_IsInRetry(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RemainingTimeInMsOnClientRequest();
    [CompilerGeneratedAttribute]
public void set_RemainingTimeInMsOnClientRequest(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_ClientRetryCount();
    [CompilerGeneratedAttribute]
public void set_ClientRetryCount(int value);
    [CompilerGeneratedAttribute]
public int get_RegionRerouteAttemptCount();
    [CompilerGeneratedAttribute]
public void set_RegionRerouteAttemptCount(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeoutForInBackoffRetryPolicy();
    [CompilerGeneratedAttribute]
public void set_TimeoutForInBackoffRetryPolicy(TimeSpan value);
}
internal class Microsoft.Azure.Documents.GoneAndRetryWithRequestRetryPolicy`1 : object {
    private static ThreadLocal`1<Random> Random;
    private static int defaultWaitTimeInMilliSeconds;
    private static int minExecutionTimeInMilliSeconds;
    private static int initialBackoffMilliSeconds;
    private static int backoffMultiplier;
    private static int defaultMaximumBackoffTimeInMilliSeconds;
    private static int defaultInitialBackoffTimeForRetryWithInMilliseconds;
    private static int defaultMaximumBackoffTimeForRetryWithInMilliseconds;
    private static int defaultRandomSaltForRetryWithInMilliseconds;
    private static int minFailedReplicaCountToConsiderConnectivityIssue;
    private int maximumBackoffTimeInMilliSeconds;
    private int maximumBackoffTimeInMillisecondsForRetryWith;
    private int initialBackoffTimeInMilliSeconds;
    private int initialBackoffTimeInMillisecondsForRetryWith;
    private Nullable`1<int> randomSaltForRetryWithMilliseconds;
    private Stopwatch durationTimer;
    private TimeSpan minBackoffForRegionReroute;
    private int attemptCount;
    private int attemptCountInvalidPartition;
    private int regionRerouteAttemptCount;
    private Nullable`1<int> currentBackoffMilliseconds;
    private Nullable`1<int> currentBackoffMillisecondsForRetryWith;
    private RetryWithException lastRetryWithException;
    private Exception previousException;
    private int waitTimeInMilliseconds;
    private int waitTimeInMillisecondsForRetryWith;
    private bool detectConnectivityIssues;
    private bool disableRetryWithPolicy;
    [CompilerGeneratedAttribute]
private GoneAndRetryRequestRetryPolicyContext <ExecuteContext>k__BackingField;
    public GoneAndRetryRequestRetryPolicyContext ExecuteContext { get; }
    public GoneAndRetryWithRequestRetryPolicy`1(bool disableRetryWithPolicy, Nullable`1<int> waitTimeInSecondsOverride, TimeSpan minBackoffForRegionReroute, bool detectConnectivityIssues, RetryWithConfiguration retryWithConfiguration);
    private static GoneAndRetryWithRequestRetryPolicy`1();
    public sealed virtual void OnBeforeSendRequest(DocumentServiceRequest request);
    [CompilerGeneratedAttribute]
public sealed virtual GoneAndRetryRequestRetryPolicyContext get_ExecuteContext();
    public sealed virtual bool TryHandleResponseSynchronously(DocumentServiceRequest request, TResponse response, Exception exception, ShouldRetryResult& shouldRetryResult);
    public sealed virtual Task`1<ShouldRetryResult> ShouldRetryAsync(DocumentServiceRequest request, TResponse response, Exception exception, CancellationToken cancellationToken);
    private static bool IsBaseGone(TResponse response, Exception exception);
    private static bool IsPartitionIsMigrating(TResponse response, Exception exception);
    private static bool IsInvalidPartition(TResponse response, Exception exception);
    private static bool IsPartitionKeySplitting(TResponse response, Exception exception);
    private static bool IsPartitionKeyRangeGone(TResponse response, Exception exception);
    private static void ClearRequestContext(DocumentServiceRequest request);
}
internal class Microsoft.Azure.Documents.GoneAndRetryWithRetryPolicy : object {
    private static int defaultWaitTimeInSeconds;
    private static int minExecutionTimeInSeconds;
    private static int initialBackoffSeconds;
    private static int backoffMultiplier;
    private static int maximumBackoffTimeInSeconds;
    private static int minFailedReplicaCountToConsiderConnectivityIssue;
    private Stopwatch durationTimer;
    private int attemptCount;
    private int attemptCountInvalidPartition;
    private int regionRerouteAttemptCount;
    private TimeSpan minBackoffForRegionReroute;
    private RetryWithException lastRetryWithException;
    private int waitTimeInSeconds;
    private bool detectConnectivityIssues;
    private int currentBackoffSeconds;
    private DocumentServiceRequest request;
    private bool Microsoft.Azure.Documents.IRetryPolicy<System.Boolean>.InitialArgumentValue { get; }
    private Tuple`3<bool, bool, TimeSpan> Microsoft.Azure.Documents.IRetryPolicy<System.Tuple<System.Boolean,System.Boolean,System.TimeSpan>>.InitialArgumentValue { get; }
    private Tuple`6<bool, bool, TimeSpan, int, int, TimeSpan> Microsoft.Azure.Documents.IRetryPolicy<System.Tuple<System.Boolean,System.Boolean,System.TimeSpan,System.Int32,System.Int32,System.TimeSpan>>.InitialArgumentValue { get; }
    public GoneAndRetryWithRetryPolicy(DocumentServiceRequest request, Nullable`1<int> waitTimeInSecondsOverride, TimeSpan minBackoffForRegionReroute, bool detectConnectivityIssues);
    private sealed virtual override bool Microsoft.Azure.Documents.IRetryPolicy<System.Boolean>.get_InitialArgumentValue();
    private sealed virtual override Tuple`3<bool, bool, TimeSpan> Microsoft.Azure.Documents.IRetryPolicy<System.Tuple<System.Boolean,System.Boolean,System.TimeSpan>>.get_InitialArgumentValue();
    private sealed virtual override Tuple`6<bool, bool, TimeSpan, int, int, TimeSpan> Microsoft.Azure.Documents.IRetryPolicy<System.Tuple<System.Boolean,System.Boolean,System.TimeSpan,System.Int32,System.Int32,System.TimeSpan>>.get_InitialArgumentValue();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.GoneAndRetryWithRetryPolicy/<Microsoft-Azure-Documents-IRetryPolicy<System-Boolean>-ShouldRetryAsync>d__23")]
private sealed virtual override Task`1<ShouldRetryResult`1<bool>> Microsoft.Azure.Documents.IRetryPolicy<System.Boolean>.ShouldRetryAsync(Exception exception, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.GoneAndRetryWithRetryPolicy/<Microsoft-Azure-Documents-IRetryPolicy<System-Tuple<System-Boolean,System-Boolean,System-TimeSpan>>-ShouldRetryAsync>d__24")]
private sealed virtual override Task`1<ShouldRetryResult`1<Tuple`3<bool, bool, TimeSpan>>> Microsoft.Azure.Documents.IRetryPolicy<System.Tuple<System.Boolean,System.Boolean,System.TimeSpan>>.ShouldRetryAsync(Exception exception, CancellationToken cancellationToken);
    [SuppressMessageAttribute("Globalization", "CA1305:Specify IFormatProvider")]
private sealed virtual override Task`1<ShouldRetryResult`1<Tuple`6<bool, bool, TimeSpan, int, int, TimeSpan>>> Microsoft.Azure.Documents.IRetryPolicy<System.Tuple<System.Boolean,System.Boolean,System.TimeSpan,System.Int32,System.Int32,System.TimeSpan>>.ShouldRetryAsync(Exception exception, CancellationToken cancellationToken);
    private void ClearRequestContext();
}
internal class Microsoft.Azure.Documents.GoneException : DocumentClientException {
    [CompilerGeneratedAttribute]
private string <LocalIp>k__BackingField;
    internal string LocalIp { get; internal set; }
    public string Message { get; }
    public GoneException(string message);
    public GoneException(string message, SubStatusCodes subStatusCode, Uri requestUri);
    public GoneException(string message, HttpResponseHeaders headers, Nullable`1<SubStatusCodes> subStatusCode, Uri requestUri);
    public GoneException(string message, Exception innerException, SubStatusCodes subStatusCode, Uri requestUri, string localIpAddress);
    public GoneException(Exception innerException, SubStatusCodes subStatusCode);
    public GoneException(string message, INameValueCollection headers, Nullable`1<SubStatusCodes> substatusCode, Uri requestUri);
    public GoneException(string message, Exception innerException, HttpResponseHeaders headers, Nullable`1<SubStatusCodes> subStatusCode, Uri requestUri);
    private GoneException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal string get_LocalIp();
    [CompilerGeneratedAttribute]
internal void set_LocalIp(string value);
    public virtual string get_Message();
    private void SetDescription();
}
internal class Microsoft.Azure.Documents.GoneOnlyRequestRetryPolicy`1 : object {
    private static int backoffMultiplier;
    private static int initialBackoffTimeInSeconds;
    private Stopwatch durationTimer;
    private TimeSpan retryTimeout;
    private int currentBackoffTimeInSeconds;
    private bool isInRetry;
    [CompilerGeneratedAttribute]
private GoneOnlyRequestRetryPolicyContext <ExecuteContext>k__BackingField;
    public GoneOnlyRequestRetryPolicyContext ExecuteContext { get; }
    public GoneOnlyRequestRetryPolicy`1(TimeSpan retryTimeout);
    [CompilerGeneratedAttribute]
public sealed virtual GoneOnlyRequestRetryPolicyContext get_ExecuteContext();
    public sealed virtual void OnBeforeSendRequest(DocumentServiceRequest request);
    public sealed virtual bool TryHandleResponseSynchronously(DocumentServiceRequest request, TResponse response, Exception exception, ShouldRetryResult& shouldRetryResult);
    public sealed virtual Task`1<ShouldRetryResult> ShouldRetryAsync(DocumentServiceRequest request, TResponse response, Exception exception, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Documents.GoneOnlyRequestRetryPolicyContext : object {
    [CompilerGeneratedAttribute]
private bool <ForceRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RemainingTimeInMsOnClientRequest>k__BackingField;
    public bool ForceRefresh { get; public set; }
    public bool IsInRetry { get; public set; }
    public TimeSpan RemainingTimeInMsOnClientRequest { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ForceRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceRefresh(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInRetry();
    [CompilerGeneratedAttribute]
public void set_IsInRetry(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RemainingTimeInMsOnClientRequest();
    [CompilerGeneratedAttribute]
public void set_RemainingTimeInMsOnClientRequest(TimeSpan value);
}
internal class Microsoft.Azure.Documents.HashIndex : Index {
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public DataType DataType { get; public set; }
    [JsonPropertyAttribute]
public Nullable`1<short> Precision { get; public set; }
    public HashIndex(DataType dataType);
    public HashIndex(DataType dataType, short precision);
    public DataType get_DataType();
    public void set_DataType(DataType value);
    public Nullable`1<short> get_Precision();
    public void set_Precision(Nullable`1<short> value);
    internal virtual void Validate();
    public sealed virtual object Clone();
}
internal static class Microsoft.Azure.Documents.Helpers : object {
    internal static int ValidateNonNegativeInteger(string name, int value);
    internal static int ValidatePositiveInteger(string name, int value);
    internal static void ValidateEnumProperties(TEnum enumValue);
    public static byte GetHeaderValueByte(INameValueCollection headerValues, string headerName, byte defaultValue);
    public static string GetDateHeader(INameValueCollection headerValues);
    public static string GetDateHeader(RequestNameValueCollection requestHeaders);
    public static long GetHeaderValueLong(INameValueCollection headerValues, string headerName, long defaultValue);
    public static double GetHeaderValueDouble(INameValueCollection headerValues, string headerName, double defaultValue);
    internal static String[] ExtractValuesFromHTTPHeaders(HttpHeaders httpHeaders, String[] keys);
    internal static string GetAppSpecificUserAgentSuffix(string appName, string appVersion);
    internal static void SetupJsonReader(JsonReader reader, JsonSerializerSettings serializerSettings);
    internal static string GetScriptLogHeader(INameValueCollection headerValues);
    internal static long ToUnixTime(DateTimeOffset dt);
    internal static string GetStatusFromStatusCode(string statusCode);
    internal static string GetStatusFromStatusCodeInt(int statusCodeInt);
    internal static T GetEnvironmentVariable(string name, T defaultValue);
    internal static T GetSafeEnvironmentVariable(string name, T defaultValue);
}
internal static class Microsoft.Azure.Documents.HexStringUtility : object {
    internal static Byte[] HexStringToBytes(string hexString);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.HttpClientExtension : object {
    [ExtensionAttribute]
internal static void AddUserAgentHeader(HttpClient httpClient, UserAgentContainer userAgent);
    [ExtensionAttribute]
internal static void AddApiTypeHeader(HttpClient httpClient, ApiType apitype);
    [ExtensionAttribute]
internal static void AddSDKSupportedCapabilitiesHeader(HttpClient httpClient, ulong capabilities);
    [ExtensionAttribute]
internal static Task`1<HttpResponseMessage> SendHttpAsync(HttpClient httpClient, HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Task`1<HttpResponseMessage> SendHttpAsync(HttpClient httpClient, HttpRequestMessage requestMessage, HttpCompletionOption options, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Task`1<HttpResponseMessage> GetHttpAsync(HttpClient httpClient, Uri serviceEndpoint, CancellationToken cancellationToken);
}
internal static class Microsoft.Azure.Documents.HttpConstants : object {
    private static Dictionary`2<int, string> StatusCodeDescriptionMap;
    private static HttpConstants();
    public static string GetStatusCodeDescription(int statusCode);
}
internal class Microsoft.Azure.Documents.HttpTransportClient : TransportClient {
    private HttpClient httpClient;
    private ICommunicationEventSource eventSource;
    public static string Match;
    public HttpTransportClient(int requestTimeout, ICommunicationEventSource eventSource, UserAgentContainer userAgent, int idleTimeoutInSeconds, HttpMessageHandler messageHandler);
    public virtual void Dispose();
    private void BeforeRequest(Guid activityId, Uri uri, ResourceType resourceType, HttpRequestHeaders requestHeaders);
    private void AfterRequest(Guid activityId, HttpStatusCode statusCode, double durationInMilliSeconds, HttpResponseHeaders responseHeaders);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.HttpTransportClient/<InvokeStoreAsync>d__7")]
internal virtual Task`1<StoreResponse> InvokeStoreAsync(Uri physicalAddress, ResourceOperation resourceOperation, DocumentServiceRequest request);
    private static void AddHeader(HttpRequestHeaders requestHeaders, string headerName, DocumentServiceRequest request);
    private static void AddHeader(HttpContentHeaders requestHeaders, string headerName, DocumentServiceRequest request);
    private static void AddHeader(HttpRequestHeaders requestHeaders, string headerName, string headerValue);
    private string GetMatch(DocumentServiceRequest request, ResourceOperation resourceOperation);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000: DisposeObjectsBeforeLosingScope")]
private HttpRequestMessage PrepareHttpMessage(Guid activityId, Uri physicalAddress, ResourceOperation resourceOperation, DocumentServiceRequest request);
    internal static Uri GetSystemResourceUri(ResourceType resourceType, Uri physicalAddress, DocumentServiceRequest request);
    internal static Uri GetResourceFeedUri(ResourceType resourceType, Uri physicalAddress, DocumentServiceRequest request);
    internal static Uri GetResourceEntryUri(ResourceType resourceType, Uri physicalAddress, DocumentServiceRequest request);
    private static Uri GetRootFeedUri(Uri baseAddress);
    internal static Uri GetRootOperationUri(Uri baseAddress, OperationType operationType);
    private static Uri GetDatabaseFeedUri(Uri baseAddress);
    private static Uri GetDatabaseEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetCollectionFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetStoredProcedureFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetTriggerFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetUserDefinedFunctionFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetCollectionEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetStoredProcedureEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetTriggerEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetUserDefinedFunctionEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetDocumentFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetDocumentEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetConflictFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetConflictEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetAttachmentFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetAttachmentEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetUserFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetUserEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetClientEncryptionKeyFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetClientEncryptionKeyEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetUserDefinedTypeFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetUserDefinedTypeEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetPermissionFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetPermissionEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetOfferFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetOfferEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetSchemaFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetSchemaEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetSnapshotFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetSnapshotEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetRoleDefinitionFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetRoleDefinitionEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetRoleAssignmentFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetRoleAssignmentEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetEncryptionScopeFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetEncryptionScopeEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetAuthPolicyElementFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetAuthPolicyElementEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetInteropUserEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetSystemDocumentFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetSystemDocumentEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetPartitionedSystemDocumentFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetPartitionedKeyRangeFeedUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetPartitionedKeyRangeEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetPartitioKeyEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetPartitionedSystemDocumentEntryUri(Uri baseAddress, DocumentServiceRequest request);
    private static Uri GetPartitionKeyFeedUri(Uri baseAddress, DocumentServiceRequest request);
    public static Task`1<StoreResponse> ProcessHttpResponse(string resourceAddress, string activityId, HttpResponseMessage response, Uri physicalAddress, DocumentServiceRequest request);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.HttpTransportClient/<CreateErrorResponseFromHttpResponse>d__66")]
private static Task`1<StoreResponse> CreateErrorResponseFromHttpResponse(string resourceAddress, string activityId, HttpResponseMessage response, DocumentServiceRequest request);
    private static UInt32 GetSubsStatusFromHeader(HttpResponseMessage response);
    internal static string GetHeader(String[] names, String[] values, string name);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.HttpTransportClient/<CreateStoreResponseFromHttpResponse>d__69")]
public static Task`1<StoreResponse> CreateStoreResponseFromHttpResponse(HttpResponseMessage responseMessage, bool includeContent);
}
internal class Microsoft.Azure.Documents.HttpUtility : object {
    private static Char[] s_entityEndingChars;
    private static HttpUtility();
    internal static string AspCompatUrlEncode(string s);
    internal static string CollapsePercentUFromStringInternal(string s, Encoding e);
    internal static string FormatHttpCookieDateTime(DateTime dt);
    internal static string FormatHttpDateTime(DateTime dt);
    internal static string FormatHttpDateTimeUtc(DateTime dt);
    internal static string FormatPlainTextAsHtml(string s);
    internal static INameValueCollection ParseQueryString(string queryString);
    internal static void FormatPlainTextAsHtml(string s, TextWriter output);
    internal static string FormatPlainTextSpacesAsHtml(string s);
    private static int HexToInt(char h);
    internal static char IntToHex(int n);
    private static bool IsNonAsciiByte(byte b);
    internal static bool IsSafe(char ch);
    public static string UrlDecode(string str);
    public static string UrlDecode(Byte[] bytes, Encoding e);
    public static string UrlDecode(string str, Encoding e);
    public static string UrlDecode(Byte[] bytes, int offset, int count, Encoding e);
    private static Byte[] UrlDecodeBytesFromBytesInternal(Byte[] buf, int offset, int count);
    private static string UrlDecodeStringFromBytesInternal(Byte[] buf, int offset, int count, Encoding e);
    private static string UrlDecodeStringFromStringInternal(string s, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes);
    public static Byte[] UrlDecodeToBytes(string str);
    public static Byte[] UrlDecodeToBytes(string str, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes, int offset, int count);
    public static string UrlEncode(Byte[] bytes);
    public static string UrlEncode(string str);
    public static string UrlEncode(string str, Encoding e);
    public static string UrlEncode(Byte[] bytes, int offset, int count);
    private static Byte[] UrlEncodeBytesToBytesInternal(Byte[] bytes, int offset, int count, bool alwaysCreateReturnValue);
    private static Byte[] UrlEncodeBytesToBytesInternalNonAscii(Byte[] bytes, int offset, int count, bool alwaysCreateReturnValue);
    internal static string UrlEncodeNonAscii(string str, Encoding e);
    internal static string UrlEncodeSpaces(string str);
    public static Byte[] UrlEncodeToBytes(string str);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes);
    public static Byte[] UrlEncodeToBytes(string str, Encoding e);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    public static string UrlEncodeUnicode(string str);
    private static string UrlEncodeUnicodeStringToStringInternal(string s, bool ignoreAscii);
    public static Byte[] UrlEncodeUnicodeToBytes(string str);
    public static string UrlPathEncode(string str);
}
internal interface Microsoft.Azure.Documents.IAddressEnumerator {
    public abstract virtual IEnumerable`1<TransportAddressUri> GetTransportAddresses(IReadOnlyList`1<TransportAddressUri> transportAddressUris, Lazy`1<HashSet`1<TransportAddressUri>> failedEndpoints, bool replicaAddressValidationEnabled);
}
internal interface Microsoft.Azure.Documents.IAddressResolver {
    public abstract virtual Task`1<PartitionAddressInformation> ResolveAsync(DocumentServiceRequest request, bool forceRefreshPartitionAddresses, CancellationToken cancellationToken);
    public abstract virtual Task UpdateAsync(ServerKey serverKey, CancellationToken cancellationToken);
}
internal interface Microsoft.Azure.Documents.IAddressResolverExtension {
    public abstract virtual Task OpenConnectionsToAllReplicasAsync(string databaseName, string containerLinkUri, CancellationToken cancellationToken);
    public abstract virtual void SetOpenConnectionsHandler(IOpenConnectionsHandler openConnectionHandler);
}
internal interface Microsoft.Azure.Documents.IAuthorizationTokenProvider {
    public abstract virtual ValueTask`1<ValueTuple`2<string, string>> GetUserAuthorizationAsync(string resourceAddress, string resourceType, string requestVerb, INameValueCollection headers, AuthorizationTokenType tokenType);
    public abstract virtual Task AddSystemAuthorizationHeaderAsync(DocumentServiceRequest request, string federationId, string verb, string resourceId);
}
internal interface Microsoft.Azure.Documents.IClientSideRequestStatistics {
    public List`1<TransportAddressUri> ContactedReplicas { get; public set; }
    public HashSet`1<TransportAddressUri> FailedReplicas { get; }
    public HashSet`1<ValueTuple`2<string, Uri>> RegionsContacted { get; }
    public Nullable`1<bool> IsCpuHigh { get; }
    public Nullable`1<bool> IsCpuThreadStarvation { get; }
    public Nullable`1<TimeSpan> RequestLatency { get; }
    public abstract virtual List`1<TransportAddressUri> get_ContactedReplicas();
    public abstract virtual void set_ContactedReplicas(List`1<TransportAddressUri> value);
    public abstract virtual HashSet`1<TransportAddressUri> get_FailedReplicas();
    public abstract virtual HashSet`1<ValueTuple`2<string, Uri>> get_RegionsContacted();
    public abstract virtual Nullable`1<bool> get_IsCpuHigh();
    public abstract virtual Nullable`1<bool> get_IsCpuThreadStarvation();
    public abstract virtual void RecordRequest(DocumentServiceRequest request);
    public abstract virtual void RecordResponse(DocumentServiceRequest request, StoreResult storeResult, DateTime startTimeUtc, DateTime endTimeUtc);
    public abstract virtual void RecordException(DocumentServiceRequest request, Exception exception, DateTime startTimeUtc, DateTime endTimeUtc);
    public abstract virtual string RecordAddressResolutionStart(Uri targetEndpoint);
    public abstract virtual void RecordAddressResolutionEnd(string identifier);
    public abstract virtual Nullable`1<TimeSpan> get_RequestLatency();
    public abstract virtual void AppendToBuilder(StringBuilder stringBuilder);
    public abstract virtual void RecordHttpResponse(HttpRequestMessage request, HttpResponseMessage response, ResourceType resourceType, DateTime requestStartTimeUtc);
    public abstract virtual void RecordHttpException(HttpRequestMessage request, Exception exception, ResourceType resourceType, DateTime requestStartTimeUtc);
}
internal interface Microsoft.Azure.Documents.ICommunicationEventSource {
    public abstract virtual void Request(Guid activityId, Guid localId, string uri, string resourceType, HttpRequestHeaders requestHeaders);
    public abstract virtual void Response(Guid activityId, Guid localId, short statusCode, double milliseconds, HttpResponseHeaders responseHeaders);
}
internal interface Microsoft.Azure.Documents.IConnectionStateListener {
    public abstract virtual void OnConnectionEvent(ConnectionEvent connectionEvent, DateTime eventTime, ServerKey serverKey);
}
internal interface Microsoft.Azure.Documents.IMasterServiceIdentityProvider {
    public ServiceIdentity MasterServiceIdentity { get; }
    public abstract virtual ServiceIdentity get_MasterServiceIdentity();
    public abstract virtual Task RefreshAsync(ServiceIdentity previousMasterService, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Documents.InAccountRestoreParameters : JsonSerializable {
    [JsonPropertyAttribute]
public string InstanceId { get; public set; }
    [JsonConverterAttribute("Newtonsoft.Json.Converters.IsoDateTimeConverter")]
[JsonPropertyAttribute]
public DateTime RestoreTimestampInUtc { get; public set; }
    [JsonPropertyAttribute]
public string RestoreSource { get; public set; }
    [JsonPropertyAttribute]
public string SourceBackupLocation { get; public set; }
    [JsonPropertyAttribute]
public bool RestoreWithTtlDisabled { get; public set; }
    public string get_InstanceId();
    public void set_InstanceId(string value);
    public DateTime get_RestoreTimestampInUtc();
    public void set_RestoreTimestampInUtc(DateTime value);
    public string get_RestoreSource();
    public void set_RestoreSource(string value);
    public string get_SourceBackupLocation();
    public void set_SourceBackupLocation(string value);
    public bool get_RestoreWithTtlDisabled();
    public void set_RestoreWithTtlDisabled(bool value);
    internal virtual void Validate();
}
internal class Microsoft.Azure.Documents.IncludedPath : JsonSerializable {
    private Collection`1<Index> indexes;
    [JsonPropertyAttribute]
public string Path { get; public set; }
    [JsonPropertyAttribute]
public Collection`1<Index> Indexes { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public Collection`1<Index> get_Indexes();
    public void set_Indexes(Collection`1<Index> value);
    internal virtual void Validate();
    internal virtual void OnSave();
    public sealed virtual object Clone();
}
[JsonConverterAttribute("Microsoft.Azure.Documents.IndexJsonConverter")]
internal abstract class Microsoft.Azure.Documents.Index : JsonSerializable {
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public IndexKind Kind { get; private set; }
    protected Index(IndexKind kind);
    public IndexKind get_Kind();
    private void set_Kind(IndexKind value);
    public static RangeIndex Range(DataType dataType);
    public static RangeIndex Range(DataType dataType, short precision);
    public static HashIndex Hash(DataType dataType);
    public static HashIndex Hash(DataType dataType, short precision);
    public static SpatialIndex Spatial(DataType dataType);
    internal virtual void Validate();
}
internal enum Microsoft.Azure.Documents.IndexingDirective : Enum {
    public int value__;
    public static IndexingDirective Default;
    public static IndexingDirective Include;
    public static IndexingDirective Exclude;
}
internal static class Microsoft.Azure.Documents.IndexingDirectiveStrings : object {
    public static string Default;
    public static string Include;
    public static string Exclude;
    private static IndexingDirectiveStrings();
    public static string FromIndexingDirective(IndexingDirective directive);
}
internal enum Microsoft.Azure.Documents.IndexingMode : Enum {
    public int value__;
    public static IndexingMode Consistent;
    public static IndexingMode Lazy;
    public static IndexingMode None;
}
internal class Microsoft.Azure.Documents.IndexingPolicy : JsonSerializable {
    private static string DefaultPath;
    private Collection`1<IncludedPath> includedPaths;
    private Collection`1<ExcludedPath> excludedPaths;
    private Collection`1<Collection`1<CompositePath>> compositeIndexes;
    private Collection`1<SpatialSpec> spatialIndexes;
    private Collection`1<VectorIndexPath> vectorIndexPaths;
    [JsonPropertyAttribute]
public bool Automatic { get; public set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public IndexingMode IndexingMode { get; public set; }
    [JsonPropertyAttribute]
public Collection`1<IncludedPath> IncludedPaths { get; public set; }
    [JsonPropertyAttribute]
public Collection`1<ExcludedPath> ExcludedPaths { get; public set; }
    [JsonPropertyAttribute]
public Collection`1<Collection`1<CompositePath>> CompositeIndexes { get; public set; }
    [JsonPropertyAttribute]
public Collection`1<SpatialSpec> SpatialIndexes { get; public set; }
    [JsonPropertyAttribute]
internal Collection`1<VectorIndexPath> VectorIndexPaths { get; internal set; }
    public IndexingPolicy(Index[] defaultIndexOverrides);
    private static IndexingPolicy();
    public bool get_Automatic();
    public void set_Automatic(bool value);
    public IndexingMode get_IndexingMode();
    public void set_IndexingMode(IndexingMode value);
    public Collection`1<IncludedPath> get_IncludedPaths();
    public void set_IncludedPaths(Collection`1<IncludedPath> value);
    public Collection`1<ExcludedPath> get_ExcludedPaths();
    public void set_ExcludedPaths(Collection`1<ExcludedPath> value);
    public Collection`1<Collection`1<CompositePath>> get_CompositeIndexes();
    public void set_CompositeIndexes(Collection`1<Collection`1<CompositePath>> value);
    public Collection`1<SpatialSpec> get_SpatialIndexes();
    public void set_SpatialIndexes(Collection`1<SpatialSpec> value);
    internal Collection`1<VectorIndexPath> get_VectorIndexPaths();
    internal void set_VectorIndexPaths(Collection`1<VectorIndexPath> value);
    internal virtual void Validate();
    internal virtual void OnSave();
    public sealed virtual object Clone();
}
internal class Microsoft.Azure.Documents.IndexJsonConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanWrite();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal enum Microsoft.Azure.Documents.IndexKind : Enum {
    public int value__;
    public static IndexKind Hash;
    public static IndexKind Range;
    public static IndexKind Spatial;
}
internal class Microsoft.Azure.Documents.InternalSchemaProperties : JsonSerializable {
    [JsonPropertyAttribute]
internal bool UseSchemaForAnalyticsOnly { get; internal set; }
    internal bool get_UseSchemaForAnalyticsOnly();
    internal void set_UseSchemaForAnalyticsOnly(bool value);
    public sealed virtual object Clone();
}
internal class Microsoft.Azure.Documents.InternalServerErrorException : DocumentClientException {
    public InternalServerErrorException(SubStatusCodes subStatusCode);
    public InternalServerErrorException(string message, SubStatusCodes subStatusCode);
    public InternalServerErrorException(string message, Uri requestUri, bool rawErrorMessageOnly);
    public InternalServerErrorException(string message, HttpResponseHeaders headers, Uri requestUri);
    public InternalServerErrorException(Exception innerException);
    public InternalServerErrorException(string message, Exception innerException, Uri requestUri);
    public InternalServerErrorException(string message, INameValueCollection headers, Uri requestUri);
    public InternalServerErrorException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri, bool rawErrorMessageOnly);
    private InternalServerErrorException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
}
internal class Microsoft.Azure.Documents.InvalidPartitionException : DocumentClientException {
    public InvalidPartitionException(string message);
    public InvalidPartitionException(string message, HttpResponseHeaders headers, Uri requestUri);
    public InvalidPartitionException(string message, Exception innerException);
    public InvalidPartitionException(Exception innerException);
    public InvalidPartitionException(string message, INameValueCollection headers, Uri requestUri);
    public InvalidPartitionException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri);
    private InvalidPartitionException(SerializationInfo info, StreamingContext context);
    private void SetSubStatus();
    private void SetDescription();
}
internal interface Microsoft.Azure.Documents.IOpenConnectionsHandler {
    public abstract virtual Task TryOpenRntbdChannelsAsync(IEnumerable`1<TransportAddressUri> addresses);
}
internal interface Microsoft.Azure.Documents.IRequestRetryPolicy`2 {
    public abstract virtual Task`1<ShouldRetryResult> ShouldRetryAsync(TRequest request, TResponse response, Exception exception, CancellationToken cancellationToken);
    public abstract virtual bool TryHandleResponseSynchronously(TRequest request, TResponse response, Exception exception, ShouldRetryResult& shouldRetryResult);
    public abstract virtual void OnBeforeSendRequest(TRequest request);
}
internal interface Microsoft.Azure.Documents.IRequestRetryPolicy`3 {
    public TPolicyContext ExecuteContext { get; }
    public abstract virtual TPolicyContext get_ExecuteContext();
}
internal interface Microsoft.Azure.Documents.IRetriableResponse {
    public HttpStatusCode StatusCode { get; }
    public SubStatusCodes SubStatusCode { get; }
    public abstract virtual HttpStatusCode get_StatusCode();
    public abstract virtual SubStatusCodes get_SubStatusCode();
}
internal interface Microsoft.Azure.Documents.IRetryPolicy {
    public abstract virtual Task`1<ShouldRetryResult> ShouldRetryAsync(Exception exception, CancellationToken cancellationToken);
}
internal interface Microsoft.Azure.Documents.IRetryPolicy`1 {
    public TPolicyArg1 InitialArgumentValue { get; }
    public abstract virtual Task`1<ShouldRetryResult`1<TPolicyArg1>> ShouldRetryAsync(Exception exception, CancellationToken cancellationToken);
    public abstract virtual TPolicyArg1 get_InitialArgumentValue();
}
internal interface Microsoft.Azure.Documents.IServiceConfigurationReader {
    public string DatabaseAccountId { get; }
    public Uri DatabaseAccountApiEndpoint { get; }
    public ReplicationPolicy UserReplicationPolicy { get; }
    public ReplicationPolicy SystemReplicationPolicy { get; }
    public ConsistencyLevel DefaultConsistencyLevel { get; }
    public ReadPolicy ReadPolicy { get; }
    public string PrimaryMasterKey { get; }
    public string SecondaryMasterKey { get; }
    public string PrimaryReadonlyMasterKey { get; }
    public string SecondaryReadonlyMasterKey { get; }
    public string ResourceSeedKey { get; }
    public string SubscriptionId { get; }
    public abstract virtual string get_DatabaseAccountId();
    public abstract virtual Uri get_DatabaseAccountApiEndpoint();
    public abstract virtual ReplicationPolicy get_UserReplicationPolicy();
    public abstract virtual ReplicationPolicy get_SystemReplicationPolicy();
    public abstract virtual ConsistencyLevel get_DefaultConsistencyLevel();
    public abstract virtual ReadPolicy get_ReadPolicy();
    public abstract virtual string get_PrimaryMasterKey();
    public abstract virtual string get_SecondaryMasterKey();
    public abstract virtual string get_PrimaryReadonlyMasterKey();
    public abstract virtual string get_SecondaryReadonlyMasterKey();
    public abstract virtual string get_ResourceSeedKey();
    public abstract virtual string get_SubscriptionId();
    public abstract virtual Task InitializeAsync();
}
internal interface Microsoft.Azure.Documents.IServiceConfigurationReaderExtension {
    public abstract virtual IServiceRetryParams TryGetServiceRetryParams(DocumentServiceRequest documentServiceRequest);
}
internal interface Microsoft.Azure.Documents.IServiceIdentity {
    public abstract virtual string GetFederationId();
    public abstract virtual Uri GetServiceUri();
    public abstract virtual long GetPartitionKey();
}
internal interface Microsoft.Azure.Documents.IServiceRetryParams {
    public abstract virtual bool TryGetRetryTimeoutInSeconds(Int32& retryTimeoutInSeconds);
}
internal interface Microsoft.Azure.Documents.ISessionContainer {
    public abstract virtual string ResolveGlobalSessionToken(DocumentServiceRequest entity);
    public abstract virtual ISessionToken ResolvePartitionLocalSessionToken(DocumentServiceRequest entity, string partitionKeyRangeId);
    public abstract virtual void ClearTokenByCollectionFullname(string collectionFullname);
    public abstract virtual void ClearTokenByResourceId(string resourceId);
    public abstract virtual void SetSessionToken(DocumentServiceRequest request, INameValueCollection responseHeader);
    public abstract virtual void SetSessionToken(string collectionRid, string collectionFullname, INameValueCollection responseHeaders);
}
internal interface Microsoft.Azure.Documents.ISessionToken {
    public long LSN { get; }
    public abstract virtual bool IsValid(ISessionToken other);
    public abstract virtual ISessionToken Merge(ISessionToken other);
    public abstract virtual long get_LSN();
    public abstract virtual string ConvertToString();
}
internal interface Microsoft.Azure.Documents.IStoreClient {
    public abstract virtual Task`1<DocumentServiceResponse> ProcessMessageAsync(DocumentServiceRequest request, IRetryPolicy retryPolicy, CancellationToken cancellationToken);
    public abstract virtual Task OpenConnectionsToAllReplicasAsync(string databaseName, string containerLinkUri, CancellationToken cancellationToken);
}
internal interface Microsoft.Azure.Documents.IStoreClientFactory {
    public abstract virtual StoreClient CreateStoreClient(IAddressResolver addressResolver, ISessionContainer sessionContainer, IServiceConfigurationReader serviceConfigurationReader, IAuthorizationTokenProvider authorizationTokenProvider, bool enableRequestDiagnostics, bool enableReadRequestsFallback, bool useFallbackClient, bool useMultipleWriteLocations, bool detectClientConnectivityIssues, bool enableReplicaValidation);
}
internal interface Microsoft.Azure.Documents.IStoreModel {
    public abstract virtual Task`1<DocumentServiceResponse> ProcessMessageAsync(DocumentServiceRequest request, CancellationToken cancellationToken);
}
internal interface Microsoft.Azure.Documents.IStoreModelExtension {
    public abstract virtual Task OpenConnectionsToAllReplicasAsync(string databaseName, string containerLinkUri, CancellationToken cancellationToken);
}
internal interface Microsoft.Azure.Documents.ITypeResolver`1 {
    public abstract virtual T Resolve(JObject propertyBag);
}
internal abstract class Microsoft.Azure.Documents.JsonSerializable : object {
    internal JObject propertyBag;
    private static string POCOSerializationOnly;
    internal static bool JustPocoSerialization;
    [CompilerGeneratedAttribute]
private JsonSerializerSettings <SerializerSettings>k__BackingField;
    internal JsonSerializerSettings SerializerSettings { get; internal set; }
    private static JsonSerializable();
    [CompilerGeneratedAttribute]
internal JsonSerializerSettings get_SerializerSettings();
    [CompilerGeneratedAttribute]
internal void set_SerializerSettings(JsonSerializerSettings value);
    public void SaveTo(Stream stream, SerializationFormattingPolicy formattingPolicy);
    public void SaveTo(Stream stream, SerializationFormattingPolicy formattingPolicy, JsonSerializerSettings settings);
    internal void SaveTo(JsonWriter writer, JsonSerializer serializer, SerializationFormattingPolicy formattingPolicy);
    internal void SaveTo(StringBuilder stringBuilder, SerializationFormattingPolicy formattingPolicy);
    public virtual void LoadFrom(JsonReader reader);
    public virtual void LoadFrom(JsonReader reader, JsonSerializerSettings serializerSettings);
    public static T LoadFrom(Stream stream);
    internal static T LoadFrom(Stream stream, ITypeResolver`1<T> typeResolver, JsonSerializerSettings settings);
    internal static T LoadFromWithResolver(Stream stream, ITypeResolver`1<T> typeResolver, JsonSerializerSettings settings);
    internal static T LoadFromWithResolver(string serialized, ITypeResolver`1<T> typeResolver, JsonSerializerSettings settings);
    internal static T LoadFrom(string serialized, ITypeResolver`1<T> typeResolver, JsonSerializerSettings settings);
    public static T LoadFromWithConstructor(Stream stream, Func`1<T> constructorFunction);
    public static T LoadFromWithConstructor(Stream stream, Func`1<T> constructorFunction, JsonSerializerSettings settings);
    public virtual string ToString();
    internal virtual void Validate();
    internal T GetValue(string propertyName);
    internal T GetValue(string propertyName, T defaultValue);
    internal Nullable`1<TEnum> GetEnumValue(string propertyName);
    internal T GetValueByPath(String[] fieldNames, T defaultValue);
    internal void SetValue(string name, object value);
    internal void SetValueByPath(String[] fieldNames, T value);
    internal Collection`1<T> GetValueCollection(string propertyName);
    internal void SetValueCollection(string propertyName, Collection`1<T> value);
    internal TSerializable GetObject(string propertyName, bool returnEmptyObject);
    internal TSerializable GetObjectWithResolver(string propertyName, ITypeResolver`1<TSerializable> typeResolver, bool returnEmptyObject);
    internal void SetObject(string propertyName, TSerializable value);
    internal Collection`1<TSerializable> GetObjectCollection(string propertyName, Type resourceType, string ownerName, ITypeResolver`1<TSerializable> typeResolver);
    internal Collection`1<TSerializable> GetObjectCollectionWithResolver(string propertyName, ITypeResolver`1<TSerializable> typeResolver);
    internal void SetObjectCollection(string propertyName, Collection`1<TSerializable> value);
    internal Dictionary`2<string, TSerializable> GetObjectDictionary(string propertyName, ITypeResolver`1<TSerializable> typeResolver, IEqualityComparer`1<string> comparer);
    internal Dictionary`2<string, TSerializable> GetObjectDictionaryWithNullableValues(string propertyName);
    internal void SetObjectDictionary(string propertyName, Dictionary`2<string, TSerializable> value);
    internal void SetObjectDictionaryWithNullableValues(string propertyName, Dictionary`2<string, TSerializable> value);
    internal virtual void OnSave();
    internal static ITypeResolver`1<TResource> GetTypeResolver();
    private static T LoadFrom(JsonTextReader jsonReader, ITypeResolver`1<T> typeResolver, JsonSerializerSettings settings);
    private static T LoadFromWithResolver(ITypeResolver`1<T> typeResolver, JsonSerializerSettings settings, JsonTextReader jsonReader);
}
internal class Microsoft.Azure.Documents.JsonSerializableList`1 : List`1<T> {
    public JsonSerializableList`1(IEnumerable`1<T> list);
    public virtual string ToString();
    public static List`1<T> LoadFrom(string serialized);
}
internal class Microsoft.Azure.Documents.KeyWrapMetadata : JsonSerializable {
    [JsonPropertyAttribute]
internal string Name { get; internal set; }
    [JsonPropertyAttribute]
internal string Type { get; internal set; }
    [JsonPropertyAttribute]
internal string Value { get; internal set; }
    [JsonPropertyAttribute]
internal string Algorithm { get; internal set; }
    internal string get_Name();
    internal void set_Name(string value);
    internal string get_Type();
    internal void set_Type(string value);
    internal string get_Value();
    internal void set_Value(string value);
    internal string get_Algorithm();
    internal void set_Algorithm(string value);
}
internal static class Microsoft.Azure.Documents.LocationNames : object {
    public static string WestUS;
    public static string WestUS2;
    public static string WestCentralUS;
    public static string EastUS;
    public static string EastUS2;
    public static string CentralUS;
    public static string SouthCentralUS;
    public static string NorthCentralUS;
    public static string WestEurope;
    public static string NorthEurope;
    public static string EastAsia;
    public static string SoutheastAsia;
    public static string JapanEast;
    public static string JapanWest;
    public static string AustraliaEast;
    public static string AustraliaSoutheast;
    public static string CentralIndia;
    public static string SouthIndia;
    public static string WestIndia;
    public static string CanadaEast;
    public static string CanadaCentral;
    public static string GermanyCentral;
    public static string GermanyNortheast;
    public static string ChinaNorth;
    public static string ChinaEast;
    public static string ChinaNorth2;
    public static string ChinaEast2;
    public static string KoreaSouth;
    public static string KoreaCentral;
    public static string UKWest;
    public static string UKSouth;
    public static string BrazilSouth;
    public static string USGovArizona;
    public static string USGovTexas;
    public static string USGovVirginia;
    public static string EastUS2EUAP;
    public static string CentralUSEUAP;
    public static string FranceCentral;
    public static string FranceSouth;
    public static string USDoDCentral;
    public static string USDoDEast;
    public static string AustraliaCentral;
    public static string AustraliaCentral2;
    public static string SouthAfricaNorth;
    public static string SouthAfricaWest;
    public static string UAECentral;
    public static string UAENorth;
    public static string USNatEast;
    public static string USNatWest;
    public static string USSecEast;
    public static string USSecWest;
    public static string USSecWestCentral;
    public static string SwitzerlandNorth;
    public static string SwitzerlandWest;
    public static string GermanyNorth;
    public static string GermanyWestCentral;
    public static string NorwayEast;
    public static string NorwayWest;
    public static string BrazilSoutheast;
    public static string WestUS3;
    public static string JioIndiaCentral;
    public static string JioIndiaWest;
    public static string EastUSSLV;
    public static string SwedenCentral;
    public static string SwedenSouth;
    public static string QatarCentral;
    public static string ChinaNorth3;
    public static string ChinaEast3;
    public static string PolandCentral;
    public static string MalaysiaSouth;
    public static string ItalyNorth;
    public static string IsraelCentral;
    public static string MexicoCentral;
    public static string SpainCentral;
    public static string TaiwanNorth;
    public static string TaiwanNorthwest;
    internal static string AustriaEast;
    internal static string NewZealandNorth;
    internal static string BleuFranceCentral;
    internal static string BleuFranceSouth;
    internal static string EastUSSTG;
    internal static string SouthCentralUSSTG;
    internal static string IndonesiaCentral;
    internal static string SoutheastUS;
    internal static string MalaysiaWest;
}
internal class Microsoft.Azure.Documents.LockedException : DocumentClientException {
    public LockedException(string message, SubStatusCodes subStatusCode);
    public LockedException(string message, Uri requestUri);
    public LockedException(string message, Exception innerException, Uri requestUri);
    public LockedException(string message, HttpResponseHeaders headers, Uri requestUri);
    public LockedException(Exception innerException);
    public LockedException(string message, INameValueCollection headers, Uri requestUri);
    public LockedException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri);
    private LockedException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
}
internal class Microsoft.Azure.Documents.MaterializedViewDefinition : JsonSerializable {
    [JsonPropertyAttribute]
public string SourceCollectionRid { get; public set; }
    [JsonPropertyAttribute]
public string SourceCollectionId { get; public set; }
    [JsonPropertyAttribute]
public string Definition { get; public set; }
    [JsonPropertyAttribute]
public string ApiSpecificDefinition { get; public set; }
    [JsonPropertyAttribute]
public string ContainerType { get; public set; }
    public string get_SourceCollectionRid();
    public void set_SourceCollectionRid(string value);
    public string get_SourceCollectionId();
    public void set_SourceCollectionId(string value);
    public string get_Definition();
    public void set_Definition(string value);
    public string get_ApiSpecificDefinition();
    public void set_ApiSpecificDefinition(string value);
    public string get_ContainerType();
    public void set_ContainerType(string value);
    public sealed virtual object Clone();
}
internal class Microsoft.Azure.Documents.MaterializedViews : JsonSerializable {
    [JsonPropertyAttribute]
public string Id { get; public set; }
    [JsonPropertyAttribute]
public string Rid { get; public set; }
    public string get_Id();
    public void set_Id(string value);
    public string get_Rid();
    public void set_Rid(string value);
    public sealed virtual object Clone();
}
internal static class Microsoft.Azure.Documents.MathUtils : object {
    public static int CeilingMultiple(int x, int n);
}
internal class Microsoft.Azure.Documents.MediaIdHelper : object {
    public static string NewMediaId(string attachmentId, byte storageIndex);
    public static bool TryParseMediaId(string mediaId, String& attachmentId, Byte& storageIndex);
}
internal interface Microsoft.Azure.Documents.MemoryStreamPool {
    public abstract virtual bool TryGetMemoryStream(int capacity, MemoryStream& memoryStream);
}
internal class Microsoft.Azure.Documents.MethodNotAllowedException : DocumentClientException {
    public MethodNotAllowedException(string message);
    public MethodNotAllowedException(string message, HttpResponseHeaders headers, Uri requestUri);
    public MethodNotAllowedException(Exception innerException);
    public MethodNotAllowedException(string message, INameValueCollection headers, Uri requestUri);
    public MethodNotAllowedException(string message, Exception innerException);
    public MethodNotAllowedException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri);
    private MethodNotAllowedException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
}
internal enum Microsoft.Azure.Documents.MigrateCollectionDirective : Enum {
    public int value__;
    public static MigrateCollectionDirective Thaw;
    public static MigrateCollectionDirective Freeze;
}
internal static class Microsoft.Azure.Documents.NativeMethods : object {
}
internal static class Microsoft.Azure.Documents.NetUtil : object {
    private static Byte[] paasV1Prefix;
    private static Byte[] paasV2Prefix;
    private static NetUtil();
    public static string GetNonLoopbackIpV4Address();
    public static string GetLocalEmulatorIpV4Address();
    public static bool GetIPv6ServiceTunnelAddress(bool isEmulated, IPAddress& ipv6LoopbackAddress);
    private static bool IsServiceTunneledIPAddress(IPAddress ipAddress);
}
internal class Microsoft.Azure.Documents.NotFoundException : DocumentClientException {
    public NotFoundException(string message);
    public NotFoundException(string message, HttpResponseHeaders headers, Uri requestUri);
    public NotFoundException(string message, Exception innerException);
    public NotFoundException(Exception innerException, bool traceCallStack);
    public NotFoundException(Exception innerException, SubStatusCodes subStatusCode, bool traceCallStack);
    public NotFoundException(string message, INameValueCollection headers, Uri requestUri);
    public NotFoundException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri, Nullable`1<SubStatusCodes> subStatusCode, bool traceCallStack);
    public NotFoundException(string message, Exception innerException, INameValueCollection headers, Nullable`1<SubStatusCodes> subStatusCode);
    private NotFoundException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
}
internal class Microsoft.Azure.Documents.NullSessionContainer : object {
    public sealed virtual string ResolveGlobalSessionToken(DocumentServiceRequest entity);
    public sealed virtual ISessionToken ResolvePartitionLocalSessionToken(DocumentServiceRequest entity, string partitionKeyRangeId);
    public sealed virtual void ClearTokenByResourceId(string resourceId);
    public sealed virtual void ClearTokenByCollectionFullname(string collectionFullname);
    public sealed virtual void SetSessionToken(DocumentServiceRequest request, INameValueCollection header);
    public sealed virtual void SetSessionToken(string collectionRid, string collectionFullname, INameValueCollection responseHeaders);
}
internal class Microsoft.Azure.Documents.Offer : Resource {
    [JsonPropertyAttribute]
public string OfferVersion { get; internal set; }
    [JsonPropertyAttribute]
public string ResourceLink { get; internal set; }
    [JsonPropertyAttribute]
public string OfferType { get; public set; }
    [JsonPropertyAttribute]
internal string OfferResourceId { get; internal set; }
    public Offer(Offer offer);
    public string get_OfferVersion();
    internal void set_OfferVersion(string value);
    public string get_ResourceLink();
    internal void set_ResourceLink(string value);
    public string get_OfferType();
    public void set_OfferType(string value);
    internal string get_OfferResourceId();
    internal void set_OfferResourceId(string value);
    internal virtual void Validate();
    public bool Equals(Offer offer);
}
internal class Microsoft.Azure.Documents.OfferContentV2 : JsonSerializable {
    [JsonPropertyAttribute]
public int OfferThroughput { get; private set; }
    [JsonPropertyAttribute]
internal Nullable`1<double> BackgroundTaskMaxAllowedThroughputPercent { get; private set; }
    [JsonPropertyAttribute]
public Nullable`1<bool> OfferIsRUPerMinuteThroughputEnabled { get; private set; }
    public OfferContentV2(int offerThroughput);
    public OfferContentV2(int offerThroughput, Nullable`1<bool> offerEnableRUPerMinuteThroughput);
    internal OfferContentV2(OfferContentV2 content, int offerThroughput, Nullable`1<bool> offerEnableRUPerMinuteThroughput);
    internal OfferContentV2(OfferContentV2 content, int offerThroughput, Nullable`1<bool> offerEnableRUPerMinuteThroughput, Nullable`1<double> bgTaskMaxAllowedThroughputPercent);
    public int get_OfferThroughput();
    private void set_OfferThroughput(int value);
    internal Nullable`1<double> get_BackgroundTaskMaxAllowedThroughputPercent();
    private void set_BackgroundTaskMaxAllowedThroughputPercent(Nullable`1<double> value);
    public Nullable`1<bool> get_OfferIsRUPerMinuteThroughputEnabled();
    private void set_OfferIsRUPerMinuteThroughputEnabled(Nullable`1<bool> value);
    internal virtual void Validate();
}
internal class Microsoft.Azure.Documents.OfferTypeResolver : object {
    public static ITypeResolver`1<Offer> RequestOfferTypeResolver;
    public static ITypeResolver`1<Offer> ResponseOfferTypeResolver;
    private bool isResponse;
    private OfferTypeResolver(bool isResponse);
    private static OfferTypeResolver();
    private sealed virtual override Offer Microsoft.Azure.Documents.ITypeResolver<Microsoft.Azure.Documents.Offer>.Resolve(JObject propertyBag);
}
internal class Microsoft.Azure.Documents.OfferV2 : Offer {
    [JsonPropertyAttribute]
public OfferContentV2 Content { get; internal set; }
    public OfferV2(int offerThroughput);
    public OfferV2(int offerThroughput, Nullable`1<bool> offerEnableRUPerMinuteThroughput);
    public OfferV2(Offer offer, int offerThroughput);
    public OfferV2(Offer offer, int offerThroughput, Nullable`1<bool> offerEnableRUPerMinuteThroughput);
    internal OfferV2(Offer offer, int offerThroughput, Nullable`1<double> bgTaskMaxAllowedThroughputPercent);
    public OfferContentV2 get_Content();
    internal void set_Content(OfferContentV2 value);
    internal virtual void Validate();
    public bool Equals(OfferV2 offer);
}
internal enum Microsoft.Azure.Documents.OperationKind : Enum {
    public int value__;
    public static OperationKind Invalid;
    public static OperationKind Create;
    public static OperationKind Replace;
    public static OperationKind Delete;
    [ObsoleteAttribute("This item is obsolete as it does not apply to Conflict.")]
public static OperationKind Read;
}
internal enum Microsoft.Azure.Documents.OperationType : Enum {
    public int value__;
    public static OperationType Invalid;
    public static OperationType Create;
    public static OperationType Patch;
    public static OperationType Read;
    public static OperationType ReadFeed;
    public static OperationType Delete;
    public static OperationType Replace;
    public static OperationType Execute;
    public static OperationType BatchApply;
    public static OperationType SqlQuery;
    public static OperationType Query;
    public static OperationType Head;
    public static OperationType HeadFeed;
    public static OperationType Upsert;
    public static OperationType AddComputeGatewayRequestCharges;
    public static OperationType Batch;
    public static OperationType QueryPlan;
    public static OperationType CompleteUserTransaction;
    public static OperationType MetadataCheckAccess;
    public static OperationType CollectionTruncate;
    public static OperationType ExecuteJavaScript;
    public static OperationType GetConfiguration;
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.OperationTypeExtensions : object {
    private static Dictionary`2<int, string> OperationTypeNames;
    private static OperationTypeExtensions();
    [ExtensionAttribute]
public static string ToOperationTypeString(OperationType type);
    [ExtensionAttribute]
public static bool IsWriteOperation(OperationType type);
    [ExtensionAttribute]
public static bool IsPointOperation(OperationType type);
    [ExtensionAttribute]
public static bool IsReadOperation(OperationType type);
}
internal class Microsoft.Azure.Documents.PartitionAddressInformation : object {
    private static int AllProtocolsCount;
    private PerProtocolPartitionAddressInformation[] perProtocolAddressInformation;
    private Lazy`1<int> generateHashCode;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AddressInformation> <AllAddresses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLocalRegion>k__BackingField;
    public IReadOnlyList`1<AddressInformation> AllAddresses { get; }
    public bool IsLocalRegion { get; public set; }
    public PartitionAddressInformation(IReadOnlyList`1<AddressInformation> replicaAddresses);
    public PartitionAddressInformation(IReadOnlyList`1<AddressInformation> replicaAddresses, bool inNetworkRequest);
    private static PartitionAddressInformation();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AddressInformation> get_AllAddresses();
    [CompilerGeneratedAttribute]
public bool get_IsLocalRegion();
    [CompilerGeneratedAttribute]
public void set_IsLocalRegion(bool value);
    public Uri GetPrimaryUri(DocumentServiceRequest request, Protocol protocol);
    public PerProtocolPartitionAddressInformation Get(Protocol protocol);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(PartitionAddressInformation other);
    [CompilerGeneratedAttribute]
private int <.ctor>b__11_0();
}
internal class Microsoft.Azure.Documents.PartitionedSystemDocument : Resource {
}
internal class Microsoft.Azure.Documents.PartitionKey : object {
    public static string SystemKeyName;
    public static string SystemKeyPath;
    [CompilerGeneratedAttribute]
private PartitionKeyInternal <InternalKey>k__BackingField;
    public static PartitionKey None { get; }
    internal PartitionKeyInternal InternalKey { get; private set; }
    public PartitionKey(object keyValue);
    internal PartitionKey(Object[] keyValues);
    public static PartitionKey FromJsonString(string keyValue);
    public static PartitionKey get_None();
    internal static PartitionKey FromInternalKey(PartitionKeyInternal keyValue);
    [CompilerGeneratedAttribute]
internal PartitionKeyInternal get_InternalKey();
    [CompilerGeneratedAttribute]
private void set_InternalKey(PartitionKeyInternal value);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
internal class Microsoft.Azure.Documents.PartitionKeyDefinition : JsonSerializable {
    private Collection`1<string> paths;
    private Nullable`1<PartitionKind> kind;
    [JsonPropertyAttribute]
public Collection`1<string> Paths { get; public set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
internal PartitionKind Kind { get; internal set; }
    [JsonPropertyAttribute]
public Nullable`1<PartitionKeyDefinitionVersion> Version { get; public set; }
    [JsonPropertyAttribute]
internal Nullable`1<bool> IsSystemKey { get; internal set; }
    public Collection`1<string> get_Paths();
    public void set_Paths(Collection`1<string> value);
    internal PartitionKind get_Kind();
    internal void set_Kind(PartitionKind value);
    public Nullable`1<PartitionKeyDefinitionVersion> get_Version();
    public void set_Version(Nullable`1<PartitionKeyDefinitionVersion> value);
    internal Nullable`1<bool> get_IsSystemKey();
    internal void set_IsSystemKey(Nullable`1<bool> value);
    internal virtual void OnSave();
    internal virtual void Validate();
    internal static bool AreEquivalent(PartitionKeyDefinition pkd1, PartitionKeyDefinition pkd2);
}
internal enum Microsoft.Azure.Documents.PartitionKeyDefinitionVersion : Enum {
    public int value__;
    public static PartitionKeyDefinitionVersion V1;
    public static PartitionKeyDefinitionVersion V2;
}
internal class Microsoft.Azure.Documents.PartitionKeyRange : Resource {
    internal static string MasterPartitionKeyRangeId;
    [JsonPropertyAttribute]
internal string MinInclusive { get; internal set; }
    [JsonPropertyAttribute]
internal string MaxExclusive { get; internal set; }
    [JsonPropertyAttribute]
internal Nullable`1<int> RidPrefix { get; internal set; }
    [JsonPropertyAttribute]
internal double ThroughputFraction { get; internal set; }
    [JsonPropertyAttribute]
internal PartitionKeyRangeStatus Status { get; internal set; }
    [JsonPropertyAttribute]
public long LSN { get; public set; }
    [JsonPropertyAttribute]
public Collection`1<string> Parents { get; public set; }
    [JsonPropertyAttribute]
internal Collection`1<string> OwnedArchivalPKRangeIds { get; internal set; }
    internal string get_MinInclusive();
    internal void set_MinInclusive(string value);
    internal string get_MaxExclusive();
    internal void set_MaxExclusive(string value);
    internal Nullable`1<int> get_RidPrefix();
    internal void set_RidPrefix(Nullable`1<int> value);
    internal double get_ThroughputFraction();
    internal void set_ThroughputFraction(double value);
    internal PartitionKeyRangeStatus get_Status();
    internal void set_Status(PartitionKeyRangeStatus value);
    public long get_LSN();
    public void set_LSN(long value);
    public Collection`1<string> get_Parents();
    public void set_Parents(Collection`1<string> value);
    internal Collection`1<string> get_OwnedArchivalPKRangeIds();
    internal void set_OwnedArchivalPKRangeIds(Collection`1<string> value);
    internal Range`1<string> ToRange();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(PartitionKeyRange other);
}
internal class Microsoft.Azure.Documents.PartitionKeyRangeIdentity : object {
    [CompilerGeneratedAttribute]
private string <CollectionRid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKeyRangeId>k__BackingField;
    public string CollectionRid { get; private set; }
    public string PartitionKeyRangeId { get; private set; }
    public PartitionKeyRangeIdentity(string collectionRid, string partitionKeyRangeId);
    public PartitionKeyRangeIdentity(string partitionKeyRangeId);
    public static PartitionKeyRangeIdentity FromHeader(string header);
    public string ToHeader();
    [CompilerGeneratedAttribute]
public string get_CollectionRid();
    [CompilerGeneratedAttribute]
private void set_CollectionRid(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
private void set_PartitionKeyRangeId(string value);
    public sealed virtual bool Equals(PartitionKeyRangeIdentity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Azure.Documents.PartitionKeyRangeStatistics : object {
    [CompilerGeneratedAttribute]
private string <PartitionKeyRangeId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeInKB>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DocumentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <SampledDistinctPartitionKeyCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PartitionKeyStatistics> <PartitionKeyStatistics>k__BackingField;
    [JsonPropertyAttribute]
public string PartitionKeyRangeId { get; private set; }
    [JsonPropertyAttribute]
public long SizeInKB { get; private set; }
    [JsonPropertyAttribute]
public long DocumentCount { get; private set; }
    [JsonPropertyAttribute]
internal Nullable`1<long> SampledDistinctPartitionKeyCount { get; private set; }
    [JsonPropertyAttribute]
public IReadOnlyList`1<PartitionKeyStatistics> PartitionKeyStatistics { get; private set; }
    [CompilerGeneratedAttribute]
public string get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
private void set_PartitionKeyRangeId(string value);
    [CompilerGeneratedAttribute]
public long get_SizeInKB();
    [CompilerGeneratedAttribute]
private void set_SizeInKB(long value);
    [CompilerGeneratedAttribute]
public long get_DocumentCount();
    [CompilerGeneratedAttribute]
private void set_DocumentCount(long value);
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_SampledDistinctPartitionKeyCount();
    [CompilerGeneratedAttribute]
private void set_SampledDistinctPartitionKeyCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PartitionKeyStatistics> get_PartitionKeyStatistics();
    [CompilerGeneratedAttribute]
private void set_PartitionKeyStatistics(IReadOnlyList`1<PartitionKeyStatistics> value);
    public virtual string ToString();
}
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
internal enum Microsoft.Azure.Documents.PartitionKeyRangeStatus : Enum {
    public int value__;
    public static PartitionKeyRangeStatus Invalid;
    [EnumMemberAttribute]
public static PartitionKeyRangeStatus Online;
    [EnumMemberAttribute]
public static PartitionKeyRangeStatus Splitting;
    [EnumMemberAttribute]
public static PartitionKeyRangeStatus Offline;
    [EnumMemberAttribute]
public static PartitionKeyRangeStatus Split;
}
[JsonObjectAttribute]
internal class Microsoft.Azure.Documents.PartitionKeyStatistics : object {
    [CompilerGeneratedAttribute]
private long <SizeInKB>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionKeyInternal <PartitionKeyInternal>k__BackingField;
    public PartitionKey PartitionKey { get; }
    [JsonPropertyAttribute]
public long SizeInKB { get; private set; }
    [JsonPropertyAttribute]
internal PartitionKeyInternal PartitionKeyInternal { get; private set; }
    public PartitionKey get_PartitionKey();
    [CompilerGeneratedAttribute]
public long get_SizeInKB();
    [CompilerGeneratedAttribute]
private void set_SizeInKB(long value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal PartitionKeyInternal get_PartitionKeyInternal();
    [CompilerGeneratedAttribute]
private void set_PartitionKeyInternal(PartitionKeyInternal value);
}
internal enum Microsoft.Azure.Documents.PartitionKind : Enum {
    public int value__;
    public static PartitionKind Hash;
    public static PartitionKind Range;
    public static PartitionKind MultiHash;
}
internal static class Microsoft.Azure.Documents.Paths : object {
    public static string Root;
    public static string OperationsPathSegment;
    public static string OperationId;
    public static string ReplicaOperations_Pause;
    public static string ReplicaOperations_Resume;
    public static string ReplicaOperations_Stop;
    public static string ReplicaOperations_Recycle;
    public static string ReplicaOperations_Crash;
    public static string ReplicaOperations_ForceConfigRefresh;
    public static string ReplicaOperations_ReportThroughputUtilization;
    public static string ReplicaOperations_BatchReportThroughputUtilization;
    public static string Operations_GetFederationConfigurations;
    public static string Operations_GetConfiguration;
    public static string Operations_GetDatabaseAccountConfigurations;
    public static string Operations_GetGraphDatabaseAccountConfiguration;
    public static string Operations_GetStorageServiceConfigurations;
    public static string Operations_GetStorageAccountKey;
    public static string Operations_GetStorageAccountSas;
    public static string Operations_GetUnwrappedDek;
    public static string Operations_GetDekProperties;
    public static string Operations_GetCustomerManagedKeyStatus;
    public static string Operations_ReadReplicaFromMasterPartition;
    public static string Operations_ReadReplicaFromServerPartition;
    public static string Operations_MasterInitiatedProgressCoordination;
    public static string Operations_GetAadGroups;
    public static string Operations_XPDatabaseAccountMetaData;
    public static string Operations_MetadataCheckAccess;
    public static string SubscriptionsSegment;
    public static string SubscriptionsSegment_Root;
    public static string SubscriptionIdSegment;
    public static string SubscriptionIdSegment_Root;
    public static string ResourceGroupsSegment;
    public static string ResourceGroupsSegment_Root;
    public static string ResourceGroupSegment;
    public static string ResourceGroupSegment_Root;
    public static string ProvidersSegment;
    public static string ProvidersSegment_Root;
    public static string CosmosProvider;
    public static string CosmosProvider_Root;
    public static string DatabaseAccountResourceType;
    public static string DatabaseAccountType_Root;
    public static string DatabasesPathSegment;
    public static string Databases_Root;
    public static string DatabaseId;
    public static string Database_Root;
    public static string FederationEndpoint_Databases_Root;
    public static string FederationEndpoint_Database_Root;
    public static string UsersPathSegment;
    public static string Users_Root;
    public static string UserId;
    public static string User_Root;
    public static string ClientEncryptionKeysPathSegment;
    public static string ClientEncryptionKeys_Root;
    public static string ClientEncryptionKeyId;
    public static string ClientEncryptionKey_Root;
    public static string UserDefinedTypesPathSegment;
    public static string UserDefinedTypes_Root;
    public static string UserDefinedTypeId;
    public static string UserDefinedType_Root;
    public static string PermissionsPathSegment;
    public static string Permissions_Root;
    public static string PermissionId;
    public static string Permission_Root;
    public static string CollectionsPathSegment;
    public static string Collections_Root;
    public static string CollectionId;
    public static string Collection_Root;
    public static string FederationEndpoint_Collections_Root;
    public static string FederationEndpoint_Collection_Root;
    public static string StoredProceduresPathSegment;
    public static string StoredProcedures_Root;
    public static string StoredProcedureId;
    public static string StoredProcedure_Root;
    public static string FederationEndpoint_StoredProcedures_Root;
    public static string FederationEndpoint_StoredProcedure_Root;
    public static string TriggersPathSegment;
    public static string Triggers_Root;
    public static string TriggerId;
    public static string Trigger_Root;
    public static string UserDefinedFunctionsPathSegment;
    public static string UserDefinedFunctions_Root;
    public static string UserDefinedFunctionId;
    public static string UserDefinedFunction_Root;
    public static string ConflictsPathSegment;
    public static string Conflicts_Root;
    public static string ConflictId;
    public static string Conflict_Root;
    public static string PartitionedSystemDocumentsPathSegment;
    public static string PartitionedSystemDocuments_Root;
    public static string PartitionedSystemDocumentId;
    public static string PartitionedSystemDocument_Root;
    public static string SystemDocumentsPathSegment;
    public static string SystemDocuments_Root;
    public static string SystemDocumentId;
    public static string SystemDocument_Root;
    public static string DocumentsPathSegment;
    public static string Documents_Root;
    public static string DocumentId;
    public static string Document_Root;
    public static string AttachmentsPathSegment;
    public static string Attachments_Root;
    public static string AttachmentId;
    public static string Attachment_Root;
    public static string FederationEndpoint_Attachments_Root;
    public static string FederationEndpoint_Attachment_Root;
    public static string PartitionKeyRangesPathSegment;
    public static string PartitionKeyRanges_Root;
    public static string PartitionKeyRangeId;
    public static string PartitionKeyRange_Root;
    public static string FederationEndpoint_PartitionKeyRanges_Root;
    public static string PartitionKeyRangePreSplitSegment;
    public static string PartitionKeyRangePreSplit_Root;
    public static string PartitionKeyRangePostSplitSegment;
    public static string PartitionKeyRangePostSplit_Root;
    public static string ParatitionKeyRangeOperations_Split;
    public static string PartitionsPathSegment;
    public static string Partitions_Root;
    public static string DatabaseAccountSegment;
    public static string DatabaseAccount_Root;
    public static string StorageAuthTokenPathSegment;
    public static string StorageAuthToken_Root;
    public static string FilesPathSegment;
    public static string Files_Root;
    public static string FileId;
    public static string File_Root;
    public static string MediaPathSegment;
    public static string Medias_Root;
    public static string MediaId;
    public static string Media_Root;
    public static string AddressPathSegment;
    public static string Address_Root;
    public static string XPReplicatorAddressPathSegment;
    public static string XPReplicatorAddress_Root;
    public static string OffersPathSegment;
    public static string Offers_Root;
    public static string OfferId;
    public static string Offer_Root;
    public static string FederationEndpoint_Offers_Root;
    public static string FederationEndpoint_Offer_Root;
    public static string TopologyPathSegment;
    public static string Topology_Root;
    public static string SchemasPathSegment;
    public static string Schemas_Root;
    public static string SchemaId;
    public static string Schema_Root;
    public static string ServiceReservationPathSegment;
    public static string ServiceReservation_Root;
    public static string DataExplorerSegment;
    public static string DataExplorerAuthTokenSegment;
    public static string RidRangePathSegment;
    public static string RidRange_Root;
    public static string SnapshotsPathSegment;
    public static string Snapshots_Root;
    public static string SnapshotId;
    public static string Snapshot_Root;
    public static string DataExplorer_Root;
    public static string DataExplorerAuthToken_Root;
    public static string DataExplorerAuthToken_WithoutResourceId;
    public static string DataExplorerAuthToken_WithResourceId;
    internal static string ComputeGatewayChargePathSegment;
    public static string ControllerOperations_BatchGetOutput;
    public static string ControllerOperations_BatchReportCharges;
    public static string ControllerOperations_BatchAutoscaleRUsConsumption;
    public static string ControllerOperations_BatchGetAutoscaleAggregateOutput;
    public static string VectorClockPathSegment;
    public static string MetadataCheckAccessPathSegment;
    public static string PartitionKeyDeletePathSegment;
    public static string PartitionKeyDelete;
    public static string RoleAssignmentsPathSegment;
    public static string RoleAssignments_Root;
    public static string RoleAssignmentId;
    public static string RoleAssignment_Root;
    public static string RoleDefinitionsPathSegment;
    public static string RoleDefinitions_Root;
    public static string RoleDefinitionId;
    public static string RoleDefinition_Root;
    public static string CollectionTruncatePathsegment;
    public static string CollectionTruncate;
    public static string TransactionsPathSegment;
    public static string Transactions_Root;
    public static string TransactionId;
    public static string Transaction_Root;
    public static string AuthPolicyElementsPathSegment;
    public static string AuthPolicyElements_Root;
    public static string AuthPolicyElementId;
    public static string AuthPolicyElement_Root;
    public static string InteropUsersPathSegment;
    public static string InteropUsers_Root;
    public static string InteropUserId;
    public static string InteropUser_Root;
    public static string LocalEmulatorPathSegment;
    public static string LocalEmulator_Root;
    public static string LocalEmulatorManagedIdentityPathSegment;
    public static string LocalEmulatorManagedIdentity_Root;
    public static string RetriableWriteCachedResponsePathSegment;
    public static string RetriableWriteCachedResponse_Root;
    public static string AccountsPathSegment;
    public static string AccountId;
    public static string FederationEndpoint_Root;
    public static string FederationEndpoint_Address_Root;
    public static string EncryptionScopesPathSegment;
    public static string EncryptionScopes_Root;
    public static string ClientConfigPathSegment;
    public static string ClientConfig_Root;
    public static string FederationEndpoint_ClientConfig_Root;
    public static string EncryptionScopeId;
    public static string EncryptionScope_Root;
    public static string OperationResultsSegment;
    public static string OperationIdSegment;
    public static string DatabaseAccountResourceSegment;
    public static string DatabaseAccountResourceSegment_Root;
    public static string CassandraRoleDefinitionResourceType;
    public static string CassandraRoleDefinitionResourceType_Root;
    public static string CassandraRoleDefinitionResourceSegment;
    public static string CassandraRoleDefinitionResourceSegment_Root;
    public static string CassandraRoleDefinitionOperationResultsSegment_Root;
    public static string CassandraRoleDefinitionOperationResultSegment_Root;
    public static string MongoDbRoleDefinitionResourceType;
    public static string MongoDbRoleDefinitionResourceType_Root;
    public static string MongoDbRoleDefinitionResourceSegment;
    public static string MongoDbRoleDefinitionResourceSegment_Root;
    public static string MongoDbRoleDefinitionOperationResultsSegment_Root;
    public static string MongoDbRoleDefinitionOperationResultSegment_Root;
    public static string MongoDbUserDefinitionResourceType;
    public static string MongoDbUserDefinitionResourceType_Root;
    public static string MongoDbUserDefinitionResourceSegment;
    public static string MongoDbUserDefinitionResourceSegment_Root;
    public static string MongoDbUserDefinitionOperationResultsSegment_Root;
    public static string MongoDbUserDefinitionOperationResultSegment_Root;
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.PathsHelper : object {
    private static char ForwardSlash;
    private static StringSegment[] EmptyArray;
    private static Char[] PathSeparatorArray;
    private static bool isClientSideValidationEnabled;
    private static PathsHelper();
    public static bool TryParsePathSegments(string resourceUrl, Boolean& isFeed, String& resourcePath, String& resourceIdOrFullName, Boolean& isNameBased, string clientVersion);
    public static bool TryParsePathSegmentsWithDatabaseAndCollectionNames(string resourceUrl, Boolean& isFeed, String& resourcePath, String& resourceIdOrFullName, Boolean& isNameBased, String& databaseName, String& collectionName, string clientVersion, bool parseDatabaseAndCollectionNames);
    public static bool TryParsePathSegmentsWithDatabaseAndCollectionAndDocumentNames(string resourceUrl, Boolean& isFeed, String& resourcePath, String& resourceIdOrFullName, Boolean& isNameBased, String& databaseName, String& collectionName, String& documentName, string clientVersion, bool parseDatabaseAndCollectionNames);
    public static void ParseDatabaseNameAndCollectionNameFromUrlSegments(String[] segments, String& databaseName, String& collectionName);
    public static void ParseDatabaseNameAndCollectionAndDocumentNameFromUrlSegments(String[] segments, String& databaseName, String& collectionName, String& documentName);
    public static bool TryParsePathSegmentsWithDatabaseAndCollectionAndOperationNames(string resourceUrl, String& resourcePath, String& resourceIdOrFullName, Boolean& isNameBased, String& databaseName, String& collectionName, ResourceType& resourceType, OperationType& operationType);
    private static bool TryParseNameSegments(string resourceUrl, String[] segments, Boolean& isFeed, String& resourcePath, String& resourceFullName, String& databaseName, String& collectionName, String& documentName, bool parseDatabaseAndCollectionNames);
    public static ResourceType GetResourcePathSegment(string resourcePathSegment);
    public static string GetResourcePath(ResourceType resourceType);
    public static string GeneratePath(ResourceType resourceType, DocumentServiceRequest request, bool isFeed, bool notRequireValidation);
    public static string GenerateUserDefinedTypePath(string databaseName, string typeName);
    public static string GetCollectionPath(string resourceFullName);
    public static string GetDatabasePath(string resourceFullName);
    public static string GetParentByIndex(string resourceFullName, int segmentIndex);
    public static string GeneratePathForNameBased(Type resourceType, string resourceOwnerFullName, string resourceName);
    public static string GeneratePathForNamedBasedInternalResources(ResourceType resourceType, string resourceName);
    internal static void SetClientSidevalidation(bool validation);
    private static string GeneratePathForNameBased(ResourceType resourceType, string resourceFullName, bool isFeed, OperationType operationType, bool notRequireValidation);
    public static string GeneratePath(ResourceType resourceType, string ownerOrResourceId, bool isFeed, OperationType operationType);
    public static string GenerateRootOperationPath(OperationType operationType);
    private static bool IsResourceType(StringSegment& resourcePathSegment);
    private static bool IsRootOperation(StringSegment& operationSegment, StringSegment& operationTypeSegment);
    private static bool IsTopLevelOperationOperation(StringSegment& replicaSegment, StringSegment& addressSegment);
    public static string RemoveAccountsSegment(string resourceUrl);
    internal static bool IsNameBased(string resourceIdOrFullName);
    [ExtensionAttribute]
internal static int IndexOfNth(string str, char value, int n);
    internal static bool ValidateResourceFullName(ResourceType resourceType, string resourceFullName);
    internal static String[] GetResourcePathArray(ResourceType resourceType);
    internal static bool ValidateResourceId(ResourceType resourceType, string resourceId);
    internal static bool ValidateDatabaseId(string resourceIdString);
    internal static bool ValidateEncryptionScopeId(string resourceIdString);
    internal static bool ValidateDocumentCollectionId(string resourceIdString);
    internal static bool ValidateDocumentId(string resourceIdString);
    internal static bool ValidateConflictId(string resourceIdString);
    internal static bool ValidateAttachmentId(string resourceIdString);
    internal static bool ValidatePermissionId(string resourceIdString);
    internal static bool ValidateStoredProcedureId(string resourceIdString);
    internal static bool ValidateTriggerId(string resourceIdString);
    internal static bool ValidateUserDefinedFunctionId(string resourceIdString);
    internal static bool ValidateUserId(string resourceIdString);
    internal static bool ValidateClientEncryptionKeyId(string resourceIdString);
    internal static bool ValidateUserDefinedTypeId(string resourceIdString);
    internal static bool ValidateSchemaId(string resourceIdString);
    internal static bool ValidateSnapshotId(string resourceIdString);
    internal static bool ValidateRoleAssignmentId(string resourceIdString);
    internal static bool ValidateRoleDefinitionId(string resourceIdString);
    internal static bool ValidateAuthPolicyElementId(string resourceIdString);
    internal static bool ValidateSystemDocumentId(string resourceIdString);
    internal static bool ValidatePartitionedSystemDocumentId(string resourceIdString);
    internal static bool ValidateInteropUserId(string resourceIdString);
    internal static bool IsPublicResource(Type resourceType);
    internal static void ParseCollectionSelfLink(string collectionSelfLink, String& databaseId, String& collectionId);
}
internal class Microsoft.Azure.Documents.Permission : Resource {
    [JsonPropertyAttribute]
public string ResourceLink { get; public set; }
    [JsonPropertyAttribute]
public PartitionKey ResourcePartitionKey { get; public set; }
    [JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
[JsonPropertyAttribute]
public PermissionMode PermissionMode { get; public set; }
    [JsonPropertyAttribute]
public string Token { get; private set; }
    public string get_ResourceLink();
    public void set_ResourceLink(string value);
    public PartitionKey get_ResourcePartitionKey();
    public void set_ResourcePartitionKey(PartitionKey value);
    public PermissionMode get_PermissionMode();
    public void set_PermissionMode(PermissionMode value);
    public string get_Token();
    private void set_Token(string value);
}
[FlagsAttribute]
internal enum Microsoft.Azure.Documents.PermissionMode : Enum {
    public byte value__;
    public static PermissionMode Read;
    public static PermissionMode All;
}
internal class Microsoft.Azure.Documents.PerProtocolPartitionAddressInformation : object {
    [CompilerGeneratedAttribute]
private Protocol <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<TransportAddressUri> <NonPrimaryReplicaTransportAddressUris>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Uri> <ReplicaUris>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<TransportAddressUri> <ReplicaTransportAddressUris>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ReplicaTransportAddressUrisHealthState>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportAddressUri <PrimaryReplicaTransportAddressUri>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AddressInformation> <ReplicaAddresses>k__BackingField;
    public Protocol Protocol { get; }
    public IReadOnlyList`1<TransportAddressUri> NonPrimaryReplicaTransportAddressUris { get; }
    public IReadOnlyList`1<Uri> ReplicaUris { get; }
    public IReadOnlyList`1<TransportAddressUri> ReplicaTransportAddressUris { get; }
    public IReadOnlyList`1<string> ReplicaTransportAddressUrisHealthState { get; private set; }
    public Uri PrimaryReplicaUri { get; }
    public TransportAddressUri PrimaryReplicaTransportAddressUri { get; }
    public IReadOnlyList`1<AddressInformation> ReplicaAddresses { get; }
    public PerProtocolPartitionAddressInformation(Protocol protocol, IReadOnlyList`1<AddressInformation> replicaAddresses);
    public void SetTransportAddressUrisHealthState(IReadOnlyList`1<string> replicaHealthStates);
    public TransportAddressUri GetPrimaryAddressUri(DocumentServiceRequest request);
    [CompilerGeneratedAttribute]
public Protocol get_Protocol();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<TransportAddressUri> get_NonPrimaryReplicaTransportAddressUris();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Uri> get_ReplicaUris();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<TransportAddressUri> get_ReplicaTransportAddressUris();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ReplicaTransportAddressUrisHealthState();
    [CompilerGeneratedAttribute]
private void set_ReplicaTransportAddressUrisHealthState(IReadOnlyList`1<string> value);
    public Uri get_PrimaryReplicaUri();
    [CompilerGeneratedAttribute]
public TransportAddressUri get_PrimaryReplicaTransportAddressUri();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AddressInformation> get_ReplicaAddresses();
}
internal enum Microsoft.Azure.Documents.Platform : Enum {
    public int value__;
    public static Platform Unknown;
    public static Platform Windows;
    public static Platform Linux;
    public static Platform Darwin;
}
internal static class Microsoft.Azure.Documents.PlatformApis : object {
    private static Lazy`1<Platform> _platform;
    private static Lazy`1<DistroInfo> _distroInfo;
    private static PlatformApis();
    public static string GetOSName();
    public static string GetOSVersion();
    public static string GetWindowsVersion(string osDescipiton);
    private static string GetDarwinVersion();
    public static Platform GetOSPlatform();
    private static string GetDistroId();
    private static string GetDistroVersionId();
    private static DistroInfo LoadDistroInfo();
    private static Platform DetermineOSPlatform();
}
internal class Microsoft.Azure.Documents.PooledTimer : object {
    private long beginTicks;
    private TimeSpan timeoutPeriod;
    private TimerPool timerPool;
    private TaskCompletionSource`1<object> tcs;
    private object memberLock;
    private bool timerStarted;
    public long TimeoutTicks { get; }
    public TimeSpan Timeout { get; public set; }
    public TimeSpan MinSupportedTimeout { get; }
    public PooledTimer(int timeout, TimerPool timerPool);
    public PooledTimer(TimeSpan timeout, TimerPool timerPool);
    public long get_TimeoutTicks();
    public TimeSpan get_Timeout();
    public void set_Timeout(TimeSpan value);
    public TimeSpan get_MinSupportedTimeout();
    public Task StartTimerAsync();
    public bool CancelTimer();
    internal bool FireTimeout();
}
internal enum Microsoft.Azure.Documents.PortReuseMode : Enum {
    public int value__;
    public static PortReuseMode ReuseUnicastPort;
    public static PortReuseMode PrivatePortPool;
}
internal class Microsoft.Azure.Documents.PreconditionFailedException : DocumentClientException {
    public PreconditionFailedException(string message, Nullable`1<SubStatusCodes> substatusCode);
    public PreconditionFailedException(string message, HttpResponseHeaders headers, Uri requestUri);
    public PreconditionFailedException(Exception innerException);
    public PreconditionFailedException(string message, Exception innerException);
    public PreconditionFailedException(string message, INameValueCollection headers, Uri requestUri);
    public PreconditionFailedException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri, Nullable`1<SubStatusCodes> substatusCode);
    [JsonConstructorAttribute]
private PreconditionFailedException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
}
internal enum Microsoft.Azure.Documents.PriorityLevel : Enum {
    public int value__;
    public static PriorityLevel High;
    public static PriorityLevel Low;
}
internal enum Microsoft.Azure.Documents.QueryPlanGenerationMode : Enum {
    public int value__;
    public static QueryPlanGenerationMode DefaultWindowsX64NativeWithFallbackToGateway;
    public static QueryPlanGenerationMode WindowsX64NativeOnly;
    public static QueryPlanGenerationMode GatewayOnly;
}
internal class Microsoft.Azure.Documents.QueryRequestPerformanceActivity : object {
    public void ActivityComplete(bool markComplete);
}
internal class Microsoft.Azure.Documents.QueryResult : object {
    private JContainer jObject;
    private string ownerFullName;
    private JsonSerializer jsonSerializer;
    public JContainer Payload { get; }
    public string OwnerFullName { get; }
    public JsonSerializer JsonSerializer { get; }
    public QueryResult(JContainer jObject, string ownerFullName, JsonSerializer jsonSerializer);
    public QueryResult(JContainer jObject, string ownerFullName, JsonSerializerSettings serializerSettings);
    public JContainer get_Payload();
    public string get_OwnerFullName();
    public JsonSerializer get_JsonSerializer();
    public virtual string ToString();
    private IEnumerable`1<string> GetDynamicMemberNames();
    private object Convert(Type type);
    private object GetProperty(string propertyName, Type returnType);
    private object SetProperty(string propertyName, object value);
    private T AsType();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
internal class Microsoft.Azure.Documents.QuorumReader : object {
    private static int maxNumberOfReadBarrierReadRetries;
    private static int maxNumberOfPrimaryReadRetries;
    private static int maxNumberOfReadQuorumRetries;
    private static int delayBetweenReadBarrierCallsInMs;
    private static int maxBarrierRetriesForMultiRegion;
    private static int barrierRetryIntervalInMsForMultiRegion;
    private static int maxShortBarrierRetriesForMultiRegion;
    private static int shortbarrierRetryIntervalInMsForMultiRegion;
    private static TimeSpan[] defaultBarrierRequestDelays;
    private static TimeSpan totalAllowedBarrierRequestDelay;
    private StoreReader storeReader;
    private IServiceConfigurationReader serviceConfigReader;
    private IAuthorizationTokenProvider authorizationTokenProvider;
    public QuorumReader(TransportClient transportClient, AddressSelector addressSelector, StoreReader storeReader, IServiceConfigurationReader serviceConfigReader, IAuthorizationTokenProvider authorizationTokenProvider);
    private static QuorumReader();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.QuorumReader/<ReadStrongAsync>d__14")]
public Task`1<StoreResponse> ReadStrongAsync(DocumentServiceRequest entity, int readQuorumValue, ReadMode readMode);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.QuorumReader/<ReadBoundedStalenessAsync>d__15")]
public Task`1<StoreResponse> ReadBoundedStalenessAsync(DocumentServiceRequest entity, int readQuorumValue);
    internal static TimeSpan[] GetDefaultBarrierRequestDelays();
    internal static TimeSpan GetTotalAllowedBarrierRequestDelay();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.QuorumReader/<ReadQuorumAsync>d__18")]
private Task`1<ReadQuorumResult> ReadQuorumAsync(DocumentServiceRequest entity, int readQuorum, bool includePrimary, ReadMode readMode);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.QuorumReader/<ReadPrimaryAsync>d__19")]
private Task`1<ReadPrimaryResult> ReadPrimaryAsync(DocumentServiceRequest entity, int readQuorum, bool useSessionToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.QuorumReader/<WaitForPrimaryLsnAsync>d__20")]
private Task`1<PrimaryReadOutcome> WaitForPrimaryLsnAsync(DocumentServiceRequest barrierRequest, long lsnToWaitFor, int readQuorum);
    private Task`1<bool> WaitForReadBarrierAsync(DocumentServiceRequest barrierRequest, bool allowPrimary, int readQuorum, long readBarrierLsn, long targetGlobalCommittedLSN, ReadMode readMode);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.QuorumReader/<WaitForReadBarrierOldAsync>d__22")]
private Task`1<bool> WaitForReadBarrierOldAsync(DocumentServiceRequest barrierRequest, bool allowPrimary, int readQuorum, long readBarrierLsn, long targetGlobalCommittedLSN, ReadMode readMode);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.QuorumReader/<WaitForReadBarrierNewAsync>d__23")]
private Task`1<bool> WaitForReadBarrierNewAsync(DocumentServiceRequest barrierRequest, bool allowPrimary, int readQuorum, long readBarrierLsn, long targetGlobalCommittedLSN, ReadMode readMode);
    private bool IsQuorumMet(IList`1<ReferenceCountedDisposable`1<StoreResult>> readResponses, int readQuorum, bool isPrimaryIncluded, bool isGlobalStrongRead, Int64& readLsn, Int64& globalCommittedLSN, ReferenceCountedDisposable`1& selectedResponse);
}
internal class Microsoft.Azure.Documents.RangeIndex : Index {
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public DataType DataType { get; public set; }
    [JsonPropertyAttribute]
public Nullable`1<short> Precision { get; public set; }
    public RangeIndex(DataType dataType);
    public RangeIndex(DataType dataType, short precision);
    public DataType get_DataType();
    public void set_DataType(DataType value);
    public Nullable`1<short> get_Precision();
    public void set_Precision(Nullable`1<short> value);
    internal virtual void Validate();
    public sealed virtual object Clone();
}
internal enum Microsoft.Azure.Documents.ReadFeedKeyType : Enum {
    public int value__;
    public static ReadFeedKeyType ResourceId;
    public static ReadFeedKeyType EffectivePartitionKey;
    public static ReadFeedKeyType EffectivePartitionKeyRange;
}
internal enum Microsoft.Azure.Documents.ReadMode : Enum {
    public int value__;
    public static ReadMode Primary;
    public static ReadMode Strong;
    public static ReadMode BoundedStaleness;
    public static ReadMode Any;
}
internal class Microsoft.Azure.Documents.ReadPolicy : JsonSerializable {
    private static int DefaultPrimaryReadCoefficient;
    private static int DefaultSecondaryReadCoefficient;
    [JsonPropertyAttribute]
public int PrimaryReadCoefficient { get; public set; }
    [JsonPropertyAttribute]
public int SecondaryReadCoefficient { get; public set; }
    public int get_PrimaryReadCoefficient();
    public void set_PrimaryReadCoefficient(int value);
    public int get_SecondaryReadCoefficient();
    public void set_SecondaryReadCoefficient(int value);
}
internal class Microsoft.Azure.Documents.ReceivedResponseEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private DocumentServiceResponse <DocumentServiceResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponseMessage <HttpResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpRequestMessage <HttpRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentServiceRequest <DocumentServiceRequest>k__BackingField;
    public DocumentServiceResponse DocumentServiceResponse { get; }
    public HttpResponseMessage HttpResponse { get; }
    public HttpRequestMessage HttpRequest { get; }
    public DocumentServiceRequest DocumentServiceRequest { get; }
    public ReceivedResponseEventArgs(DocumentServiceRequest request, DocumentServiceResponse response);
    public ReceivedResponseEventArgs(HttpRequestMessage request, HttpResponseMessage response);
    [CompilerGeneratedAttribute]
public DocumentServiceResponse get_DocumentServiceResponse();
    [CompilerGeneratedAttribute]
public HttpResponseMessage get_HttpResponse();
    [CompilerGeneratedAttribute]
public HttpRequestMessage get_HttpRequest();
    [CompilerGeneratedAttribute]
public DocumentServiceRequest get_DocumentServiceRequest();
    public bool IsHttpResponse();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Azure.Documents.ReferenceCountedDisposable`1 : object {
    [NullableAttribute("2")]
private T _instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BoxedReferenceCount<T> _boxedReferenceCount;
    public T Target { get; }
    public ReferenceCountedDisposable`1(T instance);
    private ReferenceCountedDisposable`1(T instance, BoxedReferenceCount<T> referenceCount);
    public T get_Target();
    public ReferenceCountedDisposable`1<T> TryAddReference();
    public sealed virtual void Dispose();
}
internal static class Microsoft.Azure.Documents.RegionProximityUtil : object {
    internal static Dictionary`2<string, Dictionary`2<string, long>> SourceRegionToTargetRegionsRTTInMs;
    private static RegionProximityUtil();
    public static List`1<string> GetRegionsForLinkType(GeoLinkTypes geoLinkType, List`1<string> existingRegions);
    public static List`1<string> GetRegionsForLinkType(GeoLinkTypes geoLinkType, string sourceRegion);
    public static List`1<string> GeneratePreferredRegionList(string sourceRegion);
    private static long GetLinkTypeThresholdInMs(GeoLinkTypes geoLinkType);
}
internal enum Microsoft.Azure.Documents.RemoteStorageType : Enum {
    public int value__;
    public static RemoteStorageType NotSpecified;
    public static RemoteStorageType Standard;
    public static RemoteStorageType Premium;
}
internal class Microsoft.Azure.Documents.ReplicatedResourceClient : object {
    private static string EnableGlobalStrongConfigurationName;
    private static int GoneAndRetryWithRetryTimeoutInSeconds;
    private static int StrongGoneAndRetryWithRetryTimeoutInSeconds;
    private TimeSpan minBackoffForFallingBackToOtherRegions;
    private AddressSelector addressSelector;
    private IAddressResolver addressResolver;
    private ConsistencyReader consistencyReader;
    private ConsistencyWriter consistencyWriter;
    private Protocol protocol;
    private TransportClient transportClient;
    private IServiceConfigurationReader serviceConfigReader;
    private IServiceConfigurationReaderExtension serviceConfigurationReaderExtension;
    private bool enableReadRequestsFallback;
    private bool useMultipleWriteLocations;
    private bool detectClientConnectivityIssues;
    private RetryWithConfiguration retryWithConfiguration;
    private bool disableRetryWithRetryPolicy;
    private static Lazy`1<bool> enableGlobalStrong;
    [CompilerGeneratedAttribute]
private bool <ForceAddressRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <GoneAndRetryWithRetryTimeoutInSecondsOverride>k__BackingField;
    public string LastReadAddress { get; public set; }
    public string LastWriteAddress { get; }
    public bool ForceAddressRefresh { get; public set; }
    public Nullable`1<int> GoneAndRetryWithRetryTimeoutInSecondsOverride { get; public set; }
    public ReplicatedResourceClient(IAddressResolver addressResolver, ISessionContainer sessionContainer, Protocol protocol, TransportClient transportClient, IServiceConfigurationReader serviceConfigReader, IAuthorizationTokenProvider authorizationTokenProvider, bool enableReadRequestsFallback, bool useMultipleWriteLocations, bool detectClientConnectivityIssues, bool disableRetryWithRetryPolicy, bool enableReplicaValidation, RetryWithConfiguration retryWithConfiguration);
    private static ReplicatedResourceClient();
    public string get_LastReadAddress();
    public void set_LastReadAddress(string value);
    public string get_LastWriteAddress();
    [CompilerGeneratedAttribute]
public bool get_ForceAddressRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceAddressRefresh(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_GoneAndRetryWithRetryTimeoutInSecondsOverride();
    [CompilerGeneratedAttribute]
public void set_GoneAndRetryWithRetryTimeoutInSecondsOverride(Nullable`1<int> value);
    public Task`1<StoreResponse> InvokeAsync(DocumentServiceRequest request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ReplicatedResourceClient/<OpenConnectionsToAllReplicasAsync>d__33")]
public Task OpenConnectionsToAllReplicasAsync(string databaseName, string containerLinkUri, CancellationToken cancellationToken);
    private Task`1<StoreResponse> InvokeAsync(DocumentServiceRequest request, TimeoutHelper timeout, bool isInRetry, bool forceRefresh, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ReplicatedResourceClient/<HandleGetStorageAuthTokenAsync>d__35")]
private Task`1<StoreResponse> HandleGetStorageAuthTokenAsync(DocumentServiceRequest request, bool forceRefresh);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ReplicatedResourceClient/<HandleThrottlePreCreateOrOfferPreGrowAsync>d__36")]
private Task`1<StoreResponse> HandleThrottlePreCreateOrOfferPreGrowAsync(DocumentServiceRequest request, bool forceRefresh);
    private bool CheckWriteRetryable(DocumentServiceRequest request);
    internal static bool IsGlobalStrongEnabled();
    internal static bool IsReadingFromMaster(ResourceType resourceType, OperationType operationType);
    internal static bool IsSessionTokenRequired(ResourceType resourceType, OperationType operationType);
    internal static bool IsStoredProcedureCrudOperation(ResourceType resourceType, OperationType operationType);
    internal static bool IsMasterResource(ResourceType resourceType);
}
internal class Microsoft.Azure.Documents.ReplicationPolicy : JsonSerializable {
    private static int DefaultMaxReplicaSetSize;
    private static int DefaultMinReplicaSetSize;
    private static bool DefaultAsyncReplication;
    public int MaxReplicaSetSize { get; public set; }
    public int MinReplicaSetSize { get; public set; }
    public bool AsyncReplication { get; public set; }
    public int get_MaxReplicaSetSize();
    public void set_MaxReplicaSetSize(int value);
    public int get_MinReplicaSetSize();
    public void set_MinReplicaSetSize(int value);
    public bool get_AsyncReplication();
    public void set_AsyncReplication(bool value);
    internal virtual void Validate();
}
internal class Microsoft.Azure.Documents.RequestChargeTracker : object {
    private long totalRUsNotServedToClient;
    private long totalRUs;
    private static int numberOfDecimalPointToReserveFactor;
    public double TotalRequestCharge { get; }
    public double get_TotalRequestCharge();
    public void AddCharge(double ruUsage);
    public double GetAndResetCharge();
}
internal enum Microsoft.Azure.Documents.RequestedCollectionType : Enum {
    public int value__;
    public static RequestedCollectionType All;
    public static RequestedCollectionType Standard;
    public static RequestedCollectionType MaterializedView;
}
internal class Microsoft.Azure.Documents.RequestEntityTooLargeException : DocumentClientException {
    public RequestEntityTooLargeException(string message);
    public RequestEntityTooLargeException(string message, HttpResponseHeaders httpHeaders, Uri requestUri);
    public RequestEntityTooLargeException(Exception innerException);
    public RequestEntityTooLargeException(string message, INameValueCollection headers, Uri requestUri);
    public RequestEntityTooLargeException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri);
    private RequestEntityTooLargeException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
}
internal static class Microsoft.Azure.Documents.RequestHelper : object {
    public static ConsistencyLevel GetConsistencyLevelToUse(IServiceConfigurationReader serviceConfigReader, DocumentServiceRequest request);
}
internal class Microsoft.Azure.Documents.RequestRateTooLargeException : DocumentClientException {
    public RequestRateTooLargeException(string message);
    public RequestRateTooLargeException(string message, HttpResponseHeaders headers, Uri requestUri);
    public RequestRateTooLargeException(string message, SubStatusCodes subStatus);
    public RequestRateTooLargeException(Exception innerException);
    public RequestRateTooLargeException(string message, INameValueCollection headers, Uri requestUri);
    public RequestRateTooLargeException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri);
    private RequestRateTooLargeException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
}
internal static class Microsoft.Azure.Documents.RequestRetryUtility : object {
    public static Task`1<IRetriableResponse> ProcessRequestAsync(Func`2<TInitialArguments, Task`1<IRetriableResponse>> executeAsync, Func`1<TRequest> prepareRequest, IRequestRetryPolicy`3<TInitialArguments, TRequest, IRetriableResponse> policy, CancellationToken cancellationToken);
    public static Task`1<IRetriableResponse> ProcessRequestAsync(Func`2<TInitialArguments, Task`1<IRetriableResponse>> executeAsync, Func`1<TRequest> prepareRequest, IRequestRetryPolicy`3<TInitialArguments, TRequest, IRetriableResponse> policy, Func`2<TInitialArguments, Task`1<IRetriableResponse>> inBackoffAlternateCallbackMethod, TimeSpan minBackoffForInBackoffCallback, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.RequestRetryUtility/<ProcessRequestAsync>d__2`2")]
public static Task`1<IRetriableResponse> ProcessRequestAsync(Func`1<Task`1<IRetriableResponse>> executeAsync, Func`1<TRequest> prepareRequest, IRequestRetryPolicy`2<TRequest, IRetriableResponse> policy, CancellationToken cancellationToken, Func`1<Task`1<IRetriableResponse>> inBackoffAlternateCallbackMethod, Nullable`1<TimeSpan> minBackoffForInBackoffCallback);
}
internal class Microsoft.Azure.Documents.RequestTimeoutException : DocumentClientException {
    [CompilerGeneratedAttribute]
private string <LocalIp>k__BackingField;
    public string Message { get; }
    internal string LocalIp { get; internal set; }
    public RequestTimeoutException(string message, Uri requestUri);
    public RequestTimeoutException(string message, Exception innerException, Uri requestUri);
    public RequestTimeoutException(string message, HttpResponseHeaders headers, Uri requestUri);
    public RequestTimeoutException(Exception innerException, Uri requestUri);
    public RequestTimeoutException(string message, INameValueCollection headers, Uri requestUri);
    public RequestTimeoutException(string message, Exception innerException, Uri requestUri, string localIpAddress);
    public RequestTimeoutException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri);
    private RequestTimeoutException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
internal string get_LocalIp();
    [CompilerGeneratedAttribute]
internal void set_LocalIp(string value);
    private void SetDescription();
}
internal abstract class Microsoft.Azure.Documents.Resource : JsonSerializable {
    internal static DateTime UnixStartTime;
    [CompilerGeneratedAttribute]
private string <AltLink>k__BackingField;
    [JsonPropertyAttribute]
public string Id { get; public set; }
    [JsonPropertyAttribute]
public string ResourceId { get; public set; }
    [JsonPropertyAttribute]
public string SelfLink { get; internal set; }
    [JsonIgnoreAttribute]
public string AltLink { get; public set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("Microsoft.Azure.Documents.UnixDateTimeConverter")]
public DateTime Timestamp { get; internal set; }
    [JsonPropertyAttribute]
public string ETag { get; internal set; }
    protected Resource(Resource resource);
    private static Resource();
    public virtual string get_Id();
    public virtual void set_Id(string value);
    public virtual string get_ResourceId();
    public virtual void set_ResourceId(string value);
    public string get_SelfLink();
    internal void set_SelfLink(string value);
    [CompilerGeneratedAttribute]
public string get_AltLink();
    [CompilerGeneratedAttribute]
public void set_AltLink(string value);
    public virtual DateTime get_Timestamp();
    internal virtual void set_Timestamp(DateTime value);
    public string get_ETag();
    internal void set_ETag(string value);
    public void SetPropertyValue(string propertyName, object propertyValue);
    public T GetPropertyValue(string propertyName);
    internal virtual void Validate();
    public Byte[] ToByteArray();
}
internal class Microsoft.Azure.Documents.ResourceId : object {
    private static int EncryptionScopeIdLength;
    private static int OfferIdLength;
    private static int RbacResourceIdLength;
    private static int SnapshotIdLength;
    public static ushort Length;
    public static ushort MaxPathFragment;
    public static ResourceId Empty;
    [CompilerGeneratedAttribute]
private UInt32 <Offer>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DocumentCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StoredProcedure>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Trigger>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <UserDefinedFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Conflict>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <PartitionKeyRange>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <User>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ClientEncryptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UserDefinedType>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Permission>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Attachment>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <RoleAssignment>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <RoleDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AuthPolicyElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SystemDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <PartitionedSystemDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <InteropUser>k__BackingField;
    public UInt32 Offer { get; private set; }
    public ResourceId OfferId { get; }
    public UInt32 Database { get; private set; }
    public ResourceId DatabaseId { get; }
    public bool IsDatabaseId { get; }
    public bool IsDocumentCollectionId { get; }
    public bool IsPartitionKeyRangeId { get; }
    public UInt32 DocumentCollection { get; private set; }
    public ResourceId DocumentCollectionId { get; }
    public bool IsClientEncryptionKeyId { get; }
    public ulong UniqueDocumentCollectionId { get; }
    public ulong StoredProcedure { get; private set; }
    public ResourceId StoredProcedureId { get; }
    public ulong Trigger { get; private set; }
    public ResourceId TriggerId { get; }
    public ulong UserDefinedFunction { get; private set; }
    public ResourceId UserDefinedFunctionId { get; }
    public ulong Conflict { get; private set; }
    public ResourceId ConflictId { get; }
    public ulong Document { get; private set; }
    public ResourceId DocumentId { get; }
    public ulong PartitionKeyRange { get; private set; }
    public ResourceId PartitionKeyRangeId { get; }
    public UInt32 User { get; private set; }
    public ResourceId UserId { get; }
    public UInt32 ClientEncryptionKey { get; private set; }
    public ResourceId ClientEncryptionKeyId { get; }
    public UInt32 UserDefinedType { get; private set; }
    public ResourceId UserDefinedTypeId { get; }
    public ulong Permission { get; private set; }
    public ResourceId PermissionId { get; }
    public UInt32 Attachment { get; private set; }
    public ResourceId AttachmentId { get; }
    public ulong Schema { get; private set; }
    public ResourceId SchemaId { get; }
    public ulong Snapshot { get; private set; }
    public ResourceId SnapshotId { get; }
    public bool IsSnapshotId { get; }
    public ulong EncryptionScope { get; private set; }
    public ResourceId EncryptionScopeId { get; }
    public bool IsEncryptionScopeId { get; }
    public ulong RoleAssignment { get; private set; }
    public ResourceId RoleAssignmentId { get; }
    public bool IsRoleAssignmentId { get; }
    public ulong RoleDefinition { get; private set; }
    public ResourceId RoleDefinitionId { get; }
    public bool IsRoleDefinitionId { get; }
    public ulong AuthPolicyElement { get; private set; }
    public ResourceId AuthPolicyElementId { get; }
    public bool IsAuthPolicyElementId { get; }
    public ulong SystemDocument { get; private set; }
    public ResourceId SystemDocumentId { get; }
    public ulong PartitionedSystemDocument { get; private set; }
    public ResourceId PartitionedSystemDocumentId { get; }
    public ulong InteropUser { get; private set; }
    public ResourceId InteropUserId { get; }
    public bool IsInteropUserId { get; }
    public Byte[] Value { get; }
    private static ResourceId();
    [CompilerGeneratedAttribute]
public UInt32 get_Offer();
    [CompilerGeneratedAttribute]
private void set_Offer(UInt32 value);
    public ResourceId get_OfferId();
    [CompilerGeneratedAttribute]
public UInt32 get_Database();
    [CompilerGeneratedAttribute]
private void set_Database(UInt32 value);
    public ResourceId get_DatabaseId();
    public bool get_IsDatabaseId();
    public bool get_IsDocumentCollectionId();
    public bool get_IsPartitionKeyRangeId();
    [CompilerGeneratedAttribute]
public UInt32 get_DocumentCollection();
    [CompilerGeneratedAttribute]
private void set_DocumentCollection(UInt32 value);
    public ResourceId get_DocumentCollectionId();
    public bool get_IsClientEncryptionKeyId();
    public ulong get_UniqueDocumentCollectionId();
    [CompilerGeneratedAttribute]
public ulong get_StoredProcedure();
    [CompilerGeneratedAttribute]
private void set_StoredProcedure(ulong value);
    public ResourceId get_StoredProcedureId();
    [CompilerGeneratedAttribute]
public ulong get_Trigger();
    [CompilerGeneratedAttribute]
private void set_Trigger(ulong value);
    public ResourceId get_TriggerId();
    [CompilerGeneratedAttribute]
public ulong get_UserDefinedFunction();
    [CompilerGeneratedAttribute]
private void set_UserDefinedFunction(ulong value);
    public ResourceId get_UserDefinedFunctionId();
    [CompilerGeneratedAttribute]
public ulong get_Conflict();
    [CompilerGeneratedAttribute]
private void set_Conflict(ulong value);
    public ResourceId get_ConflictId();
    [CompilerGeneratedAttribute]
public ulong get_Document();
    [CompilerGeneratedAttribute]
private void set_Document(ulong value);
    public ResourceId get_DocumentId();
    [CompilerGeneratedAttribute]
public ulong get_PartitionKeyRange();
    [CompilerGeneratedAttribute]
private void set_PartitionKeyRange(ulong value);
    public ResourceId get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
public UInt32 get_User();
    [CompilerGeneratedAttribute]
private void set_User(UInt32 value);
    public ResourceId get_UserId();
    [CompilerGeneratedAttribute]
public UInt32 get_ClientEncryptionKey();
    [CompilerGeneratedAttribute]
private void set_ClientEncryptionKey(UInt32 value);
    public ResourceId get_ClientEncryptionKeyId();
    [CompilerGeneratedAttribute]
public UInt32 get_UserDefinedType();
    [CompilerGeneratedAttribute]
private void set_UserDefinedType(UInt32 value);
    public ResourceId get_UserDefinedTypeId();
    [CompilerGeneratedAttribute]
public ulong get_Permission();
    [CompilerGeneratedAttribute]
private void set_Permission(ulong value);
    public ResourceId get_PermissionId();
    [CompilerGeneratedAttribute]
public UInt32 get_Attachment();
    [CompilerGeneratedAttribute]
private void set_Attachment(UInt32 value);
    public ResourceId get_AttachmentId();
    [CompilerGeneratedAttribute]
public ulong get_Schema();
    [CompilerGeneratedAttribute]
private void set_Schema(ulong value);
    public ResourceId get_SchemaId();
    [CompilerGeneratedAttribute]
public ulong get_Snapshot();
    [CompilerGeneratedAttribute]
private void set_Snapshot(ulong value);
    public ResourceId get_SnapshotId();
    public bool get_IsSnapshotId();
    [CompilerGeneratedAttribute]
public ulong get_EncryptionScope();
    [CompilerGeneratedAttribute]
private void set_EncryptionScope(ulong value);
    public ResourceId get_EncryptionScopeId();
    public bool get_IsEncryptionScopeId();
    [CompilerGeneratedAttribute]
public ulong get_RoleAssignment();
    [CompilerGeneratedAttribute]
private void set_RoleAssignment(ulong value);
    public ResourceId get_RoleAssignmentId();
    public bool get_IsRoleAssignmentId();
    [CompilerGeneratedAttribute]
public ulong get_RoleDefinition();
    [CompilerGeneratedAttribute]
private void set_RoleDefinition(ulong value);
    public ResourceId get_RoleDefinitionId();
    public bool get_IsRoleDefinitionId();
    [CompilerGeneratedAttribute]
public ulong get_AuthPolicyElement();
    [CompilerGeneratedAttribute]
private void set_AuthPolicyElement(ulong value);
    public ResourceId get_AuthPolicyElementId();
    public bool get_IsAuthPolicyElementId();
    [CompilerGeneratedAttribute]
public ulong get_SystemDocument();
    [CompilerGeneratedAttribute]
private void set_SystemDocument(ulong value);
    public ResourceId get_SystemDocumentId();
    [CompilerGeneratedAttribute]
public ulong get_PartitionedSystemDocument();
    [CompilerGeneratedAttribute]
private void set_PartitionedSystemDocument(ulong value);
    public ResourceId get_PartitionedSystemDocumentId();
    [CompilerGeneratedAttribute]
public ulong get_InteropUser();
    [CompilerGeneratedAttribute]
private void set_InteropUser(ulong value);
    public ResourceId get_InteropUserId();
    public bool get_IsInteropUserId();
    public Byte[] get_Value();
    public static ResourceId Parse(string id);
    public static Byte[] Parse(ResourceType eResourceType, string id);
    public static ResourceId NewDatabaseId(UInt32 dbid);
    public static ResourceId NewRoleDefinitionId(ulong roleDefinitionId);
    public static ResourceId NewRoleAssignmentId(ulong roleAssignmentId);
    public static ResourceId NewAuthPolicyElementId(ulong authPolicyElementId);
    public static ResourceId NewSnapshotId(ulong snapshotId);
    public static ResourceId NewEncryptionScopeId(ulong encryptionScopeId);
    public static ResourceId NewInteropUserId(ulong interopUserId);
    public static ResourceId NewDocumentCollectionId(string databaseId, UInt32 collectionId);
    public static ResourceId NewDocumentCollectionId(UInt32 databaseId, UInt32 collectionId);
    public static ResourceId NewClientEncryptionKeyId(string databaseId, UInt32 clientEncryptionKeyId);
    public static ResourceId NewClientEncryptionKeyId(UInt32 databaseId, UInt32 clientEncryptionKeyId);
    public static ResourceId NewCollectionChildResourceId(string collectionId, ulong childId, ResourceType resourceType);
    public static ResourceId NewUserId(string databaseId, UInt32 userId);
    public static ResourceId NewPermissionId(string userId, ulong permissionId);
    public static ResourceId NewAttachmentId(string documentId, UInt32 attachmentId);
    public static string CreateNewCollectionChildResourceId(int childResourceIdIndex, ResourceType resourceType, string ownerResourceId);
    public static bool TryParse(string id, ResourceId& rid);
    public static bool Verify(string id, Byte[]& buffer);
    public static bool Verify(string id);
    public virtual string ToString();
    public sealed virtual bool Equals(ResourceId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool TryDecodeFromBase64String(string s, Byte[]& bytes);
    public static ulong ToUnsignedLong(Byte[] buffer);
    public static ulong ToUnsignedLong(Byte[] buffer, int length);
    public static string ToBase64String(Byte[] buffer);
    public static string ToBase64String(Byte[] buffer, int offset, int length);
    private static ResourceId NewDocumentId(UInt32 dbId, UInt32 collId);
    private static ResourceId NewDocumentCollectionId(UInt32 dbId);
    private static ResourceId NewDatabaseId();
    public static void BlockCopy(Byte[] src, int srcOffset, Byte[] dst, int dstOffset, int count);
    private static bool HasNonHierarchicalResourceId(ResourceType eResourceType);
}
internal static class Microsoft.Azure.Documents.ResourceIdBase64Decoder : object {
    private static byte EncodingPad;
    private static byte Space;
    private static SByte[] DecodingMap;
    private static ResourceIdBase64Decoder();
    public static bool TryDecode(string base64string, Byte[]& bytes);
    private static int Decode(Char* encodedChars, int sourceIndex);
    private static void WriteThreeLowOrderBytes(Byte[] destination, int destIndex, int value);
    private static bool TryComputeResultLength(Char* inputPtr, int inputLength, Int32& resultLength);
}
internal class Microsoft.Azure.Documents.ResourceOperation : ValueType {
    public OperationType operationType;
    public ResourceType resourceType;
    public static ResourceOperation CreateOffer;
    public static ResourceOperation ReplaceOffer;
    public static ResourceOperation ReadOffer;
    public static ResourceOperation DeleteOffer;
    public static ResourceOperation ReadOfferFeed;
    public static ResourceOperation CreateDatabase;
    public static ResourceOperation UpsertDatabase;
    public static ResourceOperation PatchDatabase;
    public static ResourceOperation ReplaceDatabase;
    public static ResourceOperation DeleteDatabase;
    public static ResourceOperation ReadDatabase;
    public static ResourceOperation ReadDatabaseFeed;
    public static ResourceOperation HeadDatabaseFeed;
    public static ResourceOperation CreateCollection;
    public static ResourceOperation PatchCollection;
    public static ResourceOperation ReplaceCollection;
    public static ResourceOperation DeleteCollection;
    public static ResourceOperation ReadCollection;
    public static ResourceOperation HeadCollection;
    public static ResourceOperation ReadCollectionFeed;
    public static ResourceOperation CreateDocument;
    public static ResourceOperation UpsertDocument;
    public static ResourceOperation PatchDocument;
    public static ResourceOperation ReplaceDocument;
    public static ResourceOperation DeleteDocument;
    public static ResourceOperation ReadDocument;
    public static ResourceOperation ReadDocumentFeed;
    public static ResourceOperation ExecuteDocumentFeed;
    public static ResourceOperation CreateAttachment;
    public static ResourceOperation UpsertAttachment;
    public static ResourceOperation PatchAttachment;
    public static ResourceOperation ReplaceAttachment;
    public static ResourceOperation DeleteAttachment;
    public static ResourceOperation ReadAttachment;
    public static ResourceOperation ReadAttachmentFeed;
    public static ResourceOperation CreateStoredProcedure;
    public static ResourceOperation UpsertStoredProcedure;
    public static ResourceOperation ReplaceStoredProcedure;
    public static ResourceOperation DeleteStoredProcedure;
    public static ResourceOperation ReadStoredProcedure;
    public static ResourceOperation ReadStoredProcedureFeed;
    public static ResourceOperation CreateUser;
    public static ResourceOperation UpsertUser;
    public static ResourceOperation PatchUser;
    public static ResourceOperation ReplaceUser;
    public static ResourceOperation DeleteUser;
    public static ResourceOperation ReadUser;
    public static ResourceOperation ReadUserFeed;
    public static ResourceOperation CreatePermission;
    public static ResourceOperation UpsertPermission;
    public static ResourceOperation PatchPermission;
    public static ResourceOperation ReplacePermission;
    public static ResourceOperation DeletePermission;
    public static ResourceOperation ReadPermission;
    public static ResourceOperation ReadPermissionFeed;
    public static ResourceOperation CreateClientEncryptionKey;
    public static ResourceOperation ReplaceClientEncryptionKey;
    public static ResourceOperation DeleteClientEncryptionKey;
    public static ResourceOperation ReadClientEncryptionKey;
    public static ResourceOperation ReadClientEncryptionKeyFeed;
    public static ResourceOperation CreateSystemDocument;
    public static ResourceOperation ReplaceSystemDocument;
    public static ResourceOperation DeleteSystemDocument;
    public static ResourceOperation ReadSystemDocument;
    public static ResourceOperation ReadSystemDocumentFeed;
    public static ResourceOperation CreatePartitionedSystemDocument;
    public static ResourceOperation ReplacePartitionedSystemDocument;
    public static ResourceOperation DeletePartitionedSystemDocument;
    public static ResourceOperation ReadPartitionedSystemDocument;
    public static ResourceOperation ReadPartitionedSystemDocumentFeed;
    public static ResourceOperation XDeleteConflict;
    public static ResourceOperation XReadConflict;
    public static ResourceOperation XReadConflictFeed;
    public static ResourceOperation XReadRecordFeed;
    public static ResourceOperation XCreateRecord;
    public static ResourceOperation XReadRecord;
    public static ResourceOperation XUpdateRecord;
    public static ResourceOperation XDeleteRecord;
    public static ResourceOperation XXCreateTrigger;
    public static ResourceOperation XXUpsertTrigger;
    public static ResourceOperation XXReplaceTrigger;
    public static ResourceOperation XXDeleteTrigger;
    public static ResourceOperation XXReadTrigger;
    public static ResourceOperation XXReadTriggerFeed;
    public static ResourceOperation XXCreateUserDefinedFunction;
    public static ResourceOperation XXUpsertUserDefinedFunction;
    public static ResourceOperation XXReplaceUserDefinedFunction;
    public static ResourceOperation XXDeleteUserDefinedFunction;
    public static ResourceOperation XXReadUserDefinedFunction;
    public static ResourceOperation XXReadUserDefinedFunctionFeed;
    public static ResourceOperation ReadSchema;
    public static ResourceOperation ReadSchemaFeed;
    public static ResourceOperation CompleteUserTransaction;
    public ResourceOperation(OperationType operationType, ResourceType resourceType);
    private static ResourceOperation();
    public static ResourceOperation Query(OperationType operationType, ResourceType resourceType);
    public virtual string ToString();
}
internal enum Microsoft.Azure.Documents.ResourceType : Enum {
    public int value__;
    public static ResourceType Unknown;
    public static ResourceType Database;
    public static ResourceType Collection;
    public static ResourceType Document;
    public static ResourceType Attachment;
    public static ResourceType User;
    public static ResourceType Permission;
    public static ResourceType Conflict;
    public static ResourceType Record;
    public static ResourceType StoredProcedure;
    public static ResourceType Trigger;
    public static ResourceType UserDefinedFunction;
    public static ResourceType BatchApply;
    public static ResourceType Offer;
    public static ResourceType DatabaseAccount;
    public static ResourceType SchemaContainer;
    public static ResourceType Schema;
    public static ResourceType PartitionKeyRange;
    public static ResourceType ComputeGatewayCharges;
    public static ResourceType UserDefinedType;
    public static ResourceType Batch;
    public static ResourceType PartitionKey;
    public static ResourceType Snapshot;
    public static ResourceType PartitionedSystemDocument;
    public static ResourceType ClientEncryptionKey;
    public static ResourceType Transaction;
    public static ResourceType RoleDefinition;
    public static ResourceType RoleAssignment;
    public static ResourceType SystemDocument;
    public static ResourceType InteropUser;
    public static ResourceType AuthPolicyElement;
    public static ResourceType RetriableWriteCachedResponse;
    public static ResourceType EncryptionScope;
    public static ResourceType Key;
    public static ResourceType Media;
    public static ResourceType Address;
    public static ResourceType ControllerService;
    public static ResourceType Telemetry;
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.ResourceTypeExtensions : object {
    private static Dictionary`2<int, string> resourceTypeNames;
    private static ResourceTypeExtensions();
    [ExtensionAttribute]
public static string ToResourceTypeString(ResourceType type);
    [ExtensionAttribute]
public static bool IsPartitioned(ResourceType type);
    [ExtensionAttribute]
public static bool IsCollectionChild(ResourceType type);
    [ExtensionAttribute]
public static bool IsScript(ResourceType type);
}
internal class Microsoft.Azure.Documents.RetryWithConfiguration : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <InitialRetryIntervalMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumRetryIntervalMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RandomSaltMaxValueMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TotalWaitTimeMilliseconds>k__BackingField;
    public Nullable`1<int> InitialRetryIntervalMilliseconds { get; public set; }
    public Nullable`1<int> MaximumRetryIntervalMilliseconds { get; public set; }
    public Nullable`1<int> RandomSaltMaxValueMilliseconds { get; public set; }
    public Nullable`1<int> TotalWaitTimeMilliseconds { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_InitialRetryIntervalMilliseconds();
    [CompilerGeneratedAttribute]
public void set_InitialRetryIntervalMilliseconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumRetryIntervalMilliseconds();
    [CompilerGeneratedAttribute]
public void set_MaximumRetryIntervalMilliseconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RandomSaltMaxValueMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RandomSaltMaxValueMilliseconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_TotalWaitTimeMilliseconds();
    [CompilerGeneratedAttribute]
public void set_TotalWaitTimeMilliseconds(Nullable`1<int> value);
}
internal class Microsoft.Azure.Documents.RetryWithException : DocumentClientException {
    public RetryWithException(string retryMessage);
    public RetryWithException(Exception innerException);
    public RetryWithException(string retryMessage, HttpResponseHeaders headers, Uri requestUri);
    public RetryWithException(string retryMessage, INameValueCollection headers, Uri requestUri);
    private RetryWithException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
}
internal static class Microsoft.Azure.Documents.Rfc1123DateTimeCache : object {
    private static FormattedTriple Current;
    private static long Timestamp;
    private static Rfc1123DateTimeCache();
    internal static DateTime Raw();
    internal static string UtcNow();
    private static FormattedTriple GetCacheFormattedTriple();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.Azure.Documents.RMResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ApiTypeForbidden { get; }
    internal static string ArgumentRequired { get; }
    internal static string AutoScaleSettingChangeWithUserAuthIsDisallowed { get; }
    internal static string AadAuthActionNotSupported { get; }
    internal static string AadAuthenticatorNotAvailable { get; }
    internal static string AadAuthDatabaseAccountRequestBlocked { get; }
    internal static string AadAuthGroupExpansionNeeded { get; }
    internal static string AadAuthRequestBlocked { get; }
    internal static string AadAuthorizerNotAvailable { get; }
    internal static string AadAuthPublicKeysFailedToUpdate { get; }
    internal static string SasTokenAuthDisabled { get; }
    internal static string AadLocalAuthDisabled { get; }
    internal static string BadClientMongo { get; }
    internal static string BadGateway { get; }
    internal static string BadRequest { get; }
    internal static string BadUrl { get; }
    internal static string CannotOfflineWriteRegionWithNoReadRegions { get; }
    internal static string CannotSpecifyPKRangeForNonPartitionedResource { get; }
    internal static string ChangeFeedOptionsStartTimeWithUnspecifiedDateTimeKind { get; }
    internal static string ChannelClosed { get; }
    internal static string ChannelMultiplexerClosedTransportError { get; }
    internal static string ChannelOpenFailedTransportError { get; }
    internal static string ChannelOpenTimeoutTransportError { get; }
    internal static string Client_CPUOverload { get; }
    internal static string Client_ThreadStarvation { get; }
    internal static string ClientCpuOverload { get; }
    internal static string ClientCpuThreadStarvation { get; }
    internal static string ClientUnavailable { get; }
    internal static string CollectionCreateTopologyConflict { get; }
    internal static string CollectionThroughputCannotBeMoreThan { get; }
    internal static string ConnectFailedTransportError { get; }
    internal static string ConnectionBrokenTransportError { get; }
    internal static string ConnectTimeoutTransportError { get; }
    internal static string CorrelationIDNotFoundInResponse { get; }
    internal static string CorsAllowedOriginsEmptyList { get; }
    internal static string CorsAllowedOriginsInvalidPath { get; }
    internal static string CorsAllowedOriginsMalformedUri { get; }
    internal static string CorsAllowedOriginsWildcardsNotSupported { get; }
    internal static string CorsTooManyRules { get; }
    internal static string CrossPartitionContinuationAndIndex { get; }
    internal static string CrossPartitionQueryDisabled { get; }
    internal static string CrossTenantCMKNotSupportedWithFirstPartyIdentity { get; }
    internal static string CrossTenantCMKNotSupportedWithSystemAssignedIdentity { get; }
    internal static string DatabaseAccountNotFound { get; }
    internal static string DatabaseCreateTopologyConflict { get; }
    internal static string DateTimeConverterInvalidDateTime { get; }
    internal static string DateTimeConverterInvalidReaderValue { get; }
    internal static string DateTimeConveterInvalidReaderDoubleValue { get; }
    internal static string DeserializationError { get; }
    internal static string DefaultIdentityNotValidFormat { get; }
    internal static string DefaultIdentityWithoutCorrespondingDelegatedIdentity { get; }
    internal static string DefaultIdentityWithoutCorrespondingSystemIdentity { get; }
    internal static string DefaultIdentityWithoutCorrespondingUserIdentity { get; }
    internal static string DnsResolutionFailedTransportError { get; }
    internal static string DnsResolutionTimeoutTransportError { get; }
    internal static string DocumentQueryExecutionContextIsDone { get; }
    internal static string DocumentServiceUnavailable { get; }
    internal static string DuplicateCorrelationIdGenerated { get; }
    internal static string EmptyVirtualNetworkResourceGuid { get; }
    internal static string EmptyVirtualNetworkRulesSpecified { get; }
    internal static string EnableAnalyticsStorageAndEnableServerlessNotSupported { get; }
    internal static string InvalidThroughputPolicy { get; }
    internal static string EnableMultipleWriteLocationsAndEnableServerlessNotSupported { get; }
    internal static string EnableMultipleWriteLocationsAndEnableTieredStorageV1NotSupported { get; }
    internal static string EnableOnlyColdStorageContainersInAccountV1AndEnableMaterializedViewsNotSupported { get; }
    internal static string EnableMultipleWriteLocationsAndStrongConsistencyNotSupported { get; }
    internal static string EnableMultipleWriteLocationsBeforeAddingRegion { get; }
    internal static string EnableMultipleWriteLocationsNotModified { get; }
    internal static string EnableMultiRegionAndEnableServerlessNotSupported { get; }
    internal static string PitrNotSupported { get; }
    internal static string EnableMultiRegionNotSupported { get; }
    internal static string EnableMultipleWriteLocationsNotSupported { get; }
    internal static string DisableKeyBasedMetadataWriteAccessNotSupported { get; }
    internal static string MaterializedViewsNotSupported { get; }
    internal static string FullFidelityChangeFeedNotSupported { get; }
    internal static string CassandraConnectorNotSupported { get; }
    internal static string FreeTierNotSupported { get; }
    internal static string IpRangeFilterNotSupported { get; }
    internal static string AnalyticalStoreNotSupported { get; }
    internal static string VirtualNetworkFilterNotSupported { get; }
    internal static string ServerlessNotSupported { get; }
    internal static string EndpointNotFound { get; }
    internal static string EntityAlreadyExists { get; }
    internal static string ExceptionMessage { get; }
    internal static string ExceptionMessageAddIpAddress { get; }
    internal static string ExceptionMessageAddRequestUri { get; }
    internal static string FeatureNotSupportedForMultiRegionAccount { get; }
    internal static string FeatureNotSupportedInRegion { get; }
    internal static string FeatureNotSupportedOnSubscription { get; }
    internal static string MaterializedViewsNotSupportedOnZoneRedundantAccount { get; }
    internal static string FederationEntityNotFound { get; }
    internal static string Forbidden { get; }
    internal static string ForbiddenPublicIpv4 { get; }
    internal static string ForbiddenServiceEndpoint { get; }
    internal static string ForbiddenPrivateEndpoint { get; }
    internal static string GatewayTimedout { get; }
    internal static string GlobalAndWriteRegionMisMatch { get; }
    internal static string FederationAndRegionMismatch { get; }
    internal static string GlobalStrongWriteBarrierNotMet { get; }
    internal static string Gone { get; }
    internal static string IdGenerationFailed { get; }
    internal static string IncompleteRoutingMap { get; }
    internal static string InsufficientPermissions { get; }
    internal static string InsufficientResourceTokens { get; }
    internal static string InternalServerError { get; }
    internal static string InvalidAPIVersion { get; }
    internal static string InvalidAPIVersionForFeature { get; }
    internal static string InvalidAudienceKind { get; }
    internal static string InvalidAudienceResourceType { get; }
    internal static string InvalidAuthHeaderFormat { get; }
    internal static string InvalidBackendResponse { get; }
    internal static string InvalidCapabilityCombination { get; }
    internal static string InvalidCharacterInResourceName { get; }
    internal static string InvalidConflictResolutionMode { get; }
    internal static string InvalidConsistencyLevel { get; }
    internal static string InvalidContinuationToken { get; }
    internal static string InvalidDatabase { get; }
    internal static string InvalidDateHeader { get; }
    internal static string InvalidDocumentCollection { get; }
    internal static string InvalidEnableMultipleWriteLocations { get; }
    internal static string InvalidEnumValue { get; }
    internal static string InvalidFailoverPriority { get; }
    internal static string InvalidFederationCapUncapMetadataAction { get; }
    internal static string InvalidFederationCapUncapMetadataSource { get; }
    internal static string InvalidHeaderValue { get; }
    internal static string InvalidIndexKindValue { get; }
    internal static string InvalidIndexSpecFormat { get; }
    internal static string InvalidIndexTransformationProgressValues { get; }
    internal static string InvalidLocations { get; }
    internal static string InvalidPrivateLinkServiceConnections { get; }
    internal static string InvalidPrivateLinkServiceProxies { get; }
    internal static string InvalidGroupIdCount { get; }
    internal static string InvalidGroupId { get; }
    internal static string InvalidMaxStalenessInterval { get; }
    internal static string InvalidMaxStalenessPrefix { get; }
    internal static string InvalidNonPartitionedOfferThroughput { get; }
    internal static string InsufficientPartitionedDataForOfferThroughput { get; }
    internal static string InvalidOfferIsAutoScaleEnabled { get; }
    internal static string InvalidOfferAutoScaleMode { get; }
    internal static string OfferAutopilotNotSupportedForNonPartitionedCollections { get; }
    internal static string OfferAutopilotNotSupportedOnSharedThroughputDatabase { get; }
    internal static string InvalidOfferIsRUPerMinuteThroughputEnabled { get; }
    internal static string InvalidBackgroundTaskMaxAllowedThroughputPercent { get; }
    internal static string InvalidOfferThroughput { get; }
    internal static string InvalidOfferType { get; }
    internal static string InvalidOfferV2Input { get; }
    internal static string InvalidOfferCRUDForServerless { get; }
    internal static string InvalidOwnerResourceType { get; }
    internal static string InvalidPageSize { get; }
    internal static string InvalidPartitionKey { get; }
    internal static string InvalidPartitionKeyRangeIdHeader { get; }
    internal static string InvalidPermissionMode { get; }
    internal static string InvalidPolicyType { get; }
    internal static string InvalidProxyCommand { get; }
    internal static string InvalidQuery { get; }
    internal static string InvalidQueryValue { get; }
    internal static string InvalidRegionsInSessionToken { get; }
    internal static string InvalidReplicationAndConsistencyCombination { get; }
    internal static string InvalidResourceID { get; }
    internal static string InvalidResourceIdBatchSize { get; }
    internal static string InvalidResourceKind { get; }
    internal static string InvalidResourceType { get; }
    internal static string InvalidResourceUrlPath { get; }
    internal static string InvalidResourceUrlQuery { get; }
    internal static string InvalidResponseContinuationTokenLimit { get; }
    internal static string InvalidScriptResource { get; }
    internal static string InvalidSessionToken { get; }
    internal static string InvalidSpaceEndingInResourceName { get; }
    internal static string InvalidStalenessPolicy { get; }
    internal static string InvalidStorageServiceMediaIndex { get; }
    internal static string InvalidSwitchOffCanEnableMultipleWriteLocations { get; }
    internal static string InvalidSwitchOnCanEnableMultipleWriteLocations { get; }
    internal static string InvalidTarget { get; }
    internal static string InvalidTokenTimeRange { get; }
    internal static string InvalidUrl { get; }
    internal static string InvalidRequestUrl { get; }
    internal static string InvalidUseSystemKey { get; }
    internal static string InvalidVersionFormat { get; }
    internal static string IpAddressBlockedByPolicy { get; }
    internal static string IsForceDeleteFederationAllowed { get; }
    internal static string JsonArrayNotStarted { get; }
    internal static string JsonInvalidEscapedCharacter { get; }
    internal static string JsonInvalidNumber { get; }
    internal static string JsonInvalidParameter { get; }
    internal static string JsonInvalidStringCharacter { get; }
    internal static string JsonInvalidToken { get; }
    internal static string JsonInvalidUnicodeEscape { get; }
    internal static string JsonMaxNestingExceeded { get; }
    internal static string JsonMissingClosingQuote { get; }
    internal static string JsonMissingEndArray { get; }
    internal static string JsonMissingEndObject { get; }
    internal static string JsonMissingNameSeparator { get; }
    internal static string JsonMissingProperty { get; }
    internal static string JsonNotComplete { get; }
    internal static string JsonNotFieldnameToken { get; }
    internal static string JsonNotNumberToken { get; }
    internal static string JsonNotStringToken { get; }
    internal static string JsonNumberOutOfRange { get; }
    internal static string JsonNumberTooLong { get; }
    internal static string JsonObjectNotStarted { get; }
    internal static string JsonPropertyAlreadyAdded { get; }
    internal static string JsonPropertyArrayOrObjectNotStarted { get; }
    internal static string JsonUnexpectedEndArray { get; }
    internal static string JsonUnexpectedEndObject { get; }
    internal static string JsonUnexpectedNameSeparator { get; }
    internal static string JsonUnexpectedToken { get; }
    internal static string JsonUnexpectedValueSeparator { get; }
    internal static string Locked { get; }
    internal static string MaximumRULimitExceeded { get; }
    internal static string MessageIdHeaderMissing { get; }
    internal static string MethodNotAllowed { get; }
    internal static string MismatchToken { get; }
    internal static string MissingAuthHeader { get; }
    internal static string MissingDateForAuthorization { get; }
    internal static string MissingPartitionKeyValue { get; }
    internal static string MissingProperty { get; }
    internal static string MissingRequiredHeader { get; }
    internal static string MissingRequiredQuery { get; }
    internal static string MoreThanOneBackupIntervalCapability { get; }
    internal static string MoreThanOneBackupRetentionCapability { get; }
    internal static string MustHaveNonZeroPreferredRegionWhenAutomaticFailoverDisabled { get; }
    internal static string NamingPropertyNotFound { get; }
    internal static string NegativeInteger { get; }
    internal static string NoGraftPoint { get; }
    internal static string NotFound { get; }
    internal static string GremlinV2ServiceDeleteNotSupported { get; }
    internal static string OfferReplaceTopologyConflict { get; }
    internal static string OfferReplaceWithSpecifiedVersionsNotSupported { get; }
    internal static string OfferTypeAndThroughputCannotBeSpecifiedBoth { get; }
    internal static string OfferThroughputAndAutoPilotSettingsCannotBeSpecifiedBoth { get; }
    internal static string AutoPilotTierAndAutoPilotSettingsCannotBeSpecifiedBoth { get; }
    internal static string AutopilotAutoUpgradeUnsupportedNonPartitionedCollection { get; }
    internal static string OperationRequestedStatusIsInvalid { get; }
    internal static string PartitionIsFull { get; }
    internal static string PartitionKeyAndEffectivePartitionKeyBothSpecified { get; }
    internal static string PartitionKeyAndPartitionKeyRangeRangeIdBothSpecified { get; }
    internal static string PartitionKeyMismatch { get; }
    internal static string PartitionKeyRangeIdAbsentInContext { get; }
    internal static string PartitionKeyRangeIdOrPartitionKeyMustBeSpecified { get; }
    internal static string PartitionKeyRangeNotFound { get; }
    internal static string PartitionMigrationOperationError { get; }
    internal static string PerRegionPerPartitionAutoscaleNotSupported { get; }
    internal static string PerRegionPerPartitionAutoscaleNotSupportedForServerless { get; }
    internal static string PositiveInteger { get; }
    internal static string PreconditionFailed { get; }
    internal static string PrimarySuceededButAdditionalRegionsFailed { get; }
    internal static string PrimaryWriteRegionFailedFormat { get; }
    internal static string SecondaryRegionsFailedFormat { get; }
    internal static string AddRemoveRegionOperationFailed { get; }
    internal static string PrimaryNotFound { get; }
    internal static string PropertyCannotBeNull { get; }
    internal static string PropertyNotFound { get; }
    internal static string ProvisionLimit { get; }
    internal static string RbacMissingAction { get; }
    internal static string RbacMissingUserId { get; }
    internal static string RbacCannotResolveResourceRid { get; }
    internal static string ReadQuorumNotMet { get; }
    internal static string ReadSessionNotAvailable { get; }
    internal static string ReceiveFailedTransportError { get; }
    internal static string ReceiveStreamClosedTransportError { get; }
    internal static string ReceiveTimeoutTransportError { get; }
    internal static string RemoveWriteRegionNotSupported { get; }
    internal static string ReplicaAtIndexNotAvailable { get; }
    internal static string RequestConsistencyLevelNotSupported { get; }
    internal static string RequestEntityTooLarge { get; }
    internal static string RequestTimeout { get; }
    internal static string RequestTimeoutTransportError { get; }
    internal static string RequestTooLarge { get; }
    internal static string ResourceIdCannotBeEmpty { get; }
    internal static string ResourceIdNotValid { get; }
    internal static string ResourceIdPolicyNotSupported { get; }
    internal static string ResourceTypeNotSupported { get; }
    internal static string RetryWith { get; }
    internal static string ScriptRenameInMultiplePartitionsIsNotSupported { get; }
    internal static string SecondariesNotFound { get; }
    internal static string SendFailedTransportError { get; }
    internal static string SendLockTimeoutTransportError { get; }
    internal static string SendTimeoutTransportError { get; }
    internal static string Server_CompletingPartitionMigrationExceededRetryLimit { get; }
    internal static string Server_CompletingSplitExceededRetryLimit { get; }
    internal static string Server_GlobalStrongWriteBarrierNotMet { get; }
    internal static string Server_NameCacheIsStaleExceededRetryLimit { get; }
    internal static string Server_NoValidStoreResponse { get; }
    internal static string Server_PartitionKeyRangeGoneExceededRetryLimit { get; }
    internal static string Server_ReadQuorumNotMet { get; }
    internal static string ServerGenerated410 { get; }
    internal static string ServerGenerated503 { get; }
    internal static string ServerResponseBodyTooLargeError { get; }
    internal static string ServerResponseHeaderTooLargeError { get; }
    internal static string ServerResponseInvalidHeaderLengthError { get; }
    internal static string ServerResponseTransportRequestIdMissingError { get; }
    internal static string ServiceNotFound { get; }
    internal static string ServiceReservedBitsOutOfRange { get; }
    internal static string ServiceUnavailable { get; }
    internal static string ServiceUnavailableDueToHighDemandInRegion { get; }
    internal static string ServiceWithResourceIdNotFound { get; }
    internal static string SpatialBoundingBoxInvalidCoordinates { get; }
    internal static string SpatialExtensionMethodsNotImplemented { get; }
    internal static string SpatialFailedToDeserializeCrs { get; }
    internal static string SpatialInvalidGeometryType { get; }
    internal static string SpatialInvalidPosition { get; }
    internal static string SslNegotiationFailedTransportError { get; }
    internal static string SslNegotiationTimeoutTransportError { get; }
    internal static string StarSlashArgumentError { get; }
    internal static string StorageAnalyticsNotEnabled { get; }
    internal static string StringArgumentNullOrEmpty { get; }
    internal static string SystemDatabaseAccountNotFound { get; }
    internal static string SystemDatabaseAccountPitrEnabledNotSupported { get; }
    internal static string CrossTenantCMKDatabaseAccountDelegatedIdentityNotSupported { get; }
    internal static string UnexpectedExceptionCaughtonKeyVaultAccessClient { get; }
    internal static string InvalidMSALScopeLength { get; }
    internal static string InvalidRequestedScopeFormat { get; }
    internal static string InvalidSchemeInScope { get; }
    internal static string InvalildScopeSegments { get; }
    internal static string KeyVaultServiceUnavailable { get; }
    internal static string InvalidKeyVaultKeyAndCertURI { get; }
    internal static string InvalidKeyVaulSecretURI { get; }
    internal static string KeyVaultDNSNotResolved { get; }
    internal static string KeyVaultCertificateException { get; }
    internal static string KeyVaultInvalidInputBytes { get; }
    internal static string KeyVaultAadClientCredentialsGrantFailure { get; }
    internal static string FirstKeyVaultAccessAttemptShouldBeUnauthorized { get; }
    internal static string TimeoutGenerated410 { get; }
    internal static string TooFewPartitionKeyComponents { get; }
    internal static string TooManyPartitionKeyComponents { get; }
    internal static string TooManyRequests { get; }
    internal static string TransportExceptionMessage { get; }
    internal static string TransportGenerated410 { get; }
    internal static string TransportGenerated503 { get; }
    internal static string TransportNegotiationTimeoutTransportError { get; }
    internal static string ChannelWaitingToOpenTimeoutException { get; }
    internal static string UnableToDeserializePartitionKeyValue { get; }
    internal static string UnableToFindFreeConnection { get; }
    internal static string Unauthorized { get; }
    internal static string UnauthorizedOfferReplaceRequest { get; }
    internal static string UnauthorizedRequestForAutoScale { get; }
    internal static string UnexpectedConsistencyLevel { get; }
    internal static string UnexpectedJsonSerializationFormat { get; }
    internal static string UnexpectedJsonTokenType { get; }
    internal static string UnexpectedOfferVersion { get; }
    internal static string UnexpectedOperationTypeForRoutingRequest { get; }
    internal static string UnexpectedOperator { get; }
    internal static string UnexpectedPartitionKeyRangeId { get; }
    internal static string UnExpectedResourceKindToReEncrypt { get; }
    internal static string UnexpectedResourceType { get; }
    internal static string UnknownResourceKind { get; }
    internal static string UnknownResourceType { get; }
    internal static string UnknownTransportError { get; }
    internal static string UnorderedDistinctQueryContinuationToken { get; }
    internal static string UnsupportedAzRegion { get; }
    internal static string UnsupportedCapabilityForKind { get; }
    internal static string UnsupportedCapabilityUpdate { get; }
    internal static string UnsupportedCapabilityForServerVersion { get; }
    internal static string UnsupportedCrossPartitionOrderByQueryOnMixedTypes { get; }
    internal static string UnsupportedCrossPartitionQuery { get; }
    internal static string UnsupportedCrossPartitionQueryWithAggregate { get; }
    internal static string UnsupportedEntityType { get; }
    internal static string UnsupportedHints { get; }
    internal static string UnsupportedKeyType { get; }
    internal static string UnsupportedOfferOperationForProvisionedThroughput { get; }
    internal static string UnSupportedOfferThroughput { get; }
    internal static string UnSupportedOfferThroughputWithTwoRanges { get; }
    internal static string UnsupportedOfferTypeWithV2Offer { get; }
    internal static string UnsupportedOfferVersion { get; }
    internal static string UnsupportedPartitionKeyComponentValue { get; }
    internal static string UnsupportedProgram { get; }
    internal static string UnsupportedProtocol { get; }
    internal static string UnsupportedQueryWithFullResultAggregate { get; }
    internal static string UnsupportedRegion { get; }
    internal static string UnsupportedClusterRegion { get; }
    internal static string UnsupportedRollbackKind { get; }
    internal static string UnsupportedRootPolicyChange { get; }
    internal static string UnsupportedSystemKeyKind { get; }
    internal static string UnsupportedTokenType { get; }
    internal static string UnsupportedV1OfferVersion { get; }
    internal static string UnsupportedAadAccessControlType { get; }
    internal static string UnsupportedAccessControlType { get; }
    internal static string UpsertsForScriptsWithMultiplePartitionsAreNotSupported { get; }
    internal static string WebSocketRequestsNotSupported { get; }
    internal static string WriteRegionAutomaticFailoverNotEnabled { get; }
    internal static string FailoverDisabled { get; }
    internal static string FailoverPriorityChangeDisabled { get; }
    internal static string WriteRegionDoesNotExist { get; }
    internal static string ZoneRedundantAccountsNotSupportedInLocation { get; }
    internal static string ConnectionIsBusy { get; }
    internal static string InvalidGremlinPartitionKey { get; }
    internal static string InvalidUpdateMaxthroughputEverProvisioned { get; }
    internal static string DataPlaneOperationNotAllowed { get; }
    internal static string CollectionCreateInProgress { get; }
    internal static string FreeTierAppliedBefore { get; }
    internal static string FreeTierNotSupportedForInternalSubscription { get; }
    internal static string DataTransferStateStoreNotResolved { get; }
    internal static string FreeTierUpdateNotSupported { get; }
    internal static string InvalidSubPartitionKeyLength { get; }
    internal static string InvalidSubPartitionKeyVersion { get; }
    internal static string UnderscoreIdIndexRequiredForMongo { get; }
    internal static string InvalidMongoPartitionKey { get; }
    internal static string MissingSchemaPolicyOnContainer { get; }
    internal static string CannotRemoveSchemaPolicyFromContainer { get; }
    internal static string CannotReplaceCassandraConflictPolicyFromContainer { get; }
    internal static string CannotCreateContainerWithoutCassandraConflictPolicy { get; }
    internal static string InvalidTypeSystemPolicy { get; }
    internal static string MissingTypeSystemPolicy { get; }
    internal static string MongoClientAutoUpgradeNotSupported { get; }
    internal static string UpdateToAutoscaleThroughputNotAllowed { get; }
    internal static string UpdateToManualThroughputNotAllowed { get; }
    internal static string SystemDatabaseAccountDeleteNotSupported { get; }
    internal static string InvalidSystemDatabaseAccountDelete { get; }
    internal static string InvalidStoreTypeSpecified { get; }
    internal static string RevokeRegrantNotAllowed { get; }
    internal static string InvalidTotalThroughputLimitUpdate { get; }
    internal static string UnsupportedPartitionDefinitionKindForPartialKeyOperations { get; }
    internal static string DuplicatePhysicalPartitionIdInTargetPartitionThroughputInfo { get; }
    internal static string DuplicatePhysicalPartitionIdInSourcePartitionThroughputInfo { get; }
    internal static string PhysicalPartitionIdinTargetAndSourcePartitionThroughputInfo { get; }
    internal static string PhysicalPartitionIdinTargetOrSourceDoesNotExist { get; }
    internal static string InvalidMongoCollectionName { get; }
    internal static string InvalidMongoDatabaseName { get; }
    internal static string KeyVaultAuthenticationFailureRevokeMessage { get; }
    internal static string KeyVaultWrapUnwrapFailureRevokeMessage { get; }
    internal static string KeyVaultKeyNotFoundRevokeMessage { get; }
    internal static string KeyVaultNotFoundRevokeMessage { get; }
    internal static string KeyVaultDNSNotResolvedRevokeMessage { get; }
    internal static string AadClientCredentialsGrantFailureRevokeMessage { get; }
    internal static string UndefinedDefaultIdentityRevokeMessage { get; }
    internal static string InvalidKeyVaultKeyURIRevokeMessage { get; }
    internal static string NspOutboundDeniedRevokeMessage { get; }
    internal static string UnknownSubstatusCodeRevokeMessage { get; }
    internal static string CmkAccountIsNotRevoked { get; }
    internal static string EnableDataMaskingPolicyAndEnableLogStoreNotSupported { get; }
    internal static string NotServerlessAccount { get; }
    internal static string DataMaskingPolicyNotSupported { get; }
    internal static string UnexpectedResultAtCmkFastScanner { get; }
    internal static string InvalidResultAtCmkFastScanner { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ApiTypeForbidden();
    internal static string get_ArgumentRequired();
    internal static string get_AutoScaleSettingChangeWithUserAuthIsDisallowed();
    internal static string get_AadAuthActionNotSupported();
    internal static string get_AadAuthenticatorNotAvailable();
    internal static string get_AadAuthDatabaseAccountRequestBlocked();
    internal static string get_AadAuthGroupExpansionNeeded();
    internal static string get_AadAuthRequestBlocked();
    internal static string get_AadAuthorizerNotAvailable();
    internal static string get_AadAuthPublicKeysFailedToUpdate();
    internal static string get_SasTokenAuthDisabled();
    internal static string get_AadLocalAuthDisabled();
    internal static string get_BadClientMongo();
    internal static string get_BadGateway();
    internal static string get_BadRequest();
    internal static string get_BadUrl();
    internal static string get_CannotOfflineWriteRegionWithNoReadRegions();
    internal static string get_CannotSpecifyPKRangeForNonPartitionedResource();
    internal static string get_ChangeFeedOptionsStartTimeWithUnspecifiedDateTimeKind();
    internal static string get_ChannelClosed();
    internal static string get_ChannelMultiplexerClosedTransportError();
    internal static string get_ChannelOpenFailedTransportError();
    internal static string get_ChannelOpenTimeoutTransportError();
    internal static string get_Client_CPUOverload();
    internal static string get_Client_ThreadStarvation();
    internal static string get_ClientCpuOverload();
    internal static string get_ClientCpuThreadStarvation();
    internal static string get_ClientUnavailable();
    internal static string get_CollectionCreateTopologyConflict();
    internal static string get_CollectionThroughputCannotBeMoreThan();
    internal static string get_ConnectFailedTransportError();
    internal static string get_ConnectionBrokenTransportError();
    internal static string get_ConnectTimeoutTransportError();
    internal static string get_CorrelationIDNotFoundInResponse();
    internal static string get_CorsAllowedOriginsEmptyList();
    internal static string get_CorsAllowedOriginsInvalidPath();
    internal static string get_CorsAllowedOriginsMalformedUri();
    internal static string get_CorsAllowedOriginsWildcardsNotSupported();
    internal static string get_CorsTooManyRules();
    internal static string get_CrossPartitionContinuationAndIndex();
    internal static string get_CrossPartitionQueryDisabled();
    internal static string get_CrossTenantCMKNotSupportedWithFirstPartyIdentity();
    internal static string get_CrossTenantCMKNotSupportedWithSystemAssignedIdentity();
    internal static string get_DatabaseAccountNotFound();
    internal static string get_DatabaseCreateTopologyConflict();
    internal static string get_DateTimeConverterInvalidDateTime();
    internal static string get_DateTimeConverterInvalidReaderValue();
    internal static string get_DateTimeConveterInvalidReaderDoubleValue();
    internal static string get_DeserializationError();
    internal static string get_DefaultIdentityNotValidFormat();
    internal static string get_DefaultIdentityWithoutCorrespondingDelegatedIdentity();
    internal static string get_DefaultIdentityWithoutCorrespondingSystemIdentity();
    internal static string get_DefaultIdentityWithoutCorrespondingUserIdentity();
    internal static string get_DnsResolutionFailedTransportError();
    internal static string get_DnsResolutionTimeoutTransportError();
    internal static string get_DocumentQueryExecutionContextIsDone();
    internal static string get_DocumentServiceUnavailable();
    internal static string get_DuplicateCorrelationIdGenerated();
    internal static string get_EmptyVirtualNetworkResourceGuid();
    internal static string get_EmptyVirtualNetworkRulesSpecified();
    internal static string get_EnableAnalyticsStorageAndEnableServerlessNotSupported();
    internal static string get_InvalidThroughputPolicy();
    internal static string get_EnableMultipleWriteLocationsAndEnableServerlessNotSupported();
    internal static string get_EnableMultipleWriteLocationsAndEnableTieredStorageV1NotSupported();
    internal static string get_EnableOnlyColdStorageContainersInAccountV1AndEnableMaterializedViewsNotSupported();
    internal static string get_EnableMultipleWriteLocationsAndStrongConsistencyNotSupported();
    internal static string get_EnableMultipleWriteLocationsBeforeAddingRegion();
    internal static string get_EnableMultipleWriteLocationsNotModified();
    internal static string get_EnableMultiRegionAndEnableServerlessNotSupported();
    internal static string get_PitrNotSupported();
    internal static string get_EnableMultiRegionNotSupported();
    internal static string get_EnableMultipleWriteLocationsNotSupported();
    internal static string get_DisableKeyBasedMetadataWriteAccessNotSupported();
    internal static string get_MaterializedViewsNotSupported();
    internal static string get_FullFidelityChangeFeedNotSupported();
    internal static string get_CassandraConnectorNotSupported();
    internal static string get_FreeTierNotSupported();
    internal static string get_IpRangeFilterNotSupported();
    internal static string get_AnalyticalStoreNotSupported();
    internal static string get_VirtualNetworkFilterNotSupported();
    internal static string get_ServerlessNotSupported();
    internal static string get_EndpointNotFound();
    internal static string get_EntityAlreadyExists();
    internal static string get_ExceptionMessage();
    internal static string get_ExceptionMessageAddIpAddress();
    internal static string get_ExceptionMessageAddRequestUri();
    internal static string get_FeatureNotSupportedForMultiRegionAccount();
    internal static string get_FeatureNotSupportedInRegion();
    internal static string get_FeatureNotSupportedOnSubscription();
    internal static string get_MaterializedViewsNotSupportedOnZoneRedundantAccount();
    internal static string get_FederationEntityNotFound();
    internal static string get_Forbidden();
    internal static string get_ForbiddenPublicIpv4();
    internal static string get_ForbiddenServiceEndpoint();
    internal static string get_ForbiddenPrivateEndpoint();
    internal static string get_GatewayTimedout();
    internal static string get_GlobalAndWriteRegionMisMatch();
    internal static string get_FederationAndRegionMismatch();
    internal static string get_GlobalStrongWriteBarrierNotMet();
    internal static string get_Gone();
    internal static string get_IdGenerationFailed();
    internal static string get_IncompleteRoutingMap();
    internal static string get_InsufficientPermissions();
    internal static string get_InsufficientResourceTokens();
    internal static string get_InternalServerError();
    internal static string get_InvalidAPIVersion();
    internal static string get_InvalidAPIVersionForFeature();
    internal static string get_InvalidAudienceKind();
    internal static string get_InvalidAudienceResourceType();
    internal static string get_InvalidAuthHeaderFormat();
    internal static string get_InvalidBackendResponse();
    internal static string get_InvalidCapabilityCombination();
    internal static string get_InvalidCharacterInResourceName();
    internal static string get_InvalidConflictResolutionMode();
    internal static string get_InvalidConsistencyLevel();
    internal static string get_InvalidContinuationToken();
    internal static string get_InvalidDatabase();
    internal static string get_InvalidDateHeader();
    internal static string get_InvalidDocumentCollection();
    internal static string get_InvalidEnableMultipleWriteLocations();
    internal static string get_InvalidEnumValue();
    internal static string get_InvalidFailoverPriority();
    internal static string get_InvalidFederationCapUncapMetadataAction();
    internal static string get_InvalidFederationCapUncapMetadataSource();
    internal static string get_InvalidHeaderValue();
    internal static string get_InvalidIndexKindValue();
    internal static string get_InvalidIndexSpecFormat();
    internal static string get_InvalidIndexTransformationProgressValues();
    internal static string get_InvalidLocations();
    internal static string get_InvalidPrivateLinkServiceConnections();
    internal static string get_InvalidPrivateLinkServiceProxies();
    internal static string get_InvalidGroupIdCount();
    internal static string get_InvalidGroupId();
    internal static string get_InvalidMaxStalenessInterval();
    internal static string get_InvalidMaxStalenessPrefix();
    internal static string get_InvalidNonPartitionedOfferThroughput();
    internal static string get_InsufficientPartitionedDataForOfferThroughput();
    internal static string get_InvalidOfferIsAutoScaleEnabled();
    internal static string get_InvalidOfferAutoScaleMode();
    internal static string get_OfferAutopilotNotSupportedForNonPartitionedCollections();
    internal static string get_OfferAutopilotNotSupportedOnSharedThroughputDatabase();
    internal static string get_InvalidOfferIsRUPerMinuteThroughputEnabled();
    internal static string get_InvalidBackgroundTaskMaxAllowedThroughputPercent();
    internal static string get_InvalidOfferThroughput();
    internal static string get_InvalidOfferType();
    internal static string get_InvalidOfferV2Input();
    internal static string get_InvalidOfferCRUDForServerless();
    internal static string get_InvalidOwnerResourceType();
    internal static string get_InvalidPageSize();
    internal static string get_InvalidPartitionKey();
    internal static string get_InvalidPartitionKeyRangeIdHeader();
    internal static string get_InvalidPermissionMode();
    internal static string get_InvalidPolicyType();
    internal static string get_InvalidProxyCommand();
    internal static string get_InvalidQuery();
    internal static string get_InvalidQueryValue();
    internal static string get_InvalidRegionsInSessionToken();
    internal static string get_InvalidReplicationAndConsistencyCombination();
    internal static string get_InvalidResourceID();
    internal static string get_InvalidResourceIdBatchSize();
    internal static string get_InvalidResourceKind();
    internal static string get_InvalidResourceType();
    internal static string get_InvalidResourceUrlPath();
    internal static string get_InvalidResourceUrlQuery();
    internal static string get_InvalidResponseContinuationTokenLimit();
    internal static string get_InvalidScriptResource();
    internal static string get_InvalidSessionToken();
    internal static string get_InvalidSpaceEndingInResourceName();
    internal static string get_InvalidStalenessPolicy();
    internal static string get_InvalidStorageServiceMediaIndex();
    internal static string get_InvalidSwitchOffCanEnableMultipleWriteLocations();
    internal static string get_InvalidSwitchOnCanEnableMultipleWriteLocations();
    internal static string get_InvalidTarget();
    internal static string get_InvalidTokenTimeRange();
    internal static string get_InvalidUrl();
    internal static string get_InvalidRequestUrl();
    internal static string get_InvalidUseSystemKey();
    internal static string get_InvalidVersionFormat();
    internal static string get_IpAddressBlockedByPolicy();
    internal static string get_IsForceDeleteFederationAllowed();
    internal static string get_JsonArrayNotStarted();
    internal static string get_JsonInvalidEscapedCharacter();
    internal static string get_JsonInvalidNumber();
    internal static string get_JsonInvalidParameter();
    internal static string get_JsonInvalidStringCharacter();
    internal static string get_JsonInvalidToken();
    internal static string get_JsonInvalidUnicodeEscape();
    internal static string get_JsonMaxNestingExceeded();
    internal static string get_JsonMissingClosingQuote();
    internal static string get_JsonMissingEndArray();
    internal static string get_JsonMissingEndObject();
    internal static string get_JsonMissingNameSeparator();
    internal static string get_JsonMissingProperty();
    internal static string get_JsonNotComplete();
    internal static string get_JsonNotFieldnameToken();
    internal static string get_JsonNotNumberToken();
    internal static string get_JsonNotStringToken();
    internal static string get_JsonNumberOutOfRange();
    internal static string get_JsonNumberTooLong();
    internal static string get_JsonObjectNotStarted();
    internal static string get_JsonPropertyAlreadyAdded();
    internal static string get_JsonPropertyArrayOrObjectNotStarted();
    internal static string get_JsonUnexpectedEndArray();
    internal static string get_JsonUnexpectedEndObject();
    internal static string get_JsonUnexpectedNameSeparator();
    internal static string get_JsonUnexpectedToken();
    internal static string get_JsonUnexpectedValueSeparator();
    internal static string get_Locked();
    internal static string get_MaximumRULimitExceeded();
    internal static string get_MessageIdHeaderMissing();
    internal static string get_MethodNotAllowed();
    internal static string get_MismatchToken();
    internal static string get_MissingAuthHeader();
    internal static string get_MissingDateForAuthorization();
    internal static string get_MissingPartitionKeyValue();
    internal static string get_MissingProperty();
    internal static string get_MissingRequiredHeader();
    internal static string get_MissingRequiredQuery();
    internal static string get_MoreThanOneBackupIntervalCapability();
    internal static string get_MoreThanOneBackupRetentionCapability();
    internal static string get_MustHaveNonZeroPreferredRegionWhenAutomaticFailoverDisabled();
    internal static string get_NamingPropertyNotFound();
    internal static string get_NegativeInteger();
    internal static string get_NoGraftPoint();
    internal static string get_NotFound();
    internal static string get_GremlinV2ServiceDeleteNotSupported();
    internal static string get_OfferReplaceTopologyConflict();
    internal static string get_OfferReplaceWithSpecifiedVersionsNotSupported();
    internal static string get_OfferTypeAndThroughputCannotBeSpecifiedBoth();
    internal static string get_OfferThroughputAndAutoPilotSettingsCannotBeSpecifiedBoth();
    internal static string get_AutoPilotTierAndAutoPilotSettingsCannotBeSpecifiedBoth();
    internal static string get_AutopilotAutoUpgradeUnsupportedNonPartitionedCollection();
    internal static string get_OperationRequestedStatusIsInvalid();
    internal static string get_PartitionIsFull();
    internal static string get_PartitionKeyAndEffectivePartitionKeyBothSpecified();
    internal static string get_PartitionKeyAndPartitionKeyRangeRangeIdBothSpecified();
    internal static string get_PartitionKeyMismatch();
    internal static string get_PartitionKeyRangeIdAbsentInContext();
    internal static string get_PartitionKeyRangeIdOrPartitionKeyMustBeSpecified();
    internal static string get_PartitionKeyRangeNotFound();
    internal static string get_PartitionMigrationOperationError();
    internal static string get_PerRegionPerPartitionAutoscaleNotSupported();
    internal static string get_PerRegionPerPartitionAutoscaleNotSupportedForServerless();
    internal static string get_PositiveInteger();
    internal static string get_PreconditionFailed();
    internal static string get_PrimarySuceededButAdditionalRegionsFailed();
    internal static string get_PrimaryWriteRegionFailedFormat();
    internal static string get_SecondaryRegionsFailedFormat();
    internal static string get_AddRemoveRegionOperationFailed();
    internal static string get_PrimaryNotFound();
    internal static string get_PropertyCannotBeNull();
    internal static string get_PropertyNotFound();
    internal static string get_ProvisionLimit();
    internal static string get_RbacMissingAction();
    internal static string get_RbacMissingUserId();
    internal static string get_RbacCannotResolveResourceRid();
    internal static string get_ReadQuorumNotMet();
    internal static string get_ReadSessionNotAvailable();
    internal static string get_ReceiveFailedTransportError();
    internal static string get_ReceiveStreamClosedTransportError();
    internal static string get_ReceiveTimeoutTransportError();
    internal static string get_RemoveWriteRegionNotSupported();
    internal static string get_ReplicaAtIndexNotAvailable();
    internal static string get_RequestConsistencyLevelNotSupported();
    internal static string get_RequestEntityTooLarge();
    internal static string get_RequestTimeout();
    internal static string get_RequestTimeoutTransportError();
    internal static string get_RequestTooLarge();
    internal static string get_ResourceIdCannotBeEmpty();
    internal static string get_ResourceIdNotValid();
    internal static string get_ResourceIdPolicyNotSupported();
    internal static string get_ResourceTypeNotSupported();
    internal static string get_RetryWith();
    internal static string get_ScriptRenameInMultiplePartitionsIsNotSupported();
    internal static string get_SecondariesNotFound();
    internal static string get_SendFailedTransportError();
    internal static string get_SendLockTimeoutTransportError();
    internal static string get_SendTimeoutTransportError();
    internal static string get_Server_CompletingPartitionMigrationExceededRetryLimit();
    internal static string get_Server_CompletingSplitExceededRetryLimit();
    internal static string get_Server_GlobalStrongWriteBarrierNotMet();
    internal static string get_Server_NameCacheIsStaleExceededRetryLimit();
    internal static string get_Server_NoValidStoreResponse();
    internal static string get_Server_PartitionKeyRangeGoneExceededRetryLimit();
    internal static string get_Server_ReadQuorumNotMet();
    internal static string get_ServerGenerated410();
    internal static string get_ServerGenerated503();
    internal static string get_ServerResponseBodyTooLargeError();
    internal static string get_ServerResponseHeaderTooLargeError();
    internal static string get_ServerResponseInvalidHeaderLengthError();
    internal static string get_ServerResponseTransportRequestIdMissingError();
    internal static string get_ServiceNotFound();
    internal static string get_ServiceReservedBitsOutOfRange();
    internal static string get_ServiceUnavailable();
    internal static string get_ServiceUnavailableDueToHighDemandInRegion();
    internal static string get_ServiceWithResourceIdNotFound();
    internal static string get_SpatialBoundingBoxInvalidCoordinates();
    internal static string get_SpatialExtensionMethodsNotImplemented();
    internal static string get_SpatialFailedToDeserializeCrs();
    internal static string get_SpatialInvalidGeometryType();
    internal static string get_SpatialInvalidPosition();
    internal static string get_SslNegotiationFailedTransportError();
    internal static string get_SslNegotiationTimeoutTransportError();
    internal static string get_StarSlashArgumentError();
    internal static string get_StorageAnalyticsNotEnabled();
    internal static string get_StringArgumentNullOrEmpty();
    internal static string get_SystemDatabaseAccountNotFound();
    internal static string get_SystemDatabaseAccountPitrEnabledNotSupported();
    internal static string get_CrossTenantCMKDatabaseAccountDelegatedIdentityNotSupported();
    internal static string get_UnexpectedExceptionCaughtonKeyVaultAccessClient();
    internal static string get_InvalidMSALScopeLength();
    internal static string get_InvalidRequestedScopeFormat();
    internal static string get_InvalidSchemeInScope();
    internal static string get_InvalildScopeSegments();
    internal static string get_KeyVaultServiceUnavailable();
    internal static string get_InvalidKeyVaultKeyAndCertURI();
    internal static string get_InvalidKeyVaulSecretURI();
    internal static string get_KeyVaultDNSNotResolved();
    internal static string get_KeyVaultCertificateException();
    internal static string get_KeyVaultInvalidInputBytes();
    internal static string get_KeyVaultAadClientCredentialsGrantFailure();
    internal static string get_FirstKeyVaultAccessAttemptShouldBeUnauthorized();
    internal static string get_TimeoutGenerated410();
    internal static string get_TooFewPartitionKeyComponents();
    internal static string get_TooManyPartitionKeyComponents();
    internal static string get_TooManyRequests();
    internal static string get_TransportExceptionMessage();
    internal static string get_TransportGenerated410();
    internal static string get_TransportGenerated503();
    internal static string get_TransportNegotiationTimeoutTransportError();
    internal static string get_ChannelWaitingToOpenTimeoutException();
    internal static string get_UnableToDeserializePartitionKeyValue();
    internal static string get_UnableToFindFreeConnection();
    internal static string get_Unauthorized();
    internal static string get_UnauthorizedOfferReplaceRequest();
    internal static string get_UnauthorizedRequestForAutoScale();
    internal static string get_UnexpectedConsistencyLevel();
    internal static string get_UnexpectedJsonSerializationFormat();
    internal static string get_UnexpectedJsonTokenType();
    internal static string get_UnexpectedOfferVersion();
    internal static string get_UnexpectedOperationTypeForRoutingRequest();
    internal static string get_UnexpectedOperator();
    internal static string get_UnexpectedPartitionKeyRangeId();
    internal static string get_UnExpectedResourceKindToReEncrypt();
    internal static string get_UnexpectedResourceType();
    internal static string get_UnknownResourceKind();
    internal static string get_UnknownResourceType();
    internal static string get_UnknownTransportError();
    internal static string get_UnorderedDistinctQueryContinuationToken();
    internal static string get_UnsupportedAzRegion();
    internal static string get_UnsupportedCapabilityForKind();
    internal static string get_UnsupportedCapabilityUpdate();
    internal static string get_UnsupportedCapabilityForServerVersion();
    internal static string get_UnsupportedCrossPartitionOrderByQueryOnMixedTypes();
    internal static string get_UnsupportedCrossPartitionQuery();
    internal static string get_UnsupportedCrossPartitionQueryWithAggregate();
    internal static string get_UnsupportedEntityType();
    internal static string get_UnsupportedHints();
    internal static string get_UnsupportedKeyType();
    internal static string get_UnsupportedOfferOperationForProvisionedThroughput();
    internal static string get_UnSupportedOfferThroughput();
    internal static string get_UnSupportedOfferThroughputWithTwoRanges();
    internal static string get_UnsupportedOfferTypeWithV2Offer();
    internal static string get_UnsupportedOfferVersion();
    internal static string get_UnsupportedPartitionKeyComponentValue();
    internal static string get_UnsupportedProgram();
    internal static string get_UnsupportedProtocol();
    internal static string get_UnsupportedQueryWithFullResultAggregate();
    internal static string get_UnsupportedRegion();
    internal static string get_UnsupportedClusterRegion();
    internal static string get_UnsupportedRollbackKind();
    internal static string get_UnsupportedRootPolicyChange();
    internal static string get_UnsupportedSystemKeyKind();
    internal static string get_UnsupportedTokenType();
    internal static string get_UnsupportedV1OfferVersion();
    internal static string get_UnsupportedAadAccessControlType();
    internal static string get_UnsupportedAccessControlType();
    internal static string get_UpsertsForScriptsWithMultiplePartitionsAreNotSupported();
    internal static string get_WebSocketRequestsNotSupported();
    internal static string get_WriteRegionAutomaticFailoverNotEnabled();
    internal static string get_FailoverDisabled();
    internal static string get_FailoverPriorityChangeDisabled();
    internal static string get_WriteRegionDoesNotExist();
    internal static string get_ZoneRedundantAccountsNotSupportedInLocation();
    internal static string get_ConnectionIsBusy();
    internal static string get_InvalidGremlinPartitionKey();
    internal static string get_InvalidUpdateMaxthroughputEverProvisioned();
    internal static string get_DataPlaneOperationNotAllowed();
    internal static string get_CollectionCreateInProgress();
    internal static string get_FreeTierAppliedBefore();
    internal static string get_FreeTierNotSupportedForInternalSubscription();
    internal static string get_DataTransferStateStoreNotResolved();
    internal static string get_FreeTierUpdateNotSupported();
    internal static string get_InvalidSubPartitionKeyLength();
    internal static string get_InvalidSubPartitionKeyVersion();
    internal static string get_UnderscoreIdIndexRequiredForMongo();
    internal static string get_InvalidMongoPartitionKey();
    internal static string get_MissingSchemaPolicyOnContainer();
    internal static string get_CannotRemoveSchemaPolicyFromContainer();
    internal static string get_CannotReplaceCassandraConflictPolicyFromContainer();
    internal static string get_CannotCreateContainerWithoutCassandraConflictPolicy();
    internal static string get_InvalidTypeSystemPolicy();
    internal static string get_MissingTypeSystemPolicy();
    internal static string get_MongoClientAutoUpgradeNotSupported();
    internal static string get_UpdateToAutoscaleThroughputNotAllowed();
    internal static string get_UpdateToManualThroughputNotAllowed();
    internal static string get_SystemDatabaseAccountDeleteNotSupported();
    internal static string get_InvalidSystemDatabaseAccountDelete();
    internal static string get_InvalidStoreTypeSpecified();
    internal static string get_RevokeRegrantNotAllowed();
    internal static string get_InvalidTotalThroughputLimitUpdate();
    internal static string get_UnsupportedPartitionDefinitionKindForPartialKeyOperations();
    internal static string get_DuplicatePhysicalPartitionIdInTargetPartitionThroughputInfo();
    internal static string get_DuplicatePhysicalPartitionIdInSourcePartitionThroughputInfo();
    internal static string get_PhysicalPartitionIdinTargetAndSourcePartitionThroughputInfo();
    internal static string get_PhysicalPartitionIdinTargetOrSourceDoesNotExist();
    internal static string get_InvalidMongoCollectionName();
    internal static string get_InvalidMongoDatabaseName();
    internal static string get_KeyVaultAuthenticationFailureRevokeMessage();
    internal static string get_KeyVaultWrapUnwrapFailureRevokeMessage();
    internal static string get_KeyVaultKeyNotFoundRevokeMessage();
    internal static string get_KeyVaultNotFoundRevokeMessage();
    internal static string get_KeyVaultDNSNotResolvedRevokeMessage();
    internal static string get_AadClientCredentialsGrantFailureRevokeMessage();
    internal static string get_UndefinedDefaultIdentityRevokeMessage();
    internal static string get_InvalidKeyVaultKeyURIRevokeMessage();
    internal static string get_NspOutboundDeniedRevokeMessage();
    internal static string get_UnknownSubstatusCodeRevokeMessage();
    internal static string get_CmkAccountIsNotRevoked();
    internal static string get_EnableDataMaskingPolicyAndEnableLogStoreNotSupported();
    internal static string get_NotServerlessAccount();
    internal static string get_DataMaskingPolicyNotSupported();
    internal static string get_UnexpectedResultAtCmkFastScanner();
    internal static string get_InvalidResultAtCmkFastScanner();
}
internal class Microsoft.Azure.Documents.Rntbd.Channel : object {
    private Dispatcher dispatcher;
    private TimerPool timerPool;
    private int requestTimeoutSeconds;
    private Uri serverUri;
    private bool localRegionRequest;
    private bool disposed;
    private ReaderWriterLockSlim stateLock;
    private State state;
    private Task initializationTask;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isInitializationComplete;
    private ChannelOpenArguments openArguments;
    private SemaphoreSlim openingSlim;
    private IChaosInterceptor chaosInterceptor;
    [CompilerGeneratedAttribute]
private Action TestOnInitializeComplete;
    [DebuggerBrowsableAttribute("0")]
public bool Healthy { get; }
    private Guid ConnectionCorrelationId { get; }
    internal bool TestIsIdle { get; }
    public Channel(Guid activityId, Uri serverUri, ChannelProperties channelProperties, bool localRegionRequest, SemaphoreSlim openingSlim, IChaosInterceptor chaosInterceptor, Func`5<Guid, Guid, Uri, Channel, Task> onChannelOpen);
    public void InjectFaultInjectionConnectionError(TransportException transportException);
    public Uri GetServerUri();
    public sealed virtual bool get_Healthy();
    private Guid get_ConnectionCorrelationId();
    private void Initialize(Guid activityId, Func`5<Guid, Guid, Uri, Channel, Task> onChannelOpen);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Channel/<RequestAsync>d__21")]
public sealed virtual Task`1<StoreResponse> RequestAsync(DocumentServiceRequest request, TransportAddressUri physicalAddress, ResourceOperation resourceOperation, Guid activityId, TransportRequestStats transportRequestStats);
    public sealed virtual Task OpenChannelAsync(Guid activityId);
    public virtual string ToString();
    public sealed virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
internal void add_TestOnInitializeComplete(Action value);
    [CompilerGeneratedAttribute]
internal void remove_TestOnInitializeComplete(Action value);
    internal void add_TestOnConnectionClosed(Action value);
    internal void remove_TestOnConnectionClosed(Action value);
    internal bool get_TestIsIdle();
    private void ThrowIfDisposed();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Channel/<InitializeAsync>d__35")]
private Task InitializeAsync(Guid activityId, Func`5<Guid, Guid, Uri, Channel, Task> onChannelOpen);
    private void FinishInitialization(State nextState);
    private static void HandleTaskTimeout(Task runawayTask, Guid activityId, Guid connectionCorrelationId);
    [CompilerGeneratedAttribute]
private void <FinishInitialization>b__36_0(Task completedTask);
}
internal class Microsoft.Azure.Documents.Rntbd.ChannelCallArguments : object {
    private ChannelCommonArguments commonArguments;
    private OperationType operationType;
    private ResourceType resourceType;
    private string resolvedCollectionRid;
    private INameValueCollection requestHeaders;
    private Uri locationEndpointToRouteTo;
    [CompilerGeneratedAttribute]
private PrepareCallResult <PreparedCall>k__BackingField;
    public ChannelCommonArguments CommonArguments { get; }
    public PrepareCallResult PreparedCall { get; public set; }
    public OperationType OperationType { get; }
    public ResourceType ResourceType { get; }
    public string ResolvedCollectionRid { get; }
    public INameValueCollection RequestHeaders { get; }
    public Uri LocationEndpointToRouteTo { get; }
    public ChannelCallArguments(Guid activityId);
    public ChannelCallArguments(Guid activityId, OperationType operationType, ResourceType resourceType, string resolvedCollectionRid, INameValueCollection requestHeaders, Uri locationEndpointToRouteTo);
    public ChannelCommonArguments get_CommonArguments();
    [CompilerGeneratedAttribute]
public PrepareCallResult get_PreparedCall();
    [CompilerGeneratedAttribute]
public void set_PreparedCall(PrepareCallResult value);
    public OperationType get_OperationType();
    public ResourceType get_ResourceType();
    public string get_ResolvedCollectionRid();
    public INameValueCollection get_RequestHeaders();
    public Uri get_LocationEndpointToRouteTo();
    public sealed virtual void Dispose();
}
internal class Microsoft.Azure.Documents.Rntbd.ChannelCommonArguments : object {
    private object mutex;
    private TransportErrorCode timeoutCode;
    private bool payloadSent;
    [CompilerGeneratedAttribute]
private Guid <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UserPayload>k__BackingField;
    public Guid ActivityId { get; public set; }
    public bool UserPayload { get; private set; }
    public bool PayloadSent { get; }
    public ChannelCommonArguments(Guid activityId, TransportErrorCode initialTimeoutCode, bool userPayload);
    [CompilerGeneratedAttribute]
public Guid get_ActivityId();
    [CompilerGeneratedAttribute]
public void set_ActivityId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_UserPayload();
    [CompilerGeneratedAttribute]
private void set_UserPayload(bool value);
    public bool get_PayloadSent();
    public void SnapshotCallState(TransportErrorCode& timeoutCode, Boolean& payloadSent);
    public void SetTimeoutCode(TransportErrorCode errorCode);
    public void SetPayloadSent();
}
internal class Microsoft.Azure.Documents.Rntbd.ChannelDictionary : object {
    private ChannelProperties channelProperties;
    private bool disposed;
    private ConcurrentDictionary`2<ServerKey, IChannel> channels;
    private IChaosInterceptor chaosInterceptor;
    public ChannelDictionary(ChannelProperties channelProperties, IChaosInterceptor chaosInterceptor);
    public sealed virtual IChannel GetChannel(Uri requestUri, bool localRegionRequest);
    public bool TryGetChannel(Uri requestUri, IChannel& channel);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
internal class Microsoft.Azure.Documents.Rntbd.ChannelOpenArguments : object {
    private ChannelCommonArguments commonArguments;
    private ChannelOpenTimeline openTimeline;
    private TimeSpan openTimeout;
    private PortReuseMode portReuseMode;
    private UserPortPool userPortPool;
    private CallerId callerId;
    public ChannelCommonArguments CommonArguments { get; }
    public ChannelOpenTimeline OpenTimeline { get; }
    public TimeSpan OpenTimeout { get; }
    public PortReuseMode PortReuseMode { get; }
    public UserPortPool PortPool { get; }
    public CallerId CallerId { get; }
    public ChannelOpenArguments(Guid activityId, ChannelOpenTimeline openTimeline, TimeSpan openTimeout, PortReuseMode portReuseMode, UserPortPool userPortPool, CallerId callerId);
    public ChannelCommonArguments get_CommonArguments();
    public ChannelOpenTimeline get_OpenTimeline();
    public TimeSpan get_OpenTimeout();
    public PortReuseMode get_PortReuseMode();
    public UserPortPool get_PortPool();
    public CallerId get_CallerId();
}
internal class Microsoft.Azure.Documents.Rntbd.ChannelOpenTimeline : object {
    private DateTimeOffset creationTime;
    private DateTimeOffset connectTime;
    private DateTimeOffset sslHandshakeTime;
    private DateTimeOffset rntbdHandshakeTime;
    [CompilerGeneratedAttribute]
private static ConnectionTimerDelegate <TraceFunc>k__BackingField;
    public static ConnectionTimerDelegate TraceFunc { get; public set; }
    public void RecordConnectFinishTime();
    public void RecordSslHandshakeFinishTime();
    public void RecordRntbdHandshakeFinishTime();
    public void WriteTrace();
    [CompilerGeneratedAttribute]
public static ConnectionTimerDelegate get_TraceFunc();
    [CompilerGeneratedAttribute]
public static void set_TraceFunc(ConnectionTimerDelegate value);
    private static string InvariantString(DateTimeOffset t);
}
internal class Microsoft.Azure.Documents.Rntbd.ChannelProperties : object {
    [CompilerGeneratedAttribute]
private UserAgentContainer <UserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateHostNameOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private IConnectionStateListener <ConnectionStateListener>k__BackingField;
    [CompilerGeneratedAttribute]
private TimerPool <RequestTimerPool>k__BackingField;
    [CompilerGeneratedAttribute]
private TimerPool <IdleTimerPool>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <OpenTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LocalRegionOpenTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private PortReuseMode <PortReuseMode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxChannels>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PartitionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRequestsPerChannel>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ReceiveHangDetectionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SendHangDetectionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <IdleTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private UserPortPool <UserPortPool>k__BackingField;
    [CompilerGeneratedAttribute]
private CallerId <CallerId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableChannelMultiplexing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConcurrentOpeningConnectionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryStreamPool <MemoryStreamPool>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, Task`1<IPAddress>> <DnsResolutionFunction>k__BackingField;
    public UserAgentContainer UserAgent { get; private set; }
    public string CertificateHostNameOverride { get; private set; }
    public IConnectionStateListener ConnectionStateListener { get; private set; }
    public TimerPool RequestTimerPool { get; private set; }
    public TimerPool IdleTimerPool { get; private set; }
    public TimeSpan RequestTimeout { get; private set; }
    public TimeSpan OpenTimeout { get; private set; }
    public TimeSpan LocalRegionOpenTimeout { get; private set; }
    public PortReuseMode PortReuseMode { get; private set; }
    public int MaxChannels { get; private set; }
    public int PartitionCount { get; private set; }
    public int MaxRequestsPerChannel { get; private set; }
    public TimeSpan ReceiveHangDetectionTime { get; private set; }
    public TimeSpan SendHangDetectionTime { get; private set; }
    public TimeSpan IdleTimeout { get; private set; }
    public UserPortPool UserPortPool { get; private set; }
    public CallerId CallerId { get; private set; }
    public bool EnableChannelMultiplexing { get; private set; }
    public int MaxConcurrentOpeningConnectionCount { get; private set; }
    public MemoryStreamPool MemoryStreamPool { get; private set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; private set; }
    public Func`2<string, Task`1<IPAddress>> DnsResolutionFunction { get; private set; }
    public ChannelProperties(UserAgentContainer userAgent, string certificateHostNameOverride, IConnectionStateListener connectionStateListener, TimerPool requestTimerPool, TimeSpan requestTimeout, TimeSpan openTimeout, TimeSpan localRegionOpenTimeout, PortReuseMode portReuseMode, UserPortPool userPortPool, int maxChannels, int partitionCount, int maxRequestsPerChannel, int maxConcurrentOpeningConnectionCount, TimeSpan receiveHangDetectionTime, TimeSpan sendHangDetectionTime, TimeSpan idleTimeout, TimerPool idleTimerPool, CallerId callerId, bool enableChannelMultiplexing, MemoryStreamPool memoryStreamPool, RemoteCertificateValidationCallback remoteCertificateValidationCallback, Func`2<string, Task`1<IPAddress>> dnsResolutionFunction);
    [CompilerGeneratedAttribute]
public UserAgentContainer get_UserAgent();
    [CompilerGeneratedAttribute]
private void set_UserAgent(UserAgentContainer value);
    [CompilerGeneratedAttribute]
public string get_CertificateHostNameOverride();
    [CompilerGeneratedAttribute]
private void set_CertificateHostNameOverride(string value);
    [CompilerGeneratedAttribute]
public IConnectionStateListener get_ConnectionStateListener();
    [CompilerGeneratedAttribute]
private void set_ConnectionStateListener(IConnectionStateListener value);
    [CompilerGeneratedAttribute]
public TimerPool get_RequestTimerPool();
    [CompilerGeneratedAttribute]
private void set_RequestTimerPool(TimerPool value);
    [CompilerGeneratedAttribute]
public TimerPool get_IdleTimerPool();
    [CompilerGeneratedAttribute]
private void set_IdleTimerPool(TimerPool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
private void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_OpenTimeout();
    [CompilerGeneratedAttribute]
private void set_OpenTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LocalRegionOpenTimeout();
    [CompilerGeneratedAttribute]
private void set_LocalRegionOpenTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public PortReuseMode get_PortReuseMode();
    [CompilerGeneratedAttribute]
private void set_PortReuseMode(PortReuseMode value);
    [CompilerGeneratedAttribute]
public int get_MaxChannels();
    [CompilerGeneratedAttribute]
private void set_MaxChannels(int value);
    [CompilerGeneratedAttribute]
public int get_PartitionCount();
    [CompilerGeneratedAttribute]
private void set_PartitionCount(int value);
    [CompilerGeneratedAttribute]
public int get_MaxRequestsPerChannel();
    [CompilerGeneratedAttribute]
private void set_MaxRequestsPerChannel(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ReceiveHangDetectionTime();
    [CompilerGeneratedAttribute]
private void set_ReceiveHangDetectionTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_SendHangDetectionTime();
    [CompilerGeneratedAttribute]
private void set_SendHangDetectionTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_IdleTimeout();
    [CompilerGeneratedAttribute]
private void set_IdleTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public UserPortPool get_UserPortPool();
    [CompilerGeneratedAttribute]
private void set_UserPortPool(UserPortPool value);
    [CompilerGeneratedAttribute]
public CallerId get_CallerId();
    [CompilerGeneratedAttribute]
private void set_CallerId(CallerId value);
    [CompilerGeneratedAttribute]
public bool get_EnableChannelMultiplexing();
    [CompilerGeneratedAttribute]
private void set_EnableChannelMultiplexing(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxConcurrentOpeningConnectionCount();
    [CompilerGeneratedAttribute]
private void set_MaxConcurrentOpeningConnectionCount(int value);
    [CompilerGeneratedAttribute]
public MemoryStreamPool get_MemoryStreamPool();
    [CompilerGeneratedAttribute]
private void set_MemoryStreamPool(MemoryStreamPool value);
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    [CompilerGeneratedAttribute]
private void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public Func`2<string, Task`1<IPAddress>> get_DnsResolutionFunction();
    [CompilerGeneratedAttribute]
private void set_DnsResolutionFunction(Func`2<string, Task`1<IPAddress>> value);
}
internal class Microsoft.Azure.Documents.Rntbd.Connection : object {
    private static int ResponseLengthByteLimit;
    private static SslProtocols TlsProtocols;
    private static UInt32 TcpKeepAliveIntervalSocketOptionEnumValue;
    private static UInt32 TcpKeepAliveTimeSocketOptionEnumValue;
    private static UInt32 DefaultSocketOptionTcpKeepAliveInterval;
    private static UInt32 DefaultSocketOptionTcpKeepAliveTime;
    private static UInt32 SocketOptionTcpKeepAliveInterval;
    private static UInt32 SocketOptionTcpKeepAliveTime;
    private static Lazy`1<ConcurrentPrng> rng;
    private static Lazy`1<Byte[]> keepAliveConfiguration;
    private static Lazy`1<bool> isKeepAliveCustomizationSupported;
    private static TimeSpan recentReceiveWindow;
    private Guid connectionCorrelationId;
    private Uri serverUri;
    private string hostNameCertificateOverride;
    private MemoryStreamPool memoryStreamPool;
    private RemoteCertificateValidationCallback remoteCertificateValidationCallback;
    private bool disposed;
    private TcpClient tcpClient;
    private UserPortPool portPool;
    private IPEndPoint localEndPoint;
    private IPEndPoint remoteEndPoint;
    private TimeSpan idleConnectionTimeout;
    private TimeSpan idleConnectionClosureTimeout;
    private Func`2<string, Task`1<IPAddress>> dnsResolutionFunction;
    private SemaphoreSlim writeSemaphore;
    private Stream stream;
    private RntbdStreamReader streamReader;
    private object timestampLock;
    private DateTime lastSendAttemptTime;
    private DateTime lastSendTime;
    private DateTime lastReceiveTime;
    private long numberOfSendsSinceLastReceive;
    private DateTime firstSendSinceLastReceive;
    private object nameLock;
    private string name;
    private static int numberOfOpenTcpConnections;
    private ConnectionHealthChecker healthChecker;
    [CompilerGeneratedAttribute]
private BufferProvider <BufferProvider>k__BackingField;
    public static int NumberOfOpenTcpConnections { get; }
    public BufferProvider BufferProvider { get; }
    public Uri ServerUri { get; }
    public bool Healthy { get; }
    public bool Disposed { get; }
    public Guid ConnectionCorrelationId { get; }
    internal TimeSpan TestIdleConnectionClosureTimeout { get; }
    public Connection(Uri serverUri, string hostNameCertificateOverride, TimeSpan receiveHangDetectionTime, TimeSpan sendHangDetectionTime, TimeSpan idleTimeout, MemoryStreamPool memoryStreamPool, RemoteCertificateValidationCallback remoteCertificateValidationCallback, Func`2<string, Task`1<IPAddress>> dnsResolutionFunction);
    private static Connection();
    public static int get_NumberOfOpenTcpConnections();
    [CompilerGeneratedAttribute]
public BufferProvider get_BufferProvider();
    public Uri get_ServerUri();
    public bool get_Healthy();
    public bool get_Disposed();
    public Guid get_ConnectionCorrelationId();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<OpenAsync>d__53")]
public Task OpenAsync(ChannelOpenArguments args);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<WriteRequestAsync>d__54")]
public Task WriteRequestAsync(ChannelCommonArguments args, SerializedRequest messagePayload, TransportRequestStats transportRequestStats);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<ReadResponseMetadataAsync>d__55")]
[SuppressMessageAttribute("", "AvoidMultiLineComments")]
public Task`1<ResponseMetadata> ReadResponseMetadataAsync(ChannelCommonArguments args);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<ReadResponseBodyAsync>d__56")]
public Task`1<MemoryStream> ReadResponseBodyAsync(ChannelCommonArguments args);
    public virtual string ToString();
    public sealed virtual void Dispose();
    public bool IsActive(TimeSpan& timeToIdle);
    internal void NotifyConnectionStatus(bool isCompleted, bool isReadRequest);
    internal TimeSpan get_TestIdleConnectionClosureTimeout();
    internal void TestSetLastReceiveTime(DateTime lrt);
    private static UInt32 GetUInt32FromEnvironmentVariableOrDefault(string name, UInt32 minValue, UInt32 maxValue, UInt32 defaultValue);
    private void ThrowIfDisposed();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<OpenSocketAsync>d__66")]
private Task OpenSocketAsync(ChannelOpenArguments args);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<NegotiateSslAsync>d__67")]
private Task NegotiateSslAsync(ChannelOpenArguments args);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<ReadPayloadAsync>d__68")]
private Task ReadPayloadAsync(Byte[] payload, int length, string type, ChannelCommonArguments args);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<ReadPayloadAsync>d__69")]
private Task ReadPayloadAsync(MemoryStream payload, int length, string type, ChannelCommonArguments args);
    private void TraceAndThrowReceiveFailedException(IOException e, string type, ChannelCommonArguments args);
    private void TraceAndThrowEndOfStream(string type, ChannelCommonArguments args);
    private void SnapshotConnectionTimestamps(DateTime& lastSendAttempt, DateTime& lastSend, DateTime& lastReceive, Nullable`1& firstSendSinceLastReceive, Int64& numberOfSendsSinceLastReceive);
    private string GetConnectionTimestampsText();
    private void UpdateLastSendAttemptTime();
    private void UpdateLastSendTime();
    private void UpdateLastReceiveTime();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<ConnectUnicastPortAsync>d__77")]
private static Task`1<TcpClient> ConnectUnicastPortAsync(Uri serverUri, IPAddress resolvedAddress, Guid connectionCorrelationId);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<ConnectReuseAddrAsync>d__78")]
private static Task`1<Tuple`2<TcpClient, bool>> ConnectReuseAddrAsync(Uri serverUri, IPAddress address, ushort candidatePort, Guid connectionCorrelationId);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<ConnectUserPortAsync>d__79")]
private static Task`1<Tuple`2<TcpClient, bool>> ConnectUserPortAsync(Uri serverUri, IPAddress address, UserPortPool portPool, string connectionName, Guid connectionCorrelationId);
    private static Task`1<IPAddress> ResolveHostIncludingIPv6AddressesAsync(string hostName);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Connection/<ResolveHostAsync>d__81")]
internal static Task`1<IPAddress> ResolveHostAsync(string hostName, bool includeIPv6Addresses);
    private static void SetCommonSocketOptions(Socket clientSocket, Guid connectionCorrelationId);
    private static void EnableTcpKeepAlive(Socket clientSocket, Guid connectionCorrelationId);
    private static void SetKeepAliveSocketOptions(Socket clientSocket);
    private static bool IsKeepAliveCustomizationSupported();
    private static Byte[] GetWindowsKeepAliveConfiguration();
    private static void SetReuseUnicastPort(Socket clientSocket, Guid connectionCorrelationId);
}
internal class Microsoft.Azure.Documents.Rntbd.CpuLoad : ValueType {
    public DateTime Timestamp;
    public float Value;
    public CpuLoad(DateTime timestamp, float value);
    public virtual string ToString();
}
internal class Microsoft.Azure.Documents.Rntbd.CpuLoadHistory : object {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<CpuLoad> <CpuLoad>k__BackingField;
    private TimeSpan monitoringInterval;
    private Lazy`1<bool> cpuOverload;
    private Lazy`1<string> cpuloadHistory;
    internal ReadOnlyCollection`1<CpuLoad> CpuLoad { get; }
    internal DateTime LastTimestamp { get; }
    public bool IsCpuOverloaded { get; }
    public CpuLoadHistory(ReadOnlyCollection`1<CpuLoad> cpuLoad, TimeSpan monitoringInterval);
    [CompilerGeneratedAttribute]
internal ReadOnlyCollection`1<CpuLoad> get_CpuLoad();
    internal DateTime get_LastTimestamp();
    public bool get_IsCpuOverloaded();
    public virtual string ToString();
    private bool GetCpuOverload();
    [CompilerGeneratedAttribute]
private string <.ctor>b__6_0();
}
internal class Microsoft.Azure.Documents.Rntbd.CpuMonitor : object {
    internal static int DefaultRefreshIntervalInSeconds;
    private static int HistoryLength;
    private static TimeSpan refreshInterval;
    private bool disposed;
    private ReaderWriterLockSlim rwLock;
    private CancellationTokenSource cancellation;
    private CpuLoadHistory currentReading;
    private Task periodicTask;
    private static CpuMonitor();
    internal static void OverrideRefreshInterval(TimeSpan newRefreshInterval);
    public void Start();
    private void StopCoreUnderWriteLock(CancellationTokenSource& cancel, Task& backgroundTask);
    private static void StopCoreAfterReleasingWriteLock(CancellationTokenSource cancel, Task backgroundTask);
    public void Stop();
    public CpuLoadHistory GetCpuLoad();
    public sealed virtual void Dispose();
    private void MarkDisposed();
    private void ThrowIfDisposed();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.CpuMonitor/<RefreshLoopAsync>d__17")]
private Task RefreshLoopAsync(CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Documents.Rntbd.Dispatcher : object {
    private Connection connection;
    private UserAgentContainer userAgent;
    private Uri serverUri;
    private IConnectionStateListener connectionStateListener;
    private CancellationTokenSource cancellation;
    private TimerPool idleTimerPool;
    private bool enableChannelMultiplexing;
    private bool disposed;
    private ServerProperties serverProperties;
    private int nextRequestId;
    private object callLock;
    private Task receiveTask;
    private Dictionary`2<UInt32, CallInfo> calls;
    private bool callsAllowed;
    private object connectionLock;
    private PooledTimer idleTimer;
    private Task idleTimerTask;
    private IChaosInterceptor chaosInterceptor;
    private TransportException faultInjectionTransportException;
    private bool isFaultInjectionedConnectionError;
    [CompilerGeneratedAttribute]
private Action TestOnConnectionClosed;
    public Guid ConnectionCorrelationId { get; }
    internal bool TestIsIdle { get; }
    public bool Healthy { get; }
    public Dispatcher(Uri serverUri, UserAgentContainer userAgent, IConnectionStateListener connectionStateListener, string hostNameCertificateOverride, TimeSpan receiveHangDetectionTime, TimeSpan sendHangDetectionTime, TimerPool idleTimerPool, TimeSpan idleTimeout, bool enableChannelMultiplexing, MemoryStreamPool memoryStreamPool, RemoteCertificateValidationCallback remoteCertificateValidationCallback, Func`2<string, Task`1<IPAddress>> dnsResolutionFunction, IChaosInterceptor chaosInterceptor);
    public Guid get_ConnectionCorrelationId();
    [CompilerGeneratedAttribute]
internal void add_TestOnConnectionClosed(Action value);
    [CompilerGeneratedAttribute]
internal void remove_TestOnConnectionClosed(Action value);
    internal bool get_TestIsIdle();
    public bool get_Healthy();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Dispatcher/<OpenAsync>d__30")]
public Task OpenAsync(ChannelOpenArguments args);
    public void InjectFaultInjectionConnectionError(TransportException transportException);
    public PrepareCallResult PrepareCall(DocumentServiceRequest request, TransportAddressUri physicalAddress, ResourceOperation resourceOperation, Guid activityId, TransportRequestStats transportRequestStats);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Dispatcher/<CallAsync>d__34")]
public Task`1<StoreResponse> CallAsync(ChannelCallArguments args, TransportRequestStats transportRequestStats);
    public void CancelCallAndNotifyConnectionOnTimeoutEvent(PrepareCallResult preparedCall, bool isReadOnly);
    public void NotifyConnectionOnSuccessEvent();
    public virtual string ToString();
    public sealed virtual void Dispose();
    private void StartIdleTimer();
    private void OnIdleTimer(Task precedentTask);
    private void ScheduleIdleTimer(TimeSpan timeToIdle);
    private void StartConnectionShutdown();
    private Task StopIdleTimer();
    private Task CloseConnection();
    private void WaitTask(Task t, string description);
    private void ThrowIfDisposed();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Dispatcher/<NegotiateRntbdContextAsync>d__47")]
private Task NegotiateRntbdContextAsync(ChannelOpenArguments args);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Dispatcher/<ReceiveLoopAsync>d__48")]
private Task ReceiveLoopAsync();
    private Dictionary`2<UInt32, CallInfo> StopCalls();
    private void DispatchRntbdResponse(ResponseMetadata responseMd, RntbdHeader responseHeader, MemoryStream responseBody, Byte[] metadata, int metadataLength, UInt32 transportRequestId);
    private void DispatchChannelFailureException(Exception ex);
    private void DispatchCancellation();
    private CallInfo RemoveCall(UInt32 requestId);
    private void DisallowInitialCalls();
    private void DisallowRuntimeCalls();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.Dispatcher/<<OpenAsync>b__30_0>d")]
[CompilerGeneratedAttribute]
private Task <OpenAsync>b__30_0();
    [CompilerGeneratedAttribute]
private void <OpenAsync>b__30_1(Task completedTask);
    [CompilerGeneratedAttribute]
private void <ScheduleIdleTimer>b__41_0(Task failedTask);
}
internal static class Microsoft.Azure.Documents.Rntbd.HeadersTransportSerialization : object {
    public static StoreResponseNameValueCollection BuildStoreResponseNameValueCollection(Guid activityId, string serverVersion, BytesDeserializer& rntbdHeaderReader);
    internal static bool TryParseMandatoryResponseHeaders(BytesDeserializer& rntbdHeaderReader, Boolean& payloadPresent, UInt32& transportRequestId);
    private static void AdvanceByRntbdHeader(BytesDeserializer& rntbdHeaderReader, ResponseIdentifiers identifier);
    private static string ReadStringHeader(BytesDeserializer& rntbdHeaderReader);
    private static string ReadSmallStringHeader(BytesDeserializer& rntbdHeaderReader);
    private static string ReadDoubleHeader(BytesDeserializer& rntbdHeaderReader);
    private static string ReadIntHeader(BytesDeserializer& rntbdHeaderReader);
    private static string ReadLongHeader(BytesDeserializer& rntbdHeaderReader);
    private static string ReadIntBoolHeader(BytesDeserializer& rntbdHeaderReader);
    private static string ReadBoolHeader(BytesDeserializer& rntbdHeaderReader);
    private static string ReadGuidHeader(BytesDeserializer& rntbdHeaderReader);
    private static string ReadUIntHeader(BytesDeserializer& rntbdHeaderReader);
    private static string ReadUShortHeader(BytesDeserializer& rntbdHeaderReader);
    private static string ReadULongHeader(BytesDeserializer& rntbdHeaderReader);
}
internal interface Microsoft.Azure.Documents.Rntbd.IChannel {
    public bool Healthy { get; }
    public abstract virtual Task`1<StoreResponse> RequestAsync(DocumentServiceRequest request, TransportAddressUri physicalAddress, ResourceOperation resourceOperation, Guid activityId, TransportRequestStats transportRequestStats);
    public abstract virtual Task OpenChannelAsync(Guid activityId);
    public abstract virtual bool get_Healthy();
    public abstract virtual void Close();
}
internal interface Microsoft.Azure.Documents.Rntbd.IChannelDictionary {
    public abstract virtual IChannel GetChannel(Uri requestUri, bool localRegionRequest);
}
internal class Microsoft.Azure.Documents.Rntbd.LbChannelState : object {
    private int maxRequestsPending;
    private IChannel channel;
    private int requestsPending;
    private bool cachedHealthy;
    public bool DeepHealthy { get; }
    public bool ShallowHealthy { get; }
    public IChannel Channel { get; }
    public LbChannelState(IChannel channel, int maxRequestsPending);
    public bool Enter();
    public bool Exit();
    public bool get_DeepHealthy();
    public bool get_ShallowHealthy();
    public IChannel get_Channel();
    public sealed virtual void Dispose();
}
internal class Microsoft.Azure.Documents.Rntbd.LinuxSystemUtilizationReader : SystemUtilizationReaderBase {
    private ProcStatFileParser procStatFileParser;
    private ProcMemInfoFileParser procMemInfoFileParser;
    private ulong lastIdleJiffies;
    private ulong lastKernelJiffies;
    private ulong lastOtherJiffies;
    private ulong lastUserJiffies;
    internal LinuxSystemUtilizationReader(string procStatFilePath, string procMemoryInfoPath);
    protected virtual float GetSystemWideCpuUsageCore();
    protected virtual Nullable`1<long> GetSystemWideMemoryAvailabiltyCore();
}
internal class Microsoft.Azure.Documents.Rntbd.LoadBalancingChannel : object {
    private Uri serverUri;
    private LoadBalancingPartition singlePartition;
    private LoadBalancingPartition[] partitions;
    private bool disposed;
    public bool Healthy { get; }
    public LoadBalancingChannel(Uri serverUri, ChannelProperties channelProperties, bool localRegionRequest, IChaosInterceptor chaosInterceptor);
    public sealed virtual bool get_Healthy();
    public sealed virtual Task`1<StoreResponse> RequestAsync(DocumentServiceRequest request, TransportAddressUri physicalAddress, ResourceOperation resourceOperation, Guid activityId, TransportRequestStats transportRequestStats);
    public sealed virtual Task OpenChannelAsync(Guid activityId);
    private LoadBalancingPartition GetLoadBalancedPartition(Guid activityId);
    public sealed virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    private void ThrowIfDisposed();
}
internal class Microsoft.Azure.Documents.Rntbd.LoadBalancingPartition : object {
    private Uri serverUri;
    private ChannelProperties channelProperties;
    private bool localRegionRequest;
    private int maxCapacity;
    private int requestsPending;
    private SequenceGenerator sequenceGenerator;
    private ReaderWriterLockSlim capacityLock;
    private int capacity;
    private List`1<LbChannelState> openChannels;
    private SemaphoreSlim concurrentOpeningChannelSlim;
    private IChaosInterceptor chaosInterceptor;
    private Func`8<Guid, Uri, ChannelProperties, bool, SemaphoreSlim, IChaosInterceptor, Func`5<Guid, Guid, Uri, Channel, Task>, IChannel> channelFactory;
    public LoadBalancingPartition(Uri serverUri, ChannelProperties channelProperties, bool localRegionRequest, Func`8<Guid, Uri, ChannelProperties, bool, SemaphoreSlim, IChaosInterceptor, Func`5<Guid, Guid, Uri, Channel, Task>, IChannel> channelFactory, IChaosInterceptor chaosInterceptor);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.LoadBalancingPartition/<RequestAsync>d__13")]
public Task`1<StoreResponse> RequestAsync(DocumentServiceRequest request, TransportAddressUri physicalAddress, ResourceOperation resourceOperation, Guid activityId, TransportRequestStats transportRequestStats);
    internal Task OpenChannelAsync(Guid activityId);
    public sealed virtual void Dispose();
    private IChannel OpenChannelAndIncrementCapacity(Guid activityId, Func`5<Guid, Guid, Uri, Channel, Task> onChannelOpen);
    private static IChannel CreateAndInitializeChannel(Guid activityId, Uri serverUri, ChannelProperties channelProperties, bool localRegionRequest, SemaphoreSlim concurrentOpeningChannelSlim, IChaosInterceptor chaosInterceptor, Func`5<Guid, Guid, Uri, Channel, Task> onChannelOpen);
}
internal class Microsoft.Azure.Documents.Rntbd.ServerKey : object {
    [CompilerGeneratedAttribute]
private string <Server>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    public string Server { get; private set; }
    public int Port { get; private set; }
    public ServerKey(Uri uri);
    [CompilerGeneratedAttribute]
public string get_Server();
    [CompilerGeneratedAttribute]
private void set_Server(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
private void set_Port(int value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public bool Equals(ServerKey key);
    public virtual int GetHashCode();
    private static int HashInt32(int key);
}
internal class Microsoft.Azure.Documents.Rntbd.ServerProperties : object {
    [CompilerGeneratedAttribute]
private string <Agent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Agent { get; private set; }
    public string Version { get; private set; }
    public ServerProperties(string agent, string version);
    [CompilerGeneratedAttribute]
public string get_Agent();
    [CompilerGeneratedAttribute]
private void set_Agent(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(string value);
}
internal class Microsoft.Azure.Documents.Rntbd.SystemUsageHistory : object {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<SystemUsageLoad> <Values>k__BackingField;
    private TimeSpan monitoringInterval;
    private Lazy`1<string> loadHistory;
    private Lazy`1<Nullable`1<bool>> cpuHigh;
    private Lazy`1<Nullable`1<bool>> cpuThreadStarvation;
    [CompilerGeneratedAttribute]
private DateTime <LastTimestamp>k__BackingField;
    internal ReadOnlyCollection`1<SystemUsageLoad> Values { get; }
    internal DateTime LastTimestamp { get; }
    public Nullable`1<bool> IsCpuHigh { get; }
    public Nullable`1<bool> IsCpuThreadStarvation { get; }
    public SystemUsageHistory(ReadOnlyCollection`1<SystemUsageLoad> data, TimeSpan monitoringInterval);
    [CompilerGeneratedAttribute]
internal ReadOnlyCollection`1<SystemUsageLoad> get_Values();
    [CompilerGeneratedAttribute]
internal DateTime get_LastTimestamp();
    public virtual string ToString();
    public void AppendJsonString(StringBuilder stringBuilder);
    public Nullable`1<bool> get_IsCpuHigh();
    public Nullable`1<bool> get_IsCpuThreadStarvation();
    private Nullable`1<bool> GetCpuHigh();
    private Nullable`1<bool> GetCpuThreadStarvation();
    [CompilerGeneratedAttribute]
private string <.ctor>b__7_0();
}
internal class Microsoft.Azure.Documents.Rntbd.SystemUsageLoad : ValueType {
    public DateTime Timestamp;
    public Nullable`1<float> CpuUsage;
    public Nullable`1<long> MemoryAvailable;
    public ThreadInformation ThreadInfo;
    public Nullable`1<int> NumberOfOpenTcpConnections;
    public SystemUsageLoad(DateTime timestamp, ThreadInformation threadInfo, Nullable`1<float> cpuUsage, Nullable`1<long> memoryAvailable, Nullable`1<int> numberOfOpenTcpConnection);
    public void AppendJsonString(StringBuilder stringBuilder);
    public virtual string ToString();
}
internal class Microsoft.Azure.Documents.Rntbd.SystemUsageMonitor : object {
    private SystemUtilizationReaderBase systemUtilizationReader;
    private IDictionary`2<string, SystemUsageRecorder> recorders;
    private Stopwatch watch;
    private int pollDelayInMilliSeconds;
    private CancellationTokenSource cancellation;
    [CompilerGeneratedAttribute]
private Task <periodicTask>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <disposed>k__BackingField;
    private Task periodicTask { get; private set; }
    private bool disposed { get; private set; }
    internal int PollDelayInMs { get; }
    private SystemUsageMonitor(IReadOnlyList`1<SystemUsageRecorder> recorders);
    [CompilerGeneratedAttribute]
private void set_periodicTask(Task value);
    [CompilerGeneratedAttribute]
private Task get_periodicTask();
    [CompilerGeneratedAttribute]
private void set_disposed(bool value);
    [CompilerGeneratedAttribute]
private bool get_disposed();
    internal int get_PollDelayInMs();
    public bool IsRunning();
    internal bool TryGetBackgroundTaskException(AggregateException& aggregateException);
    public static SystemUsageMonitor CreateAndStart(IReadOnlyList`1<SystemUsageRecorder> usageRecorders);
    private int GCD(int timeInterval1, int timeInterval2);
    private void Start();
    public void Stop();
    public SystemUsageRecorder GetRecorder(string recorderKey);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
    private void RefreshLoopAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <Start>b__20_0();
}
internal class Microsoft.Azure.Documents.Rntbd.SystemUsageRecorder : object {
    internal string identifier;
    private int historyLength;
    internal TimeSpan refreshInterval;
    private Queue`1<SystemUsageLoad> historyQueue;
    private TimeSpan nextTimeStamp;
    [CompilerGeneratedAttribute]
private SystemUsageHistory <Data>k__BackingField;
    public SystemUsageHistory Data { get; private set; }
    internal SystemUsageRecorder(string identifier, int historyLength, TimeSpan refreshInterval);
    [CompilerGeneratedAttribute]
private void set_Data(SystemUsageHistory value);
    [CompilerGeneratedAttribute]
public SystemUsageHistory get_Data();
    internal void RecordUsage(SystemUsageLoad systemUsageLoad, Stopwatch watch);
    private ReadOnlyCollection`1<SystemUsageLoad> Collect(SystemUsageLoad loadData);
    internal bool IsEligibleForRecording(Stopwatch watch);
}
internal abstract class Microsoft.Azure.Documents.Rntbd.SystemUtilizationReaderBase : object {
    private float cachedCpuUtilization;
    private long lastCpuUsageReadTimeTicks;
    private static Lazy`1<SystemUtilizationReaderBase> singletonInstance;
    private static SystemUtilizationReaderBase singletonOverride;
    public static SystemUtilizationReaderBase SingletonInstance { get; }
    private static SystemUtilizationReaderBase();
    public static SystemUtilizationReaderBase get_SingletonInstance();
    internal static void ApplySingletonOverride(SystemUtilizationReaderBase readerOverride);
    public float GetSystemWideCpuUsageCached(TimeSpan cacheEvictionTimeInSeconds);
    [SuppressMessageAttribute("Design", "CA1031:Do not catch general exception types")]
public float GetSystemWideCpuUsage();
    public Nullable`1<long> GetSystemWideMemoryAvailabilty();
    private static SystemUtilizationReaderBase Create();
    protected abstract virtual float GetSystemWideCpuUsageCore();
    protected abstract virtual Nullable`1<long> GetSystemWideMemoryAvailabiltyCore();
}
internal class Microsoft.Azure.Documents.Rntbd.ThreadInformation : object {
    private static object lockObject;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <AvailableThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsThreadStarving>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <ThreadWaitIntervalInMs>k__BackingField;
    private static Stopwatch watch;
    private static Task task;
    internal Nullable`1<int> AvailableThreads { get; }
    internal Nullable`1<int> MinThreads { get; }
    internal Nullable`1<int> MaxThreads { get; }
    internal Nullable`1<bool> IsThreadStarving { get; }
    internal Nullable`1<double> ThreadWaitIntervalInMs { get; }
    private ThreadInformation(Nullable`1<int> availableThreads, Nullable`1<int> minThreads, Nullable`1<int> maxThreads, Nullable`1<bool> isThreadStarving, Nullable`1<double> threadWaitIntervalInMs);
    private static ThreadInformation();
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_AvailableThreads();
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_MinThreads();
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_MaxThreads();
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_IsThreadStarving();
    [CompilerGeneratedAttribute]
internal Nullable`1<double> get_ThreadWaitIntervalInMs();
    public static ThreadInformation Get();
    public void AppendJsonString(StringBuilder stringBuilder);
    public virtual string ToString();
}
internal class Microsoft.Azure.Documents.Rntbd.TransportClient : TransportClient {
    private static TransportPerformanceCounters transportPerformanceCounters;
    private TimerPool TimerPool;
    private TimerPool IdleTimerPool;
    private ChannelDictionary channelDictionary;
    private bool disposed;
    private DistributedTracingOptions DistributedTracingOptions;
    private object disableRntbdChannelLock;
    private bool disableRntbdChannel;
    [CompilerGeneratedAttribute]
private Action OnDisableRntbdChannel;
    public TransportClient(Options clientOptions, IChaosInterceptor chaosInterceptor);
    private static TransportClient();
    internal virtual Task`1<StoreResponse> InvokeStoreAsync(Uri physicalAddress, ResourceOperation resourceOperation, DocumentServiceRequest request);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.Rntbd.TransportClient/<InvokeStoreAsync>d__11")]
internal virtual Task`1<StoreResponse> InvokeStoreAsync(TransportAddressUri physicalAddress, ResourceOperation resourceOperation, DocumentServiceRequest request);
    public virtual void Dispose();
    private void ThrowIfDisposed();
    private static void LogClientOptions(Options clientOptions);
    private static void IncrementCounters();
    private static void DecrementCounters();
    internal virtual Task OpenConnectionAsync(Uri physicalAddress);
    [CompilerGeneratedAttribute]
public void add_OnDisableRntbdChannel(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnDisableRntbdChannel(Action value);
    private void RaiseProtocolDowngradeRequest(StoreResponse storeResponse);
    internal static void SetTransportPerformanceCounters(TransportPerformanceCounters transportPerformanceCounters);
    internal static TransportPerformanceCounters GetTransportPerformanceCounters();
    [CompilerGeneratedAttribute]
private void <RaiseProtocolDowngradeRequest>b__21_0();
}
internal static class Microsoft.Azure.Documents.Rntbd.TransportExceptions : object {
    internal static string LocalIpv4Address;
    private static bool AddSourceIpAddressInNetworkExceptionMessagePrivate;
    public static bool AddSourceIpAddressInNetworkExceptionMessage { get; public set; }
    public static bool get_AddSourceIpAddressInNetworkExceptionMessage();
    public static void set_AddSourceIpAddressInNetworkExceptionMessage(bool value);
    internal static GoneException GetGoneException(Uri targetAddress, Guid activityId, Exception inner, TransportRequestStats transportRequestStats);
    internal static RequestTimeoutException GetRequestTimeoutException(Uri targetAddress, Guid activityId, Exception inner, TransportRequestStats transportRequestStats);
    internal static ServiceUnavailableException GetServiceUnavailableException(Uri targetAddress, Guid activityId, Exception inner, TransportRequestStats transportRequestStats);
    internal static InternalServerErrorException GetInternalServerErrorException(Uri targetAddress, Guid activityId, Exception inner);
    internal static InternalServerErrorException GetInternalServerErrorException(Uri targetAddress, string exceptionMessage);
}
internal static class Microsoft.Azure.Documents.Rntbd.TransportSerialization : object {
    internal static Char[] UrlTrim;
    private static TransportSerialization();
    internal static SerializedRequest BuildRequestForProxy(DocumentServiceRequest request, ResourceOperation resourceOperation, Guid activityId, BufferProvider bufferProvider, string globalDatabaseAccountName, Int32& headerSize, Nullable`1& bodySize);
    internal static SerializedRequest BuildRequest(DocumentServiceRequest request, string replicaPath, ResourceOperation resourceOperation, Guid activityId, BufferProvider bufferProvider, string transportRequestIDOverride, Int32& headerSize, Nullable`1& bodySize);
    private static SerializedRequest BuildRequestCore(DocumentServiceRequest request, Request& rntbdRequest, string replicaPathForDiagnostics, ResourceOperation resourceOperation, Guid activityId, BufferProvider bufferProvider, Int32& headerSize, Nullable`1& bodySize);
    internal static Byte[] BuildContextRequest(Guid activityId, UserAgentContainer userAgent, CallerId callerId, bool enableChannelMultiplexing);
    internal static StoreResponse MakeStoreResponse(StatusCodes status, Guid activityId, Stream body, string serverVersion, BytesDeserializer& rntbdHeaderReader);
    internal static RntbdHeader DecodeRntbdHeader(Byte[] header);
    internal static RntbdOperationType GetRntbdOperationType(OperationType operationType);
    internal static RntbdResourceType GetRntbdResourceType(ResourceType resourceType);
    private static void AddMatchHeader(RequestNameValueCollection requestHeaders, RntbdOperationType operationType, Request rntbdRequest);
    private static void AddIfModifiedSinceHeader(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddA_IMHeader(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddDateHeader(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddContinuation(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddResourceIdOrPathHeaders(DocumentServiceRequest request, Request rntbdRequest);
    private static void SetResourceIdHeadersFromUri(DocumentServiceRequest request, Request rntbdRequest);
    private static void SetResourceIdHeadersFromDocumentServiceRequest(DocumentServiceRequest request, Request rntbdRequest);
    private static void AddBinaryIdIfPresent(DocumentServiceRequest request, Request rntbdRequest);
    private static void AddReturnPreferenceIfPresent(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddEffectivePartitionKeyIfPresent(DocumentServiceRequest request, Request rntbdRequest);
    private static bool TryGetHeaderValueString(DocumentServiceRequest request, string headerName, String& headerValue);
    private static void AddMergeStaticIdIfPresent(DocumentServiceRequest request, Request rntbdRequest);
    private static void AddEntityId(DocumentServiceRequest request, Request rntbdRequest);
    private static void AddIndexingDirectiveHeader(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddMigrateCollectionDirectiveHeader(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddConsistencyLevelHeader(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddIsThroughputCapRequest(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddIsFanout(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddAllowScanOnQuery(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddEnableLowPrecisionOrderBy(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddEmitVerboseTracesInQuery(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddCanCharge(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddCanThrottle(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddProfileRequest(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddPageSize(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddEnableLogging(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddSupportSpatialLegacyCoordinates(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddUsePolygonsSmallerThanAHemisphere(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddPopulateQuotaInfo(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddPopulateResourceCount(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddPopulatePartitionStatistics(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddDisableRUPerMinuteUsage(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddPopulateQueryMetrics(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddPopulateQueryMetricsIndexUtilization(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddPopulateIndexMetricsV2(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddOptimisticDirectExecute(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddQueryForceScan(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddPopulateCollectionThroughputInfo(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddShareThroughput(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddIsReadOnlyScript(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddCanOfferReplaceComplete(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddIgnoreSystemLoweringMaxThroughput(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddUpdateMaxthroughputEverProvisioned(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddGetAllPartitionKeyStatistics(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddResponseContinuationTokenLimitInKb(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddRemoteStorageType(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddCollectionChildResourceNameLimitInBytes(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddCollectionChildResourceContentLengthLimitInKB(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddUniqueIndexNameEncodingMode(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddUniqueIndexReIndexingState(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddIsInternalServerlessRequest(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddCorrelatedActivityId(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddCosmosGatewayTransactionId(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddCollectionRemoteStorageSecurityIdentifier(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddIsUserRequest(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddPreserveFullContent(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddForceSideBySideIndexMigration(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddPopulateUniqueIndexReIndexProgress(object headerObjectValue, Request rntbdRequest);
    private static void AddIsRUPerGBEnforcementRequest(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddIsOfferStorageRefreshRequest(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddIsMigrateOfferToManualThroughputRequest(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddIsMigrateOfferToAutopilotRequest(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddTruncateMergeLogRequest(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddEnumerationDirection(DocumentServiceRequest request, RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddStartAndEndKeys(DocumentServiceRequest request, RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddStartAndEndKeysFromHeaders(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void SetBytesValue(DocumentServiceRequest request, string headerName, RntbdToken token);
    private static void AddContentSerializationFormat(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    [SuppressMessageAttribute("Globalization", "CA1305:Specify IFormatProvider")]
private static void AddSupportedSerializationFormats(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void FillTokenFromHeader(DocumentServiceRequest request, string headerName, string headerStringValue, RntbdToken token, Request rntbdRequest);
    private static void AddExcludeSystemProperties(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddFanoutOperationStateHeader(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddResourceTypes(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddSystemDocumentTypeHeader(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddTransactionMetaData(DocumentServiceRequest request, Request rntbdRequest);
    private static void AddTransactionCompletionFlag(DocumentServiceRequest request, Request rntbdRequest);
    private static void AddRetriableWriteRequestMetadata(DocumentServiceRequest request, Request rntbdRequest);
    private static void AddUseSystemBudget(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddRequestedCollectionType(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddUpdateOfferStateToPending(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddUpdateOfferStateToRestorePending(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddMasterResourcesDeletionPending(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddOfferReplaceRURedistribution(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddIsMaterializedViewSourceSchemaReplaceBatchRequest(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddIsCassandraAlterTypeRequest(DocumentServiceRequest request, Request rntbdRequest);
    private static void AddHighPriorityForcedBackup(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddEnableConflictResolutionPolicyUpdate(RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddPriorityLevelHeader(DocumentServiceRequest request, string headerName, string headerStringValue, RequestNameValueCollection requestHeaders, Request rntbdRequest);
    private static void AddAllowDocumentReadsInOfflineRegion(RequestNameValueCollection requestHeaders, Request rntbdRequest);
}
internal class Microsoft.Azure.Documents.Rntbd.UnsupportedSystemUtilizationReader : SystemUtilizationReaderBase {
    protected virtual float GetSystemWideCpuUsageCore();
    protected virtual Nullable`1<long> GetSystemWideMemoryAvailabiltyCore();
}
internal class Microsoft.Azure.Documents.Rntbd.UserPortPool : object {
    private int portReuseThreshold;
    private int candidatePortCount;
    private Pool ipv4Pool;
    private Pool ipv6Pool;
    public UserPortPool(int portReuseThreshold, int candidatePortCount);
    public UInt16[] GetCandidatePorts(AddressFamily addressFamily);
    public void AddReference(AddressFamily addressFamily, ushort port);
    public void RemoveReference(AddressFamily addressFamily, ushort port);
    public void MarkUnusable(AddressFamily addressFamily, ushort port);
    public string DumpStatus();
    private string DumpPoolStatus(Pool pool);
    private Pool GetPool(AddressFamily af);
    private static UInt16[] GetRandomSample(Dictionary`2<ushort, PortState> pool, int candidatePortCount, Random rng);
    private static UInt16[] ReservoirSample(Dictionary`2<ushort, PortState> pool, int candidatePortCount, Random rng);
    private static void Shuffle(Random rng, UInt16[] sample);
}
internal class Microsoft.Azure.Documents.Rntbd.WindowsSystemUtilizationReader : SystemUtilizationReaderBase {
    private long lastIdleTime;
    private long lastKernelTime;
    private long lastUserTime;
    protected virtual float GetSystemWideCpuUsageCore();
    protected virtual Nullable`1<long> GetSystemWideMemoryAvailabiltyCore();
}
internal static class Microsoft.Azure.Documents.RntbdConstants : object {
    public static UInt32 CurrentProtocolVersion;
}
internal class Microsoft.Azure.Documents.RntbdToken : object {
    private ushort identifier;
    private RntbdTokenTypes type;
    private bool isRequired;
    public bool isPresent;
    public RntbdTokenValue value;
    public RntbdToken(bool isRequired, RntbdTokenTypes type, ushort identifier);
    public RntbdTokenTypes GetTokenType();
    public ushort GetTokenIdentifier();
    public bool IsRequired();
    public void SerializeToBinaryWriter(BytesSerializer& writer, Int32& written);
}
internal abstract class Microsoft.Azure.Documents.RntbdTokenStream`1 : object {
    internal RntbdToken[] tokens;
    private ArrayPool`1<byte> arrayPool;
    private List`1<Byte[]> borrowedBytes;
    public int RequiredTokenCount { get; }
    public abstract virtual int get_RequiredTokenCount();
    public Byte[] GetBytes(int length);
    public void Reset();
    public int CalculateLength();
    public void SerializeToBinaryWriter(BytesSerializer& writer, Int32& tokensLength);
    public void ParseFrom(BytesDeserializer& reader);
    private INameValueCollection GetValidationFailureHeader();
}
internal enum Microsoft.Azure.Documents.RntbdTokenTypes : Enum {
    public byte value__;
    public static RntbdTokenTypes Byte;
    public static RntbdTokenTypes UShort;
    public static RntbdTokenTypes ULong;
    public static RntbdTokenTypes Long;
    public static RntbdTokenTypes ULongLong;
    public static RntbdTokenTypes LongLong;
    public static RntbdTokenTypes Guid;
    public static RntbdTokenTypes SmallString;
    public static RntbdTokenTypes String;
    public static RntbdTokenTypes ULongString;
    public static RntbdTokenTypes SmallBytes;
    public static RntbdTokenTypes Bytes;
    public static RntbdTokenTypes ULongBytes;
    public static RntbdTokenTypes Float;
    public static RntbdTokenTypes Double;
    public static RntbdTokenTypes Invalid;
}
internal class Microsoft.Azure.Documents.RntbdTokenValue : ValueType {
    public byte valueByte;
    public ushort valueUShort;
    public UInt32 valueULong;
    public ulong valueULongLong;
    public int valueLong;
    public float valueFloat;
    public double valueDouble;
    public long valueLongLong;
    public Guid valueGuid;
    public ReadOnlyMemory`1<byte> valueBytes;
}
internal class Microsoft.Azure.Documents.Routing.BoolPartitionKeyComponent : object {
    private bool value;
    public BoolPartitionKeyComponent(bool value);
    public sealed virtual int CompareTo(IPartitionKeyComponent other);
    public sealed virtual int GetTypeOrdinal();
    public virtual int GetHashCode();
    public sealed virtual void JsonEncode(JsonWriter writer);
    public sealed virtual object ToObject();
    public sealed virtual IPartitionKeyComponent Truncate();
    public sealed virtual void WriteForHashing(BinaryWriter binaryWriter);
    public sealed virtual void WriteForHashingV2(BinaryWriter binaryWriter);
    public sealed virtual void WriteForBinaryEncoding(BinaryWriter binaryWriter);
}
internal class Microsoft.Azure.Documents.Routing.InfinityPartitionKeyComponent : object {
    public sealed virtual int CompareTo(IPartitionKeyComponent other);
    public sealed virtual int GetTypeOrdinal();
    public sealed virtual IPartitionKeyComponent Truncate();
    public sealed virtual void WriteForHashing(BinaryWriter writer);
    public sealed virtual void WriteForHashingV2(BinaryWriter writer);
    public virtual int GetHashCode();
    public sealed virtual void JsonEncode(JsonWriter writer);
    public sealed virtual object ToObject();
    public sealed virtual void WriteForBinaryEncoding(BinaryWriter binaryWriter);
}
internal interface Microsoft.Azure.Documents.Routing.IPartitionKeyComponent {
    public abstract virtual int CompareTo(IPartitionKeyComponent other);
    public abstract virtual int GetTypeOrdinal();
    public abstract virtual void JsonEncode(JsonWriter writer);
    public abstract virtual object ToObject();
    public abstract virtual void WriteForHashing(BinaryWriter binaryWriter);
    public abstract virtual void WriteForHashingV2(BinaryWriter binaryWriter);
    public abstract virtual void WriteForBinaryEncoding(BinaryWriter binaryWriter);
    public abstract virtual IPartitionKeyComponent Truncate();
}
internal class Microsoft.Azure.Documents.Routing.MaxNumber : object {
    public static MaxNumber Value;
    private static MaxNumber();
}
internal class Microsoft.Azure.Documents.Routing.MaxNumberPartitionKeyComponent : object {
    public static MaxNumberPartitionKeyComponent Value;
    private static MaxNumberPartitionKeyComponent();
    public sealed virtual int CompareTo(IPartitionKeyComponent other);
    public sealed virtual int GetTypeOrdinal();
    public virtual int GetHashCode();
    public sealed virtual IPartitionKeyComponent Truncate();
    public sealed virtual void WriteForHashing(BinaryWriter writer);
    public sealed virtual void WriteForHashingV2(BinaryWriter writer);
    public sealed virtual void JsonEncode(JsonWriter writer);
    public sealed virtual object ToObject();
    public sealed virtual void WriteForBinaryEncoding(BinaryWriter binaryWriter);
}
internal class Microsoft.Azure.Documents.Routing.MaxString : object {
    public static MaxString Value;
    private static MaxString();
}
internal class Microsoft.Azure.Documents.Routing.MaxStringPartitionKeyComponent : object {
    public static MaxStringPartitionKeyComponent Value;
    private static MaxStringPartitionKeyComponent();
    public sealed virtual int CompareTo(IPartitionKeyComponent other);
    public sealed virtual int GetTypeOrdinal();
    public virtual int GetHashCode();
    public sealed virtual IPartitionKeyComponent Truncate();
    public sealed virtual void WriteForHashing(BinaryWriter writer);
    public sealed virtual void WriteForHashingV2(BinaryWriter writer);
    public sealed virtual void JsonEncode(JsonWriter writer);
    public sealed virtual object ToObject();
    public sealed virtual void WriteForBinaryEncoding(BinaryWriter binaryWriter);
}
internal class Microsoft.Azure.Documents.Routing.MinNumber : object {
    public static MinNumber Value;
    private static MinNumber();
}
internal class Microsoft.Azure.Documents.Routing.MinNumberPartitionKeyComponent : object {
    public static MinNumberPartitionKeyComponent Value;
    private static MinNumberPartitionKeyComponent();
    public sealed virtual int CompareTo(IPartitionKeyComponent other);
    public sealed virtual int GetTypeOrdinal();
    public virtual int GetHashCode();
    public sealed virtual IPartitionKeyComponent Truncate();
    public sealed virtual void WriteForHashing(BinaryWriter writer);
    public sealed virtual void WriteForHashingV2(BinaryWriter writer);
    public sealed virtual void JsonEncode(JsonWriter writer);
    public sealed virtual object ToObject();
    public sealed virtual void WriteForBinaryEncoding(BinaryWriter binaryWriter);
}
internal class Microsoft.Azure.Documents.Routing.MinString : object {
    public static MinString Value;
    private static MinString();
}
internal class Microsoft.Azure.Documents.Routing.MinStringPartitionKeyComponent : object {
    public static MinStringPartitionKeyComponent Value;
    private static MinStringPartitionKeyComponent();
    public sealed virtual int CompareTo(IPartitionKeyComponent other);
    public sealed virtual int GetTypeOrdinal();
    public virtual int GetHashCode();
    public sealed virtual IPartitionKeyComponent Truncate();
    public sealed virtual void WriteForHashing(BinaryWriter writer);
    public sealed virtual void WriteForHashingV2(BinaryWriter writer);
    public sealed virtual void JsonEncode(JsonWriter writer);
    public sealed virtual object ToObject();
    public sealed virtual void WriteForBinaryEncoding(BinaryWriter binaryWriter);
}
internal static class Microsoft.Azure.Documents.Routing.MurmurHash3 : object {
    public static UInt32 Hash32(Byte[] bytes, long length, UInt32 seed);
    public static ulong Hash64(Byte[] bytes, int length, ulong seed);
    public static UInt128 Hash128(Byte[] bytes, int length, UInt128 seed);
    public static ulong Reverse(ulong value);
    private static UInt32 RotateLeft32(UInt32 n, int numBits);
    private static ulong RotateLeft64(ulong n, int numBits);
}
internal class Microsoft.Azure.Documents.Routing.NullPartitionKeyComponent : object {
    public static NullPartitionKeyComponent Value;
    private static NullPartitionKeyComponent();
    public sealed virtual int CompareTo(IPartitionKeyComponent other);
    public sealed virtual int GetTypeOrdinal();
    public sealed virtual IPartitionKeyComponent Truncate();
    public sealed virtual void WriteForHashing(BinaryWriter writer);
    public sealed virtual void WriteForHashingV2(BinaryWriter writer);
    public sealed virtual void JsonEncode(JsonWriter writer);
    public sealed virtual object ToObject();
    public sealed virtual void WriteForBinaryEncoding(BinaryWriter binaryWriter);
}
internal class Microsoft.Azure.Documents.Routing.NumberPartitionKeyComponent : object {
    private double value;
    public static NumberPartitionKeyComponent Zero;
    public double Value { get; }
    public NumberPartitionKeyComponent(double value);
    private static NumberPartitionKeyComponent();
    public double get_Value();
    public sealed virtual int CompareTo(IPartitionKeyComponent other);
    public sealed virtual int GetTypeOrdinal();
    public virtual int GetHashCode();
    public sealed virtual void JsonEncode(JsonWriter writer);
    public sealed virtual object ToObject();
    public sealed virtual IPartitionKeyComponent Truncate();
    public sealed virtual void WriteForHashing(BinaryWriter writer);
    public sealed virtual void WriteForHashingV2(BinaryWriter writer);
    public sealed virtual void WriteForBinaryEncoding(BinaryWriter binaryWriter);
    public static IPartitionKeyComponent FromHexEncodedBinaryString(Byte[] byteString, Int32& byteStringOffset);
    private static ulong EncodeDoubleAsUInt64(double value);
    private static double DecodeDoubleFromUInt64(ulong value);
}
internal class Microsoft.Azure.Documents.Routing.PartitionIsMigratingException : DocumentClientException {
    public PartitionIsMigratingException(string message);
    public PartitionIsMigratingException(string message, HttpResponseHeaders headers, Uri requestUri);
    public PartitionIsMigratingException(string message, Exception innerException);
    public PartitionIsMigratingException(Exception innerException);
    public PartitionIsMigratingException(string message, INameValueCollection headers, Uri requestUri);
    public PartitionIsMigratingException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri);
    private PartitionIsMigratingException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
    private void SetSubstatus();
}
internal enum Microsoft.Azure.Documents.Routing.PartitionKeyComponentType : Enum {
    public int value__;
    public static PartitionKeyComponentType Undefined;
    public static PartitionKeyComponentType Null;
    public static PartitionKeyComponentType False;
    public static PartitionKeyComponentType True;
    public static PartitionKeyComponentType MinNumber;
    public static PartitionKeyComponentType Number;
    public static PartitionKeyComponentType MaxNumber;
    public static PartitionKeyComponentType MinString;
    public static PartitionKeyComponentType String;
    public static PartitionKeyComponentType MaxString;
    public static PartitionKeyComponentType Int64;
    public static PartitionKeyComponentType Int32;
    public static PartitionKeyComponentType Int16;
    public static PartitionKeyComponentType Int8;
    public static PartitionKeyComponentType Uint64;
    public static PartitionKeyComponentType Uint32;
    public static PartitionKeyComponentType Uint16;
    public static PartitionKeyComponentType Uint8;
    public static PartitionKeyComponentType Binary;
    public static PartitionKeyComponentType Guid;
    public static PartitionKeyComponentType Float;
    public static PartitionKeyComponentType Infinity;
}
[JsonConverterAttribute("Microsoft.Azure.Documents.Routing.PartitionKeyInternalJsonConverter")]
[SuppressMessageAttribute("", "AvoidMultiLineComments")]
internal class Microsoft.Azure.Documents.Routing.PartitionKeyInternal : object {
    private IReadOnlyList`1<IPartitionKeyComponent> components;
    private static PartitionKeyInternal NonePartitionKey;
    private static PartitionKeyInternal EmptyPartitionKey;
    private static PartitionKeyInternal InfinityPartitionKey;
    private static PartitionKeyInternal UndefinedPartitionKey;
    private static int MaxPartitionKeyBinarySize;
    private static Int128 MaxHashV2Value;
    public static string MinimumInclusiveEffectivePartitionKey;
    public static string MaximumExclusiveEffectivePartitionKey;
    private static int HashV2EPKLength;
    private static JsonSerializer FromJsonStringSerializer;
    private static JsonSerializer ToJsonStringSerializer;
    public static PartitionKeyInternal InclusiveMinimum { get; }
    public static PartitionKeyInternal ExclusiveMaximum { get; }
    public static PartitionKeyInternal Empty { get; }
    public static PartitionKeyInternal None { get; }
    public static PartitionKeyInternal Undefined { get; }
    public IReadOnlyList`1<IPartitionKeyComponent> Components { get; }
    public PartitionKeyInternal(IReadOnlyList`1<IPartitionKeyComponent> values);
    private static PartitionKeyInternal();
    public static PartitionKeyInternal get_InclusiveMinimum();
    public static PartitionKeyInternal get_ExclusiveMaximum();
    public static PartitionKeyInternal get_Empty();
    public static PartitionKeyInternal get_None();
    public static PartitionKeyInternal get_Undefined();
    public IReadOnlyList`1<IPartitionKeyComponent> get_Components();
    public static PartitionKeyInternal FromObjectArray(IEnumerable`1<object> values, bool strict);
    public static PartitionKeyInternal FromObject(object value, bool strict);
    public Object[] ToObjectArray();
    public static PartitionKeyInternal FromJsonString(string partitionKey);
    public string ToJsonString();
    public bool Contains(PartitionKeyInternal nestedPartitionKey);
    public static PartitionKeyInternal Max(PartitionKeyInternal key1, PartitionKeyInternal key2);
    public static PartitionKeyInternal Min(PartitionKeyInternal key1, PartitionKeyInternal key2);
    public static string GetMinInclusiveEffectivePartitionKey(int partitionIndex, int partitionCount, PartitionKeyDefinition partitionKeyDefinition, bool useHashV2asDefault);
    public static string GetMaxExclusiveEffectivePartitionKey(int partitionIndex, int partitionCount, PartitionKeyDefinition partitionKeyDefinition, bool useHashV2asDefault);
    public sealed virtual int CompareTo(PartitionKeyInternal other);
    public sealed virtual bool Equals(PartitionKeyInternal other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual object Clone();
    private static IPartitionKeyComponent FromObjectToPartitionKeyComponent(object value, bool strict);
    private static string ToHexEncodedBinaryString(IReadOnlyList`1<IPartitionKeyComponent> components);
    [ObsoleteAttribute]
internal static PartitionKeyInternal FromHexEncodedBinaryString(string hexEncodedBinaryString);
    public string GetEffectivePartitionKeyString(PartitionKeyDefinition partitionKeyDefinition, bool strict);
    private string GetEffectivePartitionKeyForHashPartitioning();
    private string GetEffectivePartitionKeyForMultiHashPartitioningV2();
    private string GetEffectivePartitionKeyForHashPartitioningV2();
    private static Byte[] HexStringToByteArray(string hex);
    public static string GetMiddleRangeEffectivePartitionKey(string minInclusive, string maxExclusive, PartitionKeyDefinition partitionKeyDefinition);
    private static string GetMiddleRangeEffectivePartitionKeyForHash(string minInclusive, string maxExclusive, PartitionKeyDefinition partitionKeyDefinition);
    private static IReadOnlyList`1<Int128> GetHashValueFromEPKForMultiHash(string epkValueString, PartitionKeyDefinition partitionKeyDefinition);
    private static string GetMiddleRangeEffectivePartitionKeyForMultiHash(string minInclusive, string maxExclusive, PartitionKeyDefinition partitionKeyDefinition);
    public static String[] GetNEqualRangeEffectivePartitionKeys(string minInclusive, string maxExclusive, PartitionKeyDefinition partitionKeyDefinition, int numberOfSubRanges);
    private static double GetWidthForHashPartitioningScheme(string minInclusive, string maxExclusive, PartitionKeyDefinition partitionKeyDefinition);
    private static double GetWidthForRangePartitioningScheme(string minInclusive, string maxExclusive, PartitionKeyDefinition partitionKeyDefinition);
    private static double GetWidthForMultiHashPartitioningScheme(string minInclusive, string maxExclusive, PartitionKeyDefinition partitionKeyDefinition);
    public static double GetWidth(string minInclusive, string maxExclusive, PartitionKeyDefinition partitionKeyDefinition);
    public Range`1<string> GetEPKRangeForPrefixPartitionKey(PartitionKeyDefinition partitionKeyDefinition);
    private static bool IsPartiallySpecifiedPartitionKeyRange(PartitionKeyDefinition partitionKeyDefinition, Range`1<PartitionKeyInternal> internalRange);
    public static Range`1<string> GetEffectivePartitionKeyRange(PartitionKeyDefinition partitionKeyDefinition, Range`1<PartitionKeyInternal> range);
}
internal class Microsoft.Azure.Documents.Routing.PartitionKeyInternalJsonConverter : JsonConverter {
    private static string Type;
    private static string MinNumber;
    private static string MaxNumber;
    private static string MinString;
    private static string MaxString;
    private static string Infinity;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public static void JsonEncode(MinNumberPartitionKeyComponent component, JsonWriter writer);
    public static void JsonEncode(MaxNumberPartitionKeyComponent component, JsonWriter writer);
    public static void JsonEncode(MinStringPartitionKeyComponent component, JsonWriter writer);
    public static void JsonEncode(MaxStringPartitionKeyComponent component, JsonWriter writer);
    private static void JsonEncodeLimit(JsonWriter writer, string value);
}
internal class Microsoft.Azure.Documents.Routing.PartitionKeyRangeGoneException : DocumentClientException {
    public PartitionKeyRangeGoneException(string message);
    public PartitionKeyRangeGoneException(string message, HttpResponseHeaders headers, Uri requestUri);
    public PartitionKeyRangeGoneException(string message, Exception innerException);
    public PartitionKeyRangeGoneException(Exception innerException);
    public PartitionKeyRangeGoneException(string message, INameValueCollection headers, Uri requestUri);
    public PartitionKeyRangeGoneException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri);
    private PartitionKeyRangeGoneException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
    private void SetSubstatus();
}
internal class Microsoft.Azure.Documents.Routing.PartitionKeyRangeIsSplittingException : DocumentClientException {
    public PartitionKeyRangeIsSplittingException(string message);
    public PartitionKeyRangeIsSplittingException(string message, HttpResponseHeaders headers, Uri requestUri);
    public PartitionKeyRangeIsSplittingException(string message, Exception innerException);
    public PartitionKeyRangeIsSplittingException(Exception innerException);
    public PartitionKeyRangeIsSplittingException(string message, INameValueCollection headers, Uri requestUri);
    public PartitionKeyRangeIsSplittingException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri);
    private PartitionKeyRangeIsSplittingException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
    private void SetSubstatus();
}
[JsonObjectAttribute]
internal class Microsoft.Azure.Documents.Routing.Range`1 : object {
    public static IComparer`1<T> TComparer;
    [CompilerGeneratedAttribute]
private T <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMinInclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMaxInclusive>k__BackingField;
    [JsonPropertyAttribute("min")]
public T Min { get; private set; }
    [JsonPropertyAttribute("max")]
public T Max { get; private set; }
    [JsonPropertyAttribute("isMinInclusive")]
public bool IsMinInclusive { get; private set; }
    [JsonPropertyAttribute("isMaxInclusive")]
public bool IsMaxInclusive { get; private set; }
    public bool IsSingleValue { get; }
    public bool IsEmpty { get; }
    [JsonConstructorAttribute]
public Range`1(T min, T max, bool isMinInclusive, bool isMaxInclusive);
    private static Range`1();
    public static Range`1<T> GetPointRange(T value);
    [CompilerGeneratedAttribute]
public T get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(T value);
    [CompilerGeneratedAttribute]
public T get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(T value);
    [CompilerGeneratedAttribute]
public bool get_IsMinInclusive();
    [CompilerGeneratedAttribute]
private void set_IsMinInclusive(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMaxInclusive();
    [CompilerGeneratedAttribute]
private void set_IsMaxInclusive(bool value);
    public bool get_IsSingleValue();
    public bool get_IsEmpty();
    public static Range`1<T> GetEmptyRange(T value);
    public bool Contains(T value);
    public static bool CheckOverlapping(Range`1<T> range1, Range`1<T> range2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(Range`1<T> other);
    public virtual string ToString();
}
internal class Microsoft.Azure.Documents.Routing.StringPartitionKeyComponent : object {
    public static int MaxStringChars;
    public static int MaxStringBytesToAppend;
    private string value;
    private Byte[] utf8Value;
    public StringPartitionKeyComponent(string value);
    public sealed virtual void JsonEncode(JsonWriter writer);
    public sealed virtual object ToObject();
    public sealed virtual int CompareTo(IPartitionKeyComponent other);
    public sealed virtual int GetTypeOrdinal();
    public virtual int GetHashCode();
    public sealed virtual IPartitionKeyComponent Truncate();
    public sealed virtual void WriteForHashing(BinaryWriter writer);
    public sealed virtual void WriteForHashingV2(BinaryWriter writer);
    public sealed virtual void WriteForBinaryEncoding(BinaryWriter binaryWriter);
    public static IPartitionKeyComponent FromHexEncodedBinaryString(Byte[] byteString, Int32& offset);
}
internal class Microsoft.Azure.Documents.Routing.UndefinedPartitionKeyComponent : object {
    public static UndefinedPartitionKeyComponent Value;
    private static UndefinedPartitionKeyComponent();
    public sealed virtual int CompareTo(IPartitionKeyComponent other);
    public sealed virtual int GetTypeOrdinal();
    public double GetHashValue();
    public virtual int GetHashCode();
    public sealed virtual void JsonEncode(JsonWriter writer);
    public sealed virtual object ToObject();
    public sealed virtual IPartitionKeyComponent Truncate();
    public sealed virtual void WriteForHashing(BinaryWriter writer);
    public sealed virtual void WriteForHashingV2(BinaryWriter writer);
    public sealed virtual void WriteForBinaryEncoding(BinaryWriter binaryWriter);
}
internal static class Microsoft.Azure.Documents.RuntimeConstants : object {
    public static string IncludeExceptionDetails;
}
internal class Microsoft.Azure.Documents.Schema : Resource {
    public string ResourceLink { get; }
    public string get_ResourceLink();
    internal static Schema FromObject(object schema);
    private object GetProperty(string propertyName, Type returnType);
    private object SetProperty(string propertyName, object value);
    private T AsType();
}
internal enum Microsoft.Azure.Documents.SchemaBuilderMode : Enum {
    public int value__;
    public static SchemaBuilderMode Lazy;
    public static SchemaBuilderMode None;
}
internal class Microsoft.Azure.Documents.SchemaDiscoveryPolicy : JsonSerializable {
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public SchemaBuilderMode SchemaBuilderMode { get; public set; }
    public SchemaBuilderMode get_SchemaBuilderMode();
    public void set_SchemaBuilderMode(SchemaBuilderMode value);
    public sealed virtual object Clone();
    internal virtual void Validate();
}
[FlagsAttribute]
internal enum Microsoft.Azure.Documents.SDKSupportedCapabilities : Enum {
    public ulong value__;
    public static SDKSupportedCapabilities None;
    public static SDKSupportedCapabilities PartitionMerge;
    public static SDKSupportedCapabilities ChangeFeedWithStartTimePostMerge;
}
internal static class Microsoft.Azure.Documents.SDKSupportedCapabilitiesHelpers : object {
    private static ulong sdkSupportedCapabilities;
    private static SDKSupportedCapabilitiesHelpers();
    internal static ulong GetSDKSupportedCapabilities();
}
internal class Microsoft.Azure.Documents.SendingRequestEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private HttpRequestMessage <HttpRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentServiceRequest <DocumentServiceRequest>k__BackingField;
    public HttpRequestMessage HttpRequest { get; }
    public DocumentServiceRequest DocumentServiceRequest { get; }
    public SendingRequestEventArgs(DocumentServiceRequest request);
    public SendingRequestEventArgs(HttpRequestMessage request);
    [CompilerGeneratedAttribute]
public HttpRequestMessage get_HttpRequest();
    [CompilerGeneratedAttribute]
public DocumentServiceRequest get_DocumentServiceRequest();
    public bool IsHttpRequest();
}
internal class Microsoft.Azure.Documents.SerializableNameValueCollection : JsonSerializable {
    private Lazy`1<NameValueCollection> lazyCollection;
    [JsonIgnoreAttribute]
public NameValueCollection Collection { get; }
    public SerializableNameValueCollection(NameValueCollection collection);
    public NameValueCollection get_Collection();
    public static string SaveToString(SerializableNameValueCollection nameValueCollection);
    public static SerializableNameValueCollection LoadFromString(string value);
    internal virtual void OnSave();
    private NameValueCollection Init();
    public virtual bool Equals(object obj);
    public bool Equals(SerializableNameValueCollection collection);
    private bool IsEqual(SerializableNameValueCollection serializableNameValueCollection);
    public virtual int GetHashCode();
}
internal enum Microsoft.Azure.Documents.SerializationFormattingPolicy : Enum {
    public int value__;
    public static SerializationFormattingPolicy None;
    public static SerializationFormattingPolicy Indented;
}
internal class Microsoft.Azure.Documents.ServerStoreModel : object {
    private StoreClient storeClient;
    private EventHandler`1<SendingRequestEventArgs> sendingRequest;
    private EventHandler`1<ReceivedResponseEventArgs> receivedResponse;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <DefaultReplicaIndex>k__BackingField;
    public Nullable`1<UInt32> DefaultReplicaIndex { get; public set; }
    public string LastReadAddress { get; public set; }
    public bool ForceAddressRefresh { get; public set; }
    public ServerStoreModel(StoreClient storeClient);
    public ServerStoreModel(StoreClient storeClient, EventHandler`1<SendingRequestEventArgs> sendingRequest, EventHandler`1<ReceivedResponseEventArgs> receivedResponse);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_DefaultReplicaIndex();
    [CompilerGeneratedAttribute]
public void set_DefaultReplicaIndex(Nullable`1<UInt32> value);
    public string get_LastReadAddress();
    public void set_LastReadAddress(string value);
    public bool get_ForceAddressRefresh();
    public void set_ForceAddressRefresh(bool value);
    public sealed virtual Task`1<DocumentServiceResponse> ProcessMessageAsync(DocumentServiceRequest request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ServerStoreModel/<OpenConnectionsToAllReplicasAsync>d__16")]
public sealed virtual Task OpenConnectionsToAllReplicasAsync(string databaseName, string containerLinkUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ServerStoreModel/<ProcessMessageWithReceivedResponseDelegateAsync>d__17")]
private Task`1<DocumentServiceResponse> ProcessMessageWithReceivedResponseDelegateAsync(DocumentServiceRequest request, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
internal class Microsoft.Azure.Documents.ServiceIdentity : object {
    [CompilerGeneratedAttribute]
private string <FederationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMasterService>k__BackingField;
    [JsonPropertyAttribute]
public string FederationId { get; private set; }
    [JsonPropertyAttribute]
public Uri ServiceName { get; private set; }
    [JsonPropertyAttribute]
public bool IsMasterService { get; private set; }
    public string ApplicationName { get; }
    public ServiceIdentity(string federationId, Uri serviceName, bool isMasterService);
    [CompilerGeneratedAttribute]
public string get_FederationId();
    [CompilerGeneratedAttribute]
private void set_FederationId(string value);
    [CompilerGeneratedAttribute]
public Uri get_ServiceName();
    [CompilerGeneratedAttribute]
private void set_ServiceName(Uri value);
    [CompilerGeneratedAttribute]
public bool get_IsMasterService();
    [CompilerGeneratedAttribute]
private void set_IsMasterService(bool value);
    public string get_ApplicationName();
    public sealed virtual string GetFederationId();
    public sealed virtual Uri GetServiceUri();
    public sealed virtual long GetPartitionKey();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class Microsoft.Azure.Documents.ServiceInteropWrapper : object {
    internal static Lazy`1<bool> AssembliesExist;
    internal static bool Is64BitProcess;
    internal static bool IsWindowsOSPlatform;
    private static string DisableSkipInterop;
    private static string AllowGatewayToParseQueries;
    private static ServiceInteropWrapper();
    internal static bool UseServiceInterop(QueryPlanGenerationMode queryPlanRetrievalMode);
    internal static bool CheckIfAssembliesExist(String& validationMessage);
    [SuppressUnmanagedCodeSecurityAttribute]
public static UInt32 GetPartitionKeyRangesFromQuery(IntPtr serviceProvider, string query, bool requireFormattableOrderByQuery, bool isContinuationExpected, bool allowNonValueAggregateQuery, bool hasLogicalPartitionKey, String[] partitionKeyDefinitionPathTokens, UInt32[] partitionKeyDefinitionPathTokenLengths, UInt32 partitionKeyDefinitionPathCount, PartitionKind partitionKind, IntPtr serializedQueryExecutionInfoBuffer, UInt32 serializedQueryExecutionInfoBufferLength, UInt32& serializedQueryExecutionInfoResultLength);
    [SuppressUnmanagedCodeSecurityAttribute]
public static UInt32 GetPartitionKeyRangesFromQuery2(IntPtr serviceProvider, string query, bool requireFormattableOrderByQuery, bool isContinuationExpected, bool allowNonValueAggregateQuery, bool hasLogicalPartitionKey, bool bAllowDCount, String[] partitionKeyDefinitionPathTokens, UInt32[] partitionKeyDefinitionPathTokenLengths, UInt32 partitionKeyDefinitionPathCount, PartitionKind partitionKind, IntPtr serializedQueryExecutionInfoBuffer, UInt32 serializedQueryExecutionInfoBufferLength, UInt32& serializedQueryExecutionInfoResultLength);
    [SuppressUnmanagedCodeSecurityAttribute]
public static UInt32 GetPartitionKeyRangesFromQuery3(IntPtr serviceProvider, string query, PartitionKeyRangesApiOptions partitionKeyRangesApiOptions, String[] partitionKeyDefinitionPathTokens, UInt32[] partitionKeyDefinitionPathTokenLengths, UInt32 partitionKeyDefinitionPathCount, IntPtr serializedQueryExecutionInfoBuffer, UInt32 serializedQueryExecutionInfoBufferLength, UInt32& serializedQueryExecutionInfoResultLength);
    [SuppressUnmanagedCodeSecurityAttribute]
public static UInt32 CreateServiceProvider(string configJsonString, IntPtr& serviceProvider);
    [SuppressUnmanagedCodeSecurityAttribute]
public static UInt32 UpdateServiceProvider(IntPtr serviceProvider, string configJsonString);
    internal static bool IsGatewayAllowedToParseQueries();
    private static Nullable`1<bool> BoolParse(string boolValueString);
    private static Nullable`1<bool> GetSetting(string key);
}
internal class Microsoft.Azure.Documents.ServiceUnavailableException : DocumentClientException {
    public ServiceUnavailableException(string message);
    public ServiceUnavailableException(string message, bool rawErrorMessageOnly);
    public ServiceUnavailableException(string message, SubStatusCodes subStatusCode, Uri requestUri, bool rawErrorMessageOnly);
    public ServiceUnavailableException(string message, Exception innerException, SubStatusCodes subStatusCode, Uri requestUri);
    public ServiceUnavailableException(string message, HttpResponseHeaders headers, Nullable`1<SubStatusCodes> subStatusCode, Uri requestUri);
    public ServiceUnavailableException(Exception innerException, SubStatusCodes subStatusCode);
    public ServiceUnavailableException(string message, INameValueCollection headers, Nullable`1<SubStatusCodes> subStatusCode, Uri requestUri);
    public ServiceUnavailableException(string message, Exception innerException, HttpResponseHeaders headers, Nullable`1<SubStatusCodes> subStatusCode, Uri requestUri, bool rawErrorMessageOnly);
    private ServiceUnavailableException(SerializationInfo info, StreamingContext context);
    public static ServiceUnavailableException Create(Nullable`1<SubStatusCodes> subStatusCode, Exception innerException, HttpResponseHeaders headers, Uri requestUri);
    public static ServiceUnavailableException Create(INameValueCollection headers, Nullable`1<SubStatusCodes> subStatusCode, Uri requestUri);
    private void SetDescription();
    private static string GetExceptionMessage(Nullable`1<SubStatusCodes> subStatusCode);
    internal static SubStatusCodes GetSubStatus(INameValueCollection responseHeaders);
    internal static SubStatusCodes GetSubStatus(HttpResponseHeaders responseHeaders);
}
internal static class Microsoft.Azure.Documents.SessionTokenHelper : object {
    public static Char[] CharArrayWithColon;
    public static Char[] CharArrayWithComma;
    private static Char[] CharArrayWithCommaAndColon;
    private static SessionTokenHelper();
    public static void SetOriginalSessionToken(DocumentServiceRequest request, string originalSessionToken);
    public static void ValidateAndRemoveSessionToken(DocumentServiceRequest request);
    public static void SetPartitionLocalSessionToken(DocumentServiceRequest entity, ISessionContainer sessionContainer);
    internal static ISessionToken GetLocalSessionToken(DocumentServiceRequest request, string globalSessionToken, string partitionKeyRangeId);
    internal static ISessionToken ResolvePartitionLocalSessionToken(DocumentServiceRequest request, string partitionKeyRangeId, ConcurrentDictionary`2<string, ISessionToken> partitionKeyRangeIdToTokenMap);
    internal static ISessionToken Parse(string sessionToken);
    internal static bool TryParse(string sessionToken, ISessionToken& parsedSessionToken);
    internal static bool TryParse(string sessionToken, String& partitionKeyRangeId, ISessionToken& parsedSessionToken);
    internal static bool TryParseSessionToken(string sessionToken, ISessionToken& parsedSessionToken);
    internal static bool TryParse(string sessionTokenString, String& partitionKeyRangeId, String& sessionToken);
    internal static ISessionToken Parse(string sessionToken, string version);
    internal static bool IsSingleGlobalLsnSessionToken(string sessionToken);
    internal static bool TryFindPartitionLocalSessionToken(string sessionTokens, string partitionKeyRangeId, String& partitionLocalSessionToken);
    [IteratorStateMachineAttribute("Microsoft.Azure.Documents.SessionTokenHelper/<SplitPartitionLocalSessionTokens>d__16")]
private static IEnumerable`1<string> SplitPartitionLocalSessionTokens(string sessionTokens);
    internal static string SerializeSessionToken(string partitionKeyRangeId, ISessionToken parsedSessionToken);
}
internal class Microsoft.Azure.Documents.SessionTokenMismatchRetryPolicy : object {
    private static string sessionRetryInitialBackoff;
    private static string sessionRetryMaximumBackoff;
    private static int defaultWaitTimeInMilliSeconds;
    private static int defaultInitialBackoffTimeInMilliseconds;
    private static int defaultMaximumBackoffTimeInMilliseconds;
    private static int backoffMultiplier;
    private static Lazy`1<int> sessionRetryInitialBackoffConfig;
    private static Lazy`1<int> sessionRetryMaximumBackoffConfig;
    private int retryCount;
    private Stopwatch durationTimer;
    private int waitTimeInMilliSeconds;
    private Nullable`1<int> currentBackoffInMilliSeconds;
    private static SessionTokenMismatchRetryPolicy();
    public SessionTokenMismatchRetryPolicy(int waitTimeInMilliSeconds);
    public sealed virtual Task`1<ShouldRetryResult> ShouldRetryAsync(Exception exception, CancellationToken cancellationToken);
    private ShouldRetryResult ShouldRetryInternalAsync(Nullable`1<HttpStatusCode> statusCode, Nullable`1<SubStatusCodes> subStatusCode);
}
internal class Microsoft.Azure.Documents.SharedFiles.Routing.Int128 : ValueType {
    private BigInteger value;
    private static BigInteger MaxBigIntValue;
    public static Int128 MaxValue;
    public Byte[] Bytes { get; }
    private Int128(BigInteger value);
    public Int128(Byte[] data);
    private static Int128();
    public static Int128 op_Implicit(int n);
    public static Int128 op_Multiply(Int128 left, Int128 right);
    public static Int128 op_Addition(Int128 left, Int128 right);
    public static Int128 op_Subtraction(Int128 left, Int128 right);
    public static Int128 op_Division(Int128 left, Int128 right);
    public static bool op_GreaterThan(Int128 left, Int128 right);
    public static bool op_LessThan(Int128 left, Int128 right);
    public static bool op_Equality(Int128 left, Int128 right);
    public static bool op_Inequality(Int128 left, Int128 right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public Byte[] get_Bytes();
}
internal class Microsoft.Azure.Documents.ShouldRetryResult : object {
    private static ShouldRetryResult EmptyNoRetry;
    [CompilerGeneratedAttribute]
private bool <ShouldRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <BackoffTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ExceptionToThrow>k__BackingField;
    public bool ShouldRetry { get; protected set; }
    public TimeSpan BackoffTime { get; protected set; }
    public Exception ExceptionToThrow { get; protected set; }
    private static ShouldRetryResult();
    [CompilerGeneratedAttribute]
public bool get_ShouldRetry();
    [CompilerGeneratedAttribute]
protected void set_ShouldRetry(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_BackoffTime();
    [CompilerGeneratedAttribute]
protected void set_BackoffTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public Exception get_ExceptionToThrow();
    [CompilerGeneratedAttribute]
protected void set_ExceptionToThrow(Exception value);
    public void ThrowIfDoneTrying(ExceptionDispatchInfo capturedException);
    public static ShouldRetryResult NoRetry(Exception exception);
    public static ShouldRetryResult RetryAfter(TimeSpan backoffTime);
}
internal class Microsoft.Azure.Documents.ShouldRetryResult`1 : ShouldRetryResult {
    private static ShouldRetryResult`1<TPolicyArg1> EmptyNoRetry;
    [CompilerGeneratedAttribute]
private TPolicyArg1 <PolicyArg1>k__BackingField;
    public TPolicyArg1 PolicyArg1 { get; private set; }
    private static ShouldRetryResult`1();
    [CompilerGeneratedAttribute]
public TPolicyArg1 get_PolicyArg1();
    [CompilerGeneratedAttribute]
private void set_PolicyArg1(TPolicyArg1 value);
    public static ShouldRetryResult`1<TPolicyArg1> NoRetry(Exception exception);
    public static ShouldRetryResult`1<TPolicyArg1> RetryAfter(TimeSpan backoffTime, TPolicyArg1 policyArg1);
}
internal class Microsoft.Azure.Documents.SimpleSessionToken : object {
    private long globalLsn;
    public long LSN { get; }
    public SimpleSessionToken(long globalLsn);
    public static bool TryCreate(string globalLsn, ISessionToken& parsedSessionToken);
    public sealed virtual long get_LSN();
    public sealed virtual bool Equals(ISessionToken obj);
    public sealed virtual ISessionToken Merge(ISessionToken obj);
    public sealed virtual bool IsValid(ISessionToken otherSessionToken);
    private sealed virtual override string Microsoft.Azure.Documents.ISessionToken.ConvertToString();
}
internal class Microsoft.Azure.Documents.Snapshot : Resource {
    private static DateTime UnixStartTime;
    private SnapshotContent snapshotContent;
    [JsonPropertyAttribute]
public string ResourceLink { get; public set; }
    [JsonPropertyAttribute]
public SnapshotState State { get; internal set; }
    [JsonPropertyAttribute]
public SnapshotKind Kind { get; internal set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("Microsoft.Azure.Documents.UnixDateTimeConverter")]
public DateTime SnapshotTimestamp { get; public set; }
    [JsonPropertyAttribute]
internal string OwnerResourceId { get; internal set; }
    [JsonPropertyAttribute]
public ulong SizeInKB { get; internal set; }
    [JsonPropertyAttribute]
public ulong CompressedSizeInKB { get; internal set; }
    [JsonPropertyAttribute]
internal long LSN { get; internal set; }
    [JsonPropertyAttribute]
internal SnapshotContent Content { get; internal set; }
    [JsonPropertyAttribute]
internal string ParentResourceId { get; internal set; }
    private static Snapshot();
    public string get_ResourceLink();
    public void set_ResourceLink(string value);
    public SnapshotState get_State();
    internal void set_State(SnapshotState value);
    public SnapshotKind get_Kind();
    internal void set_Kind(SnapshotKind value);
    public DateTime get_SnapshotTimestamp();
    public void set_SnapshotTimestamp(DateTime value);
    internal string get_OwnerResourceId();
    internal void set_OwnerResourceId(string value);
    public ulong get_SizeInKB();
    internal void set_SizeInKB(ulong value);
    public ulong get_CompressedSizeInKB();
    internal void set_CompressedSizeInKB(ulong value);
    internal long get_LSN();
    internal void set_LSN(long value);
    internal SnapshotContent get_Content();
    internal void set_Content(SnapshotContent value);
    internal string get_ParentResourceId();
    internal void set_ParentResourceId(string value);
    internal virtual void OnSave();
    internal virtual void Validate();
    internal static Snapshot CloneSystemSnapshot(Snapshot existingSnapshot, OperationType operationType, bool inheritSnapshotTimestamp);
}
internal class Microsoft.Azure.Documents.SnapshotContent : JsonSerializable {
    private Database databaseResource;
    private DocumentCollection collectionResource;
    private IList`1<string> partitionKeyRanges;
    private IList`1<PartitionKeyRange> partitionKeyRangeList;
    private SerializableNameValueCollection geoLinkIdToPKRangeRid;
    private IList`1<string> partitionKeyRangeResourceIds;
    private IList`1<string> dataDirectories;
    private IList`1<string> storageAccountUris;
    private IList`1<string> serializedClientEncryptionKeys;
    private IList`1<ClientEncryptionKey> clientEncryptionKeysList;
    [JsonPropertyAttribute]
public OperationType OperationType { get; internal set; }
    [JsonIgnoreAttribute]
public Database Database { get; }
    [JsonIgnoreAttribute]
public DocumentCollection DocumentCollection { get; }
    [JsonIgnoreAttribute]
public IList`1<PartitionKeyRange> PartitionKeyRangeList { get; }
    [JsonPropertyAttribute]
public SerializableNameValueCollection GeoLinkIdToPKRangeRid { get; internal set; }
    [JsonPropertyAttribute]
public IList`1<string> PartitionKeyRangeResourceIds { get; internal set; }
    [JsonPropertyAttribute]
public IList`1<string> DataDirectories { get; internal set; }
    [JsonPropertyAttribute]
public string MetadataDirectory { get; internal set; }
    [JsonPropertyAttribute]
public string SerializedDatabase { get; internal set; }
    [JsonPropertyAttribute]
public string SerializedOffer { get; internal set; }
    [JsonPropertyAttribute]
public string SerializedCollection { get; internal set; }
    [JsonPropertyAttribute]
public Nullable`1<bool> IsMasterResourcesDeletionPending { get; internal set; }
    [JsonPropertyAttribute]
public IList`1<string> SerializedPartitionKeyRanges { get; internal set; }
    [JsonPropertyAttribute]
public IList`1<string> SerializedClientEncryptionKeyResources { get; internal set; }
    [JsonPropertyAttribute]
public IList`1<string> StorageAccountUris { get; internal set; }
    [JsonIgnoreAttribute]
public IList`1<ClientEncryptionKey> ClientEncryptionKeysList { get; }
    internal SnapshotContent(OperationType operationType, string serializedDatabase, string serializedCollection, string serializedOffer, IList`1<string> serializedPkranges);
    internal SnapshotContent(OperationType operationType, string serializedDatabase);
    internal SnapshotContent(OperationType operationType, string serializedDatabase, string serializedOffer, SerializableNameValueCollection geoLinkIdToPKRangeRid);
    internal SnapshotContent(OperationType operationType, string serializedDatabase, string serializedCollection, IList`1<string> serializedPkranges, SerializableNameValueCollection geoLinkIdToPKRangeRid);
    public OperationType get_OperationType();
    internal void set_OperationType(OperationType value);
    public Database get_Database();
    public DocumentCollection get_DocumentCollection();
    public IList`1<PartitionKeyRange> get_PartitionKeyRangeList();
    public SerializableNameValueCollection get_GeoLinkIdToPKRangeRid();
    internal void set_GeoLinkIdToPKRangeRid(SerializableNameValueCollection value);
    public IList`1<string> get_PartitionKeyRangeResourceIds();
    internal void set_PartitionKeyRangeResourceIds(IList`1<string> value);
    public IList`1<string> get_DataDirectories();
    internal void set_DataDirectories(IList`1<string> value);
    public string get_MetadataDirectory();
    internal void set_MetadataDirectory(string value);
    public string get_SerializedDatabase();
    internal void set_SerializedDatabase(string value);
    public string get_SerializedOffer();
    internal void set_SerializedOffer(string value);
    public string get_SerializedCollection();
    internal void set_SerializedCollection(string value);
    public Nullable`1<bool> get_IsMasterResourcesDeletionPending();
    internal void set_IsMasterResourcesDeletionPending(Nullable`1<bool> value);
    public IList`1<string> get_SerializedPartitionKeyRanges();
    internal void set_SerializedPartitionKeyRanges(IList`1<string> value);
    public IList`1<string> get_SerializedClientEncryptionKeyResources();
    internal void set_SerializedClientEncryptionKeyResources(IList`1<string> value);
    public IList`1<string> get_StorageAccountUris();
    internal void set_StorageAccountUris(IList`1<string> value);
    public IList`1<ClientEncryptionKey> get_ClientEncryptionKeysList();
    internal virtual void OnSave();
    private T GetResourceIfDeserialized(string body);
    internal virtual void Validate();
    private void ArgumentStringNotNullOrWhiteSpace(string parameter, string parameterName);
}
internal enum Microsoft.Azure.Documents.SnapshotKind : Enum {
    public int value__;
    public static SnapshotKind OnDemand;
    public static SnapshotKind Live;
    public static SnapshotKind System;
    public static SnapshotKind Invalid;
}
internal enum Microsoft.Azure.Documents.SnapshotState : Enum {
    public int value__;
    public static SnapshotState Pending;
    public static SnapshotState Completed;
    public static SnapshotState Failed;
    public static SnapshotState Invalid;
}
internal class Microsoft.Azure.Documents.SpatialIndex : Index {
    [JsonPropertyAttribute]
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public DataType DataType { get; public set; }
    public SpatialIndex(DataType dataType);
    public DataType get_DataType();
    public void set_DataType(DataType value);
    internal virtual void Validate();
    public sealed virtual object Clone();
}
internal class Microsoft.Azure.Documents.SpatialSpec : JsonSerializable {
    private Collection`1<SpatialType> spatialTypes;
    private BoundingBoxSpec boundingBoxSpec;
    [JsonPropertyAttribute]
public string Path { get; public set; }
    [JsonPropertyAttribute]
public Collection`1<SpatialType> SpatialTypes { get; public set; }
    [JsonPropertyAttribute]
public BoundingBoxSpec BoundingBox { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public Collection`1<SpatialType> get_SpatialTypes();
    public void set_SpatialTypes(Collection`1<SpatialType> value);
    public BoundingBoxSpec get_BoundingBox();
    public void set_BoundingBox(BoundingBoxSpec value);
    internal object Clone();
    internal virtual void Validate();
    internal virtual void OnSave();
}
internal enum Microsoft.Azure.Documents.SpatialType : Enum {
    public int value__;
    public static SpatialType Point;
    public static SpatialType LineString;
    public static SpatialType Polygon;
    public static SpatialType MultiPolygon;
}
internal enum Microsoft.Azure.Documents.StatusCodes : Enum {
    public int value__;
    public static StatusCodes Processing;
    public static StatusCodes Ok;
    public static StatusCodes Created;
    public static StatusCodes Accepted;
    public static StatusCodes NoContent;
    public static StatusCodes MultiStatus;
    public static StatusCodes NotModified;
    public static StatusCodes StartingErrorCode;
    public static StatusCodes BadRequest;
    public static StatusCodes Unauthorized;
    public static StatusCodes Forbidden;
    public static StatusCodes NotFound;
    public static StatusCodes MethodNotAllowed;
    public static StatusCodes RequestTimeout;
    public static StatusCodes Conflict;
    public static StatusCodes Gone;
    public static StatusCodes PreconditionFailed;
    public static StatusCodes RequestEntityTooLarge;
    public static StatusCodes Locked;
    public static StatusCodes FailedDependency;
    public static StatusCodes TooManyRequests;
    public static StatusCodes RetryWith;
    public static StatusCodes InternalServerError;
    public static StatusCodes BadGateway;
    public static StatusCodes ServiceUnavailable;
    public static StatusCodes OperationPaused;
    public static StatusCodes OperationCancelled;
    public static StatusCodes PartitionMigrationOperationException;
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.StatusCodesExtensions : object {
    private static Dictionary`2<int, string> CodeNameMap;
    private static StatusCodesExtensions();
    [ExtensionAttribute]
public static string ToStatusCodeString(StatusCodes code);
}
internal class Microsoft.Azure.Documents.StoreClient : object {
    private ISessionContainer sessionContainer;
    private ReplicatedResourceClient replicatedResourceClient;
    private TransportClient transportClient;
    private IServiceConfigurationReader serviceConfigurationReader;
    private bool enableRequestDiagnostics;
    [CompilerGeneratedAttribute]
private JsonSerializerSettings <SerializerSettings>k__BackingField;
    internal JsonSerializerSettings SerializerSettings { get; internal set; }
    public string LastReadAddress { get; public set; }
    public string LastWriteAddress { get; }
    public bool ForceAddressRefresh { get; public set; }
    public StoreClient(IAddressResolver addressResolver, ISessionContainer sessionContainer, IServiceConfigurationReader serviceConfigurationReader, IAuthorizationTokenProvider userTokenProvider, Protocol protocol, TransportClient transportClient, bool enableRequestDiagnostics, bool enableReadRequestsFallback, bool useMultipleWriteLocations, bool detectClientConnectivityIssues, bool disableRetryWithRetryPolicy, bool enableReplicaValidation, RetryWithConfiguration retryWithConfiguration);
    [CompilerGeneratedAttribute]
internal JsonSerializerSettings get_SerializerSettings();
    [CompilerGeneratedAttribute]
internal void set_SerializerSettings(JsonSerializerSettings value);
    public string get_LastReadAddress();
    public void set_LastReadAddress(string value);
    public string get_LastWriteAddress();
    public bool get_ForceAddressRefresh();
    public void set_ForceAddressRefresh(bool value);
    public sealed virtual Task`1<DocumentServiceResponse> ProcessMessageAsync(DocumentServiceRequest request, IRetryPolicy retryPolicy, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.StoreClient/<ProcessMessageAsync>d__19")]
public Task`1<DocumentServiceResponse> ProcessMessageAsync(DocumentServiceRequest request, CancellationToken cancellationToken, IRetryPolicy retryPolicy);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.StoreClient/<OpenConnectionsToAllReplicasAsync>d__20")]
public sealed virtual Task OpenConnectionsToAllReplicasAsync(string databaseName, string containerLinkUri, CancellationToken cancellationToken);
    private DocumentServiceResponse CompleteResponse(StoreResponse storeResponse, DocumentServiceRequest request);
    private long GetLSN(INameValueCollection headers);
    private void UpdateResponseHeader(DocumentServiceRequest request, INameValueCollection headers);
    private void CaptureSessionToken(Nullable`1<HttpStatusCode> statusCode, SubStatusCodes subStatusCode, DocumentServiceRequest request, INameValueCollection headers);
    private static INameValueCollection GetHeadersFromStoreResponse(StoreResponse storeResponse);
    internal void AddDisableRntbdChannelCallback(Action action);
}
internal class Microsoft.Azure.Documents.StoreClientFactory : object {
    private bool isDisposed;
    private Protocol protocol;
    private RetryWithConfiguration retryWithConfiguration;
    private bool disableRetryWithRetryPolicy;
    private TransportClient transportClient;
    private TransportClient fallbackTransportClient;
    private ConnectionStateListener connectionStateListener;
    public StoreClientFactory(Protocol protocol, int requestTimeoutInSeconds, int maxConcurrentConnectionOpenRequests, UserAgentContainer userAgent, ICommunicationEventSource eventSource, string overrideHostNameInCertificate, int openTimeoutInSeconds, int idleTimeoutInSeconds, int timerPoolGranularityInSeconds, int maxRntbdChannels, int rntbdPartitionCount, int maxRequestsPerRntbdChannel, PortReuseMode rntbdPortReuseMode, int rntbdPortPoolReuseThreshold, int rntbdPortPoolBindAttempts, int receiveHangDetectionTimeSeconds, int sendHangDetectionTimeSeconds, bool disableRetryWithRetryPolicy, RetryWithConfiguration retryWithConfiguration, CallerId callerId, bool enableTcpConnectionEndpointRediscovery, IAddressResolver addressResolver, TimeSpan localRegionOpenTimeout, bool enableChannelMultiplexing, int rntbdMaxConcurrentOpeningConnectionCount, MemoryStreamPool memoryStreamPool, RemoteCertificateValidationCallback remoteCertificateValidationCallback, Func`2<string, Task`1<IPAddress>> dnsResolutionFunction, DistributedTracingOptions distributedTracingOptions, IChaosInterceptor chaosInterceptor);
    private StoreClientFactory(Protocol protocol, RetryWithConfiguration retryWithConfiguration, TransportClient transportClient, TransportClient fallbackTransportClient, ConnectionStateListener connectionStateListener);
    internal StoreClientFactory Clone();
    internal void WithTransportInterceptor(Func`2<TransportClient, TransportClient> transportClientHandlerFactory);
    public sealed virtual StoreClient CreateStoreClient(IAddressResolver addressResolver, ISessionContainer sessionContainer, IServiceConfigurationReader serviceConfigurationReader, IAuthorizationTokenProvider authorizationTokenProvider, bool enableRequestDiagnostics, bool enableReadRequestsFallback, bool useFallbackClient, bool useMultipleWriteLocations, bool detectClientConnectivityIssues, bool enableReplicaValidation);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
    private static void ValidatePortPoolReuseThreshold(Int32& rntbdPortPoolReuseThreshold);
    private static void ValidatePortPoolBindAttempts(Int32& rntbdPortPoolBindAttempts);
    private static void ValidateRntbdMaxConcurrentOpeningConnectionCount(Int32& rntbdMaxConcurrentOpeningConnectionCount);
}
internal class Microsoft.Azure.Documents.StoredProcedure : Resource {
    [JsonPropertyAttribute]
public string Body { get; public set; }
    public string get_Body();
    public void set_Body(string value);
}
internal class Microsoft.Azure.Documents.StoreReader : object {
    private TransportClient transportClient;
    private AddressSelector addressSelector;
    private IAddressEnumerator addressEnumerator;
    private ISessionContainer sessionContainer;
    private bool canUseLocalLSNBasedHeaders;
    private bool isReplicaAddressValidationEnabled;
    [CompilerGeneratedAttribute]
private string <LastReadAddress>k__BackingField;
    internal string LastReadAddress { get; internal set; }
    public StoreReader(TransportClient transportClient, AddressSelector addressSelector, IAddressEnumerator addressEnumerator, ISessionContainer sessionContainer, bool enableReplicaValidation);
    [CompilerGeneratedAttribute]
internal string get_LastReadAddress();
    [CompilerGeneratedAttribute]
internal void set_LastReadAddress(string value);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.StoreReader/<ReadMultipleReplicaAsync>d__11")]
public Task`1<IList`1<ReferenceCountedDisposable`1<StoreResult>>> ReadMultipleReplicaAsync(DocumentServiceRequest entity, bool includePrimary, int replicaCountToRead, bool requiresValidLsn, bool useSessionToken, ReadMode readMode, bool checkMinLSN, bool forceReadAll);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.StoreReader/<ReadPrimaryAsync>d__12")]
public Task`1<ReferenceCountedDisposable`1<StoreResult>> ReadPrimaryAsync(DocumentServiceRequest entity, bool requiresValidLsn, bool useSessionToken);
    private static ReferenceCountedDisposable`1<StoreResult> GetStoreResultOrThrowGoneException(ReadReplicaResult readReplicaResult);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.StoreReader/<ReadMultipleReplicasInternalAsync>d__14")]
private Task`1<ReadReplicaResult> ReadMultipleReplicasInternalAsync(DocumentServiceRequest entity, bool includePrimary, int replicaCountToRead, bool requiresValidLsn, bool useSessionToken, ReadMode readMode, bool checkMinLSN, bool forceReadAll);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.StoreReader/<ReadPrimaryInternalAsync>d__15")]
private Task`1<ReadReplicaResult> ReadPrimaryInternalAsync(DocumentServiceRequest entity, bool requiresValidLsn, bool useSessionToken, bool isRetryAfterRefresh);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.StoreReader/<GetResult>d__16")]
private Task`1<ReferenceCountedDisposable`1<StoreResult>> GetResult(DocumentServiceRequest entity, bool requiresValidLsn, TransportAddressUri primaryUri, StrongBox`1<Nullable`1<DateTime>> endTimeUtc);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.StoreReader/<ReadFromStoreAsync>d__17")]
private Task`1<ValueTuple`2<StoreResponse, DateTime>> ReadFromStoreAsync(TransportAddressUri physicalAddress, DocumentServiceRequest request);
    private void UpdateContinuationTokenIfReadFeedOrQuery(DocumentServiceRequest request);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.StoreReader/<CompleteActivity>d__19")]
private static Task`1<StoreResponse> CompleteActivity(Task`1<StoreResponse> task, QueryRequestPerformanceActivity activity);
}
internal class Microsoft.Azure.Documents.StoreResponse : object {
    [CompilerGeneratedAttribute]
private int <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private INameValueCollection <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <ResponseBody>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportRequestStats <TransportRequestStats>k__BackingField;
    private Lazy`1<SubStatusCodes> subStatusCode;
    public int Status { get; public set; }
    public INameValueCollection Headers { get; public set; }
    public Stream ResponseBody { get; public set; }
    public TransportRequestStats TransportRequestStats { get; public set; }
    public long LSN { get; }
    public string PartitionKeyRangeId { get; }
    public long CollectionPartitionIndex { get; }
    public long CollectionServiceIndex { get; }
    public string Continuation { get; }
    public SubStatusCodes SubStatusCode { get; }
    public HttpStatusCode StatusCode { get; }
    [CompilerGeneratedAttribute]
public int get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(int value);
    [CompilerGeneratedAttribute]
public INameValueCollection get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(INameValueCollection value);
    [CompilerGeneratedAttribute]
public Stream get_ResponseBody();
    [CompilerGeneratedAttribute]
public void set_ResponseBody(Stream value);
    [CompilerGeneratedAttribute]
public TransportRequestStats get_TransportRequestStats();
    [CompilerGeneratedAttribute]
public void set_TransportRequestStats(TransportRequestStats value);
    public long get_LSN();
    public string get_PartitionKeyRangeId();
    public long get_CollectionPartitionIndex();
    public long get_CollectionServiceIndex();
    public string get_Continuation();
    public sealed virtual SubStatusCodes get_SubStatusCode();
    public sealed virtual HttpStatusCode get_StatusCode();
    public bool TryGetHeaderValue(string attribute, String& value);
    public void UpsertHeaderValue(string headerName, string headerValue);
    private SubStatusCodes GetSubStatusCode();
}
internal class Microsoft.Azure.Documents.StoreResult : object {
    private StoreResponse storeResponse;
    private static bool UseSessionTokenHeader;
    [CompilerGeneratedAttribute]
private DocumentClientException <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LSN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKeyRangeId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <QuorumAckedLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private long <GlobalCommittedLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfReadRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ItemLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private ISessionToken <SessionToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsingLocalLSN>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RequestCharge>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentReplicaSetSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentWriteQuorum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <StorePhysicalAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private StatusCodes <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private SubStatusCodes <SubStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BackendRequestDurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RetryAfterInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportRequestStats <TransportRequestStats>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ReplicaHealthStatuses>k__BackingField;
    public DocumentClientException Exception { get; }
    public long LSN { get; private set; }
    public string PartitionKeyRangeId { get; private set; }
    public long QuorumAckedLSN { get; private set; }
    public long GlobalCommittedLSN { get; private set; }
    public long NumberOfReadRegions { get; private set; }
    public long ItemLSN { get; private set; }
    public ISessionToken SessionToken { get; private set; }
    public bool UsingLocalLSN { get; private set; }
    public double RequestCharge { get; private set; }
    public int CurrentReplicaSetSize { get; private set; }
    public int CurrentWriteQuorum { get; private set; }
    public bool IsValid { get; private set; }
    public Uri StorePhysicalAddress { get; private set; }
    public StatusCodes StatusCode { get; private set; }
    public SubStatusCodes SubStatusCode { get; private set; }
    public string ActivityId { get; private set; }
    public string BackendRequestDurationInMs { get; private set; }
    public string RetryAfterInMs { get; private set; }
    public TransportRequestStats TransportRequestStats { get; private set; }
    public IEnumerable`1<string> ReplicaHealthStatuses { get; private set; }
    private StoreResult(StoreResponse storeResponse, DocumentClientException exception, string partitionKeyRangeId, long lsn, long quorumAckedLsn, double requestCharge, int currentReplicaSetSize, int currentWriteQuorum, bool isValid, Uri storePhysicalAddress, long globalCommittedLSN, int numberOfReadRegions, long itemLSN, ISessionToken sessionToken, bool usingLocalLSN, string activityId, string backendRequestDurationInMs, string retryAfterInMs, TransportRequestStats transportRequestStats, IEnumerable`1<string> replicaHealthStatuses);
    private static StoreResult();
    public static ReferenceCountedDisposable`1<StoreResult> CreateStoreResult(StoreResponse storeResponse, Exception responseException, bool requiresValidLsn, bool useLocalLSNBasedHeaders, IEnumerable`1<string> replicaHealthStatuses, Uri storePhysicalAddress);
    public static ReferenceCountedDisposable`1<StoreResult> CreateForTesting(StoreResponse storeResponse);
    public static ReferenceCountedDisposable`1<StoreResult> CreateForTesting(TransportRequestStats transportRequestStats);
    public static ReferenceCountedDisposable`1<StoreResult> CreateForTesting(string partitionKeyRangeId);
    [CompilerGeneratedAttribute]
public DocumentClientException get_Exception();
    [CompilerGeneratedAttribute]
public long get_LSN();
    [CompilerGeneratedAttribute]
private void set_LSN(long value);
    [CompilerGeneratedAttribute]
public string get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
private void set_PartitionKeyRangeId(string value);
    [CompilerGeneratedAttribute]
public long get_QuorumAckedLSN();
    [CompilerGeneratedAttribute]
private void set_QuorumAckedLSN(long value);
    [CompilerGeneratedAttribute]
public long get_GlobalCommittedLSN();
    [CompilerGeneratedAttribute]
private void set_GlobalCommittedLSN(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfReadRegions();
    [CompilerGeneratedAttribute]
private void set_NumberOfReadRegions(long value);
    [CompilerGeneratedAttribute]
public long get_ItemLSN();
    [CompilerGeneratedAttribute]
private void set_ItemLSN(long value);
    [CompilerGeneratedAttribute]
public ISessionToken get_SessionToken();
    [CompilerGeneratedAttribute]
private void set_SessionToken(ISessionToken value);
    [CompilerGeneratedAttribute]
public bool get_UsingLocalLSN();
    [CompilerGeneratedAttribute]
private void set_UsingLocalLSN(bool value);
    [CompilerGeneratedAttribute]
public double get_RequestCharge();
    [CompilerGeneratedAttribute]
private void set_RequestCharge(double value);
    [CompilerGeneratedAttribute]
public int get_CurrentReplicaSetSize();
    [CompilerGeneratedAttribute]
private void set_CurrentReplicaSetSize(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentWriteQuorum();
    [CompilerGeneratedAttribute]
private void set_CurrentWriteQuorum(int value);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
private void set_IsValid(bool value);
    [CompilerGeneratedAttribute]
public Uri get_StorePhysicalAddress();
    [CompilerGeneratedAttribute]
private void set_StorePhysicalAddress(Uri value);
    [CompilerGeneratedAttribute]
public StatusCodes get_StatusCode();
    [CompilerGeneratedAttribute]
private void set_StatusCode(StatusCodes value);
    [CompilerGeneratedAttribute]
public SubStatusCodes get_SubStatusCode();
    [CompilerGeneratedAttribute]
private void set_SubStatusCode(SubStatusCodes value);
    [CompilerGeneratedAttribute]
public string get_ActivityId();
    [CompilerGeneratedAttribute]
private void set_ActivityId(string value);
    [CompilerGeneratedAttribute]
public string get_BackendRequestDurationInMs();
    [CompilerGeneratedAttribute]
private void set_BackendRequestDurationInMs(string value);
    [CompilerGeneratedAttribute]
public string get_RetryAfterInMs();
    [CompilerGeneratedAttribute]
private void set_RetryAfterInMs(string value);
    [CompilerGeneratedAttribute]
public TransportRequestStats get_TransportRequestStats();
    [CompilerGeneratedAttribute]
private void set_TransportRequestStats(TransportRequestStats value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ReplicaHealthStatuses();
    [CompilerGeneratedAttribute]
private void set_ReplicaHealthStatuses(IEnumerable`1<string> value);
    public DocumentClientException GetException();
    public StoreResponse ToResponse(RequestChargeTracker requestChargeTracker);
    public virtual string ToString();
    public void AppendToBuilder(StringBuilder stringBuilder);
    private static void SetRequestCharge(StoreResponse response, DocumentClientException documentClientException, double totalRequestCharge);
    internal static void VerifyCanContinueOnException(DocumentClientException ex);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.StreamExtension : object {
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.StreamExtension/<CopyToAsync>d__0")]
[ExtensionAttribute]
public static Task CopyToAsync(Stream srcStream, Stream destinationStream, long maxSizeToCopy);
    public static MemoryStream CreateExportableMemoryStream(Byte[] body);
    public static Task`1<CloneableStream> AsClonableStreamAsync(Stream mediaStream, bool allowUnsafeDataAccess);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.StreamExtension/<CopyStreamAndReturnAsync>d__3")]
private static Task`1<CloneableStream> CopyStreamAndReturnAsync(Stream mediaStream);
}
[IsReadOnlyAttribute]
internal class Microsoft.Azure.Documents.StringSegment : ValueType {
    private string value;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    private int Start { get; }
    public int Length { get; }
    public StringSegment(string value);
    public StringSegment(string value, int start, int length);
    [CompilerGeneratedAttribute]
private int get_Start();
    [CompilerGeneratedAttribute]
public int get_Length();
    public static StringSegment op_Implicit(string b);
    public bool IsNullOrEmpty();
    public int Compare(string other, StringComparison comparison);
    public int Compare(StringSegment other, StringComparison comparison);
    public bool Equals(string other, StringComparison comparison);
    public StringSegment Substring(int start, int length);
    public int LastIndexOf(char segment);
    public StringSegment Trim(Char[] trimChars);
    public StringSegment TrimStart(Char[] trimChars);
    public StringSegment TrimEnd(Char[] trimChars);
    public string GetString();
}
internal enum Microsoft.Azure.Documents.SubStatusCodes : Enum {
    public int value__;
    public static SubStatusCodes Unknown;
    public static SubStatusCodes TooManyRequests;
    public static SubStatusCodes MissedTargetLsn;
    public static SubStatusCodes MissedTargetLsnOver100;
    public static SubStatusCodes MissedTargetLsnOver1000;
    public static SubStatusCodes MissedTargetLsnOver10000;
    public static SubStatusCodes MissedTargetGlobalCommittedLsn;
    public static SubStatusCodes MissedTargetGlobalCommittedLsnOver100;
    public static SubStatusCodes MissedTargetGlobalCommittedLsnOver1000;
    public static SubStatusCodes MissedTargetGlobalCommittedLsnOver10000;
    public static SubStatusCodes PartitionKeyMismatch;
    public static SubStatusCodes CrossPartitionQueryNotServable;
    public static SubStatusCodes ScriptCompileError;
    public static SubStatusCodes AnotherOfferReplaceOperationIsInProgress;
    public static SubStatusCodes HttpListenerException;
    public static SubStatusCodes NameCacheIsStale;
    public static SubStatusCodes PartitionKeyRangeGone;
    public static SubStatusCodes CompletingSplit;
    public static SubStatusCodes CompletingPartitionMigration;
    public static SubStatusCodes LeaseNotFound;
    public static SubStatusCodes ArchivalPartitionNotPresent;
    public static SubStatusCodes ReadSessionNotAvailable;
    public static SubStatusCodes OwnerResourceNotFound;
    public static SubStatusCodes ConfigurationNameNotFound;
    public static SubStatusCodes ConfigurationPropertyNotFound;
    public static SubStatusCodes CollectionCreateInProgress;
    public static SubStatusCodes StoreNotReady;
    public static SubStatusCodes AuthTokenNotFoundInCache;
    public static SubStatusCodes PartitionMigratingCollectionDeleted;
    public static SubStatusCodes PartitionMigrationSourcePartitionDeletedInMaster;
    public static SubStatusCodes PartitionMigrationSharedThroughputDatabasePartitionResourceNotFoundInMaster;
    public static SubStatusCodes PartitionMigrationPartitionResourceNotFoundInMaster;
    public static SubStatusCodes PartitionMigrationFailedToUpdateDNS;
    public static SubStatusCodes WriteForbidden;
    public static SubStatusCodes ProvisionLimitReached;
    public static SubStatusCodes DatabaseAccountNotFound;
    public static SubStatusCodes RedundantCollectionPut;
    public static SubStatusCodes SharedThroughputDatabaseQuotaExceeded;
    public static SubStatusCodes SharedThroughputOfferGrowNotNeeded;
    public static SubStatusCodes PartitionKeyQuotaOverLimit;
    public static SubStatusCodes SharedThroughputDatabaseCollectionCountExceeded;
    public static SubStatusCodes SharedThroughputDatabaseCountExceeded;
    public static SubStatusCodes ComputeInternalError;
    public static SubStatusCodes ThroughputCapQuotaExceeded;
    public static SubStatusCodes InvalidThroughputCapValue;
    public static SubStatusCodes ConflictWithControlPlane;
    public static SubStatusCodes DatabaseNameAlreadyExists;
    public static SubStatusCodes ConfigurationNameAlreadyExists;
    public static SubStatusCodes PartitionkeyHashCollisionForId;
    public static SubStatusCodes PartitionMigrationDocumentCountMismatchBetweenSourceAndTargetPartition;
    public static SubStatusCodes PartitionMigrationDocumentCountMismatchBetweenTargetPartitionReplicas;
    public static SubStatusCodes InsufficientBindablePartitions;
    public static SubStatusCodes ComputeFederationNotFound;
    public static SubStatusCodes OperationPaused;
    public static SubStatusCodes InsufficientCapacity;
    public static SubStatusCodes AggregatedHealthStateError;
    public static SubStatusCodes ApplicationHealthStateError;
    public static SubStatusCodes HealthStateError;
    public static SubStatusCodes UnhealthyEventFound;
    public static SubStatusCodes ClusterHealthEmpty;
    public static SubStatusCodes AllocationFailed;
    public static SubStatusCodes OperationResultNull;
    public static SubStatusCodes OperationResultUnexpected;
    public static SubStatusCodes FabricNodesHealthError;
    public static SubStatusCodes SplitIsDisabled;
    public static SubStatusCodes CollectionsInPartitionGotUpdated;
    public static SubStatusCodes CanNotAcquirePKRangesLock;
    public static SubStatusCodes ResourceNotFound;
    public static SubStatusCodes CanNotAcquireOfferOwnerLock;
    public static SubStatusCodes CanNotAcquirePKRangeLock;
    public static SubStatusCodes CanNotAcquirePartitionLock;
    public static SubStatusCodes CanNotAcquireSnapshotOwnerLock;
    public static SubStatusCodes StorageSplitConflictingWithNWayThroughputSplit;
    public static SubStatusCodes MergeIsDisabled;
    public static SubStatusCodes TombstoneRecordsNotFound;
    public static SubStatusCodes InvalidAccountStatus;
    public static SubStatusCodes OfferValidationFailed;
    public static SubStatusCodes CanNotAquireMasterPartitionAccessLock;
    public static SubStatusCodes CanNotAcquireInAccountRestoreInProgressLock;
    public static SubStatusCodes CollectionStateChanged;
    public static SubStatusCodes OfferScaledUpByUser;
    public static SubStatusCodes AccountAlreadyinTargetGateway;
    public static SubStatusCodes CanNotAcquireLogStoreStorageAccountLoadBalanceLock;
    public static SubStatusCodes PartitionMigrationCancelledForPendingUserOperation;
    public static SubStatusCodes PartitionMigrationCanNotAcquireGlobalPartitionMigrationLock;
    public static SubStatusCodes PartitionMigrationCanNotAcquireFederationPartitionMigrationLock;
    public static SubStatusCodes PartitionMigrationServiceTypeAndOperationTypeDoesnotMatch;
    public static SubStatusCodes PartitionMigrationGlobalDatabaseAccountResourceNotFound;
    public static SubStatusCodes PartitionMigrationMasterFederationForWriteRegionNotFound;
    public static SubStatusCodes PartitionMigrationMasterFederationForCurrentRegionNotFound;
    public static SubStatusCodes PartitionMigrationSourceAndTargetFederationSubregionIsNotSame;
    public static SubStatusCodes PartitionMigrationFailedToCreatePartitionMigrationLocks;
    public static SubStatusCodes PartitionMigrationFailedToResolvePartitionInformation;
    public static SubStatusCodes PartitionMigrationIsDisableOnTheGlobalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationIsDisableOnTheRunnerAccount;
    public static SubStatusCodes PartitionMigrationCanNotProceedForInactiveRegionalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationDidNotCompleteWaitForFullSyncInTenRetries;
    public static SubStatusCodes PartitionMigrationCanNotProceedForDeletingRegionalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationCanNotProceedForDeletionFailedRegionalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationCanNotAcquireRegionalDatabaseAccountPartitionMigrationLock;
    public static SubStatusCodes PartitionMigrationIsDisabledOnReadyForDecommissionFederation;
    public static SubStatusCodes PartitionMigrationCanNotAcquirePartitionLock;
    public static SubStatusCodes PartitionMigrationCanNotAcquirePartitionKeyRangesLock;
    public static SubStatusCodes PartitionMigrationCanNotProceedForDeletingGlobalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationCanNotProceedForDeletionFailedGlobalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationCanNotProceedForRevokedGlobalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationMasterServiceTopologyHasWriteRegionEmpty;
    public static SubStatusCodes PartitionMigrationWriteRegionServiceTopologyHasWriteRegionEmpty;
    public static SubStatusCodes PartitionMigrationIsDisabledOnFinalizingDecommissionFederation;
    public static SubStatusCodes PartitionMigrationCanNotProceedForCreationFailedRegionalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationCanNotProceedForCreationFailedGlobalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationCanNotProceedForOfflineRegionalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationCanNotProceedForInitializingOrCreatingRegionalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationCanNotProceedForInitializingOrCreatingGlobalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationCanNotProceedForRestoringOrRestoreFailedRegionalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationCanNotProceedForRestoringOrRestoreFailedGlobalDatabaseAccount;
    public static SubStatusCodes PartitionMigrationRequestValidationFailed;
    public static SubStatusCodes PartitionMigrationSourceFederationEntityIsNull;
    public static SubStatusCodes PartitionMigrationCanNotAcquireTargetFederationPartitionMigrationLock;
    public static SubStatusCodes ConfigurationNameNotEmpty;
    public static SubStatusCodes ConfigurationOperationCancelled;
    public static SubStatusCodes InvalidAccountConfiguration;
    public static SubStatusCodes FederationDoesnotExistOrIsLocked;
    public static SubStatusCodes PartitionFailoverErrorCode;
    public static SubStatusCodes OperationManagerDequeuePumpStopped;
    public static SubStatusCodes PrepareTimeLimitExceeded;
    public static SubStatusCodes ClientTcpChannelFull;
    public static SubStatusCodes BWTermCountLimitExceeded;
    public static SubStatusCodes RUBudgetExceeded;
    public static SubStatusCodes GatewayThrottled;
    public static SubStatusCodes StoredProcedureConcurrency;
    public static SubStatusCodes ThottleDueToSplit;
    public static SubStatusCodes AadClientCredentialsGrantFailure;
    public static SubStatusCodes AadServiceUnavailable;
    public static SubStatusCodes KeyVaultAuthenticationFailure;
    public static SubStatusCodes KeyVaultKeyNotFound;
    public static SubStatusCodes KeyVaultServiceUnavailable;
    public static SubStatusCodes KeyVaultWrapUnwrapFailure;
    public static SubStatusCodes InvalidKeyVaultKeyURI;
    public static SubStatusCodes InvalidInputBytes;
    public static SubStatusCodes KeyVaultInternalServerError;
    public static SubStatusCodes KeyVaultDNSNotResolved;
    public static SubStatusCodes InvalidKeyVaultCertURI;
    public static SubStatusCodes InvalidKeyVaultKeyAndCertURI;
    public static SubStatusCodes CustomerKeyRotated;
    public static SubStatusCodes MissingRequestParameter;
    public static SubStatusCodes InvalidKeyVaultSecretURI;
    public static SubStatusCodes UndefinedDefaultIdentity;
    public static SubStatusCodes NspOutboundDenied;
    public static SubStatusCodes KeyVaultNotFound;
    public static SubStatusCodes MissingAuthHeader;
    public static SubStatusCodes InvalidAuthHeaderFormat;
    public static SubStatusCodes AadAuthDisabled;
    public static SubStatusCodes AadTokenInvalidFormat;
    public static SubStatusCodes AadTokenInvalidSignature;
    public static SubStatusCodes AadTokenNotYetValid;
    public static SubStatusCodes AadTokenExpired;
    public static SubStatusCodes AadTokenInvalidIssuer;
    public static SubStatusCodes AadTokenInvalidAudience;
    public static SubStatusCodes AadTokenInvalidScope;
    public static SubStatusCodes FailedToGetAadToken;
    public static SubStatusCodes AadTokenMissingObjectIdentifier;
    public static SubStatusCodes SasTokenAuthDisabled;
    public static SubStatusCodes AadTokenInvalidSigningKey;
    public static SubStatusCodes AadTokenGroupExpansionError;
    public static SubStatusCodes LocalAuthDisabled;
    public static SubStatusCodes RbacOperationNotSupported;
    public static SubStatusCodes RbacUnauthorizedMetadataRequest;
    public static SubStatusCodes RbacUnauthorizedNameBasedDataRequest;
    public static SubStatusCodes RbacUnauthorizedRidBasedDataRequest;
    public static SubStatusCodes RbacRidCannotBeResolved;
    public static SubStatusCodes RbacMissingUserId;
    public static SubStatusCodes RbacMissingAction;
    public static SubStatusCodes RbacRequestWasNotAuthorized;
    public static SubStatusCodes NspInboundDenied;
    public static SubStatusCodes NspAuthorizationFailed;
    public static SubStatusCodes NspNoResult;
    public static SubStatusCodes NspInvalidParam;
    public static SubStatusCodes NspInvalidEvalResult;
    public static SubStatusCodes NspNotInitiated;
    public static SubStatusCodes NspOperationNotSupported;
    public static SubStatusCodes ListResourceFeedThrottled;
    public static SubStatusCodes MutualTlsClientAuthFailed;
    public static SubStatusCodes LocationsModified;
    public static SubStatusCodes PartitionMigrationWaitForFullSyncReceivedInternalServerErrorDuringCompleteMigrationFromBackend;
    public static SubStatusCodes PartitionMigrationWaitForFullSyncReceivedInternalServerErrorDuringAbortMigrationFromBackend;
    public static SubStatusCodes PartitionMigrationFinalizeMigrationsDidNotCompleteInTenRetries;
    public static SubStatusCodes AZMigrationCancelledForPendingUserOperation;
    public static SubStatusCodes TransportGenerated410;
    public static SubStatusCodes TimeoutGenerated410;
    public static SubStatusCodes TransportGenerated503;
    public static SubStatusCodes Client_CPUOverload;
    public static SubStatusCodes Client_ThreadStarvation;
    public static SubStatusCodes Channel_Closed;
    public static SubStatusCodes MalformedContinuationToken;
    public static SubStatusCodes Server_NameCacheIsStaleExceededRetryLimit;
    public static SubStatusCodes Server_PartitionKeyRangeGoneExceededRetryLimit;
    public static SubStatusCodes Server_CompletingSplitExceededRetryLimit;
    public static SubStatusCodes Server_CompletingPartitionMigrationExceededRetryLimit;
    public static SubStatusCodes ServerGenerated410;
    public static SubStatusCodes Server_GlobalStrongWriteBarrierNotMet;
    public static SubStatusCodes Server_ReadQuorumNotMet;
    public static SubStatusCodes ServerGenerated503;
    public static SubStatusCodes Server_NoValidStoreResponse;
    public static SubStatusCodes MissingPartitionKeyInDataTransfer;
    public static SubStatusCodes InvalidPartitionKeyInDataTransfer;
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.SubStatusCodesExtensions : object {
    private static Dictionary`2<int, string> CodeNameMap;
    private static int SDKGeneratedSubStatusStartingCode;
    private static SubStatusCodesExtensions();
    [ExtensionAttribute]
public static string ToSubStatusCodeString(SubStatusCodes code);
    [ExtensionAttribute]
public static bool IsSDKGeneratedSubStatus(SubStatusCodes code);
}
[FlagsAttribute]
internal enum Microsoft.Azure.Documents.SupportedSerializationFormats : Enum {
    public int value__;
    public static SupportedSerializationFormats None;
    public static SupportedSerializationFormats JsonText;
    public static SupportedSerializationFormats CosmosBinary;
    public static SupportedSerializationFormats HybridRow;
}
internal class Microsoft.Azure.Documents.SystemDocument : Resource {
}
internal enum Microsoft.Azure.Documents.SystemDocumentType : Enum {
    public int value__;
    public static SystemDocumentType PartitionKey;
    public static SystemDocumentType MaterializedViewLeaseDocument;
    public static SystemDocumentType MaterializedViewBuilderOwnershipDocument;
    public static SystemDocumentType MaterializedViewLeaseStoreInitDocument;
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.TaskFactoryExtensions : object {
    [ExtensionAttribute]
public static Task StartNewOnCurrentTaskSchedulerAsync(TaskFactory taskFactory, Action action);
    [ExtensionAttribute]
public static Task StartNewOnCurrentTaskSchedulerAsync(TaskFactory taskFactory, Action action, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task StartNewOnCurrentTaskSchedulerAsync(TaskFactory taskFactory, Action action, TaskCreationOptions creationOptions);
    [ExtensionAttribute]
public static Task`1<TResult> StartNewOnCurrentTaskSchedulerAsync(TaskFactory taskFactory, Func`1<TResult> function);
    [ExtensionAttribute]
public static Task`1<TResult> StartNewOnCurrentTaskSchedulerAsync(TaskFactory taskFactory, Func`1<TResult> function, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TResult> StartNewOnCurrentTaskSchedulerAsync(TaskFactory taskFactory, Func`1<TResult> function, TaskCreationOptions creationOptions);
}
internal abstract class Microsoft.Azure.Documents.Telemetry.CosmosDistributedContextPropagatorBase : object {
    internal abstract virtual void Inject(Activity activity, INameValueCollection headers);
}
internal class Microsoft.Azure.Documents.Telemetry.DefaultCosmosDistributedContextPropagator : CosmosDistributedContextPropagatorBase {
    private Action`2<Activity, Action`2<string, string>> propagator;
    internal DefaultCosmosDistributedContextPropagator(Action`2<Activity, Action`2<string, string>> propagator);
    internal virtual void Inject(Activity activity, INameValueCollection headers);
}
internal class Microsoft.Azure.Documents.Telemetry.DistributedTracingOptions : object {
    public static string NetworkLevelPrefix;
    public static string DiagnosticNamespace;
    public static string ResourceProviderNamespace;
    [CompilerGeneratedAttribute]
private bool <IsDistributedTracingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<DocumentServiceRequest, bool> <RequestEnabledPredicate>k__BackingField;
    [CompilerGeneratedAttribute]
private CosmosDistributedContextPropagatorBase <Propagator>k__BackingField;
    internal bool IsDistributedTracingEnabled { get; internal set; }
    internal Func`2<DocumentServiceRequest, bool> RequestEnabledPredicate { get; internal set; }
    internal CosmosDistributedContextPropagatorBase Propagator { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_IsDistributedTracingEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsDistributedTracingEnabled(bool value);
    [CompilerGeneratedAttribute]
internal Func`2<DocumentServiceRequest, bool> get_RequestEnabledPredicate();
    [CompilerGeneratedAttribute]
internal void set_RequestEnabledPredicate(Func`2<DocumentServiceRequest, bool> value);
    [CompilerGeneratedAttribute]
internal CosmosDistributedContextPropagatorBase get_Propagator();
    [CompilerGeneratedAttribute]
internal void set_Propagator(CosmosDistributedContextPropagatorBase value);
}
internal class Microsoft.Azure.Documents.Telemetry.OpenTelemetryRecorder : object {
    private static string DateTimeFormat;
    private DiagnosticScope scope;
    private DistributedTracingOptions options;
    private DocumentServiceRequest request;
    public OpenTelemetryRecorder(DiagnosticScope scope, DocumentServiceRequest request, DistributedTracingOptions options);
    public void Record(Uri addressUri, Exception exception, StoreResponse storeResponse);
    public sealed virtual void Dispose();
}
internal static class Microsoft.Azure.Documents.Telemetry.OpenTelemetryRecorderFactory : object {
    private static Lazy`1<DiagnosticScopeFactory> LazyScopeFactory;
    private static OpenTelemetryRecorderFactory();
    public static OpenTelemetryRecorder CreateRecorder(DistributedTracingOptions options, DocumentServiceRequest request);
}
internal class Microsoft.Azure.Documents.TimeoutHelper : object {
    private DateTime startTime;
    private TimeSpan timeOut;
    private CancellationToken cancellationToken;
    public TimeoutHelper(TimeSpan timeOut, CancellationToken cancellationToken);
    public bool IsElapsed();
    public TimeSpan GetRemainingTime();
    public void ThrowTimeoutIfElapsed();
    public void ThrowGoneIfElapsed();
}
internal class Microsoft.Azure.Documents.TimerPool : object {
    [ThreadStaticAttribute]
private static Random PooledTimerBucketSelector;
    private Timer timer;
    private ConcurrentDictionary`2[] pooledTimersByTimeout;
    private TimeSpan minSupportedTimeout;
    private object timerConcurrencyLock;
    private bool isRunning;
    private bool isDisposed;
    public TimeSpan MinSupportedTimeout { get; }
    internal ConcurrentDictionary`2[] PooledTimersByTimeout { get; }
    public TimerPool(int minSupportedTimerDelayInSeconds, int maxBucketsForPools);
    public TimeSpan get_MinSupportedTimeout();
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
    private void DisposeAllPooledTimers();
    private void OnTimer(object stateInfo);
    internal ConcurrentDictionary`2[] get_PooledTimersByTimeout();
    public PooledTimer GetPooledTimer(int timeoutInSeconds);
    public PooledTimer GetPooledTimer(TimeSpan timeout);
    public long SubscribeForTimeouts(PooledTimer pooledTimer);
}
internal class Microsoft.Azure.Documents.TransportAddressHealthState : object {
    private Nullable`1<DateTime> lastUnknownTimestamp;
    private Nullable`1<DateTime> lastUnhealthyPendingTimestamp;
    private Nullable`1<DateTime> lastUnhealthyTimestamp;
    private HealthStatus healthStatus;
    private string healthStatusDiagnosticString;
    private IReadOnlyList`1<string> healthStatusDiagnosticEnumerable;
    public TransportAddressHealthState(Uri transportUri, HealthStatus healthStatus, Nullable`1<DateTime> lastUnknownTimestamp, Nullable`1<DateTime> lastUnhealthyPendingTimestamp, Nullable`1<DateTime> lastUnhealthyTimestamp);
    public HealthStatus GetHealthStatus();
    public string GetHealthStatusDiagnosticString();
    public IEnumerable`1<string> GetHealthStatusDiagnosticsAsReadOnlyEnumerable();
    internal Nullable`1<DateTime> GetLastKnownTimestampByHealthStatus(HealthStatus healthStatus);
}
internal class Microsoft.Azure.Documents.TransportAddressUri : object {
    private static TimeSpan idleTimeInMinutes;
    private string uriToString;
    private Nullable`1<DateTime> lastFailedRequestUtc;
    private TransportAddressHealthState healthState;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathAndQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerKey <ReplicaServerKey>k__BackingField;
    public Uri Uri { get; }
    public string PathAndQuery { get; }
    public ServerKey ReplicaServerKey { get; }
    public TransportAddressUri(Uri addressUri);
    private static TransportAddressUri();
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public string get_PathAndQuery();
    [CompilerGeneratedAttribute]
public ServerKey get_ReplicaServerKey();
    public bool IsUnhealthy();
    public void SetUnhealthy();
    public void SetConnected();
    public void SetRefreshedIfUnhealthy();
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(TransportAddressUri other);
    public virtual bool Equals(object obj);
    public void ResetHealthStatus(HealthStatus status, Nullable`1<DateTime> lastUnknownTimestamp, Nullable`1<DateTime> lastUnhealthyPendingTimestamp, Nullable`1<DateTime> lastUnhealthyTimestamp);
    public TransportAddressHealthState GetCurrentHealthState();
    public HealthStatus GetEffectiveHealthStatus();
    public bool ShouldRefreshHealthStatus();
    private void SetHealthStatus(TransportAddressHealthState previousState, HealthStatus status);
    private void CreateAndUpdateCurrentHealthState(HealthStatus healthStatus, Nullable`1<DateTime> lastUnknownTimestamp, Nullable`1<DateTime> lastUnhealthyPendingTimestamp, Nullable`1<DateTime> lastUnhealthyTimestamp, TransportAddressHealthState previousState);
}
internal abstract class Microsoft.Azure.Documents.TransportClient : object {
    public virtual void Dispose();
    public virtual Task`1<StoreResponse> InvokeResourceOperationAsync(Uri physicalAddress, DocumentServiceRequest request);
    public virtual Task`1<StoreResponse> InvokeResourceOperationAsync(TransportAddressUri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreateOfferAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> GetOfferAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListOffersAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteOfferAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReplaceOfferAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> QueryOfferAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListDatabasesAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> HeadDatabasesAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> GetDatabaseAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreateDatabaseAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> UpsertDatabaseAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> PatchDatabaseAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReplaceDatabaseAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteDatabaseAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> QueryDatabasesAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListDocumentCollectionsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> GetDocumentCollectionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> HeadDocumentCollectionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreateDocumentCollectionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> PatchDocumentCollectionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReplaceDocumentCollectionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteDocumentCollectionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> QueryDocumentCollectionsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreateClientEncryptionKeyAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReadClientEncryptionKeyAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteClientEncryptionKeyAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReadClientEncryptionKeyFeedAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReplaceClientEncryptionKeyFeedAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListStoredProceduresAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> GetStoredProcedureAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreateStoredProcedureAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> UpsertStoredProcedureAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReplaceStoredProcedureAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteStoredProcedureAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> QueryStoredProceduresAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListTriggersAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> GetTriggerAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreateTriggerAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> UpsertTriggerAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReplaceTriggerAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteTriggerAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> QueryTriggersAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListUserDefinedFunctionsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> GetUserDefinedFunctionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreateUserDefinedFunctionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> UpsertUserDefinedFunctionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReplaceUserDefinedFunctionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteUserDefinedFunctionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> QueryUserDefinedFunctionsAsync(Uri physicalAddress, DocumentServiceRequest request);
    internal Task`1<StoreResponse> ListSystemDocumentsAsync(Uri physicalAddress, DocumentServiceRequest request);
    internal Task`1<StoreResponse> GetSystemDocumentAsync(Uri physicalAddress, DocumentServiceRequest request);
    internal Task`1<StoreResponse> CreateSystemDocumentAsync(Uri physicalAddress, DocumentServiceRequest request);
    internal Task`1<StoreResponse> ReplaceSystemDocumentAsync(Uri physicalAddress, DocumentServiceRequest request);
    internal Task`1<StoreResponse> DeleteSystemDocumentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListConflictsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> GetConflictAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteConflictAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> QueryConflictsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListDocumentsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> GetDocumentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreateDocumentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> UpsertDocumentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> PatchDocumentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReplaceDocumentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteDocumentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> QueryDocumentsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListAttachmentsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> GetAttachmentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreateAttachmentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> UpsertAttachmentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReplaceAttachmentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteAttachmentAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> QueryAttachmentsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListUsersAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> GetUserAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreateUserAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> UpsertUserAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> PatchUserAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReplaceUserAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteUserAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> QueryUsersAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListPermissionsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> GetPermissionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreatePermissionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> UpsertPermissionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> PatchPermissionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReplacePermissionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeletePermissionAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> QueryPermissionsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ListRecordsAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CreateRecordAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ReadRecordAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> PatchRecordAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> DeleteRecordAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> ExecuteAsync(Uri physicalAddress, DocumentServiceRequest request);
    public Task`1<StoreResponse> CompleteUserTransaction(Uri physicalAddress, DocumentServiceRequest request);
    public static void ThrowServerException(string resourceAddress, StoreResponse storeResponse, Uri physicalAddress, Guid activityId, DocumentServiceRequest request);
    protected Task`1<StoreResponse> InvokeQueryStoreAsync(Uri physicalAddress, ResourceType resourceType, DocumentServiceRequest request);
    internal virtual Task`1<StoreResponse> InvokeStoreAsync(TransportAddressUri physicalAddress, ResourceOperation resourceOperation, DocumentServiceRequest request);
    internal abstract virtual Task`1<StoreResponse> InvokeStoreAsync(Uri physicalAddress, ResourceOperation resourceOperation, DocumentServiceRequest request);
    internal virtual Task OpenConnectionAsync(Uri physicalAddress);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.TransportClient/<GetErrorResponseAsync>d__105")]
protected static Task`1<string> GetErrorResponseAsync(HttpResponseMessage responseMessage);
    protected static string GetErrorResponse(StoreResponse storeResponse, string defaultMessage, INameValueCollection& responseHeaders);
    protected static string GetErrorFromStream(Stream responseStream);
    protected static void LogException(Uri physicalAddress, string activityId);
    protected static void LogException(Exception exception, Uri physicalAddress, string rid, Guid activityId);
    protected static void LogGoneException(Uri physicalAddress, string activityId);
    protected static UInt32 GetExceptionSubStatus(INameValueCollection responseHeaders, string errorMessage, Uri physicalAddress);
}
internal enum Microsoft.Azure.Documents.TransportErrorCode : Enum {
    public int value__;
    public static TransportErrorCode Unknown;
    public static TransportErrorCode ChannelOpenFailed;
    public static TransportErrorCode ChannelOpenTimeout;
    public static TransportErrorCode DnsResolutionFailed;
    public static TransportErrorCode DnsResolutionTimeout;
    public static TransportErrorCode ConnectFailed;
    public static TransportErrorCode ConnectTimeout;
    public static TransportErrorCode SslNegotiationFailed;
    public static TransportErrorCode SslNegotiationTimeout;
    public static TransportErrorCode TransportNegotiationTimeout;
    public static TransportErrorCode RequestTimeout;
    public static TransportErrorCode ChannelMultiplexerClosed;
    public static TransportErrorCode SendFailed;
    public static TransportErrorCode SendLockTimeout;
    public static TransportErrorCode SendTimeout;
    public static TransportErrorCode ReceiveFailed;
    public static TransportErrorCode ReceiveTimeout;
    public static TransportErrorCode ReceiveStreamClosed;
    public static TransportErrorCode ConnectionBroken;
    public static TransportErrorCode ChannelWaitingToOpenTimeout;
}
internal class Microsoft.Azure.Documents.TransportException : Exception {
    private static Lazy`1<Dictionary`2<TransportErrorCode, string>> lazyMessageMap;
    private static TransportExceptionCounters transportExceptionCounters;
    private object mutex;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <RequestStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <RequestEndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceType <ResourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationType <OperationType>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportErrorCode <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <RequestUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UserRequestSent>k__BackingField;
    public string Message { get; }
    public DateTime Timestamp { get; private set; }
    public Nullable`1<DateTime> RequestStartTime { get; public set; }
    public Nullable`1<DateTime> RequestEndTime { get; public set; }
    public ResourceType ResourceType { get; public set; }
    public OperationType OperationType { get; public set; }
    public TransportErrorCode ErrorCode { get; private set; }
    public Guid ActivityId { get; private set; }
    public Uri RequestUri { get; private set; }
    public bool UserRequestSent { get; private set; }
    public TransportException(TransportErrorCode errorCode, Exception innerException, Guid activityId, Uri requestUri, string sourceDescription, bool userPayload, bool payloadSent);
    private static TransportException();
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_RequestStartTime();
    [CompilerGeneratedAttribute]
public void set_RequestStartTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_RequestEndTime();
    [CompilerGeneratedAttribute]
public void set_RequestEndTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public ResourceType get_ResourceType();
    [CompilerGeneratedAttribute]
public void set_ResourceType(ResourceType value);
    [CompilerGeneratedAttribute]
public OperationType get_OperationType();
    [CompilerGeneratedAttribute]
public void set_OperationType(OperationType value);
    [CompilerGeneratedAttribute]
public TransportErrorCode get_ErrorCode();
    [CompilerGeneratedAttribute]
private void set_ErrorCode(TransportErrorCode value);
    [CompilerGeneratedAttribute]
public Guid get_ActivityId();
    [CompilerGeneratedAttribute]
private void set_ActivityId(Guid value);
    [CompilerGeneratedAttribute]
public Uri get_RequestUri();
    [CompilerGeneratedAttribute]
private void set_RequestUri(Uri value);
    [CompilerGeneratedAttribute]
public bool get_UserRequestSent();
    [CompilerGeneratedAttribute]
private void set_UserRequestSent(bool value);
    public static bool IsTimeout(TransportErrorCode errorCode);
    private static bool IsUserRequestSent(TransportErrorCode errorCode, bool userPayload, bool payloadSent);
    private static string LoadMessage(TransportErrorCode errorCode);
    private static string GetErrorText(TransportErrorCode errorCode);
    private static Dictionary`2<TransportErrorCode, string> GetErrorTextMap();
    private static void UpdateCounters(Uri requestUri, Exception innerException);
    internal static void SetCounters(TransportExceptionCounters transportExceptionCounters);
}
internal class Microsoft.Azure.Documents.TransportExceptionCounters : object {
    internal virtual void IncrementDecryptionFailures();
    internal virtual void IncrementEphemeralPortExhaustion();
}
internal class Microsoft.Azure.Documents.TransportPerformanceCounters : object {
    internal virtual void IncrementRntbdRequestCount(ResourceType resourceType, OperationType operationType);
    internal virtual void IncrementRntbdResponseCount(ResourceType resourceType, OperationType operationType, int statusCode);
    internal virtual void IncrementRntbdConnectionEstablishedCount();
    internal virtual void IncrementRntbdConnectionClosedCount();
    internal virtual void LogRntbdBytesSentCount(ResourceType resourceType, OperationType operationType, Nullable`1<long> bytes);
    internal virtual void LogRntbdBytesReceivedCount(ResourceType resourceType, OperationType operationType, Nullable`1<long> bytes);
}
internal class Microsoft.Azure.Documents.TransportRequestStats : object {
    private static string RequestStageCreated;
    private static string RequestStageChannelAcquisitionStarted;
    private static string RequestStagePipelined;
    private static string RequestStageSent;
    private static string RequestStageReceived;
    private static string RequestStageCompleted;
    private static string RequestStageFailed;
    private ValueStopwatch stopwatch;
    private DateTime requestCreatedTime;
    private Nullable`1<TimeSpan> channelAcquisitionStartedTime;
    private Nullable`1<TimeSpan> requestPipelinedTime;
    private Nullable`1<TimeSpan> requestSentTime;
    private Nullable`1<TimeSpan> requestReceivedTime;
    private Nullable`1<TimeSpan> requestCompletedTime;
    private Nullable`1<TimeSpan> requestFailedTime;
    [CompilerGeneratedAttribute]
private RequestStage <CurrentStage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RequestSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RequestBodySizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ResponseMetadataSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ResponseBodySizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <NumberOfInflightRequestsToEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <NumberOfOpenConnectionsToEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <RequestWaitingForConnectionInitialization>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <NumberOfInflightRequestsInConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ConnectionLastSendAttemptTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ConnectionLastSendTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ConnectionLastReceiveTime>k__BackingField;
    public RequestStage CurrentStage { get; private set; }
    public Nullable`1<long> RequestSizeInBytes { get; public set; }
    public Nullable`1<long> RequestBodySizeInBytes { get; public set; }
    public Nullable`1<long> ResponseMetadataSizeInBytes { get; public set; }
    public Nullable`1<long> ResponseBodySizeInBytes { get; public set; }
    public Nullable`1<int> NumberOfInflightRequestsToEndpoint { get; public set; }
    public Nullable`1<int> NumberOfOpenConnectionsToEndpoint { get; public set; }
    public Nullable`1<bool> RequestWaitingForConnectionInitialization { get; public set; }
    public Nullable`1<int> NumberOfInflightRequestsInConnection { get; public set; }
    public Nullable`1<DateTime> ConnectionLastSendAttemptTime { get; public set; }
    public Nullable`1<DateTime> ConnectionLastSendTime { get; public set; }
    public Nullable`1<DateTime> ConnectionLastReceiveTime { get; public set; }
    [CompilerGeneratedAttribute]
public RequestStage get_CurrentStage();
    [CompilerGeneratedAttribute]
private void set_CurrentStage(RequestStage value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RequestSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_RequestSizeInBytes(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RequestBodySizeInBytes();
    [CompilerGeneratedAttribute]
public void set_RequestBodySizeInBytes(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ResponseMetadataSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_ResponseMetadataSizeInBytes(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ResponseBodySizeInBytes();
    [CompilerGeneratedAttribute]
public void set_ResponseBodySizeInBytes(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_NumberOfInflightRequestsToEndpoint();
    [CompilerGeneratedAttribute]
public void set_NumberOfInflightRequestsToEndpoint(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_NumberOfOpenConnectionsToEndpoint();
    [CompilerGeneratedAttribute]
public void set_NumberOfOpenConnectionsToEndpoint(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_RequestWaitingForConnectionInitialization();
    [CompilerGeneratedAttribute]
public void set_RequestWaitingForConnectionInitialization(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_NumberOfInflightRequestsInConnection();
    [CompilerGeneratedAttribute]
public void set_NumberOfInflightRequestsInConnection(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ConnectionLastSendAttemptTime();
    [CompilerGeneratedAttribute]
public void set_ConnectionLastSendAttemptTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ConnectionLastSendTime();
    [CompilerGeneratedAttribute]
public void set_ConnectionLastSendTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ConnectionLastReceiveTime();
    [CompilerGeneratedAttribute]
public void set_ConnectionLastReceiveTime(Nullable`1<DateTime> value);
    public void RecordState(RequestStage requestStage);
    public virtual string ToString();
    public void AppendJsonString(StringBuilder stringBuilder);
    private void AppendServiceEndpointStats(StringBuilder stringBuilder);
    private void AppendConnectionStats(StringBuilder stringBuilder);
    private static void AppendRequestStats(StringBuilder stringBuilder, string eventName, DateTime requestStartTime, TimeSpan startTime, Nullable`1<TimeSpan> endTime, Nullable`1<TimeSpan> failedTime);
}
internal class Microsoft.Azure.Documents.Trigger : Resource {
    [JsonPropertyAttribute]
public string Body { get; public set; }
    [JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
[JsonPropertyAttribute]
public TriggerType TriggerType { get; public set; }
    [JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
[JsonPropertyAttribute]
public TriggerOperation TriggerOperation { get; public set; }
    public string get_Body();
    public void set_Body(string value);
    public TriggerType get_TriggerType();
    public void set_TriggerType(TriggerType value);
    public TriggerOperation get_TriggerOperation();
    public void set_TriggerOperation(TriggerOperation value);
}
internal enum Microsoft.Azure.Documents.TriggerOperation : Enum {
    public short value__;
    public static TriggerOperation All;
    public static TriggerOperation Create;
    public static TriggerOperation Update;
    public static TriggerOperation Delete;
    public static TriggerOperation Replace;
    public static TriggerOperation Upsert;
}
internal enum Microsoft.Azure.Documents.TriggerType : Enum {
    public byte value__;
    public static TriggerType Pre;
    public static TriggerType Post;
}
internal class Microsoft.Azure.Documents.UInt128 : ValueType {
    public static UInt128 MaxValue;
    public static UInt128 MinValue;
    private static int Length;
    private ulong low;
    private ulong high;
    private UInt128(ulong low, ulong high);
    private static UInt128();
    public static UInt128 op_Implicit(int value);
    public static UInt128 op_Implicit(long value);
    public static UInt128 op_Implicit(UInt32 value);
    public static UInt128 op_Implicit(ulong value);
    public static UInt128 op_Addition(UInt128 augend, UInt128 addend);
    public static UInt128 op_Subtraction(UInt128 minuend, UInt128 subtrahend);
    public static bool op_LessThan(UInt128 left, UInt128 right);
    public static bool op_GreaterThan(UInt128 left, UInt128 right);
    public static bool op_LessThanOrEqual(UInt128 left, UInt128 right);
    public static bool op_GreaterThanOrEqual(UInt128 left, UInt128 right);
    public static bool op_Equality(UInt128 left, UInt128 right);
    public static bool op_Inequality(UInt128 left, UInt128 right);
    public static UInt128 op_BitwiseAnd(UInt128 left, UInt128 right);
    public static UInt128 op_BitwiseOr(UInt128 left, UInt128 right);
    public static UInt128 op_ExclusiveOr(UInt128 left, UInt128 right);
    public static UInt128 Create(ulong low, ulong high);
    public static UInt128 FromByteArray(Byte[] bytes, int start);
    public static Byte[] ToByteArray(UInt128 uint128);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt128 other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UInt128 other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public ulong GetHigh();
    public ulong GetLow();
}
internal class Microsoft.Azure.Documents.UnauthorizedException : DocumentClientException {
    public UnauthorizedException(string message);
    public UnauthorizedException(string message, SubStatusCodes subStatusCode);
    public UnauthorizedException(string message, HttpResponseHeaders headers, Uri requestUri);
    public UnauthorizedException(Exception innerException);
    public UnauthorizedException(string message, Exception innerException);
    public UnauthorizedException(string message, Exception innerException, SubStatusCodes subStatusCode);
    public UnauthorizedException(string message, INameValueCollection headers, Uri requestUri);
    public UnauthorizedException(string message, Exception innerException, HttpResponseHeaders headers, Uri requestUri, Nullable`1<SubStatusCodes> subStatusCode);
    private UnauthorizedException(SerializationInfo info, StreamingContext context);
    private void SetDescription();
}
internal class Microsoft.Azure.Documents.Undefined : object {
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static Undefined Value;
    private static Undefined();
    public sealed virtual bool Equals(Undefined other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
internal class Microsoft.Azure.Documents.UniqueIndexReIndexContext : JsonSerializable {
    private Collection`1<UniqueKey> uniqueKeys;
    [JsonPropertyAttribute]
public Collection`1<UniqueKey> UniqueKeys { get; public set; }
    [JsonPropertyAttribute]
public ulong LastDocumentGLSN { get; public set; }
    public Collection`1<UniqueKey> get_UniqueKeys();
    public void set_UniqueKeys(Collection`1<UniqueKey> value);
    public ulong get_LastDocumentGLSN();
    public void set_LastDocumentGLSN(ulong value);
    internal virtual void OnSave();
    internal virtual void Validate();
}
internal class Microsoft.Azure.Documents.UniqueKey : JsonSerializable {
    private Collection`1<string> paths;
    private JObject filter;
    [JsonPropertyAttribute]
public Collection`1<string> Paths { get; public set; }
    [JsonPropertyAttribute]
internal JObject Filter { get; internal set; }
    public Collection`1<string> get_Paths();
    public void set_Paths(Collection`1<string> value);
    internal JObject get_Filter();
    internal void set_Filter(JObject value);
    internal virtual void Validate();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual void OnSave();
}
internal class Microsoft.Azure.Documents.UniqueKeyPolicy : JsonSerializable {
    private Collection`1<UniqueKey> uniqueKeys;
    [JsonPropertyAttribute]
public Collection`1<UniqueKey> UniqueKeys { get; public set; }
    public Collection`1<UniqueKey> get_UniqueKeys();
    public void set_UniqueKeys(Collection`1<UniqueKey> value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual void OnSave();
    internal virtual void Validate();
}
internal class Microsoft.Azure.Documents.UnixDateTimeConverter : DateTimeConverterBase {
    private static DateTime UnixStartTime;
    private static UnixDateTimeConverter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
internal static class Microsoft.Azure.Documents.UrlUtility : object {
    internal static string ConcatenateUrlsString(string baseUrl, String[] relativeParts);
    internal static string ConcatenateUrlsString(string baseUrl, string relativePart);
    internal static string ConcatenateUrlsString(Uri baseUrl, string relativePart);
    internal static void ExtractTargetInfo(Uri uri, String& tenantId, String& applicationName, String& serviceId, String& partitionKey, String& replicaId);
    internal static string ConcatenateUrlsString(Uri baseUrl, Uri relativePart);
    internal static Uri ConcatenateUrls(string baseUrl, string relativePart);
    internal static Uri ConcatenateUrls(Uri baseUrl, string relativePart);
    internal static Uri ConcatenateUrls(Uri baseUrl, Uri relativePart);
    internal static NameValueCollection ParseQuery(string queryString);
    internal static string CreateQuery(INameValueCollection parsedQuery);
    internal static Uri SetQuery(Uri url, string query);
    internal static string RemoveLeadingQuestionMark(string path);
    internal static string RemoveTrailingSlash(string path);
    internal static StringSegment RemoveTrailingSlashes(StringSegment path);
    internal static string RemoveTrailingSlashes(string path);
    internal static StringSegment RemoveLeadingSlashes(StringSegment path);
    internal static string RemoveLeadingSlash(string path);
    internal static string RemoveLeadingSlashes(string path);
    internal static string AddTrailingSlash(string path);
    internal static string AddLeadingSlash(string path);
    internal static string GetLeftPartOfAuthority(Uri uri);
    internal static string GetLeftPartOfPath(Uri uri);
    public static String[] SplitAndRemoveEmptyEntries(string str, Char[] seperators);
    public static String[] SplitAndRemoveEmptyEntries(string str, Char[] seperators, int count);
    internal static string ExtractIdFromItemUri(Uri uri, int i);
    internal static string ExtractTenantIdFromUri(Uri uri);
    internal static string ExtractTenantIdFromUriIgnoreAccountsPattern(Uri uri);
    internal static string ExtractIdOrFullNameFromUri(string path, Boolean& isNameBased);
    internal static string ExtractIdFromItemUri(Uri uri);
    internal static string ExtractIdFromCollectionUri(Uri uri);
    internal static string ExtractItemIdAndCollectionIdFromUri(Uri uri, String& collectionId);
    internal static string ExtractFileNameFromUri(Uri uri);
    internal static bool IsLocalHostUri(Uri uri);
    private static bool IsAccountsPathSegmentPartOfFirstItem(Uri uri);
    internal static bool IsAstoriaUrl(Uri url);
    internal static Uri ToNativeUrl(Uri astoriaUrl);
    private static bool ParseAstoriaUrl(string astoriaUrl, Element[]& urlElements);
    private static bool ParseAstoriaUrlPart(string urlPart, String& name, String& id);
}
internal class Microsoft.Azure.Documents.User : Resource {
    public string PermissionsLink { get; }
    public string get_PermissionsLink();
}
internal class Microsoft.Azure.Documents.UserAgentContainer : object {
    private static string baseUserAgent;
    private string userAgent;
    private Byte[] userAgentUTF8;
    private string suffix;
    private static int maxSuffixLength;
    public string UserAgent { get; }
    public Byte[] UserAgentUTF8 { get; }
    public string Suffix { get; public set; }
    internal string BaseUserAgent { get; }
    private static UserAgentContainer();
    public UserAgentContainer(string suffix);
    public string get_UserAgent();
    public Byte[] get_UserAgentUTF8();
    public string get_Suffix();
    public void set_Suffix(string value);
    internal virtual string get_BaseUserAgent();
}
internal class Microsoft.Azure.Documents.UserDefinedFunction : Resource {
    [JsonPropertyAttribute]
public string Body { get; public set; }
    public string get_Body();
    public void set_Body(string value);
}
internal class Microsoft.Azure.Documents.UserDefinedType : Resource {
}
internal class Microsoft.Azure.Documents.ValueStopwatch : ValueType {
    private static double ToTimeSpanTicks;
    private static double ToMilliseconds;
    public static long Frequency;
    public static bool IsHighResolution;
    private long state;
    public bool IsRunning { get; }
    public long ElapsedTicks { get; }
    public long ElapsedMilliseconds { get; }
    public TimeSpan Elapsed { get; }
    private static ValueStopwatch();
    [IsReadOnlyAttribute]
public bool get_IsRunning();
    [IsReadOnlyAttribute]
public long get_ElapsedTicks();
    [IsReadOnlyAttribute]
public long get_ElapsedMilliseconds();
    [IsReadOnlyAttribute]
public TimeSpan get_Elapsed();
    public void Reset();
    public void Restart();
    public void Start();
    public void Stop();
    public static long GetTimestamp();
    public static ValueStopwatch StartNew();
}
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
internal enum Microsoft.Azure.Documents.VectorDataType : Enum {
    public int value__;
    [EnumMemberAttribute]
public static VectorDataType Float32;
    [EnumMemberAttribute]
public static VectorDataType Uint8;
    [EnumMemberAttribute]
public static VectorDataType Int8;
}
internal class Microsoft.Azure.Documents.VectorEmbeddingPolicy : JsonSerializable {
    private Collection`1<Embedding> embeddings;
    [JsonPropertyAttribute]
public Collection`1<Embedding> Embeddings { get; public set; }
    public Collection`1<Embedding> get_Embeddings();
    public void set_Embeddings(Collection`1<Embedding> value);
    internal virtual void OnSave();
}
internal class Microsoft.Azure.Documents.VectorIndexPath : JsonSerializable {
    [JsonPropertyAttribute]
public string Path { get; public set; }
    [JsonPropertyAttribute]
public VectorIndexType Type { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public VectorIndexType get_Type();
    public void set_Type(VectorIndexType value);
    public sealed virtual object Clone();
    internal virtual void OnSave();
}
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
internal enum Microsoft.Azure.Documents.VectorIndexType : Enum {
    public int value__;
    [EnumMemberAttribute]
public static VectorIndexType Flat;
    [EnumMemberAttribute]
public static VectorIndexType DiskANN;
    [EnumMemberAttribute]
public static VectorIndexType QuantizedFlat;
}
internal class Microsoft.Azure.Documents.VectorSessionToken : object {
    private static IReadOnlyDictionary`2<UInt32, long> DefaultLocalLsnByRegion;
    private static char SegmentSeparator;
    private static string SegmentSeparatorString;
    private static char RegionProgressSeparator;
    private string sessionToken;
    private long version;
    private long globalLsn;
    private IReadOnlyDictionary`2<UInt32, long> localLsnByRegion;
    public long LSN { get; }
    private VectorSessionToken(long version, long globalLsn, IReadOnlyDictionary`2<UInt32, long> localLsnByRegion, string sessionToken);
    public VectorSessionToken(VectorSessionToken other, long globalLSN);
    private static VectorSessionToken();
    public static bool TryCreate(string sessionToken, ISessionToken& parsedSessionToken);
    public sealed virtual long get_LSN();
    public sealed virtual bool Equals(ISessionToken obj);
    public sealed virtual bool IsValid(ISessionToken otherSessionToken);
    public sealed virtual ISessionToken Merge(ISessionToken obj);
    private sealed virtual override string Microsoft.Azure.Documents.ISessionToken.ConvertToString();
    private bool AreRegionProgressEqual(IReadOnlyDictionary`2<UInt32, long> other);
    private static bool AreAllLocalLsnByRegionsGreaterThanOrEqual(VectorSessionToken higherToken, VectorSessionToken lowerToken);
    private static bool TryParseSessionToken(string sessionToken, Int64& version, Int64& globalLsn, IReadOnlyDictionary`2& localLsnByRegion);
    private static bool TryParseUintTillRegionProgressSeparator(string input, Int32& index, UInt32& value);
    private static bool TryParseLongSegment(string input, Int32& index, Int64& value);
}
internal static class Microsoft.Azure.Documents.VersionUtility : object {
    private static string versionDateTimeFormat;
    private static string previewVersionDateTimeFormat;
    private static IReadOnlyDictionary`2<string, DateTime> KnownDateTimes;
    private static VersionUtility();
    internal static bool IsLaterThan(string compareVersion, string baseVersion);
    internal static bool IsValidApiVersion(string apiVersion);
    internal static bool IsPreviewApiVersion(string apiVersion);
    internal static bool IsLaterThan(string compareVersion, DateTime baseVersion);
    internal static bool IsLaterThanNotEqualTo(string compareVersion, DateTime baseVersion);
    internal static DateTime ParseNonPreviewDateTimeExact(string apiVersion);
    private static bool TryParseApiVersion(string apiVersion, DateTime& apiVersionDate);
    private static bool TryParseApiVersionCore(string apiVersion, DateTime& apiVersionDate);
}
internal static class Microsoft.Azure.Documents.WebExceptionUtility : object {
    public static bool IsWebExceptionRetriable(Exception ex);
    private static bool IsWebExceptionRetriableInternal(Exception ex);
}
internal class Microsoft.Azure.Documents.WFConstants : object {
    public static int DefaultFabricNameResolutionTimeoutInSeconds;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
