[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Testing.AnalyzerInfo : object {
    private static ConstructorInfo AttributeBaseClassCtor;
    private static ConstructorInfo AttributeUsageCtor;
    private static PropertyInfo AttributeUsageAllowMultipleProperty;
    private static object s_codeGenerationLock;
    [NullableAttribute("2")]
private static Type s_generatedAnalysisContextType;
    private static AnalyzerInfo();
    public static bool HasConfiguredGeneratedCodeAnalysis(DiagnosticAnalyzer analyzer);
    private static CustomAnalysisContext CreateAnalysisContext();
    private static Type GenerateAnalysisContextType();
    private static ModuleBuilder CreateModuleBuilder();
    private static AssemblyBuilder CreateAssemblyBuilder();
    private static void SkipVisibilityChecksFor(AssemblyBuilder assemblyBuilder, ModuleBuilder moduleBuilder, Type type);
    private static ConstructorInfo GetMagicAttributeCtor(ModuleBuilder moduleBuilder);
    private static TypeInfo EmitMagicAttribute(ModuleBuilder moduleBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.Testing.AnalyzerTest`1 : object {
    private static Lazy`1<IExportProviderFactory> ExportProviderFactory;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static TVerifier <Verify>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <DefaultFilePathPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <DefaultTestProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private CompilerDiagnostics <CompilerDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MarkupOptions <MarkupOptions>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private SolutionState <TestState>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Dictionary`2<string, string> <XmlReferences>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TestBehaviors <TestBehaviors>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private List`1<string> <DisabledDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ReferenceAssemblies <ReferenceAssemblies>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Action`3<Diagnostic, DiagnosticResult, IVerifier> <DiagnosticVerifier>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private List`1<Func`2<OptionSet, OptionSet>> <OptionsTransforms>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private List`1<Func`3<Solution, ProjectId, Solution>> <SolutionTransforms>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TimeSpan <MatchDiagnosticsTimeout>k__BackingField;
    private ConcurrentBag`1<Workspace> _workspaces;
    protected static TVerifier Verify { get; }
    protected string DefaultFilePathPrefix { get; }
    protected string DefaultTestProjectName { get; }
    protected string DefaultFilePath { get; }
    protected string DefaultFileExt { get; }
    public string Language { get; }
    unknown string TestCode {public set; }
    public List`1<DiagnosticResult> ExpectedDiagnostics { get; }
    public CompilerDiagnostics CompilerDiagnostics { get; public set; }
    public MarkupOptions MarkupOptions { get; public set; }
    public SolutionState TestState { get; }
    public Dictionary`2<string, string> XmlReferences { get; }
    public TestBehaviors TestBehaviors { get; public set; }
    public List`1<string> DisabledDiagnostics { get; }
    public ReferenceAssemblies ReferenceAssemblies { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`3<Diagnostic, DiagnosticResult, IVerifier> DiagnosticVerifier { get; public set; }
    public List`1<Func`2<OptionSet, OptionSet>> OptionsTransforms { get; }
    public List`1<Func`3<Solution, ProjectId, Solution>> SolutionTransforms { get; }
    protected TimeSpan MatchDiagnosticsTimeout { get; protected set; }
    private static AnalyzerTest`1();
    [CompilerGeneratedAttribute]
protected static TVerifier get_Verify();
    [CompilerGeneratedAttribute]
protected virtual string get_DefaultFilePathPrefix();
    [CompilerGeneratedAttribute]
protected virtual string get_DefaultTestProjectName();
    protected virtual string get_DefaultFilePath();
    protected abstract virtual string get_DefaultFileExt();
    public abstract virtual string get_Language();
    public void set_TestCode(string value);
    public List`1<DiagnosticResult> get_ExpectedDiagnostics();
    [CompilerGeneratedAttribute]
public CompilerDiagnostics get_CompilerDiagnostics();
    [CompilerGeneratedAttribute]
public void set_CompilerDiagnostics(CompilerDiagnostics value);
    [CompilerGeneratedAttribute]
public MarkupOptions get_MarkupOptions();
    [CompilerGeneratedAttribute]
public void set_MarkupOptions(MarkupOptions value);
    [CompilerGeneratedAttribute]
public SolutionState get_TestState();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_XmlReferences();
    [CompilerGeneratedAttribute]
public TestBehaviors get_TestBehaviors();
    [CompilerGeneratedAttribute]
public void set_TestBehaviors(TestBehaviors value);
    [CompilerGeneratedAttribute]
public List`1<string> get_DisabledDiagnostics();
    [CompilerGeneratedAttribute]
public ReferenceAssemblies get_ReferenceAssemblies();
    [CompilerGeneratedAttribute]
public void set_ReferenceAssemblies(ReferenceAssemblies value);
    [CompilerGeneratedAttribute]
public Action`3<Diagnostic, DiagnosticResult, IVerifier> get_DiagnosticVerifier();
    [CompilerGeneratedAttribute]
public void set_DiagnosticVerifier(Action`3<Diagnostic, DiagnosticResult, IVerifier> value);
    [CompilerGeneratedAttribute]
public List`1<Func`2<OptionSet, OptionSet>> get_OptionsTransforms();
    [CompilerGeneratedAttribute]
public List`1<Func`3<Solution, ProjectId, Solution>> get_SolutionTransforms();
    [CompilerGeneratedAttribute]
protected TimeSpan get_MatchDiagnosticsTimeout();
    [CompilerGeneratedAttribute]
protected void set_MatchDiagnosticsTimeout(TimeSpan value);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.AnalyzerTest`1/<RunAsync>d__62")]
[DebuggerStepThroughAttribute]
public Task RunAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.AnalyzerTest`1/<RunImplAsync>d__63")]
[DebuggerStepThroughAttribute]
protected virtual Task RunImplAsync(CancellationToken cancellationToken);
    protected internal virtual DiagnosticDescriptor GetDefaultDiagnostic(DiagnosticAnalyzer[] analyzers);
    protected string FormatVerifierMessage(ImmutableArray`1<DiagnosticAnalyzer> analyzers, Diagnostic actual, DiagnosticResult expected, string message);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.AnalyzerTest`1/<VerifyDiagnosticsAsync>d__66")]
[DebuggerStepThroughAttribute]
protected Task VerifyDiagnosticsAsync(EvaluatedProjectState primaryProject, ImmutableArray`1<EvaluatedProjectState> additionalProjects, DiagnosticResult[] expected, IVerifier verifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.AnalyzerTest`1/<VerifyGeneratedCodeDiagnosticsAsync>d__67")]
[DebuggerStepThroughAttribute]
private Task VerifyGeneratedCodeDiagnosticsAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, ValueTuple`2[] sources, EvaluatedProjectState primaryProject, ImmutableArray`1<EvaluatedProjectState> additionalProjects, DiagnosticResult[] expected, IVerifier verifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.AnalyzerTest`1/<VerifySuppressionDiagnosticsAsync>d__68")]
[DebuggerStepThroughAttribute]
private Task VerifySuppressionDiagnosticsAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, ValueTuple`2[] sources, EvaluatedProjectState primaryProject, ImmutableArray`1<EvaluatedProjectState> additionalProjects, DiagnosticResult[] expected, IVerifier verifier, CancellationToken cancellationToken);
    private void VerifyDiagnosticResults(IEnumerable`1<ValueTuple`2<Project, Diagnostic>> actualResults, ImmutableArray`1<DiagnosticAnalyzer> analyzers, DiagnosticResult[] expectedResults, IVerifier verifier);
    private ImmutableArray`1<ValueTuple`2<Nullable`1<ValueTuple`2<Project, Diagnostic>>, Nullable`1<DiagnosticResult>>> MatchDiagnostics(ValueTuple`2[] actualResults, DiagnosticResult[] expectedResults);
    private void VerifyDiagnosticLocation(ImmutableArray`1<DiagnosticAnalyzer> analyzers, Diagnostic diagnostic, DiagnosticResult expectedDiagnostic, Location actual, DiagnosticLocation expected, IVerifier verifier);
    private void VerifyLinePosition(ImmutableArray`1<DiagnosticAnalyzer> analyzers, Diagnostic diagnostic, DiagnosticResult expectedDiagnostic, LinePosition actualLinePosition, LinePosition expectedLinePosition, string positionText, IVerifier verifier);
    private static string FormatDiagnostics(ImmutableArray`1<DiagnosticAnalyzer> analyzers, string defaultFilePath, Diagnostic[] diagnostics);
    private static string FormatDiagnostics(ImmutableArray`1<DiagnosticAnalyzer> analyzers, string defaultFilePath, DiagnosticResult[] diagnostics);
    private static bool IsSubjectToExclusion(DiagnosticResult result, ImmutableArray`1<DiagnosticAnalyzer> analyzers, ValueTuple`2[] sources);
    private static bool IsSuppressible(ImmutableArray`1<DiagnosticAnalyzer> analyzers, DiagnosticResult result, ValueTuple`2[] sources);
    private static bool IsInSourceFile(DiagnosticResult result, ValueTuple`2[] sources);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.AnalyzerTest`1/<GetSortedDiagnosticsAsync>d__78")]
[DebuggerStepThroughAttribute]
private Task`1<ImmutableArray`1<ValueTuple`2<Project, Diagnostic>>> GetSortedDiagnosticsAsync(EvaluatedProjectState primaryProject, ImmutableArray`1<EvaluatedProjectState> additionalProjects, ImmutableArray`1<DiagnosticAnalyzer> analyzers, IVerifier verifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.AnalyzerTest`1/<GetSortedDiagnosticsAsync>d__79")]
[DebuggerStepThroughAttribute]
protected Task`1<ImmutableArray`1<ValueTuple`2<Project, Diagnostic>>> GetSortedDiagnosticsAsync(Solution solution, ImmutableArray`1<DiagnosticAnalyzer> analyzers, ImmutableArray`1<ValueTuple`2<Project, Diagnostic>> additionalDiagnostics, CompilerDiagnostics compilerDiagnostics, IVerifier verifier, CancellationToken cancellationToken);
    protected virtual Task`1<Compilation> GetProjectCompilationAsync(Project project, IVerifier verifier, CancellationToken cancellationToken);
    private static bool IsCompilerDiagnostic(Diagnostic diagnostic);
    protected virtual bool IsCompilerDiagnosticIncluded(Diagnostic diagnostic, CompilerDiagnostics compilerDiagnostics);
    protected virtual AnalyzerOptions GetAnalyzerOptions(Project project);
    protected virtual CompilationWithAnalyzers CreateCompilationWithAnalyzers(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.AnalyzerTest`1/<GetSolutionAsync>d__85")]
[DebuggerStepThroughAttribute]
private Task`1<Solution> GetSolutionAsync(EvaluatedProjectState primaryProject, ImmutableArray`1<EvaluatedProjectState> additionalProjects, IVerifier verifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.AnalyzerTest`1/<CreateProjectAsync>d__86")]
[DebuggerStepThroughAttribute]
protected Task`1<Project> CreateProjectAsync(EvaluatedProjectState primaryProject, ImmutableArray`1<EvaluatedProjectState> additionalProjects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.AnalyzerTest`1/<CreateProjectImplAsync>d__87")]
[DebuggerStepThroughAttribute]
protected virtual Task`1<Project> CreateProjectImplAsync(EvaluatedProjectState primaryProject, ImmutableArray`1<EvaluatedProjectState> additionalProjects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.AnalyzerTest`1/<CreateSolutionAsync>d__88")]
[DebuggerStepThroughAttribute]
protected virtual Task`1<Solution> CreateSolutionAsync(ProjectId projectId, EvaluatedProjectState projectState, CancellationToken cancellationToken);
    protected virtual Project ApplyCompilationOptions(Project project);
    public Workspace CreateWorkspace();
    protected virtual Workspace CreateWorkspaceImpl();
    protected abstract virtual CompilationOptions CreateCompilationOptions();
    protected abstract virtual ParseOptions CreateParseOptions();
    private static ValueTuple`2[] SortDistinctDiagnostics(IEnumerable`1<ValueTuple`2<Project, Diagnostic>> diagnostics);
    private static IReadOnlyList`1<object> GetArguments(Diagnostic diagnostic);
    protected abstract virtual IEnumerable`1<DiagnosticAnalyzer> GetDiagnosticAnalyzers();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private EvaluatedProjectState <RunImplAsync>b__63_1(ProjectState additionalProject);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static MatchQuality <MatchDiagnostics>g__RecursiveMatch|70_6(int firstActualIndex, int remainingActualItems, int firstExpectedIndex, int remainingExpectedItems, MatchQuality unmatchedActualResults, Boolean[] usedExpected, <>c__DisplayClass70_0& );
    [CompilerGeneratedAttribute]
internal static MatchQuality <MatchDiagnostics>g__Min|70_7(MatchQuality val1, MatchQuality val2);
    [CompilerGeneratedAttribute]
internal static MatchQuality <MatchDiagnostics>g__GetMatchValue|70_8(Diagnostic diagnostic, string diagnosticId, FileLinePositionSpan lineSpan, ImmutableArray`1<FileLinePositionSpan> additionalLineSpans, ImmutableArray`1<string> actualArguments, DiagnosticResult diagnosticResult, ImmutableArray`1<string> expectedArguments);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <MatchDiagnostics>g__IsLocationMatch|70_9(Diagnostic diagnostic, FileLinePositionSpan lineSpan, ImmutableArray`1<FileLinePositionSpan> additionalLineSpans, DiagnosticResult diagnosticResult, Boolean& matchSpanStart, Boolean& matchSpanEnd);
    [CompilerGeneratedAttribute]
internal static bool <MatchDiagnostics>g__IsLocationMatch2|70_10(Location actual, FileLinePositionSpan actualSpan, DiagnosticLocation expected, Boolean& matchSpanStart, Boolean& matchSpanEnd);
    [CompilerGeneratedAttribute]
internal static bool <MatchDiagnostics>g__IsSeverityMatch|70_11(Diagnostic actual, DiagnosticResult expected);
    [CompilerGeneratedAttribute]
internal static bool <MatchDiagnostics>g__IsMessageMatch|70_12(Diagnostic actual, ImmutableArray`1<string> actualArguments, DiagnosticResult expected, ImmutableArray`1<string> expectedArguments);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <FormatDiagnostics>g__AppendLocation|73_0(Location location, <>c__DisplayClass73_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <FormatDiagnostics>g__AppendLocation|74_0(DiagnosticLocation location, <>c__DisplayClass74_0& );
    [CompilerGeneratedAttribute]
internal static Solution <CreateProjectImplAsync>g__AddProjectReferences|87_1(Solution solution, ProjectId sourceProject, IEnumerable`1<ProjectId> targetProjects);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Testing.AnalyzerVerifier`3 : object {
    public static DiagnosticResult Diagnostic();
    public static DiagnosticResult Diagnostic(string diagnosticId);
    public static DiagnosticResult Diagnostic(DiagnosticDescriptor descriptor);
    public static Task VerifyAnalyzerAsync(string source, DiagnosticResult[] expected);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Testing.CodeActionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<CodeAction> GetNestedActions(CodeAction action);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.Testing.CodeActionTest`1 : AnalyzerTest`1<TVerifier> {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Nullable`1<int> <CodeActionIndex>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <CodeActionEquivalenceKey>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Action`2<CodeAction, IVerifier> <CodeActionVerifier>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private CodeActionValidationMode <CodeActionValidationMode>k__BackingField;
    public Nullable`1<int> CodeActionIndex { get; public set; }
    [NullableAttribute("2")]
public string CodeActionEquivalenceKey { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<CodeAction, IVerifier> CodeActionVerifier { get; public set; }
    public CodeActionValidationMode CodeActionValidationMode { get; public set; }
    public Type SyntaxKindType { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CodeActionIndex();
    [CompilerGeneratedAttribute]
public void set_CodeActionIndex(Nullable`1<int> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_CodeActionEquivalenceKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_CodeActionEquivalenceKey(string value);
    [CompilerGeneratedAttribute]
public Action`2<CodeAction, IVerifier> get_CodeActionVerifier();
    [CompilerGeneratedAttribute]
public void set_CodeActionVerifier(Action`2<CodeAction, IVerifier> value);
    [CompilerGeneratedAttribute]
public CodeActionValidationMode get_CodeActionValidationMode();
    [CompilerGeneratedAttribute]
public void set_CodeActionValidationMode(CodeActionValidationMode value);
    public abstract virtual Type get_SyntaxKindType();
    protected static bool CodeActionExpected(SolutionState state);
    protected static bool HasAnyChange(ProjectState oldState, ProjectState newState, bool recursive);
    [NullableContextAttribute("2")]
protected static CodeAction TryGetCodeActionToApply(int iteration, ImmutableArray`1<CodeAction> actions, Nullable`1<int> codeActionIndex, string codeActionEquivalenceKey, Action`2<CodeAction, IVerifier> codeActionVerifier, IVerifier verifier);
    protected virtual ImmutableArray`1<CodeAction> FilterCodeActions(ImmutableArray`1<CodeAction> actions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.CodeActionTest`1/<ApplyCodeActionAsync>d__22")]
[DebuggerStepThroughAttribute]
protected Task`1<Project> ApplyCodeActionAsync(Project project, CodeAction codeAction, IVerifier verifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.CodeActionTest`1/<RecreateProjectDocumentsAsync>d__23")]
[DebuggerStepThroughAttribute]
private Task`1<Project> RecreateProjectDocumentsAsync(Project project, IVerifier verifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.CodeActionTest`1/<RecreateDocumentAsync>d__24")]
[DebuggerStepThroughAttribute]
private static Task`1<Document> RecreateDocumentAsync(Document document, CancellationToken cancellationToken);
    private string TreeToString(SyntaxNodeOrToken syntaxNodeOrToken, CodeActionValidationMode validationMode);
    private void TreeToString(SyntaxNodeOrToken syntaxNodeOrToken, string indent, CodeActionValidationMode validationMode, StringBuilder result);
    [CompilerGeneratedAttribute]
internal static string <TreeToString>g__Escape|26_0(string text);
    [CompilerGeneratedAttribute]
private string <TreeToString>g__Kind|26_1(int syntaxKind);
}
public enum Microsoft.CodeAnalysis.Testing.CodeActionValidationMode : Enum {
    public int value__;
    public static CodeActionValidationMode None;
    public static CodeActionValidationMode SemanticStructure;
    public static CodeActionValidationMode Full;
}
public enum Microsoft.CodeAnalysis.Testing.CompilerDiagnostics : Enum {
    public int value__;
    public static CompilerDiagnostics None;
    public static CompilerDiagnostics Errors;
    public static CompilerDiagnostics Warnings;
    public static CompilerDiagnostics Suggestions;
    public static CompilerDiagnostics All;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Testing.ComposableCatalogExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ComposableCatalog WithDocumentTextDifferencingService(ComposableCatalog catalog);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Testing.DefaultVerifier : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableStack`1<string> <Context>k__BackingField;
    protected ImmutableStack`1<string> Context { get; }
    protected DefaultVerifier(ImmutableStack`1<string> context);
    [CompilerGeneratedAttribute]
protected ImmutableStack`1<string> get_Context();
    public virtual void Empty(string collectionName, IEnumerable`1<T> collection);
    public virtual void NotEmpty(string collectionName, IEnumerable`1<T> collection);
    public virtual void LanguageIsSupported(string language);
    public virtual void Equal(T expected, T actual, string message);
    [NullableContextAttribute("2")]
public virtual void True(bool assert, string message);
    [NullableContextAttribute("2")]
public virtual void False(bool assert, string message);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
public virtual void Fail(string message);
    public virtual void SequenceEqual(IEnumerable`1<T> expected, IEnumerable`1<T> actual, IEqualityComparer`1<T> equalityComparer, string message);
    public virtual IVerifier PushContext(string context);
    protected virtual string CreateMessage(string message);
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Testing.DiagnosticLocation : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private FileLinePositionSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DiagnosticLocationOptions <Options>k__BackingField;
    public FileLinePositionSpan Span { get; }
    public DiagnosticLocationOptions Options { get; }
    public DiagnosticLocation(FileLinePositionSpan span, DiagnosticLocationOptions options);
    [CompilerGeneratedAttribute]
public FileLinePositionSpan get_Span();
    [CompilerGeneratedAttribute]
public DiagnosticLocationOptions get_Options();
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.Testing.DiagnosticLocationOptions : Enum {
    public int value__;
    public static DiagnosticLocationOptions None;
    public static DiagnosticLocationOptions IgnoreLength;
    public static DiagnosticLocationOptions InterpretAsMarkupKey;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.Testing.DiagnosticOptions : Enum {
    public int value__;
    public static DiagnosticOptions None;
    public static DiagnosticOptions IgnoreAdditionalLocations;
    public static DiagnosticOptions IgnoreSeverity;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Testing.DiagnosticResult : ValueType {
    public static DiagnosticResult[] EmptyDiagnosticResults;
    private static Object[] EmptyArguments;
    [NullableAttribute("0")]
private ImmutableArray`1<DiagnosticLocation> _spans;
    private bool _suppressMessage;
    [NullableAttribute("2")]
private string _message;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DiagnosticSeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DiagnosticOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Id>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private LocalizableString <MessageFormat>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Object[] <MessageArguments>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Nullable`1<bool> <IsSuppressed>k__BackingField;
    [NullableAttribute("0")]
public ImmutableArray`1<DiagnosticLocation> Spans { get; }
    public DiagnosticSeverity Severity { get; }
    public DiagnosticOptions Options { get; }
    public string Id { get; }
    [NullableAttribute("2")]
public string Message { get; }
    [NullableAttribute("2")]
public LocalizableString MessageFormat { get; }
    [NullableAttribute("2")]
public Object[] MessageArguments { get; }
    public bool HasLocation { get; }
    public Nullable`1<bool> IsSuppressed { get; }
    public DiagnosticResult(string id, DiagnosticSeverity severity);
    public DiagnosticResult(DiagnosticDescriptor descriptor);
    [NullableContextAttribute("2")]
private DiagnosticResult(ImmutableArray`1<DiagnosticLocation> spans, bool suppressMessage, string message, DiagnosticSeverity severity, DiagnosticOptions options, string id, LocalizableString messageFormat, Object[] messageArguments, Nullable`1<bool> isSuppressed);
    private static DiagnosticResult();
    [NullableContextAttribute("0")]
public ImmutableArray`1<DiagnosticLocation> get_Spans();
    [CompilerGeneratedAttribute]
public DiagnosticSeverity get_Severity();
    [CompilerGeneratedAttribute]
public DiagnosticOptions get_Options();
    [CompilerGeneratedAttribute]
public string get_Id();
    [NullableContextAttribute("2")]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public LocalizableString get_MessageFormat();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Object[] get_MessageArguments();
    public bool get_HasLocation();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsSuppressed();
    public static DiagnosticResult CompilerError(string identifier);
    public static DiagnosticResult CompilerWarning(string identifier);
    public DiagnosticResult WithSeverity(DiagnosticSeverity severity);
    public DiagnosticResult WithOptions(DiagnosticOptions options);
    public DiagnosticResult WithArguments(Object[] arguments);
    [NullableContextAttribute("2")]
public DiagnosticResult WithMessage(string message);
    public DiagnosticResult WithMessageFormat(LocalizableString messageFormat);
    public DiagnosticResult WithIsSuppressed(Nullable`1<bool> isSuppressed);
    public DiagnosticResult WithNoLocation();
    public DiagnosticResult WithLocation(int line, int column);
    public DiagnosticResult WithLocation(LinePosition location);
    public DiagnosticResult WithLocation(string path, int line, int column);
    public DiagnosticResult WithLocation(string path, LinePosition location);
    public DiagnosticResult WithLocation(string path, LinePosition location, DiagnosticLocationOptions options);
    public DiagnosticResult WithSpan(int startLine, int startColumn, int endLine, int endColumn);
    public DiagnosticResult WithSpan(string path, int startLine, int startColumn, int endLine, int endColumn);
    public DiagnosticResult WithSpan(FileLinePositionSpan span);
    public DiagnosticResult WithSpan(FileLinePositionSpan span, DiagnosticLocationOptions options);
    public DiagnosticResult WithLocation(int markupKey);
    public DiagnosticResult WithLocation(int markupKey, DiagnosticLocationOptions options);
    public DiagnosticResult WithDefaultPath(string path);
    internal DiagnosticResult WithAppliedMarkupLocations(ImmutableDictionary`2<string, FileLinePositionSpan> markupLocations);
    public DiagnosticResult WithLineOffset(int offset);
    private DiagnosticResult AppendSpan(FileLinePositionSpan span, DiagnosticLocationOptions options);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Testing.DictionaryExtensions : object {
    [ExtensionAttribute]
public static void AddRange(IDictionary`2<TKey, TValue> dictionary, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> function);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> function);
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
public class Microsoft.CodeAnalysis.Testing.EmptyDiagnosticAnalyzer : DiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Testing.ExceptionUtilities : object {
    public static Exception Unreachable { get; }
    public static Exception get_Unreachable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Testing.ExportProviderExtensions : object {
    [ExtensionAttribute]
public static CompositionContext AsCompositionContext(ExportProvider exportProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Testing.Extensions.DiagnosticExtensions : object {
    private static Func`2<Diagnostic, bool> s_isSuppressed;
    private static DiagnosticExtensions();
    [ExtensionAttribute]
public static bool IsSuppressed(Diagnostic diagnostic);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Testing.IEnumerableExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<object, bool> s_notNullTest;
    private static IEnumerableExtensions();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static DiagnosticResult[] ToOrderedArray(IEnumerable`1<DiagnosticResult> diagnosticResults);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Nullable`1<T> SingleOrNull(IEnumerable`1<T> source);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeAnalysis.Testing.IVerifier {
    public abstract virtual void Empty(string collectionName, IEnumerable`1<T> collection);
    public abstract virtual void Equal(T expected, T actual, string message);
    [NullableContextAttribute("2")]
public abstract virtual void True(bool assert, string message);
    [NullableContextAttribute("2")]
public abstract virtual void False(bool assert, string message);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
public abstract virtual void Fail(string message);
    public abstract virtual void LanguageIsSupported(string language);
    public abstract virtual void NotEmpty(string collectionName, IEnumerable`1<T> collection);
    public abstract virtual void SequenceEqual(IEnumerable`1<T> expected, IEnumerable`1<T> actual, IEqualityComparer`1<T> equalityComparer, string message);
    public abstract virtual IVerifier PushContext(string context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.Testing.IVerifierExtensions : object {
    private static IChunker s_lineChunker;
    private static IChunker s_lineEndingsPreservingChunker;
    private static InlineDiffBuilder s_diffBuilder;
    private static IVerifierExtensions();
    [ExtensionAttribute]
public static void EqualOrDiff(IVerifier verifier, string expected, string actual, string message);
}
public enum Microsoft.CodeAnalysis.Testing.MarkupMode : Enum {
    public int value__;
    public static MarkupMode None;
    public static MarkupMode Ignore;
    public static MarkupMode IgnoreFixable;
    public static MarkupMode Allow;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.Testing.MarkupOptions : Enum {
    public int value__;
    public static MarkupOptions None;
    public static MarkupOptions UseFirstDescriptor;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Testing.MatchQuality : ValueType {
    public static MatchQuality Full;
    public static MatchQuality None;
    private int _value;
    public MatchQuality(int value);
    private static MatchQuality();
    public static MatchQuality op_Addition(MatchQuality left, MatchQuality right);
    public static MatchQuality op_Subtraction(MatchQuality left, MatchQuality right);
    public static bool op_Equality(MatchQuality left, MatchQuality right);
    public static bool op_Inequality(MatchQuality left, MatchQuality right);
    public static bool op_LessThan(MatchQuality left, MatchQuality right);
    public static bool op_LessThanOrEqual(MatchQuality left, MatchQuality right);
    public static bool op_GreaterThan(MatchQuality left, MatchQuality right);
    public static bool op_GreaterThanOrEqual(MatchQuality left, MatchQuality right);
    public static MatchQuality RemainingUnmatched(int count);
    public sealed virtual int CompareTo(MatchQuality other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MatchQuality other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.Testing.MetadataReferenceCollection : List`1<MetadataReference> {
    private static ConcurrentDictionary`2<string, MetadataReference> s_referencesFromFiles;
    private static MetadataReferenceCollection();
    public void Add(Assembly assembly);
    public void Add(string path);
    private static MetadataReference GetOrCreateReference(string path);
}
public static class Microsoft.CodeAnalysis.Testing.MetadataReferences : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<string, DocumentationProvider> s_createDocumentationProvider;
    private static MetadataReferences();
    [NullableContextAttribute("1")]
internal static MetadataReference CreateReferenceFromFile(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Testing.Model.EvaluatedProjectState : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ReferenceAssemblies <ReferenceAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OutputKind <OutputKind>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DocumentationMode <DocumentationMode>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableArray`1<ValueTuple`2<string, SourceText>> <Sources>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableArray`1<ValueTuple`2<string, SourceText>> <GeneratedSources>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableArray`1<ValueTuple`2<string, SourceText>> <AdditionalFiles>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableArray`1<ValueTuple`2<string, SourceText>> <AnalyzerConfigFiles>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableArray`1<string> <AdditionalProjectReferences>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableArray`1<MetadataReference> <AdditionalReferences>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableArray`1<Diagnostic> <AdditionalDiagnostics>k__BackingField;
    public string Name { get; }
    public string AssemblyName { get; }
    public string Language { get; }
    public ReferenceAssemblies ReferenceAssemblies { get; }
    public OutputKind OutputKind { get; }
    public DocumentationMode DocumentationMode { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<string, SourceText>> Sources { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<string, SourceText>> GeneratedSources { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<string, SourceText>> AdditionalFiles { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<string, SourceText>> AnalyzerConfigFiles { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> AdditionalProjectReferences { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<MetadataReference> AdditionalReferences { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Diagnostic> AdditionalDiagnostics { get; }
    public EvaluatedProjectState(ProjectState state, ReferenceAssemblies defaultReferenceAssemblies);
    private EvaluatedProjectState(string name, string assemblyName, string language, ReferenceAssemblies referenceAssemblies, OutputKind outputKind, DocumentationMode documentationMode, ImmutableArray`1<ValueTuple`2<string, SourceText>> sources, ImmutableArray`1<ValueTuple`2<string, SourceText>> generatedSources, ImmutableArray`1<ValueTuple`2<string, SourceText>> additionalFiles, ImmutableArray`1<ValueTuple`2<string, SourceText>> analyzerConfigFiles, ImmutableArray`1<string> additionalProjectReferences, ImmutableArray`1<MetadataReference> additionalReferences, ImmutableArray`1<Diagnostic> additionalDiagnostics);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public ReferenceAssemblies get_ReferenceAssemblies();
    [CompilerGeneratedAttribute]
public OutputKind get_OutputKind();
    [CompilerGeneratedAttribute]
public DocumentationMode get_DocumentationMode();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValueTuple`2<string, SourceText>> get_Sources();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValueTuple`2<string, SourceText>> get_GeneratedSources();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValueTuple`2<string, SourceText>> get_AdditionalFiles();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValueTuple`2<string, SourceText>> get_AnalyzerConfigFiles();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_AdditionalProjectReferences();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MetadataReference> get_AdditionalReferences();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Diagnostic> get_AdditionalDiagnostics();
    public EvaluatedProjectState WithSources(ImmutableArray`1<ValueTuple`2<string, SourceText>> sources);
    public EvaluatedProjectState WithAdditionalDiagnostics(ImmutableArray`1<Diagnostic> additionalDiagnostics);
    [NullableContextAttribute("0")]
private EvaluatedProjectState With(Optional`1<string> name, Optional`1<string> assemblyName, Optional`1<string> language, Optional`1<ReferenceAssemblies> referenceAssemblies, Optional`1<OutputKind> outputKind, Optional`1<DocumentationMode> documentationMode, Optional`1<ImmutableArray`1<ValueTuple`2<string, SourceText>>> sources, Optional`1<ImmutableArray`1<ValueTuple`2<string, SourceText>>> generatedSources, Optional`1<ImmutableArray`1<ValueTuple`2<string, SourceText>>> additionalFiles, Optional`1<ImmutableArray`1<ValueTuple`2<string, SourceText>>> analyzerConfigFiles, Optional`1<ImmutableArray`1<string>> additionalProjectReferences, Optional`1<ImmutableArray`1<MetadataReference>> additionalReferences, Optional`1<ImmutableArray`1<Diagnostic>> additionalDiagnostics);
    private static T GetValueOrDefault(Optional`1<T> optionalValue, T defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Testing.PackageIdentity : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Version>k__BackingField;
    public string Id { get; }
    public string Version { get; }
    public PackageIdentity(string id, string version);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Version();
    internal PackageIdentity ToNuGetIdentity();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.Testing.ProjectCollection : Dictionary`2<string, ProjectState> {
    private string _defaultLanguage;
    private string _defaultExtension;
    public ProjectState Item { get; }
    public ProjectState Item { get; }
    public ProjectCollection(string defaultLanguage, string defaultExtension);
    public ProjectState get_Item(string projectName);
    public ProjectState get_Item(string projectName, string language);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Testing.ProjectExtensions : object {
    private static Func`2<Project, IEnumerable`1<TextDocument>> s_analyzerConfigDocuments;
    private static ProjectExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<TextDocument> AnalyzerConfigDocuments(Project project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Testing.ProjectState : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Language>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ReferenceAssemblies <ReferenceAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Nullable`1<OutputKind> <OutputKind>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Nullable`1<DocumentationMode> <DocumentationMode>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private SourceFileList <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private SourceFileCollection <GeneratedSources>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private SourceFileCollection <AdditionalFiles>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private SourceFileCollection <AnalyzerConfigFiles>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private List`1<Func`1<IEnumerable`1<ValueTuple`2<string, SourceText>>>> <AdditionalFilesFactories>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private List`1<string> <AdditionalProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MetadataReferenceCollection <AdditionalReferences>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <DefaultPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <DefaultExtension>k__BackingField;
    public string Name { get; }
    public string AssemblyName { get; }
    public string Language { get; }
    [NullableAttribute("2")]
public ReferenceAssemblies ReferenceAssemblies { get; public set; }
    public Nullable`1<OutputKind> OutputKind { get; public set; }
    public Nullable`1<DocumentationMode> DocumentationMode { get; public set; }
    public SourceFileList Sources { get; }
    public SourceFileCollection GeneratedSources { get; }
    public SourceFileCollection AdditionalFiles { get; }
    public SourceFileCollection AnalyzerConfigFiles { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<Func`1<IEnumerable`1<ValueTuple`2<string, SourceText>>>> AdditionalFilesFactories { get; }
    public List`1<string> AdditionalProjectReferences { get; }
    public MetadataReferenceCollection AdditionalReferences { get; }
    private protected string DefaultPrefix { get; }
    private protected string DefaultExtension { get; }
    public ProjectState(string name, string language, string defaultPrefix, string defaultExtension);
    internal ProjectState(ProjectState sourceState);
    [CompilerGeneratedAttribute]
public string get_Name();
    public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Language();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ReferenceAssemblies get_ReferenceAssemblies();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ReferenceAssemblies(ReferenceAssemblies value);
    [CompilerGeneratedAttribute]
public Nullable`1<OutputKind> get_OutputKind();
    [CompilerGeneratedAttribute]
public void set_OutputKind(Nullable`1<OutputKind> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DocumentationMode> get_DocumentationMode();
    [CompilerGeneratedAttribute]
public void set_DocumentationMode(Nullable`1<DocumentationMode> value);
    [CompilerGeneratedAttribute]
public SourceFileList get_Sources();
    [CompilerGeneratedAttribute]
public SourceFileCollection get_GeneratedSources();
    [CompilerGeneratedAttribute]
public SourceFileCollection get_AdditionalFiles();
    [CompilerGeneratedAttribute]
public SourceFileCollection get_AnalyzerConfigFiles();
    [CompilerGeneratedAttribute]
public List`1<Func`1<IEnumerable`1<ValueTuple`2<string, SourceText>>>> get_AdditionalFilesFactories();
    [CompilerGeneratedAttribute]
public List`1<string> get_AdditionalProjectReferences();
    [CompilerGeneratedAttribute]
public MetadataReferenceCollection get_AdditionalReferences();
    [CompilerGeneratedAttribute]
private protected string get_DefaultPrefix();
    [CompilerGeneratedAttribute]
private protected string get_DefaultExtension();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Testing.ReferenceAssemblies : object {
    private static string ReferenceAssembliesPackageVersion;
    private static FileSystemSemaphore Semaphore;
    private static ImmutableDictionary`2<PackageIdentity, string> s_packageToInstalledLocation;
    private static ImmutableHashSet`1<PackageIdentity> s_emptyPackages;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, ImmutableArray`1<MetadataReference>> _references;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private AssemblyIdentityComparer <AssemblyIdentityComparer>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PackageIdentity <ReferenceAssemblyPackage>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <ReferenceAssemblyPath>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableArray`1<string> <Assemblies>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableArray`1<string> <FacadeAssemblies>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableDictionary`2<string, ImmutableArray`1<string>> <LanguageSpecificAssemblies>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImmutableArray`1<PackageIdentity> <Packages>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <NuGetConfigFilePath>k__BackingField;
    public static ReferenceAssemblies Default { get; }
    public string TargetFramework { get; }
    public AssemblyIdentityComparer AssemblyIdentityComparer { get; }
    [NullableAttribute("2")]
public PackageIdentity ReferenceAssemblyPackage { get; }
    [NullableAttribute("2")]
public string ReferenceAssemblyPath { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Assemblies { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FacadeAssemblies { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<string, ImmutableArray`1<string>> LanguageSpecificAssemblies { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<PackageIdentity> Packages { get; }
    [NullableAttribute("2")]
public string NuGetConfigFilePath { get; }
    public ReferenceAssemblies(string targetFramework);
    public ReferenceAssemblies(string targetFramework, PackageIdentity referenceAssemblyPackage, string referenceAssemblyPath);
    [NullableContextAttribute("2")]
private ReferenceAssemblies(string targetFramework, AssemblyIdentityComparer assemblyIdentityComparer, PackageIdentity referenceAssemblyPackage, string referenceAssemblyPath, ImmutableArray`1<string> assemblies, ImmutableArray`1<string> facadeAssemblies, ImmutableDictionary`2<string, ImmutableArray`1<string>> languageSpecificAssemblies, ImmutableArray`1<PackageIdentity> packages, string nugetConfigFilePath);
    private static ReferenceAssemblies();
    public static ReferenceAssemblies get_Default();
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public AssemblyIdentityComparer get_AssemblyIdentityComparer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PackageIdentity get_ReferenceAssemblyPackage();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ReferenceAssemblyPath();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Assemblies();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_FacadeAssemblies();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ImmutableArray`1<string>> get_LanguageSpecificAssemblies();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<PackageIdentity> get_Packages();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_NuGetConfigFilePath();
    public ReferenceAssemblies WithAssemblyIdentityComparer(AssemblyIdentityComparer assemblyIdentityComparer);
    public ReferenceAssemblies WithAssemblies(ImmutableArray`1<string> assemblies);
    public ReferenceAssemblies WithFacadeAssemblies(ImmutableArray`1<string> facadeAssemblies);
    public ReferenceAssemblies AddAssemblies(ImmutableArray`1<string> assemblies);
    public ReferenceAssemblies AddFacadeAssemblies(ImmutableArray`1<string> facadeAssemblies);
    public ReferenceAssemblies WithLanguageSpecificAssemblies(ImmutableDictionary`2<string, ImmutableArray`1<string>> languageSpecificAssemblies);
    public ReferenceAssemblies WithLanguageSpecificAssemblies(string language, ImmutableArray`1<string> assemblies);
    public ReferenceAssemblies AddLanguageSpecificAssemblies(string language, ImmutableArray`1<string> assemblies);
    public ReferenceAssemblies WithPackages(ImmutableArray`1<PackageIdentity> packages);
    public ReferenceAssemblies AddPackages(ImmutableArray`1<PackageIdentity> packages);
    public ReferenceAssemblies WithNuGetConfigFilePath(string nugetConfigFilePath);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.ReferenceAssemblies/<ResolveAsync>d__49")]
[DebuggerStepThroughAttribute]
public Task`1<ImmutableArray`1<MetadataReference>> ResolveAsync(string language, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.ReferenceAssemblies/<ResolveCoreAsync>d__50")]
[DebuggerStepThroughAttribute]
private Task`1<ImmutableArray`1<MetadataReference>> ResolveCoreAsync(string language, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Testing.ReferenceAssemblies/<GetPackageDependenciesAsync>d__51")]
[DebuggerStepThroughAttribute]
private static Task GetPackageDependenciesAsync(PackageIdentity packageIdentity, NuGetFramework targetFramework, ImmutableArray`1<SourceRepository> repositories, SourceCacheContext cacheContext, ILogger logger, Builder<PackageIdentity, SourcePackageDependencyInfo> dependencies, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ResolveCoreAsync>b__50_4(PackageIdentity preferred);
    [CompilerGeneratedAttribute]
internal static string <ResolveCoreAsync>g__GetInstalledPath|50_0(PackagePathResolver localPathResolver, PackagePathResolver globalPathResolver, PackageIdentity packageIdentity);
    [CompilerGeneratedAttribute]
internal static string <ResolveCoreAsync>g__GetInstalledPath|50_18(PackagePathResolver resolver, PackageIdentity id);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<PackageDependency> <GetPackageDependenciesAsync>g__FilterDependencies|51_0(IEnumerable`1<PackageDependency> dependencies);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Testing.RoslynDebug : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b, string message);
    [ConditionalAttribute("DEBUG")]
public static void AssertNotNull(T value);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Testing.SolutionExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`7<Solution, DocumentId, string, SourceText, IEnumerable`1<string>, string, Solution> s_addAnalyzerConfigDocument;
    private static SolutionExtensions();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Solution AddAnalyzerConfigDocument(Solution solution, DocumentId documentId, string name, SourceText text, IEnumerable`1<string> folders, string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Testing.SolutionState : ProjectState {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Nullable`1<StateInheritanceMode> <InheritanceMode>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ProjectCollection <AdditionalProjects>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private List`1<DiagnosticResult> <ExpectedDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Nullable`1<MarkupMode> <MarkupHandling>k__BackingField;
    public Nullable`1<StateInheritanceMode> InheritanceMode { get; public set; }
    public ProjectCollection AdditionalProjects { get; }
    public List`1<DiagnosticResult> ExpectedDiagnostics { get; }
    public Nullable`1<MarkupMode> MarkupHandling { get; public set; }
    public SolutionState(string name, string language, string defaultPrefix, string defaultExtension);
    [CompilerGeneratedAttribute]
public Nullable`1<StateInheritanceMode> get_InheritanceMode();
    [CompilerGeneratedAttribute]
public void set_InheritanceMode(Nullable`1<StateInheritanceMode> value);
    [CompilerGeneratedAttribute]
public ProjectCollection get_AdditionalProjects();
    [CompilerGeneratedAttribute]
public List`1<DiagnosticResult> get_ExpectedDiagnostics();
    [CompilerGeneratedAttribute]
public Nullable`1<MarkupMode> get_MarkupHandling();
    [CompilerGeneratedAttribute]
public void set_MarkupHandling(Nullable`1<MarkupMode> value);
    public SolutionState WithInheritedValuesApplied(SolutionState baseState, ImmutableArray`1<string> fixableDiagnostics);
    private static bool HasAnyContentChanges(bool willInherit, SolutionState state, SolutionState baseState);
    private static bool ContentEqual(SourceFileCollection x, SourceFileCollection y);
    public SolutionState WithProcessedMarkup(MarkupOptions markupOptions, DiagnosticDescriptor defaultDiagnostic, ImmutableArray`1<DiagnosticDescriptor> supportedDiagnostics, ImmutableArray`1<string> fixableDiagnostics, string defaultPath);
    private ValueTuple`2<DiagnosticResult[], ValueTuple`2[]> ProcessMarkupSources(IEnumerable`1<ValueTuple`2<string, SourceText>> sources, IEnumerable`1<DiagnosticResult> explicitDiagnostics, ImmutableDictionary`2& markupLocations, MarkupOptions markupOptions, DiagnosticDescriptor defaultDiagnostic, ImmutableArray`1<DiagnosticDescriptor> supportedDiagnostics, ImmutableArray`1<string> fixableDiagnostics, string defaultPath);
    private Nullable`1<DiagnosticResult> CreateDiagnosticForPosition(MarkupOptions markupOptions, DiagnosticDescriptor defaultDiagnostic, ImmutableArray`1<DiagnosticDescriptor> supportedDiagnostics, ImmutableArray`1<string> fixableDiagnostics, string diagnosticId, string filename, SourceText content, int position);
    private Nullable`1<DiagnosticResult> CreateDiagnosticForSpan(MarkupOptions markupOptions, DiagnosticDescriptor defaultDiagnostic, ImmutableArray`1<DiagnosticDescriptor> supportedDiagnostics, ImmutableArray`1<string> fixableDiagnostics, string diagnosticId, string filename, SourceText content, TextSpan span);
    private Nullable`1<DiagnosticResult> CreateDiagnostic(MarkupOptions markupOptions, DiagnosticDescriptor defaultDiagnostic, ImmutableArray`1<DiagnosticDescriptor> supportedDiagnostics, ImmutableArray`1<string> fixableDiagnostics, string diagnosticId);
}
[TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.Testing.SourceFileCollection : List`1<ValueTuple`2<string, SourceText>> {
    public void Add(ValueTuple`2<string, string> file);
    public void Add(ValueTuple`3<Type, string, string> file);
    public void Add(ValueTuple`3<Type, string, SourceText> file);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Testing.SourceFileList : SourceFileCollection {
    private string _defaultPrefix;
    private string _defaultExtension;
    public SourceFileList(string defaultPrefix, string defaultExtension);
    public void Add(string content);
    public void Add(SourceText content);
}
public enum Microsoft.CodeAnalysis.Testing.StateInheritanceMode : Enum {
    public int value__;
    public static StateInheritanceMode AutoInherit;
    public static StateInheritanceMode Explicit;
    public static StateInheritanceMode AutoInheritAll;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.Testing.TestBehaviors : Enum {
    public int value__;
    public static TestBehaviors None;
    public static TestBehaviors SkipGeneratedCodeCheck;
    public static TestBehaviors SkipSuppressionCheck;
    public static TestBehaviors SkipGeneratedSourcesCheck;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Testing.TestFileMarkupParser : object {
    private static string PositionString;
    private static string SpanStartString;
    private static string SpanEndString;
    private static string NamedSpanStartString;
    private static string NamedSpanEndString;
    private static string NamedSpanNumberedEndString;
    private static Regex s_namedSpanStartRegex;
    private static Regex s_namedSpanEndRegex;
    private static TestFileMarkupParser();
    private static void Parse(string input, String& output, ImmutableArray`1& positions, ImmutableDictionary`2& spans);
    private static void Parse(string input, String& output, ImmutableArray`1& positions, ImmutableArray`1& startPositions, ImmutableArray`1& endPositions);
    private static void AddMatch(string input, string value, int currentIndex, List`1<ValueTuple`2<int, string>> matches);
    public static void GetPositionsAndSpans(string input, String& output, ImmutableArray`1& positions, ImmutableDictionary`2& spans);
    public static void GetPositionAndSpans(string input, String& output, Nullable`1& cursorPosition, ImmutableDictionary`2& spans);
    public static void GetPositionAndSpans(string input, Nullable`1& cursorPosition, ImmutableDictionary`2& spans);
    public static void GetPositionAndSpans(string input, String& output, Int32& cursorPosition, ImmutableDictionary`2& spans);
    public static void GetSpans(string input, String& output, ImmutableDictionary`2& spans);
    public static void GetPositionAndSpans(string input, String& output, Nullable`1& cursorPosition, ImmutableArray`1& spans);
    [NullableContextAttribute("0")]
public static void GetPositionAndSpans(string input, Nullable`1& cursorPosition, ImmutableArray`1& spans);
    public static void GetPositionAndSpans(string input, String& output, Int32& cursorPosition, ImmutableArray`1& spans);
    public static void GetPosition(string input, String& output, Int32& cursorPosition);
    public static void GetPositionAndSpan(string input, String& output, Int32& cursorPosition, TextSpan& span);
    public static void GetSpans(string input, String& output, ImmutableArray`1& spans);
    public static void GetSpan(string input, String& output, TextSpan& span);
    public static string CreateTestFile(string code, int position);
    public static string CreateTestFile(string code, Nullable`1<int> position, ImmutableArray`1<TextSpan> spans);
    public static string CreateTestFile(string code, Nullable`1<int> position, ImmutableDictionary`2<string, ImmutableArray`1<TextSpan>> spans);
    public static string CreateTestFile(string code, ImmutableArray`1<int> positions, ImmutableDictionary`2<string, ImmutableArray`1<TextSpan>> spans);
    private static void AddSpanString(StringBuilder sb, IEnumerable`1<KeyValuePair`2<string, ImmutableArray`1<TextSpan>>> items, int position, bool start);
    [CompilerGeneratedAttribute]
internal static ValueTuple`3<int, int, string> <Parse>g__GetLastUnmatchedSpanStart|9_0(Builder<ValueTuple`3<int, int, string>> startPositionsBuilder, Builder<ValueTuple`3<int, int, string>> endPositionsBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Testing.TestXmlReferenceResolver : XmlReferenceResolver {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Dictionary`2<string, string> <XmlReferences>k__BackingField;
    public Dictionary`2<string, string> XmlReferences { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_XmlReferences();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual Stream OpenRead(string resolvedPath);
    public virtual string ResolveReference(string path, string baseFilePath);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
