public abstract class Analyzer.Utilities.AbstractVersionCheckAnalyzer : DiagnosticAnalyzer {
    private static string RuleId;
    private static string AnalyzerPackageVersion;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessageFormat;
    private static LocalizableString s_localizableDescription;
    public static DiagnosticDescriptor Rule;
    private static Version s_MicrosoftCodeAnalysisMinVersion;
    private static Version s_MicrosoftCodeAnalysisDogfoodVersion;
    private static Version s_MicrosoftCodeAnalysisVersion;
    private static bool s_ShouldExecuteOperationAnalyzers { get; }
    protected string AnalyzerPackageName { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AbstractVersionCheckAnalyzer();
    private static bool get_s_ShouldExecuteOperationAnalyzers();
    protected abstract virtual string get_AnalyzerPackageName();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__15_0(CompilationStartAnalysisContext compilationStartContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__15_1(CompilationAnalysisContext compilationContext);
}
internal static class Analyzer.Utilities.AnalyzerUtilitiesResources : object {
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private static ResourceManager <ResourceManager>k__BackingField;
    internal static CultureInfo Culture { get; internal set; }
    internal static ResourceManager ResourceManager { get; }
    internal static string CategoryDesign { get; }
    internal static string CategoryGlobalization { get; }
    internal static string CategoryInteroperability { get; }
    internal static string CategoryLibrary { get; }
    internal static string CategoryNaming { get; }
    internal static string CategoryPerformance { get; }
    internal static string CategoryReliability { get; }
    internal static string CategoryUsage { get; }
    internal static string CategoryMobility { get; }
    internal static string CategorySecurity { get; }
    internal static string CategoryDocumentation { get; }
    internal static string CategoryMaintainability { get; }
    internal static string VersionCheckDescription { get; }
    internal static string VersionCheckMessage { get; }
    internal static string VersionCheckTitle { get; }
    private static AnalyzerUtilitiesResources();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
internal static ResourceManager get_ResourceManager();
    internal static string get_CategoryDesign();
    internal static string get_CategoryGlobalization();
    internal static string get_CategoryInteroperability();
    internal static string get_CategoryLibrary();
    internal static string get_CategoryNaming();
    internal static string get_CategoryPerformance();
    internal static string get_CategoryReliability();
    internal static string get_CategoryUsage();
    internal static string get_CategoryMobility();
    internal static string get_CategorySecurity();
    internal static string get_CategoryDocumentation();
    internal static string get_CategoryMaintainability();
    internal static string get_VersionCheckDescription();
    internal static string get_VersionCheckMessage();
    internal static string get_VersionCheckTitle();
}
internal static class Analyzer.Utilities.CommonAccessibilityUtilities : object {
    public static Accessibility Minimum(Accessibility accessibility1, Accessibility accessibility2);
}
internal static class Analyzer.Utilities.DiagnosticCategory : object {
    public static string Design;
    public static string Globalization;
    public static string Interoperability;
    public static string Mobility;
    public static string Performance;
    public static string Reliability;
    public static string Security;
    public static string Usage;
    public static string Naming;
    public static string Library;
    public static string Documentation;
    public static string Maintainability;
    public static string RoslyDiagnosticsDesign;
    public static string RoslyDiagnosticsMaintainability;
    public static string RoslyDiagnosticsPerformance;
    public static string RoslyDiagnosticsReliability;
    public static string RoslyDiagnosticsUsage;
    public static string MicrosoftCodeAnalysisCorrectness;
    public static string MicrosoftCodeAnalysisDesign;
    public static string MicrosoftCodeAnalysisDocumentation;
    public static string MicrosoftCodeAnalysisLocalization;
    public static string MicrosoftCodeAnalysisPerformance;
    public static string MicrosoftCodeAnalysisCompatibility;
    private static DiagnosticCategory();
}
internal static class Analyzer.Utilities.DiagnosticHelpers : object {
    public static DiagnosticSeverity DefaultDiagnosticSeverity;
    public static bool EnabledByDefaultIfNotBuildingVSIX;
    public static bool EnabledByDefaultOnlyIfBuildingVSIX;
    public static bool EnabledByDefaultForVsixAndNuget;
    public static bool TryConvertToUInt64(object value, SpecialType specialType, UInt64& convertedValue);
    internal static bool TryGetEnumMemberValues(INamedTypeSymbol enumType, IList`1& values);
    public static string GetMemberName(ISymbol symbol);
}
public enum Analyzer.Utilities.DisposeMethodKind : Enum {
    public int value__;
    public static DisposeMethodKind None;
    public static DisposeMethodKind Dispose;
    public static DisposeMethodKind DisposeBool;
    public static DisposeMethodKind Close;
}
internal abstract class Analyzer.Utilities.DocumentChangeAction : CodeAction {
    private Func`2<CancellationToken, Task`1<Document>> _createChangedDocument;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EquivalenceKey>k__BackingField;
    public string Title { get; }
    public string EquivalenceKey { get; }
    protected DocumentChangeAction(string title, Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string equivalenceKey);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
public virtual string get_EquivalenceKey();
    protected virtual Task`1<Document> GetChangedDocumentAsync(CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.DiagnosticExtensions : object {
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.DiagnosticExtensions/<CreateDiagnostics>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<Diagnostic> CreateDiagnostics(IEnumerable`1<SyntaxNode> nodes, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxNode node, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IOperation operation, DiagnosticDescriptor rule, Object[] args);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.DiagnosticExtensions/<CreateDiagnostics>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<Diagnostic> CreateDiagnostics(IEnumerable`1<SyntaxToken> tokens, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxToken token, DiagnosticDescriptor rule, Object[] args);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.DiagnosticExtensions/<CreateDiagnostics>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<Diagnostic> CreateDiagnostics(IEnumerable`1<SyntaxNodeOrToken> nodesOrTokens, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxNodeOrToken nodeOrToken, DiagnosticDescriptor rule, Object[] args);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.DiagnosticExtensions/<CreateDiagnostics>d__7")]
[ExtensionAttribute]
public static IEnumerable`1<Diagnostic> CreateDiagnostics(IEnumerable`1<ISymbol> symbols, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(ISymbol symbol, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(Location location, DiagnosticDescriptor rule, Object[] args);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.DiagnosticExtensions/<CreateDiagnostics>d__10")]
[ExtensionAttribute]
public static IEnumerable`1<Diagnostic> CreateDiagnostics(IEnumerable`1<IEnumerable`1<Location>> setOfLocations, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IEnumerable`1<Location> locations, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IEnumerable`1<Location> locations, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IDictionaryExtensions : object {
    [ExtensionAttribute]
public static void AddKeyValueIfNotNull(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IEnumerableExtensions : object {
    private static Func`2<object, bool> s_notNullTest;
    private static IEnumerableExtensions();
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.IEnumerableExtensions/<Concat>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> source, T value);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImmutableArray`1<TSource> WhereAsArray(IEnumerable`1<TSource> source, Func`2<TSource, bool> selector);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> WhereMethodDoesNotContainAttribute(IEnumerable`1<IMethodSymbol> methods, INamedTypeSymbol attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetMethodOverloadsWithDesiredParameterAtLeadingOrTrailing(IEnumerable`1<IMethodSymbol> methods, IMethodSymbol selectedOverload, INamedTypeSymbol expectedParameterType, bool trailingOnly);
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetMethodOverloadsWithDesiredParameterAtTrailing(IEnumerable`1<IMethodSymbol> methods, IMethodSymbol selectedOverload, INamedTypeSymbol expectedTrailingParameterType);
    [ExtensionAttribute]
public static IMethodSymbol GetSingleOrDefaultMemberWithParameterInfos(IEnumerable`1<IMethodSymbol> members, ParameterInfo[] expectedParameterTypesInOrder);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsObjectEqualsOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsObjectEquals(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsStaticObjectEqualsOrReferenceEquals(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsGetHashCodeOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsToStringOverride(IMethodSymbol method);
    private static bool IsObjectMethodOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsFinalizer(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsImplementationOfInterfaceMethod(IMethodSymbol method, ITypeSymbol typeArgument, INamedTypeSymbol interfaceType, string interfaceMethodName);
    [ExtensionAttribute]
public static bool IsDisposeImplementation(IMethodSymbol method, Compilation compilation);
    [ExtensionAttribute]
public static bool IsDisposeImplementation(IMethodSymbol method, INamedTypeSymbol iDisposable);
    [ExtensionAttribute]
private static bool HasDisposeMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
public static bool HasDisposeBoolMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
private static bool HasDisposeCloseMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
public static DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method, Compilation compilation);
    [ExtensionAttribute]
public static DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method, INamedTypeSymbol iDisposable);
    [ExtensionAttribute]
public static bool IsPropertyGetter(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsIndexerGetter(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsPropertyAccessor(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsEventAccessor(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsOperator(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool HasOptionalParameters(IMethodSymbol methodSymbol);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.IMethodSymbolExtensions/<GetOverloads>d__21")]
[ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetOverloads(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsCollectionAddMethod(IMethodSymbol method, ImmutableHashSet`1<INamedTypeSymbol> iCollectionTypes);
    [ExtensionAttribute]
public static IBlockOperation GetTopmostOperationBlock(IMethodSymbol method, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLambdaOrLocalFunctionOrDelegate(IMethodSymbol method);
    [ExtensionAttribute]
public static int GetParameterIndex(IMethodSymbol methodSymbol, IParameterSymbol parameterSymbol);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions : object {
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions/<GetBaseTypesAndThis>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypesAndThis(INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool DerivesFromOrImplementsAnyConstructionOf(INamedTypeSymbol type, INamedTypeSymbol parentType);
    [ExtensionAttribute]
public static bool ImplementsOperator(INamedTypeSymbol symbol, string op);
    [ExtensionAttribute]
public static bool ImplementsEqualityOperators(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool ImplementsComparisonOperators(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool OverridesEquals(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool OverridesGetHashCode(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool HasFinalizer(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsStaticHolderType(INamedTypeSymbol symbol);
    private static bool IsQualifyingMember(ISymbol member);
    private static bool IsDisqualifyingMember(ISymbol member);
    [ExtensionAttribute]
public static IPropertySymbol GetProperty(INamedTypeSymbol namedType, string propertyName);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IOperationExtensions : object {
    [ExtensionAttribute]
public static INamedTypeSymbol GetReceiverType(IInvocationOperation invocation, Compilation compilation, bool beforeConversion, CancellationToken cancellationToken);
    private static INamedTypeSymbol GetReceiverType(SyntaxNode receiverSyntax, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool HasConstantValue(IOperation operation, string comparand, StringComparison comparison);
    [ExtensionAttribute]
public static bool HasNullConstantValue(IOperation operation);
    [ExtensionAttribute]
public static bool HasConstantValue(IOperation operation, long comparand);
    [ExtensionAttribute]
public static bool HasConstantValue(IOperation operation, ulong comparand);
    private static bool HasConstantValue(Optional`1<object> constantValue, ITypeSymbol constantValueType, ulong comparand);
    [ExtensionAttribute]
public static ITypeSymbol GetElementType(IArrayCreationOperation arrayCreation);
    [ExtensionAttribute]
public static ImmutableArray`1<IOperation> GetOperations(ImmutableArray`1<IOperation> blockOperations);
    [ExtensionAttribute]
public static bool IsOperationNoneRoot(IOperation operation);
    [ExtensionAttribute]
public static IBlockOperation GetTopmostParentBlock(IOperation operation);
    [ExtensionAttribute]
public static TOperation GetAncestor(IOperation root, OperationKind ancestorKind, Func`2<TOperation, bool> predicateOpt);
    [ExtensionAttribute]
public static IConditionalAccessOperation GetConditionalAccess(IConditionalAccessInstanceOperation operation);
    [ExtensionAttribute]
public static IOperation GetInstance(IInstanceReferenceOperation operation, bool isInsideObjectInitializer);
    [ExtensionAttribute]
public static IOperation GetCreation(IMemberInitializerOperation operation);
    [ExtensionAttribute]
public static IAnonymousObjectCreationOperation GetAnonymousObjectCreation(IPropertyReferenceOperation operation);
    [ExtensionAttribute]
public static bool IsInsideCatchClause(IOperation operation);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(IOperation operationBlock, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, OperationKind kind);
    [ExtensionAttribute]
public static bool IsConditionalOperator(IBinaryOperation binaryOperation);
    [ExtensionAttribute]
public static bool IsConditionalAndOperator(IBinaryOperation binaryOperation);
    [ExtensionAttribute]
public static bool IsConditionalOrOperator(IBinaryOperation binaryOperation);
    [ExtensionAttribute]
public static bool IsComparisonOperator(IBinaryOperation binaryOperation);
    [ExtensionAttribute]
public static ITypeSymbol GetExceptionType(IThrowOperation throwOperation);
    [ExtensionAttribute]
public static bool IsLambdaOrLocalFunctionOrDelegateInvocation(IInvocationOperation operation);
    [ExtensionAttribute]
public static bool IsLambdaOrLocalFunctionOrDelegateReference(IMethodReferenceOperation operation);
    [ExtensionAttribute]
public static InstanceReferenceKind GetInstanceReferenceKind(IOperation instance);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.ISymbolExtensions : object {
    private static SymbolDisplayFormat s_memberDisplayFormat;
    private static ISymbolExtensions();
    [ExtensionAttribute]
public static bool IsType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAccessorMethod(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsDefaultConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPublic(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsProtected(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPrivate(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsErrorType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsDestructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsIndexer(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPropertyWithBackingField(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsUserDefinedOperator(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsConversionOperator(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsExternallyVisible(ISymbol symbol);
    [ExtensionAttribute]
public static SymbolVisibility GetResultantVisibility(ISymbol symbol);
    [ExtensionAttribute]
public static bool MatchMemberDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMethodDerivedByName(IMethodSymbol method, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMethodByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchPropertyDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchFieldDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMemberByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchPropertyByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchFieldByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static string FormatMemberName(ISymbol member);
    [ExtensionAttribute]
public static bool ContainsParameterOfType(IEnumerable`1<IParameterSymbol> parameters, INamedTypeSymbol type);
    [ExtensionAttribute]
public static IEnumerable`1<IParameterSymbol> GetParametersOfType(IEnumerable`1<IParameterSymbol> parameters, INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool HasOverloadWithParameterOfType(IEnumerable`1<IMethodSymbol> overloads, IMethodSymbol self, INamedTypeSymbol type, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ISymbolExtensions/<GetParameterIndices>d__29")]
[ExtensionAttribute]
public static IEnumerable`1<int> GetParameterIndices(IMethodSymbol method, IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ParameterTypesAreSame(IMethodSymbol method1, IMethodSymbol method2, IEnumerable`1<int> parameterIndices, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsFromMscorlib(ISymbol symbol, Compilation compilation);
    [ExtensionAttribute]
public static IMethodSymbol GetMatchingOverload(IMethodSymbol method, IEnumerable`1<IMethodSymbol> overloads, int parameterIndex, INamedTypeSymbol type, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyImplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyImplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfInterfaceMember(ISymbol symbol, ISymbol interfaceMember);
    [ExtensionAttribute]
public static bool IsOverrideOrImplementationOfInterfaceMember(ISymbol symbol, ISymbol interfaceMember);
    [ExtensionAttribute]
public static ISymbol GetOverriddenMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyExplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetMemerOrLocalOrParameterType(ISymbol symbol);
    [ExtensionAttribute]
public static bool HasAttribute(ISymbol symbol, INamedTypeSymbol attribute);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.ITypeSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsPrimitiveType(ITypeSymbol type);
    [ExtensionAttribute]
public static bool Inherits(ITypeSymbol type, ITypeSymbol possibleBase);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ITypeSymbolExtensions/<GetBaseTypes>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypes(ITypeSymbol type);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ITypeSymbolExtensions/<GetBaseTypesAndThis>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type);
    [ExtensionAttribute]
public static bool DerivesFrom(ITypeSymbol symbol, ITypeSymbol candidateBaseType, bool baseTypesOnly, bool checkTypeParameterConstraints);
    [ExtensionAttribute]
public static bool ImplementsIDisposable(ITypeSymbol type, INamedTypeSymbol iDisposable);
    [ExtensionAttribute]
public static bool IsDisposable(ITypeSymbol type, INamedTypeSymbol iDisposable);
    [ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetApplicableAttributes(INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool IsAttribute(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool HasValueCopySemantics(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsNonNullableValueType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsNullableValueType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsReferenceTypeOrNullableValueType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static Accessibility DetermineMinimalAccessibility(ITypeSymbol typeSymbol);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.ObjectExtensions : object {
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TBaseType, TResult> defaultFunc);
}
public class Analyzer.Utilities.Extensions.ParameterInfo : object {
    [CompilerGeneratedAttribute]
private int <ArrayRank>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ParameterType>k__BackingField;
    public int ArrayRank { get; private set; }
    public bool IsArray { get; private set; }
    public bool IsParams { get; private set; }
    public INamedTypeSymbol ParameterType { get; private set; }
    private ParameterInfo(INamedTypeSymbol type, bool isArray, int arrayRank, bool isParams);
    [CompilerGeneratedAttribute]
public int get_ArrayRank();
    [CompilerGeneratedAttribute]
private void set_ArrayRank(int value);
    [CompilerGeneratedAttribute]
public bool get_IsArray();
    [CompilerGeneratedAttribute]
private void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParams();
    [CompilerGeneratedAttribute]
private void set_IsParams(bool value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_ParameterType();
    [CompilerGeneratedAttribute]
private void set_ParameterType(INamedTypeSymbol value);
    public static ParameterInfo GetParameterInfo(INamedTypeSymbol type, bool isArray, int arrayRank, bool isParams);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static bool IsPlural(string word);
    [ExtensionAttribute]
public static bool HasSuffix(string str, string suffix);
    [ExtensionAttribute]
public static string WithoutSuffix(string str, string suffix);
}
internal enum Analyzer.Utilities.Extensions.SymbolVisibility : Enum {
    public int value__;
    public static SymbolVisibility Public;
    public static SymbolVisibility Internal;
    public static SymbolVisibility Private;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.SymbolVisibilityExtensions : object {
    [ExtensionAttribute]
public static bool IsAtLeastAsVisibleAs(SymbolVisibility typeVisibility, SymbolVisibility comparisonVisibility);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.SyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static ISymbol GetDeclaredOrReferencedSymbol(SyntaxNode node, SemanticModel model);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.UriExtensions : object {
    private static ImmutableHashSet`1<string> s_uriWords;
    private static UriExtensions();
    [ExtensionAttribute]
public static bool ParameterNamesContainUriWordSubstring(IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool SymbolNameContainsUriWordSubstring(ISymbol symbol, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.UriExtensions/<GetParametersThatContainUriWords>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<IParameterSymbol> GetParametersThatContainUriWords(IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool SymbolNameContainsUriWords(ISymbol symbol, CancellationToken cancellationToken);
}
internal static class Analyzer.Utilities.HashUtilities : object {
    internal static int Combine(int newKey, int currentKey);
}
public enum Analyzer.Utilities.InstanceReferenceKind : Enum {
    public int value__;
    public static InstanceReferenceKind None;
    public static InstanceReferenceKind This;
    public static InstanceReferenceKind Base;
    public static InstanceReferenceKind MyClass;
    public static InstanceReferenceKind Creation;
}
internal abstract class Analyzer.Utilities.SolutionChangeAction : CodeAction {
    private Func`2<CancellationToken, Task`1<Solution>> _createChangedSolution;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EquivalenceKey>k__BackingField;
    public string Title { get; }
    public string EquivalenceKey { get; }
    protected SolutionChangeAction(string title, Func`2<CancellationToken, Task`1<Solution>> createChangedSolution, string equivalenceKey);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
public virtual string get_EquivalenceKey();
    protected virtual Task`1<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken);
}
internal static class Analyzer.Utilities.SymbolDisplayFormats : object {
    public static SymbolDisplayFormat ShortSymbolDisplayFormat;
    private static SymbolDisplayFormats();
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.SyntaxGeneratorExtensions : object {
    private static string LeftIdentifierName;
    private static string RightIdentifierName;
    private static string ReferenceEqualsMethodName;
    private static string EqualsMethodName;
    private static string CompareToMethodName;
    private static string SystemNotImplementedExceptionTypeName;
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorEqualityDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorInequalityDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorLessThanDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorLessThanOrEqualDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorGreaterThanDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorGreaterThanOrEqualDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
private static SyntaxNode ComparisonOperatorDeclaration(SyntaxGenerator generator, OperatorKind operatorKind, INamedTypeSymbol containingType, SyntaxNode[] statements);
    [ExtensionAttribute]
public static SyntaxNode DefaultEqualsOverrideDeclaration(SyntaxGenerator generator, Compilation compilation, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode DefaultGetHashCodeOverrideDeclaration(SyntaxGenerator generator, Compilation compilation);
    [IteratorStateMachineAttribute("Analyzer.Utilities.SyntaxGeneratorExtensions/<DefaultMethodBody>d__15")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> DefaultMethodBody(SyntaxGenerator generator, Compilation compilation);
    [ExtensionAttribute]
public static SyntaxNode DefaultMethodStatement(SyntaxGenerator generator, Compilation compilation);
}
internal static class Analyzer.Utilities.WellKnownTypes : object {
    public static INamedTypeSymbol ICollection(Compilation compilation);
    public static INamedTypeSymbol GenericICollection(Compilation compilation);
    public static INamedTypeSymbol GenericIReadOnlyCollection(Compilation compilation);
    public static INamedTypeSymbol IEnumerable(Compilation compilation);
    public static INamedTypeSymbol IEnumerator(Compilation compilation);
    public static INamedTypeSymbol GenericIEnumerable(Compilation compilation);
    public static INamedTypeSymbol GenericIEnumerator(Compilation compilation);
    public static INamedTypeSymbol IList(Compilation compilation);
    public static INamedTypeSymbol GenericIList(Compilation compilation);
    public static INamedTypeSymbol Array(Compilation compilation);
    public static INamedTypeSymbol FlagsAttribute(Compilation compilation);
    public static INamedTypeSymbol StringComparison(Compilation compilation);
    public static INamedTypeSymbol CharSet(Compilation compilation);
    public static INamedTypeSymbol DllImportAttribute(Compilation compilation);
    public static INamedTypeSymbol MarshalAsAttribute(Compilation compilation);
    public static INamedTypeSymbol StringBuilder(Compilation compilation);
    public static INamedTypeSymbol UnmanagedType(Compilation compilation);
    public static INamedTypeSymbol MarshalByRefObject(Compilation compilation);
    public static INamedTypeSymbol ExecutionEngineException(Compilation compilation);
    public static INamedTypeSymbol OutOfMemoryException(Compilation compilation);
    public static INamedTypeSymbol StackOverflowException(Compilation compilation);
    public static INamedTypeSymbol MemberInfo(Compilation compilation);
    public static INamedTypeSymbol ParameterInfo(Compilation compilation);
    public static INamedTypeSymbol Thread(Compilation compilation);
    public static INamedTypeSymbol Task(Compilation compilation);
    public static INamedTypeSymbol WebMethodAttribute(Compilation compilation);
    public static INamedTypeSymbol WebUIControl(Compilation compilation);
    public static INamedTypeSymbol WebUILiteralControl(Compilation compilation);
    public static INamedTypeSymbol WinFormsUIControl(Compilation compilation);
    public static INamedTypeSymbol NotImplementedException(Compilation compilation);
    public static INamedTypeSymbol IDisposable(Compilation compilation);
    public static INamedTypeSymbol ISerializable(Compilation compilation);
    public static INamedTypeSymbol SerializationInfo(Compilation compilation);
    public static INamedTypeSymbol StreamingContext(Compilation compilation);
    public static INamedTypeSymbol OnDeserializingAttribute(Compilation compilation);
    public static INamedTypeSymbol OnDeserializedAttribute(Compilation compilation);
    public static INamedTypeSymbol OnSerializingAttribute(Compilation compilation);
    public static INamedTypeSymbol OnSerializedAttribute(Compilation compilation);
    public static INamedTypeSymbol SerializableAttribute(Compilation compilation);
    public static INamedTypeSymbol NonSerializedAttribute(Compilation compilation);
    public static INamedTypeSymbol Attribute(Compilation compilation);
    public static INamedTypeSymbol AttributeUsageAttribute(Compilation compilation);
    public static INamedTypeSymbol AssemblyVersionAttribute(Compilation compilation);
    public static INamedTypeSymbol CLSCompliantAttribute(Compilation compilation);
    public static INamedTypeSymbol ConditionalAttribute(Compilation compilation);
    public static INamedTypeSymbol IComparable(Compilation compilation);
    public static INamedTypeSymbol GenericIComparable(Compilation compilation);
    public static INamedTypeSymbol ComSourceInterfaceAttribute(Compilation compilation);
    public static INamedTypeSymbol GenericEventHandler(Compilation compilation);
    public static INamedTypeSymbol EventArgs(Compilation compilation);
    public static INamedTypeSymbol Uri(Compilation compilation);
    public static INamedTypeSymbol ComVisibleAttribute(Compilation compilation);
    public static INamedTypeSymbol NeutralResourcesLanguageAttribute(Compilation compilation);
    public static INamedTypeSymbol GeneratedCodeAttribute(Compilation compilation);
    public static INamedTypeSymbol Console(Compilation compilation);
    public static INamedTypeSymbol String(Compilation compilation);
    public static INamedTypeSymbol Object(Compilation compilation);
    public static INamedTypeSymbol Exception(Compilation compilation);
    public static INamedTypeSymbol InvalidOperationException(Compilation compilation);
    public static INamedTypeSymbol ArgumentException(Compilation compilation);
    public static INamedTypeSymbol NotSupportedException(Compilation compilation);
    public static INamedTypeSymbol KeyNotFoundException(Compilation compilation);
    public static INamedTypeSymbol GenericIEqualityComparer(Compilation compilation);
    public static INamedTypeSymbol GenericIEquatable(Compilation compilation);
    public static INamedTypeSymbol IHashCodeProvider(Compilation compilation);
    public static INamedTypeSymbol IntPtr(Compilation compilation);
    public static INamedTypeSymbol UIntPtr(Compilation compilation);
    public static INamedTypeSymbol HandleRef(Compilation compilation);
    public static INamedTypeSymbol DataMemberAttribute(Compilation compilation);
    public static INamedTypeSymbol ObsoleteAttribute(Compilation compilation);
    public static INamedTypeSymbol PureAttribute(Compilation compilation);
    public static INamedTypeSymbol MEFV1ExportAttribute(Compilation compilation);
    public static INamedTypeSymbol MEFV2ExportAttribute(Compilation compilation);
    public static INamedTypeSymbol LocalizableAttribute(Compilation compilation);
    public static INamedTypeSymbol FieldOffsetAttribute(Compilation compilation);
    public static INamedTypeSymbol StructLayoutAttribute(Compilation compilation);
    public static INamedTypeSymbol IDbCommand(Compilation compilation);
    public static INamedTypeSymbol IDataAdapter(Compilation compilation);
    public static INamedTypeSymbol TestCleanupAttribute(Compilation compilation);
    public static INamedTypeSymbol TestInitializeAttribute(Compilation compilation);
    public static INamedTypeSymbol TestMethodAttribute(Compilation compilation);
    public static INamedTypeSymbol DataTestMethodAttribute(Compilation compilation);
    public static INamedTypeSymbol ExpectedException(Compilation compilation);
    public static INamedTypeSymbol UnitTestingAssert(Compilation compilation);
    public static INamedTypeSymbol UnitTestingCollectionAssert(Compilation compilation);
    public static INamedTypeSymbol UnitTestingCollectionStringAssert(Compilation compilation);
    public static INamedTypeSymbol XunitAssert(Compilation compilation);
    public static INamedTypeSymbol XunitFact(Compilation compilation);
    public static INamedTypeSymbol XunitTheory(Compilation compilation);
    public static INamedTypeSymbol NunitAssert(Compilation compilation);
    public static INamedTypeSymbol NunitOneTimeSetUp(Compilation compilation);
    public static INamedTypeSymbol NunitOneTimeTearDown(Compilation compilation);
    public static INamedTypeSymbol NunitSetUp(Compilation compilation);
    public static INamedTypeSymbol NunitSetUpFixture(Compilation compilation);
    public static INamedTypeSymbol NunitTearDown(Compilation compilation);
    public static INamedTypeSymbol NunitTest(Compilation compilation);
    public static INamedTypeSymbol NunitTestCase(Compilation compilation);
    public static INamedTypeSymbol NunitTestCaseSource(Compilation compilation);
    public static INamedTypeSymbol NunitTheory(Compilation compilation);
    public static INamedTypeSymbol SystemDiagnosticContractsContract(Compilation compilation);
    public static INamedTypeSymbol XmlWriter(Compilation compilation);
}
internal class Analyzer.Utilities.WordParser : object {
    private static char NullChar;
    private WordParserOptions _options;
    private StringBuilder _buffer;
    private string _text;
    private string _peekedWord;
    private int _index;
    private char _prefix;
    private bool SkipMnemonics { get; }
    private bool SplitCompoundWords { get; }
    public WordParser(string text, WordParserOptions options);
    public WordParser(string text, WordParserOptions options, char prefix);
    private bool get_SkipMnemonics();
    private bool get_SplitCompoundWords();
    internal static Collection`1<string> Parse(string text, WordParserOptions options);
    internal static Collection`1<string> Parse(string text, WordParserOptions options, char prefix);
    public static bool ContainsWord(string text, WordParserOptions options, String[] words);
    internal static bool ContainsWord(string text, WordParserOptions options, char prefix, String[] words);
    public string NextWord();
    public string PeekWord();
    private string NextWordCore();
    private bool ParseNext();
    private bool TryParseWord(char c);
    private bool TryParsePrefix();
    private void ParseWholeWord();
    private void ParseInteger();
    private void ParseHex();
    private void ParseNumeric();
    private void ParseLowercase();
    private void ParseUppercase();
    private void ParseWithoutCase();
    private void ParseAllCaps();
    private void Read();
    private void Skip();
    private char Peek();
    private char Peek(int lookAhead);
    private void Unread();
    private bool IsIgnored(char c);
    private static bool IsLower(char c);
    private static bool IsUpper(char c);
    private static bool IsLetterOrDigit(char c);
    private static bool IsLetterWithoutCase(char c);
    private static bool IsDigit(char c);
    private static bool IsHexDigit(char c);
    private static bool IsIntraWordPunctuation(char c);
}
[FlagsAttribute]
internal enum Analyzer.Utilities.WordParserOptions : Enum {
    public int value__;
    public static WordParserOptions None;
    public static WordParserOptions IgnoreMnemonicsIndicators;
    public static WordParserOptions SplitCompoundWords;
}
internal static class Microsoft.CodeAnalysis.Analyzers.CodeAnalysisDiagnosticsResources : object {
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private static ResourceManager <ResourceManager>k__BackingField;
    internal static CultureInfo Culture { get; internal set; }
    internal static ResourceManager ResourceManager { get; }
    internal static string MissingAttributeMessage { get; }
    internal static string MissingDiagnosticAnalyzerAttributeTitle { get; }
    internal static string MissingDiagnosticAnalyzerAttributeDescription { get; }
    internal static string AddLanguageSupportToAnalyzerMessage { get; }
    internal static string AddLanguageSupportToAnalyzerTitle { get; }
    internal static string AddLanguageSupportToAnalyzerDescription { get; }
    internal static string ApplyDiagnosticAnalyzerAttribute_1 { get; }
    internal static string ApplyDiagnosticAnalyzerAttribute_2 { get; }
    internal static string MissingSymbolKindArgumentToRegisterActionMessage { get; }
    internal static string MissingSyntaxKindArgumentToRegisterActionMessage { get; }
    internal static string MissingOperationKindArgumentToRegisterActionMessage { get; }
    internal static string MissingKindArgumentToRegisterActionTitle { get; }
    internal static string MissingKindArgumentToRegisterActionDescription { get; }
    internal static string UnsupportedSymbolKindArgumentToRegisterActionMessage { get; }
    internal static string UnsupportedSymbolKindArgumentToRegisterActionTitle { get; }
    internal static string InvalidReportDiagnosticMessage { get; }
    internal static string InvalidReportDiagnosticTitle { get; }
    internal static string InvalidReportDiagnosticDescription { get; }
    internal static string InvalidSyntaxKindTypeArgumentMessage { get; }
    internal static string InvalidSyntaxKindTypeArgumentTitle { get; }
    internal static string InvalidSyntaxKindTypeArgumentDescription { get; }
    internal static string StartActionWithOnlyEndActionTitle { get; }
    internal static string StartActionWithNoRegisteredActionsMessage { get; }
    internal static string StartActionWithNoRegisteredActionsTitle { get; }
    internal static string StartActionWithOnlyEndActionMessage { get; }
    internal static string StatefulAnalyzerRegisterActionsDescription { get; }
    internal static string UseLocalizableStringsInDescriptorMessage { get; }
    internal static string UseLocalizableStringsInDescriptorTitle { get; }
    internal static string UseLocalizableStringsInDescriptorDescription { get; }
    internal static string ProvideHelpUriInDescriptorMessage { get; }
    internal static string ProvideHelpUriInDescriptorTitle { get; }
    internal static string ProvideHelpUriInDescriptorDescription { get; }
    internal static string DoNotStorePerCompilationDataOntoFieldsMessage { get; }
    internal static string DoNotStorePerCompilationDataOntoFieldsTitle { get; }
    internal static string DoNotStorePerCompilationDataOntoFieldsDescription { get; }
    internal static string InternalImplementationOnlyDescription { get; }
    internal static string InternalImplementationOnlyMessage { get; }
    internal static string InternalImplementationOnlyTitle { get; }
    internal static string CodeActionNeedsEquivalenceKeyDescription { get; }
    internal static string CreateCodeActionWithEquivalenceKeyMessage { get; }
    internal static string CreateCodeActionWithEquivalenceKeyTitle { get; }
    internal static string OverrideCodeActionEquivalenceKeyMessage { get; }
    internal static string OverrideCodeActionEquivalenceKeyTitle { get; }
    internal static string OverrideGetFixAllProviderTitle { get; }
    internal static string OverrideGetFixAllProviderMessage { get; }
    internal static string OverrideGetFixAllProviderDescription { get; }
    internal static string OverrideGetFixAllProviderCodeFixTitle { get; }
    internal static string DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationDescription { get; }
    internal static string DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationMessage { get; }
    internal static string DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationTitle { get; }
    internal static string DiagnosticIdMustBeAConstantTitle { get; }
    internal static string DiagnosticIdMustBeAConstantMessage { get; }
    internal static string DiagnosticIdMustBeAConstantDescription { get; }
    internal static string DiagnosticIdMustBeInSpecifiedFormatTitle { get; }
    internal static string DiagnosticIdMustBeInSpecifiedFormatMessage { get; }
    internal static string DiagnosticIdMustBeInSpecifiedFormatDescription { get; }
    internal static string UseUniqueDiagnosticIdTitle { get; }
    internal static string UseUniqueDiagnosticIdMessage { get; }
    internal static string UseUniqueDiagnosticIdDescription { get; }
    internal static string UseCategoriesFromSpecifiedRangeTitle { get; }
    internal static string UseCategoriesFromSpecifiedRangeMessage { get; }
    internal static string UseCategoriesFromSpecifiedRangeDescription { get; }
    internal static string AnalyzerCategoryAndIdRangeFileInvalidTitle { get; }
    internal static string AnalyzerCategoryAndIdRangeFileInvalidMessage { get; }
    internal static string AnalyzerCategoryAndIdRangeFileInvalidDescription { get; }
    internal static string DoNotUseTypesFromAssemblyRuleDescription { get; }
    internal static string DoNotUseTypesFromAssemblyRuleDirectMessage { get; }
    internal static string DoNotUseTypesFromAssemblyRuleIndirectMessage { get; }
    internal static string DoNotUseTypesFromAssemblyRuleTitle { get; }
    internal static string UpgradeMSBuildWorkspaceDescription { get; }
    internal static string UpgradeMSBuildWorkspaceMessage { get; }
    internal static string UpgradeMSBuildWorkspaceTitle { get; }
    private static CodeAnalysisDiagnosticsResources();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
internal static ResourceManager get_ResourceManager();
    internal static string get_MissingAttributeMessage();
    internal static string get_MissingDiagnosticAnalyzerAttributeTitle();
    internal static string get_MissingDiagnosticAnalyzerAttributeDescription();
    internal static string get_AddLanguageSupportToAnalyzerMessage();
    internal static string get_AddLanguageSupportToAnalyzerTitle();
    internal static string get_AddLanguageSupportToAnalyzerDescription();
    internal static string get_ApplyDiagnosticAnalyzerAttribute_1();
    internal static string get_ApplyDiagnosticAnalyzerAttribute_2();
    internal static string get_MissingSymbolKindArgumentToRegisterActionMessage();
    internal static string get_MissingSyntaxKindArgumentToRegisterActionMessage();
    internal static string get_MissingOperationKindArgumentToRegisterActionMessage();
    internal static string get_MissingKindArgumentToRegisterActionTitle();
    internal static string get_MissingKindArgumentToRegisterActionDescription();
    internal static string get_UnsupportedSymbolKindArgumentToRegisterActionMessage();
    internal static string get_UnsupportedSymbolKindArgumentToRegisterActionTitle();
    internal static string get_InvalidReportDiagnosticMessage();
    internal static string get_InvalidReportDiagnosticTitle();
    internal static string get_InvalidReportDiagnosticDescription();
    internal static string get_InvalidSyntaxKindTypeArgumentMessage();
    internal static string get_InvalidSyntaxKindTypeArgumentTitle();
    internal static string get_InvalidSyntaxKindTypeArgumentDescription();
    internal static string get_StartActionWithOnlyEndActionTitle();
    internal static string get_StartActionWithNoRegisteredActionsMessage();
    internal static string get_StartActionWithNoRegisteredActionsTitle();
    internal static string get_StartActionWithOnlyEndActionMessage();
    internal static string get_StatefulAnalyzerRegisterActionsDescription();
    internal static string get_UseLocalizableStringsInDescriptorMessage();
    internal static string get_UseLocalizableStringsInDescriptorTitle();
    internal static string get_UseLocalizableStringsInDescriptorDescription();
    internal static string get_ProvideHelpUriInDescriptorMessage();
    internal static string get_ProvideHelpUriInDescriptorTitle();
    internal static string get_ProvideHelpUriInDescriptorDescription();
    internal static string get_DoNotStorePerCompilationDataOntoFieldsMessage();
    internal static string get_DoNotStorePerCompilationDataOntoFieldsTitle();
    internal static string get_DoNotStorePerCompilationDataOntoFieldsDescription();
    internal static string get_InternalImplementationOnlyDescription();
    internal static string get_InternalImplementationOnlyMessage();
    internal static string get_InternalImplementationOnlyTitle();
    internal static string get_CodeActionNeedsEquivalenceKeyDescription();
    internal static string get_CreateCodeActionWithEquivalenceKeyMessage();
    internal static string get_CreateCodeActionWithEquivalenceKeyTitle();
    internal static string get_OverrideCodeActionEquivalenceKeyMessage();
    internal static string get_OverrideCodeActionEquivalenceKeyTitle();
    internal static string get_OverrideGetFixAllProviderTitle();
    internal static string get_OverrideGetFixAllProviderMessage();
    internal static string get_OverrideGetFixAllProviderDescription();
    internal static string get_OverrideGetFixAllProviderCodeFixTitle();
    internal static string get_DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationDescription();
    internal static string get_DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationMessage();
    internal static string get_DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationTitle();
    internal static string get_DiagnosticIdMustBeAConstantTitle();
    internal static string get_DiagnosticIdMustBeAConstantMessage();
    internal static string get_DiagnosticIdMustBeAConstantDescription();
    internal static string get_DiagnosticIdMustBeInSpecifiedFormatTitle();
    internal static string get_DiagnosticIdMustBeInSpecifiedFormatMessage();
    internal static string get_DiagnosticIdMustBeInSpecifiedFormatDescription();
    internal static string get_UseUniqueDiagnosticIdTitle();
    internal static string get_UseUniqueDiagnosticIdMessage();
    internal static string get_UseUniqueDiagnosticIdDescription();
    internal static string get_UseCategoriesFromSpecifiedRangeTitle();
    internal static string get_UseCategoriesFromSpecifiedRangeMessage();
    internal static string get_UseCategoriesFromSpecifiedRangeDescription();
    internal static string get_AnalyzerCategoryAndIdRangeFileInvalidTitle();
    internal static string get_AnalyzerCategoryAndIdRangeFileInvalidMessage();
    internal static string get_AnalyzerCategoryAndIdRangeFileInvalidDescription();
    internal static string get_DoNotUseTypesFromAssemblyRuleDescription();
    internal static string get_DoNotUseTypesFromAssemblyRuleDirectMessage();
    internal static string get_DoNotUseTypesFromAssemblyRuleIndirectMessage();
    internal static string get_DoNotUseTypesFromAssemblyRuleTitle();
    internal static string get_UpgradeMSBuildWorkspaceDescription();
    internal static string get_UpgradeMSBuildWorkspaceMessage();
    internal static string get_UpgradeMSBuildWorkspaceTitle();
}
internal static class Microsoft.CodeAnalysis.Analyzers.DiagnosticIds : object {
    public static string MissingDiagnosticAnalyzerAttributeRuleId;
    public static string MissingKindArgumentToRegisterActionRuleId;
    public static string UnsupportedSymbolKindArgumentRuleId;
    public static string AddLanguageSupportToAnalyzerRuleId;
    public static string InvalidReportDiagnosticRuleId;
    public static string InvalidSyntaxKindTypeArgumentRuleId;
    public static string UseLocalizableStringsInDescriptorRuleId;
    public static string DoNotStorePerCompilationDataOntoFieldsRuleId;
    public static string InternalImplementationOnlyRuleId;
    public static string CreateCodeActionWithEquivalenceKeyRuleId;
    public static string OverrideCodeActionEquivalenceKeyRuleId;
    public static string StartActionWithNoRegisteredActionsRuleId;
    public static string StartActionWithOnlyEndActionRuleId;
    public static string DoNotIgnoreReturnValueOnImmutableObjectMethodInvocation;
    public static string ProvideHelpUriInDescriptorRuleId;
    public static string OverrideGetFixAllProviderRuleId;
    public static string DiagnosticIdMustBeAConstantRuleId;
    public static string DiagnosticIdMustBeInSpecifiedFormatRuleId;
    public static string UseUniqueDiagnosticIdRuleId;
    public static string UseCategoriesFromSpecifiedRangeRuleId;
    public static string AnalyzerCategoryAndIdRangeFileInvalidRuleId;
    public static string DoNotUseTypesFromAssemblyRuleId;
    public static string UpgradeMSBuildWorkspaceRuleId;
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.Analyzers.FixAnalyzers.FixerWithFixAllAnalyzer : DiagnosticAnalyzer {
    private static string CodeActionMetadataName;
    private static string CreateMethodName;
    private static string EquivalenceKeyPropertyName;
    private static string EquivalenceKeyParameterName;
    internal static string CodeFixProviderMetadataName;
    internal static string GetFixAllProviderMethodName;
    private static LocalizableString s_localizableCreateCodeActionWithEquivalenceKeyTitle;
    private static LocalizableString s_localizableCreateCodeActionWithEquivalenceKeyMessage;
    private static LocalizableString s_localizableOverrideCodeActionEquivalenceKeyTitle;
    private static LocalizableString s_localizableOverrideCodeActionEquivalenceKeyMessage;
    private static LocalizableString s_localizableOverrideGetFixAllProviderTitle;
    private static LocalizableString s_localizableOverrideGetFixAllProviderMessage;
    private static LocalizableString s_localizableCodeActionNeedsEquivalenceKeyDescription;
    private static LocalizableString s_localizableOverrideGetFixAllProviderDescription;
    internal static DiagnosticDescriptor CreateCodeActionEquivalenceKeyRule;
    internal static DiagnosticDescriptor OverrideCodeActionEquivalenceKeyRule;
    internal static DiagnosticDescriptor OverrideGetFixAllProviderRule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FixerWithFixAllAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void CreateAnalyzerWithinCompilation(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.Analyzers.InternalImplementationOnlyAnalyzer : DiagnosticAnalyzer {
    private static string InternalImplementationOnlyAttributeName;
    private static string InternalImplementationOnlyAttributeFullName;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessageFormat;
    private static LocalizableString s_localizableDescription;
    public static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InternalImplementationOnlyAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context);
}
public abstract class Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.DiagnosticAnalyzerApiUsageAnalyzer`1 : DiagnosticAnalyzer {
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessage;
    private static LocalizableString s_localizableIndirectMessage;
    private static LocalizableString s_localizableDescription;
    private static string CodeActionMetadataName;
    private static ImmutableArray`1<string> s_WorkspaceAssemblyNames;
    public static DiagnosticDescriptor DoNotUseTypesFromAssemblyDirectRule;
    public static DiagnosticDescriptor DoNotUseTypesFromAssemblyIndirectRule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DiagnosticAnalyzerApiUsageAnalyzer`1();
    protected abstract virtual bool IsNamedTypeDeclarationBlock(SyntaxNode syntax);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private ImmutableHashSet`1<INamedTypeSymbol> GetUsedNamedTypes(INamedTypeSymbol namedType, Compilation compilation, CancellationToken cancellationToken, Boolean& hasAccessToTypeFromWorkspaceAssemblies);
    private static void AddUsedNamedTypeCore(ITypeSymbol typeOpt, Builder<INamedTypeSymbol> builder, Boolean& hasAccessToTypeFromWorkspaceAssemblies);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_0(CompilationStartAnalysisContext compilationStartContext);
    [CompilerGeneratedAttribute]
private bool <GetUsedNamedTypes>b__12_0(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.DiagnosticAnalyzerAttributeAnalyzer : DiagnosticAnalyzerCorrectnessAnalyzer {
    private static LocalizableString s_localizableTitleMissingAttribute;
    private static LocalizableString s_localizableMessageMissingAttribute;
    private static LocalizableString s_localizableDescriptionMissingAttribute;
    public static DiagnosticDescriptor MissingDiagnosticAnalyzerAttributeRule;
    private static LocalizableString s_localizableTitleAddLanguageSupportToAnalyzer;
    private static LocalizableString s_localizableMessageAddLanguageSupportToAnalyzer;
    private static LocalizableString s_localizableDescriptionAddLanguageSupportToAnalyzer;
    public static DiagnosticDescriptor AddLanguageSupportToAnalyzerRule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DiagnosticAnalyzerAttributeAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual DiagnosticAnalyzerSymbolAnalyzer GetDiagnosticAnalyzerSymbolAnalyzer(CompilationStartAnalysisContext compilationContext, INamedTypeSymbol diagnosticAnalyzer, INamedTypeSymbol diagnosticAnalyzerAttribute);
    private static void CheckLanguage(TypedConstant argument, Boolean& supportsCSharp, Boolean& supportsVB);
}
public abstract class Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.DiagnosticAnalyzerCorrectnessAnalyzer : DiagnosticAnalyzer {
    internal static string DiagnosticAnalyzerTypeFullName;
    internal static string DiagnosticAnalyzerAttributeFullName;
    internal static string DiagnosticFullName;
    internal static string DiagnosticDescriptorFullName;
    internal static string LocalizableStringFullName;
    internal static string AnalysisContextFullName;
    internal static string CompilationStartAnalysisContextFullName;
    internal static string CompilationEndAnalysisContextFullName;
    internal static string SemanticModelAnalysisContextFullName;
    internal static string SymbolAnalysisContextFullName;
    internal static string SyntaxNodeAnalysisContextFullName;
    internal static string SyntaxTreeAnalysisContextFullName;
    internal static string CodeBlockStartAnalysisContextFullName;
    internal static string CodeBlockAnalysisContextFullName;
    internal static string OperationBlockStartAnalysisContextFullName;
    internal static string OperationBlockAnalysisContextFullName;
    internal static string OperationAnalysisContextFullName;
    internal static string SymbolKindFullName;
    internal static string RegisterSyntaxNodeActionName;
    internal static string RegisterSymbolActionName;
    internal static string RegisterCodeBlockStartActionName;
    internal static string RegisterCodeBlockEndActionName;
    internal static string RegisterCodeBlockActionName;
    internal static string RegisterOperationBlockStartActionName;
    internal static string RegisterOperationBlockEndActionName;
    internal static string RegisterOperationBlockActionName;
    internal static string RegisterOperationActionName;
    internal static string RegisterCompilationStartActionName;
    internal static string RegisterCompilationEndActionName;
    internal static string RegisterCompilationActionName;
    internal static string ReportDiagnosticName;
    internal static string SupportedDiagnosticsName;
    internal static string TLanguageKindEnumName;
    private static DiagnosticAnalyzerCorrectnessAnalyzer();
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual DiagnosticAnalyzerSymbolAnalyzer GetDiagnosticAnalyzerSymbolAnalyzer(CompilationStartAnalysisContext compilationContext, INamedTypeSymbol diagnosticAnalyzer, INamedTypeSymbol diagnosticAnalyzerAttribute);
    [CompilerGeneratedAttribute]
private void <Initialize>b__33_0(CompilationStartAnalysisContext compilationContext);
}
public abstract class Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.DiagnosticAnalyzerFieldsAnalyzer`4 : DiagnosticAnalyzerCorrectnessAnalyzer {
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessage;
    private static LocalizableString s_localizableDescription;
    private static string s_compilationTypeFullName;
    private static string s_symbolTypeFullName;
    private static string s_operationTypeFullName;
    public static DiagnosticDescriptor DoNotStorePerCompilationDataOntoFieldsRule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DiagnosticAnalyzerFieldsAnalyzer`4();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual DiagnosticAnalyzerSymbolAnalyzer GetDiagnosticAnalyzerSymbolAnalyzer(CompilationStartAnalysisContext compilationContext, INamedTypeSymbol diagnosticAnalyzer, INamedTypeSymbol diagnosticAnalyzerAttribute);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.DiagnosticDescriptorCreationAnalyzer : DiagnosticAnalyzer {
    private static string HelpLinkUriParameterName;
    private static string CategoryParameterName;
    private static string DiagnosticIdParameterName;
    private static string DiagnosticCategoryAndIdRangeFile;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`3<string, int, int> s_defaultAllowedIdsInfo;
    private static LocalizableString s_localizableUseLocalizableStringsTitle;
    private static LocalizableString s_localizableUseLocalizableStringsMessage;
    private static LocalizableString s_localizableUseLocalizableStringsDescription;
    private static LocalizableString s_localizableProvideHelpUriTitle;
    private static LocalizableString s_localizableProvideHelpUriMessage;
    private static LocalizableString s_localizableProvideHelpUriDescription;
    private static LocalizableString s_localizableDiagnosticIdMustBeAConstantTitle;
    private static LocalizableString s_localizableDiagnosticIdMustBeAConstantMessage;
    private static LocalizableString s_localizableDiagnosticIdMustBeAConstantDescription;
    private static LocalizableString s_localizableDiagnosticIdMustBeInSpecifiedFormatTitle;
    private static LocalizableString s_localizableDiagnosticIdMustBeInSpecifiedFormatMessage;
    private static LocalizableString s_localizableDiagnosticIdMustBeInSpecifiedFormatDescription;
    private static LocalizableString s_localizableUseUniqueDiagnosticIdTitle;
    private static LocalizableString s_localizableUseUniqueDiagnosticIdMessage;
    private static LocalizableString s_localizableUseUniqueDiagnosticIdDescription;
    private static LocalizableString s_localizableUseCategoriesFromSpecifiedRangeTitle;
    private static LocalizableString s_localizableUseCategoriesFromSpecifiedRangeMessage;
    private static LocalizableString s_localizableUseCategoriesFromSpecifiedRangeDescription;
    private static LocalizableString s_localizableAnalyzerCategoryAndIdRangeFileInvalidTitle;
    private static LocalizableString s_localizableAnalyzerCategoryAndIdRangeFileInvalidMessage;
    private static LocalizableString s_localizableAnalyzerCategoryAndIdRangeFileInvalidDescription;
    public static DiagnosticDescriptor UseLocalizableStringsInDescriptorRule;
    public static DiagnosticDescriptor ProvideHelpUriInDescriptorRule;
    public static DiagnosticDescriptor DiagnosticIdMustBeAConstantRule;
    public static DiagnosticDescriptor DiagnosticIdMustBeInSpecifiedFormatRule;
    public static DiagnosticDescriptor UseUniqueDiagnosticIdRule;
    public static DiagnosticDescriptor UseCategoriesFromSpecifiedRangeRule;
    public static DiagnosticDescriptor AnalyzerCategoryAndIdRangeFileInvalidRule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DiagnosticDescriptorCreationAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeTitle(OperationAnalysisContext operationAnalysisContext, IObjectCreationOperation objectCreation);
    private static void AnalyzeHelpLinkUri(OperationAnalysisContext operationAnalysisContext, IObjectCreationOperation objectCreation);
    private static bool TryAnalyzeCategory(OperationAnalysisContext operationAnalysisContext, IObjectCreationOperation objectCreation, AdditionalText additionalText, ImmutableDictionary`2<string, ImmutableArray`1<ValueTuple`3<string, int, int>>> categoryAndAllowedIdsInfoMap, String& category, ImmutableArray`1& allowedIdsInfoList);
    private static void AnalyzeRuleId(OperationAnalysisContext operationAnalysisContext, IObjectCreationOperation objectCreation, AdditionalText additionalTextOpt, string categoryOpt, ImmutableArray`1<ValueTuple`3<string, int, int>> allowedIdsInfoListOpt, ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, ConcurrentBag`1<Location>>> idToAnalyzerMap);
    private static bool TryGetCategoryAndAllowedIdsMap(ImmutableArray`1<AdditionalText> additionalFiles, CancellationToken cancellationToken, AdditionalText& additionalText, ImmutableDictionary`2& categoryAndAllowedIdsMap, List`1& invalidFileDiagnostics);
    private static AdditionalText TryGetCategoryAndAllowedIdsInfoFile(ImmutableArray`1<AdditionalText> additionalFiles, CancellationToken cancellationToken);
    private static bool TryParseCategoryAndAllowedIdsInfoFile(AdditionalText additionalText, CancellationToken cancellationToken, ImmutableDictionary`2& categoryAndAllowedIdsInfoMap, List`1& invalidFileDiagnostics);
    private static bool TryParseIdRangeEntry(string entry, String& prefix, Int32& suffix);
    [CompilerGeneratedAttribute]
internal static string <AnalyzeRuleId>g__GetAnalyzerName|39_0(INamedTypeSymbol a);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeRuleId>g__ShouldValidateRange|39_5(ValueTuple`3<string, int, int> range);
}
public abstract class Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.Fixers.ApplyDiagnosticAnalyzerAttributeFix : CodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.Fixers.ApplyDiagnosticAnalyzerAttributeFix/<RegisterCodeFixesAsync>d__2")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual SyntaxNode ParseExpression(string expression);
    private void AddFix(string codeFixTitle, CodeFixContext context, SyntaxNode root, SyntaxNode classDecl, SyntaxGenerator generator, String[] languages);
    private Task`1<Document> GetFix(Document document, SyntaxNode root, SyntaxNode classDecl, SyntaxGenerator generator, String[] languages);
    public sealed virtual FixAllProvider GetFixAllProvider();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.Fixers.FixerWithFixAllFix : CodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.Fixers.FixerWithFixAllFix/<RegisterCodeFixesAsync>d__3")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.Fixers.FixerWithFixAllFix/<AddMethodAsync>d__4")]
private static Task`1<Document> AddMethodAsync(Document document, SyntaxNode classDecl, CancellationToken cancellationToken);
}
public abstract class Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.RegisterActionAnalyzer`4 : DiagnosticAnalyzerCorrectnessAnalyzer {
    private static LocalizableString s_localizableTitleMissingKindArgument;
    private static LocalizableString s_localizableMessageMissingSymbolKindArgument;
    private static LocalizableString s_localizableMessageMissingSyntaxKindArgument;
    private static LocalizableString s_localizableMessageMissingOperationKindArgument;
    private static LocalizableString s_localizableDescriptionMissingKindArgument;
    public static DiagnosticDescriptor MissingSymbolKindArgumentRule;
    public static DiagnosticDescriptor MissingSyntaxKindArgumentRule;
    public static DiagnosticDescriptor MissingOperationKindArgumentRule;
    private static LocalizableString s_localizableTitleUnsupportedSymbolKindArgument;
    private static LocalizableString s_localizableMessageUnsupportedSymbolKindArgument;
    public static DiagnosticDescriptor UnsupportedSymbolKindArgumentRule;
    private static LocalizableString s_localizableTitleInvalidSyntaxKindTypeArgument;
    private static LocalizableString s_localizableMessageInvalidSyntaxKindTypeArgument;
    private static LocalizableString s_localizableDescriptionInvalidSyntaxKindTypeArgument;
    public static DiagnosticDescriptor InvalidSyntaxKindTypeArgumentRule;
    private static LocalizableString s_localizableDescriptionStatefulAnalyzerRegisterActionsDescription;
    private static LocalizableString s_localizableTitleStartActionWithNoRegisteredActions;
    private static LocalizableString s_localizableMessageStartActionWithNoRegisteredActions;
    public static DiagnosticDescriptor StartActionWithNoRegisteredActionsRule;
    private static LocalizableString s_localizableTitleStartActionWithOnlyEndAction;
    private static LocalizableString s_localizableMessageStartActionWithOnlyEndAction;
    public static DiagnosticDescriptor StartActionWithOnlyEndActionRule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RegisterActionAnalyzer`4();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual DiagnosticAnalyzerSymbolAnalyzer GetDiagnosticAnalyzerSymbolAnalyzer(CompilationStartAnalysisContext compilationContext, INamedTypeSymbol diagnosticAnalyzer, INamedTypeSymbol diagnosticAnalyzerAttribute);
    protected abstract virtual RegisterActionCodeBlockAnalyzer<TClassDeclarationSyntax, TInvocationExpressionSyntax, TArgumentSyntax, TLanguageKindEnum> GetCodeBlockAnalyzer(Compilation compilation, INamedTypeSymbol analysisContext, INamedTypeSymbol compilationStartAnalysisContext, INamedTypeSymbol codeBlockStartAnalysisContext, INamedTypeSymbol operationBlockStartAnalysisContext, INamedTypeSymbol symbolKind);
}
public abstract class Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.ReportDiagnosticAnalyzer`4 : DiagnosticAnalyzerCorrectnessAnalyzer {
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessage;
    private static LocalizableString s_localizableDescription;
    public static DiagnosticDescriptor InvalidReportDiagnosticRule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ReportDiagnosticAnalyzer`4();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual DiagnosticAnalyzerSymbolAnalyzer GetDiagnosticAnalyzerSymbolAnalyzer(CompilationStartAnalysisContext compilationContext, INamedTypeSymbol diagnosticAnalyzer, INamedTypeSymbol diagnosticAnalyzerAttribute);
    protected abstract virtual ReportDiagnosticCompilationAnalyzer<TClassDeclarationSyntax, TInvocationExpressionSyntax, TIdentifierNameSyntax, TVariableDeclaratorSyntax> GetAnalyzer(ImmutableHashSet`1<INamedTypeSymbol> contextTypes, INamedTypeSymbol diagnosticType, INamedTypeSymbol diagnosticDescriptorType, INamedTypeSymbol diagnosticAnalyzer, INamedTypeSymbol diagnosticAnalyzerAttribute);
}
public abstract class Microsoft.CodeAnalysis.Analyzers.UpgradeMSBuildWorkspaceAnalyzer : DiagnosticAnalyzer {
    private static string WorkspacesDesktop;
    private static string WorkspacesMSBuild;
    private static string MSBuildWorkspaceFullName;
    protected static string MSBuildWorkspace;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessage;
    private static LocalizableString s_localizableDescription;
    public static DiagnosticDescriptor UpgradeMSBuildWorkspaceDiagnosticRule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private bool _performAssemblyChecks;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected UpgradeMSBuildWorkspaceAnalyzer(bool performAssemblyChecks);
    private static UpgradeMSBuildWorkspaceAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual void RegisterIdentifierAnalysis(CompilationStartAnalysisContext context);
    protected abstract virtual void RegisterIdentifierAnalysis(AnalysisContext context);
    private void AnalyzeAssemblyReferences(CompilationStartAnalysisContext context);
}
